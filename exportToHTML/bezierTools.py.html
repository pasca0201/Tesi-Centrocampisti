<html>
<head>
<title>bezierTools.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #5f826b; font-style: italic;}
.s3 { color: #cf8e6d;}
.s4 { color: #bcbec4;}
.s5 { color: #2aacb8;}
.s6 { color: #6aab73;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
bezierTools.py</font>
</center></td></tr></table>
<pre><span class="s0"># -*- coding: utf-8 -*-</span>
<span class="s2">&quot;&quot;&quot;fontTools.misc.bezierTools.py -- tools for working with Bezier path segments. 
&quot;&quot;&quot;</span>

<span class="s3">from </span><span class="s1">fontTools</span><span class="s4">.</span><span class="s1">misc</span><span class="s4">.</span><span class="s1">arrayTools </span><span class="s3">import </span><span class="s1">calcBounds</span><span class="s4">, </span><span class="s1">sectRect</span><span class="s4">, </span><span class="s1">rectArea</span>
<span class="s3">from </span><span class="s1">fontTools</span><span class="s4">.</span><span class="s1">misc</span><span class="s4">.</span><span class="s1">transform </span><span class="s3">import </span><span class="s1">Identity</span>
<span class="s3">import </span><span class="s1">math</span>
<span class="s3">from </span><span class="s1">collections </span><span class="s3">import </span><span class="s1">namedtuple</span>

<span class="s3">try</span><span class="s4">:</span>
    <span class="s3">import </span><span class="s1">cython</span>

    <span class="s1">COMPILED </span><span class="s4">= </span><span class="s1">cython</span><span class="s4">.</span><span class="s1">compiled</span>
<span class="s3">except </span><span class="s4">(</span><span class="s1">AttributeError</span><span class="s4">, </span><span class="s1">ImportError</span><span class="s4">):</span>
    <span class="s0"># if cython not installed, use mock module with no-op decorators and types</span>
    <span class="s3">from </span><span class="s1">fontTools</span><span class="s4">.</span><span class="s1">misc </span><span class="s3">import </span><span class="s1">cython</span>

    <span class="s1">COMPILED </span><span class="s4">= </span><span class="s3">False</span>


<span class="s1">EPSILON </span><span class="s4">= </span><span class="s5">1e-9</span>


<span class="s1">Intersection </span><span class="s4">= </span><span class="s1">namedtuple</span><span class="s4">(</span><span class="s6">&quot;Intersection&quot;</span><span class="s4">, [</span><span class="s6">&quot;pt&quot;</span><span class="s4">, </span><span class="s6">&quot;t1&quot;</span><span class="s4">, </span><span class="s6">&quot;t2&quot;</span><span class="s4">])</span>


<span class="s1">__all__ </span><span class="s4">= [</span>
    <span class="s6">&quot;approximateCubicArcLength&quot;</span><span class="s4">,</span>
    <span class="s6">&quot;approximateCubicArcLengthC&quot;</span><span class="s4">,</span>
    <span class="s6">&quot;approximateQuadraticArcLength&quot;</span><span class="s4">,</span>
    <span class="s6">&quot;approximateQuadraticArcLengthC&quot;</span><span class="s4">,</span>
    <span class="s6">&quot;calcCubicArcLength&quot;</span><span class="s4">,</span>
    <span class="s6">&quot;calcCubicArcLengthC&quot;</span><span class="s4">,</span>
    <span class="s6">&quot;calcQuadraticArcLength&quot;</span><span class="s4">,</span>
    <span class="s6">&quot;calcQuadraticArcLengthC&quot;</span><span class="s4">,</span>
    <span class="s6">&quot;calcCubicBounds&quot;</span><span class="s4">,</span>
    <span class="s6">&quot;calcQuadraticBounds&quot;</span><span class="s4">,</span>
    <span class="s6">&quot;splitLine&quot;</span><span class="s4">,</span>
    <span class="s6">&quot;splitQuadratic&quot;</span><span class="s4">,</span>
    <span class="s6">&quot;splitCubic&quot;</span><span class="s4">,</span>
    <span class="s6">&quot;splitQuadraticAtT&quot;</span><span class="s4">,</span>
    <span class="s6">&quot;splitCubicAtT&quot;</span><span class="s4">,</span>
    <span class="s6">&quot;splitCubicAtTC&quot;</span><span class="s4">,</span>
    <span class="s6">&quot;splitCubicIntoTwoAtTC&quot;</span><span class="s4">,</span>
    <span class="s6">&quot;solveQuadratic&quot;</span><span class="s4">,</span>
    <span class="s6">&quot;solveCubic&quot;</span><span class="s4">,</span>
    <span class="s6">&quot;quadraticPointAtT&quot;</span><span class="s4">,</span>
    <span class="s6">&quot;cubicPointAtT&quot;</span><span class="s4">,</span>
    <span class="s6">&quot;cubicPointAtTC&quot;</span><span class="s4">,</span>
    <span class="s6">&quot;linePointAtT&quot;</span><span class="s4">,</span>
    <span class="s6">&quot;segmentPointAtT&quot;</span><span class="s4">,</span>
    <span class="s6">&quot;lineLineIntersections&quot;</span><span class="s4">,</span>
    <span class="s6">&quot;curveLineIntersections&quot;</span><span class="s4">,</span>
    <span class="s6">&quot;curveCurveIntersections&quot;</span><span class="s4">,</span>
    <span class="s6">&quot;segmentSegmentIntersections&quot;</span><span class="s4">,</span>
<span class="s4">]</span>


<span class="s3">def </span><span class="s1">calcCubicArcLength</span><span class="s4">(</span><span class="s1">pt1</span><span class="s4">, </span><span class="s1">pt2</span><span class="s4">, </span><span class="s1">pt3</span><span class="s4">, </span><span class="s1">pt4</span><span class="s4">, </span><span class="s1">tolerance</span><span class="s4">=</span><span class="s5">0.005</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Calculates the arc length for a cubic Bezier segment. 
 
    Whereas :func:`approximateCubicArcLength` approximates the length, this 
    function calculates it by &quot;measuring&quot;, recursively dividing the curve 
    until the divided segments are shorter than ``tolerance``. 
 
    Args: 
        pt1,pt2,pt3,pt4: Control points of the Bezier as 2D tuples. 
        tolerance: Controls the precision of the calcuation. 
 
    Returns: 
        Arc length value. 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">calcCubicArcLengthC</span><span class="s4">(</span>
        <span class="s1">complex</span><span class="s4">(*</span><span class="s1">pt1</span><span class="s4">), </span><span class="s1">complex</span><span class="s4">(*</span><span class="s1">pt2</span><span class="s4">), </span><span class="s1">complex</span><span class="s4">(*</span><span class="s1">pt3</span><span class="s4">), </span><span class="s1">complex</span><span class="s4">(*</span><span class="s1">pt4</span><span class="s4">), </span><span class="s1">tolerance</span>
    <span class="s4">)</span>


<span class="s3">def </span><span class="s1">_split_cubic_into_two</span><span class="s4">(</span><span class="s1">p0</span><span class="s4">, </span><span class="s1">p1</span><span class="s4">, </span><span class="s1">p2</span><span class="s4">, </span><span class="s1">p3</span><span class="s4">):</span>
    <span class="s1">mid </span><span class="s4">= (</span><span class="s1">p0 </span><span class="s4">+ </span><span class="s5">3 </span><span class="s4">* (</span><span class="s1">p1 </span><span class="s4">+ </span><span class="s1">p2</span><span class="s4">) + </span><span class="s1">p3</span><span class="s4">) * </span><span class="s5">0.125</span>
    <span class="s1">deriv3 </span><span class="s4">= (</span><span class="s1">p3 </span><span class="s4">+ </span><span class="s1">p2 </span><span class="s4">- </span><span class="s1">p1 </span><span class="s4">- </span><span class="s1">p0</span><span class="s4">) * </span><span class="s5">0.125</span>
    <span class="s3">return </span><span class="s4">(</span>
        <span class="s4">(</span><span class="s1">p0</span><span class="s4">, (</span><span class="s1">p0 </span><span class="s4">+ </span><span class="s1">p1</span><span class="s4">) * </span><span class="s5">0.5</span><span class="s4">, </span><span class="s1">mid </span><span class="s4">- </span><span class="s1">deriv3</span><span class="s4">, </span><span class="s1">mid</span><span class="s4">),</span>
        <span class="s4">(</span><span class="s1">mid</span><span class="s4">, </span><span class="s1">mid </span><span class="s4">+ </span><span class="s1">deriv3</span><span class="s4">, (</span><span class="s1">p2 </span><span class="s4">+ </span><span class="s1">p3</span><span class="s4">) * </span><span class="s5">0.5</span><span class="s4">, </span><span class="s1">p3</span><span class="s4">),</span>
    <span class="s4">)</span>


<span class="s4">@</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">returns</span><span class="s4">(</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">double</span><span class="s4">)</span>
<span class="s4">@</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">locals</span><span class="s4">(</span>
    <span class="s1">p0</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">complex</span><span class="s4">,</span>
    <span class="s1">p1</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">complex</span><span class="s4">,</span>
    <span class="s1">p2</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">complex</span><span class="s4">,</span>
    <span class="s1">p3</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">complex</span><span class="s4">,</span>
<span class="s4">)</span>
<span class="s4">@</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">locals</span><span class="s4">(</span><span class="s1">mult</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">double</span><span class="s4">, </span><span class="s1">arch</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">double</span><span class="s4">, </span><span class="s1">box</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">double</span><span class="s4">)</span>
<span class="s3">def </span><span class="s1">_calcCubicArcLengthCRecurse</span><span class="s4">(</span><span class="s1">mult</span><span class="s4">, </span><span class="s1">p0</span><span class="s4">, </span><span class="s1">p1</span><span class="s4">, </span><span class="s1">p2</span><span class="s4">, </span><span class="s1">p3</span><span class="s4">):</span>
    <span class="s1">arch </span><span class="s4">= </span><span class="s1">abs</span><span class="s4">(</span><span class="s1">p0 </span><span class="s4">- </span><span class="s1">p3</span><span class="s4">)</span>
    <span class="s1">box </span><span class="s4">= </span><span class="s1">abs</span><span class="s4">(</span><span class="s1">p0 </span><span class="s4">- </span><span class="s1">p1</span><span class="s4">) + </span><span class="s1">abs</span><span class="s4">(</span><span class="s1">p1 </span><span class="s4">- </span><span class="s1">p2</span><span class="s4">) + </span><span class="s1">abs</span><span class="s4">(</span><span class="s1">p2 </span><span class="s4">- </span><span class="s1">p3</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">arch </span><span class="s4">* </span><span class="s1">mult </span><span class="s4">+ </span><span class="s1">EPSILON </span><span class="s4">&gt;= </span><span class="s1">box</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s4">(</span><span class="s1">arch </span><span class="s4">+ </span><span class="s1">box</span><span class="s4">) * </span><span class="s5">0.5</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">one</span><span class="s4">, </span><span class="s1">two </span><span class="s4">= </span><span class="s1">_split_cubic_into_two</span><span class="s4">(</span><span class="s1">p0</span><span class="s4">, </span><span class="s1">p1</span><span class="s4">, </span><span class="s1">p2</span><span class="s4">, </span><span class="s1">p3</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">_calcCubicArcLengthCRecurse</span><span class="s4">(</span><span class="s1">mult</span><span class="s4">, *</span><span class="s1">one</span><span class="s4">) + </span><span class="s1">_calcCubicArcLengthCRecurse</span><span class="s4">(</span>
            <span class="s1">mult</span><span class="s4">, *</span><span class="s1">two</span>
        <span class="s4">)</span>


<span class="s4">@</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">returns</span><span class="s4">(</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">double</span><span class="s4">)</span>
<span class="s4">@</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">locals</span><span class="s4">(</span>
    <span class="s1">pt1</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">complex</span><span class="s4">,</span>
    <span class="s1">pt2</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">complex</span><span class="s4">,</span>
    <span class="s1">pt3</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">complex</span><span class="s4">,</span>
    <span class="s1">pt4</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">complex</span><span class="s4">,</span>
<span class="s4">)</span>
<span class="s4">@</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">locals</span><span class="s4">(</span>
    <span class="s1">tolerance</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">double</span><span class="s4">,</span>
    <span class="s1">mult</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">double</span><span class="s4">,</span>
<span class="s4">)</span>
<span class="s3">def </span><span class="s1">calcCubicArcLengthC</span><span class="s4">(</span><span class="s1">pt1</span><span class="s4">, </span><span class="s1">pt2</span><span class="s4">, </span><span class="s1">pt3</span><span class="s4">, </span><span class="s1">pt4</span><span class="s4">, </span><span class="s1">tolerance</span><span class="s4">=</span><span class="s5">0.005</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Calculates the arc length for a cubic Bezier segment. 
 
    Args: 
        pt1,pt2,pt3,pt4: Control points of the Bezier as complex numbers. 
        tolerance: Controls the precision of the calcuation. 
 
    Returns: 
        Arc length value. 
    &quot;&quot;&quot;</span>
    <span class="s1">mult </span><span class="s4">= </span><span class="s5">1.0 </span><span class="s4">+ </span><span class="s5">1.5 </span><span class="s4">* </span><span class="s1">tolerance  </span><span class="s0"># The 1.5 is a empirical hack; no math</span>
    <span class="s3">return </span><span class="s1">_calcCubicArcLengthCRecurse</span><span class="s4">(</span><span class="s1">mult</span><span class="s4">, </span><span class="s1">pt1</span><span class="s4">, </span><span class="s1">pt2</span><span class="s4">, </span><span class="s1">pt3</span><span class="s4">, </span><span class="s1">pt4</span><span class="s4">)</span>


<span class="s1">epsilonDigits </span><span class="s4">= </span><span class="s5">6</span>
<span class="s1">epsilon </span><span class="s4">= </span><span class="s5">1e-10</span>


<span class="s4">@</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">cfunc</span>
<span class="s4">@</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">inline</span>
<span class="s4">@</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">returns</span><span class="s4">(</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">double</span><span class="s4">)</span>
<span class="s4">@</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">locals</span><span class="s4">(</span><span class="s1">v1</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">complex</span><span class="s4">, </span><span class="s1">v2</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">complex</span><span class="s4">)</span>
<span class="s3">def </span><span class="s1">_dot</span><span class="s4">(</span><span class="s1">v1</span><span class="s4">, </span><span class="s1">v2</span><span class="s4">):</span>
    <span class="s3">return </span><span class="s4">(</span><span class="s1">v1 </span><span class="s4">* </span><span class="s1">v2</span><span class="s4">.</span><span class="s1">conjugate</span><span class="s4">()).</span><span class="s1">real</span>


<span class="s4">@</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">cfunc</span>
<span class="s4">@</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">inline</span>
<span class="s4">@</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">returns</span><span class="s4">(</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">double</span><span class="s4">)</span>
<span class="s4">@</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">locals</span><span class="s4">(</span><span class="s1">x</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">double</span><span class="s4">)</span>
<span class="s3">def </span><span class="s1">_intSecAtan</span><span class="s4">(</span><span class="s1">x</span><span class="s4">):</span>
    <span class="s0"># In : sympy.integrate(sp.sec(sp.atan(x)))</span>
    <span class="s0"># Out: x*sqrt(x**2 + 1)/2 + asinh(x)/2</span>
    <span class="s3">return </span><span class="s1">x </span><span class="s4">* </span><span class="s1">math</span><span class="s4">.</span><span class="s1">sqrt</span><span class="s4">(</span><span class="s1">x</span><span class="s4">**</span><span class="s5">2 </span><span class="s4">+ </span><span class="s5">1</span><span class="s4">) / </span><span class="s5">2 </span><span class="s4">+ </span><span class="s1">math</span><span class="s4">.</span><span class="s1">asinh</span><span class="s4">(</span><span class="s1">x</span><span class="s4">) / </span><span class="s5">2</span>


<span class="s3">def </span><span class="s1">calcQuadraticArcLength</span><span class="s4">(</span><span class="s1">pt1</span><span class="s4">, </span><span class="s1">pt2</span><span class="s4">, </span><span class="s1">pt3</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Calculates the arc length for a quadratic Bezier segment. 
 
    Args: 
        pt1: Start point of the Bezier as 2D tuple. 
        pt2: Handle point of the Bezier as 2D tuple. 
        pt3: End point of the Bezier as 2D tuple. 
 
    Returns: 
        Arc length value. 
 
    Example:: 
 
        &gt;&gt;&gt; calcQuadraticArcLength((0, 0), (0, 0), (0, 0)) # empty segment 
        0.0 
        &gt;&gt;&gt; calcQuadraticArcLength((0, 0), (50, 0), (80, 0)) # collinear points 
        80.0 
        &gt;&gt;&gt; calcQuadraticArcLength((0, 0), (0, 50), (0, 80)) # collinear points vertical 
        80.0 
        &gt;&gt;&gt; calcQuadraticArcLength((0, 0), (50, 20), (100, 40)) # collinear points 
        107.70329614269008 
        &gt;&gt;&gt; calcQuadraticArcLength((0, 0), (0, 100), (100, 0)) 
        154.02976155645263 
        &gt;&gt;&gt; calcQuadraticArcLength((0, 0), (0, 50), (100, 0)) 
        120.21581243984076 
        &gt;&gt;&gt; calcQuadraticArcLength((0, 0), (50, -10), (80, 50)) 
        102.53273816445825 
        &gt;&gt;&gt; calcQuadraticArcLength((0, 0), (40, 0), (-40, 0)) # collinear points, control point outside 
        66.66666666666667 
        &gt;&gt;&gt; calcQuadraticArcLength((0, 0), (40, 0), (0, 0)) # collinear points, looping back 
        40.0 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">calcQuadraticArcLengthC</span><span class="s4">(</span><span class="s1">complex</span><span class="s4">(*</span><span class="s1">pt1</span><span class="s4">), </span><span class="s1">complex</span><span class="s4">(*</span><span class="s1">pt2</span><span class="s4">), </span><span class="s1">complex</span><span class="s4">(*</span><span class="s1">pt3</span><span class="s4">))</span>


<span class="s4">@</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">returns</span><span class="s4">(</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">double</span><span class="s4">)</span>
<span class="s4">@</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">locals</span><span class="s4">(</span>
    <span class="s1">pt1</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">complex</span><span class="s4">,</span>
    <span class="s1">pt2</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">complex</span><span class="s4">,</span>
    <span class="s1">pt3</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">complex</span><span class="s4">,</span>
    <span class="s1">d0</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">complex</span><span class="s4">,</span>
    <span class="s1">d1</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">complex</span><span class="s4">,</span>
    <span class="s1">d</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">complex</span><span class="s4">,</span>
    <span class="s1">n</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">complex</span><span class="s4">,</span>
<span class="s4">)</span>
<span class="s4">@</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">locals</span><span class="s4">(</span>
    <span class="s1">scale</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">double</span><span class="s4">,</span>
    <span class="s1">origDist</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">double</span><span class="s4">,</span>
    <span class="s1">a</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">double</span><span class="s4">,</span>
    <span class="s1">b</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">double</span><span class="s4">,</span>
    <span class="s1">x0</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">double</span><span class="s4">,</span>
    <span class="s1">x1</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">double</span><span class="s4">,</span>
    <span class="s1">Len</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">double</span><span class="s4">,</span>
<span class="s4">)</span>
<span class="s3">def </span><span class="s1">calcQuadraticArcLengthC</span><span class="s4">(</span><span class="s1">pt1</span><span class="s4">, </span><span class="s1">pt2</span><span class="s4">, </span><span class="s1">pt3</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Calculates the arc length for a quadratic Bezier segment. 
 
    Args: 
        pt1: Start point of the Bezier as a complex number. 
        pt2: Handle point of the Bezier as a complex number. 
        pt3: End point of the Bezier as a complex number. 
 
    Returns: 
        Arc length value. 
    &quot;&quot;&quot;</span>
    <span class="s0"># Analytical solution to the length of a quadratic bezier.</span>
    <span class="s0"># Documentation: https://github.com/fonttools/fonttools/issues/3055</span>
    <span class="s1">d0 </span><span class="s4">= </span><span class="s1">pt2 </span><span class="s4">- </span><span class="s1">pt1</span>
    <span class="s1">d1 </span><span class="s4">= </span><span class="s1">pt3 </span><span class="s4">- </span><span class="s1">pt2</span>
    <span class="s1">d </span><span class="s4">= </span><span class="s1">d1 </span><span class="s4">- </span><span class="s1">d0</span>
    <span class="s1">n </span><span class="s4">= </span><span class="s1">d </span><span class="s4">* </span><span class="s5">1j</span>
    <span class="s1">scale </span><span class="s4">= </span><span class="s1">abs</span><span class="s4">(</span><span class="s1">n</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">scale </span><span class="s4">== </span><span class="s5">0.0</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">abs</span><span class="s4">(</span><span class="s1">pt3 </span><span class="s4">- </span><span class="s1">pt1</span><span class="s4">)</span>
    <span class="s1">origDist </span><span class="s4">= </span><span class="s1">_dot</span><span class="s4">(</span><span class="s1">n</span><span class="s4">, </span><span class="s1">d0</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">abs</span><span class="s4">(</span><span class="s1">origDist</span><span class="s4">) &lt; </span><span class="s1">epsilon</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">_dot</span><span class="s4">(</span><span class="s1">d0</span><span class="s4">, </span><span class="s1">d1</span><span class="s4">) &gt;= </span><span class="s5">0</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">abs</span><span class="s4">(</span><span class="s1">pt3 </span><span class="s4">- </span><span class="s1">pt1</span><span class="s4">)</span>
        <span class="s1">a</span><span class="s4">, </span><span class="s1">b </span><span class="s4">= </span><span class="s1">abs</span><span class="s4">(</span><span class="s1">d0</span><span class="s4">), </span><span class="s1">abs</span><span class="s4">(</span><span class="s1">d1</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s4">(</span><span class="s1">a </span><span class="s4">* </span><span class="s1">a </span><span class="s4">+ </span><span class="s1">b </span><span class="s4">* </span><span class="s1">b</span><span class="s4">) / (</span><span class="s1">a </span><span class="s4">+ </span><span class="s1">b</span><span class="s4">)</span>
    <span class="s1">x0 </span><span class="s4">= </span><span class="s1">_dot</span><span class="s4">(</span><span class="s1">d</span><span class="s4">, </span><span class="s1">d0</span><span class="s4">) / </span><span class="s1">origDist</span>
    <span class="s1">x1 </span><span class="s4">= </span><span class="s1">_dot</span><span class="s4">(</span><span class="s1">d</span><span class="s4">, </span><span class="s1">d1</span><span class="s4">) / </span><span class="s1">origDist</span>
    <span class="s1">Len </span><span class="s4">= </span><span class="s1">abs</span><span class="s4">(</span><span class="s5">2 </span><span class="s4">* (</span><span class="s1">_intSecAtan</span><span class="s4">(</span><span class="s1">x1</span><span class="s4">) - </span><span class="s1">_intSecAtan</span><span class="s4">(</span><span class="s1">x0</span><span class="s4">)) * </span><span class="s1">origDist </span><span class="s4">/ (</span><span class="s1">scale </span><span class="s4">* (</span><span class="s1">x1 </span><span class="s4">- </span><span class="s1">x0</span><span class="s4">)))</span>
    <span class="s3">return </span><span class="s1">Len</span>


<span class="s3">def </span><span class="s1">approximateQuadraticArcLength</span><span class="s4">(</span><span class="s1">pt1</span><span class="s4">, </span><span class="s1">pt2</span><span class="s4">, </span><span class="s1">pt3</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Calculates the arc length for a quadratic Bezier segment. 
 
    Uses Gauss-Legendre quadrature for a branch-free approximation. 
    See :func:`calcQuadraticArcLength` for a slower but more accurate result. 
 
    Args: 
        pt1: Start point of the Bezier as 2D tuple. 
        pt2: Handle point of the Bezier as 2D tuple. 
        pt3: End point of the Bezier as 2D tuple. 
 
    Returns: 
        Approximate arc length value. 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">approximateQuadraticArcLengthC</span><span class="s4">(</span><span class="s1">complex</span><span class="s4">(*</span><span class="s1">pt1</span><span class="s4">), </span><span class="s1">complex</span><span class="s4">(*</span><span class="s1">pt2</span><span class="s4">), </span><span class="s1">complex</span><span class="s4">(*</span><span class="s1">pt3</span><span class="s4">))</span>


<span class="s4">@</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">returns</span><span class="s4">(</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">double</span><span class="s4">)</span>
<span class="s4">@</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">locals</span><span class="s4">(</span>
    <span class="s1">pt1</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">complex</span><span class="s4">,</span>
    <span class="s1">pt2</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">complex</span><span class="s4">,</span>
    <span class="s1">pt3</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">complex</span><span class="s4">,</span>
<span class="s4">)</span>
<span class="s4">@</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">locals</span><span class="s4">(</span>
    <span class="s1">v0</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">double</span><span class="s4">,</span>
    <span class="s1">v1</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">double</span><span class="s4">,</span>
    <span class="s1">v2</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">double</span><span class="s4">,</span>
<span class="s4">)</span>
<span class="s3">def </span><span class="s1">approximateQuadraticArcLengthC</span><span class="s4">(</span><span class="s1">pt1</span><span class="s4">, </span><span class="s1">pt2</span><span class="s4">, </span><span class="s1">pt3</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Calculates the arc length for a quadratic Bezier segment. 
 
    Uses Gauss-Legendre quadrature for a branch-free approximation. 
    See :func:`calcQuadraticArcLength` for a slower but more accurate result. 
 
    Args: 
        pt1: Start point of the Bezier as a complex number. 
        pt2: Handle point of the Bezier as a complex number. 
        pt3: End point of the Bezier as a complex number. 
 
    Returns: 
        Approximate arc length value. 
    &quot;&quot;&quot;</span>
    <span class="s0"># This, essentially, approximates the length-of-derivative function</span>
    <span class="s0"># to be integrated with the best-matching fifth-degree polynomial</span>
    <span class="s0"># approximation of it.</span>
    <span class="s0">#</span>
    <span class="s0"># https://en.wikipedia.org/wiki/Gaussian_quadrature#Gauss.E2.80.93Legendre_quadrature</span>

    <span class="s0"># abs(BezierCurveC[2].diff(t).subs({t:T})) for T in sorted(.5, .5±sqrt(3/5)/2),</span>
    <span class="s0"># weighted 5/18, 8/18, 5/18 respectively.</span>
    <span class="s1">v0 </span><span class="s4">= </span><span class="s1">abs</span><span class="s4">(</span>
        <span class="s4">-</span><span class="s5">0.492943519233745 </span><span class="s4">* </span><span class="s1">pt1 </span><span class="s4">+ </span><span class="s5">0.430331482911935 </span><span class="s4">* </span><span class="s1">pt2 </span><span class="s4">+ </span><span class="s5">0.0626120363218102 </span><span class="s4">* </span><span class="s1">pt3</span>
    <span class="s4">)</span>
    <span class="s1">v1 </span><span class="s4">= </span><span class="s1">abs</span><span class="s4">(</span><span class="s1">pt3 </span><span class="s4">- </span><span class="s1">pt1</span><span class="s4">) * </span><span class="s5">0.4444444444444444</span>
    <span class="s1">v2 </span><span class="s4">= </span><span class="s1">abs</span><span class="s4">(</span>
        <span class="s4">-</span><span class="s5">0.0626120363218102 </span><span class="s4">* </span><span class="s1">pt1 </span><span class="s4">- </span><span class="s5">0.430331482911935 </span><span class="s4">* </span><span class="s1">pt2 </span><span class="s4">+ </span><span class="s5">0.492943519233745 </span><span class="s4">* </span><span class="s1">pt3</span>
    <span class="s4">)</span>

    <span class="s3">return </span><span class="s1">v0 </span><span class="s4">+ </span><span class="s1">v1 </span><span class="s4">+ </span><span class="s1">v2</span>


<span class="s3">def </span><span class="s1">calcQuadraticBounds</span><span class="s4">(</span><span class="s1">pt1</span><span class="s4">, </span><span class="s1">pt2</span><span class="s4">, </span><span class="s1">pt3</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Calculates the bounding rectangle for a quadratic Bezier segment. 
 
    Args: 
        pt1: Start point of the Bezier as a 2D tuple. 
        pt2: Handle point of the Bezier as a 2D tuple. 
        pt3: End point of the Bezier as a 2D tuple. 
 
    Returns: 
        A four-item tuple representing the bounding rectangle ``(xMin, yMin, xMax, yMax)``. 
 
    Example:: 
 
        &gt;&gt;&gt; calcQuadraticBounds((0, 0), (50, 100), (100, 0)) 
        (0, 0, 100, 50.0) 
        &gt;&gt;&gt; calcQuadraticBounds((0, 0), (100, 0), (100, 100)) 
        (0.0, 0.0, 100, 100) 
    &quot;&quot;&quot;</span>
    <span class="s4">(</span><span class="s1">ax</span><span class="s4">, </span><span class="s1">ay</span><span class="s4">), (</span><span class="s1">bx</span><span class="s4">, </span><span class="s1">by</span><span class="s4">), (</span><span class="s1">cx</span><span class="s4">, </span><span class="s1">cy</span><span class="s4">) = </span><span class="s1">calcQuadraticParameters</span><span class="s4">(</span><span class="s1">pt1</span><span class="s4">, </span><span class="s1">pt2</span><span class="s4">, </span><span class="s1">pt3</span><span class="s4">)</span>
    <span class="s1">ax2 </span><span class="s4">= </span><span class="s1">ax </span><span class="s4">* </span><span class="s5">2.0</span>
    <span class="s1">ay2 </span><span class="s4">= </span><span class="s1">ay </span><span class="s4">* </span><span class="s5">2.0</span>
    <span class="s1">roots </span><span class="s4">= []</span>
    <span class="s3">if </span><span class="s1">ax2 </span><span class="s4">!= </span><span class="s5">0</span><span class="s4">:</span>
        <span class="s1">roots</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(-</span><span class="s1">bx </span><span class="s4">/ </span><span class="s1">ax2</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">ay2 </span><span class="s4">!= </span><span class="s5">0</span><span class="s4">:</span>
        <span class="s1">roots</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(-</span><span class="s1">by </span><span class="s4">/ </span><span class="s1">ay2</span><span class="s4">)</span>
    <span class="s1">points </span><span class="s4">= [</span>
        <span class="s4">(</span><span class="s1">ax </span><span class="s4">* </span><span class="s1">t </span><span class="s4">* </span><span class="s1">t </span><span class="s4">+ </span><span class="s1">bx </span><span class="s4">* </span><span class="s1">t </span><span class="s4">+ </span><span class="s1">cx</span><span class="s4">, </span><span class="s1">ay </span><span class="s4">* </span><span class="s1">t </span><span class="s4">* </span><span class="s1">t </span><span class="s4">+ </span><span class="s1">by </span><span class="s4">* </span><span class="s1">t </span><span class="s4">+ </span><span class="s1">cy</span><span class="s4">)</span>
        <span class="s3">for </span><span class="s1">t </span><span class="s3">in </span><span class="s1">roots</span>
        <span class="s3">if </span><span class="s5">0 </span><span class="s4">&lt;= </span><span class="s1">t </span><span class="s4">&lt; </span><span class="s5">1</span>
    <span class="s4">] + [</span><span class="s1">pt1</span><span class="s4">, </span><span class="s1">pt3</span><span class="s4">]</span>
    <span class="s3">return </span><span class="s1">calcBounds</span><span class="s4">(</span><span class="s1">points</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">approximateCubicArcLength</span><span class="s4">(</span><span class="s1">pt1</span><span class="s4">, </span><span class="s1">pt2</span><span class="s4">, </span><span class="s1">pt3</span><span class="s4">, </span><span class="s1">pt4</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Approximates the arc length for a cubic Bezier segment. 
 
    Uses Gauss-Lobatto quadrature with n=5 points to approximate arc length. 
    See :func:`calcCubicArcLength` for a slower but more accurate result. 
 
    Args: 
        pt1,pt2,pt3,pt4: Control points of the Bezier as 2D tuples. 
 
    Returns: 
        Arc length value. 
 
    Example:: 
 
        &gt;&gt;&gt; approximateCubicArcLength((0, 0), (25, 100), (75, 100), (100, 0)) 
        190.04332968932817 
        &gt;&gt;&gt; approximateCubicArcLength((0, 0), (50, 0), (100, 50), (100, 100)) 
        154.8852074945903 
        &gt;&gt;&gt; approximateCubicArcLength((0, 0), (50, 0), (100, 0), (150, 0)) # line; exact result should be 150. 
        149.99999999999991 
        &gt;&gt;&gt; approximateCubicArcLength((0, 0), (50, 0), (100, 0), (-50, 0)) # cusp; exact result should be 150. 
        136.9267662156362 
        &gt;&gt;&gt; approximateCubicArcLength((0, 0), (50, 0), (100, -50), (-50, 0)) # cusp 
        154.80848416537057 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">approximateCubicArcLengthC</span><span class="s4">(</span>
        <span class="s1">complex</span><span class="s4">(*</span><span class="s1">pt1</span><span class="s4">), </span><span class="s1">complex</span><span class="s4">(*</span><span class="s1">pt2</span><span class="s4">), </span><span class="s1">complex</span><span class="s4">(*</span><span class="s1">pt3</span><span class="s4">), </span><span class="s1">complex</span><span class="s4">(*</span><span class="s1">pt4</span><span class="s4">)</span>
    <span class="s4">)</span>


<span class="s4">@</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">returns</span><span class="s4">(</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">double</span><span class="s4">)</span>
<span class="s4">@</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">locals</span><span class="s4">(</span>
    <span class="s1">pt1</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">complex</span><span class="s4">,</span>
    <span class="s1">pt2</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">complex</span><span class="s4">,</span>
    <span class="s1">pt3</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">complex</span><span class="s4">,</span>
    <span class="s1">pt4</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">complex</span><span class="s4">,</span>
<span class="s4">)</span>
<span class="s4">@</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">locals</span><span class="s4">(</span>
    <span class="s1">v0</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">double</span><span class="s4">,</span>
    <span class="s1">v1</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">double</span><span class="s4">,</span>
    <span class="s1">v2</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">double</span><span class="s4">,</span>
    <span class="s1">v3</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">double</span><span class="s4">,</span>
    <span class="s1">v4</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">double</span><span class="s4">,</span>
<span class="s4">)</span>
<span class="s3">def </span><span class="s1">approximateCubicArcLengthC</span><span class="s4">(</span><span class="s1">pt1</span><span class="s4">, </span><span class="s1">pt2</span><span class="s4">, </span><span class="s1">pt3</span><span class="s4">, </span><span class="s1">pt4</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Approximates the arc length for a cubic Bezier segment. 
 
    Args: 
        pt1,pt2,pt3,pt4: Control points of the Bezier as complex numbers. 
 
    Returns: 
        Arc length value. 
    &quot;&quot;&quot;</span>
    <span class="s0"># This, essentially, approximates the length-of-derivative function</span>
    <span class="s0"># to be integrated with the best-matching seventh-degree polynomial</span>
    <span class="s0"># approximation of it.</span>
    <span class="s0">#</span>
    <span class="s0"># https://en.wikipedia.org/wiki/Gaussian_quadrature#Gauss.E2.80.93Lobatto_rules</span>

    <span class="s0"># abs(BezierCurveC[3].diff(t).subs({t:T})) for T in sorted(0, .5±(3/7)**.5/2, .5, 1),</span>
    <span class="s0"># weighted 1/20, 49/180, 32/90, 49/180, 1/20 respectively.</span>
    <span class="s1">v0 </span><span class="s4">= </span><span class="s1">abs</span><span class="s4">(</span><span class="s1">pt2 </span><span class="s4">- </span><span class="s1">pt1</span><span class="s4">) * </span><span class="s5">0.15</span>
    <span class="s1">v1 </span><span class="s4">= </span><span class="s1">abs</span><span class="s4">(</span>
        <span class="s4">-</span><span class="s5">0.558983582205757 </span><span class="s4">* </span><span class="s1">pt1</span>
        <span class="s4">+ </span><span class="s5">0.325650248872424 </span><span class="s4">* </span><span class="s1">pt2</span>
        <span class="s4">+ </span><span class="s5">0.208983582205757 </span><span class="s4">* </span><span class="s1">pt3</span>
        <span class="s4">+ </span><span class="s5">0.024349751127576 </span><span class="s4">* </span><span class="s1">pt4</span>
    <span class="s4">)</span>
    <span class="s1">v2 </span><span class="s4">= </span><span class="s1">abs</span><span class="s4">(</span><span class="s1">pt4 </span><span class="s4">- </span><span class="s1">pt1 </span><span class="s4">+ </span><span class="s1">pt3 </span><span class="s4">- </span><span class="s1">pt2</span><span class="s4">) * </span><span class="s5">0.26666666666666666</span>
    <span class="s1">v3 </span><span class="s4">= </span><span class="s1">abs</span><span class="s4">(</span>
        <span class="s4">-</span><span class="s5">0.024349751127576 </span><span class="s4">* </span><span class="s1">pt1</span>
        <span class="s4">- </span><span class="s5">0.208983582205757 </span><span class="s4">* </span><span class="s1">pt2</span>
        <span class="s4">- </span><span class="s5">0.325650248872424 </span><span class="s4">* </span><span class="s1">pt3</span>
        <span class="s4">+ </span><span class="s5">0.558983582205757 </span><span class="s4">* </span><span class="s1">pt4</span>
    <span class="s4">)</span>
    <span class="s1">v4 </span><span class="s4">= </span><span class="s1">abs</span><span class="s4">(</span><span class="s1">pt4 </span><span class="s4">- </span><span class="s1">pt3</span><span class="s4">) * </span><span class="s5">0.15</span>

    <span class="s3">return </span><span class="s1">v0 </span><span class="s4">+ </span><span class="s1">v1 </span><span class="s4">+ </span><span class="s1">v2 </span><span class="s4">+ </span><span class="s1">v3 </span><span class="s4">+ </span><span class="s1">v4</span>


<span class="s3">def </span><span class="s1">calcCubicBounds</span><span class="s4">(</span><span class="s1">pt1</span><span class="s4">, </span><span class="s1">pt2</span><span class="s4">, </span><span class="s1">pt3</span><span class="s4">, </span><span class="s1">pt4</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Calculates the bounding rectangle for a quadratic Bezier segment. 
 
    Args: 
        pt1,pt2,pt3,pt4: Control points of the Bezier as 2D tuples. 
 
    Returns: 
        A four-item tuple representing the bounding rectangle ``(xMin, yMin, xMax, yMax)``. 
 
    Example:: 
 
        &gt;&gt;&gt; calcCubicBounds((0, 0), (25, 100), (75, 100), (100, 0)) 
        (0, 0, 100, 75.0) 
        &gt;&gt;&gt; calcCubicBounds((0, 0), (50, 0), (100, 50), (100, 100)) 
        (0.0, 0.0, 100, 100) 
        &gt;&gt;&gt; print(&quot;%f %f %f %f&quot; % calcCubicBounds((50, 0), (0, 100), (100, 100), (50, 0))) 
        35.566243 0.000000 64.433757 75.000000 
    &quot;&quot;&quot;</span>
    <span class="s4">(</span><span class="s1">ax</span><span class="s4">, </span><span class="s1">ay</span><span class="s4">), (</span><span class="s1">bx</span><span class="s4">, </span><span class="s1">by</span><span class="s4">), (</span><span class="s1">cx</span><span class="s4">, </span><span class="s1">cy</span><span class="s4">), (</span><span class="s1">dx</span><span class="s4">, </span><span class="s1">dy</span><span class="s4">) = </span><span class="s1">calcCubicParameters</span><span class="s4">(</span><span class="s1">pt1</span><span class="s4">, </span><span class="s1">pt2</span><span class="s4">, </span><span class="s1">pt3</span><span class="s4">, </span><span class="s1">pt4</span><span class="s4">)</span>
    <span class="s0"># calc first derivative</span>
    <span class="s1">ax3 </span><span class="s4">= </span><span class="s1">ax </span><span class="s4">* </span><span class="s5">3.0</span>
    <span class="s1">ay3 </span><span class="s4">= </span><span class="s1">ay </span><span class="s4">* </span><span class="s5">3.0</span>
    <span class="s1">bx2 </span><span class="s4">= </span><span class="s1">bx </span><span class="s4">* </span><span class="s5">2.0</span>
    <span class="s1">by2 </span><span class="s4">= </span><span class="s1">by </span><span class="s4">* </span><span class="s5">2.0</span>
    <span class="s1">xRoots </span><span class="s4">= [</span><span class="s1">t </span><span class="s3">for </span><span class="s1">t </span><span class="s3">in </span><span class="s1">solveQuadratic</span><span class="s4">(</span><span class="s1">ax3</span><span class="s4">, </span><span class="s1">bx2</span><span class="s4">, </span><span class="s1">cx</span><span class="s4">) </span><span class="s3">if </span><span class="s5">0 </span><span class="s4">&lt;= </span><span class="s1">t </span><span class="s4">&lt; </span><span class="s5">1</span><span class="s4">]</span>
    <span class="s1">yRoots </span><span class="s4">= [</span><span class="s1">t </span><span class="s3">for </span><span class="s1">t </span><span class="s3">in </span><span class="s1">solveQuadratic</span><span class="s4">(</span><span class="s1">ay3</span><span class="s4">, </span><span class="s1">by2</span><span class="s4">, </span><span class="s1">cy</span><span class="s4">) </span><span class="s3">if </span><span class="s5">0 </span><span class="s4">&lt;= </span><span class="s1">t </span><span class="s4">&lt; </span><span class="s5">1</span><span class="s4">]</span>
    <span class="s1">roots </span><span class="s4">= </span><span class="s1">xRoots </span><span class="s4">+ </span><span class="s1">yRoots</span>

    <span class="s1">points </span><span class="s4">= [</span>
        <span class="s4">(</span>
            <span class="s1">ax </span><span class="s4">* </span><span class="s1">t </span><span class="s4">* </span><span class="s1">t </span><span class="s4">* </span><span class="s1">t </span><span class="s4">+ </span><span class="s1">bx </span><span class="s4">* </span><span class="s1">t </span><span class="s4">* </span><span class="s1">t </span><span class="s4">+ </span><span class="s1">cx </span><span class="s4">* </span><span class="s1">t </span><span class="s4">+ </span><span class="s1">dx</span><span class="s4">,</span>
            <span class="s1">ay </span><span class="s4">* </span><span class="s1">t </span><span class="s4">* </span><span class="s1">t </span><span class="s4">* </span><span class="s1">t </span><span class="s4">+ </span><span class="s1">by </span><span class="s4">* </span><span class="s1">t </span><span class="s4">* </span><span class="s1">t </span><span class="s4">+ </span><span class="s1">cy </span><span class="s4">* </span><span class="s1">t </span><span class="s4">+ </span><span class="s1">dy</span><span class="s4">,</span>
        <span class="s4">)</span>
        <span class="s3">for </span><span class="s1">t </span><span class="s3">in </span><span class="s1">roots</span>
    <span class="s4">] + [</span><span class="s1">pt1</span><span class="s4">, </span><span class="s1">pt4</span><span class="s4">]</span>
    <span class="s3">return </span><span class="s1">calcBounds</span><span class="s4">(</span><span class="s1">points</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">splitLine</span><span class="s4">(</span><span class="s1">pt1</span><span class="s4">, </span><span class="s1">pt2</span><span class="s4">, </span><span class="s1">where</span><span class="s4">, </span><span class="s1">isHorizontal</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Split a line at a given coordinate. 
 
    Args: 
        pt1: Start point of line as 2D tuple. 
        pt2: End point of line as 2D tuple. 
        where: Position at which to split the line. 
        isHorizontal: Direction of the ray splitting the line. If true, 
            ``where`` is interpreted as a Y coordinate; if false, then 
            ``where`` is interpreted as an X coordinate. 
 
    Returns: 
        A list of two line segments (each line segment being two 2D tuples) 
        if the line was successfully split, or a list containing the original 
        line. 
 
    Example:: 
 
        &gt;&gt;&gt; printSegments(splitLine((0, 0), (100, 100), 50, True)) 
        ((0, 0), (50, 50)) 
        ((50, 50), (100, 100)) 
        &gt;&gt;&gt; printSegments(splitLine((0, 0), (100, 100), 100, True)) 
        ((0, 0), (100, 100)) 
        &gt;&gt;&gt; printSegments(splitLine((0, 0), (100, 100), 0, True)) 
        ((0, 0), (0, 0)) 
        ((0, 0), (100, 100)) 
        &gt;&gt;&gt; printSegments(splitLine((0, 0), (100, 100), 0, False)) 
        ((0, 0), (0, 0)) 
        ((0, 0), (100, 100)) 
        &gt;&gt;&gt; printSegments(splitLine((100, 0), (0, 0), 50, False)) 
        ((100, 0), (50, 0)) 
        ((50, 0), (0, 0)) 
        &gt;&gt;&gt; printSegments(splitLine((0, 100), (0, 0), 50, True)) 
        ((0, 100), (0, 50)) 
        ((0, 50), (0, 0)) 
    &quot;&quot;&quot;</span>
    <span class="s1">pt1x</span><span class="s4">, </span><span class="s1">pt1y </span><span class="s4">= </span><span class="s1">pt1</span>
    <span class="s1">pt2x</span><span class="s4">, </span><span class="s1">pt2y </span><span class="s4">= </span><span class="s1">pt2</span>

    <span class="s1">ax </span><span class="s4">= </span><span class="s1">pt2x </span><span class="s4">- </span><span class="s1">pt1x</span>
    <span class="s1">ay </span><span class="s4">= </span><span class="s1">pt2y </span><span class="s4">- </span><span class="s1">pt1y</span>

    <span class="s1">bx </span><span class="s4">= </span><span class="s1">pt1x</span>
    <span class="s1">by </span><span class="s4">= </span><span class="s1">pt1y</span>

    <span class="s1">a </span><span class="s4">= (</span><span class="s1">ax</span><span class="s4">, </span><span class="s1">ay</span><span class="s4">)[</span><span class="s1">isHorizontal</span><span class="s4">]</span>

    <span class="s3">if </span><span class="s1">a </span><span class="s4">== </span><span class="s5">0</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s4">[(</span><span class="s1">pt1</span><span class="s4">, </span><span class="s1">pt2</span><span class="s4">)]</span>
    <span class="s1">t </span><span class="s4">= (</span><span class="s1">where </span><span class="s4">- (</span><span class="s1">bx</span><span class="s4">, </span><span class="s1">by</span><span class="s4">)[</span><span class="s1">isHorizontal</span><span class="s4">]) / </span><span class="s1">a</span>
    <span class="s3">if </span><span class="s5">0 </span><span class="s4">&lt;= </span><span class="s1">t </span><span class="s4">&lt; </span><span class="s5">1</span><span class="s4">:</span>
        <span class="s1">midPt </span><span class="s4">= </span><span class="s1">ax </span><span class="s4">* </span><span class="s1">t </span><span class="s4">+ </span><span class="s1">bx</span><span class="s4">, </span><span class="s1">ay </span><span class="s4">* </span><span class="s1">t </span><span class="s4">+ </span><span class="s1">by</span>
        <span class="s3">return </span><span class="s4">[(</span><span class="s1">pt1</span><span class="s4">, </span><span class="s1">midPt</span><span class="s4">), (</span><span class="s1">midPt</span><span class="s4">, </span><span class="s1">pt2</span><span class="s4">)]</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s4">[(</span><span class="s1">pt1</span><span class="s4">, </span><span class="s1">pt2</span><span class="s4">)]</span>


<span class="s3">def </span><span class="s1">splitQuadratic</span><span class="s4">(</span><span class="s1">pt1</span><span class="s4">, </span><span class="s1">pt2</span><span class="s4">, </span><span class="s1">pt3</span><span class="s4">, </span><span class="s1">where</span><span class="s4">, </span><span class="s1">isHorizontal</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Split a quadratic Bezier curve at a given coordinate. 
 
    Args: 
        pt1,pt2,pt3: Control points of the Bezier as 2D tuples. 
        where: Position at which to split the curve. 
        isHorizontal: Direction of the ray splitting the curve. If true, 
            ``where`` is interpreted as a Y coordinate; if false, then 
            ``where`` is interpreted as an X coordinate. 
 
    Returns: 
        A list of two curve segments (each curve segment being three 2D tuples) 
        if the curve was successfully split, or a list containing the original 
        curve. 
 
    Example:: 
 
        &gt;&gt;&gt; printSegments(splitQuadratic((0, 0), (50, 100), (100, 0), 150, False)) 
        ((0, 0), (50, 100), (100, 0)) 
        &gt;&gt;&gt; printSegments(splitQuadratic((0, 0), (50, 100), (100, 0), 50, False)) 
        ((0, 0), (25, 50), (50, 50)) 
        ((50, 50), (75, 50), (100, 0)) 
        &gt;&gt;&gt; printSegments(splitQuadratic((0, 0), (50, 100), (100, 0), 25, False)) 
        ((0, 0), (12.5, 25), (25, 37.5)) 
        ((25, 37.5), (62.5, 75), (100, 0)) 
        &gt;&gt;&gt; printSegments(splitQuadratic((0, 0), (50, 100), (100, 0), 25, True)) 
        ((0, 0), (7.32233, 14.6447), (14.6447, 25)) 
        ((14.6447, 25), (50, 75), (85.3553, 25)) 
        ((85.3553, 25), (92.6777, 14.6447), (100, -7.10543e-15)) 
        &gt;&gt;&gt; # XXX I'm not at all sure if the following behavior is desirable: 
        &gt;&gt;&gt; printSegments(splitQuadratic((0, 0), (50, 100), (100, 0), 50, True)) 
        ((0, 0), (25, 50), (50, 50)) 
        ((50, 50), (50, 50), (50, 50)) 
        ((50, 50), (75, 50), (100, 0)) 
    &quot;&quot;&quot;</span>
    <span class="s1">a</span><span class="s4">, </span><span class="s1">b</span><span class="s4">, </span><span class="s1">c </span><span class="s4">= </span><span class="s1">calcQuadraticParameters</span><span class="s4">(</span><span class="s1">pt1</span><span class="s4">, </span><span class="s1">pt2</span><span class="s4">, </span><span class="s1">pt3</span><span class="s4">)</span>
    <span class="s1">solutions </span><span class="s4">= </span><span class="s1">solveQuadratic</span><span class="s4">(</span>
        <span class="s1">a</span><span class="s4">[</span><span class="s1">isHorizontal</span><span class="s4">], </span><span class="s1">b</span><span class="s4">[</span><span class="s1">isHorizontal</span><span class="s4">], </span><span class="s1">c</span><span class="s4">[</span><span class="s1">isHorizontal</span><span class="s4">] - </span><span class="s1">where</span>
    <span class="s4">)</span>
    <span class="s1">solutions </span><span class="s4">= </span><span class="s1">sorted</span><span class="s4">(</span><span class="s1">t </span><span class="s3">for </span><span class="s1">t </span><span class="s3">in </span><span class="s1">solutions </span><span class="s3">if </span><span class="s5">0 </span><span class="s4">&lt;= </span><span class="s1">t </span><span class="s4">&lt; </span><span class="s5">1</span><span class="s4">)</span>
    <span class="s3">if not </span><span class="s1">solutions</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s4">[(</span><span class="s1">pt1</span><span class="s4">, </span><span class="s1">pt2</span><span class="s4">, </span><span class="s1">pt3</span><span class="s4">)]</span>
    <span class="s3">return </span><span class="s1">_splitQuadraticAtT</span><span class="s4">(</span><span class="s1">a</span><span class="s4">, </span><span class="s1">b</span><span class="s4">, </span><span class="s1">c</span><span class="s4">, *</span><span class="s1">solutions</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">splitCubic</span><span class="s4">(</span><span class="s1">pt1</span><span class="s4">, </span><span class="s1">pt2</span><span class="s4">, </span><span class="s1">pt3</span><span class="s4">, </span><span class="s1">pt4</span><span class="s4">, </span><span class="s1">where</span><span class="s4">, </span><span class="s1">isHorizontal</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Split a cubic Bezier curve at a given coordinate. 
 
    Args: 
        pt1,pt2,pt3,pt4: Control points of the Bezier as 2D tuples. 
        where: Position at which to split the curve. 
        isHorizontal: Direction of the ray splitting the curve. If true, 
            ``where`` is interpreted as a Y coordinate; if false, then 
            ``where`` is interpreted as an X coordinate. 
 
    Returns: 
        A list of two curve segments (each curve segment being four 2D tuples) 
        if the curve was successfully split, or a list containing the original 
        curve. 
 
    Example:: 
 
        &gt;&gt;&gt; printSegments(splitCubic((0, 0), (25, 100), (75, 100), (100, 0), 150, False)) 
        ((0, 0), (25, 100), (75, 100), (100, 0)) 
        &gt;&gt;&gt; printSegments(splitCubic((0, 0), (25, 100), (75, 100), (100, 0), 50, False)) 
        ((0, 0), (12.5, 50), (31.25, 75), (50, 75)) 
        ((50, 75), (68.75, 75), (87.5, 50), (100, 0)) 
        &gt;&gt;&gt; printSegments(splitCubic((0, 0), (25, 100), (75, 100), (100, 0), 25, True)) 
        ((0, 0), (2.29379, 9.17517), (4.79804, 17.5085), (7.47414, 25)) 
        ((7.47414, 25), (31.2886, 91.6667), (68.7114, 91.6667), (92.5259, 25)) 
        ((92.5259, 25), (95.202, 17.5085), (97.7062, 9.17517), (100, 1.77636e-15)) 
    &quot;&quot;&quot;</span>
    <span class="s1">a</span><span class="s4">, </span><span class="s1">b</span><span class="s4">, </span><span class="s1">c</span><span class="s4">, </span><span class="s1">d </span><span class="s4">= </span><span class="s1">calcCubicParameters</span><span class="s4">(</span><span class="s1">pt1</span><span class="s4">, </span><span class="s1">pt2</span><span class="s4">, </span><span class="s1">pt3</span><span class="s4">, </span><span class="s1">pt4</span><span class="s4">)</span>
    <span class="s1">solutions </span><span class="s4">= </span><span class="s1">solveCubic</span><span class="s4">(</span>
        <span class="s1">a</span><span class="s4">[</span><span class="s1">isHorizontal</span><span class="s4">], </span><span class="s1">b</span><span class="s4">[</span><span class="s1">isHorizontal</span><span class="s4">], </span><span class="s1">c</span><span class="s4">[</span><span class="s1">isHorizontal</span><span class="s4">], </span><span class="s1">d</span><span class="s4">[</span><span class="s1">isHorizontal</span><span class="s4">] - </span><span class="s1">where</span>
    <span class="s4">)</span>
    <span class="s1">solutions </span><span class="s4">= </span><span class="s1">sorted</span><span class="s4">(</span><span class="s1">t </span><span class="s3">for </span><span class="s1">t </span><span class="s3">in </span><span class="s1">solutions </span><span class="s3">if </span><span class="s5">0 </span><span class="s4">&lt;= </span><span class="s1">t </span><span class="s4">&lt; </span><span class="s5">1</span><span class="s4">)</span>
    <span class="s3">if not </span><span class="s1">solutions</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s4">[(</span><span class="s1">pt1</span><span class="s4">, </span><span class="s1">pt2</span><span class="s4">, </span><span class="s1">pt3</span><span class="s4">, </span><span class="s1">pt4</span><span class="s4">)]</span>
    <span class="s3">return </span><span class="s1">_splitCubicAtT</span><span class="s4">(</span><span class="s1">a</span><span class="s4">, </span><span class="s1">b</span><span class="s4">, </span><span class="s1">c</span><span class="s4">, </span><span class="s1">d</span><span class="s4">, *</span><span class="s1">solutions</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">splitQuadraticAtT</span><span class="s4">(</span><span class="s1">pt1</span><span class="s4">, </span><span class="s1">pt2</span><span class="s4">, </span><span class="s1">pt3</span><span class="s4">, *</span><span class="s1">ts</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Split a quadratic Bezier curve at one or more values of t. 
 
    Args: 
        pt1,pt2,pt3: Control points of the Bezier as 2D tuples. 
        *ts: Positions at which to split the curve. 
 
    Returns: 
        A list of curve segments (each curve segment being three 2D tuples). 
 
    Examples:: 
 
        &gt;&gt;&gt; printSegments(splitQuadraticAtT((0, 0), (50, 100), (100, 0), 0.5)) 
        ((0, 0), (25, 50), (50, 50)) 
        ((50, 50), (75, 50), (100, 0)) 
        &gt;&gt;&gt; printSegments(splitQuadraticAtT((0, 0), (50, 100), (100, 0), 0.5, 0.75)) 
        ((0, 0), (25, 50), (50, 50)) 
        ((50, 50), (62.5, 50), (75, 37.5)) 
        ((75, 37.5), (87.5, 25), (100, 0)) 
    &quot;&quot;&quot;</span>
    <span class="s1">a</span><span class="s4">, </span><span class="s1">b</span><span class="s4">, </span><span class="s1">c </span><span class="s4">= </span><span class="s1">calcQuadraticParameters</span><span class="s4">(</span><span class="s1">pt1</span><span class="s4">, </span><span class="s1">pt2</span><span class="s4">, </span><span class="s1">pt3</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s1">_splitQuadraticAtT</span><span class="s4">(</span><span class="s1">a</span><span class="s4">, </span><span class="s1">b</span><span class="s4">, </span><span class="s1">c</span><span class="s4">, *</span><span class="s1">ts</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">splitCubicAtT</span><span class="s4">(</span><span class="s1">pt1</span><span class="s4">, </span><span class="s1">pt2</span><span class="s4">, </span><span class="s1">pt3</span><span class="s4">, </span><span class="s1">pt4</span><span class="s4">, *</span><span class="s1">ts</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Split a cubic Bezier curve at one or more values of t. 
 
    Args: 
        pt1,pt2,pt3,pt4: Control points of the Bezier as 2D tuples. 
        *ts: Positions at which to split the curve. 
 
    Returns: 
        A list of curve segments (each curve segment being four 2D tuples). 
 
    Examples:: 
 
        &gt;&gt;&gt; printSegments(splitCubicAtT((0, 0), (25, 100), (75, 100), (100, 0), 0.5)) 
        ((0, 0), (12.5, 50), (31.25, 75), (50, 75)) 
        ((50, 75), (68.75, 75), (87.5, 50), (100, 0)) 
        &gt;&gt;&gt; printSegments(splitCubicAtT((0, 0), (25, 100), (75, 100), (100, 0), 0.5, 0.75)) 
        ((0, 0), (12.5, 50), (31.25, 75), (50, 75)) 
        ((50, 75), (59.375, 75), (68.75, 68.75), (77.3438, 56.25)) 
        ((77.3438, 56.25), (85.9375, 43.75), (93.75, 25), (100, 0)) 
    &quot;&quot;&quot;</span>
    <span class="s1">a</span><span class="s4">, </span><span class="s1">b</span><span class="s4">, </span><span class="s1">c</span><span class="s4">, </span><span class="s1">d </span><span class="s4">= </span><span class="s1">calcCubicParameters</span><span class="s4">(</span><span class="s1">pt1</span><span class="s4">, </span><span class="s1">pt2</span><span class="s4">, </span><span class="s1">pt3</span><span class="s4">, </span><span class="s1">pt4</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s1">_splitCubicAtT</span><span class="s4">(</span><span class="s1">a</span><span class="s4">, </span><span class="s1">b</span><span class="s4">, </span><span class="s1">c</span><span class="s4">, </span><span class="s1">d</span><span class="s4">, *</span><span class="s1">ts</span><span class="s4">)</span>


<span class="s4">@</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">locals</span><span class="s4">(</span>
    <span class="s1">pt1</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">complex</span><span class="s4">,</span>
    <span class="s1">pt2</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">complex</span><span class="s4">,</span>
    <span class="s1">pt3</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">complex</span><span class="s4">,</span>
    <span class="s1">pt4</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">complex</span><span class="s4">,</span>
    <span class="s1">a</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">complex</span><span class="s4">,</span>
    <span class="s1">b</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">complex</span><span class="s4">,</span>
    <span class="s1">c</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">complex</span><span class="s4">,</span>
    <span class="s1">d</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">complex</span><span class="s4">,</span>
<span class="s4">)</span>
<span class="s3">def </span><span class="s1">splitCubicAtTC</span><span class="s4">(</span><span class="s1">pt1</span><span class="s4">, </span><span class="s1">pt2</span><span class="s4">, </span><span class="s1">pt3</span><span class="s4">, </span><span class="s1">pt4</span><span class="s4">, *</span><span class="s1">ts</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Split a cubic Bezier curve at one or more values of t. 
 
    Args: 
        pt1,pt2,pt3,pt4: Control points of the Bezier as complex numbers.. 
        *ts: Positions at which to split the curve. 
 
    Yields: 
        Curve segments (each curve segment being four complex numbers). 
    &quot;&quot;&quot;</span>
    <span class="s1">a</span><span class="s4">, </span><span class="s1">b</span><span class="s4">, </span><span class="s1">c</span><span class="s4">, </span><span class="s1">d </span><span class="s4">= </span><span class="s1">calcCubicParametersC</span><span class="s4">(</span><span class="s1">pt1</span><span class="s4">, </span><span class="s1">pt2</span><span class="s4">, </span><span class="s1">pt3</span><span class="s4">, </span><span class="s1">pt4</span><span class="s4">)</span>
    <span class="s3">yield from </span><span class="s1">_splitCubicAtTC</span><span class="s4">(</span><span class="s1">a</span><span class="s4">, </span><span class="s1">b</span><span class="s4">, </span><span class="s1">c</span><span class="s4">, </span><span class="s1">d</span><span class="s4">, *</span><span class="s1">ts</span><span class="s4">)</span>


<span class="s4">@</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">returns</span><span class="s4">(</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">complex</span><span class="s4">)</span>
<span class="s4">@</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">locals</span><span class="s4">(</span>
    <span class="s1">t</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">double</span><span class="s4">,</span>
    <span class="s1">pt1</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">complex</span><span class="s4">,</span>
    <span class="s1">pt2</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">complex</span><span class="s4">,</span>
    <span class="s1">pt3</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">complex</span><span class="s4">,</span>
    <span class="s1">pt4</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">complex</span><span class="s4">,</span>
    <span class="s1">pointAtT</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">complex</span><span class="s4">,</span>
    <span class="s1">off1</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">complex</span><span class="s4">,</span>
    <span class="s1">off2</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">complex</span><span class="s4">,</span>
<span class="s4">)</span>
<span class="s4">@</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">locals</span><span class="s4">(</span>
    <span class="s1">t2</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">double</span><span class="s4">, </span><span class="s1">_1_t</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">double</span><span class="s4">, </span><span class="s1">_1_t_2</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">double</span><span class="s4">, </span><span class="s1">_2_t_1_t</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">double</span>
<span class="s4">)</span>
<span class="s3">def </span><span class="s1">splitCubicIntoTwoAtTC</span><span class="s4">(</span><span class="s1">pt1</span><span class="s4">, </span><span class="s1">pt2</span><span class="s4">, </span><span class="s1">pt3</span><span class="s4">, </span><span class="s1">pt4</span><span class="s4">, </span><span class="s1">t</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Split a cubic Bezier curve at t. 
 
    Args: 
        pt1,pt2,pt3,pt4: Control points of the Bezier as complex numbers. 
        t: Position at which to split the curve. 
 
    Returns: 
        A tuple of two curve segments (each curve segment being four complex numbers). 
    &quot;&quot;&quot;</span>
    <span class="s1">t2 </span><span class="s4">= </span><span class="s1">t </span><span class="s4">* </span><span class="s1">t</span>
    <span class="s1">_1_t </span><span class="s4">= </span><span class="s5">1 </span><span class="s4">- </span><span class="s1">t</span>
    <span class="s1">_1_t_2 </span><span class="s4">= </span><span class="s1">_1_t </span><span class="s4">* </span><span class="s1">_1_t</span>
    <span class="s1">_2_t_1_t </span><span class="s4">= </span><span class="s5">2 </span><span class="s4">* </span><span class="s1">t </span><span class="s4">* </span><span class="s1">_1_t</span>
    <span class="s1">pointAtT </span><span class="s4">= (</span>
        <span class="s1">_1_t_2 </span><span class="s4">* </span><span class="s1">_1_t </span><span class="s4">* </span><span class="s1">pt1 </span><span class="s4">+ </span><span class="s5">3 </span><span class="s4">* (</span><span class="s1">_1_t_2 </span><span class="s4">* </span><span class="s1">t </span><span class="s4">* </span><span class="s1">pt2 </span><span class="s4">+ </span><span class="s1">_1_t </span><span class="s4">* </span><span class="s1">t2 </span><span class="s4">* </span><span class="s1">pt3</span><span class="s4">) + </span><span class="s1">t2 </span><span class="s4">* </span><span class="s1">t </span><span class="s4">* </span><span class="s1">pt4</span>
    <span class="s4">)</span>
    <span class="s1">off1 </span><span class="s4">= </span><span class="s1">_1_t_2 </span><span class="s4">* </span><span class="s1">pt1 </span><span class="s4">+ </span><span class="s1">_2_t_1_t </span><span class="s4">* </span><span class="s1">pt2 </span><span class="s4">+ </span><span class="s1">t2 </span><span class="s4">* </span><span class="s1">pt3</span>
    <span class="s1">off2 </span><span class="s4">= </span><span class="s1">_1_t_2 </span><span class="s4">* </span><span class="s1">pt2 </span><span class="s4">+ </span><span class="s1">_2_t_1_t </span><span class="s4">* </span><span class="s1">pt3 </span><span class="s4">+ </span><span class="s1">t2 </span><span class="s4">* </span><span class="s1">pt4</span>

    <span class="s1">pt2 </span><span class="s4">= </span><span class="s1">pt1 </span><span class="s4">+ (</span><span class="s1">pt2 </span><span class="s4">- </span><span class="s1">pt1</span><span class="s4">) * </span><span class="s1">t</span>
    <span class="s1">pt3 </span><span class="s4">= </span><span class="s1">pt4 </span><span class="s4">+ (</span><span class="s1">pt3 </span><span class="s4">- </span><span class="s1">pt4</span><span class="s4">) * </span><span class="s1">_1_t</span>

    <span class="s3">return </span><span class="s4">((</span><span class="s1">pt1</span><span class="s4">, </span><span class="s1">pt2</span><span class="s4">, </span><span class="s1">off1</span><span class="s4">, </span><span class="s1">pointAtT</span><span class="s4">), (</span><span class="s1">pointAtT</span><span class="s4">, </span><span class="s1">off2</span><span class="s4">, </span><span class="s1">pt3</span><span class="s4">, </span><span class="s1">pt4</span><span class="s4">))</span>


<span class="s3">def </span><span class="s1">_splitQuadraticAtT</span><span class="s4">(</span><span class="s1">a</span><span class="s4">, </span><span class="s1">b</span><span class="s4">, </span><span class="s1">c</span><span class="s4">, *</span><span class="s1">ts</span><span class="s4">):</span>
    <span class="s1">ts </span><span class="s4">= </span><span class="s1">list</span><span class="s4">(</span><span class="s1">ts</span><span class="s4">)</span>
    <span class="s1">segments </span><span class="s4">= []</span>
    <span class="s1">ts</span><span class="s4">.</span><span class="s1">insert</span><span class="s4">(</span><span class="s5">0</span><span class="s4">, </span><span class="s5">0.0</span><span class="s4">)</span>
    <span class="s1">ts</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s5">1.0</span><span class="s4">)</span>
    <span class="s1">ax</span><span class="s4">, </span><span class="s1">ay </span><span class="s4">= </span><span class="s1">a</span>
    <span class="s1">bx</span><span class="s4">, </span><span class="s1">by </span><span class="s4">= </span><span class="s1">b</span>
    <span class="s1">cx</span><span class="s4">, </span><span class="s1">cy </span><span class="s4">= </span><span class="s1">c</span>
    <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range</span><span class="s4">(</span><span class="s1">len</span><span class="s4">(</span><span class="s1">ts</span><span class="s4">) - </span><span class="s5">1</span><span class="s4">):</span>
        <span class="s1">t1 </span><span class="s4">= </span><span class="s1">ts</span><span class="s4">[</span><span class="s1">i</span><span class="s4">]</span>
        <span class="s1">t2 </span><span class="s4">= </span><span class="s1">ts</span><span class="s4">[</span><span class="s1">i </span><span class="s4">+ </span><span class="s5">1</span><span class="s4">]</span>
        <span class="s1">delta </span><span class="s4">= </span><span class="s1">t2 </span><span class="s4">- </span><span class="s1">t1</span>
        <span class="s0"># calc new a, b and c</span>
        <span class="s1">delta_2 </span><span class="s4">= </span><span class="s1">delta </span><span class="s4">* </span><span class="s1">delta</span>
        <span class="s1">a1x </span><span class="s4">= </span><span class="s1">ax </span><span class="s4">* </span><span class="s1">delta_2</span>
        <span class="s1">a1y </span><span class="s4">= </span><span class="s1">ay </span><span class="s4">* </span><span class="s1">delta_2</span>
        <span class="s1">b1x </span><span class="s4">= (</span><span class="s5">2 </span><span class="s4">* </span><span class="s1">ax </span><span class="s4">* </span><span class="s1">t1 </span><span class="s4">+ </span><span class="s1">bx</span><span class="s4">) * </span><span class="s1">delta</span>
        <span class="s1">b1y </span><span class="s4">= (</span><span class="s5">2 </span><span class="s4">* </span><span class="s1">ay </span><span class="s4">* </span><span class="s1">t1 </span><span class="s4">+ </span><span class="s1">by</span><span class="s4">) * </span><span class="s1">delta</span>
        <span class="s1">t1_2 </span><span class="s4">= </span><span class="s1">t1 </span><span class="s4">* </span><span class="s1">t1</span>
        <span class="s1">c1x </span><span class="s4">= </span><span class="s1">ax </span><span class="s4">* </span><span class="s1">t1_2 </span><span class="s4">+ </span><span class="s1">bx </span><span class="s4">* </span><span class="s1">t1 </span><span class="s4">+ </span><span class="s1">cx</span>
        <span class="s1">c1y </span><span class="s4">= </span><span class="s1">ay </span><span class="s4">* </span><span class="s1">t1_2 </span><span class="s4">+ </span><span class="s1">by </span><span class="s4">* </span><span class="s1">t1 </span><span class="s4">+ </span><span class="s1">cy</span>

        <span class="s1">pt1</span><span class="s4">, </span><span class="s1">pt2</span><span class="s4">, </span><span class="s1">pt3 </span><span class="s4">= </span><span class="s1">calcQuadraticPoints</span><span class="s4">((</span><span class="s1">a1x</span><span class="s4">, </span><span class="s1">a1y</span><span class="s4">), (</span><span class="s1">b1x</span><span class="s4">, </span><span class="s1">b1y</span><span class="s4">), (</span><span class="s1">c1x</span><span class="s4">, </span><span class="s1">c1y</span><span class="s4">))</span>
        <span class="s1">segments</span><span class="s4">.</span><span class="s1">append</span><span class="s4">((</span><span class="s1">pt1</span><span class="s4">, </span><span class="s1">pt2</span><span class="s4">, </span><span class="s1">pt3</span><span class="s4">))</span>
    <span class="s3">return </span><span class="s1">segments</span>


<span class="s3">def </span><span class="s1">_splitCubicAtT</span><span class="s4">(</span><span class="s1">a</span><span class="s4">, </span><span class="s1">b</span><span class="s4">, </span><span class="s1">c</span><span class="s4">, </span><span class="s1">d</span><span class="s4">, *</span><span class="s1">ts</span><span class="s4">):</span>
    <span class="s1">ts </span><span class="s4">= </span><span class="s1">list</span><span class="s4">(</span><span class="s1">ts</span><span class="s4">)</span>
    <span class="s1">ts</span><span class="s4">.</span><span class="s1">insert</span><span class="s4">(</span><span class="s5">0</span><span class="s4">, </span><span class="s5">0.0</span><span class="s4">)</span>
    <span class="s1">ts</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s5">1.0</span><span class="s4">)</span>
    <span class="s1">segments </span><span class="s4">= []</span>
    <span class="s1">ax</span><span class="s4">, </span><span class="s1">ay </span><span class="s4">= </span><span class="s1">a</span>
    <span class="s1">bx</span><span class="s4">, </span><span class="s1">by </span><span class="s4">= </span><span class="s1">b</span>
    <span class="s1">cx</span><span class="s4">, </span><span class="s1">cy </span><span class="s4">= </span><span class="s1">c</span>
    <span class="s1">dx</span><span class="s4">, </span><span class="s1">dy </span><span class="s4">= </span><span class="s1">d</span>
    <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range</span><span class="s4">(</span><span class="s1">len</span><span class="s4">(</span><span class="s1">ts</span><span class="s4">) - </span><span class="s5">1</span><span class="s4">):</span>
        <span class="s1">t1 </span><span class="s4">= </span><span class="s1">ts</span><span class="s4">[</span><span class="s1">i</span><span class="s4">]</span>
        <span class="s1">t2 </span><span class="s4">= </span><span class="s1">ts</span><span class="s4">[</span><span class="s1">i </span><span class="s4">+ </span><span class="s5">1</span><span class="s4">]</span>
        <span class="s1">delta </span><span class="s4">= </span><span class="s1">t2 </span><span class="s4">- </span><span class="s1">t1</span>

        <span class="s1">delta_2 </span><span class="s4">= </span><span class="s1">delta </span><span class="s4">* </span><span class="s1">delta</span>
        <span class="s1">delta_3 </span><span class="s4">= </span><span class="s1">delta </span><span class="s4">* </span><span class="s1">delta_2</span>
        <span class="s1">t1_2 </span><span class="s4">= </span><span class="s1">t1 </span><span class="s4">* </span><span class="s1">t1</span>
        <span class="s1">t1_3 </span><span class="s4">= </span><span class="s1">t1 </span><span class="s4">* </span><span class="s1">t1_2</span>

        <span class="s0"># calc new a, b, c and d</span>
        <span class="s1">a1x </span><span class="s4">= </span><span class="s1">ax </span><span class="s4">* </span><span class="s1">delta_3</span>
        <span class="s1">a1y </span><span class="s4">= </span><span class="s1">ay </span><span class="s4">* </span><span class="s1">delta_3</span>
        <span class="s1">b1x </span><span class="s4">= (</span><span class="s5">3 </span><span class="s4">* </span><span class="s1">ax </span><span class="s4">* </span><span class="s1">t1 </span><span class="s4">+ </span><span class="s1">bx</span><span class="s4">) * </span><span class="s1">delta_2</span>
        <span class="s1">b1y </span><span class="s4">= (</span><span class="s5">3 </span><span class="s4">* </span><span class="s1">ay </span><span class="s4">* </span><span class="s1">t1 </span><span class="s4">+ </span><span class="s1">by</span><span class="s4">) * </span><span class="s1">delta_2</span>
        <span class="s1">c1x </span><span class="s4">= (</span><span class="s5">2 </span><span class="s4">* </span><span class="s1">bx </span><span class="s4">* </span><span class="s1">t1 </span><span class="s4">+ </span><span class="s1">cx </span><span class="s4">+ </span><span class="s5">3 </span><span class="s4">* </span><span class="s1">ax </span><span class="s4">* </span><span class="s1">t1_2</span><span class="s4">) * </span><span class="s1">delta</span>
        <span class="s1">c1y </span><span class="s4">= (</span><span class="s5">2 </span><span class="s4">* </span><span class="s1">by </span><span class="s4">* </span><span class="s1">t1 </span><span class="s4">+ </span><span class="s1">cy </span><span class="s4">+ </span><span class="s5">3 </span><span class="s4">* </span><span class="s1">ay </span><span class="s4">* </span><span class="s1">t1_2</span><span class="s4">) * </span><span class="s1">delta</span>
        <span class="s1">d1x </span><span class="s4">= </span><span class="s1">ax </span><span class="s4">* </span><span class="s1">t1_3 </span><span class="s4">+ </span><span class="s1">bx </span><span class="s4">* </span><span class="s1">t1_2 </span><span class="s4">+ </span><span class="s1">cx </span><span class="s4">* </span><span class="s1">t1 </span><span class="s4">+ </span><span class="s1">dx</span>
        <span class="s1">d1y </span><span class="s4">= </span><span class="s1">ay </span><span class="s4">* </span><span class="s1">t1_3 </span><span class="s4">+ </span><span class="s1">by </span><span class="s4">* </span><span class="s1">t1_2 </span><span class="s4">+ </span><span class="s1">cy </span><span class="s4">* </span><span class="s1">t1 </span><span class="s4">+ </span><span class="s1">dy</span>
        <span class="s1">pt1</span><span class="s4">, </span><span class="s1">pt2</span><span class="s4">, </span><span class="s1">pt3</span><span class="s4">, </span><span class="s1">pt4 </span><span class="s4">= </span><span class="s1">calcCubicPoints</span><span class="s4">(</span>
            <span class="s4">(</span><span class="s1">a1x</span><span class="s4">, </span><span class="s1">a1y</span><span class="s4">), (</span><span class="s1">b1x</span><span class="s4">, </span><span class="s1">b1y</span><span class="s4">), (</span><span class="s1">c1x</span><span class="s4">, </span><span class="s1">c1y</span><span class="s4">), (</span><span class="s1">d1x</span><span class="s4">, </span><span class="s1">d1y</span><span class="s4">)</span>
        <span class="s4">)</span>
        <span class="s1">segments</span><span class="s4">.</span><span class="s1">append</span><span class="s4">((</span><span class="s1">pt1</span><span class="s4">, </span><span class="s1">pt2</span><span class="s4">, </span><span class="s1">pt3</span><span class="s4">, </span><span class="s1">pt4</span><span class="s4">))</span>
    <span class="s3">return </span><span class="s1">segments</span>


<span class="s4">@</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">locals</span><span class="s4">(</span>
    <span class="s1">a</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">complex</span><span class="s4">,</span>
    <span class="s1">b</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">complex</span><span class="s4">,</span>
    <span class="s1">c</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">complex</span><span class="s4">,</span>
    <span class="s1">d</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">complex</span><span class="s4">,</span>
    <span class="s1">t1</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">double</span><span class="s4">,</span>
    <span class="s1">t2</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">double</span><span class="s4">,</span>
    <span class="s1">delta</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">double</span><span class="s4">,</span>
    <span class="s1">delta_2</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">double</span><span class="s4">,</span>
    <span class="s1">delta_3</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">double</span><span class="s4">,</span>
    <span class="s1">a1</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">complex</span><span class="s4">,</span>
    <span class="s1">b1</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">complex</span><span class="s4">,</span>
    <span class="s1">c1</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">complex</span><span class="s4">,</span>
    <span class="s1">d1</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">complex</span><span class="s4">,</span>
<span class="s4">)</span>
<span class="s3">def </span><span class="s1">_splitCubicAtTC</span><span class="s4">(</span><span class="s1">a</span><span class="s4">, </span><span class="s1">b</span><span class="s4">, </span><span class="s1">c</span><span class="s4">, </span><span class="s1">d</span><span class="s4">, *</span><span class="s1">ts</span><span class="s4">):</span>
    <span class="s1">ts </span><span class="s4">= </span><span class="s1">list</span><span class="s4">(</span><span class="s1">ts</span><span class="s4">)</span>
    <span class="s1">ts</span><span class="s4">.</span><span class="s1">insert</span><span class="s4">(</span><span class="s5">0</span><span class="s4">, </span><span class="s5">0.0</span><span class="s4">)</span>
    <span class="s1">ts</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s5">1.0</span><span class="s4">)</span>
    <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range</span><span class="s4">(</span><span class="s1">len</span><span class="s4">(</span><span class="s1">ts</span><span class="s4">) - </span><span class="s5">1</span><span class="s4">):</span>
        <span class="s1">t1 </span><span class="s4">= </span><span class="s1">ts</span><span class="s4">[</span><span class="s1">i</span><span class="s4">]</span>
        <span class="s1">t2 </span><span class="s4">= </span><span class="s1">ts</span><span class="s4">[</span><span class="s1">i </span><span class="s4">+ </span><span class="s5">1</span><span class="s4">]</span>
        <span class="s1">delta </span><span class="s4">= </span><span class="s1">t2 </span><span class="s4">- </span><span class="s1">t1</span>

        <span class="s1">delta_2 </span><span class="s4">= </span><span class="s1">delta </span><span class="s4">* </span><span class="s1">delta</span>
        <span class="s1">delta_3 </span><span class="s4">= </span><span class="s1">delta </span><span class="s4">* </span><span class="s1">delta_2</span>
        <span class="s1">t1_2 </span><span class="s4">= </span><span class="s1">t1 </span><span class="s4">* </span><span class="s1">t1</span>
        <span class="s1">t1_3 </span><span class="s4">= </span><span class="s1">t1 </span><span class="s4">* </span><span class="s1">t1_2</span>

        <span class="s0"># calc new a, b, c and d</span>
        <span class="s1">a1 </span><span class="s4">= </span><span class="s1">a </span><span class="s4">* </span><span class="s1">delta_3</span>
        <span class="s1">b1 </span><span class="s4">= (</span><span class="s5">3 </span><span class="s4">* </span><span class="s1">a </span><span class="s4">* </span><span class="s1">t1 </span><span class="s4">+ </span><span class="s1">b</span><span class="s4">) * </span><span class="s1">delta_2</span>
        <span class="s1">c1 </span><span class="s4">= (</span><span class="s5">2 </span><span class="s4">* </span><span class="s1">b </span><span class="s4">* </span><span class="s1">t1 </span><span class="s4">+ </span><span class="s1">c </span><span class="s4">+ </span><span class="s5">3 </span><span class="s4">* </span><span class="s1">a </span><span class="s4">* </span><span class="s1">t1_2</span><span class="s4">) * </span><span class="s1">delta</span>
        <span class="s1">d1 </span><span class="s4">= </span><span class="s1">a </span><span class="s4">* </span><span class="s1">t1_3 </span><span class="s4">+ </span><span class="s1">b </span><span class="s4">* </span><span class="s1">t1_2 </span><span class="s4">+ </span><span class="s1">c </span><span class="s4">* </span><span class="s1">t1 </span><span class="s4">+ </span><span class="s1">d</span>
        <span class="s1">pt1</span><span class="s4">, </span><span class="s1">pt2</span><span class="s4">, </span><span class="s1">pt3</span><span class="s4">, </span><span class="s1">pt4 </span><span class="s4">= </span><span class="s1">calcCubicPointsC</span><span class="s4">(</span><span class="s1">a1</span><span class="s4">, </span><span class="s1">b1</span><span class="s4">, </span><span class="s1">c1</span><span class="s4">, </span><span class="s1">d1</span><span class="s4">)</span>
        <span class="s3">yield </span><span class="s4">(</span><span class="s1">pt1</span><span class="s4">, </span><span class="s1">pt2</span><span class="s4">, </span><span class="s1">pt3</span><span class="s4">, </span><span class="s1">pt4</span><span class="s4">)</span>


<span class="s0">#</span>
<span class="s0"># Equation solvers.</span>
<span class="s0">#</span>

<span class="s3">from </span><span class="s1">math </span><span class="s3">import </span><span class="s1">sqrt</span><span class="s4">, </span><span class="s1">acos</span><span class="s4">, </span><span class="s1">cos</span><span class="s4">, </span><span class="s1">pi</span>


<span class="s3">def </span><span class="s1">solveQuadratic</span><span class="s4">(</span><span class="s1">a</span><span class="s4">, </span><span class="s1">b</span><span class="s4">, </span><span class="s1">c</span><span class="s4">, </span><span class="s1">sqrt</span><span class="s4">=</span><span class="s1">sqrt</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Solve a quadratic equation. 
 
    Solves *a*x*x + b*x + c = 0* where a, b and c are real. 
 
    Args: 
        a: coefficient of *x²* 
        b: coefficient of *x* 
        c: constant term 
 
    Returns: 
        A list of roots. Note that the returned list is neither guaranteed to 
        be sorted nor to contain unique values! 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">abs</span><span class="s4">(</span><span class="s1">a</span><span class="s4">) &lt; </span><span class="s1">epsilon</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">abs</span><span class="s4">(</span><span class="s1">b</span><span class="s4">) &lt; </span><span class="s1">epsilon</span><span class="s4">:</span>
            <span class="s0"># We have a non-equation; therefore, we have no valid solution</span>
            <span class="s1">roots </span><span class="s4">= []</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s0"># We have a linear equation with 1 root.</span>
            <span class="s1">roots </span><span class="s4">= [-</span><span class="s1">c </span><span class="s4">/ </span><span class="s1">b</span><span class="s4">]</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s0"># We have a true quadratic equation.  Apply the quadratic formula to find two roots.</span>
        <span class="s1">DD </span><span class="s4">= </span><span class="s1">b </span><span class="s4">* </span><span class="s1">b </span><span class="s4">- </span><span class="s5">4.0 </span><span class="s4">* </span><span class="s1">a </span><span class="s4">* </span><span class="s1">c</span>
        <span class="s3">if </span><span class="s1">DD </span><span class="s4">&gt;= </span><span class="s5">0.0</span><span class="s4">:</span>
            <span class="s1">rDD </span><span class="s4">= </span><span class="s1">sqrt</span><span class="s4">(</span><span class="s1">DD</span><span class="s4">)</span>
            <span class="s1">roots </span><span class="s4">= [(-</span><span class="s1">b </span><span class="s4">+ </span><span class="s1">rDD</span><span class="s4">) / </span><span class="s5">2.0 </span><span class="s4">/ </span><span class="s1">a</span><span class="s4">, (-</span><span class="s1">b </span><span class="s4">- </span><span class="s1">rDD</span><span class="s4">) / </span><span class="s5">2.0 </span><span class="s4">/ </span><span class="s1">a</span><span class="s4">]</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s0"># complex roots, ignore</span>
            <span class="s1">roots </span><span class="s4">= []</span>
    <span class="s3">return </span><span class="s1">roots</span>


<span class="s3">def </span><span class="s1">solveCubic</span><span class="s4">(</span><span class="s1">a</span><span class="s4">, </span><span class="s1">b</span><span class="s4">, </span><span class="s1">c</span><span class="s4">, </span><span class="s1">d</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Solve a cubic equation. 
 
    Solves *a*x*x*x + b*x*x + c*x + d = 0* where a, b, c and d are real. 
 
    Args: 
        a: coefficient of *x³* 
        b: coefficient of *x²* 
        c: coefficient of *x* 
        d: constant term 
 
    Returns: 
        A list of roots. Note that the returned list is neither guaranteed to 
        be sorted nor to contain unique values! 
 
    Examples:: 
 
        &gt;&gt;&gt; solveCubic(1, 1, -6, 0) 
        [-3.0, -0.0, 2.0] 
        &gt;&gt;&gt; solveCubic(-10.0, -9.0, 48.0, -29.0) 
        [-2.9, 1.0, 1.0] 
        &gt;&gt;&gt; solveCubic(-9.875, -9.0, 47.625, -28.75) 
        [-2.911392, 1.0, 1.0] 
        &gt;&gt;&gt; solveCubic(1.0, -4.5, 6.75, -3.375) 
        [1.5, 1.5, 1.5] 
        &gt;&gt;&gt; solveCubic(-12.0, 18.0, -9.0, 1.50023651123) 
        [0.5, 0.5, 0.5] 
        &gt;&gt;&gt; solveCubic( 
        ...     9.0, 0.0, 0.0, -7.62939453125e-05 
        ... ) == [-0.0, -0.0, -0.0] 
        True 
    &quot;&quot;&quot;</span>
    <span class="s0">#</span>
    <span class="s0"># adapted from:</span>
    <span class="s0">#   CUBIC.C - Solve a cubic polynomial</span>
    <span class="s0">#   public domain by Ross Cottrell</span>
    <span class="s0"># found at: http://www.strangecreations.com/library/snippets/Cubic.C</span>
    <span class="s0">#</span>
    <span class="s3">if </span><span class="s1">abs</span><span class="s4">(</span><span class="s1">a</span><span class="s4">) &lt; </span><span class="s1">epsilon</span><span class="s4">:</span>
        <span class="s0"># don't just test for zero; for very small values of 'a' solveCubic()</span>
        <span class="s0"># returns unreliable results, so we fall back to quad.</span>
        <span class="s3">return </span><span class="s1">solveQuadratic</span><span class="s4">(</span><span class="s1">b</span><span class="s4">, </span><span class="s1">c</span><span class="s4">, </span><span class="s1">d</span><span class="s4">)</span>
    <span class="s1">a </span><span class="s4">= </span><span class="s1">float</span><span class="s4">(</span><span class="s1">a</span><span class="s4">)</span>
    <span class="s1">a1 </span><span class="s4">= </span><span class="s1">b </span><span class="s4">/ </span><span class="s1">a</span>
    <span class="s1">a2 </span><span class="s4">= </span><span class="s1">c </span><span class="s4">/ </span><span class="s1">a</span>
    <span class="s1">a3 </span><span class="s4">= </span><span class="s1">d </span><span class="s4">/ </span><span class="s1">a</span>

    <span class="s1">Q </span><span class="s4">= (</span><span class="s1">a1 </span><span class="s4">* </span><span class="s1">a1 </span><span class="s4">- </span><span class="s5">3.0 </span><span class="s4">* </span><span class="s1">a2</span><span class="s4">) / </span><span class="s5">9.0</span>
    <span class="s1">R </span><span class="s4">= (</span><span class="s5">2.0 </span><span class="s4">* </span><span class="s1">a1 </span><span class="s4">* </span><span class="s1">a1 </span><span class="s4">* </span><span class="s1">a1 </span><span class="s4">- </span><span class="s5">9.0 </span><span class="s4">* </span><span class="s1">a1 </span><span class="s4">* </span><span class="s1">a2 </span><span class="s4">+ </span><span class="s5">27.0 </span><span class="s4">* </span><span class="s1">a3</span><span class="s4">) / </span><span class="s5">54.0</span>

    <span class="s1">R2 </span><span class="s4">= </span><span class="s1">R </span><span class="s4">* </span><span class="s1">R</span>
    <span class="s1">Q3 </span><span class="s4">= </span><span class="s1">Q </span><span class="s4">* </span><span class="s1">Q </span><span class="s4">* </span><span class="s1">Q</span>
    <span class="s1">R2 </span><span class="s4">= </span><span class="s5">0 </span><span class="s3">if </span><span class="s1">R2 </span><span class="s4">&lt; </span><span class="s1">epsilon </span><span class="s3">else </span><span class="s1">R2</span>
    <span class="s1">Q3 </span><span class="s4">= </span><span class="s5">0 </span><span class="s3">if </span><span class="s1">abs</span><span class="s4">(</span><span class="s1">Q3</span><span class="s4">) &lt; </span><span class="s1">epsilon </span><span class="s3">else </span><span class="s1">Q3</span>

    <span class="s1">R2_Q3 </span><span class="s4">= </span><span class="s1">R2 </span><span class="s4">- </span><span class="s1">Q3</span>

    <span class="s3">if </span><span class="s1">R2 </span><span class="s4">== </span><span class="s5">0.0 </span><span class="s3">and </span><span class="s1">Q3 </span><span class="s4">== </span><span class="s5">0.0</span><span class="s4">:</span>
        <span class="s1">x </span><span class="s4">= </span><span class="s1">round</span><span class="s4">(-</span><span class="s1">a1 </span><span class="s4">/ </span><span class="s5">3.0</span><span class="s4">, </span><span class="s1">epsilonDigits</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s4">[</span><span class="s1">x</span><span class="s4">, </span><span class="s1">x</span><span class="s4">, </span><span class="s1">x</span><span class="s4">]</span>
    <span class="s3">elif </span><span class="s1">R2_Q3 </span><span class="s4">&lt;= </span><span class="s1">epsilon </span><span class="s4">* </span><span class="s5">0.5</span><span class="s4">:</span>
        <span class="s0"># The epsilon * .5 above ensures that Q3 is not zero.</span>
        <span class="s1">theta </span><span class="s4">= </span><span class="s1">acos</span><span class="s4">(</span><span class="s1">max</span><span class="s4">(</span><span class="s1">min</span><span class="s4">(</span><span class="s1">R </span><span class="s4">/ </span><span class="s1">sqrt</span><span class="s4">(</span><span class="s1">Q3</span><span class="s4">), </span><span class="s5">1.0</span><span class="s4">), -</span><span class="s5">1.0</span><span class="s4">))</span>
        <span class="s1">rQ2 </span><span class="s4">= -</span><span class="s5">2.0 </span><span class="s4">* </span><span class="s1">sqrt</span><span class="s4">(</span><span class="s1">Q</span><span class="s4">)</span>
        <span class="s1">a1_3 </span><span class="s4">= </span><span class="s1">a1 </span><span class="s4">/ </span><span class="s5">3.0</span>
        <span class="s1">x0 </span><span class="s4">= </span><span class="s1">rQ2 </span><span class="s4">* </span><span class="s1">cos</span><span class="s4">(</span><span class="s1">theta </span><span class="s4">/ </span><span class="s5">3.0</span><span class="s4">) - </span><span class="s1">a1_3</span>
        <span class="s1">x1 </span><span class="s4">= </span><span class="s1">rQ2 </span><span class="s4">* </span><span class="s1">cos</span><span class="s4">((</span><span class="s1">theta </span><span class="s4">+ </span><span class="s5">2.0 </span><span class="s4">* </span><span class="s1">pi</span><span class="s4">) / </span><span class="s5">3.0</span><span class="s4">) - </span><span class="s1">a1_3</span>
        <span class="s1">x2 </span><span class="s4">= </span><span class="s1">rQ2 </span><span class="s4">* </span><span class="s1">cos</span><span class="s4">((</span><span class="s1">theta </span><span class="s4">+ </span><span class="s5">4.0 </span><span class="s4">* </span><span class="s1">pi</span><span class="s4">) / </span><span class="s5">3.0</span><span class="s4">) - </span><span class="s1">a1_3</span>
        <span class="s1">x0</span><span class="s4">, </span><span class="s1">x1</span><span class="s4">, </span><span class="s1">x2 </span><span class="s4">= </span><span class="s1">sorted</span><span class="s4">([</span><span class="s1">x0</span><span class="s4">, </span><span class="s1">x1</span><span class="s4">, </span><span class="s1">x2</span><span class="s4">])</span>
        <span class="s0"># Merge roots that are close-enough</span>
        <span class="s3">if </span><span class="s1">x1 </span><span class="s4">- </span><span class="s1">x0 </span><span class="s4">&lt; </span><span class="s1">epsilon </span><span class="s3">and </span><span class="s1">x2 </span><span class="s4">- </span><span class="s1">x1 </span><span class="s4">&lt; </span><span class="s1">epsilon</span><span class="s4">:</span>
            <span class="s1">x0 </span><span class="s4">= </span><span class="s1">x1 </span><span class="s4">= </span><span class="s1">x2 </span><span class="s4">= </span><span class="s1">round</span><span class="s4">((</span><span class="s1">x0 </span><span class="s4">+ </span><span class="s1">x1 </span><span class="s4">+ </span><span class="s1">x2</span><span class="s4">) / </span><span class="s5">3.0</span><span class="s4">, </span><span class="s1">epsilonDigits</span><span class="s4">)</span>
        <span class="s3">elif </span><span class="s1">x1 </span><span class="s4">- </span><span class="s1">x0 </span><span class="s4">&lt; </span><span class="s1">epsilon</span><span class="s4">:</span>
            <span class="s1">x0 </span><span class="s4">= </span><span class="s1">x1 </span><span class="s4">= </span><span class="s1">round</span><span class="s4">((</span><span class="s1">x0 </span><span class="s4">+ </span><span class="s1">x1</span><span class="s4">) / </span><span class="s5">2.0</span><span class="s4">, </span><span class="s1">epsilonDigits</span><span class="s4">)</span>
            <span class="s1">x2 </span><span class="s4">= </span><span class="s1">round</span><span class="s4">(</span><span class="s1">x2</span><span class="s4">, </span><span class="s1">epsilonDigits</span><span class="s4">)</span>
        <span class="s3">elif </span><span class="s1">x2 </span><span class="s4">- </span><span class="s1">x1 </span><span class="s4">&lt; </span><span class="s1">epsilon</span><span class="s4">:</span>
            <span class="s1">x0 </span><span class="s4">= </span><span class="s1">round</span><span class="s4">(</span><span class="s1">x0</span><span class="s4">, </span><span class="s1">epsilonDigits</span><span class="s4">)</span>
            <span class="s1">x1 </span><span class="s4">= </span><span class="s1">x2 </span><span class="s4">= </span><span class="s1">round</span><span class="s4">((</span><span class="s1">x1 </span><span class="s4">+ </span><span class="s1">x2</span><span class="s4">) / </span><span class="s5">2.0</span><span class="s4">, </span><span class="s1">epsilonDigits</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">x0 </span><span class="s4">= </span><span class="s1">round</span><span class="s4">(</span><span class="s1">x0</span><span class="s4">, </span><span class="s1">epsilonDigits</span><span class="s4">)</span>
            <span class="s1">x1 </span><span class="s4">= </span><span class="s1">round</span><span class="s4">(</span><span class="s1">x1</span><span class="s4">, </span><span class="s1">epsilonDigits</span><span class="s4">)</span>
            <span class="s1">x2 </span><span class="s4">= </span><span class="s1">round</span><span class="s4">(</span><span class="s1">x2</span><span class="s4">, </span><span class="s1">epsilonDigits</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s4">[</span><span class="s1">x0</span><span class="s4">, </span><span class="s1">x1</span><span class="s4">, </span><span class="s1">x2</span><span class="s4">]</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">x </span><span class="s4">= </span><span class="s1">pow</span><span class="s4">(</span><span class="s1">sqrt</span><span class="s4">(</span><span class="s1">R2_Q3</span><span class="s4">) + </span><span class="s1">abs</span><span class="s4">(</span><span class="s1">R</span><span class="s4">), </span><span class="s5">1 </span><span class="s4">/ </span><span class="s5">3.0</span><span class="s4">)</span>
        <span class="s1">x </span><span class="s4">= </span><span class="s1">x </span><span class="s4">+ </span><span class="s1">Q </span><span class="s4">/ </span><span class="s1">x</span>
        <span class="s3">if </span><span class="s1">R </span><span class="s4">&gt;= </span><span class="s5">0.0</span><span class="s4">:</span>
            <span class="s1">x </span><span class="s4">= -</span><span class="s1">x</span>
        <span class="s1">x </span><span class="s4">= </span><span class="s1">round</span><span class="s4">(</span><span class="s1">x </span><span class="s4">- </span><span class="s1">a1 </span><span class="s4">/ </span><span class="s5">3.0</span><span class="s4">, </span><span class="s1">epsilonDigits</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s4">[</span><span class="s1">x</span><span class="s4">]</span>


<span class="s0">#</span>
<span class="s0"># Conversion routines for points to parameters and vice versa</span>
<span class="s0">#</span>


<span class="s3">def </span><span class="s1">calcQuadraticParameters</span><span class="s4">(</span><span class="s1">pt1</span><span class="s4">, </span><span class="s1">pt2</span><span class="s4">, </span><span class="s1">pt3</span><span class="s4">):</span>
    <span class="s1">x2</span><span class="s4">, </span><span class="s1">y2 </span><span class="s4">= </span><span class="s1">pt2</span>
    <span class="s1">x3</span><span class="s4">, </span><span class="s1">y3 </span><span class="s4">= </span><span class="s1">pt3</span>
    <span class="s1">cx</span><span class="s4">, </span><span class="s1">cy </span><span class="s4">= </span><span class="s1">pt1</span>
    <span class="s1">bx </span><span class="s4">= (</span><span class="s1">x2 </span><span class="s4">- </span><span class="s1">cx</span><span class="s4">) * </span><span class="s5">2.0</span>
    <span class="s1">by </span><span class="s4">= (</span><span class="s1">y2 </span><span class="s4">- </span><span class="s1">cy</span><span class="s4">) * </span><span class="s5">2.0</span>
    <span class="s1">ax </span><span class="s4">= </span><span class="s1">x3 </span><span class="s4">- </span><span class="s1">cx </span><span class="s4">- </span><span class="s1">bx</span>
    <span class="s1">ay </span><span class="s4">= </span><span class="s1">y3 </span><span class="s4">- </span><span class="s1">cy </span><span class="s4">- </span><span class="s1">by</span>
    <span class="s3">return </span><span class="s4">(</span><span class="s1">ax</span><span class="s4">, </span><span class="s1">ay</span><span class="s4">), (</span><span class="s1">bx</span><span class="s4">, </span><span class="s1">by</span><span class="s4">), (</span><span class="s1">cx</span><span class="s4">, </span><span class="s1">cy</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">calcCubicParameters</span><span class="s4">(</span><span class="s1">pt1</span><span class="s4">, </span><span class="s1">pt2</span><span class="s4">, </span><span class="s1">pt3</span><span class="s4">, </span><span class="s1">pt4</span><span class="s4">):</span>
    <span class="s1">x2</span><span class="s4">, </span><span class="s1">y2 </span><span class="s4">= </span><span class="s1">pt2</span>
    <span class="s1">x3</span><span class="s4">, </span><span class="s1">y3 </span><span class="s4">= </span><span class="s1">pt3</span>
    <span class="s1">x4</span><span class="s4">, </span><span class="s1">y4 </span><span class="s4">= </span><span class="s1">pt4</span>
    <span class="s1">dx</span><span class="s4">, </span><span class="s1">dy </span><span class="s4">= </span><span class="s1">pt1</span>
    <span class="s1">cx </span><span class="s4">= (</span><span class="s1">x2 </span><span class="s4">- </span><span class="s1">dx</span><span class="s4">) * </span><span class="s5">3.0</span>
    <span class="s1">cy </span><span class="s4">= (</span><span class="s1">y2 </span><span class="s4">- </span><span class="s1">dy</span><span class="s4">) * </span><span class="s5">3.0</span>
    <span class="s1">bx </span><span class="s4">= (</span><span class="s1">x3 </span><span class="s4">- </span><span class="s1">x2</span><span class="s4">) * </span><span class="s5">3.0 </span><span class="s4">- </span><span class="s1">cx</span>
    <span class="s1">by </span><span class="s4">= (</span><span class="s1">y3 </span><span class="s4">- </span><span class="s1">y2</span><span class="s4">) * </span><span class="s5">3.0 </span><span class="s4">- </span><span class="s1">cy</span>
    <span class="s1">ax </span><span class="s4">= </span><span class="s1">x4 </span><span class="s4">- </span><span class="s1">dx </span><span class="s4">- </span><span class="s1">cx </span><span class="s4">- </span><span class="s1">bx</span>
    <span class="s1">ay </span><span class="s4">= </span><span class="s1">y4 </span><span class="s4">- </span><span class="s1">dy </span><span class="s4">- </span><span class="s1">cy </span><span class="s4">- </span><span class="s1">by</span>
    <span class="s3">return </span><span class="s4">(</span><span class="s1">ax</span><span class="s4">, </span><span class="s1">ay</span><span class="s4">), (</span><span class="s1">bx</span><span class="s4">, </span><span class="s1">by</span><span class="s4">), (</span><span class="s1">cx</span><span class="s4">, </span><span class="s1">cy</span><span class="s4">), (</span><span class="s1">dx</span><span class="s4">, </span><span class="s1">dy</span><span class="s4">)</span>


<span class="s4">@</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">cfunc</span>
<span class="s4">@</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">inline</span>
<span class="s4">@</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">locals</span><span class="s4">(</span>
    <span class="s1">pt1</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">complex</span><span class="s4">,</span>
    <span class="s1">pt2</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">complex</span><span class="s4">,</span>
    <span class="s1">pt3</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">complex</span><span class="s4">,</span>
    <span class="s1">pt4</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">complex</span><span class="s4">,</span>
    <span class="s1">a</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">complex</span><span class="s4">,</span>
    <span class="s1">b</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">complex</span><span class="s4">,</span>
    <span class="s1">c</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">complex</span><span class="s4">,</span>
<span class="s4">)</span>
<span class="s3">def </span><span class="s1">calcCubicParametersC</span><span class="s4">(</span><span class="s1">pt1</span><span class="s4">, </span><span class="s1">pt2</span><span class="s4">, </span><span class="s1">pt3</span><span class="s4">, </span><span class="s1">pt4</span><span class="s4">):</span>
    <span class="s1">c </span><span class="s4">= (</span><span class="s1">pt2 </span><span class="s4">- </span><span class="s1">pt1</span><span class="s4">) * </span><span class="s5">3.0</span>
    <span class="s1">b </span><span class="s4">= (</span><span class="s1">pt3 </span><span class="s4">- </span><span class="s1">pt2</span><span class="s4">) * </span><span class="s5">3.0 </span><span class="s4">- </span><span class="s1">c</span>
    <span class="s1">a </span><span class="s4">= </span><span class="s1">pt4 </span><span class="s4">- </span><span class="s1">pt1 </span><span class="s4">- </span><span class="s1">c </span><span class="s4">- </span><span class="s1">b</span>
    <span class="s3">return </span><span class="s4">(</span><span class="s1">a</span><span class="s4">, </span><span class="s1">b</span><span class="s4">, </span><span class="s1">c</span><span class="s4">, </span><span class="s1">pt1</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">calcQuadraticPoints</span><span class="s4">(</span><span class="s1">a</span><span class="s4">, </span><span class="s1">b</span><span class="s4">, </span><span class="s1">c</span><span class="s4">):</span>
    <span class="s1">ax</span><span class="s4">, </span><span class="s1">ay </span><span class="s4">= </span><span class="s1">a</span>
    <span class="s1">bx</span><span class="s4">, </span><span class="s1">by </span><span class="s4">= </span><span class="s1">b</span>
    <span class="s1">cx</span><span class="s4">, </span><span class="s1">cy </span><span class="s4">= </span><span class="s1">c</span>
    <span class="s1">x1 </span><span class="s4">= </span><span class="s1">cx</span>
    <span class="s1">y1 </span><span class="s4">= </span><span class="s1">cy</span>
    <span class="s1">x2 </span><span class="s4">= (</span><span class="s1">bx </span><span class="s4">* </span><span class="s5">0.5</span><span class="s4">) + </span><span class="s1">cx</span>
    <span class="s1">y2 </span><span class="s4">= (</span><span class="s1">by </span><span class="s4">* </span><span class="s5">0.5</span><span class="s4">) + </span><span class="s1">cy</span>
    <span class="s1">x3 </span><span class="s4">= </span><span class="s1">ax </span><span class="s4">+ </span><span class="s1">bx </span><span class="s4">+ </span><span class="s1">cx</span>
    <span class="s1">y3 </span><span class="s4">= </span><span class="s1">ay </span><span class="s4">+ </span><span class="s1">by </span><span class="s4">+ </span><span class="s1">cy</span>
    <span class="s3">return </span><span class="s4">(</span><span class="s1">x1</span><span class="s4">, </span><span class="s1">y1</span><span class="s4">), (</span><span class="s1">x2</span><span class="s4">, </span><span class="s1">y2</span><span class="s4">), (</span><span class="s1">x3</span><span class="s4">, </span><span class="s1">y3</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">calcCubicPoints</span><span class="s4">(</span><span class="s1">a</span><span class="s4">, </span><span class="s1">b</span><span class="s4">, </span><span class="s1">c</span><span class="s4">, </span><span class="s1">d</span><span class="s4">):</span>
    <span class="s1">ax</span><span class="s4">, </span><span class="s1">ay </span><span class="s4">= </span><span class="s1">a</span>
    <span class="s1">bx</span><span class="s4">, </span><span class="s1">by </span><span class="s4">= </span><span class="s1">b</span>
    <span class="s1">cx</span><span class="s4">, </span><span class="s1">cy </span><span class="s4">= </span><span class="s1">c</span>
    <span class="s1">dx</span><span class="s4">, </span><span class="s1">dy </span><span class="s4">= </span><span class="s1">d</span>
    <span class="s1">x1 </span><span class="s4">= </span><span class="s1">dx</span>
    <span class="s1">y1 </span><span class="s4">= </span><span class="s1">dy</span>
    <span class="s1">x2 </span><span class="s4">= (</span><span class="s1">cx </span><span class="s4">/ </span><span class="s5">3.0</span><span class="s4">) + </span><span class="s1">dx</span>
    <span class="s1">y2 </span><span class="s4">= (</span><span class="s1">cy </span><span class="s4">/ </span><span class="s5">3.0</span><span class="s4">) + </span><span class="s1">dy</span>
    <span class="s1">x3 </span><span class="s4">= (</span><span class="s1">bx </span><span class="s4">+ </span><span class="s1">cx</span><span class="s4">) / </span><span class="s5">3.0 </span><span class="s4">+ </span><span class="s1">x2</span>
    <span class="s1">y3 </span><span class="s4">= (</span><span class="s1">by </span><span class="s4">+ </span><span class="s1">cy</span><span class="s4">) / </span><span class="s5">3.0 </span><span class="s4">+ </span><span class="s1">y2</span>
    <span class="s1">x4 </span><span class="s4">= </span><span class="s1">ax </span><span class="s4">+ </span><span class="s1">dx </span><span class="s4">+ </span><span class="s1">cx </span><span class="s4">+ </span><span class="s1">bx</span>
    <span class="s1">y4 </span><span class="s4">= </span><span class="s1">ay </span><span class="s4">+ </span><span class="s1">dy </span><span class="s4">+ </span><span class="s1">cy </span><span class="s4">+ </span><span class="s1">by</span>
    <span class="s3">return </span><span class="s4">(</span><span class="s1">x1</span><span class="s4">, </span><span class="s1">y1</span><span class="s4">), (</span><span class="s1">x2</span><span class="s4">, </span><span class="s1">y2</span><span class="s4">), (</span><span class="s1">x3</span><span class="s4">, </span><span class="s1">y3</span><span class="s4">), (</span><span class="s1">x4</span><span class="s4">, </span><span class="s1">y4</span><span class="s4">)</span>


<span class="s4">@</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">cfunc</span>
<span class="s4">@</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">inline</span>
<span class="s4">@</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">locals</span><span class="s4">(</span>
    <span class="s1">a</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">complex</span><span class="s4">,</span>
    <span class="s1">b</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">complex</span><span class="s4">,</span>
    <span class="s1">c</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">complex</span><span class="s4">,</span>
    <span class="s1">d</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">complex</span><span class="s4">,</span>
    <span class="s1">p2</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">complex</span><span class="s4">,</span>
    <span class="s1">p3</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">complex</span><span class="s4">,</span>
    <span class="s1">p4</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">complex</span><span class="s4">,</span>
<span class="s4">)</span>
<span class="s3">def </span><span class="s1">calcCubicPointsC</span><span class="s4">(</span><span class="s1">a</span><span class="s4">, </span><span class="s1">b</span><span class="s4">, </span><span class="s1">c</span><span class="s4">, </span><span class="s1">d</span><span class="s4">):</span>
    <span class="s1">p2 </span><span class="s4">= </span><span class="s1">c </span><span class="s4">* (</span><span class="s5">1 </span><span class="s4">/ </span><span class="s5">3</span><span class="s4">) + </span><span class="s1">d</span>
    <span class="s1">p3 </span><span class="s4">= (</span><span class="s1">b </span><span class="s4">+ </span><span class="s1">c</span><span class="s4">) * (</span><span class="s5">1 </span><span class="s4">/ </span><span class="s5">3</span><span class="s4">) + </span><span class="s1">p2</span>
    <span class="s1">p4 </span><span class="s4">= </span><span class="s1">a </span><span class="s4">+ </span><span class="s1">b </span><span class="s4">+ </span><span class="s1">c </span><span class="s4">+ </span><span class="s1">d</span>
    <span class="s3">return </span><span class="s4">(</span><span class="s1">d</span><span class="s4">, </span><span class="s1">p2</span><span class="s4">, </span><span class="s1">p3</span><span class="s4">, </span><span class="s1">p4</span><span class="s4">)</span>


<span class="s0">#</span>
<span class="s0"># Point at time</span>
<span class="s0">#</span>


<span class="s3">def </span><span class="s1">linePointAtT</span><span class="s4">(</span><span class="s1">pt1</span><span class="s4">, </span><span class="s1">pt2</span><span class="s4">, </span><span class="s1">t</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Finds the point at time `t` on a line. 
 
    Args: 
        pt1, pt2: Coordinates of the line as 2D tuples. 
        t: The time along the line. 
 
    Returns: 
        A 2D tuple with the coordinates of the point. 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s4">((</span><span class="s1">pt1</span><span class="s4">[</span><span class="s5">0</span><span class="s4">] * (</span><span class="s5">1 </span><span class="s4">- </span><span class="s1">t</span><span class="s4">) + </span><span class="s1">pt2</span><span class="s4">[</span><span class="s5">0</span><span class="s4">] * </span><span class="s1">t</span><span class="s4">), (</span><span class="s1">pt1</span><span class="s4">[</span><span class="s5">1</span><span class="s4">] * (</span><span class="s5">1 </span><span class="s4">- </span><span class="s1">t</span><span class="s4">) + </span><span class="s1">pt2</span><span class="s4">[</span><span class="s5">1</span><span class="s4">] * </span><span class="s1">t</span><span class="s4">))</span>


<span class="s3">def </span><span class="s1">quadraticPointAtT</span><span class="s4">(</span><span class="s1">pt1</span><span class="s4">, </span><span class="s1">pt2</span><span class="s4">, </span><span class="s1">pt3</span><span class="s4">, </span><span class="s1">t</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Finds the point at time `t` on a quadratic curve. 
 
    Args: 
        pt1, pt2, pt3: Coordinates of the curve as 2D tuples. 
        t: The time along the curve. 
 
    Returns: 
        A 2D tuple with the coordinates of the point. 
    &quot;&quot;&quot;</span>
    <span class="s1">x </span><span class="s4">= (</span><span class="s5">1 </span><span class="s4">- </span><span class="s1">t</span><span class="s4">) * (</span><span class="s5">1 </span><span class="s4">- </span><span class="s1">t</span><span class="s4">) * </span><span class="s1">pt1</span><span class="s4">[</span><span class="s5">0</span><span class="s4">] + </span><span class="s5">2 </span><span class="s4">* (</span><span class="s5">1 </span><span class="s4">- </span><span class="s1">t</span><span class="s4">) * </span><span class="s1">t </span><span class="s4">* </span><span class="s1">pt2</span><span class="s4">[</span><span class="s5">0</span><span class="s4">] + </span><span class="s1">t </span><span class="s4">* </span><span class="s1">t </span><span class="s4">* </span><span class="s1">pt3</span><span class="s4">[</span><span class="s5">0</span><span class="s4">]</span>
    <span class="s1">y </span><span class="s4">= (</span><span class="s5">1 </span><span class="s4">- </span><span class="s1">t</span><span class="s4">) * (</span><span class="s5">1 </span><span class="s4">- </span><span class="s1">t</span><span class="s4">) * </span><span class="s1">pt1</span><span class="s4">[</span><span class="s5">1</span><span class="s4">] + </span><span class="s5">2 </span><span class="s4">* (</span><span class="s5">1 </span><span class="s4">- </span><span class="s1">t</span><span class="s4">) * </span><span class="s1">t </span><span class="s4">* </span><span class="s1">pt2</span><span class="s4">[</span><span class="s5">1</span><span class="s4">] + </span><span class="s1">t </span><span class="s4">* </span><span class="s1">t </span><span class="s4">* </span><span class="s1">pt3</span><span class="s4">[</span><span class="s5">1</span><span class="s4">]</span>
    <span class="s3">return </span><span class="s4">(</span><span class="s1">x</span><span class="s4">, </span><span class="s1">y</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">cubicPointAtT</span><span class="s4">(</span><span class="s1">pt1</span><span class="s4">, </span><span class="s1">pt2</span><span class="s4">, </span><span class="s1">pt3</span><span class="s4">, </span><span class="s1">pt4</span><span class="s4">, </span><span class="s1">t</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Finds the point at time `t` on a cubic curve. 
 
    Args: 
        pt1, pt2, pt3, pt4: Coordinates of the curve as 2D tuples. 
        t: The time along the curve. 
 
    Returns: 
        A 2D tuple with the coordinates of the point. 
    &quot;&quot;&quot;</span>
    <span class="s1">t2 </span><span class="s4">= </span><span class="s1">t </span><span class="s4">* </span><span class="s1">t</span>
    <span class="s1">_1_t </span><span class="s4">= </span><span class="s5">1 </span><span class="s4">- </span><span class="s1">t</span>
    <span class="s1">_1_t_2 </span><span class="s4">= </span><span class="s1">_1_t </span><span class="s4">* </span><span class="s1">_1_t</span>
    <span class="s1">x </span><span class="s4">= (</span>
        <span class="s1">_1_t_2 </span><span class="s4">* </span><span class="s1">_1_t </span><span class="s4">* </span><span class="s1">pt1</span><span class="s4">[</span><span class="s5">0</span><span class="s4">]</span>
        <span class="s4">+ </span><span class="s5">3 </span><span class="s4">* (</span><span class="s1">_1_t_2 </span><span class="s4">* </span><span class="s1">t </span><span class="s4">* </span><span class="s1">pt2</span><span class="s4">[</span><span class="s5">0</span><span class="s4">] + </span><span class="s1">_1_t </span><span class="s4">* </span><span class="s1">t2 </span><span class="s4">* </span><span class="s1">pt3</span><span class="s4">[</span><span class="s5">0</span><span class="s4">])</span>
        <span class="s4">+ </span><span class="s1">t2 </span><span class="s4">* </span><span class="s1">t </span><span class="s4">* </span><span class="s1">pt4</span><span class="s4">[</span><span class="s5">0</span><span class="s4">]</span>
    <span class="s4">)</span>
    <span class="s1">y </span><span class="s4">= (</span>
        <span class="s1">_1_t_2 </span><span class="s4">* </span><span class="s1">_1_t </span><span class="s4">* </span><span class="s1">pt1</span><span class="s4">[</span><span class="s5">1</span><span class="s4">]</span>
        <span class="s4">+ </span><span class="s5">3 </span><span class="s4">* (</span><span class="s1">_1_t_2 </span><span class="s4">* </span><span class="s1">t </span><span class="s4">* </span><span class="s1">pt2</span><span class="s4">[</span><span class="s5">1</span><span class="s4">] + </span><span class="s1">_1_t </span><span class="s4">* </span><span class="s1">t2 </span><span class="s4">* </span><span class="s1">pt3</span><span class="s4">[</span><span class="s5">1</span><span class="s4">])</span>
        <span class="s4">+ </span><span class="s1">t2 </span><span class="s4">* </span><span class="s1">t </span><span class="s4">* </span><span class="s1">pt4</span><span class="s4">[</span><span class="s5">1</span><span class="s4">]</span>
    <span class="s4">)</span>
    <span class="s3">return </span><span class="s4">(</span><span class="s1">x</span><span class="s4">, </span><span class="s1">y</span><span class="s4">)</span>


<span class="s4">@</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">returns</span><span class="s4">(</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">complex</span><span class="s4">)</span>
<span class="s4">@</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">locals</span><span class="s4">(</span>
    <span class="s1">t</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">double</span><span class="s4">,</span>
    <span class="s1">pt1</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">complex</span><span class="s4">,</span>
    <span class="s1">pt2</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">complex</span><span class="s4">,</span>
    <span class="s1">pt3</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">complex</span><span class="s4">,</span>
    <span class="s1">pt4</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">complex</span><span class="s4">,</span>
<span class="s4">)</span>
<span class="s4">@</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">locals</span><span class="s4">(</span><span class="s1">t2</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">double</span><span class="s4">, </span><span class="s1">_1_t</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">double</span><span class="s4">, </span><span class="s1">_1_t_2</span><span class="s4">=</span><span class="s1">cython</span><span class="s4">.</span><span class="s1">double</span><span class="s4">)</span>
<span class="s3">def </span><span class="s1">cubicPointAtTC</span><span class="s4">(</span><span class="s1">pt1</span><span class="s4">, </span><span class="s1">pt2</span><span class="s4">, </span><span class="s1">pt3</span><span class="s4">, </span><span class="s1">pt4</span><span class="s4">, </span><span class="s1">t</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Finds the point at time `t` on a cubic curve. 
 
    Args: 
        pt1, pt2, pt3, pt4: Coordinates of the curve as complex numbers. 
        t: The time along the curve. 
 
    Returns: 
        A complex number with the coordinates of the point. 
    &quot;&quot;&quot;</span>
    <span class="s1">t2 </span><span class="s4">= </span><span class="s1">t </span><span class="s4">* </span><span class="s1">t</span>
    <span class="s1">_1_t </span><span class="s4">= </span><span class="s5">1 </span><span class="s4">- </span><span class="s1">t</span>
    <span class="s1">_1_t_2 </span><span class="s4">= </span><span class="s1">_1_t </span><span class="s4">* </span><span class="s1">_1_t</span>
    <span class="s3">return </span><span class="s1">_1_t_2 </span><span class="s4">* </span><span class="s1">_1_t </span><span class="s4">* </span><span class="s1">pt1 </span><span class="s4">+ </span><span class="s5">3 </span><span class="s4">* (</span><span class="s1">_1_t_2 </span><span class="s4">* </span><span class="s1">t </span><span class="s4">* </span><span class="s1">pt2 </span><span class="s4">+ </span><span class="s1">_1_t </span><span class="s4">* </span><span class="s1">t2 </span><span class="s4">* </span><span class="s1">pt3</span><span class="s4">) + </span><span class="s1">t2 </span><span class="s4">* </span><span class="s1">t </span><span class="s4">* </span><span class="s1">pt4</span>


<span class="s3">def </span><span class="s1">segmentPointAtT</span><span class="s4">(</span><span class="s1">seg</span><span class="s4">, </span><span class="s1">t</span><span class="s4">):</span>
    <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">seg</span><span class="s4">) == </span><span class="s5">2</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">linePointAtT</span><span class="s4">(*</span><span class="s1">seg</span><span class="s4">, </span><span class="s1">t</span><span class="s4">)</span>
    <span class="s3">elif </span><span class="s1">len</span><span class="s4">(</span><span class="s1">seg</span><span class="s4">) == </span><span class="s5">3</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">quadraticPointAtT</span><span class="s4">(*</span><span class="s1">seg</span><span class="s4">, </span><span class="s1">t</span><span class="s4">)</span>
    <span class="s3">elif </span><span class="s1">len</span><span class="s4">(</span><span class="s1">seg</span><span class="s4">) == </span><span class="s5">4</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">cubicPointAtT</span><span class="s4">(*</span><span class="s1">seg</span><span class="s4">, </span><span class="s1">t</span><span class="s4">)</span>
    <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s6">&quot;Unknown curve degree&quot;</span><span class="s4">)</span>


<span class="s0">#</span>
<span class="s0"># Intersection finders</span>
<span class="s0">#</span>


<span class="s3">def </span><span class="s1">_line_t_of_pt</span><span class="s4">(</span><span class="s1">s</span><span class="s4">, </span><span class="s1">e</span><span class="s4">, </span><span class="s1">pt</span><span class="s4">):</span>
    <span class="s1">sx</span><span class="s4">, </span><span class="s1">sy </span><span class="s4">= </span><span class="s1">s</span>
    <span class="s1">ex</span><span class="s4">, </span><span class="s1">ey </span><span class="s4">= </span><span class="s1">e</span>
    <span class="s1">px</span><span class="s4">, </span><span class="s1">py </span><span class="s4">= </span><span class="s1">pt</span>
    <span class="s3">if </span><span class="s1">abs</span><span class="s4">(</span><span class="s1">sx </span><span class="s4">- </span><span class="s1">ex</span><span class="s4">) &lt; </span><span class="s1">epsilon </span><span class="s3">and </span><span class="s1">abs</span><span class="s4">(</span><span class="s1">sy </span><span class="s4">- </span><span class="s1">ey</span><span class="s4">) &lt; </span><span class="s1">epsilon</span><span class="s4">:</span>
        <span class="s0"># Line is a point!</span>
        <span class="s3">return </span><span class="s4">-</span><span class="s5">1</span>
    <span class="s0"># Use the largest</span>
    <span class="s3">if </span><span class="s1">abs</span><span class="s4">(</span><span class="s1">sx </span><span class="s4">- </span><span class="s1">ex</span><span class="s4">) &gt; </span><span class="s1">abs</span><span class="s4">(</span><span class="s1">sy </span><span class="s4">- </span><span class="s1">ey</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s4">(</span><span class="s1">px </span><span class="s4">- </span><span class="s1">sx</span><span class="s4">) / (</span><span class="s1">ex </span><span class="s4">- </span><span class="s1">sx</span><span class="s4">)</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s4">(</span><span class="s1">py </span><span class="s4">- </span><span class="s1">sy</span><span class="s4">) / (</span><span class="s1">ey </span><span class="s4">- </span><span class="s1">sy</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">_both_points_are_on_same_side_of_origin</span><span class="s4">(</span><span class="s1">a</span><span class="s4">, </span><span class="s1">b</span><span class="s4">, </span><span class="s1">origin</span><span class="s4">):</span>
    <span class="s1">xDiff </span><span class="s4">= (</span><span class="s1">a</span><span class="s4">[</span><span class="s5">0</span><span class="s4">] - </span><span class="s1">origin</span><span class="s4">[</span><span class="s5">0</span><span class="s4">]) * (</span><span class="s1">b</span><span class="s4">[</span><span class="s5">0</span><span class="s4">] - </span><span class="s1">origin</span><span class="s4">[</span><span class="s5">0</span><span class="s4">])</span>
    <span class="s1">yDiff </span><span class="s4">= (</span><span class="s1">a</span><span class="s4">[</span><span class="s5">1</span><span class="s4">] - </span><span class="s1">origin</span><span class="s4">[</span><span class="s5">1</span><span class="s4">]) * (</span><span class="s1">b</span><span class="s4">[</span><span class="s5">1</span><span class="s4">] - </span><span class="s1">origin</span><span class="s4">[</span><span class="s5">1</span><span class="s4">])</span>
    <span class="s3">return not </span><span class="s4">(</span><span class="s1">xDiff </span><span class="s4">&lt;= </span><span class="s5">0.0 </span><span class="s3">and </span><span class="s1">yDiff </span><span class="s4">&lt;= </span><span class="s5">0.0</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">lineLineIntersections</span><span class="s4">(</span><span class="s1">s1</span><span class="s4">, </span><span class="s1">e1</span><span class="s4">, </span><span class="s1">s2</span><span class="s4">, </span><span class="s1">e2</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Finds intersections between two line segments. 
 
    Args: 
        s1, e1: Coordinates of the first line as 2D tuples. 
        s2, e2: Coordinates of the second line as 2D tuples. 
 
    Returns: 
        A list of ``Intersection`` objects, each object having ``pt``, ``t1`` 
        and ``t2`` attributes containing the intersection point, time on first 
        segment and time on second segment respectively. 
 
    Examples:: 
 
        &gt;&gt;&gt; a = lineLineIntersections( (310,389), (453, 222), (289, 251), (447, 367)) 
        &gt;&gt;&gt; len(a) 
        1 
        &gt;&gt;&gt; intersection = a[0] 
        &gt;&gt;&gt; intersection.pt 
        (374.44882952482897, 313.73458370177315) 
        &gt;&gt;&gt; (intersection.t1, intersection.t2) 
        (0.45069111555824465, 0.5408153767394238) 
    &quot;&quot;&quot;</span>
    <span class="s1">s1x</span><span class="s4">, </span><span class="s1">s1y </span><span class="s4">= </span><span class="s1">s1</span>
    <span class="s1">e1x</span><span class="s4">, </span><span class="s1">e1y </span><span class="s4">= </span><span class="s1">e1</span>
    <span class="s1">s2x</span><span class="s4">, </span><span class="s1">s2y </span><span class="s4">= </span><span class="s1">s2</span>
    <span class="s1">e2x</span><span class="s4">, </span><span class="s1">e2y </span><span class="s4">= </span><span class="s1">e2</span>
    <span class="s3">if </span><span class="s4">(</span>
        <span class="s1">math</span><span class="s4">.</span><span class="s1">isclose</span><span class="s4">(</span><span class="s1">s2x</span><span class="s4">, </span><span class="s1">e2x</span><span class="s4">) </span><span class="s3">and </span><span class="s1">math</span><span class="s4">.</span><span class="s1">isclose</span><span class="s4">(</span><span class="s1">s1x</span><span class="s4">, </span><span class="s1">e1x</span><span class="s4">) </span><span class="s3">and not </span><span class="s1">math</span><span class="s4">.</span><span class="s1">isclose</span><span class="s4">(</span><span class="s1">s1x</span><span class="s4">, </span><span class="s1">s2x</span><span class="s4">)</span>
    <span class="s4">):  </span><span class="s0"># Parallel vertical</span>
        <span class="s3">return </span><span class="s4">[]</span>
    <span class="s3">if </span><span class="s4">(</span>
        <span class="s1">math</span><span class="s4">.</span><span class="s1">isclose</span><span class="s4">(</span><span class="s1">s2y</span><span class="s4">, </span><span class="s1">e2y</span><span class="s4">) </span><span class="s3">and </span><span class="s1">math</span><span class="s4">.</span><span class="s1">isclose</span><span class="s4">(</span><span class="s1">s1y</span><span class="s4">, </span><span class="s1">e1y</span><span class="s4">) </span><span class="s3">and not </span><span class="s1">math</span><span class="s4">.</span><span class="s1">isclose</span><span class="s4">(</span><span class="s1">s1y</span><span class="s4">, </span><span class="s1">s2y</span><span class="s4">)</span>
    <span class="s4">):  </span><span class="s0"># Parallel horizontal</span>
        <span class="s3">return </span><span class="s4">[]</span>
    <span class="s3">if </span><span class="s1">math</span><span class="s4">.</span><span class="s1">isclose</span><span class="s4">(</span><span class="s1">s2x</span><span class="s4">, </span><span class="s1">e2x</span><span class="s4">) </span><span class="s3">and </span><span class="s1">math</span><span class="s4">.</span><span class="s1">isclose</span><span class="s4">(</span><span class="s1">s2y</span><span class="s4">, </span><span class="s1">e2y</span><span class="s4">):  </span><span class="s0"># Line segment is tiny</span>
        <span class="s3">return </span><span class="s4">[]</span>
    <span class="s3">if </span><span class="s1">math</span><span class="s4">.</span><span class="s1">isclose</span><span class="s4">(</span><span class="s1">s1x</span><span class="s4">, </span><span class="s1">e1x</span><span class="s4">) </span><span class="s3">and </span><span class="s1">math</span><span class="s4">.</span><span class="s1">isclose</span><span class="s4">(</span><span class="s1">s1y</span><span class="s4">, </span><span class="s1">e1y</span><span class="s4">):  </span><span class="s0"># Line segment is tiny</span>
        <span class="s3">return </span><span class="s4">[]</span>
    <span class="s3">if </span><span class="s1">math</span><span class="s4">.</span><span class="s1">isclose</span><span class="s4">(</span><span class="s1">e1x</span><span class="s4">, </span><span class="s1">s1x</span><span class="s4">):</span>
        <span class="s1">x </span><span class="s4">= </span><span class="s1">s1x</span>
        <span class="s1">slope34 </span><span class="s4">= (</span><span class="s1">e2y </span><span class="s4">- </span><span class="s1">s2y</span><span class="s4">) / (</span><span class="s1">e2x </span><span class="s4">- </span><span class="s1">s2x</span><span class="s4">)</span>
        <span class="s1">y </span><span class="s4">= </span><span class="s1">slope34 </span><span class="s4">* (</span><span class="s1">x </span><span class="s4">- </span><span class="s1">s2x</span><span class="s4">) + </span><span class="s1">s2y</span>
        <span class="s1">pt </span><span class="s4">= (</span><span class="s1">x</span><span class="s4">, </span><span class="s1">y</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s4">[</span>
            <span class="s1">Intersection</span><span class="s4">(</span>
                <span class="s1">pt</span><span class="s4">=</span><span class="s1">pt</span><span class="s4">, </span><span class="s1">t1</span><span class="s4">=</span><span class="s1">_line_t_of_pt</span><span class="s4">(</span><span class="s1">s1</span><span class="s4">, </span><span class="s1">e1</span><span class="s4">, </span><span class="s1">pt</span><span class="s4">), </span><span class="s1">t2</span><span class="s4">=</span><span class="s1">_line_t_of_pt</span><span class="s4">(</span><span class="s1">s2</span><span class="s4">, </span><span class="s1">e2</span><span class="s4">, </span><span class="s1">pt</span><span class="s4">)</span>
            <span class="s4">)</span>
        <span class="s4">]</span>
    <span class="s3">if </span><span class="s1">math</span><span class="s4">.</span><span class="s1">isclose</span><span class="s4">(</span><span class="s1">s2x</span><span class="s4">, </span><span class="s1">e2x</span><span class="s4">):</span>
        <span class="s1">x </span><span class="s4">= </span><span class="s1">s2x</span>
        <span class="s1">slope12 </span><span class="s4">= (</span><span class="s1">e1y </span><span class="s4">- </span><span class="s1">s1y</span><span class="s4">) / (</span><span class="s1">e1x </span><span class="s4">- </span><span class="s1">s1x</span><span class="s4">)</span>
        <span class="s1">y </span><span class="s4">= </span><span class="s1">slope12 </span><span class="s4">* (</span><span class="s1">x </span><span class="s4">- </span><span class="s1">s1x</span><span class="s4">) + </span><span class="s1">s1y</span>
        <span class="s1">pt </span><span class="s4">= (</span><span class="s1">x</span><span class="s4">, </span><span class="s1">y</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s4">[</span>
            <span class="s1">Intersection</span><span class="s4">(</span>
                <span class="s1">pt</span><span class="s4">=</span><span class="s1">pt</span><span class="s4">, </span><span class="s1">t1</span><span class="s4">=</span><span class="s1">_line_t_of_pt</span><span class="s4">(</span><span class="s1">s1</span><span class="s4">, </span><span class="s1">e1</span><span class="s4">, </span><span class="s1">pt</span><span class="s4">), </span><span class="s1">t2</span><span class="s4">=</span><span class="s1">_line_t_of_pt</span><span class="s4">(</span><span class="s1">s2</span><span class="s4">, </span><span class="s1">e2</span><span class="s4">, </span><span class="s1">pt</span><span class="s4">)</span>
            <span class="s4">)</span>
        <span class="s4">]</span>

    <span class="s1">slope12 </span><span class="s4">= (</span><span class="s1">e1y </span><span class="s4">- </span><span class="s1">s1y</span><span class="s4">) / (</span><span class="s1">e1x </span><span class="s4">- </span><span class="s1">s1x</span><span class="s4">)</span>
    <span class="s1">slope34 </span><span class="s4">= (</span><span class="s1">e2y </span><span class="s4">- </span><span class="s1">s2y</span><span class="s4">) / (</span><span class="s1">e2x </span><span class="s4">- </span><span class="s1">s2x</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">math</span><span class="s4">.</span><span class="s1">isclose</span><span class="s4">(</span><span class="s1">slope12</span><span class="s4">, </span><span class="s1">slope34</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s4">[]</span>
    <span class="s1">x </span><span class="s4">= (</span><span class="s1">slope12 </span><span class="s4">* </span><span class="s1">s1x </span><span class="s4">- </span><span class="s1">s1y </span><span class="s4">- </span><span class="s1">slope34 </span><span class="s4">* </span><span class="s1">s2x </span><span class="s4">+ </span><span class="s1">s2y</span><span class="s4">) / (</span><span class="s1">slope12 </span><span class="s4">- </span><span class="s1">slope34</span><span class="s4">)</span>
    <span class="s1">y </span><span class="s4">= </span><span class="s1">slope12 </span><span class="s4">* (</span><span class="s1">x </span><span class="s4">- </span><span class="s1">s1x</span><span class="s4">) + </span><span class="s1">s1y</span>
    <span class="s1">pt </span><span class="s4">= (</span><span class="s1">x</span><span class="s4">, </span><span class="s1">y</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">_both_points_are_on_same_side_of_origin</span><span class="s4">(</span>
        <span class="s1">pt</span><span class="s4">, </span><span class="s1">e1</span><span class="s4">, </span><span class="s1">s1</span>
    <span class="s4">) </span><span class="s3">and </span><span class="s1">_both_points_are_on_same_side_of_origin</span><span class="s4">(</span><span class="s1">pt</span><span class="s4">, </span><span class="s1">s2</span><span class="s4">, </span><span class="s1">e2</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s4">[</span>
            <span class="s1">Intersection</span><span class="s4">(</span>
                <span class="s1">pt</span><span class="s4">=</span><span class="s1">pt</span><span class="s4">, </span><span class="s1">t1</span><span class="s4">=</span><span class="s1">_line_t_of_pt</span><span class="s4">(</span><span class="s1">s1</span><span class="s4">, </span><span class="s1">e1</span><span class="s4">, </span><span class="s1">pt</span><span class="s4">), </span><span class="s1">t2</span><span class="s4">=</span><span class="s1">_line_t_of_pt</span><span class="s4">(</span><span class="s1">s2</span><span class="s4">, </span><span class="s1">e2</span><span class="s4">, </span><span class="s1">pt</span><span class="s4">)</span>
            <span class="s4">)</span>
        <span class="s4">]</span>
    <span class="s3">return </span><span class="s4">[]</span>


<span class="s3">def </span><span class="s1">_alignment_transformation</span><span class="s4">(</span><span class="s1">segment</span><span class="s4">):</span>
    <span class="s0"># Returns a transformation which aligns a segment horizontally at the</span>
    <span class="s0"># origin. Apply this transformation to curves and root-find to find</span>
    <span class="s0"># intersections with the segment.</span>
    <span class="s1">start </span><span class="s4">= </span><span class="s1">segment</span><span class="s4">[</span><span class="s5">0</span><span class="s4">]</span>
    <span class="s1">end </span><span class="s4">= </span><span class="s1">segment</span><span class="s4">[-</span><span class="s5">1</span><span class="s4">]</span>
    <span class="s1">angle </span><span class="s4">= </span><span class="s1">math</span><span class="s4">.</span><span class="s1">atan2</span><span class="s4">(</span><span class="s1">end</span><span class="s4">[</span><span class="s5">1</span><span class="s4">] - </span><span class="s1">start</span><span class="s4">[</span><span class="s5">1</span><span class="s4">], </span><span class="s1">end</span><span class="s4">[</span><span class="s5">0</span><span class="s4">] - </span><span class="s1">start</span><span class="s4">[</span><span class="s5">0</span><span class="s4">])</span>
    <span class="s3">return </span><span class="s1">Identity</span><span class="s4">.</span><span class="s1">rotate</span><span class="s4">(-</span><span class="s1">angle</span><span class="s4">).</span><span class="s1">translate</span><span class="s4">(-</span><span class="s1">start</span><span class="s4">[</span><span class="s5">0</span><span class="s4">], -</span><span class="s1">start</span><span class="s4">[</span><span class="s5">1</span><span class="s4">])</span>


<span class="s3">def </span><span class="s1">_curve_line_intersections_t</span><span class="s4">(</span><span class="s1">curve</span><span class="s4">, </span><span class="s1">line</span><span class="s4">):</span>
    <span class="s1">aligned_curve </span><span class="s4">= </span><span class="s1">_alignment_transformation</span><span class="s4">(</span><span class="s1">line</span><span class="s4">).</span><span class="s1">transformPoints</span><span class="s4">(</span><span class="s1">curve</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">curve</span><span class="s4">) == </span><span class="s5">3</span><span class="s4">:</span>
        <span class="s1">a</span><span class="s4">, </span><span class="s1">b</span><span class="s4">, </span><span class="s1">c </span><span class="s4">= </span><span class="s1">calcQuadraticParameters</span><span class="s4">(*</span><span class="s1">aligned_curve</span><span class="s4">)</span>
        <span class="s1">intersections </span><span class="s4">= </span><span class="s1">solveQuadratic</span><span class="s4">(</span><span class="s1">a</span><span class="s4">[</span><span class="s5">1</span><span class="s4">], </span><span class="s1">b</span><span class="s4">[</span><span class="s5">1</span><span class="s4">], </span><span class="s1">c</span><span class="s4">[</span><span class="s5">1</span><span class="s4">])</span>
    <span class="s3">elif </span><span class="s1">len</span><span class="s4">(</span><span class="s1">curve</span><span class="s4">) == </span><span class="s5">4</span><span class="s4">:</span>
        <span class="s1">a</span><span class="s4">, </span><span class="s1">b</span><span class="s4">, </span><span class="s1">c</span><span class="s4">, </span><span class="s1">d </span><span class="s4">= </span><span class="s1">calcCubicParameters</span><span class="s4">(*</span><span class="s1">aligned_curve</span><span class="s4">)</span>
        <span class="s1">intersections </span><span class="s4">= </span><span class="s1">solveCubic</span><span class="s4">(</span><span class="s1">a</span><span class="s4">[</span><span class="s5">1</span><span class="s4">], </span><span class="s1">b</span><span class="s4">[</span><span class="s5">1</span><span class="s4">], </span><span class="s1">c</span><span class="s4">[</span><span class="s5">1</span><span class="s4">], </span><span class="s1">d</span><span class="s4">[</span><span class="s5">1</span><span class="s4">])</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s6">&quot;Unknown curve degree&quot;</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s1">sorted</span><span class="s4">(</span><span class="s1">i </span><span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">intersections </span><span class="s3">if </span><span class="s5">0.0 </span><span class="s4">&lt;= </span><span class="s1">i </span><span class="s4">&lt;= </span><span class="s5">1</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">curveLineIntersections</span><span class="s4">(</span><span class="s1">curve</span><span class="s4">, </span><span class="s1">line</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Finds intersections between a curve and a line. 
 
    Args: 
        curve: List of coordinates of the curve segment as 2D tuples. 
        line: List of coordinates of the line segment as 2D tuples. 
 
    Returns: 
        A list of ``Intersection`` objects, each object having ``pt``, ``t1`` 
        and ``t2`` attributes containing the intersection point, time on first 
        segment and time on second segment respectively. 
 
    Examples:: 
        &gt;&gt;&gt; curve = [ (100, 240), (30, 60), (210, 230), (160, 30) ] 
        &gt;&gt;&gt; line  = [ (25, 260), (230, 20) ] 
        &gt;&gt;&gt; intersections = curveLineIntersections(curve, line) 
        &gt;&gt;&gt; len(intersections) 
        3 
        &gt;&gt;&gt; intersections[0].pt 
        (84.9000930760723, 189.87306176459828) 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">curve</span><span class="s4">) == </span><span class="s5">3</span><span class="s4">:</span>
        <span class="s1">pointFinder </span><span class="s4">= </span><span class="s1">quadraticPointAtT</span>
    <span class="s3">elif </span><span class="s1">len</span><span class="s4">(</span><span class="s1">curve</span><span class="s4">) == </span><span class="s5">4</span><span class="s4">:</span>
        <span class="s1">pointFinder </span><span class="s4">= </span><span class="s1">cubicPointAtT</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s6">&quot;Unknown curve degree&quot;</span><span class="s4">)</span>
    <span class="s1">intersections </span><span class="s4">= []</span>
    <span class="s3">for </span><span class="s1">t </span><span class="s3">in </span><span class="s1">_curve_line_intersections_t</span><span class="s4">(</span><span class="s1">curve</span><span class="s4">, </span><span class="s1">line</span><span class="s4">):</span>
        <span class="s1">pt </span><span class="s4">= </span><span class="s1">pointFinder</span><span class="s4">(*</span><span class="s1">curve</span><span class="s4">, </span><span class="s1">t</span><span class="s4">)</span>
        <span class="s0"># Back-project the point onto the line, to avoid problems with</span>
        <span class="s0"># numerical accuracy in the case of vertical and horizontal lines</span>
        <span class="s1">line_t </span><span class="s4">= </span><span class="s1">_line_t_of_pt</span><span class="s4">(*</span><span class="s1">line</span><span class="s4">, </span><span class="s1">pt</span><span class="s4">)</span>
        <span class="s1">pt </span><span class="s4">= </span><span class="s1">linePointAtT</span><span class="s4">(*</span><span class="s1">line</span><span class="s4">, </span><span class="s1">line_t</span><span class="s4">)</span>
        <span class="s1">intersections</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">Intersection</span><span class="s4">(</span><span class="s1">pt</span><span class="s4">=</span><span class="s1">pt</span><span class="s4">, </span><span class="s1">t1</span><span class="s4">=</span><span class="s1">t</span><span class="s4">, </span><span class="s1">t2</span><span class="s4">=</span><span class="s1">line_t</span><span class="s4">))</span>
    <span class="s3">return </span><span class="s1">intersections</span>


<span class="s3">def </span><span class="s1">_curve_bounds</span><span class="s4">(</span><span class="s1">c</span><span class="s4">):</span>
    <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">c</span><span class="s4">) == </span><span class="s5">3</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">calcQuadraticBounds</span><span class="s4">(*</span><span class="s1">c</span><span class="s4">)</span>
    <span class="s3">elif </span><span class="s1">len</span><span class="s4">(</span><span class="s1">c</span><span class="s4">) == </span><span class="s5">4</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">calcCubicBounds</span><span class="s4">(*</span><span class="s1">c</span><span class="s4">)</span>
    <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s6">&quot;Unknown curve degree&quot;</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">_split_segment_at_t</span><span class="s4">(</span><span class="s1">c</span><span class="s4">, </span><span class="s1">t</span><span class="s4">):</span>
    <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">c</span><span class="s4">) == </span><span class="s5">2</span><span class="s4">:</span>
        <span class="s1">s</span><span class="s4">, </span><span class="s1">e </span><span class="s4">= </span><span class="s1">c</span>
        <span class="s1">midpoint </span><span class="s4">= </span><span class="s1">linePointAtT</span><span class="s4">(</span><span class="s1">s</span><span class="s4">, </span><span class="s1">e</span><span class="s4">, </span><span class="s1">t</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s4">[(</span><span class="s1">s</span><span class="s4">, </span><span class="s1">midpoint</span><span class="s4">), (</span><span class="s1">midpoint</span><span class="s4">, </span><span class="s1">e</span><span class="s4">)]</span>
    <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">c</span><span class="s4">) == </span><span class="s5">3</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">splitQuadraticAtT</span><span class="s4">(*</span><span class="s1">c</span><span class="s4">, </span><span class="s1">t</span><span class="s4">)</span>
    <span class="s3">elif </span><span class="s1">len</span><span class="s4">(</span><span class="s1">c</span><span class="s4">) == </span><span class="s5">4</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">splitCubicAtT</span><span class="s4">(*</span><span class="s1">c</span><span class="s4">, </span><span class="s1">t</span><span class="s4">)</span>
    <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s6">&quot;Unknown curve degree&quot;</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">_curve_curve_intersections_t</span><span class="s4">(</span>
    <span class="s1">curve1</span><span class="s4">, </span><span class="s1">curve2</span><span class="s4">, </span><span class="s1">precision</span><span class="s4">=</span><span class="s5">1e-3</span><span class="s4">, </span><span class="s1">range1</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">range2</span><span class="s4">=</span><span class="s3">None</span>
<span class="s4">):</span>
    <span class="s1">bounds1 </span><span class="s4">= </span><span class="s1">_curve_bounds</span><span class="s4">(</span><span class="s1">curve1</span><span class="s4">)</span>
    <span class="s1">bounds2 </span><span class="s4">= </span><span class="s1">_curve_bounds</span><span class="s4">(</span><span class="s1">curve2</span><span class="s4">)</span>

    <span class="s3">if not </span><span class="s1">range1</span><span class="s4">:</span>
        <span class="s1">range1 </span><span class="s4">= (</span><span class="s5">0.0</span><span class="s4">, </span><span class="s5">1.0</span><span class="s4">)</span>
    <span class="s3">if not </span><span class="s1">range2</span><span class="s4">:</span>
        <span class="s1">range2 </span><span class="s4">= (</span><span class="s5">0.0</span><span class="s4">, </span><span class="s5">1.0</span><span class="s4">)</span>

    <span class="s0"># If bounds don't intersect, go home</span>
    <span class="s1">intersects</span><span class="s4">, </span><span class="s1">_ </span><span class="s4">= </span><span class="s1">sectRect</span><span class="s4">(</span><span class="s1">bounds1</span><span class="s4">, </span><span class="s1">bounds2</span><span class="s4">)</span>
    <span class="s3">if not </span><span class="s1">intersects</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s4">[]</span>

    <span class="s3">def </span><span class="s1">midpoint</span><span class="s4">(</span><span class="s1">r</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s5">0.5 </span><span class="s4">* (</span><span class="s1">r</span><span class="s4">[</span><span class="s5">0</span><span class="s4">] + </span><span class="s1">r</span><span class="s4">[</span><span class="s5">1</span><span class="s4">])</span>

    <span class="s0"># If they do overlap but they're tiny, approximate</span>
    <span class="s3">if </span><span class="s1">rectArea</span><span class="s4">(</span><span class="s1">bounds1</span><span class="s4">) &lt; </span><span class="s1">precision </span><span class="s3">and </span><span class="s1">rectArea</span><span class="s4">(</span><span class="s1">bounds2</span><span class="s4">) &lt; </span><span class="s1">precision</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s4">[(</span><span class="s1">midpoint</span><span class="s4">(</span><span class="s1">range1</span><span class="s4">), </span><span class="s1">midpoint</span><span class="s4">(</span><span class="s1">range2</span><span class="s4">))]</span>

    <span class="s1">c11</span><span class="s4">, </span><span class="s1">c12 </span><span class="s4">= </span><span class="s1">_split_segment_at_t</span><span class="s4">(</span><span class="s1">curve1</span><span class="s4">, </span><span class="s5">0.5</span><span class="s4">)</span>
    <span class="s1">c11_range </span><span class="s4">= (</span><span class="s1">range1</span><span class="s4">[</span><span class="s5">0</span><span class="s4">], </span><span class="s1">midpoint</span><span class="s4">(</span><span class="s1">range1</span><span class="s4">))</span>
    <span class="s1">c12_range </span><span class="s4">= (</span><span class="s1">midpoint</span><span class="s4">(</span><span class="s1">range1</span><span class="s4">), </span><span class="s1">range1</span><span class="s4">[</span><span class="s5">1</span><span class="s4">])</span>

    <span class="s1">c21</span><span class="s4">, </span><span class="s1">c22 </span><span class="s4">= </span><span class="s1">_split_segment_at_t</span><span class="s4">(</span><span class="s1">curve2</span><span class="s4">, </span><span class="s5">0.5</span><span class="s4">)</span>
    <span class="s1">c21_range </span><span class="s4">= (</span><span class="s1">range2</span><span class="s4">[</span><span class="s5">0</span><span class="s4">], </span><span class="s1">midpoint</span><span class="s4">(</span><span class="s1">range2</span><span class="s4">))</span>
    <span class="s1">c22_range </span><span class="s4">= (</span><span class="s1">midpoint</span><span class="s4">(</span><span class="s1">range2</span><span class="s4">), </span><span class="s1">range2</span><span class="s4">[</span><span class="s5">1</span><span class="s4">])</span>

    <span class="s1">found </span><span class="s4">= []</span>
    <span class="s1">found</span><span class="s4">.</span><span class="s1">extend</span><span class="s4">(</span>
        <span class="s1">_curve_curve_intersections_t</span><span class="s4">(</span>
            <span class="s1">c11</span><span class="s4">, </span><span class="s1">c21</span><span class="s4">, </span><span class="s1">precision</span><span class="s4">, </span><span class="s1">range1</span><span class="s4">=</span><span class="s1">c11_range</span><span class="s4">, </span><span class="s1">range2</span><span class="s4">=</span><span class="s1">c21_range</span>
        <span class="s4">)</span>
    <span class="s4">)</span>
    <span class="s1">found</span><span class="s4">.</span><span class="s1">extend</span><span class="s4">(</span>
        <span class="s1">_curve_curve_intersections_t</span><span class="s4">(</span>
            <span class="s1">c12</span><span class="s4">, </span><span class="s1">c21</span><span class="s4">, </span><span class="s1">precision</span><span class="s4">, </span><span class="s1">range1</span><span class="s4">=</span><span class="s1">c12_range</span><span class="s4">, </span><span class="s1">range2</span><span class="s4">=</span><span class="s1">c21_range</span>
        <span class="s4">)</span>
    <span class="s4">)</span>
    <span class="s1">found</span><span class="s4">.</span><span class="s1">extend</span><span class="s4">(</span>
        <span class="s1">_curve_curve_intersections_t</span><span class="s4">(</span>
            <span class="s1">c11</span><span class="s4">, </span><span class="s1">c22</span><span class="s4">, </span><span class="s1">precision</span><span class="s4">, </span><span class="s1">range1</span><span class="s4">=</span><span class="s1">c11_range</span><span class="s4">, </span><span class="s1">range2</span><span class="s4">=</span><span class="s1">c22_range</span>
        <span class="s4">)</span>
    <span class="s4">)</span>
    <span class="s1">found</span><span class="s4">.</span><span class="s1">extend</span><span class="s4">(</span>
        <span class="s1">_curve_curve_intersections_t</span><span class="s4">(</span>
            <span class="s1">c12</span><span class="s4">, </span><span class="s1">c22</span><span class="s4">, </span><span class="s1">precision</span><span class="s4">, </span><span class="s1">range1</span><span class="s4">=</span><span class="s1">c12_range</span><span class="s4">, </span><span class="s1">range2</span><span class="s4">=</span><span class="s1">c22_range</span>
        <span class="s4">)</span>
    <span class="s4">)</span>

    <span class="s1">unique_key </span><span class="s4">= </span><span class="s3">lambda </span><span class="s1">ts</span><span class="s4">: (</span><span class="s1">int</span><span class="s4">(</span><span class="s1">ts</span><span class="s4">[</span><span class="s5">0</span><span class="s4">] / </span><span class="s1">precision</span><span class="s4">), </span><span class="s1">int</span><span class="s4">(</span><span class="s1">ts</span><span class="s4">[</span><span class="s5">1</span><span class="s4">] / </span><span class="s1">precision</span><span class="s4">))</span>
    <span class="s1">seen </span><span class="s4">= </span><span class="s1">set</span><span class="s4">()</span>
    <span class="s1">unique_values </span><span class="s4">= []</span>

    <span class="s3">for </span><span class="s1">ts </span><span class="s3">in </span><span class="s1">found</span><span class="s4">:</span>
        <span class="s1">key </span><span class="s4">= </span><span class="s1">unique_key</span><span class="s4">(</span><span class="s1">ts</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">key </span><span class="s3">in </span><span class="s1">seen</span><span class="s4">:</span>
            <span class="s3">continue</span>
        <span class="s1">seen</span><span class="s4">.</span><span class="s1">add</span><span class="s4">(</span><span class="s1">key</span><span class="s4">)</span>
        <span class="s1">unique_values</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">ts</span><span class="s4">)</span>

    <span class="s3">return </span><span class="s1">unique_values</span>


<span class="s3">def </span><span class="s1">_is_linelike</span><span class="s4">(</span><span class="s1">segment</span><span class="s4">):</span>
    <span class="s1">maybeline </span><span class="s4">= </span><span class="s1">_alignment_transformation</span><span class="s4">(</span><span class="s1">segment</span><span class="s4">).</span><span class="s1">transformPoints</span><span class="s4">(</span><span class="s1">segment</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s1">all</span><span class="s4">(</span><span class="s1">math</span><span class="s4">.</span><span class="s1">isclose</span><span class="s4">(</span><span class="s1">p</span><span class="s4">[</span><span class="s5">1</span><span class="s4">], </span><span class="s5">0.0</span><span class="s4">) </span><span class="s3">for </span><span class="s1">p </span><span class="s3">in </span><span class="s1">maybeline</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">curveCurveIntersections</span><span class="s4">(</span><span class="s1">curve1</span><span class="s4">, </span><span class="s1">curve2</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Finds intersections between a curve and a curve. 
 
    Args: 
        curve1: List of coordinates of the first curve segment as 2D tuples. 
        curve2: List of coordinates of the second curve segment as 2D tuples. 
 
    Returns: 
        A list of ``Intersection`` objects, each object having ``pt``, ``t1`` 
        and ``t2`` attributes containing the intersection point, time on first 
        segment and time on second segment respectively. 
 
    Examples:: 
        &gt;&gt;&gt; curve1 = [ (10,100), (90,30), (40,140), (220,220) ] 
        &gt;&gt;&gt; curve2 = [ (5,150), (180,20), (80,250), (210,190) ] 
        &gt;&gt;&gt; intersections = curveCurveIntersections(curve1, curve2) 
        &gt;&gt;&gt; len(intersections) 
        3 
        &gt;&gt;&gt; intersections[0].pt 
        (81.7831487395506, 109.88904552375288) 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">_is_linelike</span><span class="s4">(</span><span class="s1">curve1</span><span class="s4">):</span>
        <span class="s1">line1 </span><span class="s4">= </span><span class="s1">curve1</span><span class="s4">[</span><span class="s5">0</span><span class="s4">], </span><span class="s1">curve1</span><span class="s4">[-</span><span class="s5">1</span><span class="s4">]</span>
        <span class="s3">if </span><span class="s1">_is_linelike</span><span class="s4">(</span><span class="s1">curve2</span><span class="s4">):</span>
            <span class="s1">line2 </span><span class="s4">= </span><span class="s1">curve2</span><span class="s4">[</span><span class="s5">0</span><span class="s4">], </span><span class="s1">curve2</span><span class="s4">[-</span><span class="s5">1</span><span class="s4">]</span>
            <span class="s3">return </span><span class="s1">lineLineIntersections</span><span class="s4">(*</span><span class="s1">line1</span><span class="s4">, *</span><span class="s1">line2</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">curveLineIntersections</span><span class="s4">(</span><span class="s1">curve2</span><span class="s4">, </span><span class="s1">line1</span><span class="s4">)</span>
    <span class="s3">elif </span><span class="s1">_is_linelike</span><span class="s4">(</span><span class="s1">curve2</span><span class="s4">):</span>
        <span class="s1">line2 </span><span class="s4">= </span><span class="s1">curve2</span><span class="s4">[</span><span class="s5">0</span><span class="s4">], </span><span class="s1">curve2</span><span class="s4">[-</span><span class="s5">1</span><span class="s4">]</span>
        <span class="s3">return </span><span class="s1">curveLineIntersections</span><span class="s4">(</span><span class="s1">curve1</span><span class="s4">, </span><span class="s1">line2</span><span class="s4">)</span>

    <span class="s1">intersection_ts </span><span class="s4">= </span><span class="s1">_curve_curve_intersections_t</span><span class="s4">(</span><span class="s1">curve1</span><span class="s4">, </span><span class="s1">curve2</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s4">[</span>
        <span class="s1">Intersection</span><span class="s4">(</span><span class="s1">pt</span><span class="s4">=</span><span class="s1">segmentPointAtT</span><span class="s4">(</span><span class="s1">curve1</span><span class="s4">, </span><span class="s1">ts</span><span class="s4">[</span><span class="s5">0</span><span class="s4">]), </span><span class="s1">t1</span><span class="s4">=</span><span class="s1">ts</span><span class="s4">[</span><span class="s5">0</span><span class="s4">], </span><span class="s1">t2</span><span class="s4">=</span><span class="s1">ts</span><span class="s4">[</span><span class="s5">1</span><span class="s4">])</span>
        <span class="s3">for </span><span class="s1">ts </span><span class="s3">in </span><span class="s1">intersection_ts</span>
    <span class="s4">]</span>


<span class="s3">def </span><span class="s1">segmentSegmentIntersections</span><span class="s4">(</span><span class="s1">seg1</span><span class="s4">, </span><span class="s1">seg2</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Finds intersections between two segments. 
 
    Args: 
        seg1: List of coordinates of the first segment as 2D tuples. 
        seg2: List of coordinates of the second segment as 2D tuples. 
 
    Returns: 
        A list of ``Intersection`` objects, each object having ``pt``, ``t1`` 
        and ``t2`` attributes containing the intersection point, time on first 
        segment and time on second segment respectively. 
 
    Examples:: 
        &gt;&gt;&gt; curve1 = [ (10,100), (90,30), (40,140), (220,220) ] 
        &gt;&gt;&gt; curve2 = [ (5,150), (180,20), (80,250), (210,190) ] 
        &gt;&gt;&gt; intersections = segmentSegmentIntersections(curve1, curve2) 
        &gt;&gt;&gt; len(intersections) 
        3 
        &gt;&gt;&gt; intersections[0].pt 
        (81.7831487395506, 109.88904552375288) 
        &gt;&gt;&gt; curve3 = [ (100, 240), (30, 60), (210, 230), (160, 30) ] 
        &gt;&gt;&gt; line  = [ (25, 260), (230, 20) ] 
        &gt;&gt;&gt; intersections = segmentSegmentIntersections(curve3, line) 
        &gt;&gt;&gt; len(intersections) 
        3 
        &gt;&gt;&gt; intersections[0].pt 
        (84.9000930760723, 189.87306176459828) 
 
    &quot;&quot;&quot;</span>
    <span class="s0"># Arrange by degree</span>
    <span class="s1">swapped </span><span class="s4">= </span><span class="s3">False</span>
    <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">seg2</span><span class="s4">) &gt; </span><span class="s1">len</span><span class="s4">(</span><span class="s1">seg1</span><span class="s4">):</span>
        <span class="s1">seg2</span><span class="s4">, </span><span class="s1">seg1 </span><span class="s4">= </span><span class="s1">seg1</span><span class="s4">, </span><span class="s1">seg2</span>
        <span class="s1">swapped </span><span class="s4">= </span><span class="s3">True</span>
    <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">seg1</span><span class="s4">) &gt; </span><span class="s5">2</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">seg2</span><span class="s4">) &gt; </span><span class="s5">2</span><span class="s4">:</span>
            <span class="s1">intersections </span><span class="s4">= </span><span class="s1">curveCurveIntersections</span><span class="s4">(</span><span class="s1">seg1</span><span class="s4">, </span><span class="s1">seg2</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">intersections </span><span class="s4">= </span><span class="s1">curveLineIntersections</span><span class="s4">(</span><span class="s1">seg1</span><span class="s4">, </span><span class="s1">seg2</span><span class="s4">)</span>
    <span class="s3">elif </span><span class="s1">len</span><span class="s4">(</span><span class="s1">seg1</span><span class="s4">) == </span><span class="s5">2 </span><span class="s3">and </span><span class="s1">len</span><span class="s4">(</span><span class="s1">seg2</span><span class="s4">) == </span><span class="s5">2</span><span class="s4">:</span>
        <span class="s1">intersections </span><span class="s4">= </span><span class="s1">lineLineIntersections</span><span class="s4">(*</span><span class="s1">seg1</span><span class="s4">, *</span><span class="s1">seg2</span><span class="s4">)</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s6">&quot;Couldn't work out which intersection function to use&quot;</span><span class="s4">)</span>
    <span class="s3">if not </span><span class="s1">swapped</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">intersections</span>
    <span class="s3">return </span><span class="s4">[</span><span class="s1">Intersection</span><span class="s4">(</span><span class="s1">pt</span><span class="s4">=</span><span class="s1">i</span><span class="s4">.</span><span class="s1">pt</span><span class="s4">, </span><span class="s1">t1</span><span class="s4">=</span><span class="s1">i</span><span class="s4">.</span><span class="s1">t2</span><span class="s4">, </span><span class="s1">t2</span><span class="s4">=</span><span class="s1">i</span><span class="s4">.</span><span class="s1">t1</span><span class="s4">) </span><span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">intersections</span><span class="s4">]</span>


<span class="s3">def </span><span class="s1">_segmentrepr</span><span class="s4">(</span><span class="s1">obj</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot; 
    &gt;&gt;&gt; _segmentrepr([1, [2, 3], [], [[2, [3, 4], [0.1, 2.2]]]]) 
    '(1, (2, 3), (), ((2, (3, 4), (0.1, 2.2))))' 
    &quot;&quot;&quot;</span>
    <span class="s3">try</span><span class="s4">:</span>
        <span class="s1">it </span><span class="s4">= </span><span class="s1">iter</span><span class="s4">(</span><span class="s1">obj</span><span class="s4">)</span>
    <span class="s3">except </span><span class="s1">TypeError</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s6">&quot;%g&quot; </span><span class="s4">% </span><span class="s1">obj</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s6">&quot;(%s)&quot; </span><span class="s4">% </span><span class="s6">&quot;, &quot;</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span><span class="s1">_segmentrepr</span><span class="s4">(</span><span class="s1">x</span><span class="s4">) </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">it</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">printSegments</span><span class="s4">(</span><span class="s1">segments</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Helper for the doctests, displaying each segment in a list of 
    segments on a single line as a tuple. 
    &quot;&quot;&quot;</span>
    <span class="s3">for </span><span class="s1">segment </span><span class="s3">in </span><span class="s1">segments</span><span class="s4">:</span>
        <span class="s1">print</span><span class="s4">(</span><span class="s1">_segmentrepr</span><span class="s4">(</span><span class="s1">segment</span><span class="s4">))</span>


<span class="s3">if </span><span class="s1">__name__ </span><span class="s4">== </span><span class="s6">&quot;__main__&quot;</span><span class="s4">:</span>
    <span class="s3">import </span><span class="s1">sys</span>
    <span class="s3">import </span><span class="s1">doctest</span>

    <span class="s1">sys</span><span class="s4">.</span><span class="s1">exit</span><span class="s4">(</span><span class="s1">doctest</span><span class="s4">.</span><span class="s1">testmod</span><span class="s4">().</span><span class="s1">failed</span><span class="s4">)</span>
</pre>
</body>
</html>