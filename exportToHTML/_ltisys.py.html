<html>
<head>
<title>_ltisys.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #7a7e85;}
.s3 { color: #cf8e6d;}
.s4 { color: #bcbec4;}
.s5 { color: #6aab73;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_ltisys.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
ltisys -- a collection of classes and functions for modeling linear 
time invariant systems. 
&quot;&quot;&quot;</span>
<span class="s2">#</span>
<span class="s2"># Author: Travis Oliphant 2001</span>
<span class="s2">#</span>
<span class="s2"># Feb 2010: Warren Weckesser</span>
<span class="s2">#   Rewrote lsim2 and added impulse2.</span>
<span class="s2"># Apr 2011: Jeffrey Armstrong &lt;jeff@approximatrix.com&gt;</span>
<span class="s2">#   Added dlsim, dstep, dimpulse, cont2discrete</span>
<span class="s2"># Aug 2013: Juan Luis Cano</span>
<span class="s2">#   Rewrote abcd_normalize.</span>
<span class="s2"># Jan 2015: Irvin Probst irvin DOT probst AT ensta-bretagne DOT fr</span>
<span class="s2">#   Added pole placement</span>
<span class="s2"># Mar 2015: Clancy Rowley</span>
<span class="s2">#   Rewrote lsim</span>
<span class="s2"># May 2015: Felix Berkenkamp</span>
<span class="s2">#   Split lti class into subclasses</span>
<span class="s2">#   Merged discrete systems and added dlti</span>

<span class="s3">import </span><span class="s1">warnings</span>

<span class="s2"># np.linalg.qr fails on some tests with LinAlgError: zgeqrf returns -7</span>
<span class="s2"># use scipy's qr until this is solved</span>

<span class="s3">from </span><span class="s1">scipy</span><span class="s4">.</span><span class="s1">linalg </span><span class="s3">import </span><span class="s1">qr </span><span class="s3">as </span><span class="s1">s_qr</span>
<span class="s3">from </span><span class="s1">scipy </span><span class="s3">import </span><span class="s1">linalg</span>
<span class="s3">from </span><span class="s1">scipy</span><span class="s4">.</span><span class="s1">interpolate </span><span class="s3">import </span><span class="s1">make_interp_spline</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">_filter_design </span><span class="s3">import </span><span class="s4">(</span><span class="s1">tf2zpk</span><span class="s4">, </span><span class="s1">zpk2tf</span><span class="s4">, </span><span class="s1">normalize</span><span class="s4">, </span><span class="s1">freqs</span><span class="s4">, </span><span class="s1">freqz</span><span class="s4">, </span><span class="s1">freqs_zpk</span><span class="s4">,</span>
                            <span class="s1">freqz_zpk</span><span class="s4">)</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">_lti_conversion </span><span class="s3">import </span><span class="s4">(</span><span class="s1">tf2ss</span><span class="s4">, </span><span class="s1">abcd_normalize</span><span class="s4">, </span><span class="s1">ss2tf</span><span class="s4">, </span><span class="s1">zpk2ss</span><span class="s4">, </span><span class="s1">ss2zpk</span><span class="s4">,</span>
                             <span class="s1">cont2discrete</span><span class="s4">, </span><span class="s1">_atleast_2d_or_none</span><span class="s4">)</span>

<span class="s3">import </span><span class="s1">numpy </span><span class="s3">as </span><span class="s1">np</span>
<span class="s3">from </span><span class="s1">numpy </span><span class="s3">import </span><span class="s4">(</span><span class="s1">real</span><span class="s4">, </span><span class="s1">atleast_1d</span><span class="s4">, </span><span class="s1">squeeze</span><span class="s4">, </span><span class="s1">asarray</span><span class="s4">, </span><span class="s1">zeros</span><span class="s4">,</span>
                   <span class="s1">dot</span><span class="s4">, </span><span class="s1">transpose</span><span class="s4">, </span><span class="s1">ones</span><span class="s4">, </span><span class="s1">linspace</span><span class="s4">)</span>
<span class="s3">import </span><span class="s1">copy</span>

<span class="s1">__all__ </span><span class="s4">= [</span><span class="s5">'lti'</span><span class="s4">, </span><span class="s5">'dlti'</span><span class="s4">, </span><span class="s5">'TransferFunction'</span><span class="s4">, </span><span class="s5">'ZerosPolesGain'</span><span class="s4">, </span><span class="s5">'StateSpace'</span><span class="s4">,</span>
           <span class="s5">'lsim'</span><span class="s4">, </span><span class="s5">'impulse'</span><span class="s4">, </span><span class="s5">'step'</span><span class="s4">, </span><span class="s5">'bode'</span><span class="s4">,</span>
           <span class="s5">'freqresp'</span><span class="s4">, </span><span class="s5">'place_poles'</span><span class="s4">, </span><span class="s5">'dlsim'</span><span class="s4">, </span><span class="s5">'dstep'</span><span class="s4">, </span><span class="s5">'dimpulse'</span><span class="s4">,</span>
           <span class="s5">'dfreqresp'</span><span class="s4">, </span><span class="s5">'dbode'</span><span class="s4">]</span>


<span class="s3">class </span><span class="s1">LinearTimeInvariant</span><span class="s4">:</span>
    <span class="s3">def </span><span class="s1">__new__</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">, *</span><span class="s1">system</span><span class="s4">, **</span><span class="s1">kwargs</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Create a new object, don't allow direct instances.&quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">cls </span><span class="s3">is </span><span class="s1">LinearTimeInvariant</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">(</span><span class="s5">'The LinearTimeInvariant class is not '</span>
                                      <span class="s5">'meant to be used directly, use `lti` '</span>
                                      <span class="s5">'or `dlti` instead.'</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">super</span><span class="s4">().</span><span class="s1">__new__</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Initialize the `lti` baseclass. 
 
        The heavy lifting is done by the subclasses. 
        &quot;&quot;&quot;</span>
        <span class="s1">super</span><span class="s4">().</span><span class="s1">__init__</span><span class="s4">()</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">inputs </span><span class="s4">= </span><span class="s3">None</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">outputs </span><span class="s4">= </span><span class="s3">None</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_dt </span><span class="s4">= </span><span class="s3">None</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">dt</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Return the sampling time of the system, `None` for `lti` systems.&quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_dt</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">_dt_dict</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">dt </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s4">{}</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s4">{</span><span class="s5">'dt'</span><span class="s4">: </span><span class="s1">self</span><span class="s4">.</span><span class="s1">dt</span><span class="s4">}</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">zeros</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Zeros of the system.&quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">to_zpk</span><span class="s4">().</span><span class="s1">zeros</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">poles</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Poles of the system.&quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">to_zpk</span><span class="s4">().</span><span class="s1">poles</span>

    <span class="s3">def </span><span class="s1">_as_ss</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Convert to `StateSpace` system, without copying. 
 
        Returns 
        ------- 
        sys: StateSpace 
            The `StateSpace` system. If the class is already an instance of 
            `StateSpace` then this instance is returned. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">StateSpace</span><span class="s4">):</span>
            <span class="s3">return </span><span class="s1">self</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">to_ss</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">_as_zpk</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Convert to `ZerosPolesGain` system, without copying. 
 
        Returns 
        ------- 
        sys: ZerosPolesGain 
            The `ZerosPolesGain` system. If the class is already an instance of 
            `ZerosPolesGain` then this instance is returned. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">ZerosPolesGain</span><span class="s4">):</span>
            <span class="s3">return </span><span class="s1">self</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">to_zpk</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">_as_tf</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Convert to `TransferFunction` system, without copying. 
 
        Returns 
        ------- 
        sys: ZerosPolesGain 
            The `TransferFunction` system. If the class is already an instance of 
            `TransferFunction` then this instance is returned. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">TransferFunction</span><span class="s4">):</span>
            <span class="s3">return </span><span class="s1">self</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">to_tf</span><span class="s4">()</span>


<span class="s3">class </span><span class="s1">lti</span><span class="s4">(</span><span class="s1">LinearTimeInvariant</span><span class="s4">):</span>
    <span class="s0">r&quot;&quot;&quot; 
    Continuous-time linear time invariant system base class. 
 
    Parameters 
    ---------- 
    *system : arguments 
        The `lti` class can be instantiated with either 2, 3 or 4 arguments. 
        The following gives the number of arguments and the corresponding 
        continuous-time subclass that is created: 
 
            * 2: `TransferFunction`:  (numerator, denominator) 
            * 3: `ZerosPolesGain`: (zeros, poles, gain) 
            * 4: `StateSpace`:  (A, B, C, D) 
 
        Each argument can be an array or a sequence. 
 
    See Also 
    -------- 
    ZerosPolesGain, StateSpace, TransferFunction, dlti 
 
    Notes 
    ----- 
    `lti` instances do not exist directly. Instead, `lti` creates an instance 
    of one of its subclasses: `StateSpace`, `TransferFunction` or 
    `ZerosPolesGain`. 
 
    If (numerator, denominator) is passed in for ``*system``, coefficients for 
    both the numerator and denominator should be specified in descending 
    exponent order (e.g., ``s^2 + 3s + 5`` would be represented as ``[1, 3, 
    5]``). 
 
    Changing the value of properties that are not directly part of the current 
    system representation (such as the `zeros` of a `StateSpace` system) is 
    very inefficient and may lead to numerical inaccuracies. It is better to 
    convert to the specific system representation first. For example, call 
    ``sys = sys.to_zpk()`` before accessing/changing the zeros, poles or gain. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy import signal 
 
    &gt;&gt;&gt; signal.lti(1, 2, 3, 4) 
    StateSpaceContinuous( 
    array([[1]]), 
    array([[2]]), 
    array([[3]]), 
    array([[4]]), 
    dt: None 
    ) 
 
    Construct the transfer function 
    :math:`H(s) = \frac{5(s - 1)(s - 2)}{(s - 3)(s - 4)}`: 
 
    &gt;&gt;&gt; signal.lti([1, 2], [3, 4], 5) 
    ZerosPolesGainContinuous( 
    array([1, 2]), 
    array([3, 4]), 
    5, 
    dt: None 
    ) 
 
    Construct the transfer function :math:`H(s) = \frac{3s + 4}{1s + 2}`: 
 
    &gt;&gt;&gt; signal.lti([3, 4], [1, 2]) 
    TransferFunctionContinuous( 
    array([3., 4.]), 
    array([1., 2.]), 
    dt: None 
    ) 
 
    &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">__new__</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">, *</span><span class="s1">system</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Create an instance of the appropriate subclass.&quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">cls </span><span class="s3">is </span><span class="s1">lti</span><span class="s4">:</span>
            <span class="s1">N </span><span class="s4">= </span><span class="s1">len</span><span class="s4">(</span><span class="s1">system</span><span class="s4">)</span>
            <span class="s3">if </span><span class="s1">N </span><span class="s4">== </span><span class="s6">2</span><span class="s4">:</span>
                <span class="s3">return </span><span class="s1">TransferFunctionContinuous</span><span class="s4">.</span><span class="s1">__new__</span><span class="s4">(</span>
                    <span class="s1">TransferFunctionContinuous</span><span class="s4">, *</span><span class="s1">system</span><span class="s4">)</span>
            <span class="s3">elif </span><span class="s1">N </span><span class="s4">== </span><span class="s6">3</span><span class="s4">:</span>
                <span class="s3">return </span><span class="s1">ZerosPolesGainContinuous</span><span class="s4">.</span><span class="s1">__new__</span><span class="s4">(</span>
                    <span class="s1">ZerosPolesGainContinuous</span><span class="s4">, *</span><span class="s1">system</span><span class="s4">)</span>
            <span class="s3">elif </span><span class="s1">N </span><span class="s4">== </span><span class="s6">4</span><span class="s4">:</span>
                <span class="s3">return </span><span class="s1">StateSpaceContinuous</span><span class="s4">.</span><span class="s1">__new__</span><span class="s4">(</span><span class="s1">StateSpaceContinuous</span><span class="s4">,</span>
                                                    <span class="s4">*</span><span class="s1">system</span><span class="s4">)</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;`system` needs to be an instance of `lti` &quot;</span>
                                 <span class="s5">&quot;or have 2, 3 or 4 arguments.&quot;</span><span class="s4">)</span>
        <span class="s2"># __new__ was called from a subclass, let it call its own functions</span>
        <span class="s3">return </span><span class="s1">super</span><span class="s4">().</span><span class="s1">__new__</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, *</span><span class="s1">system</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Initialize the `lti` baseclass. 
 
        The heavy lifting is done by the subclasses. 
        &quot;&quot;&quot;</span>
        <span class="s1">super</span><span class="s4">().</span><span class="s1">__init__</span><span class="s4">(*</span><span class="s1">system</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">impulse</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">X0</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">T</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">N</span><span class="s4">=</span><span class="s3">None</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the impulse response of a continuous-time system. 
        See `impulse` for details. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">impulse</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">X0</span><span class="s4">=</span><span class="s1">X0</span><span class="s4">, </span><span class="s1">T</span><span class="s4">=</span><span class="s1">T</span><span class="s4">, </span><span class="s1">N</span><span class="s4">=</span><span class="s1">N</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">step</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">X0</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">T</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">N</span><span class="s4">=</span><span class="s3">None</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the step response of a continuous-time system. 
        See `step` for details. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">step</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">X0</span><span class="s4">=</span><span class="s1">X0</span><span class="s4">, </span><span class="s1">T</span><span class="s4">=</span><span class="s1">T</span><span class="s4">, </span><span class="s1">N</span><span class="s4">=</span><span class="s1">N</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">output</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">U</span><span class="s4">, </span><span class="s1">T</span><span class="s4">, </span><span class="s1">X0</span><span class="s4">=</span><span class="s3">None</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the response of a continuous-time system to input `U`. 
        See `lsim` for details. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">lsim</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">U</span><span class="s4">, </span><span class="s1">T</span><span class="s4">, </span><span class="s1">X0</span><span class="s4">=</span><span class="s1">X0</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">bode</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">w</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">n</span><span class="s4">=</span><span class="s6">100</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Calculate Bode magnitude and phase data of a continuous-time system. 
 
        Returns a 3-tuple containing arrays of frequencies [rad/s], magnitude 
        [dB] and phase [deg]. See `bode` for details. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; from scipy import signal 
        &gt;&gt;&gt; import matplotlib.pyplot as plt 
 
        &gt;&gt;&gt; sys = signal.TransferFunction([1], [1, 1]) 
        &gt;&gt;&gt; w, mag, phase = sys.bode() 
 
        &gt;&gt;&gt; plt.figure() 
        &gt;&gt;&gt; plt.semilogx(w, mag)    # Bode magnitude plot 
        &gt;&gt;&gt; plt.figure() 
        &gt;&gt;&gt; plt.semilogx(w, phase)  # Bode phase plot 
        &gt;&gt;&gt; plt.show() 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">bode</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">w</span><span class="s4">=</span><span class="s1">w</span><span class="s4">, </span><span class="s1">n</span><span class="s4">=</span><span class="s1">n</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">freqresp</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">w</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">n</span><span class="s4">=</span><span class="s6">10000</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Calculate the frequency response of a continuous-time system. 
 
        Returns a 2-tuple containing arrays of frequencies [rad/s] and 
        complex magnitude. 
        See `freqresp` for details. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">freqresp</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">w</span><span class="s4">=</span><span class="s1">w</span><span class="s4">, </span><span class="s1">n</span><span class="s4">=</span><span class="s1">n</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">to_discrete</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">dt</span><span class="s4">, </span><span class="s1">method</span><span class="s4">=</span><span class="s5">'zoh'</span><span class="s4">, </span><span class="s1">alpha</span><span class="s4">=</span><span class="s3">None</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Return a discretized version of the current system. 
 
        Parameters: See `cont2discrete` for details. 
 
        Returns 
        ------- 
        sys: instance of `dlti` 
        &quot;&quot;&quot;</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">(</span><span class="s5">'to_discrete is not implemented for this '</span>
                                  <span class="s5">'system class.'</span><span class="s4">)</span>


<span class="s3">class </span><span class="s1">dlti</span><span class="s4">(</span><span class="s1">LinearTimeInvariant</span><span class="s4">):</span>
    <span class="s0">r&quot;&quot;&quot; 
    Discrete-time linear time invariant system base class. 
 
    Parameters 
    ---------- 
    *system: arguments 
        The `dlti` class can be instantiated with either 2, 3 or 4 arguments. 
        The following gives the number of arguments and the corresponding 
        discrete-time subclass that is created: 
 
            * 2: `TransferFunction`:  (numerator, denominator) 
            * 3: `ZerosPolesGain`: (zeros, poles, gain) 
            * 4: `StateSpace`:  (A, B, C, D) 
 
        Each argument can be an array or a sequence. 
    dt: float, optional 
        Sampling time [s] of the discrete-time systems. Defaults to ``True`` 
        (unspecified sampling time). Must be specified as a keyword argument, 
        for example, ``dt=0.1``. 
 
    See Also 
    -------- 
    ZerosPolesGain, StateSpace, TransferFunction, lti 
 
    Notes 
    ----- 
    `dlti` instances do not exist directly. Instead, `dlti` creates an instance 
    of one of its subclasses: `StateSpace`, `TransferFunction` or 
    `ZerosPolesGain`. 
 
    Changing the value of properties that are not directly part of the current 
    system representation (such as the `zeros` of a `StateSpace` system) is 
    very inefficient and may lead to numerical inaccuracies.  It is better to 
    convert to the specific system representation first. For example, call 
    ``sys = sys.to_zpk()`` before accessing/changing the zeros, poles or gain. 
 
    If (numerator, denominator) is passed in for ``*system``, coefficients for 
    both the numerator and denominator should be specified in descending 
    exponent order (e.g., ``z^2 + 3z + 5`` would be represented as ``[1, 3, 
    5]``). 
 
    .. versionadded:: 0.18.0 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy import signal 
 
    &gt;&gt;&gt; signal.dlti(1, 2, 3, 4) 
    StateSpaceDiscrete( 
    array([[1]]), 
    array([[2]]), 
    array([[3]]), 
    array([[4]]), 
    dt: True 
    ) 
 
    &gt;&gt;&gt; signal.dlti(1, 2, 3, 4, dt=0.1) 
    StateSpaceDiscrete( 
    array([[1]]), 
    array([[2]]), 
    array([[3]]), 
    array([[4]]), 
    dt: 0.1 
    ) 
 
    Construct the transfer function 
    :math:`H(z) = \frac{5(z - 1)(z - 2)}{(z - 3)(z - 4)}` with a sampling time 
    of 0.1 seconds: 
 
    &gt;&gt;&gt; signal.dlti([1, 2], [3, 4], 5, dt=0.1) 
    ZerosPolesGainDiscrete( 
    array([1, 2]), 
    array([3, 4]), 
    5, 
    dt: 0.1 
    ) 
 
    Construct the transfer function :math:`H(z) = \frac{3z + 4}{1z + 2}` with 
    a sampling time of 0.1 seconds: 
 
    &gt;&gt;&gt; signal.dlti([3, 4], [1, 2], dt=0.1) 
    TransferFunctionDiscrete( 
    array([3., 4.]), 
    array([1., 2.]), 
    dt: 0.1 
    ) 
 
    &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">__new__</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">, *</span><span class="s1">system</span><span class="s4">, **</span><span class="s1">kwargs</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Create an instance of the appropriate subclass.&quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">cls </span><span class="s3">is </span><span class="s1">dlti</span><span class="s4">:</span>
            <span class="s1">N </span><span class="s4">= </span><span class="s1">len</span><span class="s4">(</span><span class="s1">system</span><span class="s4">)</span>
            <span class="s3">if </span><span class="s1">N </span><span class="s4">== </span><span class="s6">2</span><span class="s4">:</span>
                <span class="s3">return </span><span class="s1">TransferFunctionDiscrete</span><span class="s4">.</span><span class="s1">__new__</span><span class="s4">(</span>
                    <span class="s1">TransferFunctionDiscrete</span><span class="s4">, *</span><span class="s1">system</span><span class="s4">, **</span><span class="s1">kwargs</span><span class="s4">)</span>
            <span class="s3">elif </span><span class="s1">N </span><span class="s4">== </span><span class="s6">3</span><span class="s4">:</span>
                <span class="s3">return </span><span class="s1">ZerosPolesGainDiscrete</span><span class="s4">.</span><span class="s1">__new__</span><span class="s4">(</span><span class="s1">ZerosPolesGainDiscrete</span><span class="s4">,</span>
                                                      <span class="s4">*</span><span class="s1">system</span><span class="s4">, **</span><span class="s1">kwargs</span><span class="s4">)</span>
            <span class="s3">elif </span><span class="s1">N </span><span class="s4">== </span><span class="s6">4</span><span class="s4">:</span>
                <span class="s3">return </span><span class="s1">StateSpaceDiscrete</span><span class="s4">.</span><span class="s1">__new__</span><span class="s4">(</span><span class="s1">StateSpaceDiscrete</span><span class="s4">, *</span><span class="s1">system</span><span class="s4">,</span>
                                                  <span class="s4">**</span><span class="s1">kwargs</span><span class="s4">)</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;`system` needs to be an instance of `dlti` &quot;</span>
                                 <span class="s5">&quot;or have 2, 3 or 4 arguments.&quot;</span><span class="s4">)</span>
        <span class="s2"># __new__ was called from a subclass, let it call its own functions</span>
        <span class="s3">return </span><span class="s1">super</span><span class="s4">().</span><span class="s1">__new__</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, *</span><span class="s1">system</span><span class="s4">, **</span><span class="s1">kwargs</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Initialize the `lti` baseclass. 
 
        The heavy lifting is done by the subclasses. 
        &quot;&quot;&quot;</span>
        <span class="s1">dt </span><span class="s4">= </span><span class="s1">kwargs</span><span class="s4">.</span><span class="s1">pop</span><span class="s4">(</span><span class="s5">'dt'</span><span class="s4">, </span><span class="s3">True</span><span class="s4">)</span>
        <span class="s1">super</span><span class="s4">().</span><span class="s1">__init__</span><span class="s4">(*</span><span class="s1">system</span><span class="s4">, **</span><span class="s1">kwargs</span><span class="s4">)</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">dt </span><span class="s4">= </span><span class="s1">dt</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">dt</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Return the sampling time of the system.&quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_dt</span>

    <span class="s4">@</span><span class="s1">dt</span><span class="s4">.</span><span class="s1">setter</span>
    <span class="s3">def </span><span class="s1">dt</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">dt</span><span class="s4">):</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_dt </span><span class="s4">= </span><span class="s1">dt</span>

    <span class="s3">def </span><span class="s1">impulse</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">x0</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">t</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">n</span><span class="s4">=</span><span class="s3">None</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the impulse response of the discrete-time `dlti` system. 
        See `dimpulse` for details. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">dimpulse</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">x0</span><span class="s4">=</span><span class="s1">x0</span><span class="s4">, </span><span class="s1">t</span><span class="s4">=</span><span class="s1">t</span><span class="s4">, </span><span class="s1">n</span><span class="s4">=</span><span class="s1">n</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">step</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">x0</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">t</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">n</span><span class="s4">=</span><span class="s3">None</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the step response of the discrete-time `dlti` system. 
        See `dstep` for details. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">dstep</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">x0</span><span class="s4">=</span><span class="s1">x0</span><span class="s4">, </span><span class="s1">t</span><span class="s4">=</span><span class="s1">t</span><span class="s4">, </span><span class="s1">n</span><span class="s4">=</span><span class="s1">n</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">output</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">u</span><span class="s4">, </span><span class="s1">t</span><span class="s4">, </span><span class="s1">x0</span><span class="s4">=</span><span class="s3">None</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the response of the discrete-time system to input `u`. 
        See `dlsim` for details. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">dlsim</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">u</span><span class="s4">, </span><span class="s1">t</span><span class="s4">, </span><span class="s1">x0</span><span class="s4">=</span><span class="s1">x0</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">bode</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">w</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">n</span><span class="s4">=</span><span class="s6">100</span><span class="s4">):</span>
        <span class="s0">r&quot;&quot;&quot; 
        Calculate Bode magnitude and phase data of a discrete-time system. 
 
        Returns a 3-tuple containing arrays of frequencies [rad/s], magnitude 
        [dB] and phase [deg]. See `dbode` for details. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; from scipy import signal 
        &gt;&gt;&gt; import matplotlib.pyplot as plt 
 
        Construct the transfer function :math:`H(z) = \frac{1}{z^2 + 2z + 3}` 
        with sampling time 0.5s: 
 
        &gt;&gt;&gt; sys = signal.TransferFunction([1], [1, 2, 3], dt=0.5) 
 
        Equivalent: signal.dbode(sys) 
 
        &gt;&gt;&gt; w, mag, phase = sys.bode() 
 
        &gt;&gt;&gt; plt.figure() 
        &gt;&gt;&gt; plt.semilogx(w, mag)    # Bode magnitude plot 
        &gt;&gt;&gt; plt.figure() 
        &gt;&gt;&gt; plt.semilogx(w, phase)  # Bode phase plot 
        &gt;&gt;&gt; plt.show() 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">dbode</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">w</span><span class="s4">=</span><span class="s1">w</span><span class="s4">, </span><span class="s1">n</span><span class="s4">=</span><span class="s1">n</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">freqresp</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">w</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">n</span><span class="s4">=</span><span class="s6">10000</span><span class="s4">, </span><span class="s1">whole</span><span class="s4">=</span><span class="s3">False</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Calculate the frequency response of a discrete-time system. 
 
        Returns a 2-tuple containing arrays of frequencies [rad/s] and 
        complex magnitude. 
        See `dfreqresp` for details. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">dfreqresp</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">w</span><span class="s4">=</span><span class="s1">w</span><span class="s4">, </span><span class="s1">n</span><span class="s4">=</span><span class="s1">n</span><span class="s4">, </span><span class="s1">whole</span><span class="s4">=</span><span class="s1">whole</span><span class="s4">)</span>


<span class="s3">class </span><span class="s1">TransferFunction</span><span class="s4">(</span><span class="s1">LinearTimeInvariant</span><span class="s4">):</span>
    <span class="s0">r&quot;&quot;&quot;Linear Time Invariant system class in transfer function form. 
 
    Represents the system as the continuous-time transfer function 
    :math:`H(s)=\sum_{i=0}^N b[N-i] s^i / \sum_{j=0}^M a[M-j] s^j` or the 
    discrete-time transfer function 
    :math:`H(z)=\sum_{i=0}^N b[N-i] z^i / \sum_{j=0}^M a[M-j] z^j`, where 
    :math:`b` are elements of the numerator `num`, :math:`a` are elements of 
    the denominator `den`, and ``N == len(b) - 1``, ``M == len(a) - 1``. 
    `TransferFunction` systems inherit additional 
    functionality from the `lti`, respectively the `dlti` classes, depending on 
    which system representation is used. 
 
    Parameters 
    ---------- 
    *system: arguments 
        The `TransferFunction` class can be instantiated with 1 or 2 
        arguments. The following gives the number of input arguments and their 
        interpretation: 
 
            * 1: `lti` or `dlti` system: (`StateSpace`, `TransferFunction` or 
              `ZerosPolesGain`) 
            * 2: array_like: (numerator, denominator) 
    dt: float, optional 
        Sampling time [s] of the discrete-time systems. Defaults to `None` 
        (continuous-time). Must be specified as a keyword argument, for 
        example, ``dt=0.1``. 
 
    See Also 
    -------- 
    ZerosPolesGain, StateSpace, lti, dlti 
    tf2ss, tf2zpk, tf2sos 
 
    Notes 
    ----- 
    Changing the value of properties that are not part of the 
    `TransferFunction` system representation (such as the `A`, `B`, `C`, `D` 
    state-space matrices) is very inefficient and may lead to numerical 
    inaccuracies.  It is better to convert to the specific system 
    representation first. For example, call ``sys = sys.to_ss()`` before 
    accessing/changing the A, B, C, D system matrices. 
 
    If (numerator, denominator) is passed in for ``*system``, coefficients 
    for both the numerator and denominator should be specified in descending 
    exponent order (e.g. ``s^2 + 3s + 5`` or ``z^2 + 3z + 5`` would be 
    represented as ``[1, 3, 5]``) 
 
    Examples 
    -------- 
    Construct the transfer function 
    :math:`H(s) = \frac{s^2 + 3s + 3}{s^2 + 2s + 1}`: 
 
    &gt;&gt;&gt; from scipy import signal 
 
    &gt;&gt;&gt; num = [1, 3, 3] 
    &gt;&gt;&gt; den = [1, 2, 1] 
 
    &gt;&gt;&gt; signal.TransferFunction(num, den) 
    TransferFunctionContinuous( 
    array([1., 3., 3.]), 
    array([1., 2., 1.]), 
    dt: None 
    ) 
 
    Construct the transfer function 
    :math:`H(z) = \frac{z^2 + 3z + 3}{z^2 + 2z + 1}` with a sampling time of 
    0.1 seconds: 
 
    &gt;&gt;&gt; signal.TransferFunction(num, den, dt=0.1) 
    TransferFunctionDiscrete( 
    array([1., 3., 3.]), 
    array([1., 2., 1.]), 
    dt: 0.1 
    ) 
 
    &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">__new__</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">, *</span><span class="s1">system</span><span class="s4">, **</span><span class="s1">kwargs</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Handle object conversion if input is an instance of lti.&quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">system</span><span class="s4">) == </span><span class="s6">1 </span><span class="s3">and </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">system</span><span class="s4">[</span><span class="s6">0</span><span class="s4">], </span><span class="s1">LinearTimeInvariant</span><span class="s4">):</span>
            <span class="s3">return </span><span class="s1">system</span><span class="s4">[</span><span class="s6">0</span><span class="s4">].</span><span class="s1">to_tf</span><span class="s4">()</span>

        <span class="s2"># Choose whether to inherit from `lti` or from `dlti`</span>
        <span class="s3">if </span><span class="s1">cls </span><span class="s3">is </span><span class="s1">TransferFunction</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">kwargs</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s5">'dt'</span><span class="s4">) </span><span class="s3">is None</span><span class="s4">:</span>
                <span class="s3">return </span><span class="s1">TransferFunctionContinuous</span><span class="s4">.</span><span class="s1">__new__</span><span class="s4">(</span>
                    <span class="s1">TransferFunctionContinuous</span><span class="s4">,</span>
                    <span class="s4">*</span><span class="s1">system</span><span class="s4">,</span>
                    <span class="s4">**</span><span class="s1">kwargs</span><span class="s4">)</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s3">return </span><span class="s1">TransferFunctionDiscrete</span><span class="s4">.</span><span class="s1">__new__</span><span class="s4">(</span>
                    <span class="s1">TransferFunctionDiscrete</span><span class="s4">,</span>
                    <span class="s4">*</span><span class="s1">system</span><span class="s4">,</span>
                    <span class="s4">**</span><span class="s1">kwargs</span><span class="s4">)</span>

        <span class="s2"># No special conversion needed</span>
        <span class="s3">return </span><span class="s1">super</span><span class="s4">().</span><span class="s1">__new__</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, *</span><span class="s1">system</span><span class="s4">, **</span><span class="s1">kwargs</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Initialize the state space LTI system.&quot;&quot;&quot;</span>
        <span class="s2"># Conversion of lti instances is handled in __new__</span>
        <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">system</span><span class="s4">[</span><span class="s6">0</span><span class="s4">], </span><span class="s1">LinearTimeInvariant</span><span class="s4">):</span>
            <span class="s3">return</span>

        <span class="s2"># Remove system arguments, not needed by parents anymore</span>
        <span class="s1">super</span><span class="s4">().</span><span class="s1">__init__</span><span class="s4">(**</span><span class="s1">kwargs</span><span class="s4">)</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">_num </span><span class="s4">= </span><span class="s3">None</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_den </span><span class="s4">= </span><span class="s3">None</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">num</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">den </span><span class="s4">= </span><span class="s1">normalize</span><span class="s4">(*</span><span class="s1">system</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">__repr__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Return representation of the system's transfer function&quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s4">(</span>
            <span class="s5">f'</span><span class="s3">{</span><span class="s1">self</span><span class="s4">.</span><span class="s1">__class__</span><span class="s4">.</span><span class="s1">__name__</span><span class="s3">}</span><span class="s5">(</span><span class="s3">\n</span><span class="s5">'</span>
            <span class="s5">f'</span><span class="s3">{</span><span class="s1">repr</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">num</span><span class="s4">)</span><span class="s3">}</span><span class="s5">,</span><span class="s3">\n</span><span class="s5">'</span>
            <span class="s5">f'</span><span class="s3">{</span><span class="s1">repr</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">den</span><span class="s4">)</span><span class="s3">}</span><span class="s5">,</span><span class="s3">\n</span><span class="s5">'</span>
            <span class="s5">f'dt: </span><span class="s3">{</span><span class="s1">repr</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">dt</span><span class="s4">)</span><span class="s3">}\n</span><span class="s5">)'</span>
        <span class="s4">)</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">num</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Numerator of the `TransferFunction` system.&quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_num</span>

    <span class="s4">@</span><span class="s1">num</span><span class="s4">.</span><span class="s1">setter</span>
    <span class="s3">def </span><span class="s1">num</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">num</span><span class="s4">):</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_num </span><span class="s4">= </span><span class="s1">atleast_1d</span><span class="s4">(</span><span class="s1">num</span><span class="s4">)</span>

        <span class="s2"># Update dimensions</span>
        <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">num</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">) &gt; </span><span class="s6">1</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">outputs</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">inputs </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">num</span><span class="s4">.</span><span class="s1">shape</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">outputs </span><span class="s4">= </span><span class="s6">1</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">inputs </span><span class="s4">= </span><span class="s6">1</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">den</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Denominator of the `TransferFunction` system.&quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_den</span>

    <span class="s4">@</span><span class="s1">den</span><span class="s4">.</span><span class="s1">setter</span>
    <span class="s3">def </span><span class="s1">den</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">den</span><span class="s4">):</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_den </span><span class="s4">= </span><span class="s1">atleast_1d</span><span class="s4">(</span><span class="s1">den</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_copy</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">system</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Copy the parameters of another `TransferFunction` object 
 
        Parameters 
        ---------- 
        system : `TransferFunction` 
            The `StateSpace` system that is to be copied 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">num </span><span class="s4">= </span><span class="s1">system</span><span class="s4">.</span><span class="s1">num</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">den </span><span class="s4">= </span><span class="s1">system</span><span class="s4">.</span><span class="s1">den</span>

    <span class="s3">def </span><span class="s1">to_tf</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return a copy of the current `TransferFunction` system. 
 
        Returns 
        ------- 
        sys : instance of `TransferFunction` 
            The current system (copy) 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">copy</span><span class="s4">.</span><span class="s1">deepcopy</span><span class="s4">(</span><span class="s1">self</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">to_zpk</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Convert system representation to `ZerosPolesGain`. 
 
        Returns 
        ------- 
        sys : instance of `ZerosPolesGain` 
            Zeros, poles, gain representation of the current system 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">ZerosPolesGain</span><span class="s4">(*</span><span class="s1">tf2zpk</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">num</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">den</span><span class="s4">),</span>
                              <span class="s4">**</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_dt_dict</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">to_ss</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Convert system representation to `StateSpace`. 
 
        Returns 
        ------- 
        sys : instance of `StateSpace` 
            State space model of the current system 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">StateSpace</span><span class="s4">(*</span><span class="s1">tf2ss</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">num</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">den</span><span class="s4">),</span>
                          <span class="s4">**</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_dt_dict</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">staticmethod</span>
    <span class="s3">def </span><span class="s1">_z_to_zinv</span><span class="s4">(</span><span class="s1">num</span><span class="s4">, </span><span class="s1">den</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Change a transfer function from the variable `z` to `z**-1`. 
 
        Parameters 
        ---------- 
        num, den: 1d array_like 
            Sequences representing the coefficients of the numerator and 
            denominator polynomials, in order of descending degree of 'z'. 
            That is, ``5z**2 + 3z + 2`` is presented as ``[5, 3, 2]``. 
 
        Returns 
        ------- 
        num, den: 1d array_like 
            Sequences representing the coefficients of the numerator and 
            denominator polynomials, in order of ascending degree of 'z**-1'. 
            That is, ``5 + 3 z**-1 + 2 z**-2`` is presented as ``[5, 3, 2]``. 
        &quot;&quot;&quot;</span>
        <span class="s1">diff </span><span class="s4">= </span><span class="s1">len</span><span class="s4">(</span><span class="s1">num</span><span class="s4">) - </span><span class="s1">len</span><span class="s4">(</span><span class="s1">den</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">diff </span><span class="s4">&gt; </span><span class="s6">0</span><span class="s4">:</span>
            <span class="s1">den </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">hstack</span><span class="s4">((</span><span class="s1">np</span><span class="s4">.</span><span class="s1">zeros</span><span class="s4">(</span><span class="s1">diff</span><span class="s4">), </span><span class="s1">den</span><span class="s4">))</span>
        <span class="s3">elif </span><span class="s1">diff </span><span class="s4">&lt; </span><span class="s6">0</span><span class="s4">:</span>
            <span class="s1">num </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">hstack</span><span class="s4">((</span><span class="s1">np</span><span class="s4">.</span><span class="s1">zeros</span><span class="s4">(-</span><span class="s1">diff</span><span class="s4">), </span><span class="s1">num</span><span class="s4">))</span>
        <span class="s3">return </span><span class="s1">num</span><span class="s4">, </span><span class="s1">den</span>

    <span class="s4">@</span><span class="s1">staticmethod</span>
    <span class="s3">def </span><span class="s1">_zinv_to_z</span><span class="s4">(</span><span class="s1">num</span><span class="s4">, </span><span class="s1">den</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Change a transfer function from the variable `z` to `z**-1`. 
 
        Parameters 
        ---------- 
        num, den: 1d array_like 
            Sequences representing the coefficients of the numerator and 
            denominator polynomials, in order of ascending degree of 'z**-1'. 
            That is, ``5 + 3 z**-1 + 2 z**-2`` is presented as ``[5, 3, 2]``. 
 
        Returns 
        ------- 
        num, den: 1d array_like 
            Sequences representing the coefficients of the numerator and 
            denominator polynomials, in order of descending degree of 'z'. 
            That is, ``5z**2 + 3z + 2`` is presented as ``[5, 3, 2]``. 
        &quot;&quot;&quot;</span>
        <span class="s1">diff </span><span class="s4">= </span><span class="s1">len</span><span class="s4">(</span><span class="s1">num</span><span class="s4">) - </span><span class="s1">len</span><span class="s4">(</span><span class="s1">den</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">diff </span><span class="s4">&gt; </span><span class="s6">0</span><span class="s4">:</span>
            <span class="s1">den </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">hstack</span><span class="s4">((</span><span class="s1">den</span><span class="s4">, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">zeros</span><span class="s4">(</span><span class="s1">diff</span><span class="s4">)))</span>
        <span class="s3">elif </span><span class="s1">diff </span><span class="s4">&lt; </span><span class="s6">0</span><span class="s4">:</span>
            <span class="s1">num </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">hstack</span><span class="s4">((</span><span class="s1">num</span><span class="s4">, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">zeros</span><span class="s4">(-</span><span class="s1">diff</span><span class="s4">)))</span>
        <span class="s3">return </span><span class="s1">num</span><span class="s4">, </span><span class="s1">den</span>


<span class="s3">class </span><span class="s1">TransferFunctionContinuous</span><span class="s4">(</span><span class="s1">TransferFunction</span><span class="s4">, </span><span class="s1">lti</span><span class="s4">):</span>
    <span class="s0">r&quot;&quot;&quot; 
    Continuous-time Linear Time Invariant system in transfer function form. 
 
    Represents the system as the transfer function 
    :math:`H(s)=\sum_{i=0}^N b[N-i] s^i / \sum_{j=0}^M a[M-j] s^j`, where 
    :math:`b` are elements of the numerator `num`, :math:`a` are elements of 
    the denominator `den`, and ``N == len(b) - 1``, ``M == len(a) - 1``. 
    Continuous-time `TransferFunction` systems inherit additional 
    functionality from the `lti` class. 
 
    Parameters 
    ---------- 
    *system: arguments 
        The `TransferFunction` class can be instantiated with 1 or 2 
        arguments. The following gives the number of input arguments and their 
        interpretation: 
 
            * 1: `lti` system: (`StateSpace`, `TransferFunction` or 
              `ZerosPolesGain`) 
            * 2: array_like: (numerator, denominator) 
 
    See Also 
    -------- 
    ZerosPolesGain, StateSpace, lti 
    tf2ss, tf2zpk, tf2sos 
 
    Notes 
    ----- 
    Changing the value of properties that are not part of the 
    `TransferFunction` system representation (such as the `A`, `B`, `C`, `D` 
    state-space matrices) is very inefficient and may lead to numerical 
    inaccuracies.  It is better to convert to the specific system 
    representation first. For example, call ``sys = sys.to_ss()`` before 
    accessing/changing the A, B, C, D system matrices. 
 
    If (numerator, denominator) is passed in for ``*system``, coefficients 
    for both the numerator and denominator should be specified in descending 
    exponent order (e.g. ``s^2 + 3s + 5`` would be represented as 
    ``[1, 3, 5]``) 
 
    Examples 
    -------- 
    Construct the transfer function 
    :math:`H(s) = \frac{s^2 + 3s + 3}{s^2 + 2s + 1}`: 
 
    &gt;&gt;&gt; from scipy import signal 
 
    &gt;&gt;&gt; num = [1, 3, 3] 
    &gt;&gt;&gt; den = [1, 2, 1] 
 
    &gt;&gt;&gt; signal.TransferFunction(num, den) 
    TransferFunctionContinuous( 
    array([ 1.,  3.,  3.]), 
    array([ 1.,  2.,  1.]), 
    dt: None 
    ) 
 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">to_discrete</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">dt</span><span class="s4">, </span><span class="s1">method</span><span class="s4">=</span><span class="s5">'zoh'</span><span class="s4">, </span><span class="s1">alpha</span><span class="s4">=</span><span class="s3">None</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Returns the discretized `TransferFunction` system. 
 
        Parameters: See `cont2discrete` for details. 
 
        Returns 
        ------- 
        sys: instance of `dlti` and `StateSpace` 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">TransferFunction</span><span class="s4">(*</span><span class="s1">cont2discrete</span><span class="s4">((</span><span class="s1">self</span><span class="s4">.</span><span class="s1">num</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">den</span><span class="s4">),</span>
                                               <span class="s1">dt</span><span class="s4">,</span>
                                               <span class="s1">method</span><span class="s4">=</span><span class="s1">method</span><span class="s4">,</span>
                                               <span class="s1">alpha</span><span class="s4">=</span><span class="s1">alpha</span><span class="s4">)[:-</span><span class="s6">1</span><span class="s4">],</span>
                                <span class="s1">dt</span><span class="s4">=</span><span class="s1">dt</span><span class="s4">)</span>


<span class="s3">class </span><span class="s1">TransferFunctionDiscrete</span><span class="s4">(</span><span class="s1">TransferFunction</span><span class="s4">, </span><span class="s1">dlti</span><span class="s4">):</span>
    <span class="s0">r&quot;&quot;&quot; 
    Discrete-time Linear Time Invariant system in transfer function form. 
 
    Represents the system as the transfer function 
    :math:`H(z)=\sum_{i=0}^N b[N-i] z^i / \sum_{j=0}^M a[M-j] z^j`, where 
    :math:`b` are elements of the numerator `num`, :math:`a` are elements of 
    the denominator `den`, and ``N == len(b) - 1``, ``M == len(a) - 1``. 
    Discrete-time `TransferFunction` systems inherit additional functionality 
    from the `dlti` class. 
 
    Parameters 
    ---------- 
    *system: arguments 
        The `TransferFunction` class can be instantiated with 1 or 2 
        arguments. The following gives the number of input arguments and their 
        interpretation: 
 
            * 1: `dlti` system: (`StateSpace`, `TransferFunction` or 
              `ZerosPolesGain`) 
            * 2: array_like: (numerator, denominator) 
    dt: float, optional 
        Sampling time [s] of the discrete-time systems. Defaults to `True` 
        (unspecified sampling time). Must be specified as a keyword argument, 
        for example, ``dt=0.1``. 
 
    See Also 
    -------- 
    ZerosPolesGain, StateSpace, dlti 
    tf2ss, tf2zpk, tf2sos 
 
    Notes 
    ----- 
    Changing the value of properties that are not part of the 
    `TransferFunction` system representation (such as the `A`, `B`, `C`, `D` 
    state-space matrices) is very inefficient and may lead to numerical 
    inaccuracies. 
 
    If (numerator, denominator) is passed in for ``*system``, coefficients 
    for both the numerator and denominator should be specified in descending 
    exponent order (e.g., ``z^2 + 3z + 5`` would be represented as 
    ``[1, 3, 5]``). 
 
    Examples 
    -------- 
    Construct the transfer function 
    :math:`H(z) = \frac{z^2 + 3z + 3}{z^2 + 2z + 1}` with a sampling time of 
    0.5 seconds: 
 
    &gt;&gt;&gt; from scipy import signal 
 
    &gt;&gt;&gt; num = [1, 3, 3] 
    &gt;&gt;&gt; den = [1, 2, 1] 
 
    &gt;&gt;&gt; signal.TransferFunction(num, den, dt=0.5) 
    TransferFunctionDiscrete( 
    array([ 1.,  3.,  3.]), 
    array([ 1.,  2.,  1.]), 
    dt: 0.5 
    ) 
 
    &quot;&quot;&quot;</span>
    <span class="s3">pass</span>


<span class="s3">class </span><span class="s1">ZerosPolesGain</span><span class="s4">(</span><span class="s1">LinearTimeInvariant</span><span class="s4">):</span>
    <span class="s0">r&quot;&quot;&quot; 
    Linear Time Invariant system class in zeros, poles, gain form. 
 
    Represents the system as the continuous- or discrete-time transfer function 
    :math:`H(s)=k \prod_i (s - z[i]) / \prod_j (s - p[j])`, where :math:`k` is 
    the `gain`, :math:`z` are the `zeros` and :math:`p` are the `poles`. 
    `ZerosPolesGain` systems inherit additional functionality from the `lti`, 
    respectively the `dlti` classes, depending on which system representation 
    is used. 
 
    Parameters 
    ---------- 
    *system : arguments 
        The `ZerosPolesGain` class can be instantiated with 1 or 3 
        arguments. The following gives the number of input arguments and their 
        interpretation: 
 
            * 1: `lti` or `dlti` system: (`StateSpace`, `TransferFunction` or 
              `ZerosPolesGain`) 
            * 3: array_like: (zeros, poles, gain) 
    dt: float, optional 
        Sampling time [s] of the discrete-time systems. Defaults to `None` 
        (continuous-time). Must be specified as a keyword argument, for 
        example, ``dt=0.1``. 
 
 
    See Also 
    -------- 
    TransferFunction, StateSpace, lti, dlti 
    zpk2ss, zpk2tf, zpk2sos 
 
    Notes 
    ----- 
    Changing the value of properties that are not part of the 
    `ZerosPolesGain` system representation (such as the `A`, `B`, `C`, `D` 
    state-space matrices) is very inefficient and may lead to numerical 
    inaccuracies.  It is better to convert to the specific system 
    representation first. For example, call ``sys = sys.to_ss()`` before 
    accessing/changing the A, B, C, D system matrices. 
 
    Examples 
    -------- 
    Construct the transfer function 
    :math:`H(s) = \frac{5(s - 1)(s - 2)}{(s - 3)(s - 4)}`: 
 
    &gt;&gt;&gt; from scipy import signal 
 
    &gt;&gt;&gt; signal.ZerosPolesGain([1, 2], [3, 4], 5) 
    ZerosPolesGainContinuous( 
    array([1, 2]), 
    array([3, 4]), 
    5, 
    dt: None 
    ) 
 
    Construct the transfer function 
    :math:`H(z) = \frac{5(z - 1)(z - 2)}{(z - 3)(z - 4)}` with a sampling time 
    of 0.1 seconds: 
 
    &gt;&gt;&gt; signal.ZerosPolesGain([1, 2], [3, 4], 5, dt=0.1) 
    ZerosPolesGainDiscrete( 
    array([1, 2]), 
    array([3, 4]), 
    5, 
    dt: 0.1 
    ) 
 
    &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">__new__</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">, *</span><span class="s1">system</span><span class="s4">, **</span><span class="s1">kwargs</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Handle object conversion if input is an instance of `lti`&quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">system</span><span class="s4">) == </span><span class="s6">1 </span><span class="s3">and </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">system</span><span class="s4">[</span><span class="s6">0</span><span class="s4">], </span><span class="s1">LinearTimeInvariant</span><span class="s4">):</span>
            <span class="s3">return </span><span class="s1">system</span><span class="s4">[</span><span class="s6">0</span><span class="s4">].</span><span class="s1">to_zpk</span><span class="s4">()</span>

        <span class="s2"># Choose whether to inherit from `lti` or from `dlti`</span>
        <span class="s3">if </span><span class="s1">cls </span><span class="s3">is </span><span class="s1">ZerosPolesGain</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">kwargs</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s5">'dt'</span><span class="s4">) </span><span class="s3">is None</span><span class="s4">:</span>
                <span class="s3">return </span><span class="s1">ZerosPolesGainContinuous</span><span class="s4">.</span><span class="s1">__new__</span><span class="s4">(</span>
                    <span class="s1">ZerosPolesGainContinuous</span><span class="s4">,</span>
                    <span class="s4">*</span><span class="s1">system</span><span class="s4">,</span>
                    <span class="s4">**</span><span class="s1">kwargs</span><span class="s4">)</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s3">return </span><span class="s1">ZerosPolesGainDiscrete</span><span class="s4">.</span><span class="s1">__new__</span><span class="s4">(</span>
                    <span class="s1">ZerosPolesGainDiscrete</span><span class="s4">,</span>
                    <span class="s4">*</span><span class="s1">system</span><span class="s4">,</span>
                    <span class="s4">**</span><span class="s1">kwargs</span>
                    <span class="s4">)</span>

        <span class="s2"># No special conversion needed</span>
        <span class="s3">return </span><span class="s1">super</span><span class="s4">().</span><span class="s1">__new__</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, *</span><span class="s1">system</span><span class="s4">, **</span><span class="s1">kwargs</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Initialize the zeros, poles, gain system.&quot;&quot;&quot;</span>
        <span class="s2"># Conversion of lti instances is handled in __new__</span>
        <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">system</span><span class="s4">[</span><span class="s6">0</span><span class="s4">], </span><span class="s1">LinearTimeInvariant</span><span class="s4">):</span>
            <span class="s3">return</span>

        <span class="s1">super</span><span class="s4">().</span><span class="s1">__init__</span><span class="s4">(**</span><span class="s1">kwargs</span><span class="s4">)</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">_zeros </span><span class="s4">= </span><span class="s3">None</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_poles </span><span class="s4">= </span><span class="s3">None</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_gain </span><span class="s4">= </span><span class="s3">None</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">zeros</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">poles</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">gain </span><span class="s4">= </span><span class="s1">system</span>

    <span class="s3">def </span><span class="s1">__repr__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Return representation of the `ZerosPolesGain` system.&quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s4">(</span>
            <span class="s5">f'</span><span class="s3">{</span><span class="s1">self</span><span class="s4">.</span><span class="s1">__class__</span><span class="s4">.</span><span class="s1">__name__</span><span class="s3">}</span><span class="s5">(</span><span class="s3">\n</span><span class="s5">'</span>
            <span class="s5">f'</span><span class="s3">{</span><span class="s1">repr</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">zeros</span><span class="s4">)</span><span class="s3">}</span><span class="s5">,</span><span class="s3">\n</span><span class="s5">'</span>
            <span class="s5">f'</span><span class="s3">{</span><span class="s1">repr</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">poles</span><span class="s4">)</span><span class="s3">}</span><span class="s5">,</span><span class="s3">\n</span><span class="s5">'</span>
            <span class="s5">f'</span><span class="s3">{</span><span class="s1">repr</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">gain</span><span class="s4">)</span><span class="s3">}</span><span class="s5">,</span><span class="s3">\n</span><span class="s5">'</span>
            <span class="s5">f'dt: </span><span class="s3">{</span><span class="s1">repr</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">dt</span><span class="s4">)</span><span class="s3">}\n</span><span class="s5">)'</span>
        <span class="s4">)</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">zeros</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Zeros of the `ZerosPolesGain` system.&quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_zeros</span>

    <span class="s4">@</span><span class="s1">zeros</span><span class="s4">.</span><span class="s1">setter</span>
    <span class="s3">def </span><span class="s1">zeros</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">zeros</span><span class="s4">):</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_zeros </span><span class="s4">= </span><span class="s1">atleast_1d</span><span class="s4">(</span><span class="s1">zeros</span><span class="s4">)</span>

        <span class="s2"># Update dimensions</span>
        <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">zeros</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">) &gt; </span><span class="s6">1</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">outputs</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">inputs </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">zeros</span><span class="s4">.</span><span class="s1">shape</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">outputs </span><span class="s4">= </span><span class="s6">1</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">inputs </span><span class="s4">= </span><span class="s6">1</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">poles</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Poles of the `ZerosPolesGain` system.&quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_poles</span>

    <span class="s4">@</span><span class="s1">poles</span><span class="s4">.</span><span class="s1">setter</span>
    <span class="s3">def </span><span class="s1">poles</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">poles</span><span class="s4">):</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_poles </span><span class="s4">= </span><span class="s1">atleast_1d</span><span class="s4">(</span><span class="s1">poles</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">gain</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Gain of the `ZerosPolesGain` system.&quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_gain</span>

    <span class="s4">@</span><span class="s1">gain</span><span class="s4">.</span><span class="s1">setter</span>
    <span class="s3">def </span><span class="s1">gain</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">gain</span><span class="s4">):</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_gain </span><span class="s4">= </span><span class="s1">gain</span>

    <span class="s3">def </span><span class="s1">_copy</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">system</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Copy the parameters of another `ZerosPolesGain` system. 
 
        Parameters 
        ---------- 
        system : instance of `ZerosPolesGain` 
            The zeros, poles gain system that is to be copied 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">poles </span><span class="s4">= </span><span class="s1">system</span><span class="s4">.</span><span class="s1">poles</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">zeros </span><span class="s4">= </span><span class="s1">system</span><span class="s4">.</span><span class="s1">zeros</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">gain </span><span class="s4">= </span><span class="s1">system</span><span class="s4">.</span><span class="s1">gain</span>

    <span class="s3">def </span><span class="s1">to_tf</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Convert system representation to `TransferFunction`. 
 
        Returns 
        ------- 
        sys : instance of `TransferFunction` 
            Transfer function of the current system 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">TransferFunction</span><span class="s4">(*</span><span class="s1">zpk2tf</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">zeros</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">poles</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">gain</span><span class="s4">),</span>
                                <span class="s4">**</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_dt_dict</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">to_zpk</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return a copy of the current 'ZerosPolesGain' system. 
 
        Returns 
        ------- 
        sys : instance of `ZerosPolesGain` 
            The current system (copy) 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">copy</span><span class="s4">.</span><span class="s1">deepcopy</span><span class="s4">(</span><span class="s1">self</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">to_ss</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Convert system representation to `StateSpace`. 
 
        Returns 
        ------- 
        sys : instance of `StateSpace` 
            State space model of the current system 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">StateSpace</span><span class="s4">(*</span><span class="s1">zpk2ss</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">zeros</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">poles</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">gain</span><span class="s4">),</span>
                          <span class="s4">**</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_dt_dict</span><span class="s4">)</span>


<span class="s3">class </span><span class="s1">ZerosPolesGainContinuous</span><span class="s4">(</span><span class="s1">ZerosPolesGain</span><span class="s4">, </span><span class="s1">lti</span><span class="s4">):</span>
    <span class="s0">r&quot;&quot;&quot; 
    Continuous-time Linear Time Invariant system in zeros, poles, gain form. 
 
    Represents the system as the continuous time transfer function 
    :math:`H(s)=k \prod_i (s - z[i]) / \prod_j (s - p[j])`, where :math:`k` is 
    the `gain`, :math:`z` are the `zeros` and :math:`p` are the `poles`. 
    Continuous-time `ZerosPolesGain` systems inherit additional functionality 
    from the `lti` class. 
 
    Parameters 
    ---------- 
    *system : arguments 
        The `ZerosPolesGain` class can be instantiated with 1 or 3 
        arguments. The following gives the number of input arguments and their 
        interpretation: 
 
            * 1: `lti` system: (`StateSpace`, `TransferFunction` or 
              `ZerosPolesGain`) 
            * 3: array_like: (zeros, poles, gain) 
 
    See Also 
    -------- 
    TransferFunction, StateSpace, lti 
    zpk2ss, zpk2tf, zpk2sos 
 
    Notes 
    ----- 
    Changing the value of properties that are not part of the 
    `ZerosPolesGain` system representation (such as the `A`, `B`, `C`, `D` 
    state-space matrices) is very inefficient and may lead to numerical 
    inaccuracies.  It is better to convert to the specific system 
    representation first. For example, call ``sys = sys.to_ss()`` before 
    accessing/changing the A, B, C, D system matrices. 
 
    Examples 
    -------- 
    Construct the transfer function 
    :math:`H(s)=\frac{5(s - 1)(s - 2)}{(s - 3)(s - 4)}`: 
 
    &gt;&gt;&gt; from scipy import signal 
 
    &gt;&gt;&gt; signal.ZerosPolesGain([1, 2], [3, 4], 5) 
    ZerosPolesGainContinuous( 
    array([1, 2]), 
    array([3, 4]), 
    5, 
    dt: None 
    ) 
 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">to_discrete</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">dt</span><span class="s4">, </span><span class="s1">method</span><span class="s4">=</span><span class="s5">'zoh'</span><span class="s4">, </span><span class="s1">alpha</span><span class="s4">=</span><span class="s3">None</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Returns the discretized `ZerosPolesGain` system. 
 
        Parameters: See `cont2discrete` for details. 
 
        Returns 
        ------- 
        sys: instance of `dlti` and `ZerosPolesGain` 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">ZerosPolesGain</span><span class="s4">(</span>
            <span class="s4">*</span><span class="s1">cont2discrete</span><span class="s4">((</span><span class="s1">self</span><span class="s4">.</span><span class="s1">zeros</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">poles</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">gain</span><span class="s4">),</span>
                           <span class="s1">dt</span><span class="s4">,</span>
                           <span class="s1">method</span><span class="s4">=</span><span class="s1">method</span><span class="s4">,</span>
                           <span class="s1">alpha</span><span class="s4">=</span><span class="s1">alpha</span><span class="s4">)[:-</span><span class="s6">1</span><span class="s4">],</span>
            <span class="s1">dt</span><span class="s4">=</span><span class="s1">dt</span><span class="s4">)</span>


<span class="s3">class </span><span class="s1">ZerosPolesGainDiscrete</span><span class="s4">(</span><span class="s1">ZerosPolesGain</span><span class="s4">, </span><span class="s1">dlti</span><span class="s4">):</span>
    <span class="s0">r&quot;&quot;&quot; 
    Discrete-time Linear Time Invariant system in zeros, poles, gain form. 
 
    Represents the system as the discrete-time transfer function 
    :math:`H(z)=k \prod_i (z - q[i]) / \prod_j (z - p[j])`, where :math:`k` is 
    the `gain`, :math:`q` are the `zeros` and :math:`p` are the `poles`. 
    Discrete-time `ZerosPolesGain` systems inherit additional functionality 
    from the `dlti` class. 
 
    Parameters 
    ---------- 
    *system : arguments 
        The `ZerosPolesGain` class can be instantiated with 1 or 3 
        arguments. The following gives the number of input arguments and their 
        interpretation: 
 
            * 1: `dlti` system: (`StateSpace`, `TransferFunction` or 
              `ZerosPolesGain`) 
            * 3: array_like: (zeros, poles, gain) 
    dt: float, optional 
        Sampling time [s] of the discrete-time systems. Defaults to `True` 
        (unspecified sampling time). Must be specified as a keyword argument, 
        for example, ``dt=0.1``. 
 
    See Also 
    -------- 
    TransferFunction, StateSpace, dlti 
    zpk2ss, zpk2tf, zpk2sos 
 
    Notes 
    ----- 
    Changing the value of properties that are not part of the 
    `ZerosPolesGain` system representation (such as the `A`, `B`, `C`, `D` 
    state-space matrices) is very inefficient and may lead to numerical 
    inaccuracies.  It is better to convert to the specific system 
    representation first. For example, call ``sys = sys.to_ss()`` before 
    accessing/changing the A, B, C, D system matrices. 
 
    Examples 
    -------- 
    Construct the transfer function 
    :math:`H(s) = \frac{5(s - 1)(s - 2)}{(s - 3)(s - 4)}`: 
 
    &gt;&gt;&gt; from scipy import signal 
 
    &gt;&gt;&gt; signal.ZerosPolesGain([1, 2], [3, 4], 5) 
    ZerosPolesGainContinuous( 
    array([1, 2]), 
    array([3, 4]), 
    5, 
    dt: None 
    ) 
 
    Construct the transfer function 
    :math:`H(z) = \frac{5(z - 1)(z - 2)}{(z - 3)(z - 4)}` with a sampling time 
    of 0.1 seconds: 
 
    &gt;&gt;&gt; signal.ZerosPolesGain([1, 2], [3, 4], 5, dt=0.1) 
    ZerosPolesGainDiscrete( 
    array([1, 2]), 
    array([3, 4]), 
    5, 
    dt: 0.1 
    ) 
 
    &quot;&quot;&quot;</span>
    <span class="s3">pass</span>


<span class="s3">class </span><span class="s1">StateSpace</span><span class="s4">(</span><span class="s1">LinearTimeInvariant</span><span class="s4">):</span>
    <span class="s0">r&quot;&quot;&quot; 
    Linear Time Invariant system in state-space form. 
 
    Represents the system as the continuous-time, first order differential 
    equation :math:`\dot{x} = A x + B u` or the discrete-time difference 
    equation :math:`x[k+1] = A x[k] + B u[k]`. `StateSpace` systems 
    inherit additional functionality from the `lti`, respectively the `dlti` 
    classes, depending on which system representation is used. 
 
    Parameters 
    ---------- 
    *system: arguments 
        The `StateSpace` class can be instantiated with 1 or 4 arguments. 
        The following gives the number of input arguments and their 
        interpretation: 
 
            * 1: `lti` or `dlti` system: (`StateSpace`, `TransferFunction` or 
              `ZerosPolesGain`) 
            * 4: array_like: (A, B, C, D) 
    dt: float, optional 
        Sampling time [s] of the discrete-time systems. Defaults to `None` 
        (continuous-time). Must be specified as a keyword argument, for 
        example, ``dt=0.1``. 
 
    See Also 
    -------- 
    TransferFunction, ZerosPolesGain, lti, dlti 
    ss2zpk, ss2tf, zpk2sos 
 
    Notes 
    ----- 
    Changing the value of properties that are not part of the 
    `StateSpace` system representation (such as `zeros` or `poles`) is very 
    inefficient and may lead to numerical inaccuracies.  It is better to 
    convert to the specific system representation first. For example, call 
    ``sys = sys.to_zpk()`` before accessing/changing the zeros, poles or gain. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy import signal 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; a = np.array([[0, 1], [0, 0]]) 
    &gt;&gt;&gt; b = np.array([[0], [1]]) 
    &gt;&gt;&gt; c = np.array([[1, 0]]) 
    &gt;&gt;&gt; d = np.array([[0]]) 
 
    &gt;&gt;&gt; sys = signal.StateSpace(a, b, c, d) 
    &gt;&gt;&gt; print(sys) 
    StateSpaceContinuous( 
    array([[0, 1], 
           [0, 0]]), 
    array([[0], 
           [1]]), 
    array([[1, 0]]), 
    array([[0]]), 
    dt: None 
    ) 
 
    &gt;&gt;&gt; sys.to_discrete(0.1) 
    StateSpaceDiscrete( 
    array([[1. , 0.1], 
           [0. , 1. ]]), 
    array([[0.005], 
           [0.1  ]]), 
    array([[1, 0]]), 
    array([[0]]), 
    dt: 0.1 
    ) 
 
    &gt;&gt;&gt; a = np.array([[1, 0.1], [0, 1]]) 
    &gt;&gt;&gt; b = np.array([[0.005], [0.1]]) 
 
    &gt;&gt;&gt; signal.StateSpace(a, b, c, d, dt=0.1) 
    StateSpaceDiscrete( 
    array([[1. , 0.1], 
           [0. , 1. ]]), 
    array([[0.005], 
           [0.1  ]]), 
    array([[1, 0]]), 
    array([[0]]), 
    dt: 0.1 
    ) 
 
    &quot;&quot;&quot;</span>

    <span class="s2"># Override NumPy binary operations and ufuncs</span>
    <span class="s1">__array_priority__ </span><span class="s4">= </span><span class="s6">100.0</span>
    <span class="s1">__array_ufunc__ </span><span class="s4">= </span><span class="s3">None</span>

    <span class="s3">def </span><span class="s1">__new__</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">, *</span><span class="s1">system</span><span class="s4">, **</span><span class="s1">kwargs</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Create new StateSpace object and settle inheritance.&quot;&quot;&quot;</span>
        <span class="s2"># Handle object conversion if input is an instance of `lti`</span>
        <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">system</span><span class="s4">) == </span><span class="s6">1 </span><span class="s3">and </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">system</span><span class="s4">[</span><span class="s6">0</span><span class="s4">], </span><span class="s1">LinearTimeInvariant</span><span class="s4">):</span>
            <span class="s3">return </span><span class="s1">system</span><span class="s4">[</span><span class="s6">0</span><span class="s4">].</span><span class="s1">to_ss</span><span class="s4">()</span>

        <span class="s2"># Choose whether to inherit from `lti` or from `dlti`</span>
        <span class="s3">if </span><span class="s1">cls </span><span class="s3">is </span><span class="s1">StateSpace</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">kwargs</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s5">'dt'</span><span class="s4">) </span><span class="s3">is None</span><span class="s4">:</span>
                <span class="s3">return </span><span class="s1">StateSpaceContinuous</span><span class="s4">.</span><span class="s1">__new__</span><span class="s4">(</span><span class="s1">StateSpaceContinuous</span><span class="s4">,</span>
                                                    <span class="s4">*</span><span class="s1">system</span><span class="s4">, **</span><span class="s1">kwargs</span><span class="s4">)</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s3">return </span><span class="s1">StateSpaceDiscrete</span><span class="s4">.</span><span class="s1">__new__</span><span class="s4">(</span><span class="s1">StateSpaceDiscrete</span><span class="s4">,</span>
                                                  <span class="s4">*</span><span class="s1">system</span><span class="s4">, **</span><span class="s1">kwargs</span><span class="s4">)</span>

        <span class="s2"># No special conversion needed</span>
        <span class="s3">return </span><span class="s1">super</span><span class="s4">().</span><span class="s1">__new__</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, *</span><span class="s1">system</span><span class="s4">, **</span><span class="s1">kwargs</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Initialize the state space lti/dlti system.&quot;&quot;&quot;</span>
        <span class="s2"># Conversion of lti instances is handled in __new__</span>
        <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">system</span><span class="s4">[</span><span class="s6">0</span><span class="s4">], </span><span class="s1">LinearTimeInvariant</span><span class="s4">):</span>
            <span class="s3">return</span>

        <span class="s2"># Remove system arguments, not needed by parents anymore</span>
        <span class="s1">super</span><span class="s4">().</span><span class="s1">__init__</span><span class="s4">(**</span><span class="s1">kwargs</span><span class="s4">)</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">_A </span><span class="s4">= </span><span class="s3">None</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_B </span><span class="s4">= </span><span class="s3">None</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_C </span><span class="s4">= </span><span class="s3">None</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_D </span><span class="s4">= </span><span class="s3">None</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">A</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">B</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">C</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">D </span><span class="s4">= </span><span class="s1">abcd_normalize</span><span class="s4">(*</span><span class="s1">system</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">__repr__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Return representation of the `StateSpace` system.&quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s4">(</span>
            <span class="s5">f'</span><span class="s3">{</span><span class="s1">self</span><span class="s4">.</span><span class="s1">__class__</span><span class="s4">.</span><span class="s1">__name__</span><span class="s3">}</span><span class="s5">(</span><span class="s3">\n</span><span class="s5">'</span>
            <span class="s5">f'</span><span class="s3">{</span><span class="s1">repr</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">A</span><span class="s4">)</span><span class="s3">}</span><span class="s5">,</span><span class="s3">\n</span><span class="s5">'</span>
            <span class="s5">f'</span><span class="s3">{</span><span class="s1">repr</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">B</span><span class="s4">)</span><span class="s3">}</span><span class="s5">,</span><span class="s3">\n</span><span class="s5">'</span>
            <span class="s5">f'</span><span class="s3">{</span><span class="s1">repr</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">C</span><span class="s4">)</span><span class="s3">}</span><span class="s5">,</span><span class="s3">\n</span><span class="s5">'</span>
            <span class="s5">f'</span><span class="s3">{</span><span class="s1">repr</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">D</span><span class="s4">)</span><span class="s3">}</span><span class="s5">,</span><span class="s3">\n</span><span class="s5">'</span>
            <span class="s5">f'dt: </span><span class="s3">{</span><span class="s1">repr</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">dt</span><span class="s4">)</span><span class="s3">}\n</span><span class="s5">)'</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_check_binop_other</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">other</span><span class="s4">, (</span><span class="s1">StateSpace</span><span class="s4">, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">ndarray</span><span class="s4">, </span><span class="s1">float</span><span class="s4">, </span><span class="s1">complex</span><span class="s4">,</span>
                                  <span class="s1">np</span><span class="s4">.</span><span class="s1">number</span><span class="s4">, </span><span class="s1">int</span><span class="s4">))</span>

    <span class="s3">def </span><span class="s1">__mul__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Post-multiply another system or a scalar 
 
        Handles multiplication of systems in the sense of a frequency domain 
        multiplication. That means, given two systems E1(s) and E2(s), their 
        multiplication, H(s) = E1(s) * E2(s), means that applying H(s) to U(s) 
        is equivalent to first applying E2(s), and then E1(s). 
 
        Notes 
        ----- 
        For SISO systems the order of system application does not matter. 
        However, for MIMO systems, where the two systems are matrices, the 
        order above ensures standard Matrix multiplication rules apply. 
        &quot;&quot;&quot;</span>
        <span class="s3">if not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_check_binop_other</span><span class="s4">(</span><span class="s1">other</span><span class="s4">):</span>
            <span class="s3">return </span><span class="s1">NotImplemented</span>

        <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">other</span><span class="s4">, </span><span class="s1">StateSpace</span><span class="s4">):</span>
            <span class="s2"># Disallow mix of discrete and continuous systems.</span>
            <span class="s3">if </span><span class="s1">type</span><span class="s4">(</span><span class="s1">other</span><span class="s4">) </span><span class="s3">is not </span><span class="s1">type</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
                <span class="s3">return </span><span class="s1">NotImplemented</span>

            <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">dt </span><span class="s4">!= </span><span class="s1">other</span><span class="s4">.</span><span class="s1">dt</span><span class="s4">:</span>
                <span class="s3">raise </span><span class="s1">TypeError</span><span class="s4">(</span><span class="s5">'Cannot multiply systems with different `dt`.'</span><span class="s4">)</span>

            <span class="s1">n1 </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">A</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]</span>
            <span class="s1">n2 </span><span class="s4">= </span><span class="s1">other</span><span class="s4">.</span><span class="s1">A</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]</span>

            <span class="s2"># Interconnection of systems</span>
            <span class="s2"># x1' = A1 x1 + B1 u1</span>
            <span class="s2"># y1  = C1 x1 + D1 u1</span>
            <span class="s2"># x2' = A2 x2 + B2 y1</span>
            <span class="s2"># y2  = C2 x2 + D2 y1</span>
            <span class="s2">#</span>
            <span class="s2"># Plugging in with u1 = y2 yields</span>
            <span class="s2"># [x1']   [A1 B1*C2 ] [x1]   [B1*D2]</span>
            <span class="s2"># [x2'] = [0  A2    ] [x2] + [B2   ] u2</span>
            <span class="s2">#                    [x1]</span>
            <span class="s2">#  y2   = [C1 D1*C2] [x2] + D1*D2 u2</span>
            <span class="s1">a </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">vstack</span><span class="s4">((</span><span class="s1">np</span><span class="s4">.</span><span class="s1">hstack</span><span class="s4">((</span><span class="s1">self</span><span class="s4">.</span><span class="s1">A</span><span class="s4">, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">dot</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">B</span><span class="s4">, </span><span class="s1">other</span><span class="s4">.</span><span class="s1">C</span><span class="s4">))),</span>
                           <span class="s1">np</span><span class="s4">.</span><span class="s1">hstack</span><span class="s4">((</span><span class="s1">zeros</span><span class="s4">((</span><span class="s1">n2</span><span class="s4">, </span><span class="s1">n1</span><span class="s4">)), </span><span class="s1">other</span><span class="s4">.</span><span class="s1">A</span><span class="s4">))))</span>
            <span class="s1">b </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">vstack</span><span class="s4">((</span><span class="s1">np</span><span class="s4">.</span><span class="s1">dot</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">B</span><span class="s4">, </span><span class="s1">other</span><span class="s4">.</span><span class="s1">D</span><span class="s4">), </span><span class="s1">other</span><span class="s4">.</span><span class="s1">B</span><span class="s4">))</span>
            <span class="s1">c </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">hstack</span><span class="s4">((</span><span class="s1">self</span><span class="s4">.</span><span class="s1">C</span><span class="s4">, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">dot</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">D</span><span class="s4">, </span><span class="s1">other</span><span class="s4">.</span><span class="s1">C</span><span class="s4">)))</span>
            <span class="s1">d </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">dot</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">D</span><span class="s4">, </span><span class="s1">other</span><span class="s4">.</span><span class="s1">D</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s2"># Assume that other is a scalar / matrix</span>
            <span class="s2"># For post multiplication the input gets scaled</span>
            <span class="s1">a </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">A</span>
            <span class="s1">b </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">dot</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">B</span><span class="s4">, </span><span class="s1">other</span><span class="s4">)</span>
            <span class="s1">c </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">C</span>
            <span class="s1">d </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">dot</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">D</span><span class="s4">, </span><span class="s1">other</span><span class="s4">)</span>

        <span class="s1">common_dtype </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">result_type</span><span class="s4">(</span><span class="s1">a</span><span class="s4">.</span><span class="s1">dtype</span><span class="s4">, </span><span class="s1">b</span><span class="s4">.</span><span class="s1">dtype</span><span class="s4">, </span><span class="s1">c</span><span class="s4">.</span><span class="s1">dtype</span><span class="s4">, </span><span class="s1">d</span><span class="s4">.</span><span class="s1">dtype</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">StateSpace</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">(</span><span class="s1">a</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">common_dtype</span><span class="s4">),</span>
                          <span class="s1">np</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">(</span><span class="s1">b</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">common_dtype</span><span class="s4">),</span>
                          <span class="s1">np</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">(</span><span class="s1">c</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">common_dtype</span><span class="s4">),</span>
                          <span class="s1">np</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">(</span><span class="s1">d</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">common_dtype</span><span class="s4">),</span>
                          <span class="s4">**</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_dt_dict</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">__rmul__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Pre-multiply a scalar or matrix (but not StateSpace)&quot;&quot;&quot;</span>
        <span class="s3">if not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_check_binop_other</span><span class="s4">(</span><span class="s1">other</span><span class="s4">) </span><span class="s3">or </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">other</span><span class="s4">, </span><span class="s1">StateSpace</span><span class="s4">):</span>
            <span class="s3">return </span><span class="s1">NotImplemented</span>

        <span class="s2"># For pre-multiplication only the output gets scaled</span>
        <span class="s1">a </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">A</span>
        <span class="s1">b </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">B</span>
        <span class="s1">c </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">dot</span><span class="s4">(</span><span class="s1">other</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">C</span><span class="s4">)</span>
        <span class="s1">d </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">dot</span><span class="s4">(</span><span class="s1">other</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">D</span><span class="s4">)</span>

        <span class="s1">common_dtype </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">result_type</span><span class="s4">(</span><span class="s1">a</span><span class="s4">.</span><span class="s1">dtype</span><span class="s4">, </span><span class="s1">b</span><span class="s4">.</span><span class="s1">dtype</span><span class="s4">, </span><span class="s1">c</span><span class="s4">.</span><span class="s1">dtype</span><span class="s4">, </span><span class="s1">d</span><span class="s4">.</span><span class="s1">dtype</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">StateSpace</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">(</span><span class="s1">a</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">common_dtype</span><span class="s4">),</span>
                          <span class="s1">np</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">(</span><span class="s1">b</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">common_dtype</span><span class="s4">),</span>
                          <span class="s1">np</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">(</span><span class="s1">c</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">common_dtype</span><span class="s4">),</span>
                          <span class="s1">np</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">(</span><span class="s1">d</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">common_dtype</span><span class="s4">),</span>
                          <span class="s4">**</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_dt_dict</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">__neg__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Negate the system (equivalent to pre-multiplying by -1).&quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">StateSpace</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">A</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">B</span><span class="s4">, -</span><span class="s1">self</span><span class="s4">.</span><span class="s1">C</span><span class="s4">, -</span><span class="s1">self</span><span class="s4">.</span><span class="s1">D</span><span class="s4">, **</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_dt_dict</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">__add__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Adds two systems in the sense of frequency domain addition. 
        &quot;&quot;&quot;</span>
        <span class="s3">if not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_check_binop_other</span><span class="s4">(</span><span class="s1">other</span><span class="s4">):</span>
            <span class="s3">return </span><span class="s1">NotImplemented</span>

        <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">other</span><span class="s4">, </span><span class="s1">StateSpace</span><span class="s4">):</span>
            <span class="s2"># Disallow mix of discrete and continuous systems.</span>
            <span class="s3">if </span><span class="s1">type</span><span class="s4">(</span><span class="s1">other</span><span class="s4">) </span><span class="s3">is not </span><span class="s1">type</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
                <span class="s3">raise </span><span class="s1">TypeError</span><span class="s4">(</span><span class="s5">f'Cannot add </span><span class="s3">{</span><span class="s1">type</span><span class="s4">(</span><span class="s1">self</span><span class="s4">)</span><span class="s3">} </span><span class="s5">and </span><span class="s3">{</span><span class="s1">type</span><span class="s4">(</span><span class="s1">other</span><span class="s4">)</span><span class="s3">}</span><span class="s5">'</span><span class="s4">)</span>

            <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">dt </span><span class="s4">!= </span><span class="s1">other</span><span class="s4">.</span><span class="s1">dt</span><span class="s4">:</span>
                <span class="s3">raise </span><span class="s1">TypeError</span><span class="s4">(</span><span class="s5">'Cannot add systems with different `dt`.'</span><span class="s4">)</span>
            <span class="s2"># Interconnection of systems</span>
            <span class="s2"># x1' = A1 x1 + B1 u</span>
            <span class="s2"># y1  = C1 x1 + D1 u</span>
            <span class="s2"># x2' = A2 x2 + B2 u</span>
            <span class="s2"># y2  = C2 x2 + D2 u</span>
            <span class="s2"># y   = y1 + y2</span>
            <span class="s2">#</span>
            <span class="s2"># Plugging in yields</span>
            <span class="s2"># [x1']   [A1 0 ] [x1]   [B1]</span>
            <span class="s2"># [x2'] = [0  A2] [x2] + [B2] u</span>
            <span class="s2">#                 [x1]</span>
            <span class="s2">#  y    = [C1 C2] [x2] + [D1 + D2] u</span>
            <span class="s1">a </span><span class="s4">= </span><span class="s1">linalg</span><span class="s4">.</span><span class="s1">block_diag</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">A</span><span class="s4">, </span><span class="s1">other</span><span class="s4">.</span><span class="s1">A</span><span class="s4">)</span>
            <span class="s1">b </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">vstack</span><span class="s4">((</span><span class="s1">self</span><span class="s4">.</span><span class="s1">B</span><span class="s4">, </span><span class="s1">other</span><span class="s4">.</span><span class="s1">B</span><span class="s4">))</span>
            <span class="s1">c </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">hstack</span><span class="s4">((</span><span class="s1">self</span><span class="s4">.</span><span class="s1">C</span><span class="s4">, </span><span class="s1">other</span><span class="s4">.</span><span class="s1">C</span><span class="s4">))</span>
            <span class="s1">d </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">D </span><span class="s4">+ </span><span class="s1">other</span><span class="s4">.</span><span class="s1">D</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">other </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">atleast_2d</span><span class="s4">(</span><span class="s1">other</span><span class="s4">)</span>
            <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">D</span><span class="s4">.</span><span class="s1">shape </span><span class="s4">== </span><span class="s1">other</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">:</span>
                <span class="s2"># A scalar/matrix is really just a static system (A=0, B=0, C=0)</span>
                <span class="s1">a </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">A</span>
                <span class="s1">b </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">B</span>
                <span class="s1">c </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">C</span>
                <span class="s1">d </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">D </span><span class="s4">+ </span><span class="s1">other</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;Cannot add systems with incompatible &quot;</span>
                                 <span class="s5">f&quot;dimensions (</span><span class="s3">{</span><span class="s1">self</span><span class="s4">.</span><span class="s1">D</span><span class="s4">.</span><span class="s1">shape</span><span class="s3">} </span><span class="s5">and </span><span class="s3">{</span><span class="s1">other</span><span class="s4">.</span><span class="s1">shape</span><span class="s3">}</span><span class="s5">)&quot;</span><span class="s4">)</span>

        <span class="s1">common_dtype </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">result_type</span><span class="s4">(</span><span class="s1">a</span><span class="s4">.</span><span class="s1">dtype</span><span class="s4">, </span><span class="s1">b</span><span class="s4">.</span><span class="s1">dtype</span><span class="s4">, </span><span class="s1">c</span><span class="s4">.</span><span class="s1">dtype</span><span class="s4">, </span><span class="s1">d</span><span class="s4">.</span><span class="s1">dtype</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">StateSpace</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">(</span><span class="s1">a</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">common_dtype</span><span class="s4">),</span>
                          <span class="s1">np</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">(</span><span class="s1">b</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">common_dtype</span><span class="s4">),</span>
                          <span class="s1">np</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">(</span><span class="s1">c</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">common_dtype</span><span class="s4">),</span>
                          <span class="s1">np</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">(</span><span class="s1">d</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">common_dtype</span><span class="s4">),</span>
                          <span class="s4">**</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_dt_dict</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">__sub__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">):</span>
        <span class="s3">if not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_check_binop_other</span><span class="s4">(</span><span class="s1">other</span><span class="s4">):</span>
            <span class="s3">return </span><span class="s1">NotImplemented</span>

        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">__add__</span><span class="s4">(-</span><span class="s1">other</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">__radd__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">):</span>
        <span class="s3">if not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_check_binop_other</span><span class="s4">(</span><span class="s1">other</span><span class="s4">):</span>
            <span class="s3">return </span><span class="s1">NotImplemented</span>

        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">__add__</span><span class="s4">(</span><span class="s1">other</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">__rsub__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">):</span>
        <span class="s3">if not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_check_binop_other</span><span class="s4">(</span><span class="s1">other</span><span class="s4">):</span>
            <span class="s3">return </span><span class="s1">NotImplemented</span>

        <span class="s3">return </span><span class="s4">(-</span><span class="s1">self</span><span class="s4">).</span><span class="s1">__add__</span><span class="s4">(</span><span class="s1">other</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">__truediv__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Divide by a scalar 
        &quot;&quot;&quot;</span>
        <span class="s2"># Division by non-StateSpace scalars</span>
        <span class="s3">if not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_check_binop_other</span><span class="s4">(</span><span class="s1">other</span><span class="s4">) </span><span class="s3">or </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">other</span><span class="s4">, </span><span class="s1">StateSpace</span><span class="s4">):</span>
            <span class="s3">return </span><span class="s1">NotImplemented</span>

        <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">other</span><span class="s4">, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">ndarray</span><span class="s4">) </span><span class="s3">and </span><span class="s1">other</span><span class="s4">.</span><span class="s1">ndim </span><span class="s4">&gt; </span><span class="s6">0</span><span class="s4">:</span>
            <span class="s2"># It's ambiguous what this means, so disallow it</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;Cannot divide StateSpace by non-scalar numpy arrays&quot;</span><span class="s4">)</span>

        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">__mul__</span><span class="s4">(</span><span class="s6">1</span><span class="s4">/</span><span class="s1">other</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">A</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;State matrix of the `StateSpace` system.&quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_A</span>

    <span class="s4">@</span><span class="s1">A</span><span class="s4">.</span><span class="s1">setter</span>
    <span class="s3">def </span><span class="s1">A</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">A</span><span class="s4">):</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_A </span><span class="s4">= </span><span class="s1">_atleast_2d_or_none</span><span class="s4">(</span><span class="s1">A</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">B</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Input matrix of the `StateSpace` system.&quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_B</span>

    <span class="s4">@</span><span class="s1">B</span><span class="s4">.</span><span class="s1">setter</span>
    <span class="s3">def </span><span class="s1">B</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">B</span><span class="s4">):</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_B </span><span class="s4">= </span><span class="s1">_atleast_2d_or_none</span><span class="s4">(</span><span class="s1">B</span><span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">inputs </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">B</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[-</span><span class="s6">1</span><span class="s4">]</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">C</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Output matrix of the `StateSpace` system.&quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_C</span>

    <span class="s4">@</span><span class="s1">C</span><span class="s4">.</span><span class="s1">setter</span>
    <span class="s3">def </span><span class="s1">C</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">C</span><span class="s4">):</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_C </span><span class="s4">= </span><span class="s1">_atleast_2d_or_none</span><span class="s4">(</span><span class="s1">C</span><span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">outputs </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">C</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">D</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Feedthrough matrix of the `StateSpace` system.&quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_D</span>

    <span class="s4">@</span><span class="s1">D</span><span class="s4">.</span><span class="s1">setter</span>
    <span class="s3">def </span><span class="s1">D</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">D</span><span class="s4">):</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_D </span><span class="s4">= </span><span class="s1">_atleast_2d_or_none</span><span class="s4">(</span><span class="s1">D</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_copy</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">system</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Copy the parameters of another `StateSpace` system. 
 
        Parameters 
        ---------- 
        system : instance of `StateSpace` 
            The state-space system that is to be copied 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">A </span><span class="s4">= </span><span class="s1">system</span><span class="s4">.</span><span class="s1">A</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">B </span><span class="s4">= </span><span class="s1">system</span><span class="s4">.</span><span class="s1">B</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">C </span><span class="s4">= </span><span class="s1">system</span><span class="s4">.</span><span class="s1">C</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">D </span><span class="s4">= </span><span class="s1">system</span><span class="s4">.</span><span class="s1">D</span>

    <span class="s3">def </span><span class="s1">to_tf</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, **</span><span class="s1">kwargs</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Convert system representation to `TransferFunction`. 
 
        Parameters 
        ---------- 
        kwargs : dict, optional 
            Additional keywords passed to `ss2zpk` 
 
        Returns 
        ------- 
        sys : instance of `TransferFunction` 
            Transfer function of the current system 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">TransferFunction</span><span class="s4">(*</span><span class="s1">ss2tf</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_A</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_B</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_C</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_D</span><span class="s4">,</span>
                                       <span class="s4">**</span><span class="s1">kwargs</span><span class="s4">), **</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_dt_dict</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">to_zpk</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, **</span><span class="s1">kwargs</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Convert system representation to `ZerosPolesGain`. 
 
        Parameters 
        ---------- 
        kwargs : dict, optional 
            Additional keywords passed to `ss2zpk` 
 
        Returns 
        ------- 
        sys : instance of `ZerosPolesGain` 
            Zeros, poles, gain representation of the current system 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">ZerosPolesGain</span><span class="s4">(*</span><span class="s1">ss2zpk</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_A</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_B</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_C</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_D</span><span class="s4">,</span>
                                      <span class="s4">**</span><span class="s1">kwargs</span><span class="s4">), **</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_dt_dict</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">to_ss</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return a copy of the current `StateSpace` system. 
 
        Returns 
        ------- 
        sys : instance of `StateSpace` 
            The current system (copy) 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">copy</span><span class="s4">.</span><span class="s1">deepcopy</span><span class="s4">(</span><span class="s1">self</span><span class="s4">)</span>


<span class="s3">class </span><span class="s1">StateSpaceContinuous</span><span class="s4">(</span><span class="s1">StateSpace</span><span class="s4">, </span><span class="s1">lti</span><span class="s4">):</span>
    <span class="s0">r&quot;&quot;&quot; 
    Continuous-time Linear Time Invariant system in state-space form. 
 
    Represents the system as the continuous-time, first order differential 
    equation :math:`\dot{x} = A x + B u`. 
    Continuous-time `StateSpace` systems inherit additional functionality 
    from the `lti` class. 
 
    Parameters 
    ---------- 
    *system: arguments 
        The `StateSpace` class can be instantiated with 1 or 3 arguments. 
        The following gives the number of input arguments and their 
        interpretation: 
 
            * 1: `lti` system: (`StateSpace`, `TransferFunction` or 
              `ZerosPolesGain`) 
            * 4: array_like: (A, B, C, D) 
 
    See Also 
    -------- 
    TransferFunction, ZerosPolesGain, lti 
    ss2zpk, ss2tf, zpk2sos 
 
    Notes 
    ----- 
    Changing the value of properties that are not part of the 
    `StateSpace` system representation (such as `zeros` or `poles`) is very 
    inefficient and may lead to numerical inaccuracies.  It is better to 
    convert to the specific system representation first. For example, call 
    ``sys = sys.to_zpk()`` before accessing/changing the zeros, poles or gain. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import signal 
 
    &gt;&gt;&gt; a = np.array([[0, 1], [0, 0]]) 
    &gt;&gt;&gt; b = np.array([[0], [1]]) 
    &gt;&gt;&gt; c = np.array([[1, 0]]) 
    &gt;&gt;&gt; d = np.array([[0]]) 
 
    &gt;&gt;&gt; sys = signal.StateSpace(a, b, c, d) 
    &gt;&gt;&gt; print(sys) 
    StateSpaceContinuous( 
    array([[0, 1], 
           [0, 0]]), 
    array([[0], 
           [1]]), 
    array([[1, 0]]), 
    array([[0]]), 
    dt: None 
    ) 
 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">to_discrete</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">dt</span><span class="s4">, </span><span class="s1">method</span><span class="s4">=</span><span class="s5">'zoh'</span><span class="s4">, </span><span class="s1">alpha</span><span class="s4">=</span><span class="s3">None</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Returns the discretized `StateSpace` system. 
 
        Parameters: See `cont2discrete` for details. 
 
        Returns 
        ------- 
        sys: instance of `dlti` and `StateSpace` 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">StateSpace</span><span class="s4">(*</span><span class="s1">cont2discrete</span><span class="s4">((</span><span class="s1">self</span><span class="s4">.</span><span class="s1">A</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">B</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">C</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">D</span><span class="s4">),</span>
                                         <span class="s1">dt</span><span class="s4">,</span>
                                         <span class="s1">method</span><span class="s4">=</span><span class="s1">method</span><span class="s4">,</span>
                                         <span class="s1">alpha</span><span class="s4">=</span><span class="s1">alpha</span><span class="s4">)[:-</span><span class="s6">1</span><span class="s4">],</span>
                          <span class="s1">dt</span><span class="s4">=</span><span class="s1">dt</span><span class="s4">)</span>


<span class="s3">class </span><span class="s1">StateSpaceDiscrete</span><span class="s4">(</span><span class="s1">StateSpace</span><span class="s4">, </span><span class="s1">dlti</span><span class="s4">):</span>
    <span class="s0">r&quot;&quot;&quot; 
    Discrete-time Linear Time Invariant system in state-space form. 
 
    Represents the system as the discrete-time difference equation 
    :math:`x[k+1] = A x[k] + B u[k]`. 
    `StateSpace` systems inherit additional functionality from the `dlti` 
    class. 
 
    Parameters 
    ---------- 
    *system: arguments 
        The `StateSpace` class can be instantiated with 1 or 3 arguments. 
        The following gives the number of input arguments and their 
        interpretation: 
 
            * 1: `dlti` system: (`StateSpace`, `TransferFunction` or 
              `ZerosPolesGain`) 
            * 4: array_like: (A, B, C, D) 
    dt: float, optional 
        Sampling time [s] of the discrete-time systems. Defaults to `True` 
        (unspecified sampling time). Must be specified as a keyword argument, 
        for example, ``dt=0.1``. 
 
    See Also 
    -------- 
    TransferFunction, ZerosPolesGain, dlti 
    ss2zpk, ss2tf, zpk2sos 
 
    Notes 
    ----- 
    Changing the value of properties that are not part of the 
    `StateSpace` system representation (such as `zeros` or `poles`) is very 
    inefficient and may lead to numerical inaccuracies.  It is better to 
    convert to the specific system representation first. For example, call 
    ``sys = sys.to_zpk()`` before accessing/changing the zeros, poles or gain. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import signal 
 
    &gt;&gt;&gt; a = np.array([[1, 0.1], [0, 1]]) 
    &gt;&gt;&gt; b = np.array([[0.005], [0.1]]) 
    &gt;&gt;&gt; c = np.array([[1, 0]]) 
    &gt;&gt;&gt; d = np.array([[0]]) 
 
    &gt;&gt;&gt; signal.StateSpace(a, b, c, d, dt=0.1) 
    StateSpaceDiscrete( 
    array([[ 1. ,  0.1], 
           [ 0. ,  1. ]]), 
    array([[ 0.005], 
           [ 0.1  ]]), 
    array([[1, 0]]), 
    array([[0]]), 
    dt: 0.1 
    ) 
 
    &quot;&quot;&quot;</span>
    <span class="s3">pass</span>


<span class="s3">def </span><span class="s1">lsim</span><span class="s4">(</span><span class="s1">system</span><span class="s4">, </span><span class="s1">U</span><span class="s4">, </span><span class="s1">T</span><span class="s4">, </span><span class="s1">X0</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">interp</span><span class="s4">=</span><span class="s3">True</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Simulate output of a continuous-time linear system. 
 
    Parameters 
    ---------- 
    system : an instance of the LTI class or a tuple describing the system. 
        The following gives the number of elements in the tuple and 
        the interpretation: 
 
        * 1: (instance of `lti`) 
        * 2: (num, den) 
        * 3: (zeros, poles, gain) 
        * 4: (A, B, C, D) 
 
    U : array_like 
        An input array describing the input at each time `T` 
        (interpolation is assumed between given times).  If there are 
        multiple inputs, then each column of the rank-2 array 
        represents an input.  If U = 0 or None, a zero input is used. 
    T : array_like 
        The time steps at which the input is defined and at which the 
        output is desired.  Must be nonnegative, increasing, and equally spaced. 
    X0 : array_like, optional 
        The initial conditions on the state vector (zero by default). 
    interp : bool, optional 
        Whether to use linear (True, the default) or zero-order-hold (False) 
        interpolation for the input array. 
 
    Returns 
    ------- 
    T : 1D ndarray 
        Time values for the output. 
    yout : 1D ndarray 
        System response. 
    xout : ndarray 
        Time evolution of the state vector. 
 
    Notes 
    ----- 
    If (num, den) is passed in for ``system``, coefficients for both the 
    numerator and denominator should be specified in descending exponent 
    order (e.g. ``s^2 + 3s + 5`` would be represented as ``[1, 3, 5]``). 
 
    Examples 
    -------- 
    We'll use `lsim` to simulate an analog Bessel filter applied to 
    a signal. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.signal import bessel, lsim 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
 
    Create a low-pass Bessel filter with a cutoff of 12 Hz. 
 
    &gt;&gt;&gt; b, a = bessel(N=5, Wn=2*np.pi*12, btype='lowpass', analog=True) 
 
    Generate data to which the filter is applied. 
 
    &gt;&gt;&gt; t = np.linspace(0, 1.25, 500, endpoint=False) 
 
    The input signal is the sum of three sinusoidal curves, with 
    frequencies 4 Hz, 40 Hz, and 80 Hz.  The filter should mostly 
    eliminate the 40 Hz and 80 Hz components, leaving just the 4 Hz signal. 
 
    &gt;&gt;&gt; u = (np.cos(2*np.pi*4*t) + 0.6*np.sin(2*np.pi*40*t) + 
    ...      0.5*np.cos(2*np.pi*80*t)) 
 
    Simulate the filter with `lsim`. 
 
    &gt;&gt;&gt; tout, yout, xout = lsim((b, a), U=u, T=t) 
 
    Plot the result. 
 
    &gt;&gt;&gt; plt.plot(t, u, 'r', alpha=0.5, linewidth=1, label='input') 
    &gt;&gt;&gt; plt.plot(tout, yout, 'k', linewidth=1.5, label='output') 
    &gt;&gt;&gt; plt.legend(loc='best', shadow=True, framealpha=1) 
    &gt;&gt;&gt; plt.grid(alpha=0.3) 
    &gt;&gt;&gt; plt.xlabel('t') 
    &gt;&gt;&gt; plt.show() 
 
    In a second example, we simulate a double integrator ``y'' = u``, with 
    a constant input ``u = 1``.  We'll use the state space representation 
    of the integrator. 
 
    &gt;&gt;&gt; from scipy.signal import lti 
    &gt;&gt;&gt; A = np.array([[0.0, 1.0], [0.0, 0.0]]) 
    &gt;&gt;&gt; B = np.array([[0.0], [1.0]]) 
    &gt;&gt;&gt; C = np.array([[1.0, 0.0]]) 
    &gt;&gt;&gt; D = 0.0 
    &gt;&gt;&gt; system = lti(A, B, C, D) 
 
    `t` and `u` define the time and input signal for the system to 
    be simulated. 
 
    &gt;&gt;&gt; t = np.linspace(0, 5, num=50) 
    &gt;&gt;&gt; u = np.ones_like(t) 
 
    Compute the simulation, and then plot `y`.  As expected, the plot shows 
    the curve ``y = 0.5*t**2``. 
 
    &gt;&gt;&gt; tout, y, x = lsim(system, u, t) 
    &gt;&gt;&gt; plt.plot(t, y) 
    &gt;&gt;&gt; plt.grid(alpha=0.3) 
    &gt;&gt;&gt; plt.xlabel('t') 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">system</span><span class="s4">, </span><span class="s1">lti</span><span class="s4">):</span>
        <span class="s1">sys </span><span class="s4">= </span><span class="s1">system</span><span class="s4">.</span><span class="s1">_as_ss</span><span class="s4">()</span>
    <span class="s3">elif </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">system</span><span class="s4">, </span><span class="s1">dlti</span><span class="s4">):</span>
        <span class="s3">raise </span><span class="s1">AttributeError</span><span class="s4">(</span><span class="s5">'lsim can only be used with continuous-time '</span>
                             <span class="s5">'systems.'</span><span class="s4">)</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">sys </span><span class="s4">= </span><span class="s1">lti</span><span class="s4">(*</span><span class="s1">system</span><span class="s4">).</span><span class="s1">_as_ss</span><span class="s4">()</span>
    <span class="s1">T </span><span class="s4">= </span><span class="s1">atleast_1d</span><span class="s4">(</span><span class="s1">T</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">T</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">) != </span><span class="s6">1</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;T must be a rank-1 array.&quot;</span><span class="s4">)</span>

    <span class="s1">A</span><span class="s4">, </span><span class="s1">B</span><span class="s4">, </span><span class="s1">C</span><span class="s4">, </span><span class="s1">D </span><span class="s4">= </span><span class="s1">map</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">, (</span><span class="s1">sys</span><span class="s4">.</span><span class="s1">A</span><span class="s4">, </span><span class="s1">sys</span><span class="s4">.</span><span class="s1">B</span><span class="s4">, </span><span class="s1">sys</span><span class="s4">.</span><span class="s1">C</span><span class="s4">, </span><span class="s1">sys</span><span class="s4">.</span><span class="s1">D</span><span class="s4">))</span>
    <span class="s1">n_states </span><span class="s4">= </span><span class="s1">A</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]</span>
    <span class="s1">n_inputs </span><span class="s4">= </span><span class="s1">B</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">1</span><span class="s4">]</span>

    <span class="s1">n_steps </span><span class="s4">= </span><span class="s1">T</span><span class="s4">.</span><span class="s1">size</span>
    <span class="s3">if </span><span class="s1">X0 </span><span class="s3">is None</span><span class="s4">:</span>
        <span class="s1">X0 </span><span class="s4">= </span><span class="s1">zeros</span><span class="s4">(</span><span class="s1">n_states</span><span class="s4">, </span><span class="s1">sys</span><span class="s4">.</span><span class="s1">A</span><span class="s4">.</span><span class="s1">dtype</span><span class="s4">)</span>
    <span class="s1">xout </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">empty</span><span class="s4">((</span><span class="s1">n_steps</span><span class="s4">, </span><span class="s1">n_states</span><span class="s4">), </span><span class="s1">sys</span><span class="s4">.</span><span class="s1">A</span><span class="s4">.</span><span class="s1">dtype</span><span class="s4">)</span>

    <span class="s3">if </span><span class="s1">T</span><span class="s4">[</span><span class="s6">0</span><span class="s4">] == </span><span class="s6">0</span><span class="s4">:</span>
        <span class="s1">xout</span><span class="s4">[</span><span class="s6">0</span><span class="s4">] = </span><span class="s1">X0</span>
    <span class="s3">elif </span><span class="s1">T</span><span class="s4">[</span><span class="s6">0</span><span class="s4">] &gt; </span><span class="s6">0</span><span class="s4">:</span>
        <span class="s2"># step forward to initial time, with zero input</span>
        <span class="s1">xout</span><span class="s4">[</span><span class="s6">0</span><span class="s4">] = </span><span class="s1">dot</span><span class="s4">(</span><span class="s1">X0</span><span class="s4">, </span><span class="s1">linalg</span><span class="s4">.</span><span class="s1">expm</span><span class="s4">(</span><span class="s1">transpose</span><span class="s4">(</span><span class="s1">A</span><span class="s4">) * </span><span class="s1">T</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]))</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;Initial time must be nonnegative&quot;</span><span class="s4">)</span>

    <span class="s1">no_input </span><span class="s4">= (</span><span class="s1">U </span><span class="s3">is None or</span>
                <span class="s4">(</span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">U</span><span class="s4">, (</span><span class="s1">int</span><span class="s4">, </span><span class="s1">float</span><span class="s4">)) </span><span class="s3">and </span><span class="s1">U </span><span class="s4">== </span><span class="s6">0.</span><span class="s4">) </span><span class="s3">or</span>
                <span class="s3">not </span><span class="s1">np</span><span class="s4">.</span><span class="s1">any</span><span class="s4">(</span><span class="s1">U</span><span class="s4">))</span>

    <span class="s3">if </span><span class="s1">n_steps </span><span class="s4">== </span><span class="s6">1</span><span class="s4">:</span>
        <span class="s1">yout </span><span class="s4">= </span><span class="s1">squeeze</span><span class="s4">(</span><span class="s1">xout </span><span class="s4">@ </span><span class="s1">C</span><span class="s4">.</span><span class="s1">T</span><span class="s4">)</span>
        <span class="s3">if not </span><span class="s1">no_input</span><span class="s4">:</span>
            <span class="s1">yout </span><span class="s4">+= </span><span class="s1">squeeze</span><span class="s4">(</span><span class="s1">U </span><span class="s4">@ </span><span class="s1">D</span><span class="s4">.</span><span class="s1">T</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">T</span><span class="s4">, </span><span class="s1">yout</span><span class="s4">, </span><span class="s1">squeeze</span><span class="s4">(</span><span class="s1">xout</span><span class="s4">)</span>

    <span class="s1">dt </span><span class="s4">= </span><span class="s1">T</span><span class="s4">[</span><span class="s6">1</span><span class="s4">] - </span><span class="s1">T</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]</span>
    <span class="s3">if not </span><span class="s1">np</span><span class="s4">.</span><span class="s1">allclose</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">diff</span><span class="s4">(</span><span class="s1">T</span><span class="s4">), </span><span class="s1">dt</span><span class="s4">):</span>
        <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;Time steps are not equally spaced.&quot;</span><span class="s4">)</span>

    <span class="s3">if </span><span class="s1">no_input</span><span class="s4">:</span>
        <span class="s2"># Zero input: just use matrix exponential</span>
        <span class="s2"># take transpose because state is a row vector</span>
        <span class="s1">expAT_dt </span><span class="s4">= </span><span class="s1">linalg</span><span class="s4">.</span><span class="s1">expm</span><span class="s4">(</span><span class="s1">A</span><span class="s4">.</span><span class="s1">T </span><span class="s4">* </span><span class="s1">dt</span><span class="s4">)</span>
        <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range</span><span class="s4">(</span><span class="s6">1</span><span class="s4">, </span><span class="s1">n_steps</span><span class="s4">):</span>
            <span class="s1">xout</span><span class="s4">[</span><span class="s1">i</span><span class="s4">] = </span><span class="s1">xout</span><span class="s4">[</span><span class="s1">i</span><span class="s4">-</span><span class="s6">1</span><span class="s4">] @ </span><span class="s1">expAT_dt</span>
        <span class="s1">yout </span><span class="s4">= </span><span class="s1">squeeze</span><span class="s4">(</span><span class="s1">xout </span><span class="s4">@ </span><span class="s1">C</span><span class="s4">.</span><span class="s1">T</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">T</span><span class="s4">, </span><span class="s1">yout</span><span class="s4">, </span><span class="s1">squeeze</span><span class="s4">(</span><span class="s1">xout</span><span class="s4">)</span>

    <span class="s2"># Nonzero input</span>
    <span class="s1">U </span><span class="s4">= </span><span class="s1">atleast_1d</span><span class="s4">(</span><span class="s1">U</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">U</span><span class="s4">.</span><span class="s1">ndim </span><span class="s4">== </span><span class="s6">1</span><span class="s4">:</span>
        <span class="s1">U </span><span class="s4">= </span><span class="s1">U</span><span class="s4">[:, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">newaxis</span><span class="s4">]</span>

    <span class="s3">if </span><span class="s1">U</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">] != </span><span class="s1">n_steps</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;U must have the same number of rows &quot;</span>
                         <span class="s5">&quot;as elements in T.&quot;</span><span class="s4">)</span>

    <span class="s3">if </span><span class="s1">U</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">1</span><span class="s4">] != </span><span class="s1">n_inputs</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;System does not define that many inputs.&quot;</span><span class="s4">)</span>

    <span class="s3">if not </span><span class="s1">interp</span><span class="s4">:</span>
        <span class="s2"># Zero-order hold</span>
        <span class="s2"># Algorithm: to integrate from time 0 to time dt, we solve</span>
        <span class="s2">#   xdot = A x + B u,  x(0) = x0</span>
        <span class="s2">#   udot = 0,          u(0) = u0.</span>
        <span class="s2">#</span>
        <span class="s2"># Solution is</span>
        <span class="s2">#   [ x(dt) ]       [ A*dt   B*dt ] [ x0 ]</span>
        <span class="s2">#   [ u(dt) ] = exp [  0     0    ] [ u0 ]</span>
        <span class="s1">M </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">vstack</span><span class="s4">([</span><span class="s1">np</span><span class="s4">.</span><span class="s1">hstack</span><span class="s4">([</span><span class="s1">A </span><span class="s4">* </span><span class="s1">dt</span><span class="s4">, </span><span class="s1">B </span><span class="s4">* </span><span class="s1">dt</span><span class="s4">]),</span>
                       <span class="s1">np</span><span class="s4">.</span><span class="s1">zeros</span><span class="s4">((</span><span class="s1">n_inputs</span><span class="s4">, </span><span class="s1">n_states </span><span class="s4">+ </span><span class="s1">n_inputs</span><span class="s4">))])</span>
        <span class="s2"># transpose everything because the state and input are row vectors</span>
        <span class="s1">expMT </span><span class="s4">= </span><span class="s1">linalg</span><span class="s4">.</span><span class="s1">expm</span><span class="s4">(</span><span class="s1">M</span><span class="s4">.</span><span class="s1">T</span><span class="s4">)</span>
        <span class="s1">Ad </span><span class="s4">= </span><span class="s1">expMT</span><span class="s4">[:</span><span class="s1">n_states</span><span class="s4">, :</span><span class="s1">n_states</span><span class="s4">]</span>
        <span class="s1">Bd </span><span class="s4">= </span><span class="s1">expMT</span><span class="s4">[</span><span class="s1">n_states</span><span class="s4">:, :</span><span class="s1">n_states</span><span class="s4">]</span>
        <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range</span><span class="s4">(</span><span class="s6">1</span><span class="s4">, </span><span class="s1">n_steps</span><span class="s4">):</span>
            <span class="s1">xout</span><span class="s4">[</span><span class="s1">i</span><span class="s4">] = </span><span class="s1">xout</span><span class="s4">[</span><span class="s1">i</span><span class="s4">-</span><span class="s6">1</span><span class="s4">] @ </span><span class="s1">Ad </span><span class="s4">+ </span><span class="s1">U</span><span class="s4">[</span><span class="s1">i</span><span class="s4">-</span><span class="s6">1</span><span class="s4">] @ </span><span class="s1">Bd</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s2"># Linear interpolation between steps</span>
        <span class="s2"># Algorithm: to integrate from time 0 to time dt, with linear</span>
        <span class="s2"># interpolation between inputs u(0) = u0 and u(dt) = u1, we solve</span>
        <span class="s2">#   xdot = A x + B u,        x(0) = x0</span>
        <span class="s2">#   udot = (u1 - u0) / dt,   u(0) = u0.</span>
        <span class="s2">#</span>
        <span class="s2"># Solution is</span>
        <span class="s2">#   [ x(dt) ]       [ A*dt  B*dt  0 ] [  x0   ]</span>
        <span class="s2">#   [ u(dt) ] = exp [  0     0    I ] [  u0   ]</span>
        <span class="s2">#   [u1 - u0]       [  0     0    0 ] [u1 - u0]</span>
        <span class="s1">M </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">vstack</span><span class="s4">([</span><span class="s1">np</span><span class="s4">.</span><span class="s1">hstack</span><span class="s4">([</span><span class="s1">A </span><span class="s4">* </span><span class="s1">dt</span><span class="s4">, </span><span class="s1">B </span><span class="s4">* </span><span class="s1">dt</span><span class="s4">,</span>
                                  <span class="s1">np</span><span class="s4">.</span><span class="s1">zeros</span><span class="s4">((</span><span class="s1">n_states</span><span class="s4">, </span><span class="s1">n_inputs</span><span class="s4">))]),</span>
                       <span class="s1">np</span><span class="s4">.</span><span class="s1">hstack</span><span class="s4">([</span><span class="s1">np</span><span class="s4">.</span><span class="s1">zeros</span><span class="s4">((</span><span class="s1">n_inputs</span><span class="s4">, </span><span class="s1">n_states </span><span class="s4">+ </span><span class="s1">n_inputs</span><span class="s4">)),</span>
                                  <span class="s1">np</span><span class="s4">.</span><span class="s1">identity</span><span class="s4">(</span><span class="s1">n_inputs</span><span class="s4">)]),</span>
                       <span class="s1">np</span><span class="s4">.</span><span class="s1">zeros</span><span class="s4">((</span><span class="s1">n_inputs</span><span class="s4">, </span><span class="s1">n_states </span><span class="s4">+ </span><span class="s6">2 </span><span class="s4">* </span><span class="s1">n_inputs</span><span class="s4">))])</span>
        <span class="s1">expMT </span><span class="s4">= </span><span class="s1">linalg</span><span class="s4">.</span><span class="s1">expm</span><span class="s4">(</span><span class="s1">M</span><span class="s4">.</span><span class="s1">T</span><span class="s4">)</span>
        <span class="s1">Ad </span><span class="s4">= </span><span class="s1">expMT</span><span class="s4">[:</span><span class="s1">n_states</span><span class="s4">, :</span><span class="s1">n_states</span><span class="s4">]</span>
        <span class="s1">Bd1 </span><span class="s4">= </span><span class="s1">expMT</span><span class="s4">[</span><span class="s1">n_states</span><span class="s4">+</span><span class="s1">n_inputs</span><span class="s4">:, :</span><span class="s1">n_states</span><span class="s4">]</span>
        <span class="s1">Bd0 </span><span class="s4">= </span><span class="s1">expMT</span><span class="s4">[</span><span class="s1">n_states</span><span class="s4">:</span><span class="s1">n_states </span><span class="s4">+ </span><span class="s1">n_inputs</span><span class="s4">, :</span><span class="s1">n_states</span><span class="s4">] - </span><span class="s1">Bd1</span>
        <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range</span><span class="s4">(</span><span class="s6">1</span><span class="s4">, </span><span class="s1">n_steps</span><span class="s4">):</span>
            <span class="s1">xout</span><span class="s4">[</span><span class="s1">i</span><span class="s4">] = </span><span class="s1">xout</span><span class="s4">[</span><span class="s1">i</span><span class="s4">-</span><span class="s6">1</span><span class="s4">] @ </span><span class="s1">Ad </span><span class="s4">+ </span><span class="s1">U</span><span class="s4">[</span><span class="s1">i</span><span class="s4">-</span><span class="s6">1</span><span class="s4">] @ </span><span class="s1">Bd0 </span><span class="s4">+ </span><span class="s1">U</span><span class="s4">[</span><span class="s1">i</span><span class="s4">] @ </span><span class="s1">Bd1</span>

    <span class="s1">yout </span><span class="s4">= </span><span class="s1">squeeze</span><span class="s4">(</span><span class="s1">xout </span><span class="s4">@ </span><span class="s1">C</span><span class="s4">.</span><span class="s1">T</span><span class="s4">) + </span><span class="s1">squeeze</span><span class="s4">(</span><span class="s1">U </span><span class="s4">@ </span><span class="s1">D</span><span class="s4">.</span><span class="s1">T</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s1">T</span><span class="s4">, </span><span class="s1">yout</span><span class="s4">, </span><span class="s1">squeeze</span><span class="s4">(</span><span class="s1">xout</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">_default_response_times</span><span class="s4">(</span><span class="s1">A</span><span class="s4">, </span><span class="s1">n</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Compute a reasonable set of time samples for the response time. 
 
    This function is used by `impulse` and `step`  to compute the response time 
    when the `T` argument to the function is None. 
 
    Parameters 
    ---------- 
    A : array_like 
        The system matrix, which is square. 
    n : int 
        The number of time samples to generate. 
 
    Returns 
    ------- 
    t : ndarray 
        The 1-D array of length `n` of time samples at which the response 
        is to be computed. 
    &quot;&quot;&quot;</span>
    <span class="s2"># Create a reasonable time interval.</span>
    <span class="s2"># TODO: This could use some more work.</span>
    <span class="s2"># For example, what is expected when the system is unstable?</span>
    <span class="s1">vals </span><span class="s4">= </span><span class="s1">linalg</span><span class="s4">.</span><span class="s1">eigvals</span><span class="s4">(</span><span class="s1">A</span><span class="s4">)</span>
    <span class="s1">r </span><span class="s4">= </span><span class="s1">min</span><span class="s4">(</span><span class="s1">abs</span><span class="s4">(</span><span class="s1">real</span><span class="s4">(</span><span class="s1">vals</span><span class="s4">)))</span>
    <span class="s3">if </span><span class="s1">r </span><span class="s4">== </span><span class="s6">0.0</span><span class="s4">:</span>
        <span class="s1">r </span><span class="s4">= </span><span class="s6">1.0</span>
    <span class="s1">tc </span><span class="s4">= </span><span class="s6">1.0 </span><span class="s4">/ </span><span class="s1">r</span>
    <span class="s1">t </span><span class="s4">= </span><span class="s1">linspace</span><span class="s4">(</span><span class="s6">0.0</span><span class="s4">, </span><span class="s6">7 </span><span class="s4">* </span><span class="s1">tc</span><span class="s4">, </span><span class="s1">n</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s1">t</span>


<span class="s3">def </span><span class="s1">impulse</span><span class="s4">(</span><span class="s1">system</span><span class="s4">, </span><span class="s1">X0</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">T</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">N</span><span class="s4">=</span><span class="s3">None</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Impulse response of continuous-time system. 
 
    Parameters 
    ---------- 
    system : an instance of the LTI class or a tuple of array_like 
        describing the system. 
        The following gives the number of elements in the tuple and 
        the interpretation: 
 
            * 1 (instance of `lti`) 
            * 2 (num, den) 
            * 3 (zeros, poles, gain) 
            * 4 (A, B, C, D) 
 
    X0 : array_like, optional 
        Initial state-vector.  Defaults to zero. 
    T : array_like, optional 
        Time points.  Computed if not given. 
    N : int, optional 
        The number of time points to compute (if `T` is not given). 
 
    Returns 
    ------- 
    T : ndarray 
        A 1-D array of time points. 
    yout : ndarray 
        A 1-D array containing the impulse response of the system (except for 
        singularities at zero). 
 
    Notes 
    ----- 
    If (num, den) is passed in for ``system``, coefficients for both the 
    numerator and denominator should be specified in descending exponent 
    order (e.g. ``s^2 + 3s + 5`` would be represented as ``[1, 3, 5]``). 
 
    Examples 
    -------- 
    Compute the impulse response of a second order system with a repeated 
    root: ``x''(t) + 2*x'(t) + x(t) = u(t)`` 
 
    &gt;&gt;&gt; from scipy import signal 
    &gt;&gt;&gt; system = ([1.0], [1.0, 2.0, 1.0]) 
    &gt;&gt;&gt; t, y = signal.impulse(system) 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; plt.plot(t, y) 
 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">system</span><span class="s4">, </span><span class="s1">lti</span><span class="s4">):</span>
        <span class="s1">sys </span><span class="s4">= </span><span class="s1">system</span><span class="s4">.</span><span class="s1">_as_ss</span><span class="s4">()</span>
    <span class="s3">elif </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">system</span><span class="s4">, </span><span class="s1">dlti</span><span class="s4">):</span>
        <span class="s3">raise </span><span class="s1">AttributeError</span><span class="s4">(</span><span class="s5">'impulse can only be used with continuous-time '</span>
                             <span class="s5">'systems.'</span><span class="s4">)</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">sys </span><span class="s4">= </span><span class="s1">lti</span><span class="s4">(*</span><span class="s1">system</span><span class="s4">).</span><span class="s1">_as_ss</span><span class="s4">()</span>
    <span class="s3">if </span><span class="s1">X0 </span><span class="s3">is None</span><span class="s4">:</span>
        <span class="s1">X </span><span class="s4">= </span><span class="s1">squeeze</span><span class="s4">(</span><span class="s1">sys</span><span class="s4">.</span><span class="s1">B</span><span class="s4">)</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">X </span><span class="s4">= </span><span class="s1">squeeze</span><span class="s4">(</span><span class="s1">sys</span><span class="s4">.</span><span class="s1">B </span><span class="s4">+ </span><span class="s1">X0</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">N </span><span class="s3">is None</span><span class="s4">:</span>
        <span class="s1">N </span><span class="s4">= </span><span class="s6">100</span>
    <span class="s3">if </span><span class="s1">T </span><span class="s3">is None</span><span class="s4">:</span>
        <span class="s1">T </span><span class="s4">= </span><span class="s1">_default_response_times</span><span class="s4">(</span><span class="s1">sys</span><span class="s4">.</span><span class="s1">A</span><span class="s4">, </span><span class="s1">N</span><span class="s4">)</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">T </span><span class="s4">= </span><span class="s1">asarray</span><span class="s4">(</span><span class="s1">T</span><span class="s4">)</span>

    <span class="s1">_</span><span class="s4">, </span><span class="s1">h</span><span class="s4">, </span><span class="s1">_ </span><span class="s4">= </span><span class="s1">lsim</span><span class="s4">(</span><span class="s1">sys</span><span class="s4">, </span><span class="s6">0.</span><span class="s4">, </span><span class="s1">T</span><span class="s4">, </span><span class="s1">X</span><span class="s4">, </span><span class="s1">interp</span><span class="s4">=</span><span class="s3">False</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s1">T</span><span class="s4">, </span><span class="s1">h</span>


<span class="s3">def </span><span class="s1">step</span><span class="s4">(</span><span class="s1">system</span><span class="s4">, </span><span class="s1">X0</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">T</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">N</span><span class="s4">=</span><span class="s3">None</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Step response of continuous-time system. 
 
    Parameters 
    ---------- 
    system : an instance of the LTI class or a tuple of array_like 
        describing the system. 
        The following gives the number of elements in the tuple and 
        the interpretation: 
 
            * 1 (instance of `lti`) 
            * 2 (num, den) 
            * 3 (zeros, poles, gain) 
            * 4 (A, B, C, D) 
 
    X0 : array_like, optional 
        Initial state-vector (default is zero). 
    T : array_like, optional 
        Time points (computed if not given). 
    N : int, optional 
        Number of time points to compute if `T` is not given. 
 
    Returns 
    ------- 
    T : 1D ndarray 
        Output time points. 
    yout : 1D ndarray 
        Step response of system. 
 
 
    Notes 
    ----- 
    If (num, den) is passed in for ``system``, coefficients for both the 
    numerator and denominator should be specified in descending exponent 
    order (e.g. ``s^2 + 3s + 5`` would be represented as ``[1, 3, 5]``). 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy import signal 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; lti = signal.lti([1.0], [1.0, 1.0]) 
    &gt;&gt;&gt; t, y = signal.step(lti) 
    &gt;&gt;&gt; plt.plot(t, y) 
    &gt;&gt;&gt; plt.xlabel('Time [s]') 
    &gt;&gt;&gt; plt.ylabel('Amplitude') 
    &gt;&gt;&gt; plt.title('Step response for 1. Order Lowpass') 
    &gt;&gt;&gt; plt.grid() 
 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">system</span><span class="s4">, </span><span class="s1">lti</span><span class="s4">):</span>
        <span class="s1">sys </span><span class="s4">= </span><span class="s1">system</span><span class="s4">.</span><span class="s1">_as_ss</span><span class="s4">()</span>
    <span class="s3">elif </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">system</span><span class="s4">, </span><span class="s1">dlti</span><span class="s4">):</span>
        <span class="s3">raise </span><span class="s1">AttributeError</span><span class="s4">(</span><span class="s5">'step can only be used with continuous-time '</span>
                             <span class="s5">'systems.'</span><span class="s4">)</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">sys </span><span class="s4">= </span><span class="s1">lti</span><span class="s4">(*</span><span class="s1">system</span><span class="s4">).</span><span class="s1">_as_ss</span><span class="s4">()</span>
    <span class="s3">if </span><span class="s1">N </span><span class="s3">is None</span><span class="s4">:</span>
        <span class="s1">N </span><span class="s4">= </span><span class="s6">100</span>
    <span class="s3">if </span><span class="s1">T </span><span class="s3">is None</span><span class="s4">:</span>
        <span class="s1">T </span><span class="s4">= </span><span class="s1">_default_response_times</span><span class="s4">(</span><span class="s1">sys</span><span class="s4">.</span><span class="s1">A</span><span class="s4">, </span><span class="s1">N</span><span class="s4">)</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">T </span><span class="s4">= </span><span class="s1">asarray</span><span class="s4">(</span><span class="s1">T</span><span class="s4">)</span>
    <span class="s1">U </span><span class="s4">= </span><span class="s1">ones</span><span class="s4">(</span><span class="s1">T</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">, </span><span class="s1">sys</span><span class="s4">.</span><span class="s1">A</span><span class="s4">.</span><span class="s1">dtype</span><span class="s4">)</span>
    <span class="s1">vals </span><span class="s4">= </span><span class="s1">lsim</span><span class="s4">(</span><span class="s1">sys</span><span class="s4">, </span><span class="s1">U</span><span class="s4">, </span><span class="s1">T</span><span class="s4">, </span><span class="s1">X0</span><span class="s4">=</span><span class="s1">X0</span><span class="s4">, </span><span class="s1">interp</span><span class="s4">=</span><span class="s3">False</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s1">vals</span><span class="s4">[</span><span class="s6">0</span><span class="s4">], </span><span class="s1">vals</span><span class="s4">[</span><span class="s6">1</span><span class="s4">]</span>


<span class="s3">def </span><span class="s1">bode</span><span class="s4">(</span><span class="s1">system</span><span class="s4">, </span><span class="s1">w</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">n</span><span class="s4">=</span><span class="s6">100</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Calculate Bode magnitude and phase data of a continuous-time system. 
 
    Parameters 
    ---------- 
    system : an instance of the LTI class or a tuple describing the system. 
        The following gives the number of elements in the tuple and 
        the interpretation: 
 
            * 1 (instance of `lti`) 
            * 2 (num, den) 
            * 3 (zeros, poles, gain) 
            * 4 (A, B, C, D) 
 
    w : array_like, optional 
        Array of frequencies (in rad/s). Magnitude and phase data is calculated 
        for every value in this array. If not given a reasonable set will be 
        calculated. 
    n : int, optional 
        Number of frequency points to compute if `w` is not given. The `n` 
        frequencies are logarithmically spaced in an interval chosen to 
        include the influence of the poles and zeros of the system. 
 
    Returns 
    ------- 
    w : 1D ndarray 
        Frequency array [rad/s] 
    mag : 1D ndarray 
        Magnitude array [dB] 
    phase : 1D ndarray 
        Phase array [deg] 
 
    Notes 
    ----- 
    If (num, den) is passed in for ``system``, coefficients for both the 
    numerator and denominator should be specified in descending exponent 
    order (e.g. ``s^2 + 3s + 5`` would be represented as ``[1, 3, 5]``). 
 
    .. versionadded:: 0.11.0 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy import signal 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
 
    &gt;&gt;&gt; sys = signal.TransferFunction([1], [1, 1]) 
    &gt;&gt;&gt; w, mag, phase = signal.bode(sys) 
 
    &gt;&gt;&gt; plt.figure() 
    &gt;&gt;&gt; plt.semilogx(w, mag)    # Bode magnitude plot 
    &gt;&gt;&gt; plt.figure() 
    &gt;&gt;&gt; plt.semilogx(w, phase)  # Bode phase plot 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span>
    <span class="s1">w</span><span class="s4">, </span><span class="s1">y </span><span class="s4">= </span><span class="s1">freqresp</span><span class="s4">(</span><span class="s1">system</span><span class="s4">, </span><span class="s1">w</span><span class="s4">=</span><span class="s1">w</span><span class="s4">, </span><span class="s1">n</span><span class="s4">=</span><span class="s1">n</span><span class="s4">)</span>

    <span class="s1">mag </span><span class="s4">= </span><span class="s6">20.0 </span><span class="s4">* </span><span class="s1">np</span><span class="s4">.</span><span class="s1">log10</span><span class="s4">(</span><span class="s1">abs</span><span class="s4">(</span><span class="s1">y</span><span class="s4">))</span>
    <span class="s1">phase </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">unwrap</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">arctan2</span><span class="s4">(</span><span class="s1">y</span><span class="s4">.</span><span class="s1">imag</span><span class="s4">, </span><span class="s1">y</span><span class="s4">.</span><span class="s1">real</span><span class="s4">)) * </span><span class="s6">180.0 </span><span class="s4">/ </span><span class="s1">np</span><span class="s4">.</span><span class="s1">pi</span>

    <span class="s3">return </span><span class="s1">w</span><span class="s4">, </span><span class="s1">mag</span><span class="s4">, </span><span class="s1">phase</span>


<span class="s3">def </span><span class="s1">freqresp</span><span class="s4">(</span><span class="s1">system</span><span class="s4">, </span><span class="s1">w</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">n</span><span class="s4">=</span><span class="s6">10000</span><span class="s4">):</span>
    <span class="s0">r&quot;&quot;&quot;Calculate the frequency response of a continuous-time system. 
 
    Parameters 
    ---------- 
    system : an instance of the `lti` class or a tuple describing the system. 
        The following gives the number of elements in the tuple and 
        the interpretation: 
 
            * 1 (instance of `lti`) 
            * 2 (num, den) 
            * 3 (zeros, poles, gain) 
            * 4 (A, B, C, D) 
 
    w : array_like, optional 
        Array of frequencies (in rad/s). Magnitude and phase data is 
        calculated for every value in this array. If not given, a reasonable 
        set will be calculated. 
    n : int, optional 
        Number of frequency points to compute if `w` is not given. The `n` 
        frequencies are logarithmically spaced in an interval chosen to 
        include the influence of the poles and zeros of the system. 
 
    Returns 
    ------- 
    w : 1D ndarray 
        Frequency array [rad/s] 
    H : 1D ndarray 
        Array of complex magnitude values 
 
    Notes 
    ----- 
    If (num, den) is passed in for ``system``, coefficients for both the 
    numerator and denominator should be specified in descending exponent 
    order (e.g. ``s^2 + 3s + 5`` would be represented as ``[1, 3, 5]``). 
 
    Examples 
    -------- 
    Generating the Nyquist plot of a transfer function 
 
    &gt;&gt;&gt; from scipy import signal 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
 
    Construct the transfer function :math:`H(s) = \frac{5}{(s-1)^3}`: 
 
    &gt;&gt;&gt; s1 = signal.ZerosPolesGain([], [1, 1, 1], [5]) 
 
    &gt;&gt;&gt; w, H = signal.freqresp(s1) 
 
    &gt;&gt;&gt; plt.figure() 
    &gt;&gt;&gt; plt.plot(H.real, H.imag, &quot;b&quot;) 
    &gt;&gt;&gt; plt.plot(H.real, -H.imag, &quot;r&quot;) 
    &gt;&gt;&gt; plt.show() 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">system</span><span class="s4">, </span><span class="s1">lti</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">system</span><span class="s4">, (</span><span class="s1">TransferFunction</span><span class="s4">, </span><span class="s1">ZerosPolesGain</span><span class="s4">)):</span>
            <span class="s1">sys </span><span class="s4">= </span><span class="s1">system</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">sys </span><span class="s4">= </span><span class="s1">system</span><span class="s4">.</span><span class="s1">_as_zpk</span><span class="s4">()</span>
    <span class="s3">elif </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">system</span><span class="s4">, </span><span class="s1">dlti</span><span class="s4">):</span>
        <span class="s3">raise </span><span class="s1">AttributeError</span><span class="s4">(</span><span class="s5">'freqresp can only be used with continuous-time '</span>
                             <span class="s5">'systems.'</span><span class="s4">)</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">sys </span><span class="s4">= </span><span class="s1">lti</span><span class="s4">(*</span><span class="s1">system</span><span class="s4">).</span><span class="s1">_as_zpk</span><span class="s4">()</span>

    <span class="s3">if </span><span class="s1">sys</span><span class="s4">.</span><span class="s1">inputs </span><span class="s4">!= </span><span class="s6">1 </span><span class="s3">or </span><span class="s1">sys</span><span class="s4">.</span><span class="s1">outputs </span><span class="s4">!= </span><span class="s6">1</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;freqresp() requires a SISO (single input, single &quot;</span>
                         <span class="s5">&quot;output) system.&quot;</span><span class="s4">)</span>

    <span class="s3">if </span><span class="s1">w </span><span class="s3">is not None</span><span class="s4">:</span>
        <span class="s1">worN </span><span class="s4">= </span><span class="s1">w</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">worN </span><span class="s4">= </span><span class="s1">n</span>

    <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">sys</span><span class="s4">, </span><span class="s1">TransferFunction</span><span class="s4">):</span>
        <span class="s2"># In the call to freqs(), sys.num.ravel() is used because there are</span>
        <span class="s2"># cases where sys.num is a 2-D array with a single row.</span>
        <span class="s1">w</span><span class="s4">, </span><span class="s1">h </span><span class="s4">= </span><span class="s1">freqs</span><span class="s4">(</span><span class="s1">sys</span><span class="s4">.</span><span class="s1">num</span><span class="s4">.</span><span class="s1">ravel</span><span class="s4">(), </span><span class="s1">sys</span><span class="s4">.</span><span class="s1">den</span><span class="s4">, </span><span class="s1">worN</span><span class="s4">=</span><span class="s1">worN</span><span class="s4">)</span>

    <span class="s3">elif </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">sys</span><span class="s4">, </span><span class="s1">ZerosPolesGain</span><span class="s4">):</span>
        <span class="s1">w</span><span class="s4">, </span><span class="s1">h </span><span class="s4">= </span><span class="s1">freqs_zpk</span><span class="s4">(</span><span class="s1">sys</span><span class="s4">.</span><span class="s1">zeros</span><span class="s4">, </span><span class="s1">sys</span><span class="s4">.</span><span class="s1">poles</span><span class="s4">, </span><span class="s1">sys</span><span class="s4">.</span><span class="s1">gain</span><span class="s4">, </span><span class="s1">worN</span><span class="s4">=</span><span class="s1">worN</span><span class="s4">)</span>

    <span class="s3">return </span><span class="s1">w</span><span class="s4">, </span><span class="s1">h</span>


<span class="s2"># This class will be used by place_poles to return its results</span>
<span class="s2"># see https://code.activestate.com/recipes/52308/</span>
<span class="s3">class </span><span class="s1">Bunch</span><span class="s4">:</span>
    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, **</span><span class="s1">kwds</span><span class="s4">):</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">__dict__</span><span class="s4">.</span><span class="s1">update</span><span class="s4">(</span><span class="s1">kwds</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">_valid_inputs</span><span class="s4">(</span><span class="s1">A</span><span class="s4">, </span><span class="s1">B</span><span class="s4">, </span><span class="s1">poles</span><span class="s4">, </span><span class="s1">method</span><span class="s4">, </span><span class="s1">rtol</span><span class="s4">, </span><span class="s1">maxiter</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Check the poles come in complex conjugage pairs 
    Check shapes of A, B and poles are compatible. 
    Check the method chosen is compatible with provided poles 
    Return update method to use and ordered poles 
 
    &quot;&quot;&quot;</span>
    <span class="s1">poles </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">(</span><span class="s1">poles</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">poles</span><span class="s4">.</span><span class="s1">ndim </span><span class="s4">&gt; </span><span class="s6">1</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;Poles must be a 1D array like.&quot;</span><span class="s4">)</span>
    <span class="s2"># Will raise ValueError if poles do not come in complex conjugates pairs</span>
    <span class="s1">poles </span><span class="s4">= </span><span class="s1">_order_complex_poles</span><span class="s4">(</span><span class="s1">poles</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">A</span><span class="s4">.</span><span class="s1">ndim </span><span class="s4">&gt; </span><span class="s6">2</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;A must be a 2D array/matrix.&quot;</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">B</span><span class="s4">.</span><span class="s1">ndim </span><span class="s4">&gt; </span><span class="s6">2</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;B must be a 2D array/matrix&quot;</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">A</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">] != </span><span class="s1">A</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">1</span><span class="s4">]:</span>
        <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;A must be square&quot;</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">poles</span><span class="s4">) &gt; </span><span class="s1">A</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]:</span>
        <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;maximum number of poles is %d but you asked for %d&quot; </span><span class="s4">%</span>
                         <span class="s4">(</span><span class="s1">A</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">], </span><span class="s1">len</span><span class="s4">(</span><span class="s1">poles</span><span class="s4">)))</span>
    <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">poles</span><span class="s4">) &lt; </span><span class="s1">A</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]:</span>
        <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;number of poles is %d but you should provide %d&quot; </span><span class="s4">%</span>
                         <span class="s4">(</span><span class="s1">len</span><span class="s4">(</span><span class="s1">poles</span><span class="s4">), </span><span class="s1">A</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]))</span>
    <span class="s1">r </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">linalg</span><span class="s4">.</span><span class="s1">matrix_rank</span><span class="s4">(</span><span class="s1">B</span><span class="s4">)</span>
    <span class="s3">for </span><span class="s1">p </span><span class="s3">in </span><span class="s1">poles</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">sum</span><span class="s4">(</span><span class="s1">p </span><span class="s4">== </span><span class="s1">poles</span><span class="s4">) &gt; </span><span class="s1">r</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;at least one of the requested pole is repeated &quot;</span>
                             <span class="s5">&quot;more than rank(B) times&quot;</span><span class="s4">)</span>
    <span class="s2"># Choose update method</span>
    <span class="s1">update_loop </span><span class="s4">= </span><span class="s1">_YT_loop</span>
    <span class="s3">if </span><span class="s1">method </span><span class="s3">not in </span><span class="s4">(</span><span class="s5">'KNV0'</span><span class="s4">,</span><span class="s5">'YT'</span><span class="s4">):</span>
        <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;The method keyword must be one of 'YT' or 'KNV0'&quot;</span><span class="s4">)</span>

    <span class="s3">if </span><span class="s1">method </span><span class="s4">== </span><span class="s5">&quot;KNV0&quot;</span><span class="s4">:</span>
        <span class="s1">update_loop </span><span class="s4">= </span><span class="s1">_KNV0_loop</span>
        <span class="s3">if not </span><span class="s1">all</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">isreal</span><span class="s4">(</span><span class="s1">poles</span><span class="s4">)):</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;Complex poles are not supported by KNV0&quot;</span><span class="s4">)</span>

    <span class="s3">if </span><span class="s1">maxiter </span><span class="s4">&lt; </span><span class="s6">1</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;maxiter must be at least equal to 1&quot;</span><span class="s4">)</span>

    <span class="s2"># We do not check rtol &lt;= 0 as the user can use a negative rtol to</span>
    <span class="s2"># force maxiter iterations</span>
    <span class="s3">if </span><span class="s1">rtol </span><span class="s4">&gt; </span><span class="s6">1</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;rtol can not be greater than 1&quot;</span><span class="s4">)</span>

    <span class="s3">return </span><span class="s1">update_loop</span><span class="s4">, </span><span class="s1">poles</span>


<span class="s3">def </span><span class="s1">_order_complex_poles</span><span class="s4">(</span><span class="s1">poles</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Check we have complex conjugates pairs and reorder P according to YT, ie 
    real_poles, complex_i, conjugate complex_i, .... 
    The lexicographic sort on the complex poles is added to help the user to 
    compare sets of poles. 
    &quot;&quot;&quot;</span>
    <span class="s1">ordered_poles </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">sort</span><span class="s4">(</span><span class="s1">poles</span><span class="s4">[</span><span class="s1">np</span><span class="s4">.</span><span class="s1">isreal</span><span class="s4">(</span><span class="s1">poles</span><span class="s4">)])</span>
    <span class="s1">im_poles </span><span class="s4">= []</span>
    <span class="s3">for </span><span class="s1">p </span><span class="s3">in </span><span class="s1">np</span><span class="s4">.</span><span class="s1">sort</span><span class="s4">(</span><span class="s1">poles</span><span class="s4">[</span><span class="s1">np</span><span class="s4">.</span><span class="s1">imag</span><span class="s4">(</span><span class="s1">poles</span><span class="s4">) &lt; </span><span class="s6">0</span><span class="s4">]):</span>
        <span class="s3">if </span><span class="s1">np</span><span class="s4">.</span><span class="s1">conj</span><span class="s4">(</span><span class="s1">p</span><span class="s4">) </span><span class="s3">in </span><span class="s1">poles</span><span class="s4">:</span>
            <span class="s1">im_poles</span><span class="s4">.</span><span class="s1">extend</span><span class="s4">((</span><span class="s1">p</span><span class="s4">, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">conj</span><span class="s4">(</span><span class="s1">p</span><span class="s4">)))</span>

    <span class="s1">ordered_poles </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">hstack</span><span class="s4">((</span><span class="s1">ordered_poles</span><span class="s4">, </span><span class="s1">im_poles</span><span class="s4">))</span>

    <span class="s3">if </span><span class="s1">poles</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">] != </span><span class="s1">len</span><span class="s4">(</span><span class="s1">ordered_poles</span><span class="s4">):</span>
        <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;Complex poles must come with their conjugates&quot;</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s1">ordered_poles</span>


<span class="s3">def </span><span class="s1">_KNV0</span><span class="s4">(</span><span class="s1">B</span><span class="s4">, </span><span class="s1">ker_pole</span><span class="s4">, </span><span class="s1">transfer_matrix</span><span class="s4">, </span><span class="s1">j</span><span class="s4">, </span><span class="s1">poles</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Algorithm &quot;KNV0&quot; Kautsky et Al. Robust pole 
    assignment in linear state feedback, Int journal of Control 
    1985, vol 41 p 1129-&gt;1155 
    https://la.epfl.ch/files/content/sites/la/files/ 
        users/105941/public/KautskyNicholsDooren 
 
    &quot;&quot;&quot;</span>
    <span class="s2"># Remove xj form the base</span>
    <span class="s1">transfer_matrix_not_j </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">delete</span><span class="s4">(</span><span class="s1">transfer_matrix</span><span class="s4">, </span><span class="s1">j</span><span class="s4">, </span><span class="s1">axis</span><span class="s4">=</span><span class="s6">1</span><span class="s4">)</span>
    <span class="s2"># If we QR this matrix in full mode Q=Q0|Q1</span>
    <span class="s2"># then Q1 will be a single column orthogonnal to</span>
    <span class="s2"># Q0, that's what we are looking for !</span>

    <span class="s2"># After merge of gh-4249 great speed improvements could be achieved</span>
    <span class="s2"># using QR updates instead of full QR in the line below</span>

    <span class="s2"># To debug with numpy qr uncomment the line below</span>
    <span class="s2"># Q, R = np.linalg.qr(transfer_matrix_not_j, mode=&quot;complete&quot;)</span>
    <span class="s1">Q</span><span class="s4">, </span><span class="s1">R </span><span class="s4">= </span><span class="s1">s_qr</span><span class="s4">(</span><span class="s1">transfer_matrix_not_j</span><span class="s4">, </span><span class="s1">mode</span><span class="s4">=</span><span class="s5">&quot;full&quot;</span><span class="s4">)</span>

    <span class="s1">mat_ker_pj </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">dot</span><span class="s4">(</span><span class="s1">ker_pole</span><span class="s4">[</span><span class="s1">j</span><span class="s4">], </span><span class="s1">ker_pole</span><span class="s4">[</span><span class="s1">j</span><span class="s4">].</span><span class="s1">T</span><span class="s4">)</span>
    <span class="s1">yj </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">dot</span><span class="s4">(</span><span class="s1">mat_ker_pj</span><span class="s4">, </span><span class="s1">Q</span><span class="s4">[:, -</span><span class="s6">1</span><span class="s4">])</span>

    <span class="s2"># If Q[:, -1] is &quot;almost&quot; orthogonal to ker_pole[j] its</span>
    <span class="s2"># projection into ker_pole[j] will yield a vector</span>
    <span class="s2"># close to 0.  As we are looking for a vector in ker_pole[j]</span>
    <span class="s2"># simply stick with transfer_matrix[:, j] (unless someone provides me with</span>
    <span class="s2"># a better choice ?)</span>

    <span class="s3">if not </span><span class="s1">np</span><span class="s4">.</span><span class="s1">allclose</span><span class="s4">(</span><span class="s1">yj</span><span class="s4">, </span><span class="s6">0</span><span class="s4">):</span>
        <span class="s1">xj </span><span class="s4">= </span><span class="s1">yj</span><span class="s4">/</span><span class="s1">np</span><span class="s4">.</span><span class="s1">linalg</span><span class="s4">.</span><span class="s1">norm</span><span class="s4">(</span><span class="s1">yj</span><span class="s4">)</span>
        <span class="s1">transfer_matrix</span><span class="s4">[:, </span><span class="s1">j</span><span class="s4">] = </span><span class="s1">xj</span>

        <span class="s2"># KNV does not support complex poles, using YT technique the two lines</span>
        <span class="s2"># below seem to work 9 out of 10 times but it is not reliable enough:</span>
        <span class="s2"># transfer_matrix[:, j]=real(xj)</span>
        <span class="s2"># transfer_matrix[:, j+1]=imag(xj)</span>

        <span class="s2"># Add this at the beginning of this function if you wish to test</span>
        <span class="s2"># complex support:</span>
        <span class="s2">#    if ~np.isreal(P[j]) and (j&gt;=B.shape[0]-1 or P[j]!=np.conj(P[j+1])):</span>
        <span class="s2">#        return</span>
        <span class="s2"># Problems arise when imag(xj)=&gt;0 I have no idea on how to fix this</span>


<span class="s3">def </span><span class="s1">_YT_real</span><span class="s4">(</span><span class="s1">ker_pole</span><span class="s4">, </span><span class="s1">Q</span><span class="s4">, </span><span class="s1">transfer_matrix</span><span class="s4">, </span><span class="s1">i</span><span class="s4">, </span><span class="s1">j</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Applies algorithm from YT section 6.1 page 19 related to real pairs 
    &quot;&quot;&quot;</span>
    <span class="s2"># step 1 page 19</span>
    <span class="s1">u </span><span class="s4">= </span><span class="s1">Q</span><span class="s4">[:, -</span><span class="s6">2</span><span class="s4">, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">newaxis</span><span class="s4">]</span>
    <span class="s1">v </span><span class="s4">= </span><span class="s1">Q</span><span class="s4">[:, -</span><span class="s6">1</span><span class="s4">, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">newaxis</span><span class="s4">]</span>

    <span class="s2"># step 2 page 19</span>
    <span class="s1">m </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">dot</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">dot</span><span class="s4">(</span><span class="s1">ker_pole</span><span class="s4">[</span><span class="s1">i</span><span class="s4">].</span><span class="s1">T</span><span class="s4">, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">dot</span><span class="s4">(</span><span class="s1">u</span><span class="s4">, </span><span class="s1">v</span><span class="s4">.</span><span class="s1">T</span><span class="s4">) -</span>
        <span class="s1">np</span><span class="s4">.</span><span class="s1">dot</span><span class="s4">(</span><span class="s1">v</span><span class="s4">, </span><span class="s1">u</span><span class="s4">.</span><span class="s1">T</span><span class="s4">)), </span><span class="s1">ker_pole</span><span class="s4">[</span><span class="s1">j</span><span class="s4">])</span>

    <span class="s2"># step 3 page 19</span>
    <span class="s1">um</span><span class="s4">, </span><span class="s1">sm</span><span class="s4">, </span><span class="s1">vm </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">linalg</span><span class="s4">.</span><span class="s1">svd</span><span class="s4">(</span><span class="s1">m</span><span class="s4">)</span>
    <span class="s2"># mu1, mu2 two first columns of U =&gt; 2 first lines of U.T</span>
    <span class="s1">mu1</span><span class="s4">, </span><span class="s1">mu2 </span><span class="s4">= </span><span class="s1">um</span><span class="s4">.</span><span class="s1">T</span><span class="s4">[:</span><span class="s6">2</span><span class="s4">, :, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">newaxis</span><span class="s4">]</span>
    <span class="s2"># VM is V.T with numpy we want the first two lines of V.T</span>
    <span class="s1">nu1</span><span class="s4">, </span><span class="s1">nu2 </span><span class="s4">= </span><span class="s1">vm</span><span class="s4">[:</span><span class="s6">2</span><span class="s4">, :, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">newaxis</span><span class="s4">]</span>

    <span class="s2"># what follows is a rough python translation of the formulas</span>
    <span class="s2"># in section 6.2 page 20 (step 4)</span>
    <span class="s1">transfer_matrix_j_mo_transfer_matrix_j </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">vstack</span><span class="s4">((</span>
            <span class="s1">transfer_matrix</span><span class="s4">[:, </span><span class="s1">i</span><span class="s4">, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">newaxis</span><span class="s4">],</span>
            <span class="s1">transfer_matrix</span><span class="s4">[:, </span><span class="s1">j</span><span class="s4">, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">newaxis</span><span class="s4">]))</span>

    <span class="s3">if not </span><span class="s1">np</span><span class="s4">.</span><span class="s1">allclose</span><span class="s4">(</span><span class="s1">sm</span><span class="s4">[</span><span class="s6">0</span><span class="s4">], </span><span class="s1">sm</span><span class="s4">[</span><span class="s6">1</span><span class="s4">]):</span>
        <span class="s1">ker_pole_imo_mu1 </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">dot</span><span class="s4">(</span><span class="s1">ker_pole</span><span class="s4">[</span><span class="s1">i</span><span class="s4">], </span><span class="s1">mu1</span><span class="s4">)</span>
        <span class="s1">ker_pole_i_nu1 </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">dot</span><span class="s4">(</span><span class="s1">ker_pole</span><span class="s4">[</span><span class="s1">j</span><span class="s4">], </span><span class="s1">nu1</span><span class="s4">)</span>
        <span class="s1">ker_pole_mu_nu </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">vstack</span><span class="s4">((</span><span class="s1">ker_pole_imo_mu1</span><span class="s4">, </span><span class="s1">ker_pole_i_nu1</span><span class="s4">))</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">ker_pole_ij </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">vstack</span><span class="s4">((</span>
                                <span class="s1">np</span><span class="s4">.</span><span class="s1">hstack</span><span class="s4">((</span><span class="s1">ker_pole</span><span class="s4">[</span><span class="s1">i</span><span class="s4">],</span>
                                           <span class="s1">np</span><span class="s4">.</span><span class="s1">zeros</span><span class="s4">(</span><span class="s1">ker_pole</span><span class="s4">[</span><span class="s1">i</span><span class="s4">].</span><span class="s1">shape</span><span class="s4">))),</span>
                                <span class="s1">np</span><span class="s4">.</span><span class="s1">hstack</span><span class="s4">((</span><span class="s1">np</span><span class="s4">.</span><span class="s1">zeros</span><span class="s4">(</span><span class="s1">ker_pole</span><span class="s4">[</span><span class="s1">j</span><span class="s4">].</span><span class="s1">shape</span><span class="s4">),</span>
                                                    <span class="s1">ker_pole</span><span class="s4">[</span><span class="s1">j</span><span class="s4">]))</span>
                                <span class="s4">))</span>
        <span class="s1">mu_nu_matrix </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">vstack</span><span class="s4">(</span>
            <span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">hstack</span><span class="s4">((</span><span class="s1">mu1</span><span class="s4">, </span><span class="s1">mu2</span><span class="s4">)), </span><span class="s1">np</span><span class="s4">.</span><span class="s1">hstack</span><span class="s4">((</span><span class="s1">nu1</span><span class="s4">, </span><span class="s1">nu2</span><span class="s4">)))</span>
            <span class="s4">)</span>
        <span class="s1">ker_pole_mu_nu </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">dot</span><span class="s4">(</span><span class="s1">ker_pole_ij</span><span class="s4">, </span><span class="s1">mu_nu_matrix</span><span class="s4">)</span>
    <span class="s1">transfer_matrix_ij </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">dot</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">dot</span><span class="s4">(</span><span class="s1">ker_pole_mu_nu</span><span class="s4">, </span><span class="s1">ker_pole_mu_nu</span><span class="s4">.</span><span class="s1">T</span><span class="s4">),</span>
                             <span class="s1">transfer_matrix_j_mo_transfer_matrix_j</span><span class="s4">)</span>
    <span class="s3">if not </span><span class="s1">np</span><span class="s4">.</span><span class="s1">allclose</span><span class="s4">(</span><span class="s1">transfer_matrix_ij</span><span class="s4">, </span><span class="s6">0</span><span class="s4">):</span>
        <span class="s1">transfer_matrix_ij </span><span class="s4">= (</span><span class="s1">np</span><span class="s4">.</span><span class="s1">sqrt</span><span class="s4">(</span><span class="s6">2</span><span class="s4">)*</span><span class="s1">transfer_matrix_ij </span><span class="s4">/</span>
                              <span class="s1">np</span><span class="s4">.</span><span class="s1">linalg</span><span class="s4">.</span><span class="s1">norm</span><span class="s4">(</span><span class="s1">transfer_matrix_ij</span><span class="s4">))</span>
        <span class="s1">transfer_matrix</span><span class="s4">[:, </span><span class="s1">i</span><span class="s4">] = </span><span class="s1">transfer_matrix_ij</span><span class="s4">[</span>
            <span class="s4">:</span><span class="s1">transfer_matrix</span><span class="s4">[:, </span><span class="s1">i</span><span class="s4">].</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">], </span><span class="s6">0</span>
            <span class="s4">]</span>
        <span class="s1">transfer_matrix</span><span class="s4">[:, </span><span class="s1">j</span><span class="s4">] = </span><span class="s1">transfer_matrix_ij</span><span class="s4">[</span>
            <span class="s1">transfer_matrix</span><span class="s4">[:, </span><span class="s1">i</span><span class="s4">].</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]:, </span><span class="s6">0</span>
            <span class="s4">]</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s2"># As in knv0 if transfer_matrix_j_mo_transfer_matrix_j is orthogonal to</span>
        <span class="s2"># Vect{ker_pole_mu_nu} assign transfer_matrixi/transfer_matrix_j to</span>
        <span class="s2"># ker_pole_mu_nu and iterate. As we are looking for a vector in</span>
        <span class="s2"># Vect{Matker_pole_MU_NU} (see section 6.1 page 19) this might help</span>
        <span class="s2"># (that's a guess, not a claim !)</span>
        <span class="s1">transfer_matrix</span><span class="s4">[:, </span><span class="s1">i</span><span class="s4">] = </span><span class="s1">ker_pole_mu_nu</span><span class="s4">[</span>
            <span class="s4">:</span><span class="s1">transfer_matrix</span><span class="s4">[:, </span><span class="s1">i</span><span class="s4">].</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">], </span><span class="s6">0</span>
            <span class="s4">]</span>
        <span class="s1">transfer_matrix</span><span class="s4">[:, </span><span class="s1">j</span><span class="s4">] = </span><span class="s1">ker_pole_mu_nu</span><span class="s4">[</span>
            <span class="s1">transfer_matrix</span><span class="s4">[:, </span><span class="s1">i</span><span class="s4">].</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]:, </span><span class="s6">0</span>
            <span class="s4">]</span>


<span class="s3">def </span><span class="s1">_YT_complex</span><span class="s4">(</span><span class="s1">ker_pole</span><span class="s4">, </span><span class="s1">Q</span><span class="s4">, </span><span class="s1">transfer_matrix</span><span class="s4">, </span><span class="s1">i</span><span class="s4">, </span><span class="s1">j</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Applies algorithm from YT section 6.2 page 20 related to complex pairs 
    &quot;&quot;&quot;</span>
    <span class="s2"># step 1 page 20</span>
    <span class="s1">ur </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">sqrt</span><span class="s4">(</span><span class="s6">2</span><span class="s4">)*</span><span class="s1">Q</span><span class="s4">[:, -</span><span class="s6">2</span><span class="s4">, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">newaxis</span><span class="s4">]</span>
    <span class="s1">ui </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">sqrt</span><span class="s4">(</span><span class="s6">2</span><span class="s4">)*</span><span class="s1">Q</span><span class="s4">[:, -</span><span class="s6">1</span><span class="s4">, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">newaxis</span><span class="s4">]</span>
    <span class="s1">u </span><span class="s4">= </span><span class="s1">ur </span><span class="s4">+ </span><span class="s6">1j</span><span class="s4">*</span><span class="s1">ui</span>

    <span class="s2"># step 2 page 20</span>
    <span class="s1">ker_pole_ij </span><span class="s4">= </span><span class="s1">ker_pole</span><span class="s4">[</span><span class="s1">i</span><span class="s4">]</span>
    <span class="s1">m </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">dot</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">dot</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">conj</span><span class="s4">(</span><span class="s1">ker_pole_ij</span><span class="s4">.</span><span class="s1">T</span><span class="s4">), </span><span class="s1">np</span><span class="s4">.</span><span class="s1">dot</span><span class="s4">(</span><span class="s1">u</span><span class="s4">, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">conj</span><span class="s4">(</span><span class="s1">u</span><span class="s4">).</span><span class="s1">T</span><span class="s4">) -</span>
               <span class="s1">np</span><span class="s4">.</span><span class="s1">dot</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">conj</span><span class="s4">(</span><span class="s1">u</span><span class="s4">), </span><span class="s1">u</span><span class="s4">.</span><span class="s1">T</span><span class="s4">)), </span><span class="s1">ker_pole_ij</span><span class="s4">)</span>

    <span class="s2"># step 3 page 20</span>
    <span class="s1">e_val</span><span class="s4">, </span><span class="s1">e_vec </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">linalg</span><span class="s4">.</span><span class="s1">eig</span><span class="s4">(</span><span class="s1">m</span><span class="s4">)</span>
    <span class="s2"># sort eigenvalues according to their module</span>
    <span class="s1">e_val_idx </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">argsort</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">abs</span><span class="s4">(</span><span class="s1">e_val</span><span class="s4">))</span>
    <span class="s1">mu1 </span><span class="s4">= </span><span class="s1">e_vec</span><span class="s4">[:, </span><span class="s1">e_val_idx</span><span class="s4">[-</span><span class="s6">1</span><span class="s4">], </span><span class="s1">np</span><span class="s4">.</span><span class="s1">newaxis</span><span class="s4">]</span>
    <span class="s1">mu2 </span><span class="s4">= </span><span class="s1">e_vec</span><span class="s4">[:, </span><span class="s1">e_val_idx</span><span class="s4">[-</span><span class="s6">2</span><span class="s4">], </span><span class="s1">np</span><span class="s4">.</span><span class="s1">newaxis</span><span class="s4">]</span>

    <span class="s2"># what follows is a rough python translation of the formulas</span>
    <span class="s2"># in section 6.2 page 20 (step 4)</span>

    <span class="s2"># remember transfer_matrix_i has been split as</span>
    <span class="s2"># transfer_matrix[i]=real(transfer_matrix_i) and</span>
    <span class="s2"># transfer_matrix[j]=imag(transfer_matrix_i)</span>
    <span class="s1">transfer_matrix_j_mo_transfer_matrix_j </span><span class="s4">= (</span>
        <span class="s1">transfer_matrix</span><span class="s4">[:, </span><span class="s1">i</span><span class="s4">, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">newaxis</span><span class="s4">] +</span>
        <span class="s6">1j</span><span class="s4">*</span><span class="s1">transfer_matrix</span><span class="s4">[:, </span><span class="s1">j</span><span class="s4">, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">newaxis</span><span class="s4">]</span>
        <span class="s4">)</span>
    <span class="s3">if not </span><span class="s1">np</span><span class="s4">.</span><span class="s1">allclose</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">abs</span><span class="s4">(</span><span class="s1">e_val</span><span class="s4">[</span><span class="s1">e_val_idx</span><span class="s4">[-</span><span class="s6">1</span><span class="s4">]]),</span>
                              <span class="s1">np</span><span class="s4">.</span><span class="s1">abs</span><span class="s4">(</span><span class="s1">e_val</span><span class="s4">[</span><span class="s1">e_val_idx</span><span class="s4">[-</span><span class="s6">2</span><span class="s4">]])):</span>
        <span class="s1">ker_pole_mu </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">dot</span><span class="s4">(</span><span class="s1">ker_pole_ij</span><span class="s4">, </span><span class="s1">mu1</span><span class="s4">)</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">mu1_mu2_matrix </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">hstack</span><span class="s4">((</span><span class="s1">mu1</span><span class="s4">, </span><span class="s1">mu2</span><span class="s4">))</span>
        <span class="s1">ker_pole_mu </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">dot</span><span class="s4">(</span><span class="s1">ker_pole_ij</span><span class="s4">, </span><span class="s1">mu1_mu2_matrix</span><span class="s4">)</span>
    <span class="s1">transfer_matrix_i_j </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">dot</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">dot</span><span class="s4">(</span><span class="s1">ker_pole_mu</span><span class="s4">, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">conj</span><span class="s4">(</span><span class="s1">ker_pole_mu</span><span class="s4">.</span><span class="s1">T</span><span class="s4">)),</span>
                              <span class="s1">transfer_matrix_j_mo_transfer_matrix_j</span><span class="s4">)</span>

    <span class="s3">if not </span><span class="s1">np</span><span class="s4">.</span><span class="s1">allclose</span><span class="s4">(</span><span class="s1">transfer_matrix_i_j</span><span class="s4">, </span><span class="s6">0</span><span class="s4">):</span>
        <span class="s1">transfer_matrix_i_j </span><span class="s4">= (</span><span class="s1">transfer_matrix_i_j </span><span class="s4">/</span>
            <span class="s1">np</span><span class="s4">.</span><span class="s1">linalg</span><span class="s4">.</span><span class="s1">norm</span><span class="s4">(</span><span class="s1">transfer_matrix_i_j</span><span class="s4">))</span>
        <span class="s1">transfer_matrix</span><span class="s4">[:, </span><span class="s1">i</span><span class="s4">] = </span><span class="s1">np</span><span class="s4">.</span><span class="s1">real</span><span class="s4">(</span><span class="s1">transfer_matrix_i_j</span><span class="s4">[:, </span><span class="s6">0</span><span class="s4">])</span>
        <span class="s1">transfer_matrix</span><span class="s4">[:, </span><span class="s1">j</span><span class="s4">] = </span><span class="s1">np</span><span class="s4">.</span><span class="s1">imag</span><span class="s4">(</span><span class="s1">transfer_matrix_i_j</span><span class="s4">[:, </span><span class="s6">0</span><span class="s4">])</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s2"># same idea as in YT_real</span>
        <span class="s1">transfer_matrix</span><span class="s4">[:, </span><span class="s1">i</span><span class="s4">] = </span><span class="s1">np</span><span class="s4">.</span><span class="s1">real</span><span class="s4">(</span><span class="s1">ker_pole_mu</span><span class="s4">[:, </span><span class="s6">0</span><span class="s4">])</span>
        <span class="s1">transfer_matrix</span><span class="s4">[:, </span><span class="s1">j</span><span class="s4">] = </span><span class="s1">np</span><span class="s4">.</span><span class="s1">imag</span><span class="s4">(</span><span class="s1">ker_pole_mu</span><span class="s4">[:, </span><span class="s6">0</span><span class="s4">])</span>


<span class="s3">def </span><span class="s1">_YT_loop</span><span class="s4">(</span><span class="s1">ker_pole</span><span class="s4">, </span><span class="s1">transfer_matrix</span><span class="s4">, </span><span class="s1">poles</span><span class="s4">, </span><span class="s1">B</span><span class="s4">, </span><span class="s1">maxiter</span><span class="s4">, </span><span class="s1">rtol</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Algorithm &quot;YT&quot; Tits, Yang. Globally Convergent 
    Algorithms for Robust Pole Assignment by State Feedback 
    https://hdl.handle.net/1903/5598 
    The poles P have to be sorted accordingly to section 6.2 page 20 
 
    &quot;&quot;&quot;</span>
    <span class="s2"># The IEEE edition of the YT paper gives useful information on the</span>
    <span class="s2"># optimal update order for the real poles in order to minimize the number</span>
    <span class="s2"># of times we have to loop over all poles, see page 1442</span>
    <span class="s1">nb_real </span><span class="s4">= </span><span class="s1">poles</span><span class="s4">[</span><span class="s1">np</span><span class="s4">.</span><span class="s1">isreal</span><span class="s4">(</span><span class="s1">poles</span><span class="s4">)].</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]</span>
    <span class="s2"># hnb =&gt; Half Nb Real</span>
    <span class="s1">hnb </span><span class="s4">= </span><span class="s1">nb_real </span><span class="s4">// </span><span class="s6">2</span>

    <span class="s2"># Stick to the indices in the paper and then remove one to get numpy array</span>
    <span class="s2"># index it is a bit easier to link the code to the paper this way even if it</span>
    <span class="s2"># is not very clean. The paper is unclear about what should be done when</span>
    <span class="s2"># there is only one real pole =&gt; use KNV0 on this real pole seem to work</span>
    <span class="s3">if </span><span class="s1">nb_real </span><span class="s4">&gt; </span><span class="s6">0</span><span class="s4">:</span>
        <span class="s2">#update the biggest real pole with the smallest one</span>
        <span class="s1">update_order </span><span class="s4">= [[</span><span class="s1">nb_real</span><span class="s4">], [</span><span class="s6">1</span><span class="s4">]]</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">update_order </span><span class="s4">= [[],[]]</span>

    <span class="s1">r_comp </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">arange</span><span class="s4">(</span><span class="s1">nb_real</span><span class="s4">+</span><span class="s6">1</span><span class="s4">, </span><span class="s1">len</span><span class="s4">(</span><span class="s1">poles</span><span class="s4">)+</span><span class="s6">1</span><span class="s4">, </span><span class="s6">2</span><span class="s4">)</span>
    <span class="s2"># step 1.a</span>
    <span class="s1">r_p </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">arange</span><span class="s4">(</span><span class="s6">1</span><span class="s4">, </span><span class="s1">hnb</span><span class="s4">+</span><span class="s1">nb_real </span><span class="s4">% </span><span class="s6">2</span><span class="s4">)</span>
    <span class="s1">update_order</span><span class="s4">[</span><span class="s6">0</span><span class="s4">].</span><span class="s1">extend</span><span class="s4">(</span><span class="s6">2</span><span class="s4">*</span><span class="s1">r_p</span><span class="s4">)</span>
    <span class="s1">update_order</span><span class="s4">[</span><span class="s6">1</span><span class="s4">].</span><span class="s1">extend</span><span class="s4">(</span><span class="s6">2</span><span class="s4">*</span><span class="s1">r_p</span><span class="s4">+</span><span class="s6">1</span><span class="s4">)</span>
    <span class="s2"># step 1.b</span>
    <span class="s1">update_order</span><span class="s4">[</span><span class="s6">0</span><span class="s4">].</span><span class="s1">extend</span><span class="s4">(</span><span class="s1">r_comp</span><span class="s4">)</span>
    <span class="s1">update_order</span><span class="s4">[</span><span class="s6">1</span><span class="s4">].</span><span class="s1">extend</span><span class="s4">(</span><span class="s1">r_comp</span><span class="s4">+</span><span class="s6">1</span><span class="s4">)</span>
    <span class="s2"># step 1.c</span>
    <span class="s1">r_p </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">arange</span><span class="s4">(</span><span class="s6">1</span><span class="s4">, </span><span class="s1">hnb</span><span class="s4">+</span><span class="s6">1</span><span class="s4">)</span>
    <span class="s1">update_order</span><span class="s4">[</span><span class="s6">0</span><span class="s4">].</span><span class="s1">extend</span><span class="s4">(</span><span class="s6">2</span><span class="s4">*</span><span class="s1">r_p</span><span class="s4">-</span><span class="s6">1</span><span class="s4">)</span>
    <span class="s1">update_order</span><span class="s4">[</span><span class="s6">1</span><span class="s4">].</span><span class="s1">extend</span><span class="s4">(</span><span class="s6">2</span><span class="s4">*</span><span class="s1">r_p</span><span class="s4">)</span>
    <span class="s2"># step 1.d</span>
    <span class="s3">if </span><span class="s1">hnb </span><span class="s4">== </span><span class="s6">0 </span><span class="s3">and </span><span class="s1">np</span><span class="s4">.</span><span class="s1">isreal</span><span class="s4">(</span><span class="s1">poles</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]):</span>
        <span class="s1">update_order</span><span class="s4">[</span><span class="s6">0</span><span class="s4">].</span><span class="s1">append</span><span class="s4">(</span><span class="s6">1</span><span class="s4">)</span>
        <span class="s1">update_order</span><span class="s4">[</span><span class="s6">1</span><span class="s4">].</span><span class="s1">append</span><span class="s4">(</span><span class="s6">1</span><span class="s4">)</span>
    <span class="s1">update_order</span><span class="s4">[</span><span class="s6">0</span><span class="s4">].</span><span class="s1">extend</span><span class="s4">(</span><span class="s1">r_comp</span><span class="s4">)</span>
    <span class="s1">update_order</span><span class="s4">[</span><span class="s6">1</span><span class="s4">].</span><span class="s1">extend</span><span class="s4">(</span><span class="s1">r_comp</span><span class="s4">+</span><span class="s6">1</span><span class="s4">)</span>
    <span class="s2"># step 2.a</span>
    <span class="s1">r_j </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">arange</span><span class="s4">(</span><span class="s6">2</span><span class="s4">, </span><span class="s1">hnb</span><span class="s4">+</span><span class="s1">nb_real </span><span class="s4">% </span><span class="s6">2</span><span class="s4">)</span>
    <span class="s3">for </span><span class="s1">j </span><span class="s3">in </span><span class="s1">r_j</span><span class="s4">:</span>
        <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range</span><span class="s4">(</span><span class="s6">1</span><span class="s4">, </span><span class="s1">hnb</span><span class="s4">+</span><span class="s6">1</span><span class="s4">):</span>
            <span class="s1">update_order</span><span class="s4">[</span><span class="s6">0</span><span class="s4">].</span><span class="s1">append</span><span class="s4">(</span><span class="s1">i</span><span class="s4">)</span>
            <span class="s1">update_order</span><span class="s4">[</span><span class="s6">1</span><span class="s4">].</span><span class="s1">append</span><span class="s4">(</span><span class="s1">i</span><span class="s4">+</span><span class="s1">j</span><span class="s4">)</span>
    <span class="s2"># step 2.b</span>
    <span class="s3">if </span><span class="s1">hnb </span><span class="s4">== </span><span class="s6">0 </span><span class="s3">and </span><span class="s1">np</span><span class="s4">.</span><span class="s1">isreal</span><span class="s4">(</span><span class="s1">poles</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]):</span>
        <span class="s1">update_order</span><span class="s4">[</span><span class="s6">0</span><span class="s4">].</span><span class="s1">append</span><span class="s4">(</span><span class="s6">1</span><span class="s4">)</span>
        <span class="s1">update_order</span><span class="s4">[</span><span class="s6">1</span><span class="s4">].</span><span class="s1">append</span><span class="s4">(</span><span class="s6">1</span><span class="s4">)</span>
    <span class="s1">update_order</span><span class="s4">[</span><span class="s6">0</span><span class="s4">].</span><span class="s1">extend</span><span class="s4">(</span><span class="s1">r_comp</span><span class="s4">)</span>
    <span class="s1">update_order</span><span class="s4">[</span><span class="s6">1</span><span class="s4">].</span><span class="s1">extend</span><span class="s4">(</span><span class="s1">r_comp</span><span class="s4">+</span><span class="s6">1</span><span class="s4">)</span>
    <span class="s2"># step 2.c</span>
    <span class="s1">r_j </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">arange</span><span class="s4">(</span><span class="s6">2</span><span class="s4">, </span><span class="s1">hnb</span><span class="s4">+</span><span class="s1">nb_real </span><span class="s4">% </span><span class="s6">2</span><span class="s4">)</span>
    <span class="s3">for </span><span class="s1">j </span><span class="s3">in </span><span class="s1">r_j</span><span class="s4">:</span>
        <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range</span><span class="s4">(</span><span class="s1">hnb</span><span class="s4">+</span><span class="s6">1</span><span class="s4">, </span><span class="s1">nb_real</span><span class="s4">+</span><span class="s6">1</span><span class="s4">):</span>
            <span class="s1">idx_1 </span><span class="s4">= </span><span class="s1">i</span><span class="s4">+</span><span class="s1">j</span>
            <span class="s3">if </span><span class="s1">idx_1 </span><span class="s4">&gt; </span><span class="s1">nb_real</span><span class="s4">:</span>
                <span class="s1">idx_1 </span><span class="s4">= </span><span class="s1">i</span><span class="s4">+</span><span class="s1">j</span><span class="s4">-</span><span class="s1">nb_real</span>
            <span class="s1">update_order</span><span class="s4">[</span><span class="s6">0</span><span class="s4">].</span><span class="s1">append</span><span class="s4">(</span><span class="s1">i</span><span class="s4">)</span>
            <span class="s1">update_order</span><span class="s4">[</span><span class="s6">1</span><span class="s4">].</span><span class="s1">append</span><span class="s4">(</span><span class="s1">idx_1</span><span class="s4">)</span>
    <span class="s2"># step 2.d</span>
    <span class="s3">if </span><span class="s1">hnb </span><span class="s4">== </span><span class="s6">0 </span><span class="s3">and </span><span class="s1">np</span><span class="s4">.</span><span class="s1">isreal</span><span class="s4">(</span><span class="s1">poles</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]):</span>
        <span class="s1">update_order</span><span class="s4">[</span><span class="s6">0</span><span class="s4">].</span><span class="s1">append</span><span class="s4">(</span><span class="s6">1</span><span class="s4">)</span>
        <span class="s1">update_order</span><span class="s4">[</span><span class="s6">1</span><span class="s4">].</span><span class="s1">append</span><span class="s4">(</span><span class="s6">1</span><span class="s4">)</span>
    <span class="s1">update_order</span><span class="s4">[</span><span class="s6">0</span><span class="s4">].</span><span class="s1">extend</span><span class="s4">(</span><span class="s1">r_comp</span><span class="s4">)</span>
    <span class="s1">update_order</span><span class="s4">[</span><span class="s6">1</span><span class="s4">].</span><span class="s1">extend</span><span class="s4">(</span><span class="s1">r_comp</span><span class="s4">+</span><span class="s6">1</span><span class="s4">)</span>
    <span class="s2"># step 3.a</span>
    <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range</span><span class="s4">(</span><span class="s6">1</span><span class="s4">, </span><span class="s1">hnb</span><span class="s4">+</span><span class="s6">1</span><span class="s4">):</span>
        <span class="s1">update_order</span><span class="s4">[</span><span class="s6">0</span><span class="s4">].</span><span class="s1">append</span><span class="s4">(</span><span class="s1">i</span><span class="s4">)</span>
        <span class="s1">update_order</span><span class="s4">[</span><span class="s6">1</span><span class="s4">].</span><span class="s1">append</span><span class="s4">(</span><span class="s1">i</span><span class="s4">+</span><span class="s1">hnb</span><span class="s4">)</span>
    <span class="s2"># step 3.b</span>
    <span class="s3">if </span><span class="s1">hnb </span><span class="s4">== </span><span class="s6">0 </span><span class="s3">and </span><span class="s1">np</span><span class="s4">.</span><span class="s1">isreal</span><span class="s4">(</span><span class="s1">poles</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]):</span>
        <span class="s1">update_order</span><span class="s4">[</span><span class="s6">0</span><span class="s4">].</span><span class="s1">append</span><span class="s4">(</span><span class="s6">1</span><span class="s4">)</span>
        <span class="s1">update_order</span><span class="s4">[</span><span class="s6">1</span><span class="s4">].</span><span class="s1">append</span><span class="s4">(</span><span class="s6">1</span><span class="s4">)</span>
    <span class="s1">update_order</span><span class="s4">[</span><span class="s6">0</span><span class="s4">].</span><span class="s1">extend</span><span class="s4">(</span><span class="s1">r_comp</span><span class="s4">)</span>
    <span class="s1">update_order</span><span class="s4">[</span><span class="s6">1</span><span class="s4">].</span><span class="s1">extend</span><span class="s4">(</span><span class="s1">r_comp</span><span class="s4">+</span><span class="s6">1</span><span class="s4">)</span>

    <span class="s1">update_order </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">array</span><span class="s4">(</span><span class="s1">update_order</span><span class="s4">).</span><span class="s1">T</span><span class="s4">-</span><span class="s6">1</span>
    <span class="s1">stop </span><span class="s4">= </span><span class="s3">False</span>
    <span class="s1">nb_try </span><span class="s4">= </span><span class="s6">0</span>
    <span class="s3">while </span><span class="s1">nb_try </span><span class="s4">&lt; </span><span class="s1">maxiter </span><span class="s3">and not </span><span class="s1">stop</span><span class="s4">:</span>
        <span class="s1">det_transfer_matrixb </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">abs</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">linalg</span><span class="s4">.</span><span class="s1">det</span><span class="s4">(</span><span class="s1">transfer_matrix</span><span class="s4">))</span>
        <span class="s3">for </span><span class="s1">i</span><span class="s4">, </span><span class="s1">j </span><span class="s3">in </span><span class="s1">update_order</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">i </span><span class="s4">== </span><span class="s1">j</span><span class="s4">:</span>
                <span class="s3">assert </span><span class="s1">i </span><span class="s4">== </span><span class="s6">0</span><span class="s4">, </span><span class="s5">&quot;i!=0 for KNV call in YT&quot;</span>
                <span class="s3">assert </span><span class="s1">np</span><span class="s4">.</span><span class="s1">isreal</span><span class="s4">(</span><span class="s1">poles</span><span class="s4">[</span><span class="s1">i</span><span class="s4">]), </span><span class="s5">&quot;calling KNV on a complex pole&quot;</span>
                <span class="s1">_KNV0</span><span class="s4">(</span><span class="s1">B</span><span class="s4">, </span><span class="s1">ker_pole</span><span class="s4">, </span><span class="s1">transfer_matrix</span><span class="s4">, </span><span class="s1">i</span><span class="s4">, </span><span class="s1">poles</span><span class="s4">)</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">transfer_matrix_not_i_j </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">delete</span><span class="s4">(</span><span class="s1">transfer_matrix</span><span class="s4">, (</span><span class="s1">i</span><span class="s4">, </span><span class="s1">j</span><span class="s4">),</span>
                                                    <span class="s1">axis</span><span class="s4">=</span><span class="s6">1</span><span class="s4">)</span>
                <span class="s2"># after merge of gh-4249 great speed improvements could be</span>
                <span class="s2"># achieved using QR updates instead of full QR in the line below</span>

                <span class="s2">#to debug with numpy qr uncomment the line below</span>
                <span class="s2">#Q, _ = np.linalg.qr(transfer_matrix_not_i_j, mode=&quot;complete&quot;)</span>
                <span class="s1">Q</span><span class="s4">, </span><span class="s1">_ </span><span class="s4">= </span><span class="s1">s_qr</span><span class="s4">(</span><span class="s1">transfer_matrix_not_i_j</span><span class="s4">, </span><span class="s1">mode</span><span class="s4">=</span><span class="s5">&quot;full&quot;</span><span class="s4">)</span>

                <span class="s3">if </span><span class="s1">np</span><span class="s4">.</span><span class="s1">isreal</span><span class="s4">(</span><span class="s1">poles</span><span class="s4">[</span><span class="s1">i</span><span class="s4">]):</span>
                    <span class="s3">assert </span><span class="s1">np</span><span class="s4">.</span><span class="s1">isreal</span><span class="s4">(</span><span class="s1">poles</span><span class="s4">[</span><span class="s1">j</span><span class="s4">]), </span><span class="s5">&quot;mixing real and complex &quot; </span><span class="s4">+ </span><span class="s1">\</span>
                        <span class="s5">&quot;in YT_real&quot; </span><span class="s4">+ </span><span class="s1">str</span><span class="s4">(</span><span class="s1">poles</span><span class="s4">)</span>
                    <span class="s1">_YT_real</span><span class="s4">(</span><span class="s1">ker_pole</span><span class="s4">, </span><span class="s1">Q</span><span class="s4">, </span><span class="s1">transfer_matrix</span><span class="s4">, </span><span class="s1">i</span><span class="s4">, </span><span class="s1">j</span><span class="s4">)</span>
                <span class="s3">else</span><span class="s4">:</span>
                    <span class="s3">assert </span><span class="s4">~</span><span class="s1">np</span><span class="s4">.</span><span class="s1">isreal</span><span class="s4">(</span><span class="s1">poles</span><span class="s4">[</span><span class="s1">i</span><span class="s4">]), </span><span class="s5">&quot;mixing real and complex &quot; </span><span class="s4">+ </span><span class="s1">\</span>
                        <span class="s5">&quot;in YT_real&quot; </span><span class="s4">+ </span><span class="s1">str</span><span class="s4">(</span><span class="s1">poles</span><span class="s4">)</span>
                    <span class="s1">_YT_complex</span><span class="s4">(</span><span class="s1">ker_pole</span><span class="s4">, </span><span class="s1">Q</span><span class="s4">, </span><span class="s1">transfer_matrix</span><span class="s4">, </span><span class="s1">i</span><span class="s4">, </span><span class="s1">j</span><span class="s4">)</span>

        <span class="s1">det_transfer_matrix </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">max</span><span class="s4">((</span><span class="s1">np</span><span class="s4">.</span><span class="s1">sqrt</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">spacing</span><span class="s4">(</span><span class="s6">1</span><span class="s4">)),</span>
                                  <span class="s1">np</span><span class="s4">.</span><span class="s1">abs</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">linalg</span><span class="s4">.</span><span class="s1">det</span><span class="s4">(</span><span class="s1">transfer_matrix</span><span class="s4">))))</span>
        <span class="s1">cur_rtol </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">abs</span><span class="s4">(</span>
            <span class="s4">(</span><span class="s1">det_transfer_matrix </span><span class="s4">-</span>
             <span class="s1">det_transfer_matrixb</span><span class="s4">) /</span>
            <span class="s1">det_transfer_matrix</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">cur_rtol </span><span class="s4">&lt; </span><span class="s1">rtol </span><span class="s3">and </span><span class="s1">det_transfer_matrix </span><span class="s4">&gt; </span><span class="s1">np</span><span class="s4">.</span><span class="s1">sqrt</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">spacing</span><span class="s4">(</span><span class="s6">1</span><span class="s4">)):</span>
            <span class="s2"># Convergence test from YT page 21</span>
            <span class="s1">stop </span><span class="s4">= </span><span class="s3">True</span>
        <span class="s1">nb_try </span><span class="s4">+= </span><span class="s6">1</span>
    <span class="s3">return </span><span class="s1">stop</span><span class="s4">, </span><span class="s1">cur_rtol</span><span class="s4">, </span><span class="s1">nb_try</span>


<span class="s3">def </span><span class="s1">_KNV0_loop</span><span class="s4">(</span><span class="s1">ker_pole</span><span class="s4">, </span><span class="s1">transfer_matrix</span><span class="s4">, </span><span class="s1">poles</span><span class="s4">, </span><span class="s1">B</span><span class="s4">, </span><span class="s1">maxiter</span><span class="s4">, </span><span class="s1">rtol</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Loop over all poles one by one and apply KNV method 0 algorithm 
    &quot;&quot;&quot;</span>
    <span class="s2"># This method is useful only because we need to be able to call</span>
    <span class="s2"># _KNV0 from YT without looping over all poles, otherwise it would</span>
    <span class="s2"># have been fine to mix _KNV0_loop and _KNV0 in a single function</span>
    <span class="s1">stop </span><span class="s4">= </span><span class="s3">False</span>
    <span class="s1">nb_try </span><span class="s4">= </span><span class="s6">0</span>
    <span class="s3">while </span><span class="s1">nb_try </span><span class="s4">&lt; </span><span class="s1">maxiter </span><span class="s3">and not </span><span class="s1">stop</span><span class="s4">:</span>
        <span class="s1">det_transfer_matrixb </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">abs</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">linalg</span><span class="s4">.</span><span class="s1">det</span><span class="s4">(</span><span class="s1">transfer_matrix</span><span class="s4">))</span>
        <span class="s3">for </span><span class="s1">j </span><span class="s3">in </span><span class="s1">range</span><span class="s4">(</span><span class="s1">B</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]):</span>
            <span class="s1">_KNV0</span><span class="s4">(</span><span class="s1">B</span><span class="s4">, </span><span class="s1">ker_pole</span><span class="s4">, </span><span class="s1">transfer_matrix</span><span class="s4">, </span><span class="s1">j</span><span class="s4">, </span><span class="s1">poles</span><span class="s4">)</span>

        <span class="s1">det_transfer_matrix </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">max</span><span class="s4">((</span><span class="s1">np</span><span class="s4">.</span><span class="s1">sqrt</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">spacing</span><span class="s4">(</span><span class="s6">1</span><span class="s4">)),</span>
                                  <span class="s1">np</span><span class="s4">.</span><span class="s1">abs</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">linalg</span><span class="s4">.</span><span class="s1">det</span><span class="s4">(</span><span class="s1">transfer_matrix</span><span class="s4">))))</span>
        <span class="s1">cur_rtol </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">abs</span><span class="s4">((</span><span class="s1">det_transfer_matrix </span><span class="s4">- </span><span class="s1">det_transfer_matrixb</span><span class="s4">) /</span>
                       <span class="s1">det_transfer_matrix</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">cur_rtol </span><span class="s4">&lt; </span><span class="s1">rtol </span><span class="s3">and </span><span class="s1">det_transfer_matrix </span><span class="s4">&gt; </span><span class="s1">np</span><span class="s4">.</span><span class="s1">sqrt</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">spacing</span><span class="s4">(</span><span class="s6">1</span><span class="s4">)):</span>
            <span class="s2"># Convergence test from YT page 21</span>
            <span class="s1">stop </span><span class="s4">= </span><span class="s3">True</span>

        <span class="s1">nb_try </span><span class="s4">+= </span><span class="s6">1</span>
    <span class="s3">return </span><span class="s1">stop</span><span class="s4">, </span><span class="s1">cur_rtol</span><span class="s4">, </span><span class="s1">nb_try</span>


<span class="s3">def </span><span class="s1">place_poles</span><span class="s4">(</span><span class="s1">A</span><span class="s4">, </span><span class="s1">B</span><span class="s4">, </span><span class="s1">poles</span><span class="s4">, </span><span class="s1">method</span><span class="s4">=</span><span class="s5">&quot;YT&quot;</span><span class="s4">, </span><span class="s1">rtol</span><span class="s4">=</span><span class="s6">1e-3</span><span class="s4">, </span><span class="s1">maxiter</span><span class="s4">=</span><span class="s6">30</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Compute K such that eigenvalues (A - dot(B, K))=poles. 
 
    K is the gain matrix such as the plant described by the linear system 
    ``AX+BU`` will have its closed-loop poles, i.e the eigenvalues ``A - B*K``, 
    as close as possible to those asked for in poles. 
 
    SISO, MISO and MIMO systems are supported. 
 
    Parameters 
    ---------- 
    A, B : ndarray 
        State-space representation of linear system ``AX + BU``. 
    poles : array_like 
        Desired real poles and/or complex conjugates poles. 
        Complex poles are only supported with ``method=&quot;YT&quot;`` (default). 
    method: {'YT', 'KNV0'}, optional 
        Which method to choose to find the gain matrix K. One of: 
 
            - 'YT': Yang Tits 
            - 'KNV0': Kautsky, Nichols, Van Dooren update method 0 
 
        See References and Notes for details on the algorithms. 
    rtol: float, optional 
        After each iteration the determinant of the eigenvectors of 
        ``A - B*K`` is compared to its previous value, when the relative 
        error between these two values becomes lower than `rtol` the algorithm 
        stops.  Default is 1e-3. 
    maxiter: int, optional 
        Maximum number of iterations to compute the gain matrix. 
        Default is 30. 
 
    Returns 
    ------- 
    full_state_feedback : Bunch object 
        full_state_feedback is composed of: 
            gain_matrix : 1-D ndarray 
                The closed loop matrix K such as the eigenvalues of ``A-BK`` 
                are as close as possible to the requested poles. 
            computed_poles : 1-D ndarray 
                The poles corresponding to ``A-BK`` sorted as first the real 
                poles in increasing order, then the complex congugates in 
                lexicographic order. 
            requested_poles : 1-D ndarray 
                The poles the algorithm was asked to place sorted as above, 
                they may differ from what was achieved. 
            X : 2-D ndarray 
                The transfer matrix such as ``X * diag(poles) = (A - B*K)*X`` 
                (see Notes) 
            rtol : float 
                The relative tolerance achieved on ``det(X)`` (see Notes). 
                `rtol` will be NaN if it is possible to solve the system 
                ``diag(poles) = (A - B*K)``, or 0 when the optimization 
                algorithms can't do anything i.e when ``B.shape[1] == 1``. 
            nb_iter : int 
                The number of iterations performed before converging. 
                `nb_iter` will be NaN if it is possible to solve the system 
                ``diag(poles) = (A - B*K)``, or 0 when the optimization 
                algorithms can't do anything i.e when ``B.shape[1] == 1``. 
 
    Notes 
    ----- 
    The Tits and Yang (YT), [2]_ paper is an update of the original Kautsky et 
    al. (KNV) paper [1]_.  KNV relies on rank-1 updates to find the transfer 
    matrix X such that ``X * diag(poles) = (A - B*K)*X``, whereas YT uses 
    rank-2 updates. This yields on average more robust solutions (see [2]_ 
    pp 21-22), furthermore the YT algorithm supports complex poles whereas KNV 
    does not in its original version.  Only update method 0 proposed by KNV has 
    been implemented here, hence the name ``'KNV0'``. 
 
    KNV extended to complex poles is used in Matlab's ``place`` function, YT is 
    distributed under a non-free licence by Slicot under the name ``robpole``. 
    It is unclear and undocumented how KNV0 has been extended to complex poles 
    (Tits and Yang claim on page 14 of their paper that their method can not be 
    used to extend KNV to complex poles), therefore only YT supports them in 
    this implementation. 
 
    As the solution to the problem of pole placement is not unique for MIMO 
    systems, both methods start with a tentative transfer matrix which is 
    altered in various way to increase its determinant.  Both methods have been 
    proven to converge to a stable solution, however depending on the way the 
    initial transfer matrix is chosen they will converge to different 
    solutions and therefore there is absolutely no guarantee that using 
    ``'KNV0'`` will yield results similar to Matlab's or any other 
    implementation of these algorithms. 
 
    Using the default method ``'YT'`` should be fine in most cases; ``'KNV0'`` 
    is only provided because it is needed by ``'YT'`` in some specific cases. 
    Furthermore ``'YT'`` gives on average more robust results than ``'KNV0'`` 
    when ``abs(det(X))`` is used as a robustness indicator. 
 
    [2]_ is available as a technical report on the following URL: 
    https://hdl.handle.net/1903/5598 
 
    References 
    ---------- 
    .. [1] J. Kautsky, N.K. Nichols and P. van Dooren, &quot;Robust pole assignment 
           in linear state feedback&quot;, International Journal of Control, Vol. 41 
           pp. 1129-1155, 1985. 
    .. [2] A.L. Tits and Y. Yang, &quot;Globally convergent algorithms for robust 
           pole assignment by state feedback&quot;, IEEE Transactions on Automatic 
           Control, Vol. 41, pp. 1432-1452, 1996. 
 
    Examples 
    -------- 
    A simple example demonstrating real pole placement using both KNV and YT 
    algorithms.  This is example number 1 from section 4 of the reference KNV 
    publication ([1]_): 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import signal 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
 
    &gt;&gt;&gt; A = np.array([[ 1.380,  -0.2077,  6.715, -5.676  ], 
    ...               [-0.5814, -4.290,   0,      0.6750 ], 
    ...               [ 1.067,   4.273,  -6.654,  5.893  ], 
    ...               [ 0.0480,  4.273,   1.343, -2.104  ]]) 
    &gt;&gt;&gt; B = np.array([[ 0,      5.679 ], 
    ...               [ 1.136,  1.136 ], 
    ...               [ 0,      0,    ], 
    ...               [-3.146,  0     ]]) 
    &gt;&gt;&gt; P = np.array([-0.2, -0.5, -5.0566, -8.6659]) 
 
    Now compute K with KNV method 0, with the default YT method and with the YT 
    method while forcing 100 iterations of the algorithm and print some results 
    after each call. 
 
    &gt;&gt;&gt; fsf1 = signal.place_poles(A, B, P, method='KNV0') 
    &gt;&gt;&gt; fsf1.gain_matrix 
    array([[ 0.20071427, -0.96665799,  0.24066128, -0.10279785], 
           [ 0.50587268,  0.57779091,  0.51795763, -0.41991442]]) 
 
    &gt;&gt;&gt; fsf2 = signal.place_poles(A, B, P)  # uses YT method 
    &gt;&gt;&gt; fsf2.computed_poles 
    array([-8.6659, -5.0566, -0.5   , -0.2   ]) 
 
    &gt;&gt;&gt; fsf3 = signal.place_poles(A, B, P, rtol=-1, maxiter=100) 
    &gt;&gt;&gt; fsf3.X 
    array([[ 0.52072442+0.j, -0.08409372+0.j, -0.56847937+0.j,  0.74823657+0.j], 
           [-0.04977751+0.j, -0.80872954+0.j,  0.13566234+0.j, -0.29322906+0.j], 
           [-0.82266932+0.j, -0.19168026+0.j, -0.56348322+0.j, -0.43815060+0.j], 
           [ 0.22267347+0.j,  0.54967577+0.j, -0.58387806+0.j, -0.40271926+0.j]]) 
 
    The absolute value of the determinant of X is a good indicator to check the 
    robustness of the results, both ``'KNV0'`` and ``'YT'`` aim at maximizing 
    it.  Below a comparison of the robustness of the results above: 
 
    &gt;&gt;&gt; abs(np.linalg.det(fsf1.X)) &lt; abs(np.linalg.det(fsf2.X)) 
    True 
    &gt;&gt;&gt; abs(np.linalg.det(fsf2.X)) &lt; abs(np.linalg.det(fsf3.X)) 
    True 
 
    Now a simple example for complex poles: 
 
    &gt;&gt;&gt; A = np.array([[ 0,  7/3.,  0,   0   ], 
    ...               [ 0,   0,    0,  7/9. ], 
    ...               [ 0,   0,    0,   0   ], 
    ...               [ 0,   0,    0,   0   ]]) 
    &gt;&gt;&gt; B = np.array([[ 0,  0 ], 
    ...               [ 0,  0 ], 
    ...               [ 1,  0 ], 
    ...               [ 0,  1 ]]) 
    &gt;&gt;&gt; P = np.array([-3, -1, -2-1j, -2+1j]) / 3. 
    &gt;&gt;&gt; fsf = signal.place_poles(A, B, P, method='YT') 
 
    We can plot the desired and computed poles in the complex plane: 
 
    &gt;&gt;&gt; t = np.linspace(0, 2*np.pi, 401) 
    &gt;&gt;&gt; plt.plot(np.cos(t), np.sin(t), 'k--')  # unit circle 
    &gt;&gt;&gt; plt.plot(fsf.requested_poles.real, fsf.requested_poles.imag, 
    ...          'wo', label='Desired') 
    &gt;&gt;&gt; plt.plot(fsf.computed_poles.real, fsf.computed_poles.imag, 'bx', 
    ...          label='Placed') 
    &gt;&gt;&gt; plt.grid() 
    &gt;&gt;&gt; plt.axis('image') 
    &gt;&gt;&gt; plt.axis([-1.1, 1.1, -1.1, 1.1]) 
    &gt;&gt;&gt; plt.legend(bbox_to_anchor=(1.05, 1), loc=2, numpoints=1) 
 
    &quot;&quot;&quot;</span>
    <span class="s2"># Move away all the inputs checking, it only adds noise to the code</span>
    <span class="s1">update_loop</span><span class="s4">, </span><span class="s1">poles </span><span class="s4">= </span><span class="s1">_valid_inputs</span><span class="s4">(</span><span class="s1">A</span><span class="s4">, </span><span class="s1">B</span><span class="s4">, </span><span class="s1">poles</span><span class="s4">, </span><span class="s1">method</span><span class="s4">, </span><span class="s1">rtol</span><span class="s4">, </span><span class="s1">maxiter</span><span class="s4">)</span>

    <span class="s2"># The current value of the relative tolerance we achieved</span>
    <span class="s1">cur_rtol </span><span class="s4">= </span><span class="s6">0</span>
    <span class="s2"># The number of iterations needed before converging</span>
    <span class="s1">nb_iter </span><span class="s4">= </span><span class="s6">0</span>

    <span class="s2"># Step A: QR decomposition of B page 1132 KN</span>
    <span class="s2"># to debug with numpy qr uncomment the line below</span>
    <span class="s2"># u, z = np.linalg.qr(B, mode=&quot;complete&quot;)</span>
    <span class="s1">u</span><span class="s4">, </span><span class="s1">z </span><span class="s4">= </span><span class="s1">s_qr</span><span class="s4">(</span><span class="s1">B</span><span class="s4">, </span><span class="s1">mode</span><span class="s4">=</span><span class="s5">&quot;full&quot;</span><span class="s4">)</span>
    <span class="s1">rankB </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">linalg</span><span class="s4">.</span><span class="s1">matrix_rank</span><span class="s4">(</span><span class="s1">B</span><span class="s4">)</span>
    <span class="s1">u0 </span><span class="s4">= </span><span class="s1">u</span><span class="s4">[:, :</span><span class="s1">rankB</span><span class="s4">]</span>
    <span class="s1">u1 </span><span class="s4">= </span><span class="s1">u</span><span class="s4">[:, </span><span class="s1">rankB</span><span class="s4">:]</span>
    <span class="s1">z </span><span class="s4">= </span><span class="s1">z</span><span class="s4">[:</span><span class="s1">rankB</span><span class="s4">, :]</span>

    <span class="s2"># If we can use the identity matrix as X the solution is obvious</span>
    <span class="s3">if </span><span class="s1">B</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">] == </span><span class="s1">rankB</span><span class="s4">:</span>
        <span class="s2"># if B is square and full rank there is only one solution</span>
        <span class="s2"># such as (A+BK)=inv(X)*diag(P)*X with X=eye(A.shape[0])</span>
        <span class="s2"># i.e K=inv(B)*(diag(P)-A)</span>
        <span class="s2"># if B has as many lines as its rank (but not square) there are many</span>
        <span class="s2"># solutions and we can choose one using least squares</span>
        <span class="s2"># =&gt; use lstsq in both cases.</span>
        <span class="s2"># In both cases the transfer matrix X will be eye(A.shape[0]) and I</span>
        <span class="s2"># can hardly think of a better one so there is nothing to optimize</span>
        <span class="s2">#</span>
        <span class="s2"># for complex poles we use the following trick</span>
        <span class="s2">#</span>
        <span class="s2"># |a -b| has for eigenvalues a+b and a-b</span>
        <span class="s2"># |b a|</span>
        <span class="s2">#</span>
        <span class="s2"># |a+bi 0| has the obvious eigenvalues a+bi and a-bi</span>
        <span class="s2"># |0 a-bi|</span>
        <span class="s2">#</span>
        <span class="s2"># e.g solving the first one in R gives the solution</span>
        <span class="s2"># for the second one in C</span>
        <span class="s1">diag_poles </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">zeros</span><span class="s4">(</span><span class="s1">A</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">)</span>
        <span class="s1">idx </span><span class="s4">= </span><span class="s6">0</span>
        <span class="s3">while </span><span class="s1">idx </span><span class="s4">&lt; </span><span class="s1">poles</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]:</span>
            <span class="s1">p </span><span class="s4">= </span><span class="s1">poles</span><span class="s4">[</span><span class="s1">idx</span><span class="s4">]</span>
            <span class="s1">diag_poles</span><span class="s4">[</span><span class="s1">idx</span><span class="s4">, </span><span class="s1">idx</span><span class="s4">] = </span><span class="s1">np</span><span class="s4">.</span><span class="s1">real</span><span class="s4">(</span><span class="s1">p</span><span class="s4">)</span>
            <span class="s3">if </span><span class="s4">~</span><span class="s1">np</span><span class="s4">.</span><span class="s1">isreal</span><span class="s4">(</span><span class="s1">p</span><span class="s4">):</span>
                <span class="s1">diag_poles</span><span class="s4">[</span><span class="s1">idx</span><span class="s4">, </span><span class="s1">idx</span><span class="s4">+</span><span class="s6">1</span><span class="s4">] = -</span><span class="s1">np</span><span class="s4">.</span><span class="s1">imag</span><span class="s4">(</span><span class="s1">p</span><span class="s4">)</span>
                <span class="s1">diag_poles</span><span class="s4">[</span><span class="s1">idx</span><span class="s4">+</span><span class="s6">1</span><span class="s4">, </span><span class="s1">idx</span><span class="s4">+</span><span class="s6">1</span><span class="s4">] = </span><span class="s1">np</span><span class="s4">.</span><span class="s1">real</span><span class="s4">(</span><span class="s1">p</span><span class="s4">)</span>
                <span class="s1">diag_poles</span><span class="s4">[</span><span class="s1">idx</span><span class="s4">+</span><span class="s6">1</span><span class="s4">, </span><span class="s1">idx</span><span class="s4">] = </span><span class="s1">np</span><span class="s4">.</span><span class="s1">imag</span><span class="s4">(</span><span class="s1">p</span><span class="s4">)</span>
                <span class="s1">idx </span><span class="s4">+= </span><span class="s6">1  </span><span class="s2"># skip next one</span>
            <span class="s1">idx </span><span class="s4">+= </span><span class="s6">1</span>
        <span class="s1">gain_matrix </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">linalg</span><span class="s4">.</span><span class="s1">lstsq</span><span class="s4">(</span><span class="s1">B</span><span class="s4">, </span><span class="s1">diag_poles</span><span class="s4">-</span><span class="s1">A</span><span class="s4">, </span><span class="s1">rcond</span><span class="s4">=-</span><span class="s6">1</span><span class="s4">)[</span><span class="s6">0</span><span class="s4">]</span>
        <span class="s1">transfer_matrix </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">eye</span><span class="s4">(</span><span class="s1">A</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">])</span>
        <span class="s1">cur_rtol </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">nan</span>
        <span class="s1">nb_iter </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">nan</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s2"># step A (p1144 KNV) and beginning of step F: decompose</span>
        <span class="s2"># dot(U1.T, A-P[i]*I).T and build our set of transfer_matrix vectors</span>
        <span class="s2"># in the same loop</span>
        <span class="s1">ker_pole </span><span class="s4">= []</span>

        <span class="s2"># flag to skip the conjugate of a complex pole</span>
        <span class="s1">skip_conjugate </span><span class="s4">= </span><span class="s3">False</span>
        <span class="s2"># select orthonormal base ker_pole for each Pole and vectors for</span>
        <span class="s2"># transfer_matrix</span>
        <span class="s3">for </span><span class="s1">j </span><span class="s3">in </span><span class="s1">range</span><span class="s4">(</span><span class="s1">B</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]):</span>
            <span class="s3">if </span><span class="s1">skip_conjugate</span><span class="s4">:</span>
                <span class="s1">skip_conjugate </span><span class="s4">= </span><span class="s3">False</span>
                <span class="s3">continue</span>
            <span class="s1">pole_space_j </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">dot</span><span class="s4">(</span><span class="s1">u1</span><span class="s4">.</span><span class="s1">T</span><span class="s4">, </span><span class="s1">A</span><span class="s4">-</span><span class="s1">poles</span><span class="s4">[</span><span class="s1">j</span><span class="s4">]*</span><span class="s1">np</span><span class="s4">.</span><span class="s1">eye</span><span class="s4">(</span><span class="s1">B</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">])).</span><span class="s1">T</span>

            <span class="s2"># after QR Q=Q0|Q1</span>
            <span class="s2"># only Q0 is used to reconstruct  the qr'ed (dot Q, R) matrix.</span>
            <span class="s2"># Q1 is orthogonnal to Q0 and will be multiplied by the zeros in</span>
            <span class="s2"># R when using mode &quot;complete&quot;. In default mode Q1 and the zeros</span>
            <span class="s2"># in R are not computed</span>

            <span class="s2"># To debug with numpy qr uncomment the line below</span>
            <span class="s2"># Q, _ = np.linalg.qr(pole_space_j, mode=&quot;complete&quot;)</span>
            <span class="s1">Q</span><span class="s4">, </span><span class="s1">_ </span><span class="s4">= </span><span class="s1">s_qr</span><span class="s4">(</span><span class="s1">pole_space_j</span><span class="s4">, </span><span class="s1">mode</span><span class="s4">=</span><span class="s5">&quot;full&quot;</span><span class="s4">)</span>

            <span class="s1">ker_pole_j </span><span class="s4">= </span><span class="s1">Q</span><span class="s4">[:, </span><span class="s1">pole_space_j</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">1</span><span class="s4">]:]</span>

            <span class="s2"># We want to select one vector in ker_pole_j to build the transfer</span>
            <span class="s2"># matrix, however qr returns sometimes vectors with zeros on the</span>
            <span class="s2"># same line for each pole and this yields very long convergence</span>
            <span class="s2"># times.</span>
            <span class="s2"># Or some other times a set of vectors, one with zero imaginary</span>
            <span class="s2"># part and one (or several) with imaginary parts. After trying</span>
            <span class="s2"># many ways to select the best possible one (eg ditch vectors</span>
            <span class="s2"># with zero imaginary part for complex poles) I ended up summing</span>
            <span class="s2"># all vectors in ker_pole_j, this solves 100% of the problems and</span>
            <span class="s2"># is a valid choice for transfer_matrix.</span>
            <span class="s2"># This way for complex poles we are sure to have a non zero</span>
            <span class="s2"># imaginary part that way, and the problem of lines full of zeros</span>
            <span class="s2"># in transfer_matrix is solved too as when a vector from</span>
            <span class="s2"># ker_pole_j has a zero the other one(s) when</span>
            <span class="s2"># ker_pole_j.shape[1]&gt;1) for sure won't have a zero there.</span>

            <span class="s1">transfer_matrix_j </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">sum</span><span class="s4">(</span><span class="s1">ker_pole_j</span><span class="s4">, </span><span class="s1">axis</span><span class="s4">=</span><span class="s6">1</span><span class="s4">)[:, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">newaxis</span><span class="s4">]</span>
            <span class="s1">transfer_matrix_j </span><span class="s4">= (</span><span class="s1">transfer_matrix_j </span><span class="s4">/</span>
                                 <span class="s1">np</span><span class="s4">.</span><span class="s1">linalg</span><span class="s4">.</span><span class="s1">norm</span><span class="s4">(</span><span class="s1">transfer_matrix_j</span><span class="s4">))</span>
            <span class="s3">if </span><span class="s4">~</span><span class="s1">np</span><span class="s4">.</span><span class="s1">isreal</span><span class="s4">(</span><span class="s1">poles</span><span class="s4">[</span><span class="s1">j</span><span class="s4">]):  </span><span class="s2"># complex pole</span>
                <span class="s1">transfer_matrix_j </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">hstack</span><span class="s4">([</span><span class="s1">np</span><span class="s4">.</span><span class="s1">real</span><span class="s4">(</span><span class="s1">transfer_matrix_j</span><span class="s4">),</span>
                                               <span class="s1">np</span><span class="s4">.</span><span class="s1">imag</span><span class="s4">(</span><span class="s1">transfer_matrix_j</span><span class="s4">)])</span>
                <span class="s1">ker_pole</span><span class="s4">.</span><span class="s1">extend</span><span class="s4">([</span><span class="s1">ker_pole_j</span><span class="s4">, </span><span class="s1">ker_pole_j</span><span class="s4">])</span>

                <span class="s2"># Skip next pole as it is the conjugate</span>
                <span class="s1">skip_conjugate </span><span class="s4">= </span><span class="s3">True</span>
            <span class="s3">else</span><span class="s4">:  </span><span class="s2"># real pole, nothing to do</span>
                <span class="s1">ker_pole</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">ker_pole_j</span><span class="s4">)</span>

            <span class="s3">if </span><span class="s1">j </span><span class="s4">== </span><span class="s6">0</span><span class="s4">:</span>
                <span class="s1">transfer_matrix </span><span class="s4">= </span><span class="s1">transfer_matrix_j</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">transfer_matrix </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">hstack</span><span class="s4">((</span><span class="s1">transfer_matrix</span><span class="s4">, </span><span class="s1">transfer_matrix_j</span><span class="s4">))</span>

        <span class="s3">if </span><span class="s1">rankB </span><span class="s4">&gt; </span><span class="s6">1</span><span class="s4">:  </span><span class="s2"># otherwise there is nothing we can optimize</span>
            <span class="s1">stop</span><span class="s4">, </span><span class="s1">cur_rtol</span><span class="s4">, </span><span class="s1">nb_iter </span><span class="s4">= </span><span class="s1">update_loop</span><span class="s4">(</span><span class="s1">ker_pole</span><span class="s4">, </span><span class="s1">transfer_matrix</span><span class="s4">,</span>
                                                  <span class="s1">poles</span><span class="s4">, </span><span class="s1">B</span><span class="s4">, </span><span class="s1">maxiter</span><span class="s4">, </span><span class="s1">rtol</span><span class="s4">)</span>
            <span class="s3">if not </span><span class="s1">stop </span><span class="s3">and </span><span class="s1">rtol </span><span class="s4">&gt; </span><span class="s6">0</span><span class="s4">:</span>
                <span class="s2"># if rtol&lt;=0 the user has probably done that on purpose,</span>
                <span class="s2"># don't annoy them</span>
                <span class="s1">err_msg </span><span class="s4">= (</span>
                    <span class="s5">&quot;Convergence was not reached after maxiter iterations.</span><span class="s3">\n</span><span class="s5">&quot;</span>
                    <span class="s5">f&quot;You asked for a tolerance of </span><span class="s3">{</span><span class="s1">rtol</span><span class="s3">}</span><span class="s5">, we got </span><span class="s3">{</span><span class="s1">cur_rtol</span><span class="s3">}</span><span class="s5">.&quot;</span>
                    <span class="s4">)</span>
                <span class="s1">warnings</span><span class="s4">.</span><span class="s1">warn</span><span class="s4">(</span><span class="s1">err_msg</span><span class="s4">, </span><span class="s1">stacklevel</span><span class="s4">=</span><span class="s6">2</span><span class="s4">)</span>

        <span class="s2"># reconstruct transfer_matrix to match complex conjugate pairs,</span>
        <span class="s2"># ie transfer_matrix_j/transfer_matrix_j+1 are</span>
        <span class="s2"># Re(Complex_pole), Im(Complex_pole) now and will be Re-Im/Re+Im after</span>
        <span class="s1">transfer_matrix </span><span class="s4">= </span><span class="s1">transfer_matrix</span><span class="s4">.</span><span class="s1">astype</span><span class="s4">(</span><span class="s1">complex</span><span class="s4">)</span>
        <span class="s1">idx </span><span class="s4">= </span><span class="s6">0</span>
        <span class="s3">while </span><span class="s1">idx </span><span class="s4">&lt; </span><span class="s1">poles</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]-</span><span class="s6">1</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s4">~</span><span class="s1">np</span><span class="s4">.</span><span class="s1">isreal</span><span class="s4">(</span><span class="s1">poles</span><span class="s4">[</span><span class="s1">idx</span><span class="s4">]):</span>
                <span class="s1">rel </span><span class="s4">= </span><span class="s1">transfer_matrix</span><span class="s4">[:, </span><span class="s1">idx</span><span class="s4">].</span><span class="s1">copy</span><span class="s4">()</span>
                <span class="s1">img </span><span class="s4">= </span><span class="s1">transfer_matrix</span><span class="s4">[:, </span><span class="s1">idx</span><span class="s4">+</span><span class="s6">1</span><span class="s4">]</span>
                <span class="s2"># rel will be an array referencing a column of transfer_matrix</span>
                <span class="s2"># if we don't copy() it will changer after the next line and</span>
                <span class="s2"># and the line after will not yield the correct value</span>
                <span class="s1">transfer_matrix</span><span class="s4">[:, </span><span class="s1">idx</span><span class="s4">] = </span><span class="s1">rel</span><span class="s4">-</span><span class="s6">1j</span><span class="s4">*</span><span class="s1">img</span>
                <span class="s1">transfer_matrix</span><span class="s4">[:, </span><span class="s1">idx</span><span class="s4">+</span><span class="s6">1</span><span class="s4">] = </span><span class="s1">rel</span><span class="s4">+</span><span class="s6">1j</span><span class="s4">*</span><span class="s1">img</span>
                <span class="s1">idx </span><span class="s4">+= </span><span class="s6">1  </span><span class="s2"># skip next one</span>
            <span class="s1">idx </span><span class="s4">+= </span><span class="s6">1</span>

        <span class="s3">try</span><span class="s4">:</span>
            <span class="s1">m </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">linalg</span><span class="s4">.</span><span class="s1">solve</span><span class="s4">(</span><span class="s1">transfer_matrix</span><span class="s4">.</span><span class="s1">T</span><span class="s4">, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">dot</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">diag</span><span class="s4">(</span><span class="s1">poles</span><span class="s4">),</span>
                                                          <span class="s1">transfer_matrix</span><span class="s4">.</span><span class="s1">T</span><span class="s4">)).</span><span class="s1">T</span>
            <span class="s1">gain_matrix </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">linalg</span><span class="s4">.</span><span class="s1">solve</span><span class="s4">(</span><span class="s1">z</span><span class="s4">, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">dot</span><span class="s4">(</span><span class="s1">u0</span><span class="s4">.</span><span class="s1">T</span><span class="s4">, </span><span class="s1">m</span><span class="s4">-</span><span class="s1">A</span><span class="s4">))</span>
        <span class="s3">except </span><span class="s1">np</span><span class="s4">.</span><span class="s1">linalg</span><span class="s4">.</span><span class="s1">LinAlgError </span><span class="s3">as </span><span class="s1">e</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;The poles you've chosen can't be placed. &quot;</span>
                             <span class="s5">&quot;Check the controllability matrix and try &quot;</span>
                             <span class="s5">&quot;another set of poles&quot;</span><span class="s4">) </span><span class="s3">from </span><span class="s1">e</span>

    <span class="s2"># Beware: Kautsky solves A+BK but the usual form is A-BK</span>
    <span class="s1">gain_matrix </span><span class="s4">= -</span><span class="s1">gain_matrix</span>
    <span class="s2"># K still contains complex with ~=0j imaginary parts, get rid of them</span>
    <span class="s1">gain_matrix </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">real</span><span class="s4">(</span><span class="s1">gain_matrix</span><span class="s4">)</span>

    <span class="s1">full_state_feedback </span><span class="s4">= </span><span class="s1">Bunch</span><span class="s4">()</span>
    <span class="s1">full_state_feedback</span><span class="s4">.</span><span class="s1">gain_matrix </span><span class="s4">= </span><span class="s1">gain_matrix</span>
    <span class="s1">full_state_feedback</span><span class="s4">.</span><span class="s1">computed_poles </span><span class="s4">= </span><span class="s1">_order_complex_poles</span><span class="s4">(</span>
        <span class="s1">np</span><span class="s4">.</span><span class="s1">linalg</span><span class="s4">.</span><span class="s1">eig</span><span class="s4">(</span><span class="s1">A </span><span class="s4">- </span><span class="s1">np</span><span class="s4">.</span><span class="s1">dot</span><span class="s4">(</span><span class="s1">B</span><span class="s4">, </span><span class="s1">gain_matrix</span><span class="s4">))[</span><span class="s6">0</span><span class="s4">]</span>
        <span class="s4">)</span>
    <span class="s1">full_state_feedback</span><span class="s4">.</span><span class="s1">requested_poles </span><span class="s4">= </span><span class="s1">poles</span>
    <span class="s1">full_state_feedback</span><span class="s4">.</span><span class="s1">X </span><span class="s4">= </span><span class="s1">transfer_matrix</span>
    <span class="s1">full_state_feedback</span><span class="s4">.</span><span class="s1">rtol </span><span class="s4">= </span><span class="s1">cur_rtol</span>
    <span class="s1">full_state_feedback</span><span class="s4">.</span><span class="s1">nb_iter </span><span class="s4">= </span><span class="s1">nb_iter</span>

    <span class="s3">return </span><span class="s1">full_state_feedback</span>


<span class="s3">def </span><span class="s1">dlsim</span><span class="s4">(</span><span class="s1">system</span><span class="s4">, </span><span class="s1">u</span><span class="s4">, </span><span class="s1">t</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">x0</span><span class="s4">=</span><span class="s3">None</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Simulate output of a discrete-time linear system. 
 
    Parameters 
    ---------- 
    system : tuple of array_like or instance of `dlti` 
        A tuple describing the system. 
        The following gives the number of elements in the tuple and 
        the interpretation: 
 
            * 1: (instance of `dlti`) 
            * 3: (num, den, dt) 
            * 4: (zeros, poles, gain, dt) 
            * 5: (A, B, C, D, dt) 
 
    u : array_like 
        An input array describing the input at each time `t` (interpolation is 
        assumed between given times).  If there are multiple inputs, then each 
        column of the rank-2 array represents an input. 
    t : array_like, optional 
        The time steps at which the input is defined.  If `t` is given, it 
        must be the same length as `u`, and the final value in `t` determines 
        the number of steps returned in the output. 
    x0 : array_like, optional 
        The initial conditions on the state vector (zero by default). 
 
    Returns 
    ------- 
    tout : ndarray 
        Time values for the output, as a 1-D array. 
    yout : ndarray 
        System response, as a 1-D array. 
    xout : ndarray, optional 
        Time-evolution of the state-vector.  Only generated if the input is a 
        `StateSpace` system. 
 
    See Also 
    -------- 
    lsim, dstep, dimpulse, cont2discrete 
 
    Examples 
    -------- 
    A simple integrator transfer function with a discrete time step of 1.0 
    could be implemented as: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import signal 
    &gt;&gt;&gt; tf = ([1.0,], [1.0, -1.0], 1.0) 
    &gt;&gt;&gt; t_in = [0.0, 1.0, 2.0, 3.0] 
    &gt;&gt;&gt; u = np.asarray([0.0, 0.0, 1.0, 1.0]) 
    &gt;&gt;&gt; t_out, y = signal.dlsim(tf, u, t=t_in) 
    &gt;&gt;&gt; y.T 
    array([[ 0.,  0.,  0.,  1.]]) 
 
    &quot;&quot;&quot;</span>
    <span class="s2"># Convert system to dlti-StateSpace</span>
    <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">system</span><span class="s4">, </span><span class="s1">lti</span><span class="s4">):</span>
        <span class="s3">raise </span><span class="s1">AttributeError</span><span class="s4">(</span><span class="s5">'dlsim can only be used with discrete-time dlti '</span>
                             <span class="s5">'systems.'</span><span class="s4">)</span>
    <span class="s3">elif not </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">system</span><span class="s4">, </span><span class="s1">dlti</span><span class="s4">):</span>
        <span class="s1">system </span><span class="s4">= </span><span class="s1">dlti</span><span class="s4">(*</span><span class="s1">system</span><span class="s4">[:-</span><span class="s6">1</span><span class="s4">], </span><span class="s1">dt</span><span class="s4">=</span><span class="s1">system</span><span class="s4">[-</span><span class="s6">1</span><span class="s4">])</span>

    <span class="s2"># Condition needed to ensure output remains compatible</span>
    <span class="s1">is_ss_input </span><span class="s4">= </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">system</span><span class="s4">, </span><span class="s1">StateSpace</span><span class="s4">)</span>
    <span class="s1">system </span><span class="s4">= </span><span class="s1">system</span><span class="s4">.</span><span class="s1">_as_ss</span><span class="s4">()</span>

    <span class="s1">u </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">atleast_1d</span><span class="s4">(</span><span class="s1">u</span><span class="s4">)</span>

    <span class="s3">if </span><span class="s1">u</span><span class="s4">.</span><span class="s1">ndim </span><span class="s4">== </span><span class="s6">1</span><span class="s4">:</span>
        <span class="s1">u </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">atleast_2d</span><span class="s4">(</span><span class="s1">u</span><span class="s4">).</span><span class="s1">T</span>

    <span class="s3">if </span><span class="s1">t </span><span class="s3">is None</span><span class="s4">:</span>
        <span class="s1">out_samples </span><span class="s4">= </span><span class="s1">len</span><span class="s4">(</span><span class="s1">u</span><span class="s4">)</span>
        <span class="s1">stoptime </span><span class="s4">= (</span><span class="s1">out_samples </span><span class="s4">- </span><span class="s6">1</span><span class="s4">) * </span><span class="s1">system</span><span class="s4">.</span><span class="s1">dt</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">stoptime </span><span class="s4">= </span><span class="s1">t</span><span class="s4">[-</span><span class="s6">1</span><span class="s4">]</span>
        <span class="s1">out_samples </span><span class="s4">= </span><span class="s1">int</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">floor</span><span class="s4">(</span><span class="s1">stoptime </span><span class="s4">/ </span><span class="s1">system</span><span class="s4">.</span><span class="s1">dt</span><span class="s4">)) + </span><span class="s6">1</span>

    <span class="s2"># Pre-build output arrays</span>
    <span class="s1">xout </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">zeros</span><span class="s4">((</span><span class="s1">out_samples</span><span class="s4">, </span><span class="s1">system</span><span class="s4">.</span><span class="s1">A</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]))</span>
    <span class="s1">yout </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">zeros</span><span class="s4">((</span><span class="s1">out_samples</span><span class="s4">, </span><span class="s1">system</span><span class="s4">.</span><span class="s1">C</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]))</span>
    <span class="s1">tout </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">linspace</span><span class="s4">(</span><span class="s6">0.0</span><span class="s4">, </span><span class="s1">stoptime</span><span class="s4">, </span><span class="s1">num</span><span class="s4">=</span><span class="s1">out_samples</span><span class="s4">)</span>

    <span class="s2"># Check initial condition</span>
    <span class="s3">if </span><span class="s1">x0 </span><span class="s3">is None</span><span class="s4">:</span>
        <span class="s1">xout</span><span class="s4">[</span><span class="s6">0</span><span class="s4">, :] = </span><span class="s1">np</span><span class="s4">.</span><span class="s1">zeros</span><span class="s4">((</span><span class="s1">system</span><span class="s4">.</span><span class="s1">A</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">1</span><span class="s4">],))</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">xout</span><span class="s4">[</span><span class="s6">0</span><span class="s4">, :] = </span><span class="s1">np</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">(</span><span class="s1">x0</span><span class="s4">)</span>

    <span class="s2"># Pre-interpolate inputs into the desired time steps</span>
    <span class="s3">if </span><span class="s1">t </span><span class="s3">is None</span><span class="s4">:</span>
        <span class="s1">u_dt </span><span class="s4">= </span><span class="s1">u</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">u</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">) == </span><span class="s6">1</span><span class="s4">:</span>
            <span class="s1">u </span><span class="s4">= </span><span class="s1">u</span><span class="s4">[:, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">newaxis</span><span class="s4">]</span>

        <span class="s1">u_dt </span><span class="s4">= </span><span class="s1">make_interp_spline</span><span class="s4">(</span><span class="s1">t</span><span class="s4">, </span><span class="s1">u</span><span class="s4">, </span><span class="s1">k</span><span class="s4">=</span><span class="s6">1</span><span class="s4">)(</span><span class="s1">tout</span><span class="s4">)</span>

    <span class="s2"># Simulate the system</span>
    <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range</span><span class="s4">(</span><span class="s6">0</span><span class="s4">, </span><span class="s1">out_samples </span><span class="s4">- </span><span class="s6">1</span><span class="s4">):</span>
        <span class="s1">xout</span><span class="s4">[</span><span class="s1">i</span><span class="s4">+</span><span class="s6">1</span><span class="s4">, :] = (</span><span class="s1">np</span><span class="s4">.</span><span class="s1">dot</span><span class="s4">(</span><span class="s1">system</span><span class="s4">.</span><span class="s1">A</span><span class="s4">, </span><span class="s1">xout</span><span class="s4">[</span><span class="s1">i</span><span class="s4">, :]) +</span>
                        <span class="s1">np</span><span class="s4">.</span><span class="s1">dot</span><span class="s4">(</span><span class="s1">system</span><span class="s4">.</span><span class="s1">B</span><span class="s4">, </span><span class="s1">u_dt</span><span class="s4">[</span><span class="s1">i</span><span class="s4">, :]))</span>
        <span class="s1">yout</span><span class="s4">[</span><span class="s1">i</span><span class="s4">, :] = (</span><span class="s1">np</span><span class="s4">.</span><span class="s1">dot</span><span class="s4">(</span><span class="s1">system</span><span class="s4">.</span><span class="s1">C</span><span class="s4">, </span><span class="s1">xout</span><span class="s4">[</span><span class="s1">i</span><span class="s4">, :]) +</span>
                      <span class="s1">np</span><span class="s4">.</span><span class="s1">dot</span><span class="s4">(</span><span class="s1">system</span><span class="s4">.</span><span class="s1">D</span><span class="s4">, </span><span class="s1">u_dt</span><span class="s4">[</span><span class="s1">i</span><span class="s4">, :]))</span>

    <span class="s2"># Last point</span>
    <span class="s1">yout</span><span class="s4">[</span><span class="s1">out_samples</span><span class="s4">-</span><span class="s6">1</span><span class="s4">, :] = (</span><span class="s1">np</span><span class="s4">.</span><span class="s1">dot</span><span class="s4">(</span><span class="s1">system</span><span class="s4">.</span><span class="s1">C</span><span class="s4">, </span><span class="s1">xout</span><span class="s4">[</span><span class="s1">out_samples</span><span class="s4">-</span><span class="s6">1</span><span class="s4">, :]) +</span>
                              <span class="s1">np</span><span class="s4">.</span><span class="s1">dot</span><span class="s4">(</span><span class="s1">system</span><span class="s4">.</span><span class="s1">D</span><span class="s4">, </span><span class="s1">u_dt</span><span class="s4">[</span><span class="s1">out_samples</span><span class="s4">-</span><span class="s6">1</span><span class="s4">, :]))</span>

    <span class="s3">if </span><span class="s1">is_ss_input</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">tout</span><span class="s4">, </span><span class="s1">yout</span><span class="s4">, </span><span class="s1">xout</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">tout</span><span class="s4">, </span><span class="s1">yout</span>


<span class="s3">def </span><span class="s1">dimpulse</span><span class="s4">(</span><span class="s1">system</span><span class="s4">, </span><span class="s1">x0</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">t</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">n</span><span class="s4">=</span><span class="s3">None</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Impulse response of discrete-time system. 
 
    Parameters 
    ---------- 
    system : tuple of array_like or instance of `dlti` 
        A tuple describing the system. 
        The following gives the number of elements in the tuple and 
        the interpretation: 
 
            * 1: (instance of `dlti`) 
            * 3: (num, den, dt) 
            * 4: (zeros, poles, gain, dt) 
            * 5: (A, B, C, D, dt) 
 
    x0 : array_like, optional 
        Initial state-vector.  Defaults to zero. 
    t : array_like, optional 
        Time points.  Computed if not given. 
    n : int, optional 
        The number of time points to compute (if `t` is not given). 
 
    Returns 
    ------- 
    tout : ndarray 
        Time values for the output, as a 1-D array. 
    yout : tuple of ndarray 
        Impulse response of system.  Each element of the tuple represents 
        the output of the system based on an impulse in each input. 
 
    See Also 
    -------- 
    impulse, dstep, dlsim, cont2discrete 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import signal 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
 
    &gt;&gt;&gt; butter = signal.dlti(*signal.butter(3, 0.5)) 
    &gt;&gt;&gt; t, y = signal.dimpulse(butter, n=25) 
    &gt;&gt;&gt; plt.step(t, np.squeeze(y)) 
    &gt;&gt;&gt; plt.grid() 
    &gt;&gt;&gt; plt.xlabel('n [samples]') 
    &gt;&gt;&gt; plt.ylabel('Amplitude') 
 
    &quot;&quot;&quot;</span>
    <span class="s2"># Convert system to dlti-StateSpace</span>
    <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">system</span><span class="s4">, </span><span class="s1">dlti</span><span class="s4">):</span>
        <span class="s1">system </span><span class="s4">= </span><span class="s1">system</span><span class="s4">.</span><span class="s1">_as_ss</span><span class="s4">()</span>
    <span class="s3">elif </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">system</span><span class="s4">, </span><span class="s1">lti</span><span class="s4">):</span>
        <span class="s3">raise </span><span class="s1">AttributeError</span><span class="s4">(</span><span class="s5">'dimpulse can only be used with discrete-time '</span>
                             <span class="s5">'dlti systems.'</span><span class="s4">)</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">system </span><span class="s4">= </span><span class="s1">dlti</span><span class="s4">(*</span><span class="s1">system</span><span class="s4">[:-</span><span class="s6">1</span><span class="s4">], </span><span class="s1">dt</span><span class="s4">=</span><span class="s1">system</span><span class="s4">[-</span><span class="s6">1</span><span class="s4">]).</span><span class="s1">_as_ss</span><span class="s4">()</span>

    <span class="s2"># Default to 100 samples if unspecified</span>
    <span class="s3">if </span><span class="s1">n </span><span class="s3">is None</span><span class="s4">:</span>
        <span class="s1">n </span><span class="s4">= </span><span class="s6">100</span>

    <span class="s2"># If time is not specified, use the number of samples</span>
    <span class="s2"># and system dt</span>
    <span class="s3">if </span><span class="s1">t </span><span class="s3">is None</span><span class="s4">:</span>
        <span class="s1">t </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">linspace</span><span class="s4">(</span><span class="s6">0</span><span class="s4">, </span><span class="s1">n </span><span class="s4">* </span><span class="s1">system</span><span class="s4">.</span><span class="s1">dt</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">endpoint</span><span class="s4">=</span><span class="s3">False</span><span class="s4">)</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">t </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">(</span><span class="s1">t</span><span class="s4">)</span>

    <span class="s2"># For each input, implement a step change</span>
    <span class="s1">yout </span><span class="s4">= </span><span class="s3">None</span>
    <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range</span><span class="s4">(</span><span class="s6">0</span><span class="s4">, </span><span class="s1">system</span><span class="s4">.</span><span class="s1">inputs</span><span class="s4">):</span>
        <span class="s1">u </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">zeros</span><span class="s4">((</span><span class="s1">t</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">], </span><span class="s1">system</span><span class="s4">.</span><span class="s1">inputs</span><span class="s4">))</span>
        <span class="s1">u</span><span class="s4">[</span><span class="s6">0</span><span class="s4">, </span><span class="s1">i</span><span class="s4">] = </span><span class="s6">1.0</span>

        <span class="s1">one_output </span><span class="s4">= </span><span class="s1">dlsim</span><span class="s4">(</span><span class="s1">system</span><span class="s4">, </span><span class="s1">u</span><span class="s4">, </span><span class="s1">t</span><span class="s4">=</span><span class="s1">t</span><span class="s4">, </span><span class="s1">x0</span><span class="s4">=</span><span class="s1">x0</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s1">yout </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s1">yout </span><span class="s4">= (</span><span class="s1">one_output</span><span class="s4">[</span><span class="s6">1</span><span class="s4">],)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">yout </span><span class="s4">= </span><span class="s1">yout </span><span class="s4">+ (</span><span class="s1">one_output</span><span class="s4">[</span><span class="s6">1</span><span class="s4">],)</span>

        <span class="s1">tout </span><span class="s4">= </span><span class="s1">one_output</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]</span>

    <span class="s3">return </span><span class="s1">tout</span><span class="s4">, </span><span class="s1">yout</span>


<span class="s3">def </span><span class="s1">dstep</span><span class="s4">(</span><span class="s1">system</span><span class="s4">, </span><span class="s1">x0</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">t</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">n</span><span class="s4">=</span><span class="s3">None</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Step response of discrete-time system. 
 
    Parameters 
    ---------- 
    system : tuple of array_like 
        A tuple describing the system. 
        The following gives the number of elements in the tuple and 
        the interpretation: 
 
            * 1: (instance of `dlti`) 
            * 3: (num, den, dt) 
            * 4: (zeros, poles, gain, dt) 
            * 5: (A, B, C, D, dt) 
 
    x0 : array_like, optional 
        Initial state-vector.  Defaults to zero. 
    t : array_like, optional 
        Time points.  Computed if not given. 
    n : int, optional 
        The number of time points to compute (if `t` is not given). 
 
    Returns 
    ------- 
    tout : ndarray 
        Output time points, as a 1-D array. 
    yout : tuple of ndarray 
        Step response of system.  Each element of the tuple represents 
        the output of the system based on a step response to each input. 
 
    See Also 
    -------- 
    step, dimpulse, dlsim, cont2discrete 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import signal 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
 
    &gt;&gt;&gt; butter = signal.dlti(*signal.butter(3, 0.5)) 
    &gt;&gt;&gt; t, y = signal.dstep(butter, n=25) 
    &gt;&gt;&gt; plt.step(t, np.squeeze(y)) 
    &gt;&gt;&gt; plt.grid() 
    &gt;&gt;&gt; plt.xlabel('n [samples]') 
    &gt;&gt;&gt; plt.ylabel('Amplitude') 
    &quot;&quot;&quot;</span>
    <span class="s2"># Convert system to dlti-StateSpace</span>
    <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">system</span><span class="s4">, </span><span class="s1">dlti</span><span class="s4">):</span>
        <span class="s1">system </span><span class="s4">= </span><span class="s1">system</span><span class="s4">.</span><span class="s1">_as_ss</span><span class="s4">()</span>
    <span class="s3">elif </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">system</span><span class="s4">, </span><span class="s1">lti</span><span class="s4">):</span>
        <span class="s3">raise </span><span class="s1">AttributeError</span><span class="s4">(</span><span class="s5">'dstep can only be used with discrete-time dlti '</span>
                             <span class="s5">'systems.'</span><span class="s4">)</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">system </span><span class="s4">= </span><span class="s1">dlti</span><span class="s4">(*</span><span class="s1">system</span><span class="s4">[:-</span><span class="s6">1</span><span class="s4">], </span><span class="s1">dt</span><span class="s4">=</span><span class="s1">system</span><span class="s4">[-</span><span class="s6">1</span><span class="s4">]).</span><span class="s1">_as_ss</span><span class="s4">()</span>

    <span class="s2"># Default to 100 samples if unspecified</span>
    <span class="s3">if </span><span class="s1">n </span><span class="s3">is None</span><span class="s4">:</span>
        <span class="s1">n </span><span class="s4">= </span><span class="s6">100</span>

    <span class="s2"># If time is not specified, use the number of samples</span>
    <span class="s2"># and system dt</span>
    <span class="s3">if </span><span class="s1">t </span><span class="s3">is None</span><span class="s4">:</span>
        <span class="s1">t </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">linspace</span><span class="s4">(</span><span class="s6">0</span><span class="s4">, </span><span class="s1">n </span><span class="s4">* </span><span class="s1">system</span><span class="s4">.</span><span class="s1">dt</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">endpoint</span><span class="s4">=</span><span class="s3">False</span><span class="s4">)</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">t </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">(</span><span class="s1">t</span><span class="s4">)</span>

    <span class="s2"># For each input, implement a step change</span>
    <span class="s1">yout </span><span class="s4">= </span><span class="s3">None</span>
    <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range</span><span class="s4">(</span><span class="s6">0</span><span class="s4">, </span><span class="s1">system</span><span class="s4">.</span><span class="s1">inputs</span><span class="s4">):</span>
        <span class="s1">u </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">zeros</span><span class="s4">((</span><span class="s1">t</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">], </span><span class="s1">system</span><span class="s4">.</span><span class="s1">inputs</span><span class="s4">))</span>
        <span class="s1">u</span><span class="s4">[:, </span><span class="s1">i</span><span class="s4">] = </span><span class="s1">np</span><span class="s4">.</span><span class="s1">ones</span><span class="s4">((</span><span class="s1">t</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">],))</span>

        <span class="s1">one_output </span><span class="s4">= </span><span class="s1">dlsim</span><span class="s4">(</span><span class="s1">system</span><span class="s4">, </span><span class="s1">u</span><span class="s4">, </span><span class="s1">t</span><span class="s4">=</span><span class="s1">t</span><span class="s4">, </span><span class="s1">x0</span><span class="s4">=</span><span class="s1">x0</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s1">yout </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s1">yout </span><span class="s4">= (</span><span class="s1">one_output</span><span class="s4">[</span><span class="s6">1</span><span class="s4">],)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">yout </span><span class="s4">= </span><span class="s1">yout </span><span class="s4">+ (</span><span class="s1">one_output</span><span class="s4">[</span><span class="s6">1</span><span class="s4">],)</span>

        <span class="s1">tout </span><span class="s4">= </span><span class="s1">one_output</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]</span>

    <span class="s3">return </span><span class="s1">tout</span><span class="s4">, </span><span class="s1">yout</span>


<span class="s3">def </span><span class="s1">dfreqresp</span><span class="s4">(</span><span class="s1">system</span><span class="s4">, </span><span class="s1">w</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">n</span><span class="s4">=</span><span class="s6">10000</span><span class="s4">, </span><span class="s1">whole</span><span class="s4">=</span><span class="s3">False</span><span class="s4">):</span>
    <span class="s0">r&quot;&quot;&quot; 
    Calculate the frequency response of a discrete-time system. 
 
    Parameters 
    ---------- 
    system : an instance of the `dlti` class or a tuple describing the system. 
        The following gives the number of elements in the tuple and 
        the interpretation: 
 
            * 1 (instance of `dlti`) 
            * 2 (numerator, denominator, dt) 
            * 3 (zeros, poles, gain, dt) 
            * 4 (A, B, C, D, dt) 
 
    w : array_like, optional 
        Array of frequencies (in radians/sample). Magnitude and phase data is 
        calculated for every value in this array. If not given a reasonable 
        set will be calculated. 
    n : int, optional 
        Number of frequency points to compute if `w` is not given. The `n` 
        frequencies are logarithmically spaced in an interval chosen to 
        include the influence of the poles and zeros of the system. 
    whole : bool, optional 
        Normally, if 'w' is not given, frequencies are computed from 0 to the 
        Nyquist frequency, pi radians/sample (upper-half of unit-circle). If 
        `whole` is True, compute frequencies from 0 to 2*pi radians/sample. 
 
    Returns 
    ------- 
    w : 1D ndarray 
        Frequency array [radians/sample] 
    H : 1D ndarray 
        Array of complex magnitude values 
 
    Notes 
    ----- 
    If (num, den) is passed in for ``system``, coefficients for both the 
    numerator and denominator should be specified in descending exponent 
    order (e.g. ``z^2 + 3z + 5`` would be represented as ``[1, 3, 5]``). 
 
    .. versionadded:: 0.18.0 
 
    Examples 
    -------- 
    Generating the Nyquist plot of a transfer function 
 
    &gt;&gt;&gt; from scipy import signal 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
 
    Construct the transfer function 
    :math:`H(z) = \frac{1}{z^2 + 2z + 3}` with a sampling time of 0.05 
    seconds: 
 
    &gt;&gt;&gt; sys = signal.TransferFunction([1], [1, 2, 3], dt=0.05) 
 
    &gt;&gt;&gt; w, H = signal.dfreqresp(sys) 
 
    &gt;&gt;&gt; plt.figure() 
    &gt;&gt;&gt; plt.plot(H.real, H.imag, &quot;b&quot;) 
    &gt;&gt;&gt; plt.plot(H.real, -H.imag, &quot;r&quot;) 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span>
    <span class="s3">if not </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">system</span><span class="s4">, </span><span class="s1">dlti</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">system</span><span class="s4">, </span><span class="s1">lti</span><span class="s4">):</span>
            <span class="s3">raise </span><span class="s1">AttributeError</span><span class="s4">(</span><span class="s5">'dfreqresp can only be used with '</span>
                                 <span class="s5">'discrete-time systems.'</span><span class="s4">)</span>

        <span class="s1">system </span><span class="s4">= </span><span class="s1">dlti</span><span class="s4">(*</span><span class="s1">system</span><span class="s4">[:-</span><span class="s6">1</span><span class="s4">], </span><span class="s1">dt</span><span class="s4">=</span><span class="s1">system</span><span class="s4">[-</span><span class="s6">1</span><span class="s4">])</span>

    <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">system</span><span class="s4">, </span><span class="s1">StateSpace</span><span class="s4">):</span>
        <span class="s2"># No SS-&gt;ZPK code exists right now, just SS-&gt;TF-&gt;ZPK</span>
        <span class="s1">system </span><span class="s4">= </span><span class="s1">system</span><span class="s4">.</span><span class="s1">_as_tf</span><span class="s4">()</span>

    <span class="s3">if not </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">system</span><span class="s4">, (</span><span class="s1">TransferFunction</span><span class="s4">, </span><span class="s1">ZerosPolesGain</span><span class="s4">)):</span>
        <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">'Unknown system type'</span><span class="s4">)</span>

    <span class="s3">if </span><span class="s1">system</span><span class="s4">.</span><span class="s1">inputs </span><span class="s4">!= </span><span class="s6">1 </span><span class="s3">or </span><span class="s1">system</span><span class="s4">.</span><span class="s1">outputs </span><span class="s4">!= </span><span class="s6">1</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;dfreqresp requires a SISO (single input, single &quot;</span>
                         <span class="s5">&quot;output) system.&quot;</span><span class="s4">)</span>

    <span class="s3">if </span><span class="s1">w </span><span class="s3">is not None</span><span class="s4">:</span>
        <span class="s1">worN </span><span class="s4">= </span><span class="s1">w</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">worN </span><span class="s4">= </span><span class="s1">n</span>

    <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">system</span><span class="s4">, </span><span class="s1">TransferFunction</span><span class="s4">):</span>
        <span class="s2"># Convert numerator and denominator from polynomials in the variable</span>
        <span class="s2"># 'z' to polynomials in the variable 'z^-1', as freqz expects.</span>
        <span class="s1">num</span><span class="s4">, </span><span class="s1">den </span><span class="s4">= </span><span class="s1">TransferFunction</span><span class="s4">.</span><span class="s1">_z_to_zinv</span><span class="s4">(</span><span class="s1">system</span><span class="s4">.</span><span class="s1">num</span><span class="s4">.</span><span class="s1">ravel</span><span class="s4">(), </span><span class="s1">system</span><span class="s4">.</span><span class="s1">den</span><span class="s4">)</span>
        <span class="s1">w</span><span class="s4">, </span><span class="s1">h </span><span class="s4">= </span><span class="s1">freqz</span><span class="s4">(</span><span class="s1">num</span><span class="s4">, </span><span class="s1">den</span><span class="s4">, </span><span class="s1">worN</span><span class="s4">=</span><span class="s1">worN</span><span class="s4">, </span><span class="s1">whole</span><span class="s4">=</span><span class="s1">whole</span><span class="s4">)</span>

    <span class="s3">elif </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">system</span><span class="s4">, </span><span class="s1">ZerosPolesGain</span><span class="s4">):</span>
        <span class="s1">w</span><span class="s4">, </span><span class="s1">h </span><span class="s4">= </span><span class="s1">freqz_zpk</span><span class="s4">(</span><span class="s1">system</span><span class="s4">.</span><span class="s1">zeros</span><span class="s4">, </span><span class="s1">system</span><span class="s4">.</span><span class="s1">poles</span><span class="s4">, </span><span class="s1">system</span><span class="s4">.</span><span class="s1">gain</span><span class="s4">, </span><span class="s1">worN</span><span class="s4">=</span><span class="s1">worN</span><span class="s4">,</span>
                         <span class="s1">whole</span><span class="s4">=</span><span class="s1">whole</span><span class="s4">)</span>

    <span class="s3">return </span><span class="s1">w</span><span class="s4">, </span><span class="s1">h</span>


<span class="s3">def </span><span class="s1">dbode</span><span class="s4">(</span><span class="s1">system</span><span class="s4">, </span><span class="s1">w</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">n</span><span class="s4">=</span><span class="s6">100</span><span class="s4">):</span>
    <span class="s0">r&quot;&quot;&quot; 
    Calculate Bode magnitude and phase data of a discrete-time system. 
 
    Parameters 
    ---------- 
    system : an instance of the LTI class or a tuple describing the system. 
        The following gives the number of elements in the tuple and 
        the interpretation: 
 
            * 1 (instance of `dlti`) 
            * 2 (num, den, dt) 
            * 3 (zeros, poles, gain, dt) 
            * 4 (A, B, C, D, dt) 
 
    w : array_like, optional 
        Array of frequencies (in radians/sample). Magnitude and phase data is 
        calculated for every value in this array. If not given a reasonable 
        set will be calculated. 
    n : int, optional 
        Number of frequency points to compute if `w` is not given. The `n` 
        frequencies are logarithmically spaced in an interval chosen to 
        include the influence of the poles and zeros of the system. 
 
    Returns 
    ------- 
    w : 1D ndarray 
        Frequency array [rad/time_unit] 
    mag : 1D ndarray 
        Magnitude array [dB] 
    phase : 1D ndarray 
        Phase array [deg] 
 
    Notes 
    ----- 
    If (num, den) is passed in for ``system``, coefficients for both the 
    numerator and denominator should be specified in descending exponent 
    order (e.g. ``z^2 + 3z + 5`` would be represented as ``[1, 3, 5]``). 
 
    .. versionadded:: 0.18.0 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy import signal 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
 
    Construct the transfer function :math:`H(z) = \frac{1}{z^2 + 2z + 3}` with 
    a sampling time of 0.05 seconds: 
 
    &gt;&gt;&gt; sys = signal.TransferFunction([1], [1, 2, 3], dt=0.05) 
 
    Equivalent: sys.bode() 
 
    &gt;&gt;&gt; w, mag, phase = signal.dbode(sys) 
 
    &gt;&gt;&gt; plt.figure() 
    &gt;&gt;&gt; plt.semilogx(w, mag)    # Bode magnitude plot 
    &gt;&gt;&gt; plt.figure() 
    &gt;&gt;&gt; plt.semilogx(w, phase)  # Bode phase plot 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span>
    <span class="s1">w</span><span class="s4">, </span><span class="s1">y </span><span class="s4">= </span><span class="s1">dfreqresp</span><span class="s4">(</span><span class="s1">system</span><span class="s4">, </span><span class="s1">w</span><span class="s4">=</span><span class="s1">w</span><span class="s4">, </span><span class="s1">n</span><span class="s4">=</span><span class="s1">n</span><span class="s4">)</span>

    <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">system</span><span class="s4">, </span><span class="s1">dlti</span><span class="s4">):</span>
        <span class="s1">dt </span><span class="s4">= </span><span class="s1">system</span><span class="s4">.</span><span class="s1">dt</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">dt </span><span class="s4">= </span><span class="s1">system</span><span class="s4">[-</span><span class="s6">1</span><span class="s4">]</span>

    <span class="s1">mag </span><span class="s4">= </span><span class="s6">20.0 </span><span class="s4">* </span><span class="s1">np</span><span class="s4">.</span><span class="s1">log10</span><span class="s4">(</span><span class="s1">abs</span><span class="s4">(</span><span class="s1">y</span><span class="s4">))</span>
    <span class="s1">phase </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">rad2deg</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">unwrap</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">angle</span><span class="s4">(</span><span class="s1">y</span><span class="s4">)))</span>

    <span class="s3">return </span><span class="s1">w </span><span class="s4">/ </span><span class="s1">dt</span><span class="s4">, </span><span class="s1">mag</span><span class="s4">, </span><span class="s1">phase</span>
</pre>
</body>
</html>