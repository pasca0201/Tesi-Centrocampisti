<html>
<head>
<title>_measurements.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #6aab73;}
.s5 { color: #5f826b; font-style: italic;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_measurements.py</font>
</center></td></tr></table>
<pre><span class="s0"># Copyright (C) 2003-2005 Peter J. Verveer</span>
<span class="s0">#</span>
<span class="s0"># Redistribution and use in source and binary forms, with or without</span>
<span class="s0"># modification, are permitted provided that the following conditions</span>
<span class="s0"># are met:</span>
<span class="s0">#</span>
<span class="s0"># 1. Redistributions of source code must retain the above copyright</span>
<span class="s0">#    notice, this list of conditions and the following disclaimer.</span>
<span class="s0">#</span>
<span class="s0"># 2. Redistributions in binary form must reproduce the above</span>
<span class="s0">#    copyright notice, this list of conditions and the following</span>
<span class="s0">#    disclaimer in the documentation and/or other materials provided</span>
<span class="s0">#    with the distribution.</span>
<span class="s0">#</span>
<span class="s0"># 3. The name of the author may not be used to endorse or promote</span>
<span class="s0">#    products derived from this software without specific prior</span>
<span class="s0">#    written permission.</span>
<span class="s0">#</span>
<span class="s0"># THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS</span>
<span class="s0"># OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED</span>
<span class="s0"># WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</span>
<span class="s0"># ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY</span>
<span class="s0"># DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</span>
<span class="s0"># DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE</span>
<span class="s0"># GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</span>
<span class="s0"># INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,</span>
<span class="s0"># WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING</span>
<span class="s0"># NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS</span>
<span class="s0"># SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">from </span><span class="s3">. </span><span class="s2">import </span><span class="s1">_ni_support</span>
<span class="s2">from </span><span class="s3">. </span><span class="s2">import </span><span class="s1">_ni_label</span>
<span class="s2">from </span><span class="s3">. </span><span class="s2">import </span><span class="s1">_nd_image</span>
<span class="s2">from </span><span class="s3">. </span><span class="s2">import </span><span class="s1">_morphology</span>

<span class="s1">__all__ </span><span class="s3">= [</span><span class="s4">'label'</span><span class="s3">, </span><span class="s4">'find_objects'</span><span class="s3">, </span><span class="s4">'labeled_comprehension'</span><span class="s3">, </span><span class="s4">'sum'</span><span class="s3">, </span><span class="s4">'mean'</span><span class="s3">,</span>
           <span class="s4">'variance'</span><span class="s3">, </span><span class="s4">'standard_deviation'</span><span class="s3">, </span><span class="s4">'minimum'</span><span class="s3">, </span><span class="s4">'maximum'</span><span class="s3">, </span><span class="s4">'median'</span><span class="s3">,</span>
           <span class="s4">'minimum_position'</span><span class="s3">, </span><span class="s4">'maximum_position'</span><span class="s3">, </span><span class="s4">'extrema'</span><span class="s3">, </span><span class="s4">'center_of_mass'</span><span class="s3">,</span>
           <span class="s4">'histogram'</span><span class="s3">, </span><span class="s4">'watershed_ift'</span><span class="s3">, </span><span class="s4">'sum_labels'</span><span class="s3">, </span><span class="s4">'value_indices'</span><span class="s3">]</span>


<span class="s2">def </span><span class="s1">label</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">structure</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">output</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Label features in an array. 
 
    Parameters 
    ---------- 
    input : array_like 
        An array-like object to be labeled. Any non-zero values in `input` are 
        counted as features and zero values are considered the background. 
    structure : array_like, optional 
        A structuring element that defines feature connections. 
        `structure` must be centrosymmetric 
        (see Notes). 
        If no structuring element is provided, 
        one is automatically generated with a squared connectivity equal to 
        one.  That is, for a 2-D `input` array, the default structuring element 
        is:: 
 
            [[0,1,0], 
             [1,1,1], 
             [0,1,0]] 
 
    output : (None, data-type, array_like), optional 
        If `output` is a data type, it specifies the type of the resulting 
        labeled feature array. 
        If `output` is an array-like object, then `output` will be updated 
        with the labeled features from this function.  This function can 
        operate in-place, by passing output=input. 
        Note that the output must be able to store the largest label, or this 
        function will raise an Exception. 
 
    Returns 
    ------- 
    label : ndarray or int 
        An integer ndarray where each unique feature in `input` has a unique 
        label in the returned array. 
    num_features : int 
        How many objects were found. 
 
        If `output` is None, this function returns a tuple of 
        (`labeled_array`, `num_features`). 
 
        If `output` is a ndarray, then it will be updated with values in 
        `labeled_array` and only `num_features` will be returned by this 
        function. 
 
    See Also 
    -------- 
    find_objects : generate a list of slices for the labeled features (or 
                   objects); useful for finding features' position or 
                   dimensions 
 
    Notes 
    ----- 
    A centrosymmetric matrix is a matrix that is symmetric about the center. 
    See [1]_ for more information. 
 
    The `structure` matrix must be centrosymmetric to ensure 
    two-way connections. 
    For instance, if the `structure` matrix is not centrosymmetric 
    and is defined as:: 
 
        [[0,1,0], 
         [1,1,0], 
         [0,0,0]] 
 
    and the `input` is:: 
 
        [[1,2], 
         [0,3]] 
 
    then the structure matrix would indicate the 
    entry 2 in the input is connected to 1, 
    but 1 is not connected to 2. 
 
    References 
    ---------- 
    .. [1] James R. Weaver, &quot;Centrosymmetric (cross-symmetric) 
       matrices, their basic properties, eigenvalues, and 
       eigenvectors.&quot; The American Mathematical Monthly 92.10 
       (1985): 711-717. 
 
    Examples 
    -------- 
    Create an image with some features, then label it using the default 
    (cross-shaped) structuring element: 
 
    &gt;&gt;&gt; from scipy.ndimage import label, generate_binary_structure 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; a = np.array([[0,0,1,1,0,0], 
    ...               [0,0,0,1,0,0], 
    ...               [1,1,0,0,1,0], 
    ...               [0,0,0,1,0,0]]) 
    &gt;&gt;&gt; labeled_array, num_features = label(a) 
 
    Each of the 4 features are labeled with a different integer: 
 
    &gt;&gt;&gt; num_features 
    4 
    &gt;&gt;&gt; labeled_array 
    array([[0, 0, 1, 1, 0, 0], 
           [0, 0, 0, 1, 0, 0], 
           [2, 2, 0, 0, 3, 0], 
           [0, 0, 0, 4, 0, 0]]) 
 
    Generate a structuring element that will consider features connected even 
    if they touch diagonally: 
 
    &gt;&gt;&gt; s = generate_binary_structure(2,2) 
 
    or, 
 
    &gt;&gt;&gt; s = [[1,1,1], 
    ...      [1,1,1], 
    ...      [1,1,1]] 
 
    Label the image using the new structuring element: 
 
    &gt;&gt;&gt; labeled_array, num_features = label(a, structure=s) 
 
    Show the 2 labeled features (note that features 1, 3, and 4 from above are 
    now considered a single feature): 
 
    &gt;&gt;&gt; num_features 
    2 
    &gt;&gt;&gt; labeled_array 
    array([[0, 0, 1, 1, 0, 0], 
           [0, 0, 0, 1, 0, 0], 
           [2, 2, 0, 0, 1, 0], 
           [0, 0, 0, 1, 0, 0]]) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">input </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">input</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">iscomplexobj</span><span class="s3">(</span><span class="s1">input</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s4">'Complex type not supported'</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">structure </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">structure </span><span class="s3">= </span><span class="s1">_morphology</span><span class="s3">.</span><span class="s1">generate_binary_structure</span><span class="s3">(</span><span class="s1">input</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">, </span><span class="s6">1</span><span class="s3">)</span>
    <span class="s1">structure </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">structure</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">bool</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">structure</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">!= </span><span class="s1">input</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">RuntimeError</span><span class="s3">(</span><span class="s4">'structure and input must have equal rank'</span><span class="s3">)</span>
    <span class="s2">for </span><span class="s1">ii </span><span class="s2">in </span><span class="s1">structure</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">ii </span><span class="s3">!= </span><span class="s6">3</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'structure dimensions must be equal to 3'</span><span class="s3">)</span>

    <span class="s0"># Use 32 bits if it's large enough for this image.</span>
    <span class="s0"># _ni_label.label() needs two entries for background and</span>
    <span class="s0"># foreground tracking</span>
    <span class="s1">need_64bits </span><span class="s3">= </span><span class="s1">input</span><span class="s3">.</span><span class="s1">size </span><span class="s3">&gt;= (</span><span class="s6">2</span><span class="s3">**</span><span class="s6">31 </span><span class="s3">- </span><span class="s6">2</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">output</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndarray</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">output</span><span class="s3">.</span><span class="s1">shape </span><span class="s3">!= </span><span class="s1">input</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;output shape not correct&quot;</span><span class="s3">)</span>
        <span class="s1">caller_provided_output </span><span class="s3">= </span><span class="s2">True</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">caller_provided_output </span><span class="s3">= </span><span class="s2">False</span>
        <span class="s2">if </span><span class="s1">output </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s1">output </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">input</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">intp </span><span class="s2">if </span><span class="s1">need_64bits </span><span class="s2">else </span><span class="s1">np</span><span class="s3">.</span><span class="s1">int32</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">output </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">input</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">output</span><span class="s3">)</span>

    <span class="s0"># handle scalars, 0-D arrays</span>
    <span class="s2">if </span><span class="s1">input</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s6">0 </span><span class="s2">or </span><span class="s1">input</span><span class="s3">.</span><span class="s1">size </span><span class="s3">== </span><span class="s6">0</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">input</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s6">0</span><span class="s3">:</span>
            <span class="s0"># scalar</span>
            <span class="s1">maxlabel </span><span class="s3">= </span><span class="s6">1 </span><span class="s2">if </span><span class="s3">(</span><span class="s1">input </span><span class="s3">!= </span><span class="s6">0</span><span class="s3">) </span><span class="s2">else </span><span class="s6">0</span>
            <span class="s1">output</span><span class="s3">[...] = </span><span class="s1">maxlabel</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s0"># 0-D</span>
            <span class="s1">maxlabel </span><span class="s3">= </span><span class="s6">0</span>
        <span class="s2">if </span><span class="s1">caller_provided_output</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">maxlabel</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">output</span><span class="s3">, </span><span class="s1">maxlabel</span>

    <span class="s2">try</span><span class="s3">:</span>
        <span class="s1">max_label </span><span class="s3">= </span><span class="s1">_ni_label</span><span class="s3">.</span><span class="s1">_label</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">structure</span><span class="s3">, </span><span class="s1">output</span><span class="s3">)</span>
    <span class="s2">except </span><span class="s1">_ni_label</span><span class="s3">.</span><span class="s1">NeedMoreBits </span><span class="s2">as </span><span class="s1">e</span><span class="s3">:</span>
        <span class="s0"># Make another attempt with enough bits, then try to cast to the</span>
        <span class="s0"># new type.</span>
        <span class="s1">tmp_output </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">input</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">intp </span><span class="s2">if </span><span class="s1">need_64bits </span><span class="s2">else </span><span class="s1">np</span><span class="s3">.</span><span class="s1">int32</span><span class="s3">)</span>
        <span class="s1">max_label </span><span class="s3">= </span><span class="s1">_ni_label</span><span class="s3">.</span><span class="s1">_label</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">structure</span><span class="s3">, </span><span class="s1">tmp_output</span><span class="s3">)</span>
        <span class="s1">output</span><span class="s3">[...] = </span><span class="s1">tmp_output</span><span class="s3">[...]</span>
        <span class="s2">if not </span><span class="s1">np</span><span class="s3">.</span><span class="s1">all</span><span class="s3">(</span><span class="s1">output </span><span class="s3">== </span><span class="s1">tmp_output</span><span class="s3">):</span>
            <span class="s0"># refuse to return bad results</span>
            <span class="s2">raise </span><span class="s1">RuntimeError</span><span class="s3">(</span>
                <span class="s4">&quot;insufficient bit-depth in requested output type&quot;</span>
            <span class="s3">) </span><span class="s2">from </span><span class="s1">e</span>

    <span class="s2">if </span><span class="s1">caller_provided_output</span><span class="s3">:</span>
        <span class="s0"># result was written in-place</span>
        <span class="s2">return </span><span class="s1">max_label</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">output</span><span class="s3">, </span><span class="s1">max_label</span>


<span class="s2">def </span><span class="s1">find_objects</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">max_label</span><span class="s3">=</span><span class="s6">0</span><span class="s3">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Find objects in a labeled array. 
 
    Parameters 
    ---------- 
    input : ndarray of ints 
        Array containing objects defined by different labels. Labels with 
        value 0 are ignored. 
    max_label : int, optional 
        Maximum label to be searched for in `input`. If max_label is not 
        given, the positions of all objects are returned. 
 
    Returns 
    ------- 
    object_slices : list of tuples 
        A list of tuples, with each tuple containing N slices (with N the 
        dimension of the input array). Slices correspond to the minimal 
        parallelepiped that contains the object. If a number is missing, 
        None is returned instead of a slice. The label ``l`` corresponds to 
        the index ``l-1`` in the returned list. 
 
    See Also 
    -------- 
    label, center_of_mass 
 
    Notes 
    ----- 
    This function is very useful for isolating a volume of interest inside 
    a 3-D array, that cannot be &quot;seen through&quot;. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy import ndimage 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; a = np.zeros((6,6), dtype=int) 
    &gt;&gt;&gt; a[2:4, 2:4] = 1 
    &gt;&gt;&gt; a[4, 4] = 1 
    &gt;&gt;&gt; a[:2, :3] = 2 
    &gt;&gt;&gt; a[0, 5] = 3 
    &gt;&gt;&gt; a 
    array([[2, 2, 2, 0, 0, 3], 
           [2, 2, 2, 0, 0, 0], 
           [0, 0, 1, 1, 0, 0], 
           [0, 0, 1, 1, 0, 0], 
           [0, 0, 0, 0, 1, 0], 
           [0, 0, 0, 0, 0, 0]]) 
    &gt;&gt;&gt; ndimage.find_objects(a) 
    [(slice(2, 5, None), slice(2, 5, None)), 
     (slice(0, 2, None), slice(0, 3, None)), 
     (slice(0, 1, None), slice(5, 6, None))] 
    &gt;&gt;&gt; ndimage.find_objects(a, max_label=2) 
    [(slice(2, 5, None), slice(2, 5, None)), (slice(0, 2, None), slice(0, 3, None))] 
    &gt;&gt;&gt; ndimage.find_objects(a == 1, max_label=2) 
    [(slice(2, 5, None), slice(2, 5, None)), None] 
 
    &gt;&gt;&gt; loc = ndimage.find_objects(a)[0] 
    &gt;&gt;&gt; a[loc] 
    array([[1, 1, 0], 
           [1, 1, 0], 
           [0, 0, 1]]) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">input </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">input</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">iscomplexobj</span><span class="s3">(</span><span class="s1">input</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s4">'Complex type not supported'</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">max_label </span><span class="s3">&lt; </span><span class="s6">1</span><span class="s3">:</span>
        <span class="s1">max_label </span><span class="s3">= </span><span class="s1">input</span><span class="s3">.</span><span class="s1">max</span><span class="s3">()</span>

    <span class="s2">return </span><span class="s1">_nd_image</span><span class="s3">.</span><span class="s1">find_objects</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">max_label</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">value_indices</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">, *, </span><span class="s1">ignore_value</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Find indices of each distinct value in given array. 
 
    Parameters 
    ---------- 
    arr : ndarray of ints 
        Array containing integer values. 
    ignore_value : int, optional 
        This value will be ignored in searching the `arr` array. If not 
        given, all values found will be included in output. Default 
        is None. 
 
    Returns 
    ------- 
    indices : dictionary 
        A Python dictionary of array indices for each distinct value. The 
        dictionary is keyed by the distinct values, the entries are array 
        index tuples covering all occurrences of the value within the 
        array. 
 
        This dictionary can occupy significant memory, usually several times 
        the size of the input array. 
 
    See Also 
    -------- 
    label, maximum, median, minimum_position, extrema, sum, mean, variance, 
    standard_deviation, numpy.where, numpy.unique 
 
    Notes 
    ----- 
    For a small array with few distinct values, one might use 
    `numpy.unique()` to find all possible values, and ``(arr == val)`` to 
    locate each value within that array. However, for large arrays, 
    with many distinct values, this can become extremely inefficient, 
    as locating each value would require a new search through the entire 
    array. Using this function, there is essentially one search, with 
    the indices saved for all distinct values. 
 
    This is useful when matching a categorical image (e.g. a segmentation 
    or classification) to an associated image of other data, allowing 
    any per-class statistic(s) to then be calculated. Provides a 
    more flexible alternative to functions like ``scipy.ndimage.mean()`` 
    and ``scipy.ndimage.variance()``. 
 
    Some other closely related functionality, with different strengths and 
    weaknesses, can also be found in ``scipy.stats.binned_statistic()`` and 
    the `scikit-image &lt;https://scikit-image.org/&gt;`_ function 
    ``skimage.measure.regionprops()``. 
 
    Note for IDL users: this provides functionality equivalent to IDL's 
    REVERSE_INDICES option (as per the IDL documentation for the 
    `HISTOGRAM &lt;https://www.l3harrisgeospatial.com/docs/histogram.html&gt;`_ 
    function). 
 
    .. versionadded:: 1.10.0 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import ndimage 
    &gt;&gt;&gt; a = np.zeros((6, 6), dtype=int) 
    &gt;&gt;&gt; a[2:4, 2:4] = 1 
    &gt;&gt;&gt; a[4, 4] = 1 
    &gt;&gt;&gt; a[:2, :3] = 2 
    &gt;&gt;&gt; a[0, 5] = 3 
    &gt;&gt;&gt; a 
    array([[2, 2, 2, 0, 0, 3], 
           [2, 2, 2, 0, 0, 0], 
           [0, 0, 1, 1, 0, 0], 
           [0, 0, 1, 1, 0, 0], 
           [0, 0, 0, 0, 1, 0], 
           [0, 0, 0, 0, 0, 0]]) 
    &gt;&gt;&gt; val_indices = ndimage.value_indices(a) 
 
    The dictionary `val_indices` will have an entry for each distinct 
    value in the input array. 
 
    &gt;&gt;&gt; val_indices.keys() 
    dict_keys([np.int64(0), np.int64(1), np.int64(2), np.int64(3)]) 
 
    The entry for each value is an index tuple, locating the elements 
    with that value. 
 
    &gt;&gt;&gt; ndx1 = val_indices[1] 
    &gt;&gt;&gt; ndx1 
    (array([2, 2, 3, 3, 4]), array([2, 3, 2, 3, 4])) 
 
    This can be used to index into the original array, or any other 
    array with the same shape. 
 
    &gt;&gt;&gt; a[ndx1] 
    array([1, 1, 1, 1, 1]) 
 
    If the zeros were to be ignored, then the resulting dictionary 
    would no longer have an entry for zero. 
 
    &gt;&gt;&gt; val_indices = ndimage.value_indices(a, ignore_value=0) 
    &gt;&gt;&gt; val_indices.keys() 
    dict_keys([np.int64(1), np.int64(2), np.int64(3)]) 
 
    &quot;&quot;&quot;</span>
    <span class="s0"># Cope with ignore_value being None, without too much extra complexity</span>
    <span class="s0"># in the C code. If not None, the value is passed in as a numpy array</span>
    <span class="s0"># with the same dtype as arr.</span>
    <span class="s1">ignore_value_arr </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">((</span><span class="s6">1</span><span class="s3">,), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">arr</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>
    <span class="s1">ignoreIsNone </span><span class="s3">= (</span><span class="s1">ignore_value </span><span class="s2">is None</span><span class="s3">)</span>
    <span class="s2">if not </span><span class="s1">ignoreIsNone</span><span class="s3">:</span>
        <span class="s1">ignore_value_arr</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">ignore_value_arr</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">type</span><span class="s3">(</span><span class="s1">ignore_value</span><span class="s3">)</span>

    <span class="s1">val_indices </span><span class="s3">= </span><span class="s1">_nd_image</span><span class="s3">.</span><span class="s1">value_indices</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">, </span><span class="s1">ignoreIsNone</span><span class="s3">, </span><span class="s1">ignore_value_arr</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">val_indices</span>


<span class="s2">def </span><span class="s1">labeled_comprehension</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">labels</span><span class="s3">, </span><span class="s1">index</span><span class="s3">, </span><span class="s1">func</span><span class="s3">, </span><span class="s1">out_dtype</span><span class="s3">, </span><span class="s1">default</span><span class="s3">,</span>
                          <span class="s1">pass_positions</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Roughly equivalent to [func(input[labels == i]) for i in index]. 
 
    Sequentially applies an arbitrary function (that works on array_like input) 
    to subsets of an N-D image array specified by `labels` and `index`. 
    The option exists to provide the function with positional parameters as the 
    second argument. 
 
    Parameters 
    ---------- 
    input : array_like 
        Data from which to select `labels` to process. 
    labels : array_like or None 
        Labels to objects in `input`. 
        If not None, array must be same shape as `input`. 
        If None, `func` is applied to raveled `input`. 
    index : int, sequence of ints or None 
        Subset of `labels` to which to apply `func`. 
        If a scalar, a single value is returned. 
        If None, `func` is applied to all non-zero values of `labels`. 
    func : callable 
        Python function to apply to `labels` from `input`. 
    out_dtype : dtype 
        Dtype to use for `result`. 
    default : int, float or None 
        Default return value when a element of `index` does not exist 
        in `labels`. 
    pass_positions : bool, optional 
        If True, pass linear indices to `func` as a second argument. 
        Default is False. 
 
    Returns 
    ------- 
    result : ndarray 
        Result of applying `func` to each of `labels` to `input` in `index`. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; a = np.array([[1, 2, 0, 0], 
    ...               [5, 3, 0, 4], 
    ...               [0, 0, 0, 7], 
    ...               [9, 3, 0, 0]]) 
    &gt;&gt;&gt; from scipy import ndimage 
    &gt;&gt;&gt; lbl, nlbl = ndimage.label(a) 
    &gt;&gt;&gt; lbls = np.arange(1, nlbl+1) 
    &gt;&gt;&gt; ndimage.labeled_comprehension(a, lbl, lbls, np.mean, float, 0) 
    array([ 2.75,  5.5 ,  6.  ]) 
 
    Falling back to `default`: 
 
    &gt;&gt;&gt; lbls = np.arange(1, nlbl+2) 
    &gt;&gt;&gt; ndimage.labeled_comprehension(a, lbl, lbls, np.mean, float, -1) 
    array([ 2.75,  5.5 ,  6.  , -1.  ]) 
 
    Passing positions: 
 
    &gt;&gt;&gt; def fn(val, pos): 
    ...     print(&quot;fn says: %s : %s&quot; % (val, pos)) 
    ...     return (val.sum()) if (pos.sum() % 2 == 0) else (-val.sum()) 
    ... 
    &gt;&gt;&gt; ndimage.labeled_comprehension(a, lbl, lbls, fn, float, 0, True) 
    fn says: [1 2 5 3] : [0 1 4 5] 
    fn says: [4 7] : [ 7 11] 
    fn says: [9 3] : [12 13] 
    array([ 11.,  11., -12.,   0.]) 
 
    &quot;&quot;&quot;</span>

    <span class="s1">as_scalar </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isscalar</span><span class="s3">(</span><span class="s1">index</span><span class="s3">)</span>
    <span class="s1">input </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">input</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">pass_positions</span><span class="s3">:</span>
        <span class="s1">positions </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s1">input</span><span class="s3">.</span><span class="s1">size</span><span class="s3">).</span><span class="s1">reshape</span><span class="s3">(</span><span class="s1">input</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">labels </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">index </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;index without defined labels&quot;</span><span class="s3">)</span>
        <span class="s2">if not </span><span class="s1">pass_positions</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">func</span><span class="s3">(</span><span class="s1">input</span><span class="s3">.</span><span class="s1">ravel</span><span class="s3">())</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">func</span><span class="s3">(</span><span class="s1">input</span><span class="s3">.</span><span class="s1">ravel</span><span class="s3">(), </span><span class="s1">positions</span><span class="s3">.</span><span class="s1">ravel</span><span class="s3">())</span>

    <span class="s2">try</span><span class="s3">:</span>
        <span class="s1">input</span><span class="s3">, </span><span class="s1">labels </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">broadcast_arrays</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">labels</span><span class="s3">)</span>
    <span class="s2">except </span><span class="s1">ValueError </span><span class="s2">as </span><span class="s1">e</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;input and labels must have the same shape &quot;</span>
                            <span class="s4">&quot;(excepting dimensions with width 1)&quot;</span><span class="s3">) </span><span class="s2">from </span><span class="s1">e</span>

    <span class="s2">if </span><span class="s1">index </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s2">if not </span><span class="s1">pass_positions</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">func</span><span class="s3">(</span><span class="s1">input</span><span class="s3">[</span><span class="s1">labels </span><span class="s3">&gt; </span><span class="s6">0</span><span class="s3">])</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">func</span><span class="s3">(</span><span class="s1">input</span><span class="s3">[</span><span class="s1">labels </span><span class="s3">&gt; </span><span class="s6">0</span><span class="s3">], </span><span class="s1">positions</span><span class="s3">[</span><span class="s1">labels </span><span class="s3">&gt; </span><span class="s6">0</span><span class="s3">])</span>

    <span class="s1">index </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">atleast_1d</span><span class="s3">(</span><span class="s1">index</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">any</span><span class="s3">(</span><span class="s1">index</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">labels</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">).</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">index</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">) != </span><span class="s1">index</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">f&quot;Cannot convert index values from &lt;</span><span class="s2">{</span><span class="s1">index</span><span class="s3">.</span><span class="s1">dtype</span><span class="s2">}</span><span class="s4">&gt; to &quot;</span>
                         <span class="s4">f&quot;&lt;</span><span class="s2">{</span><span class="s1">labels</span><span class="s3">.</span><span class="s1">dtype</span><span class="s2">}</span><span class="s4">&gt; (labels' type) without loss of precision&quot;</span><span class="s3">)</span>

    <span class="s1">index </span><span class="s3">= </span><span class="s1">index</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">labels</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>

    <span class="s0"># optimization: find min/max in index,</span>
    <span class="s0"># and select those parts of labels, input, and positions</span>
    <span class="s1">lo </span><span class="s3">= </span><span class="s1">index</span><span class="s3">.</span><span class="s1">min</span><span class="s3">()</span>
    <span class="s1">hi </span><span class="s3">= </span><span class="s1">index</span><span class="s3">.</span><span class="s1">max</span><span class="s3">()</span>
    <span class="s1">mask </span><span class="s3">= (</span><span class="s1">labels </span><span class="s3">&gt;= </span><span class="s1">lo</span><span class="s3">) &amp; (</span><span class="s1">labels </span><span class="s3">&lt;= </span><span class="s1">hi</span><span class="s3">)</span>

    <span class="s0"># this also ravels the arrays</span>
    <span class="s1">labels </span><span class="s3">= </span><span class="s1">labels</span><span class="s3">[</span><span class="s1">mask</span><span class="s3">]</span>
    <span class="s1">input </span><span class="s3">= </span><span class="s1">input</span><span class="s3">[</span><span class="s1">mask</span><span class="s3">]</span>
    <span class="s2">if </span><span class="s1">pass_positions</span><span class="s3">:</span>
        <span class="s1">positions </span><span class="s3">= </span><span class="s1">positions</span><span class="s3">[</span><span class="s1">mask</span><span class="s3">]</span>

    <span class="s0"># sort everything by labels</span>
    <span class="s1">label_order </span><span class="s3">= </span><span class="s1">labels</span><span class="s3">.</span><span class="s1">argsort</span><span class="s3">()</span>
    <span class="s1">labels </span><span class="s3">= </span><span class="s1">labels</span><span class="s3">[</span><span class="s1">label_order</span><span class="s3">]</span>
    <span class="s1">input </span><span class="s3">= </span><span class="s1">input</span><span class="s3">[</span><span class="s1">label_order</span><span class="s3">]</span>
    <span class="s2">if </span><span class="s1">pass_positions</span><span class="s3">:</span>
        <span class="s1">positions </span><span class="s3">= </span><span class="s1">positions</span><span class="s3">[</span><span class="s1">label_order</span><span class="s3">]</span>

    <span class="s1">index_order </span><span class="s3">= </span><span class="s1">index</span><span class="s3">.</span><span class="s1">argsort</span><span class="s3">()</span>
    <span class="s1">sorted_index </span><span class="s3">= </span><span class="s1">index</span><span class="s3">[</span><span class="s1">index_order</span><span class="s3">]</span>

    <span class="s2">def </span><span class="s1">do_map</span><span class="s3">(</span><span class="s1">inputs</span><span class="s3">, </span><span class="s1">output</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot;labels must be sorted&quot;&quot;&quot;</span>
        <span class="s1">nidx </span><span class="s3">= </span><span class="s1">sorted_index</span><span class="s3">.</span><span class="s1">size</span>

        <span class="s0"># Find boundaries for each stretch of constant labels</span>
        <span class="s0"># This could be faster, but we already paid N log N to sort labels.</span>
        <span class="s1">lo </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">searchsorted</span><span class="s3">(</span><span class="s1">labels</span><span class="s3">, </span><span class="s1">sorted_index</span><span class="s3">, </span><span class="s1">side</span><span class="s3">=</span><span class="s4">'left'</span><span class="s3">)</span>
        <span class="s1">hi </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">searchsorted</span><span class="s3">(</span><span class="s1">labels</span><span class="s3">, </span><span class="s1">sorted_index</span><span class="s3">, </span><span class="s1">side</span><span class="s3">=</span><span class="s4">'right'</span><span class="s3">)</span>

        <span class="s2">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">l</span><span class="s3">, </span><span class="s1">h </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">range</span><span class="s3">(</span><span class="s1">nidx</span><span class="s3">), </span><span class="s1">lo</span><span class="s3">, </span><span class="s1">hi</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">l </span><span class="s3">== </span><span class="s1">h</span><span class="s3">:</span>
                <span class="s2">continue</span>
            <span class="s1">output</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">func</span><span class="s3">(*[</span><span class="s1">inp</span><span class="s3">[</span><span class="s1">l</span><span class="s3">:</span><span class="s1">h</span><span class="s3">] </span><span class="s2">for </span><span class="s1">inp </span><span class="s2">in </span><span class="s1">inputs</span><span class="s3">])</span>

    <span class="s1">temp </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">index</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">out_dtype</span><span class="s3">)</span>
    <span class="s1">temp</span><span class="s3">[:] = </span><span class="s1">default</span>
    <span class="s2">if not </span><span class="s1">pass_positions</span><span class="s3">:</span>
        <span class="s1">do_map</span><span class="s3">([</span><span class="s1">input</span><span class="s3">], </span><span class="s1">temp</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">do_map</span><span class="s3">([</span><span class="s1">input</span><span class="s3">, </span><span class="s1">positions</span><span class="s3">], </span><span class="s1">temp</span><span class="s3">)</span>

    <span class="s1">output </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">index</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">out_dtype</span><span class="s3">)</span>
    <span class="s1">output</span><span class="s3">[</span><span class="s1">index_order</span><span class="s3">] = </span><span class="s1">temp</span>
    <span class="s2">if </span><span class="s1">as_scalar</span><span class="s3">:</span>
        <span class="s1">output </span><span class="s3">= </span><span class="s1">output</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]</span>

    <span class="s2">return </span><span class="s1">output</span>


<span class="s2">def </span><span class="s1">_safely_castable_to_int</span><span class="s3">(</span><span class="s1">dt</span><span class="s3">):</span>
    <span class="s5">&quot;&quot;&quot;Test whether the NumPy data type `dt` can be safely cast to an int.&quot;&quot;&quot;</span>
    <span class="s1">int_size </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">(</span><span class="s1">int</span><span class="s3">).</span><span class="s1">itemsize</span>
    <span class="s1">safe </span><span class="s3">= ((</span><span class="s1">np</span><span class="s3">.</span><span class="s1">issubdtype</span><span class="s3">(</span><span class="s1">dt</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">signedinteger</span><span class="s3">) </span><span class="s2">and </span><span class="s1">dt</span><span class="s3">.</span><span class="s1">itemsize </span><span class="s3">&lt;= </span><span class="s1">int_size</span><span class="s3">) </span><span class="s2">or</span>
            <span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">issubdtype</span><span class="s3">(</span><span class="s1">dt</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">unsignedinteger</span><span class="s3">) </span><span class="s2">and </span><span class="s1">dt</span><span class="s3">.</span><span class="s1">itemsize </span><span class="s3">&lt; </span><span class="s1">int_size</span><span class="s3">))</span>
    <span class="s2">return </span><span class="s1">safe</span>


<span class="s2">def </span><span class="s1">_stats</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">labels</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">index</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">centered</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s5">&quot;&quot;&quot;Count, sum, and optionally compute (sum - centre)^2 of input by label 
 
    Parameters 
    ---------- 
    input : array_like, N-D 
        The input data to be analyzed. 
    labels : array_like (N-D), optional 
        The labels of the data in `input`. This array must be broadcast 
        compatible with `input`; typically, it is the same shape as `input`. 
        If `labels` is None, all nonzero values in `input` are treated as 
        the single labeled group. 
    index : label or sequence of labels, optional 
        These are the labels of the groups for which the stats are computed. 
        If `index` is None, the stats are computed for the single group where 
        `labels` is greater than 0. 
    centered : bool, optional 
        If True, the centered sum of squares for each labeled group is 
        also returned. Default is False. 
 
    Returns 
    ------- 
    counts : int or ndarray of ints 
        The number of elements in each labeled group. 
    sums : scalar or ndarray of scalars 
        The sums of the values in each labeled group. 
    sums_c : scalar or ndarray of scalars, optional 
        The sums of mean-centered squares of the values in each labeled group. 
        This is only returned if `centered` is True. 
 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">single_group</span><span class="s3">(</span><span class="s1">vals</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">centered</span><span class="s3">:</span>
            <span class="s1">vals_c </span><span class="s3">= </span><span class="s1">vals </span><span class="s3">- </span><span class="s1">vals</span><span class="s3">.</span><span class="s1">mean</span><span class="s3">()</span>
            <span class="s2">return </span><span class="s1">vals</span><span class="s3">.</span><span class="s1">size</span><span class="s3">, </span><span class="s1">vals</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">(), (</span><span class="s1">vals_c </span><span class="s3">* </span><span class="s1">vals_c</span><span class="s3">.</span><span class="s1">conjugate</span><span class="s3">()).</span><span class="s1">sum</span><span class="s3">()</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">vals</span><span class="s3">.</span><span class="s1">size</span><span class="s3">, </span><span class="s1">vals</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">()</span>

    <span class="s2">if </span><span class="s1">labels </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">single_group</span><span class="s3">(</span><span class="s1">input</span><span class="s3">)</span>

    <span class="s0"># ensure input and labels match sizes</span>
    <span class="s1">input</span><span class="s3">, </span><span class="s1">labels </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">broadcast_arrays</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">labels</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">index </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">single_group</span><span class="s3">(</span><span class="s1">input</span><span class="s3">[</span><span class="s1">labels </span><span class="s3">&gt; </span><span class="s6">0</span><span class="s3">])</span>

    <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isscalar</span><span class="s3">(</span><span class="s1">index</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">single_group</span><span class="s3">(</span><span class="s1">input</span><span class="s3">[</span><span class="s1">labels </span><span class="s3">== </span><span class="s1">index</span><span class="s3">])</span>

    <span class="s2">def </span><span class="s1">_sum_centered</span><span class="s3">(</span><span class="s1">labels</span><span class="s3">):</span>
        <span class="s0"># `labels` is expected to be an ndarray with the same shape as `input`.</span>
        <span class="s0"># It must contain the label indices (which are not necessarily the labels</span>
        <span class="s0"># themselves).</span>
        <span class="s1">means </span><span class="s3">= </span><span class="s1">sums </span><span class="s3">/ </span><span class="s1">counts</span>
        <span class="s1">centered_input </span><span class="s3">= </span><span class="s1">input </span><span class="s3">- </span><span class="s1">means</span><span class="s3">[</span><span class="s1">labels</span><span class="s3">]</span>
        <span class="s0"># bincount expects 1-D inputs, so we ravel the arguments.</span>
        <span class="s1">bc </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">bincount</span><span class="s3">(</span><span class="s1">labels</span><span class="s3">.</span><span class="s1">ravel</span><span class="s3">(),</span>
                              <span class="s1">weights</span><span class="s3">=(</span><span class="s1">centered_input </span><span class="s3">*</span>
                                       <span class="s1">centered_input</span><span class="s3">.</span><span class="s1">conjugate</span><span class="s3">()).</span><span class="s1">ravel</span><span class="s3">())</span>
        <span class="s2">return </span><span class="s1">bc</span>

    <span class="s0"># Remap labels to unique integers if necessary, or if the largest</span>
    <span class="s0"># label is larger than the number of values.</span>

    <span class="s2">if </span><span class="s3">(</span><span class="s2">not </span><span class="s1">_safely_castable_to_int</span><span class="s3">(</span><span class="s1">labels</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">) </span><span class="s2">or</span>
            <span class="s1">labels</span><span class="s3">.</span><span class="s1">min</span><span class="s3">() &lt; </span><span class="s6">0 </span><span class="s2">or </span><span class="s1">labels</span><span class="s3">.</span><span class="s1">max</span><span class="s3">() &gt; </span><span class="s1">labels</span><span class="s3">.</span><span class="s1">size</span><span class="s3">):</span>
        <span class="s0"># Use np.unique to generate the label indices.  `new_labels` will</span>
        <span class="s0"># be 1-D, but it should be interpreted as the flattened N-D array of</span>
        <span class="s0"># label indices.</span>
        <span class="s1">unique_labels</span><span class="s3">, </span><span class="s1">new_labels </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">unique</span><span class="s3">(</span><span class="s1">labels</span><span class="s3">, </span><span class="s1">return_inverse</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
        <span class="s1">new_labels </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">(</span><span class="s1">new_labels</span><span class="s3">, (-</span><span class="s6">1</span><span class="s3">,))  </span><span class="s0"># flatten, since it may be &gt;1-D</span>
        <span class="s1">counts </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">bincount</span><span class="s3">(</span><span class="s1">new_labels</span><span class="s3">)</span>
        <span class="s1">sums </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">bincount</span><span class="s3">(</span><span class="s1">new_labels</span><span class="s3">, </span><span class="s1">weights</span><span class="s3">=</span><span class="s1">input</span><span class="s3">.</span><span class="s1">ravel</span><span class="s3">())</span>
        <span class="s2">if </span><span class="s1">centered</span><span class="s3">:</span>
            <span class="s0"># Compute the sum of the mean-centered squares.</span>
            <span class="s0"># We must reshape new_labels to the N-D shape of `input` before</span>
            <span class="s0"># passing it _sum_centered.</span>
            <span class="s1">sums_c </span><span class="s3">= </span><span class="s1">_sum_centered</span><span class="s3">(</span><span class="s1">new_labels</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">(</span><span class="s1">labels</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">))</span>
        <span class="s1">idxs </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">searchsorted</span><span class="s3">(</span><span class="s1">unique_labels</span><span class="s3">, </span><span class="s1">index</span><span class="s3">)</span>
        <span class="s0"># make all of idxs valid</span>
        <span class="s1">idxs</span><span class="s3">[</span><span class="s1">idxs </span><span class="s3">&gt;= </span><span class="s1">unique_labels</span><span class="s3">.</span><span class="s1">size</span><span class="s3">] = </span><span class="s6">0</span>
        <span class="s1">found </span><span class="s3">= (</span><span class="s1">unique_labels</span><span class="s3">[</span><span class="s1">idxs</span><span class="s3">] == </span><span class="s1">index</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s0"># labels are an integer type allowed by bincount, and there aren't too</span>
        <span class="s0"># many, so call bincount directly.</span>
        <span class="s1">counts </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">bincount</span><span class="s3">(</span><span class="s1">labels</span><span class="s3">.</span><span class="s1">ravel</span><span class="s3">())</span>
        <span class="s1">sums </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">bincount</span><span class="s3">(</span><span class="s1">labels</span><span class="s3">.</span><span class="s1">ravel</span><span class="s3">(), </span><span class="s1">weights</span><span class="s3">=</span><span class="s1">input</span><span class="s3">.</span><span class="s1">ravel</span><span class="s3">())</span>
        <span class="s2">if </span><span class="s1">centered</span><span class="s3">:</span>
            <span class="s1">sums_c </span><span class="s3">= </span><span class="s1">_sum_centered</span><span class="s3">(</span><span class="s1">labels</span><span class="s3">)</span>
        <span class="s0"># make sure all index values are valid</span>
        <span class="s1">idxs </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asanyarray</span><span class="s3">(</span><span class="s1">index</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">int_</span><span class="s3">).</span><span class="s1">copy</span><span class="s3">()</span>
        <span class="s1">found </span><span class="s3">= (</span><span class="s1">idxs </span><span class="s3">&gt;= </span><span class="s6">0</span><span class="s3">) &amp; (</span><span class="s1">idxs </span><span class="s3">&lt; </span><span class="s1">counts</span><span class="s3">.</span><span class="s1">size</span><span class="s3">)</span>
        <span class="s1">idxs</span><span class="s3">[~</span><span class="s1">found</span><span class="s3">] = </span><span class="s6">0</span>

    <span class="s1">counts </span><span class="s3">= </span><span class="s1">counts</span><span class="s3">[</span><span class="s1">idxs</span><span class="s3">]</span>
    <span class="s1">counts</span><span class="s3">[~</span><span class="s1">found</span><span class="s3">] = </span><span class="s6">0</span>
    <span class="s1">sums </span><span class="s3">= </span><span class="s1">sums</span><span class="s3">[</span><span class="s1">idxs</span><span class="s3">]</span>
    <span class="s1">sums</span><span class="s3">[~</span><span class="s1">found</span><span class="s3">] = </span><span class="s6">0</span>

    <span class="s2">if not </span><span class="s1">centered</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s3">(</span><span class="s1">counts</span><span class="s3">, </span><span class="s1">sums</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">sums_c </span><span class="s3">= </span><span class="s1">sums_c</span><span class="s3">[</span><span class="s1">idxs</span><span class="s3">]</span>
        <span class="s1">sums_c</span><span class="s3">[~</span><span class="s1">found</span><span class="s3">] = </span><span class="s6">0</span>
        <span class="s2">return </span><span class="s3">(</span><span class="s1">counts</span><span class="s3">, </span><span class="s1">sums</span><span class="s3">, </span><span class="s1">sums_c</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">sum</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">labels</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">index</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Calculate the sum of the values of the array. 
 
    Notes 
    ----- 
    This is an alias for `ndimage.sum_labels` kept for backwards compatibility 
    reasons, for new code please prefer `sum_labels`.  See the `sum_labels` 
    docstring for more details. 
 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">sum_labels</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">labels</span><span class="s3">, </span><span class="s1">index</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">sum_labels</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">labels</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">index</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Calculate the sum of the values of the array. 
 
    Parameters 
    ---------- 
    input : array_like 
        Values of `input` inside the regions defined by `labels` 
        are summed together. 
    labels : array_like of ints, optional 
        Assign labels to the values of the array. Has to have the same shape as 
        `input`. 
    index : array_like, optional 
        A single label number or a sequence of label numbers of 
        the objects to be measured. 
 
    Returns 
    ------- 
    sum : ndarray or scalar 
        An array of the sums of values of `input` inside the regions defined 
        by `labels` with the same shape as `index`. If 'index' is None or scalar, 
        a scalar is returned. 
 
    See Also 
    -------- 
    mean, median 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy import ndimage 
    &gt;&gt;&gt; input =  [0,1,2,3] 
    &gt;&gt;&gt; labels = [1,1,2,2] 
    &gt;&gt;&gt; ndimage.sum_labels(input, labels, index=[1,2]) 
    [1.0, 5.0] 
    &gt;&gt;&gt; ndimage.sum_labels(input, labels, index=1) 
    1 
    &gt;&gt;&gt; ndimage.sum_labels(input, labels) 
    6 
 
 
    &quot;&quot;&quot;</span>
    <span class="s1">count</span><span class="s3">, </span><span class="s1">sum </span><span class="s3">= </span><span class="s1">_stats</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">labels</span><span class="s3">, </span><span class="s1">index</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">sum</span>


<span class="s2">def </span><span class="s1">mean</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">labels</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">index</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Calculate the mean of the values of an array at labels. 
 
    Parameters 
    ---------- 
    input : array_like 
        Array on which to compute the mean of elements over distinct 
        regions. 
    labels : array_like, optional 
        Array of labels of same shape, or broadcastable to the same shape as 
        `input`. All elements sharing the same label form one region over 
        which the mean of the elements is computed. 
    index : int or sequence of ints, optional 
        Labels of the objects over which the mean is to be computed. 
        Default is None, in which case the mean for all values where label is 
        greater than 0 is calculated. 
 
    Returns 
    ------- 
    out : list 
        Sequence of same length as `index`, with the mean of the different 
        regions labeled by the labels in `index`. 
 
    See Also 
    -------- 
    variance, standard_deviation, minimum, maximum, sum, label 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy import ndimage 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; a = np.arange(25).reshape((5,5)) 
    &gt;&gt;&gt; labels = np.zeros_like(a) 
    &gt;&gt;&gt; labels[3:5,3:5] = 1 
    &gt;&gt;&gt; index = np.unique(labels) 
    &gt;&gt;&gt; labels 
    array([[0, 0, 0, 0, 0], 
           [0, 0, 0, 0, 0], 
           [0, 0, 0, 0, 0], 
           [0, 0, 0, 1, 1], 
           [0, 0, 0, 1, 1]]) 
    &gt;&gt;&gt; index 
    array([0, 1]) 
    &gt;&gt;&gt; ndimage.mean(a, labels=labels, index=index) 
    [10.285714285714286, 21.0] 
 
    &quot;&quot;&quot;</span>

    <span class="s1">count</span><span class="s3">, </span><span class="s1">sum </span><span class="s3">= </span><span class="s1">_stats</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">labels</span><span class="s3">, </span><span class="s1">index</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">sum </span><span class="s3">/ </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asanyarray</span><span class="s3">(</span><span class="s1">count</span><span class="s3">).</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">variance</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">labels</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">index</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Calculate the variance of the values of an N-D image array, optionally at 
    specified sub-regions. 
 
    Parameters 
    ---------- 
    input : array_like 
        Nd-image data to process. 
    labels : array_like, optional 
        Labels defining sub-regions in `input`. 
        If not None, must be same shape as `input`. 
    index : int or sequence of ints, optional 
        `labels` to include in output.  If None (default), all values where 
        `labels` is non-zero are used. 
 
    Returns 
    ------- 
    variance : float or ndarray 
        Values of variance, for each sub-region if `labels` and `index` are 
        specified. 
 
    See Also 
    -------- 
    label, standard_deviation, maximum, minimum, extrema 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; a = np.array([[1, 2, 0, 0], 
    ...               [5, 3, 0, 4], 
    ...               [0, 0, 0, 7], 
    ...               [9, 3, 0, 0]]) 
    &gt;&gt;&gt; from scipy import ndimage 
    &gt;&gt;&gt; ndimage.variance(a) 
    7.609375 
 
    Features to process can be specified using `labels` and `index`: 
 
    &gt;&gt;&gt; lbl, nlbl = ndimage.label(a) 
    &gt;&gt;&gt; ndimage.variance(a, lbl, index=np.arange(1, nlbl+1)) 
    array([ 2.1875,  2.25  ,  9.    ]) 
 
    If no index is given, all non-zero `labels` are processed: 
 
    &gt;&gt;&gt; ndimage.variance(a, lbl) 
    6.1875 
 
    &quot;&quot;&quot;</span>
    <span class="s1">count</span><span class="s3">, </span><span class="s1">sum</span><span class="s3">, </span><span class="s1">sum_c_sq </span><span class="s3">= </span><span class="s1">_stats</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">labels</span><span class="s3">, </span><span class="s1">index</span><span class="s3">, </span><span class="s1">centered</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">sum_c_sq </span><span class="s3">/ </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asanyarray</span><span class="s3">(</span><span class="s1">count</span><span class="s3">).</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">float</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">standard_deviation</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">labels</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">index</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Calculate the standard deviation of the values of an N-D image array, 
    optionally at specified sub-regions. 
 
    Parameters 
    ---------- 
    input : array_like 
        N-D image data to process. 
    labels : array_like, optional 
        Labels to identify sub-regions in `input`. 
        If not None, must be same shape as `input`. 
    index : int or sequence of ints, optional 
        `labels` to include in output. If None (default), all values where 
        `labels` is non-zero are used. 
 
    Returns 
    ------- 
    standard_deviation : float or ndarray 
        Values of standard deviation, for each sub-region if `labels` and 
        `index` are specified. 
 
    See Also 
    -------- 
    label, variance, maximum, minimum, extrema 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; a = np.array([[1, 2, 0, 0], 
    ...               [5, 3, 0, 4], 
    ...               [0, 0, 0, 7], 
    ...               [9, 3, 0, 0]]) 
    &gt;&gt;&gt; from scipy import ndimage 
    &gt;&gt;&gt; ndimage.standard_deviation(a) 
    2.7585095613392387 
 
    Features to process can be specified using `labels` and `index`: 
 
    &gt;&gt;&gt; lbl, nlbl = ndimage.label(a) 
    &gt;&gt;&gt; ndimage.standard_deviation(a, lbl, index=np.arange(1, nlbl+1)) 
    array([ 1.479,  1.5  ,  3.   ]) 
 
    If no index is given, non-zero `labels` are processed: 
 
    &gt;&gt;&gt; ndimage.standard_deviation(a, lbl) 
    2.4874685927665499 
 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s1">variance</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">labels</span><span class="s3">, </span><span class="s1">index</span><span class="s3">))</span>


<span class="s2">def </span><span class="s1">_select</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">labels</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">index</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">find_min</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">find_max</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
            <span class="s1">find_min_positions</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">find_max_positions</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
            <span class="s1">find_median</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s5">&quot;&quot;&quot;Returns min, max, or both, plus their positions (if requested), and 
    median.&quot;&quot;&quot;</span>

    <span class="s1">input </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asanyarray</span><span class="s3">(</span><span class="s1">input</span><span class="s3">)</span>

    <span class="s1">find_positions </span><span class="s3">= </span><span class="s1">find_min_positions </span><span class="s2">or </span><span class="s1">find_max_positions</span>
    <span class="s1">positions </span><span class="s3">= </span><span class="s2">None</span>
    <span class="s2">if </span><span class="s1">find_positions</span><span class="s3">:</span>
        <span class="s1">positions </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s1">input</span><span class="s3">.</span><span class="s1">size</span><span class="s3">).</span><span class="s1">reshape</span><span class="s3">(</span><span class="s1">input</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">single_group</span><span class="s3">(</span><span class="s1">vals</span><span class="s3">, </span><span class="s1">positions</span><span class="s3">):</span>
        <span class="s1">result </span><span class="s3">= []</span>
        <span class="s2">if </span><span class="s1">find_min</span><span class="s3">:</span>
            <span class="s1">result </span><span class="s3">+= [</span><span class="s1">vals</span><span class="s3">.</span><span class="s1">min</span><span class="s3">()]</span>
        <span class="s2">if </span><span class="s1">find_min_positions</span><span class="s3">:</span>
            <span class="s1">result </span><span class="s3">+= [</span><span class="s1">positions</span><span class="s3">[</span><span class="s1">vals </span><span class="s3">== </span><span class="s1">vals</span><span class="s3">.</span><span class="s1">min</span><span class="s3">()][</span><span class="s6">0</span><span class="s3">]]</span>
        <span class="s2">if </span><span class="s1">find_max</span><span class="s3">:</span>
            <span class="s1">result </span><span class="s3">+= [</span><span class="s1">vals</span><span class="s3">.</span><span class="s1">max</span><span class="s3">()]</span>
        <span class="s2">if </span><span class="s1">find_max_positions</span><span class="s3">:</span>
            <span class="s1">result </span><span class="s3">+= [</span><span class="s1">positions</span><span class="s3">[</span><span class="s1">vals </span><span class="s3">== </span><span class="s1">vals</span><span class="s3">.</span><span class="s1">max</span><span class="s3">()][</span><span class="s6">0</span><span class="s3">]]</span>
        <span class="s2">if </span><span class="s1">find_median</span><span class="s3">:</span>
            <span class="s1">result </span><span class="s3">+= [</span><span class="s1">np</span><span class="s3">.</span><span class="s1">median</span><span class="s3">(</span><span class="s1">vals</span><span class="s3">)]</span>
        <span class="s2">return </span><span class="s1">result</span>

    <span class="s2">if </span><span class="s1">labels </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">single_group</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">positions</span><span class="s3">)</span>

    <span class="s0"># ensure input and labels match sizes</span>
    <span class="s1">input</span><span class="s3">, </span><span class="s1">labels </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">broadcast_arrays</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">labels</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">index </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">mask </span><span class="s3">= (</span><span class="s1">labels </span><span class="s3">&gt; </span><span class="s6">0</span><span class="s3">)</span>
        <span class="s1">masked_positions </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s2">if </span><span class="s1">find_positions</span><span class="s3">:</span>
            <span class="s1">masked_positions </span><span class="s3">= </span><span class="s1">positions</span><span class="s3">[</span><span class="s1">mask</span><span class="s3">]</span>
        <span class="s2">return </span><span class="s1">single_group</span><span class="s3">(</span><span class="s1">input</span><span class="s3">[</span><span class="s1">mask</span><span class="s3">], </span><span class="s1">masked_positions</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isscalar</span><span class="s3">(</span><span class="s1">index</span><span class="s3">):</span>
        <span class="s1">mask </span><span class="s3">= (</span><span class="s1">labels </span><span class="s3">== </span><span class="s1">index</span><span class="s3">)</span>
        <span class="s1">masked_positions </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s2">if </span><span class="s1">find_positions</span><span class="s3">:</span>
            <span class="s1">masked_positions </span><span class="s3">= </span><span class="s1">positions</span><span class="s3">[</span><span class="s1">mask</span><span class="s3">]</span>
        <span class="s2">return </span><span class="s1">single_group</span><span class="s3">(</span><span class="s1">input</span><span class="s3">[</span><span class="s1">mask</span><span class="s3">], </span><span class="s1">masked_positions</span><span class="s3">)</span>

    <span class="s0"># remap labels to unique integers if necessary, or if the largest</span>
    <span class="s0"># label is larger than the number of values.</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s2">not </span><span class="s1">_safely_castable_to_int</span><span class="s3">(</span><span class="s1">labels</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">) </span><span class="s2">or</span>
            <span class="s1">labels</span><span class="s3">.</span><span class="s1">min</span><span class="s3">() &lt; </span><span class="s6">0 </span><span class="s2">or </span><span class="s1">labels</span><span class="s3">.</span><span class="s1">max</span><span class="s3">() &gt; </span><span class="s1">labels</span><span class="s3">.</span><span class="s1">size</span><span class="s3">):</span>
        <span class="s0"># remap labels, and indexes</span>
        <span class="s1">unique_labels</span><span class="s3">, </span><span class="s1">labels </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">unique</span><span class="s3">(</span><span class="s1">labels</span><span class="s3">, </span><span class="s1">return_inverse</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
        <span class="s1">idxs </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">searchsorted</span><span class="s3">(</span><span class="s1">unique_labels</span><span class="s3">, </span><span class="s1">index</span><span class="s3">)</span>

        <span class="s0"># make all of idxs valid</span>
        <span class="s1">idxs</span><span class="s3">[</span><span class="s1">idxs </span><span class="s3">&gt;= </span><span class="s1">unique_labels</span><span class="s3">.</span><span class="s1">size</span><span class="s3">] = </span><span class="s6">0</span>
        <span class="s1">found </span><span class="s3">= (</span><span class="s1">unique_labels</span><span class="s3">[</span><span class="s1">idxs</span><span class="s3">] == </span><span class="s1">index</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s0"># labels are an integer type, and there aren't too many</span>
        <span class="s1">idxs </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asanyarray</span><span class="s3">(</span><span class="s1">index</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">int_</span><span class="s3">).</span><span class="s1">copy</span><span class="s3">()</span>
        <span class="s1">found </span><span class="s3">= (</span><span class="s1">idxs </span><span class="s3">&gt;= </span><span class="s6">0</span><span class="s3">) &amp; (</span><span class="s1">idxs </span><span class="s3">&lt;= </span><span class="s1">labels</span><span class="s3">.</span><span class="s1">max</span><span class="s3">())</span>

    <span class="s1">idxs</span><span class="s3">[~ </span><span class="s1">found</span><span class="s3">] = </span><span class="s1">labels</span><span class="s3">.</span><span class="s1">max</span><span class="s3">() + </span><span class="s6">1</span>

    <span class="s2">if </span><span class="s1">find_median</span><span class="s3">:</span>
        <span class="s1">order </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">lexsort</span><span class="s3">((</span><span class="s1">input</span><span class="s3">.</span><span class="s1">ravel</span><span class="s3">(), </span><span class="s1">labels</span><span class="s3">.</span><span class="s1">ravel</span><span class="s3">()))</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">order </span><span class="s3">= </span><span class="s1">input</span><span class="s3">.</span><span class="s1">ravel</span><span class="s3">().</span><span class="s1">argsort</span><span class="s3">()</span>
    <span class="s1">input </span><span class="s3">= </span><span class="s1">input</span><span class="s3">.</span><span class="s1">ravel</span><span class="s3">()[</span><span class="s1">order</span><span class="s3">]</span>
    <span class="s1">labels </span><span class="s3">= </span><span class="s1">labels</span><span class="s3">.</span><span class="s1">ravel</span><span class="s3">()[</span><span class="s1">order</span><span class="s3">]</span>
    <span class="s2">if </span><span class="s1">find_positions</span><span class="s3">:</span>
        <span class="s1">positions </span><span class="s3">= </span><span class="s1">positions</span><span class="s3">.</span><span class="s1">ravel</span><span class="s3">()[</span><span class="s1">order</span><span class="s3">]</span>

    <span class="s1">result </span><span class="s3">= []</span>
    <span class="s2">if </span><span class="s1">find_min</span><span class="s3">:</span>
        <span class="s1">mins </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">labels</span><span class="s3">.</span><span class="s1">max</span><span class="s3">() + </span><span class="s6">2</span><span class="s3">, </span><span class="s1">input</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>
        <span class="s1">mins</span><span class="s3">[</span><span class="s1">labels</span><span class="s3">[::-</span><span class="s6">1</span><span class="s3">]] = </span><span class="s1">input</span><span class="s3">[::-</span><span class="s6">1</span><span class="s3">]</span>
        <span class="s1">result </span><span class="s3">+= [</span><span class="s1">mins</span><span class="s3">[</span><span class="s1">idxs</span><span class="s3">]]</span>
    <span class="s2">if </span><span class="s1">find_min_positions</span><span class="s3">:</span>
        <span class="s1">minpos </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">labels</span><span class="s3">.</span><span class="s1">max</span><span class="s3">() + </span><span class="s6">2</span><span class="s3">, </span><span class="s1">int</span><span class="s3">)</span>
        <span class="s1">minpos</span><span class="s3">[</span><span class="s1">labels</span><span class="s3">[::-</span><span class="s6">1</span><span class="s3">]] = </span><span class="s1">positions</span><span class="s3">[::-</span><span class="s6">1</span><span class="s3">]</span>
        <span class="s1">result </span><span class="s3">+= [</span><span class="s1">minpos</span><span class="s3">[</span><span class="s1">idxs</span><span class="s3">]]</span>
    <span class="s2">if </span><span class="s1">find_max</span><span class="s3">:</span>
        <span class="s1">maxs </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">labels</span><span class="s3">.</span><span class="s1">max</span><span class="s3">() + </span><span class="s6">2</span><span class="s3">, </span><span class="s1">input</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>
        <span class="s1">maxs</span><span class="s3">[</span><span class="s1">labels</span><span class="s3">] = </span><span class="s1">input</span>
        <span class="s1">result </span><span class="s3">+= [</span><span class="s1">maxs</span><span class="s3">[</span><span class="s1">idxs</span><span class="s3">]]</span>
    <span class="s2">if </span><span class="s1">find_max_positions</span><span class="s3">:</span>
        <span class="s1">maxpos </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">labels</span><span class="s3">.</span><span class="s1">max</span><span class="s3">() + </span><span class="s6">2</span><span class="s3">, </span><span class="s1">int</span><span class="s3">)</span>
        <span class="s1">maxpos</span><span class="s3">[</span><span class="s1">labels</span><span class="s3">] = </span><span class="s1">positions</span>
        <span class="s1">result </span><span class="s3">+= [</span><span class="s1">maxpos</span><span class="s3">[</span><span class="s1">idxs</span><span class="s3">]]</span>
    <span class="s2">if </span><span class="s1">find_median</span><span class="s3">:</span>
        <span class="s1">locs </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">labels</span><span class="s3">))</span>
        <span class="s1">lo </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">labels</span><span class="s3">.</span><span class="s1">max</span><span class="s3">() + </span><span class="s6">2</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">int_</span><span class="s3">)</span>
        <span class="s1">lo</span><span class="s3">[</span><span class="s1">labels</span><span class="s3">[::-</span><span class="s6">1</span><span class="s3">]] = </span><span class="s1">locs</span><span class="s3">[::-</span><span class="s6">1</span><span class="s3">]</span>
        <span class="s1">hi </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">labels</span><span class="s3">.</span><span class="s1">max</span><span class="s3">() + </span><span class="s6">2</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">int_</span><span class="s3">)</span>
        <span class="s1">hi</span><span class="s3">[</span><span class="s1">labels</span><span class="s3">] = </span><span class="s1">locs</span>
        <span class="s1">lo </span><span class="s3">= </span><span class="s1">lo</span><span class="s3">[</span><span class="s1">idxs</span><span class="s3">]</span>
        <span class="s1">hi </span><span class="s3">= </span><span class="s1">hi</span><span class="s3">[</span><span class="s1">idxs</span><span class="s3">]</span>
        <span class="s0"># lo is an index to the lowest value in input for each label,</span>
        <span class="s0"># hi is an index to the largest value.</span>
        <span class="s0"># move them to be either the same ((hi - lo) % 2 == 0) or next</span>
        <span class="s0"># to each other ((hi - lo) % 2 == 1), then average.</span>
        <span class="s1">step </span><span class="s3">= (</span><span class="s1">hi </span><span class="s3">- </span><span class="s1">lo</span><span class="s3">) // </span><span class="s6">2</span>
        <span class="s1">lo </span><span class="s3">+= </span><span class="s1">step</span>
        <span class="s1">hi </span><span class="s3">-= </span><span class="s1">step</span>
        <span class="s2">if </span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">issubdtype</span><span class="s3">(</span><span class="s1">input</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">integer</span><span class="s3">)</span>
                <span class="s2">or </span><span class="s1">np</span><span class="s3">.</span><span class="s1">issubdtype</span><span class="s3">(</span><span class="s1">input</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">bool_</span><span class="s3">)):</span>
            <span class="s0"># avoid integer overflow or boolean addition (gh-12836)</span>
            <span class="s1">result </span><span class="s3">+= [(</span><span class="s1">input</span><span class="s3">[</span><span class="s1">lo</span><span class="s3">].</span><span class="s1">astype</span><span class="s3">(</span><span class="s4">'d'</span><span class="s3">) + </span><span class="s1">input</span><span class="s3">[</span><span class="s1">hi</span><span class="s3">].</span><span class="s1">astype</span><span class="s3">(</span><span class="s4">'d'</span><span class="s3">)) / </span><span class="s6">2.0</span><span class="s3">]</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">result </span><span class="s3">+= [(</span><span class="s1">input</span><span class="s3">[</span><span class="s1">lo</span><span class="s3">] + </span><span class="s1">input</span><span class="s3">[</span><span class="s1">hi</span><span class="s3">]) / </span><span class="s6">2.0</span><span class="s3">]</span>

    <span class="s2">return </span><span class="s1">result</span>


<span class="s2">def </span><span class="s1">minimum</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">labels</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">index</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Calculate the minimum of the values of an array over labeled regions. 
 
    Parameters 
    ---------- 
    input : array_like 
        Array_like of values. For each region specified by `labels`, the 
        minimal values of `input` over the region is computed. 
    labels : array_like, optional 
        An array_like of integers marking different regions over which the 
        minimum value of `input` is to be computed. `labels` must have the 
        same shape as `input`. If `labels` is not specified, the minimum 
        over the whole array is returned. 
    index : array_like, optional 
        A list of region labels that are taken into account for computing the 
        minima. If index is None, the minimum over all elements where `labels` 
        is non-zero is returned. 
 
    Returns 
    ------- 
    minimum : float or list of floats 
        List of minima of `input` over the regions determined by `labels` and 
        whose index is in `index`. If `index` or `labels` are not specified, a 
        float is returned: the minimal value of `input` if `labels` is None, 
        and the minimal value of elements where `labels` is greater than zero 
        if `index` is None. 
 
    See Also 
    -------- 
    label, maximum, median, minimum_position, extrema, sum, mean, variance, 
    standard_deviation 
 
    Notes 
    ----- 
    The function returns a Python list and not a NumPy array, use 
    `np.array` to convert the list to an array. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy import ndimage 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; a = np.array([[1, 2, 0, 0], 
    ...               [5, 3, 0, 4], 
    ...               [0, 0, 0, 7], 
    ...               [9, 3, 0, 0]]) 
    &gt;&gt;&gt; labels, labels_nb = ndimage.label(a) 
    &gt;&gt;&gt; labels 
    array([[1, 1, 0, 0], 
           [1, 1, 0, 2], 
           [0, 0, 0, 2], 
           [3, 3, 0, 0]]) 
    &gt;&gt;&gt; ndimage.minimum(a, labels=labels, index=np.arange(1, labels_nb + 1)) 
    [1.0, 4.0, 3.0] 
    &gt;&gt;&gt; ndimage.minimum(a) 
    0.0 
    &gt;&gt;&gt; ndimage.minimum(a, labels=labels) 
    1.0 
 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_select</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">labels</span><span class="s3">, </span><span class="s1">index</span><span class="s3">, </span><span class="s1">find_min</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)[</span><span class="s6">0</span><span class="s3">]</span>


<span class="s2">def </span><span class="s1">maximum</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">labels</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">index</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Calculate the maximum of the values of an array over labeled regions. 
 
    Parameters 
    ---------- 
    input : array_like 
        Array_like of values. For each region specified by `labels`, the 
        maximal values of `input` over the region is computed. 
    labels : array_like, optional 
        An array of integers marking different regions over which the 
        maximum value of `input` is to be computed. `labels` must have the 
        same shape as `input`. If `labels` is not specified, the maximum 
        over the whole array is returned. 
    index : array_like, optional 
        A list of region labels that are taken into account for computing the 
        maxima. If index is None, the maximum over all elements where `labels` 
        is non-zero is returned. 
 
    Returns 
    ------- 
    output : float or list of floats 
        List of maxima of `input` over the regions determined by `labels` and 
        whose index is in `index`. If `index` or `labels` are not specified, a 
        float is returned: the maximal value of `input` if `labels` is None, 
        and the maximal value of elements where `labels` is greater than zero 
        if `index` is None. 
 
    See Also 
    -------- 
    label, minimum, median, maximum_position, extrema, sum, mean, variance, 
    standard_deviation 
 
    Notes 
    ----- 
    The function returns a Python list and not a NumPy array, use 
    `np.array` to convert the list to an array. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; a = np.arange(16).reshape((4,4)) 
    &gt;&gt;&gt; a 
    array([[ 0,  1,  2,  3], 
           [ 4,  5,  6,  7], 
           [ 8,  9, 10, 11], 
           [12, 13, 14, 15]]) 
    &gt;&gt;&gt; labels = np.zeros_like(a) 
    &gt;&gt;&gt; labels[:2,:2] = 1 
    &gt;&gt;&gt; labels[2:, 1:3] = 2 
    &gt;&gt;&gt; labels 
    array([[1, 1, 0, 0], 
           [1, 1, 0, 0], 
           [0, 2, 2, 0], 
           [0, 2, 2, 0]]) 
    &gt;&gt;&gt; from scipy import ndimage 
    &gt;&gt;&gt; ndimage.maximum(a) 
    15.0 
    &gt;&gt;&gt; ndimage.maximum(a, labels=labels, index=[1,2]) 
    [5.0, 14.0] 
    &gt;&gt;&gt; ndimage.maximum(a, labels=labels) 
    14.0 
 
    &gt;&gt;&gt; b = np.array([[1, 2, 0, 0], 
    ...               [5, 3, 0, 4], 
    ...               [0, 0, 0, 7], 
    ...               [9, 3, 0, 0]]) 
    &gt;&gt;&gt; labels, labels_nb = ndimage.label(b) 
    &gt;&gt;&gt; labels 
    array([[1, 1, 0, 0], 
           [1, 1, 0, 2], 
           [0, 0, 0, 2], 
           [3, 3, 0, 0]]) 
    &gt;&gt;&gt; ndimage.maximum(b, labels=labels, index=np.arange(1, labels_nb + 1)) 
    [5.0, 7.0, 9.0] 
 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_select</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">labels</span><span class="s3">, </span><span class="s1">index</span><span class="s3">, </span><span class="s1">find_max</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)[</span><span class="s6">0</span><span class="s3">]</span>


<span class="s2">def </span><span class="s1">median</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">labels</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">index</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Calculate the median of the values of an array over labeled regions. 
 
    Parameters 
    ---------- 
    input : array_like 
        Array_like of values. For each region specified by `labels`, the 
        median value of `input` over the region is computed. 
    labels : array_like, optional 
        An array_like of integers marking different regions over which the 
        median value of `input` is to be computed. `labels` must have the 
        same shape as `input`. If `labels` is not specified, the median 
        over the whole array is returned. 
    index : array_like, optional 
        A list of region labels that are taken into account for computing the 
        medians. If index is None, the median over all elements where `labels` 
        is non-zero is returned. 
 
    Returns 
    ------- 
    median : float or list of floats 
        List of medians of `input` over the regions determined by `labels` and 
        whose index is in `index`. If `index` or `labels` are not specified, a 
        float is returned: the median value of `input` if `labels` is None, 
        and the median value of elements where `labels` is greater than zero 
        if `index` is None. 
 
    See Also 
    -------- 
    label, minimum, maximum, extrema, sum, mean, variance, standard_deviation 
 
    Notes 
    ----- 
    The function returns a Python list and not a NumPy array, use 
    `np.array` to convert the list to an array. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy import ndimage 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; a = np.array([[1, 2, 0, 1], 
    ...               [5, 3, 0, 4], 
    ...               [0, 0, 0, 7], 
    ...               [9, 3, 0, 0]]) 
    &gt;&gt;&gt; labels, labels_nb = ndimage.label(a) 
    &gt;&gt;&gt; labels 
    array([[1, 1, 0, 2], 
           [1, 1, 0, 2], 
           [0, 0, 0, 2], 
           [3, 3, 0, 0]]) 
    &gt;&gt;&gt; ndimage.median(a, labels=labels, index=np.arange(1, labels_nb + 1)) 
    [2.5, 4.0, 6.0] 
    &gt;&gt;&gt; ndimage.median(a) 
    1.0 
    &gt;&gt;&gt; ndimage.median(a, labels=labels) 
    3.0 
 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_select</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">labels</span><span class="s3">, </span><span class="s1">index</span><span class="s3">, </span><span class="s1">find_median</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)[</span><span class="s6">0</span><span class="s3">]</span>


<span class="s2">def </span><span class="s1">minimum_position</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">labels</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">index</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Find the positions of the minimums of the values of an array at labels. 
 
    Parameters 
    ---------- 
    input : array_like 
        Array_like of values. 
    labels : array_like, optional 
        An array of integers marking different regions over which the 
        position of the minimum value of `input` is to be computed. 
        `labels` must have the same shape as `input`. If `labels` is not 
        specified, the location of the first minimum over the whole 
        array is returned. 
 
        The `labels` argument only works when `index` is specified. 
    index : array_like, optional 
        A list of region labels that are taken into account for finding the 
        location of the minima. If `index` is None, the ``first`` minimum 
        over all elements where `labels` is non-zero is returned. 
 
        The `index` argument only works when `labels` is specified. 
 
    Returns 
    ------- 
    output : list of tuples of ints 
        Tuple of ints or list of tuples of ints that specify the location 
        of minima of `input` over the regions determined by `labels` and 
        whose index is in `index`. 
 
        If `index` or `labels` are not specified, a tuple of ints is 
        returned specifying the location of the first minimal value of `input`. 
 
    See Also 
    -------- 
    label, minimum, median, maximum_position, extrema, sum, mean, variance, 
    standard_deviation 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; a = np.array([[10, 20, 30], 
    ...               [40, 80, 100], 
    ...               [1, 100, 200]]) 
    &gt;&gt;&gt; b = np.array([[1, 2, 0, 1], 
    ...               [5, 3, 0, 4], 
    ...               [0, 0, 0, 7], 
    ...               [9, 3, 0, 0]]) 
 
    &gt;&gt;&gt; from scipy import ndimage 
 
    &gt;&gt;&gt; ndimage.minimum_position(a) 
    (2, 0) 
    &gt;&gt;&gt; ndimage.minimum_position(b) 
    (0, 2) 
 
    Features to process can be specified using `labels` and `index`: 
 
    &gt;&gt;&gt; label, pos = ndimage.label(a) 
    &gt;&gt;&gt; ndimage.minimum_position(a, label, index=np.arange(1, pos+1)) 
    [(2, 0)] 
 
    &gt;&gt;&gt; label, pos = ndimage.label(b) 
    &gt;&gt;&gt; ndimage.minimum_position(b, label, index=np.arange(1, pos+1)) 
    [(0, 0), (0, 3), (3, 1)] 
 
    &quot;&quot;&quot;</span>
    <span class="s1">dims </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">input</span><span class="s3">).</span><span class="s1">shape</span><span class="s3">)</span>
    <span class="s0"># see np.unravel_index to understand this line.</span>
    <span class="s1">dim_prod </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">cumprod</span><span class="s3">([</span><span class="s6">1</span><span class="s3">] + </span><span class="s1">list</span><span class="s3">(</span><span class="s1">dims</span><span class="s3">[:</span><span class="s6">0</span><span class="s3">:-</span><span class="s6">1</span><span class="s3">]))[::-</span><span class="s6">1</span><span class="s3">]</span>

    <span class="s1">result </span><span class="s3">= </span><span class="s1">_select</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">labels</span><span class="s3">, </span><span class="s1">index</span><span class="s3">, </span><span class="s1">find_min_positions</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)[</span><span class="s6">0</span><span class="s3">]</span>

    <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isscalar</span><span class="s3">(</span><span class="s1">result</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">tuple</span><span class="s3">((</span><span class="s1">result </span><span class="s3">// </span><span class="s1">dim_prod</span><span class="s3">) % </span><span class="s1">dims</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s3">[</span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">v</span><span class="s3">) </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s3">(</span><span class="s1">result</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">(-</span><span class="s6">1</span><span class="s3">, </span><span class="s6">1</span><span class="s3">) // </span><span class="s1">dim_prod</span><span class="s3">) % </span><span class="s1">dims</span><span class="s3">]</span>


<span class="s2">def </span><span class="s1">maximum_position</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">labels</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">index</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Find the positions of the maximums of the values of an array at labels. 
 
    For each region specified by `labels`, the position of the maximum 
    value of `input` within the region is returned. 
 
    Parameters 
    ---------- 
    input : array_like 
        Array_like of values. 
    labels : array_like, optional 
        An array of integers marking different regions over which the 
        position of the maximum value of `input` is to be computed. 
        `labels` must have the same shape as `input`. If `labels` is not 
        specified, the location of the first maximum over the whole 
        array is returned. 
 
        The `labels` argument only works when `index` is specified. 
    index : array_like, optional 
        A list of region labels that are taken into account for finding the 
        location of the maxima. If `index` is None, the first maximum 
        over all elements where `labels` is non-zero is returned. 
 
        The `index` argument only works when `labels` is specified. 
 
    Returns 
    ------- 
    output : list of tuples of ints 
        List of tuples of ints that specify the location of maxima of 
        `input` over the regions determined by `labels` and whose index 
        is in `index`. 
 
        If `index` or `labels` are not specified, a tuple of ints is 
        returned specifying the location of the ``first`` maximal value 
        of `input`. 
 
    See Also 
    -------- 
    label, minimum, median, maximum_position, extrema, sum, mean, variance, 
    standard_deviation 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy import ndimage 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; a = np.array([[1, 2, 0, 0], 
    ...               [5, 3, 0, 4], 
    ...               [0, 0, 0, 7], 
    ...               [9, 3, 0, 0]]) 
    &gt;&gt;&gt; ndimage.maximum_position(a) 
    (3, 0) 
 
    Features to process can be specified using `labels` and `index`: 
 
    &gt;&gt;&gt; lbl = np.array([[0, 1, 2, 3], 
    ...                 [0, 1, 2, 3], 
    ...                 [0, 1, 2, 3], 
    ...                 [0, 1, 2, 3]]) 
    &gt;&gt;&gt; ndimage.maximum_position(a, lbl, 1) 
    (1, 1) 
 
    If no index is given, non-zero `labels` are processed: 
 
    &gt;&gt;&gt; ndimage.maximum_position(a, lbl) 
    (2, 3) 
 
    If there are no maxima, the position of the first element is returned: 
 
    &gt;&gt;&gt; ndimage.maximum_position(a, lbl, 2) 
    (0, 2) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">dims </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">input</span><span class="s3">).</span><span class="s1">shape</span><span class="s3">)</span>
    <span class="s0"># see np.unravel_index to understand this line.</span>
    <span class="s1">dim_prod </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">cumprod</span><span class="s3">([</span><span class="s6">1</span><span class="s3">] + </span><span class="s1">list</span><span class="s3">(</span><span class="s1">dims</span><span class="s3">[:</span><span class="s6">0</span><span class="s3">:-</span><span class="s6">1</span><span class="s3">]))[::-</span><span class="s6">1</span><span class="s3">]</span>

    <span class="s1">result </span><span class="s3">= </span><span class="s1">_select</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">labels</span><span class="s3">, </span><span class="s1">index</span><span class="s3">, </span><span class="s1">find_max_positions</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)[</span><span class="s6">0</span><span class="s3">]</span>

    <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isscalar</span><span class="s3">(</span><span class="s1">result</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">tuple</span><span class="s3">((</span><span class="s1">result </span><span class="s3">// </span><span class="s1">dim_prod</span><span class="s3">) % </span><span class="s1">dims</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s3">[</span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">v</span><span class="s3">) </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s3">(</span><span class="s1">result</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">(-</span><span class="s6">1</span><span class="s3">, </span><span class="s6">1</span><span class="s3">) // </span><span class="s1">dim_prod</span><span class="s3">) % </span><span class="s1">dims</span><span class="s3">]</span>


<span class="s2">def </span><span class="s1">extrema</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">labels</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">index</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Calculate the minimums and maximums of the values of an array 
    at labels, along with their positions. 
 
    Parameters 
    ---------- 
    input : ndarray 
        N-D image data to process. 
    labels : ndarray, optional 
        Labels of features in input. 
        If not None, must be same shape as `input`. 
    index : int or sequence of ints, optional 
        Labels to include in output.  If None (default), all values where 
        non-zero `labels` are used. 
 
    Returns 
    ------- 
    minimums, maximums : int or ndarray 
        Values of minimums and maximums in each feature. 
    min_positions, max_positions : tuple or list of tuples 
        Each tuple gives the N-D coordinates of the corresponding minimum 
        or maximum. 
 
    See Also 
    -------- 
    maximum, minimum, maximum_position, minimum_position, center_of_mass 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; a = np.array([[1, 2, 0, 0], 
    ...               [5, 3, 0, 4], 
    ...               [0, 0, 0, 7], 
    ...               [9, 3, 0, 0]]) 
    &gt;&gt;&gt; from scipy import ndimage 
    &gt;&gt;&gt; ndimage.extrema(a) 
    (0, 9, (0, 2), (3, 0)) 
 
    Features to process can be specified using `labels` and `index`: 
 
    &gt;&gt;&gt; lbl, nlbl = ndimage.label(a) 
    &gt;&gt;&gt; ndimage.extrema(a, lbl, index=np.arange(1, nlbl+1)) 
    (array([1, 4, 3]), 
     array([5, 7, 9]), 
     [(0, 0), (1, 3), (3, 1)], 
     [(1, 0), (2, 3), (3, 0)]) 
 
    If no index is given, non-zero `labels` are processed: 
 
    &gt;&gt;&gt; ndimage.extrema(a, lbl) 
    (1, 9, (0, 0), (3, 0)) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">dims </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">input</span><span class="s3">).</span><span class="s1">shape</span><span class="s3">)</span>
    <span class="s0"># see np.unravel_index to understand this line.</span>
    <span class="s1">dim_prod </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">cumprod</span><span class="s3">([</span><span class="s6">1</span><span class="s3">] + </span><span class="s1">list</span><span class="s3">(</span><span class="s1">dims</span><span class="s3">[:</span><span class="s6">0</span><span class="s3">:-</span><span class="s6">1</span><span class="s3">]))[::-</span><span class="s6">1</span><span class="s3">]</span>

    <span class="s1">minimums</span><span class="s3">, </span><span class="s1">min_positions</span><span class="s3">, </span><span class="s1">maximums</span><span class="s3">, </span><span class="s1">max_positions </span><span class="s3">= </span><span class="s1">_select</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">labels</span><span class="s3">,</span>
                                                               <span class="s1">index</span><span class="s3">,</span>
                                                               <span class="s1">find_min</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
                                                               <span class="s1">find_max</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
                                                               <span class="s1">find_min_positions</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
                                                               <span class="s1">find_max_positions</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isscalar</span><span class="s3">(</span><span class="s1">minimums</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s3">(</span><span class="s1">minimums</span><span class="s3">, </span><span class="s1">maximums</span><span class="s3">, </span><span class="s1">tuple</span><span class="s3">((</span><span class="s1">min_positions </span><span class="s3">// </span><span class="s1">dim_prod</span><span class="s3">) % </span><span class="s1">dims</span><span class="s3">),</span>
                <span class="s1">tuple</span><span class="s3">((</span><span class="s1">max_positions </span><span class="s3">// </span><span class="s1">dim_prod</span><span class="s3">) % </span><span class="s1">dims</span><span class="s3">))</span>

    <span class="s1">min_positions </span><span class="s3">= [</span>
        <span class="s1">tuple</span><span class="s3">(</span><span class="s1">v</span><span class="s3">) </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s3">(</span><span class="s1">min_positions</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">(-</span><span class="s6">1</span><span class="s3">, </span><span class="s6">1</span><span class="s3">) // </span><span class="s1">dim_prod</span><span class="s3">) % </span><span class="s1">dims</span>
    <span class="s3">]</span>
    <span class="s1">max_positions </span><span class="s3">= [</span>
        <span class="s1">tuple</span><span class="s3">(</span><span class="s1">v</span><span class="s3">) </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s3">(</span><span class="s1">max_positions</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">(-</span><span class="s6">1</span><span class="s3">, </span><span class="s6">1</span><span class="s3">) // </span><span class="s1">dim_prod</span><span class="s3">) % </span><span class="s1">dims</span>
    <span class="s3">]</span>

    <span class="s2">return </span><span class="s1">minimums</span><span class="s3">, </span><span class="s1">maximums</span><span class="s3">, </span><span class="s1">min_positions</span><span class="s3">, </span><span class="s1">max_positions</span>


<span class="s2">def </span><span class="s1">center_of_mass</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">labels</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">index</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Calculate the center of mass of the values of an array at labels. 
 
    Parameters 
    ---------- 
    input : ndarray 
        Data from which to calculate center-of-mass. The masses can either 
        be positive or negative. 
    labels : ndarray, optional 
        Labels for objects in `input`, as generated by `ndimage.label`. 
        Only used with `index`. Dimensions must be the same as `input`. 
    index : int or sequence of ints, optional 
        Labels for which to calculate centers-of-mass. If not specified, 
        the combined center of mass of all labels greater than zero 
        will be calculated. Only used with `labels`. 
 
    Returns 
    ------- 
    center_of_mass : tuple, or list of tuples 
        Coordinates of centers-of-mass. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; a = np.array(([0,0,0,0], 
    ...               [0,1,1,0], 
    ...               [0,1,1,0], 
    ...               [0,1,1,0])) 
    &gt;&gt;&gt; from scipy import ndimage 
    &gt;&gt;&gt; ndimage.center_of_mass(a) 
    (2.0, 1.5) 
 
    Calculation of multiple objects in an image 
 
    &gt;&gt;&gt; b = np.array(([0,1,1,0], 
    ...               [0,1,0,0], 
    ...               [0,0,0,0], 
    ...               [0,0,1,1], 
    ...               [0,0,1,1])) 
    &gt;&gt;&gt; lbl = ndimage.label(b)[0] 
    &gt;&gt;&gt; ndimage.center_of_mass(b, lbl, [1,2]) 
    [(0.33333333333333331, 1.3333333333333333), (3.5, 2.5)] 
 
    Negative masses are also accepted, which can occur for example when 
    bias is removed from measured data due to random noise. 
 
    &gt;&gt;&gt; c = np.array(([-1,0,0,0], 
    ...               [0,-1,-1,0], 
    ...               [0,1,-1,0], 
    ...               [0,1,1,0])) 
    &gt;&gt;&gt; ndimage.center_of_mass(c) 
    (-4.0, 1.0) 
 
    If there are division by zero issues, the function does not raise an 
    error but rather issues a RuntimeWarning before returning inf and/or NaN. 
 
    &gt;&gt;&gt; d = np.array([-1, 1]) 
    &gt;&gt;&gt; ndimage.center_of_mass(d) 
    (inf,) 
    &quot;&quot;&quot;</span>
    <span class="s1">normalizer </span><span class="s3">= </span><span class="s1">sum</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">labels</span><span class="s3">, </span><span class="s1">index</span><span class="s3">)</span>
    <span class="s1">grids </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ogrid</span><span class="s3">[[</span><span class="s1">slice</span><span class="s3">(</span><span class="s6">0</span><span class="s3">, </span><span class="s1">i</span><span class="s3">) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">input</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">]]</span>

    <span class="s1">results </span><span class="s3">= [</span><span class="s1">sum</span><span class="s3">(</span><span class="s1">input </span><span class="s3">* </span><span class="s1">grids</span><span class="s3">[</span><span class="s1">dir</span><span class="s3">].</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">float</span><span class="s3">), </span><span class="s1">labels</span><span class="s3">, </span><span class="s1">index</span><span class="s3">) / </span><span class="s1">normalizer</span>
               <span class="s2">for </span><span class="s1">dir </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">input</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">)]</span>

    <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isscalar</span><span class="s3">(</span><span class="s1">results</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]):</span>
        <span class="s2">return </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">results</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s3">[</span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">v</span><span class="s3">) </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">results</span><span class="s3">).</span><span class="s1">T</span><span class="s3">]</span>


<span class="s2">def </span><span class="s1">histogram</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">min</span><span class="s3">, </span><span class="s1">max</span><span class="s3">, </span><span class="s1">bins</span><span class="s3">, </span><span class="s1">labels</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">index</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Calculate the histogram of the values of an array, optionally at labels. 
 
    Histogram calculates the frequency of values in an array within bins 
    determined by `min`, `max`, and `bins`. The `labels` and `index` 
    keywords can limit the scope of the histogram to specified sub-regions 
    within the array. 
 
    Parameters 
    ---------- 
    input : array_like 
        Data for which to calculate histogram. 
    min, max : int 
        Minimum and maximum values of range of histogram bins. 
    bins : int 
        Number of bins. 
    labels : array_like, optional 
        Labels for objects in `input`. 
        If not None, must be same shape as `input`. 
    index : int or sequence of ints, optional 
        Label or labels for which to calculate histogram. If None, all values 
        where label is greater than zero are used 
 
    Returns 
    ------- 
    hist : ndarray 
        Histogram counts. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; a = np.array([[ 0.    ,  0.2146,  0.5962,  0.    ], 
    ...               [ 0.    ,  0.7778,  0.    ,  0.    ], 
    ...               [ 0.    ,  0.    ,  0.    ,  0.    ], 
    ...               [ 0.    ,  0.    ,  0.7181,  0.2787], 
    ...               [ 0.    ,  0.    ,  0.6573,  0.3094]]) 
    &gt;&gt;&gt; from scipy import ndimage 
    &gt;&gt;&gt; ndimage.histogram(a, 0, 1, 10) 
    array([13,  0,  2,  1,  0,  1,  1,  2,  0,  0]) 
 
    With labels and no indices, non-zero elements are counted: 
 
    &gt;&gt;&gt; lbl, nlbl = ndimage.label(a) 
    &gt;&gt;&gt; ndimage.histogram(a, 0, 1, 10, lbl) 
    array([0, 0, 2, 1, 0, 1, 1, 2, 0, 0]) 
 
    Indices can be used to count only certain objects: 
 
    &gt;&gt;&gt; ndimage.histogram(a, 0, 1, 10, lbl, 2) 
    array([0, 0, 1, 1, 0, 0, 1, 1, 0, 0]) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">_bins </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">linspace</span><span class="s3">(</span><span class="s1">min</span><span class="s3">, </span><span class="s1">max</span><span class="s3">, </span><span class="s1">bins </span><span class="s3">+ </span><span class="s6">1</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_hist</span><span class="s3">(</span><span class="s1">vals</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">histogram</span><span class="s3">(</span><span class="s1">vals</span><span class="s3">, </span><span class="s1">_bins</span><span class="s3">)[</span><span class="s6">0</span><span class="s3">]</span>

    <span class="s2">return </span><span class="s1">labeled_comprehension</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">labels</span><span class="s3">, </span><span class="s1">index</span><span class="s3">, </span><span class="s1">_hist</span><span class="s3">, </span><span class="s1">object</span><span class="s3">, </span><span class="s2">None</span><span class="s3">,</span>
                                 <span class="s1">pass_positions</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">watershed_ift</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">markers</span><span class="s3">, </span><span class="s1">structure</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">output</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Apply watershed from markers using image foresting transform algorithm. 
 
    Parameters 
    ---------- 
    input : array_like 
        Input. 
    markers : array_like 
        Markers are points within each watershed that form the beginning 
        of the process. Negative markers are considered background markers 
        which are processed after the other markers. 
    structure : structure element, optional 
        A structuring element defining the connectivity of the object can be 
        provided. If None, an element is generated with a squared 
        connectivity equal to one. 
    output : ndarray, optional 
        An output array can optionally be provided. The same shape as input. 
 
    Returns 
    ------- 
    watershed_ift : ndarray 
        Output.  Same shape as `input`. 
 
    References 
    ---------- 
    .. [1] A.X. Falcao, J. Stolfi and R. de Alencar Lotufo, &quot;The image 
           foresting transform: theory, algorithms, and applications&quot;, 
           Pattern Analysis and Machine Intelligence, vol. 26, pp. 19-29, 2004. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">input </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">input</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">input</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">type </span><span class="s2">not in </span><span class="s3">[</span><span class="s1">np</span><span class="s3">.</span><span class="s1">uint8</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">uint16</span><span class="s3">]:</span>
        <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s4">'only 8 and 16 unsigned inputs are supported'</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">structure </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">structure </span><span class="s3">= </span><span class="s1">_morphology</span><span class="s3">.</span><span class="s1">generate_binary_structure</span><span class="s3">(</span><span class="s1">input</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">, </span><span class="s6">1</span><span class="s3">)</span>
    <span class="s1">structure </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">structure</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">bool</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">structure</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">!= </span><span class="s1">input</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">RuntimeError</span><span class="s3">(</span><span class="s4">'structure and input must have equal rank'</span><span class="s3">)</span>
    <span class="s2">for </span><span class="s1">ii </span><span class="s2">in </span><span class="s1">structure</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">ii </span><span class="s3">!= </span><span class="s6">3</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">RuntimeError</span><span class="s3">(</span><span class="s4">'structure dimensions must be equal to 3'</span><span class="s3">)</span>

    <span class="s2">if not </span><span class="s1">structure</span><span class="s3">.</span><span class="s1">flags</span><span class="s3">.</span><span class="s1">contiguous</span><span class="s3">:</span>
        <span class="s1">structure </span><span class="s3">= </span><span class="s1">structure</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>
    <span class="s1">markers </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">markers</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">input</span><span class="s3">.</span><span class="s1">shape </span><span class="s3">!= </span><span class="s1">markers</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">RuntimeError</span><span class="s3">(</span><span class="s4">'input and markers must have equal shape'</span><span class="s3">)</span>

    <span class="s1">integral_types </span><span class="s3">= [</span><span class="s1">np</span><span class="s3">.</span><span class="s1">int8</span><span class="s3">,</span>
                      <span class="s1">np</span><span class="s3">.</span><span class="s1">int16</span><span class="s3">,</span>
                      <span class="s1">np</span><span class="s3">.</span><span class="s1">int32</span><span class="s3">,</span>
                      <span class="s1">np</span><span class="s3">.</span><span class="s1">int64</span><span class="s3">,</span>
                      <span class="s1">np</span><span class="s3">.</span><span class="s1">intc</span><span class="s3">,</span>
                      <span class="s1">np</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">]</span>

    <span class="s2">if </span><span class="s1">markers</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">type </span><span class="s2">not in </span><span class="s1">integral_types</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">RuntimeError</span><span class="s3">(</span><span class="s4">'marker should be of integer type'</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">output</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndarray</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">output</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">type </span><span class="s2">not in </span><span class="s1">integral_types</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">RuntimeError</span><span class="s3">(</span><span class="s4">'output should be of integer type'</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">output </span><span class="s3">= </span><span class="s1">markers</span><span class="s3">.</span><span class="s1">dtype</span>

    <span class="s1">output </span><span class="s3">= </span><span class="s1">_ni_support</span><span class="s3">.</span><span class="s1">_get_output</span><span class="s3">(</span><span class="s1">output</span><span class="s3">, </span><span class="s1">input</span><span class="s3">)</span>
    <span class="s1">_nd_image</span><span class="s3">.</span><span class="s1">watershed_ift</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">markers</span><span class="s3">, </span><span class="s1">structure</span><span class="s3">, </span><span class="s1">output</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">output</span>
</pre>
</body>
</html>