<html>
<head>
<title>splines.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #6aab73;}
.s4 { color: #cf8e6d;}
.s5 { color: #2aacb8;}
.s6 { color: #5f826b; font-style: italic;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
splines.py</font>
</center></td></tr></table>
<pre><span class="s0"># This file is part of Patsy</span>
<span class="s0"># Copyright (C) 2012-2013 Nathaniel Smith &lt;njs@pobox.com&gt;</span>
<span class="s0"># See file LICENSE.txt for license information.</span>

<span class="s0"># R-compatible spline basis functions</span>

<span class="s0"># These are made available in the patsy.* namespace</span>
<span class="s1">__all__ </span><span class="s2">= [</span><span class="s3">&quot;bs&quot;</span><span class="s2">]</span>

<span class="s4">import </span><span class="s1">numpy </span><span class="s4">as </span><span class="s1">np</span>

<span class="s4">from </span><span class="s1">patsy</span><span class="s2">.</span><span class="s1">util </span><span class="s4">import </span><span class="s1">have_pandas</span><span class="s2">, </span><span class="s1">no_pickling</span><span class="s2">, </span><span class="s1">assert_no_pickling</span>
<span class="s4">from </span><span class="s1">patsy</span><span class="s2">.</span><span class="s1">state </span><span class="s4">import </span><span class="s1">stateful_transform</span>

<span class="s4">if </span><span class="s1">have_pandas</span><span class="s2">:</span>
    <span class="s4">import </span><span class="s1">pandas</span>

<span class="s4">def </span><span class="s1">_eval_bspline_basis</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">knots</span><span class="s2">, </span><span class="s1">degree</span><span class="s2">):</span>
    <span class="s4">try</span><span class="s2">:</span>
        <span class="s4">from </span><span class="s1">scipy</span><span class="s2">.</span><span class="s1">interpolate </span><span class="s4">import </span><span class="s1">splev</span>
    <span class="s4">except </span><span class="s1">ImportError</span><span class="s2">: </span><span class="s0"># pragma: no cover</span>
        <span class="s4">raise </span><span class="s1">ImportError</span><span class="s2">(</span><span class="s3">&quot;spline functionality requires scipy&quot;</span><span class="s2">)</span>
    <span class="s0"># 'knots' are assumed to be already pre-processed. E.g. usually you</span>
    <span class="s0"># want to include duplicate copies of boundary knots; you should do</span>
    <span class="s0"># that *before* calling this constructor.</span>
    <span class="s1">knots </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">atleast_1d</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">knots</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">float</span><span class="s2">))</span>
    <span class="s4">assert </span><span class="s1">knots</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s5">1</span>
    <span class="s1">knots</span><span class="s2">.</span><span class="s1">sort</span><span class="s2">()</span>
    <span class="s1">degree </span><span class="s2">= </span><span class="s1">int</span><span class="s2">(</span><span class="s1">degree</span><span class="s2">)</span>
    <span class="s1">x </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">atleast_1d</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)</span>
    <span class="s4">if </span><span class="s1">x</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s5">2 </span><span class="s4">and </span><span class="s1">x</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">1</span><span class="s2">] == </span><span class="s5">1</span><span class="s2">:</span>
        <span class="s1">x </span><span class="s2">= </span><span class="s1">x</span><span class="s2">[:, </span><span class="s5">0</span><span class="s2">]</span>
    <span class="s4">assert </span><span class="s1">x</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s5">1</span>
    <span class="s0"># XX FIXME: when points fall outside of the boundaries, splev and R seem</span>
    <span class="s0"># to handle them differently. I don't know why yet. So until we understand</span>
    <span class="s0"># this and decide what to do with it, I'm going to play it safe and</span>
    <span class="s0"># disallow such points.</span>
    <span class="s4">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">min</span><span class="s2">(</span><span class="s1">x</span><span class="s2">) &lt; </span><span class="s1">np</span><span class="s2">.</span><span class="s1">min</span><span class="s2">(</span><span class="s1">knots</span><span class="s2">) </span><span class="s4">or </span><span class="s1">np</span><span class="s2">.</span><span class="s1">max</span><span class="s2">(</span><span class="s1">x</span><span class="s2">) &gt; </span><span class="s1">np</span><span class="s2">.</span><span class="s1">max</span><span class="s2">(</span><span class="s1">knots</span><span class="s2">):</span>
        <span class="s4">raise </span><span class="s1">NotImplementedError</span><span class="s2">(</span><span class="s3">&quot;some data points fall outside the &quot;</span>
                                  <span class="s3">&quot;outermost knots, and I'm not sure how &quot;</span>
                                  <span class="s3">&quot;to handle them. (Patches accepted!)&quot;</span><span class="s2">)</span>
    <span class="s0"># Thanks to Charles Harris for explaining splev. It's not well</span>
    <span class="s0"># documented, but basically it computes an arbitrary b-spline basis</span>
    <span class="s0"># given knots and degree on some specified points (or derivatives</span>
    <span class="s0"># thereof, but we don't use that functionality), and then returns some</span>
    <span class="s0"># linear combination of these basis functions. To get out the basis</span>
    <span class="s0"># functions themselves, we use linear combinations like [1, 0, 0], [0,</span>
    <span class="s0"># 1, 0], [0, 0, 1].</span>
    <span class="s0"># NB: This probably makes it rather inefficient (though I haven't checked</span>
    <span class="s0"># to be sure -- maybe the fortran code actually skips computing the basis</span>
    <span class="s0"># function for coefficients that are zero).</span>
    <span class="s0"># Note: the order of a spline is the same as its degree + 1.</span>
    <span class="s0"># Note: there are (len(knots) - order) basis functions.</span>
    <span class="s1">n_bases </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">knots</span><span class="s2">) - (</span><span class="s1">degree </span><span class="s2">+ </span><span class="s5">1</span><span class="s2">)</span>
    <span class="s1">basis </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">((</span><span class="s1">x</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">0</span><span class="s2">], </span><span class="s1">n_bases</span><span class="s2">), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">float</span><span class="s2">)</span>
    <span class="s4">for </span><span class="s1">i </span><span class="s4">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">n_bases</span><span class="s2">):</span>
        <span class="s1">coefs </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">((</span><span class="s1">n_bases</span><span class="s2">,))</span>
        <span class="s1">coefs</span><span class="s2">[</span><span class="s1">i</span><span class="s2">] = </span><span class="s5">1</span>
        <span class="s1">basis</span><span class="s2">[:, </span><span class="s1">i</span><span class="s2">] = </span><span class="s1">splev</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, (</span><span class="s1">knots</span><span class="s2">, </span><span class="s1">coefs</span><span class="s2">, </span><span class="s1">degree</span><span class="s2">))</span>
    <span class="s4">return </span><span class="s1">basis</span>

<span class="s4">def </span><span class="s1">_R_compat_quantile</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">probs</span><span class="s2">):</span>
    <span class="s0">#return np.percentile(x, 100 * np.asarray(probs))</span>
    <span class="s1">probs </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">probs</span><span class="s2">)</span>
    <span class="s1">quantiles </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">([</span><span class="s1">np</span><span class="s2">.</span><span class="s1">percentile</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s5">100 </span><span class="s2">* </span><span class="s1">prob</span><span class="s2">)</span>
                            <span class="s4">for </span><span class="s1">prob </span><span class="s4">in </span><span class="s1">probs</span><span class="s2">.</span><span class="s1">ravel</span><span class="s2">(</span><span class="s1">order</span><span class="s2">=</span><span class="s3">&quot;C&quot;</span><span class="s2">)])</span>
    <span class="s4">return </span><span class="s1">quantiles</span><span class="s2">.</span><span class="s1">reshape</span><span class="s2">(</span><span class="s1">probs</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">order</span><span class="s2">=</span><span class="s3">&quot;C&quot;</span><span class="s2">)</span>

<span class="s4">def </span><span class="s1">test__R_compat_quantile</span><span class="s2">():</span>
    <span class="s4">def </span><span class="s1">t</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">prob</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">):</span>
        <span class="s4">assert </span><span class="s1">np</span><span class="s2">.</span><span class="s1">allclose</span><span class="s2">(</span><span class="s1">_R_compat_quantile</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">prob</span><span class="s2">), </span><span class="s1">expected</span><span class="s2">)</span>
    <span class="s1">t</span><span class="s2">([</span><span class="s5">10</span><span class="s2">, </span><span class="s5">20</span><span class="s2">], </span><span class="s5">0.5</span><span class="s2">, </span><span class="s5">15</span><span class="s2">)</span>
    <span class="s1">t</span><span class="s2">([</span><span class="s5">10</span><span class="s2">, </span><span class="s5">20</span><span class="s2">], </span><span class="s5">0.3</span><span class="s2">, </span><span class="s5">13</span><span class="s2">)</span>
    <span class="s1">t</span><span class="s2">([</span><span class="s5">10</span><span class="s2">, </span><span class="s5">20</span><span class="s2">], [</span><span class="s5">0.3</span><span class="s2">, </span><span class="s5">0.7</span><span class="s2">], [</span><span class="s5">13</span><span class="s2">, </span><span class="s5">17</span><span class="s2">])</span>
    <span class="s1">t</span><span class="s2">(</span><span class="s1">list</span><span class="s2">(</span><span class="s1">range</span><span class="s2">(</span><span class="s5">10</span><span class="s2">)), [</span><span class="s5">0.3</span><span class="s2">, </span><span class="s5">0.7</span><span class="s2">], [</span><span class="s5">2.7</span><span class="s2">, </span><span class="s5">6.3</span><span class="s2">])</span>

<span class="s4">class </span><span class="s1">BS</span><span class="s2">(</span><span class="s1">object</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot;bs(x, df=None, knots=None, degree=3, include_intercept=False, lower_bound=None, upper_bound=None) 
 
    Generates a B-spline basis for ``x``, allowing non-linear fits. The usual 
    usage is something like:: 
 
      y ~ 1 + bs(x, 4) 
 
    to fit ``y`` as a smooth function of ``x``, with 4 degrees of freedom 
    given to the smooth. 
 
    :arg df: The number of degrees of freedom to use for this spline. The 
      return value will have this many columns. You must specify at least one 
      of ``df`` and ``knots``. 
    :arg knots: The interior knots to use for the spline. If unspecified, then 
      equally spaced quantiles of the input data are used. You must specify at 
      least one of ``df`` and ``knots``. 
    :arg degree: The degree of the spline to use. 
    :arg include_intercept: If ``True``, then the resulting 
      spline basis will span the intercept term (i.e., the constant 
      function). If ``False`` (the default) then this will not be the case, 
      which is useful for avoiding overspecification in models that include 
      multiple spline terms and/or an intercept term. 
    :arg lower_bound: The lower exterior knot location. 
    :arg upper_bound: The upper exterior knot location. 
 
    A spline with ``degree=0`` is piecewise constant with breakpoints at each 
    knot, and the default knot positions are quantiles of the input. So if you 
    find yourself in the situation of wanting to quantize a continuous 
    variable into ``num_bins`` equal-sized bins with a constant effect across 
    each bin, you can use ``bs(x, num_bins - 1, degree=0)``. (The ``- 1`` is 
    because one degree of freedom will be taken by the intercept; 
    alternatively, you could leave the intercept term out of your model and 
    use ``bs(x, num_bins, degree=0, include_intercept=True)``. 
 
    A spline with ``degree=1`` is piecewise linear with breakpoints at each 
    knot. 
 
    The default is ``degree=3``, which gives a cubic b-spline. 
 
    This is a stateful transform (for details see 
    :ref:`stateful-transforms`). If ``knots``, ``lower_bound``, or 
    ``upper_bound`` are not specified, they will be calculated from the data 
    and then the chosen values will be remembered and re-used for prediction 
    from the fitted model. 
 
    Using this function requires scipy be installed. 
 
    .. note:: This function is very similar to the R function of the same 
      name. In cases where both return output at all (e.g., R's ``bs`` will 
      raise an error if ``degree=0``, while patsy's will not), they should 
      produce identical output given identical input and parameter settings. 
 
    .. warning:: I'm not sure on what the proper handling of points outside 
      the lower/upper bounds is, so for now attempting to evaluate a spline 
      basis at such points produces an error. Patches gratefully accepted. 
 
    .. versionadded:: 0.2.0 
    &quot;&quot;&quot;</span>
    <span class="s4">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_tmp </span><span class="s2">= {}</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_degree </span><span class="s2">= </span><span class="s4">None</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_all_knots </span><span class="s2">= </span><span class="s4">None</span>

    <span class="s4">def </span><span class="s1">memorize_chunk</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">df</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">knots</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">degree</span><span class="s2">=</span><span class="s5">3</span><span class="s2">,</span>
                       <span class="s1">include_intercept</span><span class="s2">=</span><span class="s4">False</span><span class="s2">,</span>
                       <span class="s1">lower_bound</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">upper_bound</span><span class="s2">=</span><span class="s4">None</span><span class="s2">):</span>
        <span class="s1">args </span><span class="s2">= {</span><span class="s3">&quot;df&quot;</span><span class="s2">: </span><span class="s1">df</span><span class="s2">,</span>
                <span class="s3">&quot;knots&quot;</span><span class="s2">: </span><span class="s1">knots</span><span class="s2">,</span>
                <span class="s3">&quot;degree&quot;</span><span class="s2">: </span><span class="s1">degree</span><span class="s2">,</span>
                <span class="s3">&quot;include_intercept&quot;</span><span class="s2">: </span><span class="s1">include_intercept</span><span class="s2">,</span>
                <span class="s3">&quot;lower_bound&quot;</span><span class="s2">: </span><span class="s1">lower_bound</span><span class="s2">,</span>
                <span class="s3">&quot;upper_bound&quot;</span><span class="s2">: </span><span class="s1">upper_bound</span><span class="s2">,</span>
                <span class="s2">}</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_tmp</span><span class="s2">[</span><span class="s3">&quot;args&quot;</span><span class="s2">] = </span><span class="s1">args</span>
        <span class="s0"># XX: check whether we need x values before saving them</span>
        <span class="s1">x </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">atleast_1d</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">x</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s5">2 </span><span class="s4">and </span><span class="s1">x</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">1</span><span class="s2">] == </span><span class="s5">1</span><span class="s2">:</span>
            <span class="s1">x </span><span class="s2">= </span><span class="s1">x</span><span class="s2">[:, </span><span class="s5">0</span><span class="s2">]</span>
        <span class="s4">if </span><span class="s1">x</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">&gt; </span><span class="s5">1</span><span class="s2">:</span>
            <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;input to 'bs' must be 1-d, &quot;</span>
                             <span class="s3">&quot;or a 2-d column vector&quot;</span><span class="s2">)</span>
        <span class="s0"># There's no better way to compute exact quantiles than memorizing</span>
        <span class="s0"># all data.</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_tmp</span><span class="s2">.</span><span class="s1">setdefault</span><span class="s2">(</span><span class="s3">&quot;xs&quot;</span><span class="s2">, []).</span><span class="s1">append</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">memorize_finish</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">tmp </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_tmp</span>
        <span class="s1">args </span><span class="s2">= </span><span class="s1">tmp</span><span class="s2">[</span><span class="s3">&quot;args&quot;</span><span class="s2">]</span>
        <span class="s4">del </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_tmp</span>

        <span class="s4">if </span><span class="s1">args</span><span class="s2">[</span><span class="s3">&quot;degree&quot;</span><span class="s2">] &lt; </span><span class="s5">0</span><span class="s2">:</span>
            <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;degree must be greater than 0 (not %r)&quot;</span>
                             <span class="s2">% (</span><span class="s1">args</span><span class="s2">[</span><span class="s3">&quot;degree&quot;</span><span class="s2">],))</span>
        <span class="s4">if </span><span class="s1">int</span><span class="s2">(</span><span class="s1">args</span><span class="s2">[</span><span class="s3">&quot;degree&quot;</span><span class="s2">]) != </span><span class="s1">args</span><span class="s2">[</span><span class="s3">&quot;degree&quot;</span><span class="s2">]:</span>
            <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;degree must be an integer (not %r)&quot;</span>
                             <span class="s2">% (</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_degree</span><span class="s2">,))</span>

        <span class="s0"># These are guaranteed to all be 1d vectors by the code above</span>
        <span class="s1">x </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">concatenate</span><span class="s2">(</span><span class="s1">tmp</span><span class="s2">[</span><span class="s3">&quot;xs&quot;</span><span class="s2">])</span>
        <span class="s4">if </span><span class="s1">args</span><span class="s2">[</span><span class="s3">&quot;df&quot;</span><span class="s2">] </span><span class="s4">is None and </span><span class="s1">args</span><span class="s2">[</span><span class="s3">&quot;knots&quot;</span><span class="s2">] </span><span class="s4">is None</span><span class="s2">:</span>
            <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;must specify either df or knots&quot;</span><span class="s2">)</span>
        <span class="s1">order </span><span class="s2">= </span><span class="s1">args</span><span class="s2">[</span><span class="s3">&quot;degree&quot;</span><span class="s2">] + </span><span class="s5">1</span>
        <span class="s4">if </span><span class="s1">args</span><span class="s2">[</span><span class="s3">&quot;df&quot;</span><span class="s2">] </span><span class="s4">is not None</span><span class="s2">:</span>
            <span class="s1">n_inner_knots </span><span class="s2">= </span><span class="s1">args</span><span class="s2">[</span><span class="s3">&quot;df&quot;</span><span class="s2">] - </span><span class="s1">order</span>
            <span class="s4">if not </span><span class="s1">args</span><span class="s2">[</span><span class="s3">&quot;include_intercept&quot;</span><span class="s2">]:</span>
                <span class="s1">n_inner_knots </span><span class="s2">+= </span><span class="s5">1</span>
            <span class="s4">if </span><span class="s1">n_inner_knots </span><span class="s2">&lt; </span><span class="s5">0</span><span class="s2">:</span>
                <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;df=%r is too small for degree=%r and &quot;</span>
                                 <span class="s3">&quot;include_intercept=%r; must be &gt;= %s&quot;</span>
                                 <span class="s2">% (</span><span class="s1">args</span><span class="s2">[</span><span class="s3">&quot;df&quot;</span><span class="s2">], </span><span class="s1">args</span><span class="s2">[</span><span class="s3">&quot;degree&quot;</span><span class="s2">],</span>
                                    <span class="s1">args</span><span class="s2">[</span><span class="s3">&quot;include_intercept&quot;</span><span class="s2">],</span>
                                    <span class="s0"># We know that n_inner_knots is negative;</span>
                                    <span class="s0"># if df were that much larger, it would</span>
                                    <span class="s0"># have been zero, and things would work.</span>
                                    <span class="s1">args</span><span class="s2">[</span><span class="s3">&quot;df&quot;</span><span class="s2">] - </span><span class="s1">n_inner_knots</span><span class="s2">))</span>
            <span class="s4">if </span><span class="s1">args</span><span class="s2">[</span><span class="s3">&quot;knots&quot;</span><span class="s2">] </span><span class="s4">is not None</span><span class="s2">:</span>
                <span class="s4">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">args</span><span class="s2">[</span><span class="s3">&quot;knots&quot;</span><span class="s2">]) != </span><span class="s1">n_inner_knots</span><span class="s2">:</span>
                    <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;df=%s with degree=%r implies %s knots, &quot;</span>
                                     <span class="s3">&quot;but %s knots were provided&quot;</span>
                                     <span class="s2">% (</span><span class="s1">args</span><span class="s2">[</span><span class="s3">&quot;df&quot;</span><span class="s2">], </span><span class="s1">args</span><span class="s2">[</span><span class="s3">&quot;degree&quot;</span><span class="s2">],</span>
                                        <span class="s1">n_inner_knots</span><span class="s2">, </span><span class="s1">len</span><span class="s2">(</span><span class="s1">args</span><span class="s2">[</span><span class="s3">&quot;knots&quot;</span><span class="s2">])))</span>
            <span class="s4">else</span><span class="s2">:</span>
                <span class="s0"># Need to compute inner knots</span>
                <span class="s1">knot_quantiles </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linspace</span><span class="s2">(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s1">n_inner_knots </span><span class="s2">+ </span><span class="s5">2</span><span class="s2">)[</span><span class="s5">1</span><span class="s2">:-</span><span class="s5">1</span><span class="s2">]</span>
                <span class="s1">inner_knots </span><span class="s2">= </span><span class="s1">_R_compat_quantile</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">knot_quantiles</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">args</span><span class="s2">[</span><span class="s3">&quot;knots&quot;</span><span class="s2">] </span><span class="s4">is not None</span><span class="s2">:</span>
            <span class="s1">inner_knots </span><span class="s2">= </span><span class="s1">args</span><span class="s2">[</span><span class="s3">&quot;knots&quot;</span><span class="s2">]</span>
        <span class="s4">if </span><span class="s1">args</span><span class="s2">[</span><span class="s3">&quot;lower_bound&quot;</span><span class="s2">] </span><span class="s4">is not None</span><span class="s2">:</span>
            <span class="s1">lower_bound </span><span class="s2">= </span><span class="s1">args</span><span class="s2">[</span><span class="s3">&quot;lower_bound&quot;</span><span class="s2">]</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">lower_bound </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">min</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">args</span><span class="s2">[</span><span class="s3">&quot;upper_bound&quot;</span><span class="s2">] </span><span class="s4">is not None</span><span class="s2">:</span>
            <span class="s1">upper_bound </span><span class="s2">= </span><span class="s1">args</span><span class="s2">[</span><span class="s3">&quot;upper_bound&quot;</span><span class="s2">]</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">upper_bound </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">max</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">lower_bound </span><span class="s2">&gt; </span><span class="s1">upper_bound</span><span class="s2">:</span>
            <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;lower_bound &gt; upper_bound (%r &gt; %r)&quot;</span>
                             <span class="s2">% (</span><span class="s1">lower_bound</span><span class="s2">, </span><span class="s1">upper_bound</span><span class="s2">))</span>
        <span class="s1">inner_knots </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">inner_knots</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">inner_knots</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">&gt; </span><span class="s5">1</span><span class="s2">:</span>
            <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;knots must be 1 dimensional&quot;</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">any</span><span class="s2">(</span><span class="s1">inner_knots </span><span class="s2">&lt; </span><span class="s1">lower_bound</span><span class="s2">):</span>
            <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;some knot values (%s) fall below lower bound &quot;</span>
                             <span class="s3">&quot;(%r)&quot;</span>
                             <span class="s2">% (</span><span class="s1">inner_knots</span><span class="s2">[</span><span class="s1">inner_knots </span><span class="s2">&lt; </span><span class="s1">lower_bound</span><span class="s2">],</span>
                                <span class="s1">lower_bound</span><span class="s2">))</span>
        <span class="s4">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">any</span><span class="s2">(</span><span class="s1">inner_knots </span><span class="s2">&gt; </span><span class="s1">upper_bound</span><span class="s2">):</span>
            <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;some knot values (%s) fall above upper bound &quot;</span>
                             <span class="s3">&quot;(%r)&quot;</span>
                             <span class="s2">% (</span><span class="s1">inner_knots</span><span class="s2">[</span><span class="s1">inner_knots </span><span class="s2">&gt; </span><span class="s1">upper_bound</span><span class="s2">],</span>
                                <span class="s1">upper_bound</span><span class="s2">))</span>
        <span class="s1">all_knots </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">concatenate</span><span class="s2">(([</span><span class="s1">lower_bound</span><span class="s2">, </span><span class="s1">upper_bound</span><span class="s2">] * </span><span class="s1">order</span><span class="s2">,</span>
                                    <span class="s1">inner_knots</span><span class="s2">))</span>
        <span class="s1">all_knots</span><span class="s2">.</span><span class="s1">sort</span><span class="s2">()</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">_degree </span><span class="s2">= </span><span class="s1">args</span><span class="s2">[</span><span class="s3">&quot;degree&quot;</span><span class="s2">]</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_all_knots </span><span class="s2">= </span><span class="s1">all_knots</span>

    <span class="s4">def </span><span class="s1">transform</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">df</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">knots</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">degree</span><span class="s2">=</span><span class="s5">3</span><span class="s2">,</span>
                  <span class="s1">include_intercept</span><span class="s2">=</span><span class="s4">False</span><span class="s2">,</span>
                  <span class="s1">lower_bound</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">upper_bound</span><span class="s2">=</span><span class="s4">None</span><span class="s2">):</span>
        <span class="s1">basis </span><span class="s2">= </span><span class="s1">_eval_bspline_basis</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_all_knots</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_degree</span><span class="s2">)</span>
        <span class="s4">if not </span><span class="s1">include_intercept</span><span class="s2">:</span>
            <span class="s1">basis </span><span class="s2">= </span><span class="s1">basis</span><span class="s2">[:, </span><span class="s5">1</span><span class="s2">:]</span>
        <span class="s4">if </span><span class="s1">have_pandas</span><span class="s2">:</span>
            <span class="s4">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, (</span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">Series</span><span class="s2">, </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">DataFrame</span><span class="s2">)):</span>
                <span class="s1">basis </span><span class="s2">= </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">DataFrame</span><span class="s2">(</span><span class="s1">basis</span><span class="s2">)</span>
                <span class="s1">basis</span><span class="s2">.</span><span class="s1">index </span><span class="s2">= </span><span class="s1">x</span><span class="s2">.</span><span class="s1">index</span>
        <span class="s4">return </span><span class="s1">basis</span>

    <span class="s1">__getstate__ </span><span class="s2">= </span><span class="s1">no_pickling</span>

<span class="s1">bs </span><span class="s2">= </span><span class="s1">stateful_transform</span><span class="s2">(</span><span class="s1">BS</span><span class="s2">)</span>

<span class="s4">def </span><span class="s1">test_bs_compat</span><span class="s2">():</span>
    <span class="s4">from </span><span class="s1">patsy</span><span class="s2">.</span><span class="s1">test_state </span><span class="s4">import </span><span class="s1">check_stateful</span>
    <span class="s4">from </span><span class="s1">patsy</span><span class="s2">.</span><span class="s1">test_splines_bs_data </span><span class="s4">import </span><span class="s2">(</span><span class="s1">R_bs_test_x</span><span class="s2">,</span>
                                            <span class="s1">R_bs_test_data</span><span class="s2">,</span>
                                            <span class="s1">R_bs_num_tests</span><span class="s2">)</span>
    <span class="s1">lines </span><span class="s2">= </span><span class="s1">R_bs_test_data</span><span class="s2">.</span><span class="s1">split</span><span class="s2">(</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3">&quot;</span><span class="s2">)</span>
    <span class="s1">tests_ran </span><span class="s2">= </span><span class="s5">0</span>
    <span class="s1">start_idx </span><span class="s2">= </span><span class="s1">lines</span><span class="s2">.</span><span class="s1">index</span><span class="s2">(</span><span class="s3">&quot;--BEGIN TEST CASE--&quot;</span><span class="s2">)</span>
    <span class="s4">while True</span><span class="s2">:</span>
        <span class="s4">if not </span><span class="s1">lines</span><span class="s2">[</span><span class="s1">start_idx</span><span class="s2">] == </span><span class="s3">&quot;--BEGIN TEST CASE--&quot;</span><span class="s2">:</span>
            <span class="s4">break</span>
        <span class="s1">start_idx </span><span class="s2">+= </span><span class="s5">1</span>
        <span class="s1">stop_idx </span><span class="s2">= </span><span class="s1">lines</span><span class="s2">.</span><span class="s1">index</span><span class="s2">(</span><span class="s3">&quot;--END TEST CASE--&quot;</span><span class="s2">, </span><span class="s1">start_idx</span><span class="s2">)</span>
        <span class="s1">block </span><span class="s2">= </span><span class="s1">lines</span><span class="s2">[</span><span class="s1">start_idx</span><span class="s2">:</span><span class="s1">stop_idx</span><span class="s2">]</span>
        <span class="s1">test_data </span><span class="s2">= {}</span>
        <span class="s4">for </span><span class="s1">line </span><span class="s4">in </span><span class="s1">block</span><span class="s2">:</span>
            <span class="s1">key</span><span class="s2">, </span><span class="s1">value </span><span class="s2">= </span><span class="s1">line</span><span class="s2">.</span><span class="s1">split</span><span class="s2">(</span><span class="s3">&quot;=&quot;</span><span class="s2">, </span><span class="s5">1</span><span class="s2">)</span>
            <span class="s1">test_data</span><span class="s2">[</span><span class="s1">key</span><span class="s2">] = </span><span class="s1">value</span>
        <span class="s0"># Translate the R output into Python calling conventions</span>
        <span class="s1">kwargs </span><span class="s2">= {</span>
            <span class="s3">&quot;degree&quot;</span><span class="s2">: </span><span class="s1">int</span><span class="s2">(</span><span class="s1">test_data</span><span class="s2">[</span><span class="s3">&quot;degree&quot;</span><span class="s2">]),</span>
            <span class="s0"># integer, or None</span>
            <span class="s3">&quot;df&quot;</span><span class="s2">: </span><span class="s1">eval</span><span class="s2">(</span><span class="s1">test_data</span><span class="s2">[</span><span class="s3">&quot;df&quot;</span><span class="s2">]),</span>
            <span class="s0"># np.array() call, or None</span>
            <span class="s3">&quot;knots&quot;</span><span class="s2">: </span><span class="s1">eval</span><span class="s2">(</span><span class="s1">test_data</span><span class="s2">[</span><span class="s3">&quot;knots&quot;</span><span class="s2">]),</span>
            <span class="s2">}</span>
        <span class="s4">if </span><span class="s1">test_data</span><span class="s2">[</span><span class="s3">&quot;Boundary.knots&quot;</span><span class="s2">] != </span><span class="s3">&quot;None&quot;</span><span class="s2">:</span>
            <span class="s1">lower</span><span class="s2">, </span><span class="s1">upper </span><span class="s2">= </span><span class="s1">eval</span><span class="s2">(</span><span class="s1">test_data</span><span class="s2">[</span><span class="s3">&quot;Boundary.knots&quot;</span><span class="s2">])</span>
            <span class="s1">kwargs</span><span class="s2">[</span><span class="s3">&quot;lower_bound&quot;</span><span class="s2">] = </span><span class="s1">lower</span>
            <span class="s1">kwargs</span><span class="s2">[</span><span class="s3">&quot;upper_bound&quot;</span><span class="s2">] = </span><span class="s1">upper</span>
        <span class="s1">kwargs</span><span class="s2">[</span><span class="s3">&quot;include_intercept&quot;</span><span class="s2">] = (</span><span class="s1">test_data</span><span class="s2">[</span><span class="s3">&quot;intercept&quot;</span><span class="s2">] == </span><span class="s3">&quot;TRUE&quot;</span><span class="s2">)</span>
        <span class="s0"># Special case: in R, setting intercept=TRUE increases the effective</span>
        <span class="s0"># dof by 1. Adjust our arguments to match.</span>
        <span class="s0"># if kwargs[&quot;df&quot;] is not None and kwargs[&quot;include_intercept&quot;]:</span>
        <span class="s0">#     kwargs[&quot;df&quot;] += 1</span>
        <span class="s1">output </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">eval</span><span class="s2">(</span><span class="s1">test_data</span><span class="s2">[</span><span class="s3">&quot;output&quot;</span><span class="s2">]))</span>
        <span class="s4">if </span><span class="s1">kwargs</span><span class="s2">[</span><span class="s3">&quot;df&quot;</span><span class="s2">] </span><span class="s4">is not None</span><span class="s2">:</span>
            <span class="s4">assert </span><span class="s1">output</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">1</span><span class="s2">] == </span><span class="s1">kwargs</span><span class="s2">[</span><span class="s3">&quot;df&quot;</span><span class="s2">]</span>
        <span class="s0"># Do the actual test</span>
        <span class="s1">check_stateful</span><span class="s2">(</span><span class="s1">BS</span><span class="s2">, </span><span class="s4">False</span><span class="s2">, </span><span class="s1">R_bs_test_x</span><span class="s2">, </span><span class="s1">output</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>
        <span class="s1">tests_ran </span><span class="s2">+= </span><span class="s5">1</span>
        <span class="s0"># Set up for the next one</span>
        <span class="s1">start_idx </span><span class="s2">= </span><span class="s1">stop_idx </span><span class="s2">+ </span><span class="s5">1</span>
    <span class="s4">assert </span><span class="s1">tests_ran </span><span class="s2">== </span><span class="s1">R_bs_num_tests</span>

<span class="s1">test_bs_compat</span><span class="s2">.</span><span class="s1">slow </span><span class="s2">= </span><span class="s5">1</span>

<span class="s0"># This isn't checked by the above, because R doesn't have zero degree</span>
<span class="s0"># b-splines.</span>
<span class="s4">def </span><span class="s1">test_bs_0degree</span><span class="s2">():</span>
    <span class="s1">x </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">logspace</span><span class="s2">(-</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">10</span><span class="s2">)</span>
    <span class="s1">result </span><span class="s2">= </span><span class="s1">bs</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">knots</span><span class="s2">=[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">4</span><span class="s2">], </span><span class="s1">degree</span><span class="s2">=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">include_intercept</span><span class="s2">=</span><span class="s4">True</span><span class="s2">)</span>
    <span class="s4">assert </span><span class="s1">result</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">1</span><span class="s2">] == </span><span class="s5">3</span>
    <span class="s1">expected_0 </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">(</span><span class="s5">10</span><span class="s2">)</span>
    <span class="s1">expected_0</span><span class="s2">[</span><span class="s1">x </span><span class="s2">&lt; </span><span class="s5">1</span><span class="s2">] = </span><span class="s5">1</span>
    <span class="s4">assert </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array_equal</span><span class="s2">(</span><span class="s1">result</span><span class="s2">[:, </span><span class="s5">0</span><span class="s2">], </span><span class="s1">expected_0</span><span class="s2">)</span>
    <span class="s1">expected_1 </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">(</span><span class="s5">10</span><span class="s2">)</span>
    <span class="s1">expected_1</span><span class="s2">[(</span><span class="s1">x </span><span class="s2">&gt;= </span><span class="s5">1</span><span class="s2">) &amp; (</span><span class="s1">x </span><span class="s2">&lt; </span><span class="s5">4</span><span class="s2">)] = </span><span class="s5">1</span>
    <span class="s4">assert </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array_equal</span><span class="s2">(</span><span class="s1">result</span><span class="s2">[:, </span><span class="s5">1</span><span class="s2">], </span><span class="s1">expected_1</span><span class="s2">)</span>
    <span class="s1">expected_2 </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">(</span><span class="s5">10</span><span class="s2">)</span>
    <span class="s1">expected_2</span><span class="s2">[</span><span class="s1">x </span><span class="s2">&gt;= </span><span class="s5">4</span><span class="s2">] = </span><span class="s5">1</span>
    <span class="s4">assert </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array_equal</span><span class="s2">(</span><span class="s1">result</span><span class="s2">[:, </span><span class="s5">2</span><span class="s2">], </span><span class="s1">expected_2</span><span class="s2">)</span>
    <span class="s0"># Check handling of points that exactly fall on knots. They arbitrarily</span>
    <span class="s0"># get included into the larger region, not the smaller. This is consistent</span>
    <span class="s0"># with Python's half-open interval convention -- each basis function is</span>
    <span class="s0"># constant on [knot[i], knot[i + 1]).</span>
    <span class="s4">assert </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array_equal</span><span class="s2">(</span><span class="s1">bs</span><span class="s2">([</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">], </span><span class="s1">degree</span><span class="s2">=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">knots</span><span class="s2">=[</span><span class="s5">1</span><span class="s2">],</span>
                             <span class="s1">include_intercept</span><span class="s2">=</span><span class="s4">True</span><span class="s2">),</span>
                          <span class="s2">[[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">],</span>
                           <span class="s2">[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">],</span>
                           <span class="s2">[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">]])</span>

    <span class="s1">result_int </span><span class="s2">= </span><span class="s1">bs</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">knots</span><span class="s2">=[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">4</span><span class="s2">], </span><span class="s1">degree</span><span class="s2">=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">include_intercept</span><span class="s2">=</span><span class="s4">True</span><span class="s2">)</span>
    <span class="s1">result_no_int </span><span class="s2">= </span><span class="s1">bs</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">knots</span><span class="s2">=[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">4</span><span class="s2">], </span><span class="s1">degree</span><span class="s2">=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">include_intercept</span><span class="s2">=</span><span class="s4">False</span><span class="s2">)</span>
    <span class="s4">assert </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array_equal</span><span class="s2">(</span><span class="s1">result_int</span><span class="s2">[:, </span><span class="s5">1</span><span class="s2">:], </span><span class="s1">result_no_int</span><span class="s2">)</span>

<span class="s4">def </span><span class="s1">test_bs_errors</span><span class="s2">():</span>
    <span class="s4">import </span><span class="s1">pytest</span>
    <span class="s1">x </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linspace</span><span class="s2">(-</span><span class="s5">10</span><span class="s2">, </span><span class="s5">10</span><span class="s2">, </span><span class="s5">20</span><span class="s2">)</span>
    <span class="s0"># error checks:</span>
    <span class="s0"># out of bounds</span>
    <span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">NotImplementedError</span><span class="s2">, </span><span class="s1">bs</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s1">lower_bound</span><span class="s2">=</span><span class="s5">0</span><span class="s2">)</span>
    <span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">NotImplementedError</span><span class="s2">, </span><span class="s1">bs</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s1">upper_bound</span><span class="s2">=</span><span class="s5">0</span><span class="s2">)</span>
    <span class="s0"># must specify df or knots</span>
    <span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">ValueError</span><span class="s2">, </span><span class="s1">bs</span><span class="s2">, </span><span class="s1">x</span><span class="s2">)</span>
    <span class="s0"># df/knots match/mismatch (with and without intercept)</span>
    <span class="s0">#   match:</span>
    <span class="s1">bs</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">df</span><span class="s2">=</span><span class="s5">10</span><span class="s2">, </span><span class="s1">include_intercept</span><span class="s2">=</span><span class="s4">False</span><span class="s2">, </span><span class="s1">knots</span><span class="s2">=[</span><span class="s5">0</span><span class="s2">] * </span><span class="s5">7</span><span class="s2">)</span>
    <span class="s1">bs</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">df</span><span class="s2">=</span><span class="s5">10</span><span class="s2">, </span><span class="s1">include_intercept</span><span class="s2">=</span><span class="s4">True</span><span class="s2">, </span><span class="s1">knots</span><span class="s2">=[</span><span class="s5">0</span><span class="s2">] * </span><span class="s5">6</span><span class="s2">)</span>
    <span class="s1">bs</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">df</span><span class="s2">=</span><span class="s5">10</span><span class="s2">, </span><span class="s1">include_intercept</span><span class="s2">=</span><span class="s4">False</span><span class="s2">, </span><span class="s1">knots</span><span class="s2">=[</span><span class="s5">0</span><span class="s2">] * </span><span class="s5">9</span><span class="s2">, </span><span class="s1">degree</span><span class="s2">=</span><span class="s5">1</span><span class="s2">)</span>
    <span class="s1">bs</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">df</span><span class="s2">=</span><span class="s5">10</span><span class="s2">, </span><span class="s1">include_intercept</span><span class="s2">=</span><span class="s4">True</span><span class="s2">, </span><span class="s1">knots</span><span class="s2">=[</span><span class="s5">0</span><span class="s2">] * </span><span class="s5">8</span><span class="s2">, </span><span class="s1">degree</span><span class="s2">=</span><span class="s5">1</span><span class="s2">)</span>
    <span class="s0">#   too many knots:</span>
    <span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">ValueError</span><span class="s2">,</span>
                  <span class="s1">bs</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">df</span><span class="s2">=</span><span class="s5">10</span><span class="s2">, </span><span class="s1">include_intercept</span><span class="s2">=</span><span class="s4">False</span><span class="s2">, </span><span class="s1">knots</span><span class="s2">=[</span><span class="s5">0</span><span class="s2">] * </span><span class="s5">8</span><span class="s2">)</span>
    <span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">ValueError</span><span class="s2">,</span>
                  <span class="s1">bs</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">df</span><span class="s2">=</span><span class="s5">10</span><span class="s2">, </span><span class="s1">include_intercept</span><span class="s2">=</span><span class="s4">True</span><span class="s2">, </span><span class="s1">knots</span><span class="s2">=[</span><span class="s5">0</span><span class="s2">] * </span><span class="s5">7</span><span class="s2">)</span>
    <span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">ValueError</span><span class="s2">,</span>
                  <span class="s1">bs</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">df</span><span class="s2">=</span><span class="s5">10</span><span class="s2">, </span><span class="s1">include_intercept</span><span class="s2">=</span><span class="s4">False</span><span class="s2">, </span><span class="s1">knots</span><span class="s2">=[</span><span class="s5">0</span><span class="s2">] * </span><span class="s5">10</span><span class="s2">,</span>
                  <span class="s1">degree</span><span class="s2">=</span><span class="s5">1</span><span class="s2">)</span>
    <span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">ValueError</span><span class="s2">,</span>
                  <span class="s1">bs</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">df</span><span class="s2">=</span><span class="s5">10</span><span class="s2">, </span><span class="s1">include_intercept</span><span class="s2">=</span><span class="s4">True</span><span class="s2">, </span><span class="s1">knots</span><span class="s2">=[</span><span class="s5">0</span><span class="s2">] * </span><span class="s5">9</span><span class="s2">,</span>
                  <span class="s1">degree</span><span class="s2">=</span><span class="s5">1</span><span class="s2">)</span>
    <span class="s0">#   too few knots:</span>
    <span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">ValueError</span><span class="s2">,</span>
                  <span class="s1">bs</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">df</span><span class="s2">=</span><span class="s5">10</span><span class="s2">, </span><span class="s1">include_intercept</span><span class="s2">=</span><span class="s4">False</span><span class="s2">, </span><span class="s1">knots</span><span class="s2">=[</span><span class="s5">0</span><span class="s2">] * </span><span class="s5">6</span><span class="s2">)</span>
    <span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">ValueError</span><span class="s2">,</span>
                  <span class="s1">bs</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">df</span><span class="s2">=</span><span class="s5">10</span><span class="s2">, </span><span class="s1">include_intercept</span><span class="s2">=</span><span class="s4">True</span><span class="s2">, </span><span class="s1">knots</span><span class="s2">=[</span><span class="s5">0</span><span class="s2">] * </span><span class="s5">5</span><span class="s2">)</span>
    <span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">ValueError</span><span class="s2">,</span>
                  <span class="s1">bs</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">df</span><span class="s2">=</span><span class="s5">10</span><span class="s2">, </span><span class="s1">include_intercept</span><span class="s2">=</span><span class="s4">False</span><span class="s2">, </span><span class="s1">knots</span><span class="s2">=[</span><span class="s5">0</span><span class="s2">] * </span><span class="s5">8</span><span class="s2">,</span>
                  <span class="s1">degree</span><span class="s2">=</span><span class="s5">1</span><span class="s2">)</span>
    <span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">ValueError</span><span class="s2">,</span>
                  <span class="s1">bs</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">df</span><span class="s2">=</span><span class="s5">10</span><span class="s2">, </span><span class="s1">include_intercept</span><span class="s2">=</span><span class="s4">True</span><span class="s2">, </span><span class="s1">knots</span><span class="s2">=[</span><span class="s5">0</span><span class="s2">] * </span><span class="s5">7</span><span class="s2">,</span>
                  <span class="s1">degree</span><span class="s2">=</span><span class="s5">1</span><span class="s2">)</span>
    <span class="s0"># df too small</span>
    <span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">ValueError</span><span class="s2">,</span>
                  <span class="s1">bs</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">df</span><span class="s2">=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">degree</span><span class="s2">=</span><span class="s5">3</span><span class="s2">)</span>
    <span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">ValueError</span><span class="s2">,</span>
                  <span class="s1">bs</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">df</span><span class="s2">=</span><span class="s5">3</span><span class="s2">, </span><span class="s1">degree</span><span class="s2">=</span><span class="s5">5</span><span class="s2">)</span>
    <span class="s0"># bad degree</span>
    <span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">ValueError</span><span class="s2">,</span>
                  <span class="s1">bs</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">df</span><span class="s2">=</span><span class="s5">10</span><span class="s2">, </span><span class="s1">degree</span><span class="s2">=-</span><span class="s5">1</span><span class="s2">)</span>
    <span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">ValueError</span><span class="s2">,</span>
                  <span class="s1">bs</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">df</span><span class="s2">=</span><span class="s5">10</span><span class="s2">, </span><span class="s1">degree</span><span class="s2">=</span><span class="s5">1.5</span><span class="s2">)</span>
    <span class="s0"># upper_bound &lt; lower_bound</span>
    <span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">ValueError</span><span class="s2">,</span>
                  <span class="s1">bs</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s1">lower_bound</span><span class="s2">=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">upper_bound</span><span class="s2">=-</span><span class="s5">1</span><span class="s2">)</span>
    <span class="s0"># multidimensional input</span>
    <span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">ValueError</span><span class="s2">,</span>
                  <span class="s1">bs</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">column_stack</span><span class="s2">((</span><span class="s1">x</span><span class="s2">, </span><span class="s1">x</span><span class="s2">)), </span><span class="s5">3</span><span class="s2">)</span>
    <span class="s0"># unsorted knots are okay, and get sorted</span>
    <span class="s4">assert </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array_equal</span><span class="s2">(</span><span class="s1">bs</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">knots</span><span class="s2">=[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">4</span><span class="s2">]), </span><span class="s1">bs</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">knots</span><span class="s2">=[</span><span class="s5">4</span><span class="s2">, </span><span class="s5">1</span><span class="s2">]))</span>
    <span class="s0"># 2d knots</span>
    <span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">ValueError</span><span class="s2">,</span>
                  <span class="s1">bs</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">knots</span><span class="s2">=[[</span><span class="s5">0</span><span class="s2">], [</span><span class="s5">20</span><span class="s2">]])</span>
    <span class="s0"># knots &gt; upper_bound</span>
    <span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">ValueError</span><span class="s2">,</span>
                  <span class="s1">bs</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">knots</span><span class="s2">=[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">20</span><span class="s2">])</span>
    <span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">ValueError</span><span class="s2">,</span>
                  <span class="s1">bs</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">knots</span><span class="s2">=[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">4</span><span class="s2">], </span><span class="s1">upper_bound</span><span class="s2">=</span><span class="s5">3</span><span class="s2">)</span>
    <span class="s0"># knots &lt; lower_bound</span>
    <span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">ValueError</span><span class="s2">,</span>
                  <span class="s1">bs</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">knots</span><span class="s2">=[-</span><span class="s5">20</span><span class="s2">, </span><span class="s5">0</span><span class="s2">])</span>
    <span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">ValueError</span><span class="s2">,</span>
                  <span class="s1">bs</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">knots</span><span class="s2">=[-</span><span class="s5">4</span><span class="s2">, </span><span class="s5">0</span><span class="s2">], </span><span class="s1">lower_bound</span><span class="s2">=-</span><span class="s5">3</span><span class="s2">)</span>



<span class="s0"># differences between bs and ns (since the R code is a pile of copy-paste):</span>
<span class="s0"># - degree is always 3</span>
<span class="s0"># - different number of interior knots given df (b/c fewer dof used at edges I</span>
<span class="s0">#   guess)</span>
<span class="s0"># - boundary knots always repeated exactly 4 times (same as bs with degree=3)</span>
<span class="s0"># - complications at the end to handle boundary conditions</span>
<span class="s0"># the 'rcs' function uses slightly different conventions -- in particular it</span>
<span class="s0"># picks boundary knots that are not quite at the edges of the data, which</span>
<span class="s0"># makes sense for a natural spline.</span>
</pre>
</body>
</html>