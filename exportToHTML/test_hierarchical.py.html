<html>
<head>
<title>test_hierarchical.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #7a7e85;}
.s3 { color: #cf8e6d;}
.s4 { color: #bcbec4;}
.s5 { color: #2aacb8;}
.s6 { color: #6aab73;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_hierarchical.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Several basic tests for hierarchical clustering procedures 
 
&quot;&quot;&quot;</span>

<span class="s2"># Authors: Vincent Michel, 2010, Gael Varoquaux 2012,</span>
<span class="s2">#          Matteo Visconti di Oleggio Castello 2014</span>
<span class="s2"># License: BSD 3 clause</span>
<span class="s3">import </span><span class="s1">itertools</span>
<span class="s3">import </span><span class="s1">shutil</span>
<span class="s3">from </span><span class="s1">functools </span><span class="s3">import </span><span class="s1">partial</span>
<span class="s3">from </span><span class="s1">tempfile </span><span class="s3">import </span><span class="s1">mkdtemp</span>

<span class="s3">import </span><span class="s1">numpy </span><span class="s3">as </span><span class="s1">np</span>
<span class="s3">import </span><span class="s1">pytest</span>
<span class="s3">from </span><span class="s1">scipy</span><span class="s4">.</span><span class="s1">cluster </span><span class="s3">import </span><span class="s1">hierarchy</span>
<span class="s3">from </span><span class="s1">scipy</span><span class="s4">.</span><span class="s1">sparse</span><span class="s4">.</span><span class="s1">csgraph </span><span class="s3">import </span><span class="s1">connected_components</span>

<span class="s3">from </span><span class="s1">sklearn</span><span class="s4">.</span><span class="s1">cluster </span><span class="s3">import </span><span class="s1">AgglomerativeClustering</span><span class="s4">, </span><span class="s1">FeatureAgglomeration</span><span class="s4">, </span><span class="s1">ward_tree</span>
<span class="s3">from </span><span class="s1">sklearn</span><span class="s4">.</span><span class="s1">cluster</span><span class="s4">.</span><span class="s1">_agglomerative </span><span class="s3">import </span><span class="s4">(</span>
    <span class="s1">_TREE_BUILDERS</span><span class="s4">,</span>
    <span class="s1">_fix_connectivity</span><span class="s4">,</span>
    <span class="s1">_hc_cut</span><span class="s4">,</span>
    <span class="s1">linkage_tree</span><span class="s4">,</span>
<span class="s4">)</span>
<span class="s3">from </span><span class="s1">sklearn</span><span class="s4">.</span><span class="s1">cluster</span><span class="s4">.</span><span class="s1">_hierarchical_fast </span><span class="s3">import </span><span class="s4">(</span>
    <span class="s1">average_merge</span><span class="s4">,</span>
    <span class="s1">max_merge</span><span class="s4">,</span>
    <span class="s1">mst_linkage_core</span><span class="s4">,</span>
<span class="s4">)</span>
<span class="s3">from </span><span class="s1">sklearn</span><span class="s4">.</span><span class="s1">datasets </span><span class="s3">import </span><span class="s1">make_circles</span><span class="s4">, </span><span class="s1">make_moons</span>
<span class="s3">from </span><span class="s1">sklearn</span><span class="s4">.</span><span class="s1">feature_extraction</span><span class="s4">.</span><span class="s1">image </span><span class="s3">import </span><span class="s1">grid_to_graph</span>
<span class="s3">from </span><span class="s1">sklearn</span><span class="s4">.</span><span class="s1">metrics </span><span class="s3">import </span><span class="s1">DistanceMetric</span>
<span class="s3">from </span><span class="s1">sklearn</span><span class="s4">.</span><span class="s1">metrics</span><span class="s4">.</span><span class="s1">cluster </span><span class="s3">import </span><span class="s1">adjusted_rand_score</span><span class="s4">, </span><span class="s1">normalized_mutual_info_score</span>
<span class="s3">from </span><span class="s1">sklearn</span><span class="s4">.</span><span class="s1">metrics</span><span class="s4">.</span><span class="s1">pairwise </span><span class="s3">import </span><span class="s4">(</span>
    <span class="s1">PAIRED_DISTANCES</span><span class="s4">,</span>
    <span class="s1">cosine_distances</span><span class="s4">,</span>
    <span class="s1">manhattan_distances</span><span class="s4">,</span>
    <span class="s1">pairwise_distances</span><span class="s4">,</span>
<span class="s4">)</span>
<span class="s3">from </span><span class="s1">sklearn</span><span class="s4">.</span><span class="s1">metrics</span><span class="s4">.</span><span class="s1">tests</span><span class="s4">.</span><span class="s1">test_dist_metrics </span><span class="s3">import </span><span class="s1">METRICS_DEFAULT_PARAMS</span>
<span class="s3">from </span><span class="s1">sklearn</span><span class="s4">.</span><span class="s1">neighbors </span><span class="s3">import </span><span class="s1">kneighbors_graph</span>
<span class="s3">from </span><span class="s1">sklearn</span><span class="s4">.</span><span class="s1">utils</span><span class="s4">.</span><span class="s1">_fast_dict </span><span class="s3">import </span><span class="s1">IntFloatDict</span>
<span class="s3">from </span><span class="s1">sklearn</span><span class="s4">.</span><span class="s1">utils</span><span class="s4">.</span><span class="s1">_testing </span><span class="s3">import </span><span class="s4">(</span>
    <span class="s1">assert_almost_equal</span><span class="s4">,</span>
    <span class="s1">assert_array_almost_equal</span><span class="s4">,</span>
    <span class="s1">assert_array_equal</span><span class="s4">,</span>
    <span class="s1">create_memmap_backed_data</span><span class="s4">,</span>
    <span class="s1">ignore_warnings</span><span class="s4">,</span>
<span class="s4">)</span>
<span class="s3">from </span><span class="s1">sklearn</span><span class="s4">.</span><span class="s1">utils</span><span class="s4">.</span><span class="s1">fixes </span><span class="s3">import </span><span class="s1">LIL_CONTAINERS</span>


<span class="s3">def </span><span class="s1">test_linkage_misc</span><span class="s4">():</span>
    <span class="s2"># Misc tests on linkage</span>
    <span class="s1">rng </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">random</span><span class="s4">.</span><span class="s1">RandomState</span><span class="s4">(</span><span class="s5">42</span><span class="s4">)</span>
    <span class="s1">X </span><span class="s4">= </span><span class="s1">rng</span><span class="s4">.</span><span class="s1">normal</span><span class="s4">(</span><span class="s1">size</span><span class="s4">=(</span><span class="s5">5</span><span class="s4">, </span><span class="s5">5</span><span class="s4">))</span>

    <span class="s3">with </span><span class="s1">pytest</span><span class="s4">.</span><span class="s1">raises</span><span class="s4">(</span><span class="s1">ValueError</span><span class="s4">):</span>
        <span class="s1">linkage_tree</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">linkage</span><span class="s4">=</span><span class="s6">&quot;foo&quot;</span><span class="s4">)</span>

    <span class="s3">with </span><span class="s1">pytest</span><span class="s4">.</span><span class="s1">raises</span><span class="s4">(</span><span class="s1">ValueError</span><span class="s4">):</span>
        <span class="s1">linkage_tree</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">connectivity</span><span class="s4">=</span><span class="s1">np</span><span class="s4">.</span><span class="s1">ones</span><span class="s4">((</span><span class="s5">4</span><span class="s4">, </span><span class="s5">4</span><span class="s4">)))</span>

    <span class="s2"># Smoke test FeatureAgglomeration</span>
    <span class="s1">FeatureAgglomeration</span><span class="s4">().</span><span class="s1">fit</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)</span>

    <span class="s2"># test hierarchical clustering on a precomputed distances matrix</span>
    <span class="s1">dis </span><span class="s4">= </span><span class="s1">cosine_distances</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)</span>

    <span class="s1">res </span><span class="s4">= </span><span class="s1">linkage_tree</span><span class="s4">(</span><span class="s1">dis</span><span class="s4">, </span><span class="s1">affinity</span><span class="s4">=</span><span class="s6">&quot;precomputed&quot;</span><span class="s4">)</span>
    <span class="s1">assert_array_equal</span><span class="s4">(</span><span class="s1">res</span><span class="s4">[</span><span class="s5">0</span><span class="s4">], </span><span class="s1">linkage_tree</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">affinity</span><span class="s4">=</span><span class="s6">&quot;cosine&quot;</span><span class="s4">)[</span><span class="s5">0</span><span class="s4">])</span>

    <span class="s2"># test hierarchical clustering on a precomputed distances matrix</span>
    <span class="s1">res </span><span class="s4">= </span><span class="s1">linkage_tree</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">affinity</span><span class="s4">=</span><span class="s1">manhattan_distances</span><span class="s4">)</span>
    <span class="s1">assert_array_equal</span><span class="s4">(</span><span class="s1">res</span><span class="s4">[</span><span class="s5">0</span><span class="s4">], </span><span class="s1">linkage_tree</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">affinity</span><span class="s4">=</span><span class="s6">&quot;manhattan&quot;</span><span class="s4">)[</span><span class="s5">0</span><span class="s4">])</span>


<span class="s3">def </span><span class="s1">test_structured_linkage_tree</span><span class="s4">():</span>
    <span class="s2"># Check that we obtain the correct solution for structured linkage trees.</span>
    <span class="s1">rng </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">random</span><span class="s4">.</span><span class="s1">RandomState</span><span class="s4">(</span><span class="s5">0</span><span class="s4">)</span>
    <span class="s1">mask </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">ones</span><span class="s4">([</span><span class="s5">10</span><span class="s4">, </span><span class="s5">10</span><span class="s4">], </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">bool</span><span class="s4">)</span>
    <span class="s2"># Avoiding a mask with only 'True' entries</span>
    <span class="s1">mask</span><span class="s4">[</span><span class="s5">4</span><span class="s4">:</span><span class="s5">7</span><span class="s4">, </span><span class="s5">4</span><span class="s4">:</span><span class="s5">7</span><span class="s4">] = </span><span class="s5">0</span>
    <span class="s1">X </span><span class="s4">= </span><span class="s1">rng</span><span class="s4">.</span><span class="s1">randn</span><span class="s4">(</span><span class="s5">50</span><span class="s4">, </span><span class="s5">100</span><span class="s4">)</span>
    <span class="s1">connectivity </span><span class="s4">= </span><span class="s1">grid_to_graph</span><span class="s4">(*</span><span class="s1">mask</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">)</span>
    <span class="s3">for </span><span class="s1">tree_builder </span><span class="s3">in </span><span class="s1">_TREE_BUILDERS</span><span class="s4">.</span><span class="s1">values</span><span class="s4">():</span>
        <span class="s1">children</span><span class="s4">, </span><span class="s1">n_components</span><span class="s4">, </span><span class="s1">n_leaves</span><span class="s4">, </span><span class="s1">parent </span><span class="s4">= </span><span class="s1">tree_builder</span><span class="s4">(</span>
            <span class="s1">X</span><span class="s4">.</span><span class="s1">T</span><span class="s4">, </span><span class="s1">connectivity</span><span class="s4">=</span><span class="s1">connectivity</span>
        <span class="s4">)</span>
        <span class="s1">n_nodes </span><span class="s4">= </span><span class="s5">2 </span><span class="s4">* </span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s5">1</span><span class="s4">] - </span><span class="s5">1</span>
        <span class="s3">assert </span><span class="s1">len</span><span class="s4">(</span><span class="s1">children</span><span class="s4">) + </span><span class="s1">n_leaves </span><span class="s4">== </span><span class="s1">n_nodes</span>
        <span class="s2"># Check that ward_tree raises a ValueError with a connectivity matrix</span>
        <span class="s2"># of the wrong shape</span>
        <span class="s3">with </span><span class="s1">pytest</span><span class="s4">.</span><span class="s1">raises</span><span class="s4">(</span><span class="s1">ValueError</span><span class="s4">):</span>
            <span class="s1">tree_builder</span><span class="s4">(</span><span class="s1">X</span><span class="s4">.</span><span class="s1">T</span><span class="s4">, </span><span class="s1">connectivity</span><span class="s4">=</span><span class="s1">np</span><span class="s4">.</span><span class="s1">ones</span><span class="s4">((</span><span class="s5">4</span><span class="s4">, </span><span class="s5">4</span><span class="s4">)))</span>
        <span class="s2"># Check that fitting with no samples raises an error</span>
        <span class="s3">with </span><span class="s1">pytest</span><span class="s4">.</span><span class="s1">raises</span><span class="s4">(</span><span class="s1">ValueError</span><span class="s4">):</span>
            <span class="s1">tree_builder</span><span class="s4">(</span><span class="s1">X</span><span class="s4">.</span><span class="s1">T</span><span class="s4">[:</span><span class="s5">0</span><span class="s4">], </span><span class="s1">connectivity</span><span class="s4">=</span><span class="s1">connectivity</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">test_unstructured_linkage_tree</span><span class="s4">():</span>
    <span class="s2"># Check that we obtain the correct solution for unstructured linkage trees.</span>
    <span class="s1">rng </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">random</span><span class="s4">.</span><span class="s1">RandomState</span><span class="s4">(</span><span class="s5">0</span><span class="s4">)</span>
    <span class="s1">X </span><span class="s4">= </span><span class="s1">rng</span><span class="s4">.</span><span class="s1">randn</span><span class="s4">(</span><span class="s5">50</span><span class="s4">, </span><span class="s5">100</span><span class="s4">)</span>
    <span class="s3">for </span><span class="s1">this_X </span><span class="s3">in </span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">X</span><span class="s4">[</span><span class="s5">0</span><span class="s4">]):</span>
        <span class="s2"># With specified a number of clusters just for the sake of</span>
        <span class="s2"># raising a warning and testing the warning code</span>
        <span class="s3">with </span><span class="s1">ignore_warnings</span><span class="s4">():</span>
            <span class="s3">with </span><span class="s1">pytest</span><span class="s4">.</span><span class="s1">warns</span><span class="s4">(</span><span class="s1">UserWarning</span><span class="s4">):</span>
                <span class="s1">children</span><span class="s4">, </span><span class="s1">n_nodes</span><span class="s4">, </span><span class="s1">n_leaves</span><span class="s4">, </span><span class="s1">parent </span><span class="s4">= </span><span class="s1">ward_tree</span><span class="s4">(</span><span class="s1">this_X</span><span class="s4">.</span><span class="s1">T</span><span class="s4">, </span><span class="s1">n_clusters</span><span class="s4">=</span><span class="s5">10</span><span class="s4">)</span>
        <span class="s1">n_nodes </span><span class="s4">= </span><span class="s5">2 </span><span class="s4">* </span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s5">1</span><span class="s4">] - </span><span class="s5">1</span>
        <span class="s3">assert </span><span class="s1">len</span><span class="s4">(</span><span class="s1">children</span><span class="s4">) + </span><span class="s1">n_leaves </span><span class="s4">== </span><span class="s1">n_nodes</span>

    <span class="s3">for </span><span class="s1">tree_builder </span><span class="s3">in </span><span class="s1">_TREE_BUILDERS</span><span class="s4">.</span><span class="s1">values</span><span class="s4">():</span>
        <span class="s3">for </span><span class="s1">this_X </span><span class="s3">in </span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">X</span><span class="s4">[</span><span class="s5">0</span><span class="s4">]):</span>
            <span class="s3">with </span><span class="s1">ignore_warnings</span><span class="s4">():</span>
                <span class="s3">with </span><span class="s1">pytest</span><span class="s4">.</span><span class="s1">warns</span><span class="s4">(</span><span class="s1">UserWarning</span><span class="s4">):</span>
                    <span class="s1">children</span><span class="s4">, </span><span class="s1">n_nodes</span><span class="s4">, </span><span class="s1">n_leaves</span><span class="s4">, </span><span class="s1">parent </span><span class="s4">= </span><span class="s1">tree_builder</span><span class="s4">(</span>
                        <span class="s1">this_X</span><span class="s4">.</span><span class="s1">T</span><span class="s4">, </span><span class="s1">n_clusters</span><span class="s4">=</span><span class="s5">10</span>
                    <span class="s4">)</span>
            <span class="s1">n_nodes </span><span class="s4">= </span><span class="s5">2 </span><span class="s4">* </span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s5">1</span><span class="s4">] - </span><span class="s5">1</span>
            <span class="s3">assert </span><span class="s1">len</span><span class="s4">(</span><span class="s1">children</span><span class="s4">) + </span><span class="s1">n_leaves </span><span class="s4">== </span><span class="s1">n_nodes</span>


<span class="s3">def </span><span class="s1">test_height_linkage_tree</span><span class="s4">():</span>
    <span class="s2"># Check that the height of the results of linkage tree is sorted.</span>
    <span class="s1">rng </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">random</span><span class="s4">.</span><span class="s1">RandomState</span><span class="s4">(</span><span class="s5">0</span><span class="s4">)</span>
    <span class="s1">mask </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">ones</span><span class="s4">([</span><span class="s5">10</span><span class="s4">, </span><span class="s5">10</span><span class="s4">], </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">bool</span><span class="s4">)</span>
    <span class="s1">X </span><span class="s4">= </span><span class="s1">rng</span><span class="s4">.</span><span class="s1">randn</span><span class="s4">(</span><span class="s5">50</span><span class="s4">, </span><span class="s5">100</span><span class="s4">)</span>
    <span class="s1">connectivity </span><span class="s4">= </span><span class="s1">grid_to_graph</span><span class="s4">(*</span><span class="s1">mask</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">)</span>
    <span class="s3">for </span><span class="s1">linkage_func </span><span class="s3">in </span><span class="s1">_TREE_BUILDERS</span><span class="s4">.</span><span class="s1">values</span><span class="s4">():</span>
        <span class="s1">children</span><span class="s4">, </span><span class="s1">n_nodes</span><span class="s4">, </span><span class="s1">n_leaves</span><span class="s4">, </span><span class="s1">parent </span><span class="s4">= </span><span class="s1">linkage_func</span><span class="s4">(</span>
            <span class="s1">X</span><span class="s4">.</span><span class="s1">T</span><span class="s4">, </span><span class="s1">connectivity</span><span class="s4">=</span><span class="s1">connectivity</span>
        <span class="s4">)</span>
        <span class="s1">n_nodes </span><span class="s4">= </span><span class="s5">2 </span><span class="s4">* </span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s5">1</span><span class="s4">] - </span><span class="s5">1</span>
        <span class="s3">assert </span><span class="s1">len</span><span class="s4">(</span><span class="s1">children</span><span class="s4">) + </span><span class="s1">n_leaves </span><span class="s4">== </span><span class="s1">n_nodes</span>


<span class="s3">def </span><span class="s1">test_zero_cosine_linkage_tree</span><span class="s4">():</span>
    <span class="s2"># Check that zero vectors in X produce an error when</span>
    <span class="s2"># 'cosine' affinity is used</span>
    <span class="s1">X </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">array</span><span class="s4">([[</span><span class="s5">0</span><span class="s4">, </span><span class="s5">1</span><span class="s4">], [</span><span class="s5">0</span><span class="s4">, </span><span class="s5">0</span><span class="s4">]])</span>
    <span class="s1">msg </span><span class="s4">= </span><span class="s6">&quot;Cosine affinity cannot be used when X contains zero vectors&quot;</span>
    <span class="s3">with </span><span class="s1">pytest</span><span class="s4">.</span><span class="s1">raises</span><span class="s4">(</span><span class="s1">ValueError</span><span class="s4">, </span><span class="s1">match</span><span class="s4">=</span><span class="s1">msg</span><span class="s4">):</span>
        <span class="s1">linkage_tree</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">affinity</span><span class="s4">=</span><span class="s6">&quot;cosine&quot;</span><span class="s4">)</span>


<span class="s4">@</span><span class="s1">pytest</span><span class="s4">.</span><span class="s1">mark</span><span class="s4">.</span><span class="s1">parametrize</span><span class="s4">(</span><span class="s6">&quot;n_clusters, distance_threshold&quot;</span><span class="s4">, [(</span><span class="s3">None</span><span class="s4">, </span><span class="s5">0.5</span><span class="s4">), (</span><span class="s5">10</span><span class="s4">, </span><span class="s3">None</span><span class="s4">)])</span>
<span class="s4">@</span><span class="s1">pytest</span><span class="s4">.</span><span class="s1">mark</span><span class="s4">.</span><span class="s1">parametrize</span><span class="s4">(</span><span class="s6">&quot;compute_distances&quot;</span><span class="s4">, [</span><span class="s3">True</span><span class="s4">, </span><span class="s3">False</span><span class="s4">])</span>
<span class="s4">@</span><span class="s1">pytest</span><span class="s4">.</span><span class="s1">mark</span><span class="s4">.</span><span class="s1">parametrize</span><span class="s4">(</span><span class="s6">&quot;linkage&quot;</span><span class="s4">, [</span><span class="s6">&quot;ward&quot;</span><span class="s4">, </span><span class="s6">&quot;complete&quot;</span><span class="s4">, </span><span class="s6">&quot;average&quot;</span><span class="s4">, </span><span class="s6">&quot;single&quot;</span><span class="s4">])</span>
<span class="s3">def </span><span class="s1">test_agglomerative_clustering_distances</span><span class="s4">(</span>
    <span class="s1">n_clusters</span><span class="s4">, </span><span class="s1">compute_distances</span><span class="s4">, </span><span class="s1">distance_threshold</span><span class="s4">, </span><span class="s1">linkage</span>
<span class="s4">):</span>
    <span class="s2"># Check that when `compute_distances` is True or `distance_threshold` is</span>
    <span class="s2"># given, the fitted model has an attribute `distances_`.</span>
    <span class="s1">rng </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">random</span><span class="s4">.</span><span class="s1">RandomState</span><span class="s4">(</span><span class="s5">0</span><span class="s4">)</span>
    <span class="s1">mask </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">ones</span><span class="s4">([</span><span class="s5">10</span><span class="s4">, </span><span class="s5">10</span><span class="s4">], </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">bool</span><span class="s4">)</span>
    <span class="s1">n_samples </span><span class="s4">= </span><span class="s5">100</span>
    <span class="s1">X </span><span class="s4">= </span><span class="s1">rng</span><span class="s4">.</span><span class="s1">randn</span><span class="s4">(</span><span class="s1">n_samples</span><span class="s4">, </span><span class="s5">50</span><span class="s4">)</span>
    <span class="s1">connectivity </span><span class="s4">= </span><span class="s1">grid_to_graph</span><span class="s4">(*</span><span class="s1">mask</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">)</span>

    <span class="s1">clustering </span><span class="s4">= </span><span class="s1">AgglomerativeClustering</span><span class="s4">(</span>
        <span class="s1">n_clusters</span><span class="s4">=</span><span class="s1">n_clusters</span><span class="s4">,</span>
        <span class="s1">connectivity</span><span class="s4">=</span><span class="s1">connectivity</span><span class="s4">,</span>
        <span class="s1">linkage</span><span class="s4">=</span><span class="s1">linkage</span><span class="s4">,</span>
        <span class="s1">distance_threshold</span><span class="s4">=</span><span class="s1">distance_threshold</span><span class="s4">,</span>
        <span class="s1">compute_distances</span><span class="s4">=</span><span class="s1">compute_distances</span><span class="s4">,</span>
    <span class="s4">)</span>
    <span class="s1">clustering</span><span class="s4">.</span><span class="s1">fit</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">compute_distances </span><span class="s3">or </span><span class="s4">(</span><span class="s1">distance_threshold </span><span class="s3">is not None</span><span class="s4">):</span>
        <span class="s3">assert </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">clustering</span><span class="s4">, </span><span class="s6">&quot;distances_&quot;</span><span class="s4">)</span>
        <span class="s1">n_children </span><span class="s4">= </span><span class="s1">clustering</span><span class="s4">.</span><span class="s1">children_</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s5">0</span><span class="s4">]</span>
        <span class="s1">n_nodes </span><span class="s4">= </span><span class="s1">n_children </span><span class="s4">+ </span><span class="s5">1</span>
        <span class="s3">assert </span><span class="s1">clustering</span><span class="s4">.</span><span class="s1">distances_</span><span class="s4">.</span><span class="s1">shape </span><span class="s4">== (</span><span class="s1">n_nodes </span><span class="s4">- </span><span class="s5">1</span><span class="s4">,)</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s3">assert not </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">clustering</span><span class="s4">, </span><span class="s6">&quot;distances_&quot;</span><span class="s4">)</span>


<span class="s4">@</span><span class="s1">pytest</span><span class="s4">.</span><span class="s1">mark</span><span class="s4">.</span><span class="s1">parametrize</span><span class="s4">(</span><span class="s6">&quot;lil_container&quot;</span><span class="s4">, </span><span class="s1">LIL_CONTAINERS</span><span class="s4">)</span>
<span class="s3">def </span><span class="s1">test_agglomerative_clustering</span><span class="s4">(</span><span class="s1">global_random_seed</span><span class="s4">, </span><span class="s1">lil_container</span><span class="s4">):</span>
    <span class="s2"># Check that we obtain the correct number of clusters with</span>
    <span class="s2"># agglomerative clustering.</span>
    <span class="s1">rng </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">random</span><span class="s4">.</span><span class="s1">RandomState</span><span class="s4">(</span><span class="s1">global_random_seed</span><span class="s4">)</span>
    <span class="s1">mask </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">ones</span><span class="s4">([</span><span class="s5">10</span><span class="s4">, </span><span class="s5">10</span><span class="s4">], </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">bool</span><span class="s4">)</span>
    <span class="s1">n_samples </span><span class="s4">= </span><span class="s5">100</span>
    <span class="s1">X </span><span class="s4">= </span><span class="s1">rng</span><span class="s4">.</span><span class="s1">randn</span><span class="s4">(</span><span class="s1">n_samples</span><span class="s4">, </span><span class="s5">50</span><span class="s4">)</span>
    <span class="s1">connectivity </span><span class="s4">= </span><span class="s1">grid_to_graph</span><span class="s4">(*</span><span class="s1">mask</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">)</span>
    <span class="s3">for </span><span class="s1">linkage </span><span class="s3">in </span><span class="s4">(</span><span class="s6">&quot;ward&quot;</span><span class="s4">, </span><span class="s6">&quot;complete&quot;</span><span class="s4">, </span><span class="s6">&quot;average&quot;</span><span class="s4">, </span><span class="s6">&quot;single&quot;</span><span class="s4">):</span>
        <span class="s1">clustering </span><span class="s4">= </span><span class="s1">AgglomerativeClustering</span><span class="s4">(</span>
            <span class="s1">n_clusters</span><span class="s4">=</span><span class="s5">10</span><span class="s4">, </span><span class="s1">connectivity</span><span class="s4">=</span><span class="s1">connectivity</span><span class="s4">, </span><span class="s1">linkage</span><span class="s4">=</span><span class="s1">linkage</span>
        <span class="s4">)</span>
        <span class="s1">clustering</span><span class="s4">.</span><span class="s1">fit</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)</span>
        <span class="s2"># test caching</span>
        <span class="s3">try</span><span class="s4">:</span>
            <span class="s1">tempdir </span><span class="s4">= </span><span class="s1">mkdtemp</span><span class="s4">()</span>
            <span class="s1">clustering </span><span class="s4">= </span><span class="s1">AgglomerativeClustering</span><span class="s4">(</span>
                <span class="s1">n_clusters</span><span class="s4">=</span><span class="s5">10</span><span class="s4">,</span>
                <span class="s1">connectivity</span><span class="s4">=</span><span class="s1">connectivity</span><span class="s4">,</span>
                <span class="s1">memory</span><span class="s4">=</span><span class="s1">tempdir</span><span class="s4">,</span>
                <span class="s1">linkage</span><span class="s4">=</span><span class="s1">linkage</span><span class="s4">,</span>
            <span class="s4">)</span>
            <span class="s1">clustering</span><span class="s4">.</span><span class="s1">fit</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)</span>
            <span class="s1">labels </span><span class="s4">= </span><span class="s1">clustering</span><span class="s4">.</span><span class="s1">labels_</span>
            <span class="s3">assert </span><span class="s1">np</span><span class="s4">.</span><span class="s1">size</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">unique</span><span class="s4">(</span><span class="s1">labels</span><span class="s4">)) == </span><span class="s5">10</span>
        <span class="s3">finally</span><span class="s4">:</span>
            <span class="s1">shutil</span><span class="s4">.</span><span class="s1">rmtree</span><span class="s4">(</span><span class="s1">tempdir</span><span class="s4">)</span>
        <span class="s2"># Turn caching off now</span>
        <span class="s1">clustering </span><span class="s4">= </span><span class="s1">AgglomerativeClustering</span><span class="s4">(</span>
            <span class="s1">n_clusters</span><span class="s4">=</span><span class="s5">10</span><span class="s4">, </span><span class="s1">connectivity</span><span class="s4">=</span><span class="s1">connectivity</span><span class="s4">, </span><span class="s1">linkage</span><span class="s4">=</span><span class="s1">linkage</span>
        <span class="s4">)</span>
        <span class="s2"># Check that we obtain the same solution with early-stopping of the</span>
        <span class="s2"># tree building</span>
        <span class="s1">clustering</span><span class="s4">.</span><span class="s1">compute_full_tree </span><span class="s4">= </span><span class="s3">False</span>
        <span class="s1">clustering</span><span class="s4">.</span><span class="s1">fit</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)</span>
        <span class="s1">assert_almost_equal</span><span class="s4">(</span><span class="s1">normalized_mutual_info_score</span><span class="s4">(</span><span class="s1">clustering</span><span class="s4">.</span><span class="s1">labels_</span><span class="s4">, </span><span class="s1">labels</span><span class="s4">), </span><span class="s5">1</span><span class="s4">)</span>
        <span class="s1">clustering</span><span class="s4">.</span><span class="s1">connectivity </span><span class="s4">= </span><span class="s3">None</span>
        <span class="s1">clustering</span><span class="s4">.</span><span class="s1">fit</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)</span>
        <span class="s3">assert </span><span class="s1">np</span><span class="s4">.</span><span class="s1">size</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">unique</span><span class="s4">(</span><span class="s1">clustering</span><span class="s4">.</span><span class="s1">labels_</span><span class="s4">)) == </span><span class="s5">10</span>
        <span class="s2"># Check that we raise a TypeError on dense matrices</span>
        <span class="s1">clustering </span><span class="s4">= </span><span class="s1">AgglomerativeClustering</span><span class="s4">(</span>
            <span class="s1">n_clusters</span><span class="s4">=</span><span class="s5">10</span><span class="s4">,</span>
            <span class="s1">connectivity</span><span class="s4">=</span><span class="s1">lil_container</span><span class="s4">(</span><span class="s1">connectivity</span><span class="s4">.</span><span class="s1">toarray</span><span class="s4">()[:</span><span class="s5">10</span><span class="s4">, :</span><span class="s5">10</span><span class="s4">]),</span>
            <span class="s1">linkage</span><span class="s4">=</span><span class="s1">linkage</span><span class="s4">,</span>
        <span class="s4">)</span>
        <span class="s3">with </span><span class="s1">pytest</span><span class="s4">.</span><span class="s1">raises</span><span class="s4">(</span><span class="s1">ValueError</span><span class="s4">):</span>
            <span class="s1">clustering</span><span class="s4">.</span><span class="s1">fit</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)</span>

    <span class="s2"># Test that using ward with another metric than euclidean raises an</span>
    <span class="s2"># exception</span>
    <span class="s1">clustering </span><span class="s4">= </span><span class="s1">AgglomerativeClustering</span><span class="s4">(</span>
        <span class="s1">n_clusters</span><span class="s4">=</span><span class="s5">10</span><span class="s4">,</span>
        <span class="s1">connectivity</span><span class="s4">=</span><span class="s1">connectivity</span><span class="s4">.</span><span class="s1">toarray</span><span class="s4">(),</span>
        <span class="s1">metric</span><span class="s4">=</span><span class="s6">&quot;manhattan&quot;</span><span class="s4">,</span>
        <span class="s1">linkage</span><span class="s4">=</span><span class="s6">&quot;ward&quot;</span><span class="s4">,</span>
    <span class="s4">)</span>
    <span class="s3">with </span><span class="s1">pytest</span><span class="s4">.</span><span class="s1">raises</span><span class="s4">(</span><span class="s1">ValueError</span><span class="s4">):</span>
        <span class="s1">clustering</span><span class="s4">.</span><span class="s1">fit</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)</span>

    <span class="s2"># Test using another metric than euclidean works with linkage complete</span>
    <span class="s3">for </span><span class="s1">metric </span><span class="s3">in </span><span class="s1">PAIRED_DISTANCES</span><span class="s4">.</span><span class="s1">keys</span><span class="s4">():</span>
        <span class="s2"># Compare our (structured) implementation to scipy</span>
        <span class="s1">clustering </span><span class="s4">= </span><span class="s1">AgglomerativeClustering</span><span class="s4">(</span>
            <span class="s1">n_clusters</span><span class="s4">=</span><span class="s5">10</span><span class="s4">,</span>
            <span class="s1">connectivity</span><span class="s4">=</span><span class="s1">np</span><span class="s4">.</span><span class="s1">ones</span><span class="s4">((</span><span class="s1">n_samples</span><span class="s4">, </span><span class="s1">n_samples</span><span class="s4">)),</span>
            <span class="s1">metric</span><span class="s4">=</span><span class="s1">metric</span><span class="s4">,</span>
            <span class="s1">linkage</span><span class="s4">=</span><span class="s6">&quot;complete&quot;</span><span class="s4">,</span>
        <span class="s4">)</span>
        <span class="s1">clustering</span><span class="s4">.</span><span class="s1">fit</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)</span>
        <span class="s1">clustering2 </span><span class="s4">= </span><span class="s1">AgglomerativeClustering</span><span class="s4">(</span>
            <span class="s1">n_clusters</span><span class="s4">=</span><span class="s5">10</span><span class="s4">, </span><span class="s1">connectivity</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">metric</span><span class="s4">=</span><span class="s1">metric</span><span class="s4">, </span><span class="s1">linkage</span><span class="s4">=</span><span class="s6">&quot;complete&quot;</span>
        <span class="s4">)</span>
        <span class="s1">clustering2</span><span class="s4">.</span><span class="s1">fit</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)</span>
        <span class="s1">assert_almost_equal</span><span class="s4">(</span>
            <span class="s1">normalized_mutual_info_score</span><span class="s4">(</span><span class="s1">clustering2</span><span class="s4">.</span><span class="s1">labels_</span><span class="s4">, </span><span class="s1">clustering</span><span class="s4">.</span><span class="s1">labels_</span><span class="s4">), </span><span class="s5">1</span>
        <span class="s4">)</span>

    <span class="s2"># Test that using a distance matrix (affinity = 'precomputed') has same</span>
    <span class="s2"># results (with connectivity constraints)</span>
    <span class="s1">clustering </span><span class="s4">= </span><span class="s1">AgglomerativeClustering</span><span class="s4">(</span>
        <span class="s1">n_clusters</span><span class="s4">=</span><span class="s5">10</span><span class="s4">, </span><span class="s1">connectivity</span><span class="s4">=</span><span class="s1">connectivity</span><span class="s4">, </span><span class="s1">linkage</span><span class="s4">=</span><span class="s6">&quot;complete&quot;</span>
    <span class="s4">)</span>
    <span class="s1">clustering</span><span class="s4">.</span><span class="s1">fit</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)</span>
    <span class="s1">X_dist </span><span class="s4">= </span><span class="s1">pairwise_distances</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)</span>
    <span class="s1">clustering2 </span><span class="s4">= </span><span class="s1">AgglomerativeClustering</span><span class="s4">(</span>
        <span class="s1">n_clusters</span><span class="s4">=</span><span class="s5">10</span><span class="s4">,</span>
        <span class="s1">connectivity</span><span class="s4">=</span><span class="s1">connectivity</span><span class="s4">,</span>
        <span class="s1">metric</span><span class="s4">=</span><span class="s6">&quot;precomputed&quot;</span><span class="s4">,</span>
        <span class="s1">linkage</span><span class="s4">=</span><span class="s6">&quot;complete&quot;</span><span class="s4">,</span>
    <span class="s4">)</span>
    <span class="s1">clustering2</span><span class="s4">.</span><span class="s1">fit</span><span class="s4">(</span><span class="s1">X_dist</span><span class="s4">)</span>
    <span class="s1">assert_array_equal</span><span class="s4">(</span><span class="s1">clustering</span><span class="s4">.</span><span class="s1">labels_</span><span class="s4">, </span><span class="s1">clustering2</span><span class="s4">.</span><span class="s1">labels_</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">test_agglomerative_clustering_memory_mapped</span><span class="s4">():</span>
    <span class="s0">&quot;&quot;&quot;AgglomerativeClustering must work on mem-mapped dataset. 
 
    Non-regression test for issue #19875. 
    &quot;&quot;&quot;</span>
    <span class="s1">rng </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">random</span><span class="s4">.</span><span class="s1">RandomState</span><span class="s4">(</span><span class="s5">0</span><span class="s4">)</span>
    <span class="s1">Xmm </span><span class="s4">= </span><span class="s1">create_memmap_backed_data</span><span class="s4">(</span><span class="s1">rng</span><span class="s4">.</span><span class="s1">randn</span><span class="s4">(</span><span class="s5">50</span><span class="s4">, </span><span class="s5">100</span><span class="s4">))</span>
    <span class="s1">AgglomerativeClustering</span><span class="s4">(</span><span class="s1">metric</span><span class="s4">=</span><span class="s6">&quot;euclidean&quot;</span><span class="s4">, </span><span class="s1">linkage</span><span class="s4">=</span><span class="s6">&quot;single&quot;</span><span class="s4">).</span><span class="s1">fit</span><span class="s4">(</span><span class="s1">Xmm</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">test_ward_agglomeration</span><span class="s4">(</span><span class="s1">global_random_seed</span><span class="s4">):</span>
    <span class="s2"># Check that we obtain the correct solution in a simplistic case</span>
    <span class="s1">rng </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">random</span><span class="s4">.</span><span class="s1">RandomState</span><span class="s4">(</span><span class="s1">global_random_seed</span><span class="s4">)</span>
    <span class="s1">mask </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">ones</span><span class="s4">([</span><span class="s5">10</span><span class="s4">, </span><span class="s5">10</span><span class="s4">], </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">bool</span><span class="s4">)</span>
    <span class="s1">X </span><span class="s4">= </span><span class="s1">rng</span><span class="s4">.</span><span class="s1">randn</span><span class="s4">(</span><span class="s5">50</span><span class="s4">, </span><span class="s5">100</span><span class="s4">)</span>
    <span class="s1">connectivity </span><span class="s4">= </span><span class="s1">grid_to_graph</span><span class="s4">(*</span><span class="s1">mask</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">)</span>
    <span class="s1">agglo </span><span class="s4">= </span><span class="s1">FeatureAgglomeration</span><span class="s4">(</span><span class="s1">n_clusters</span><span class="s4">=</span><span class="s5">5</span><span class="s4">, </span><span class="s1">connectivity</span><span class="s4">=</span><span class="s1">connectivity</span><span class="s4">)</span>
    <span class="s1">agglo</span><span class="s4">.</span><span class="s1">fit</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)</span>
    <span class="s3">assert </span><span class="s1">np</span><span class="s4">.</span><span class="s1">size</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">unique</span><span class="s4">(</span><span class="s1">agglo</span><span class="s4">.</span><span class="s1">labels_</span><span class="s4">)) == </span><span class="s5">5</span>

    <span class="s1">X_red </span><span class="s4">= </span><span class="s1">agglo</span><span class="s4">.</span><span class="s1">transform</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)</span>
    <span class="s3">assert </span><span class="s1">X_red</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s5">1</span><span class="s4">] == </span><span class="s5">5</span>
    <span class="s1">X_full </span><span class="s4">= </span><span class="s1">agglo</span><span class="s4">.</span><span class="s1">inverse_transform</span><span class="s4">(</span><span class="s1">X_red</span><span class="s4">)</span>
    <span class="s3">assert </span><span class="s1">np</span><span class="s4">.</span><span class="s1">unique</span><span class="s4">(</span><span class="s1">X_full</span><span class="s4">[</span><span class="s5">0</span><span class="s4">]).</span><span class="s1">size </span><span class="s4">== </span><span class="s5">5</span>
    <span class="s1">assert_array_almost_equal</span><span class="s4">(</span><span class="s1">agglo</span><span class="s4">.</span><span class="s1">transform</span><span class="s4">(</span><span class="s1">X_full</span><span class="s4">), </span><span class="s1">X_red</span><span class="s4">)</span>

    <span class="s2"># Check that fitting with no samples raises a ValueError</span>
    <span class="s3">with </span><span class="s1">pytest</span><span class="s4">.</span><span class="s1">raises</span><span class="s4">(</span><span class="s1">ValueError</span><span class="s4">):</span>
        <span class="s1">agglo</span><span class="s4">.</span><span class="s1">fit</span><span class="s4">(</span><span class="s1">X</span><span class="s4">[:</span><span class="s5">0</span><span class="s4">])</span>


<span class="s3">def </span><span class="s1">test_single_linkage_clustering</span><span class="s4">():</span>
    <span class="s2"># Check that we get the correct result in two emblematic cases</span>
    <span class="s1">moons</span><span class="s4">, </span><span class="s1">moon_labels </span><span class="s4">= </span><span class="s1">make_moons</span><span class="s4">(</span><span class="s1">noise</span><span class="s4">=</span><span class="s5">0.05</span><span class="s4">, </span><span class="s1">random_state</span><span class="s4">=</span><span class="s5">42</span><span class="s4">)</span>
    <span class="s1">clustering </span><span class="s4">= </span><span class="s1">AgglomerativeClustering</span><span class="s4">(</span><span class="s1">n_clusters</span><span class="s4">=</span><span class="s5">2</span><span class="s4">, </span><span class="s1">linkage</span><span class="s4">=</span><span class="s6">&quot;single&quot;</span><span class="s4">)</span>
    <span class="s1">clustering</span><span class="s4">.</span><span class="s1">fit</span><span class="s4">(</span><span class="s1">moons</span><span class="s4">)</span>
    <span class="s1">assert_almost_equal</span><span class="s4">(</span>
        <span class="s1">normalized_mutual_info_score</span><span class="s4">(</span><span class="s1">clustering</span><span class="s4">.</span><span class="s1">labels_</span><span class="s4">, </span><span class="s1">moon_labels</span><span class="s4">), </span><span class="s5">1</span>
    <span class="s4">)</span>

    <span class="s1">circles</span><span class="s4">, </span><span class="s1">circle_labels </span><span class="s4">= </span><span class="s1">make_circles</span><span class="s4">(</span><span class="s1">factor</span><span class="s4">=</span><span class="s5">0.5</span><span class="s4">, </span><span class="s1">noise</span><span class="s4">=</span><span class="s5">0.025</span><span class="s4">, </span><span class="s1">random_state</span><span class="s4">=</span><span class="s5">42</span><span class="s4">)</span>
    <span class="s1">clustering </span><span class="s4">= </span><span class="s1">AgglomerativeClustering</span><span class="s4">(</span><span class="s1">n_clusters</span><span class="s4">=</span><span class="s5">2</span><span class="s4">, </span><span class="s1">linkage</span><span class="s4">=</span><span class="s6">&quot;single&quot;</span><span class="s4">)</span>
    <span class="s1">clustering</span><span class="s4">.</span><span class="s1">fit</span><span class="s4">(</span><span class="s1">circles</span><span class="s4">)</span>
    <span class="s1">assert_almost_equal</span><span class="s4">(</span>
        <span class="s1">normalized_mutual_info_score</span><span class="s4">(</span><span class="s1">clustering</span><span class="s4">.</span><span class="s1">labels_</span><span class="s4">, </span><span class="s1">circle_labels</span><span class="s4">), </span><span class="s5">1</span>
    <span class="s4">)</span>


<span class="s3">def </span><span class="s1">assess_same_labelling</span><span class="s4">(</span><span class="s1">cut1</span><span class="s4">, </span><span class="s1">cut2</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Util for comparison with scipy&quot;&quot;&quot;</span>
    <span class="s1">co_clust </span><span class="s4">= []</span>
    <span class="s3">for </span><span class="s1">cut </span><span class="s3">in </span><span class="s4">[</span><span class="s1">cut1</span><span class="s4">, </span><span class="s1">cut2</span><span class="s4">]:</span>
        <span class="s1">n </span><span class="s4">= </span><span class="s1">len</span><span class="s4">(</span><span class="s1">cut</span><span class="s4">)</span>
        <span class="s1">k </span><span class="s4">= </span><span class="s1">cut</span><span class="s4">.</span><span class="s1">max</span><span class="s4">() + </span><span class="s5">1</span>
        <span class="s1">ecut </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">zeros</span><span class="s4">((</span><span class="s1">n</span><span class="s4">, </span><span class="s1">k</span><span class="s4">))</span>
        <span class="s1">ecut</span><span class="s4">[</span><span class="s1">np</span><span class="s4">.</span><span class="s1">arange</span><span class="s4">(</span><span class="s1">n</span><span class="s4">), </span><span class="s1">cut</span><span class="s4">] = </span><span class="s5">1</span>
        <span class="s1">co_clust</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">dot</span><span class="s4">(</span><span class="s1">ecut</span><span class="s4">, </span><span class="s1">ecut</span><span class="s4">.</span><span class="s1">T</span><span class="s4">))</span>
    <span class="s3">assert </span><span class="s4">(</span><span class="s1">co_clust</span><span class="s4">[</span><span class="s5">0</span><span class="s4">] == </span><span class="s1">co_clust</span><span class="s4">[</span><span class="s5">1</span><span class="s4">]).</span><span class="s1">all</span><span class="s4">()</span>


<span class="s3">def </span><span class="s1">test_sparse_scikit_vs_scipy</span><span class="s4">(</span><span class="s1">global_random_seed</span><span class="s4">):</span>
    <span class="s2"># Test scikit linkage with full connectivity (i.e. unstructured) vs scipy</span>
    <span class="s1">n</span><span class="s4">, </span><span class="s1">p</span><span class="s4">, </span><span class="s1">k </span><span class="s4">= </span><span class="s5">10</span><span class="s4">, </span><span class="s5">5</span><span class="s4">, </span><span class="s5">3</span>
    <span class="s1">rng </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">random</span><span class="s4">.</span><span class="s1">RandomState</span><span class="s4">(</span><span class="s1">global_random_seed</span><span class="s4">)</span>

    <span class="s2"># Not using a lil_matrix here, just to check that non sparse</span>
    <span class="s2"># matrices are well handled</span>
    <span class="s1">connectivity </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">ones</span><span class="s4">((</span><span class="s1">n</span><span class="s4">, </span><span class="s1">n</span><span class="s4">))</span>
    <span class="s3">for </span><span class="s1">linkage </span><span class="s3">in </span><span class="s1">_TREE_BUILDERS</span><span class="s4">.</span><span class="s1">keys</span><span class="s4">():</span>
        <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range</span><span class="s4">(</span><span class="s5">5</span><span class="s4">):</span>
            <span class="s1">X </span><span class="s4">= </span><span class="s5">0.1 </span><span class="s4">* </span><span class="s1">rng</span><span class="s4">.</span><span class="s1">normal</span><span class="s4">(</span><span class="s1">size</span><span class="s4">=(</span><span class="s1">n</span><span class="s4">, </span><span class="s1">p</span><span class="s4">))</span>
            <span class="s1">X </span><span class="s4">-= </span><span class="s5">4.0 </span><span class="s4">* </span><span class="s1">np</span><span class="s4">.</span><span class="s1">arange</span><span class="s4">(</span><span class="s1">n</span><span class="s4">)[:, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">newaxis</span><span class="s4">]</span>
            <span class="s1">X </span><span class="s4">-= </span><span class="s1">X</span><span class="s4">.</span><span class="s1">mean</span><span class="s4">(</span><span class="s1">axis</span><span class="s4">=</span><span class="s5">1</span><span class="s4">)[:, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">newaxis</span><span class="s4">]</span>

            <span class="s1">out </span><span class="s4">= </span><span class="s1">hierarchy</span><span class="s4">.</span><span class="s1">linkage</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">method</span><span class="s4">=</span><span class="s1">linkage</span><span class="s4">)</span>

            <span class="s1">children_ </span><span class="s4">= </span><span class="s1">out</span><span class="s4">[:, :</span><span class="s5">2</span><span class="s4">].</span><span class="s1">astype</span><span class="s4">(</span><span class="s1">int</span><span class="s4">, </span><span class="s1">copy</span><span class="s4">=</span><span class="s3">False</span><span class="s4">)</span>
            <span class="s1">children</span><span class="s4">, </span><span class="s1">_</span><span class="s4">, </span><span class="s1">n_leaves</span><span class="s4">, </span><span class="s1">_ </span><span class="s4">= </span><span class="s1">_TREE_BUILDERS</span><span class="s4">[</span><span class="s1">linkage</span><span class="s4">](</span>
                <span class="s1">X</span><span class="s4">, </span><span class="s1">connectivity</span><span class="s4">=</span><span class="s1">connectivity</span>
            <span class="s4">)</span>

            <span class="s2"># Sort the order of child nodes per row for consistency</span>
            <span class="s1">children</span><span class="s4">.</span><span class="s1">sort</span><span class="s4">(</span><span class="s1">axis</span><span class="s4">=</span><span class="s5">1</span><span class="s4">)</span>
            <span class="s1">assert_array_equal</span><span class="s4">(</span>
                <span class="s1">children</span><span class="s4">,</span>
                <span class="s1">children_</span><span class="s4">,</span>
                <span class="s6">&quot;linkage tree differs from scipy impl for linkage: &quot; </span><span class="s4">+ </span><span class="s1">linkage</span><span class="s4">,</span>
            <span class="s4">)</span>

            <span class="s1">cut </span><span class="s4">= </span><span class="s1">_hc_cut</span><span class="s4">(</span><span class="s1">k</span><span class="s4">, </span><span class="s1">children</span><span class="s4">, </span><span class="s1">n_leaves</span><span class="s4">)</span>
            <span class="s1">cut_ </span><span class="s4">= </span><span class="s1">_hc_cut</span><span class="s4">(</span><span class="s1">k</span><span class="s4">, </span><span class="s1">children_</span><span class="s4">, </span><span class="s1">n_leaves</span><span class="s4">)</span>
            <span class="s1">assess_same_labelling</span><span class="s4">(</span><span class="s1">cut</span><span class="s4">, </span><span class="s1">cut_</span><span class="s4">)</span>

    <span class="s2"># Test error management in _hc_cut</span>
    <span class="s3">with </span><span class="s1">pytest</span><span class="s4">.</span><span class="s1">raises</span><span class="s4">(</span><span class="s1">ValueError</span><span class="s4">):</span>
        <span class="s1">_hc_cut</span><span class="s4">(</span><span class="s1">n_leaves </span><span class="s4">+ </span><span class="s5">1</span><span class="s4">, </span><span class="s1">children</span><span class="s4">, </span><span class="s1">n_leaves</span><span class="s4">)</span>


<span class="s2"># Make sure our custom mst_linkage_core gives</span>
<span class="s2"># the same results as scipy's builtin</span>
<span class="s3">def </span><span class="s1">test_vector_scikit_single_vs_scipy_single</span><span class="s4">(</span><span class="s1">global_random_seed</span><span class="s4">):</span>
    <span class="s1">n_samples</span><span class="s4">, </span><span class="s1">n_features</span><span class="s4">, </span><span class="s1">n_clusters </span><span class="s4">= </span><span class="s5">10</span><span class="s4">, </span><span class="s5">5</span><span class="s4">, </span><span class="s5">3</span>
    <span class="s1">rng </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">random</span><span class="s4">.</span><span class="s1">RandomState</span><span class="s4">(</span><span class="s1">global_random_seed</span><span class="s4">)</span>
    <span class="s1">X </span><span class="s4">= </span><span class="s5">0.1 </span><span class="s4">* </span><span class="s1">rng</span><span class="s4">.</span><span class="s1">normal</span><span class="s4">(</span><span class="s1">size</span><span class="s4">=(</span><span class="s1">n_samples</span><span class="s4">, </span><span class="s1">n_features</span><span class="s4">))</span>
    <span class="s1">X </span><span class="s4">-= </span><span class="s5">4.0 </span><span class="s4">* </span><span class="s1">np</span><span class="s4">.</span><span class="s1">arange</span><span class="s4">(</span><span class="s1">n_samples</span><span class="s4">)[:, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">newaxis</span><span class="s4">]</span>
    <span class="s1">X </span><span class="s4">-= </span><span class="s1">X</span><span class="s4">.</span><span class="s1">mean</span><span class="s4">(</span><span class="s1">axis</span><span class="s4">=</span><span class="s5">1</span><span class="s4">)[:, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">newaxis</span><span class="s4">]</span>

    <span class="s1">out </span><span class="s4">= </span><span class="s1">hierarchy</span><span class="s4">.</span><span class="s1">linkage</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">method</span><span class="s4">=</span><span class="s6">&quot;single&quot;</span><span class="s4">)</span>
    <span class="s1">children_scipy </span><span class="s4">= </span><span class="s1">out</span><span class="s4">[:, :</span><span class="s5">2</span><span class="s4">].</span><span class="s1">astype</span><span class="s4">(</span><span class="s1">int</span><span class="s4">)</span>

    <span class="s1">children</span><span class="s4">, </span><span class="s1">_</span><span class="s4">, </span><span class="s1">n_leaves</span><span class="s4">, </span><span class="s1">_ </span><span class="s4">= </span><span class="s1">_TREE_BUILDERS</span><span class="s4">[</span><span class="s6">&quot;single&quot;</span><span class="s4">](</span><span class="s1">X</span><span class="s4">)</span>

    <span class="s2"># Sort the order of child nodes per row for consistency</span>
    <span class="s1">children</span><span class="s4">.</span><span class="s1">sort</span><span class="s4">(</span><span class="s1">axis</span><span class="s4">=</span><span class="s5">1</span><span class="s4">)</span>
    <span class="s1">assert_array_equal</span><span class="s4">(</span>
        <span class="s1">children</span><span class="s4">,</span>
        <span class="s1">children_scipy</span><span class="s4">,</span>
        <span class="s6">&quot;linkage tree differs from scipy impl for single linkage.&quot;</span><span class="s4">,</span>
    <span class="s4">)</span>

    <span class="s1">cut </span><span class="s4">= </span><span class="s1">_hc_cut</span><span class="s4">(</span><span class="s1">n_clusters</span><span class="s4">, </span><span class="s1">children</span><span class="s4">, </span><span class="s1">n_leaves</span><span class="s4">)</span>
    <span class="s1">cut_scipy </span><span class="s4">= </span><span class="s1">_hc_cut</span><span class="s4">(</span><span class="s1">n_clusters</span><span class="s4">, </span><span class="s1">children_scipy</span><span class="s4">, </span><span class="s1">n_leaves</span><span class="s4">)</span>
    <span class="s1">assess_same_labelling</span><span class="s4">(</span><span class="s1">cut</span><span class="s4">, </span><span class="s1">cut_scipy</span><span class="s4">)</span>


<span class="s4">@</span><span class="s1">pytest</span><span class="s4">.</span><span class="s1">mark</span><span class="s4">.</span><span class="s1">parametrize</span><span class="s4">(</span><span class="s6">&quot;metric_param_grid&quot;</span><span class="s4">, </span><span class="s1">METRICS_DEFAULT_PARAMS</span><span class="s4">)</span>
<span class="s3">def </span><span class="s1">test_mst_linkage_core_memory_mapped</span><span class="s4">(</span><span class="s1">metric_param_grid</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;The MST-LINKAGE-CORE algorithm must work on mem-mapped dataset. 
 
    Non-regression test for issue #19875. 
    &quot;&quot;&quot;</span>
    <span class="s1">rng </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">random</span><span class="s4">.</span><span class="s1">RandomState</span><span class="s4">(</span><span class="s1">seed</span><span class="s4">=</span><span class="s5">1</span><span class="s4">)</span>
    <span class="s1">X </span><span class="s4">= </span><span class="s1">rng</span><span class="s4">.</span><span class="s1">normal</span><span class="s4">(</span><span class="s1">size</span><span class="s4">=(</span><span class="s5">20</span><span class="s4">, </span><span class="s5">4</span><span class="s4">))</span>
    <span class="s1">Xmm </span><span class="s4">= </span><span class="s1">create_memmap_backed_data</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)</span>
    <span class="s1">metric</span><span class="s4">, </span><span class="s1">param_grid </span><span class="s4">= </span><span class="s1">metric_param_grid</span>
    <span class="s1">keys </span><span class="s4">= </span><span class="s1">param_grid</span><span class="s4">.</span><span class="s1">keys</span><span class="s4">()</span>
    <span class="s3">for </span><span class="s1">vals </span><span class="s3">in </span><span class="s1">itertools</span><span class="s4">.</span><span class="s1">product</span><span class="s4">(*</span><span class="s1">param_grid</span><span class="s4">.</span><span class="s1">values</span><span class="s4">()):</span>
        <span class="s1">kwargs </span><span class="s4">= </span><span class="s1">dict</span><span class="s4">(</span><span class="s1">zip</span><span class="s4">(</span><span class="s1">keys</span><span class="s4">, </span><span class="s1">vals</span><span class="s4">))</span>
        <span class="s1">distance_metric </span><span class="s4">= </span><span class="s1">DistanceMetric</span><span class="s4">.</span><span class="s1">get_metric</span><span class="s4">(</span><span class="s1">metric</span><span class="s4">, **</span><span class="s1">kwargs</span><span class="s4">)</span>
        <span class="s1">mst </span><span class="s4">= </span><span class="s1">mst_linkage_core</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">distance_metric</span><span class="s4">)</span>
        <span class="s1">mst_mm </span><span class="s4">= </span><span class="s1">mst_linkage_core</span><span class="s4">(</span><span class="s1">Xmm</span><span class="s4">, </span><span class="s1">distance_metric</span><span class="s4">)</span>
        <span class="s1">np</span><span class="s4">.</span><span class="s1">testing</span><span class="s4">.</span><span class="s1">assert_equal</span><span class="s4">(</span><span class="s1">mst</span><span class="s4">, </span><span class="s1">mst_mm</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">test_identical_points</span><span class="s4">():</span>
    <span class="s2"># Ensure identical points are handled correctly when using mst with</span>
    <span class="s2"># a sparse connectivity matrix</span>
    <span class="s1">X </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">array</span><span class="s4">([[</span><span class="s5">0</span><span class="s4">, </span><span class="s5">0</span><span class="s4">, </span><span class="s5">0</span><span class="s4">], [</span><span class="s5">0</span><span class="s4">, </span><span class="s5">0</span><span class="s4">, </span><span class="s5">0</span><span class="s4">], [</span><span class="s5">1</span><span class="s4">, </span><span class="s5">1</span><span class="s4">, </span><span class="s5">1</span><span class="s4">], [</span><span class="s5">1</span><span class="s4">, </span><span class="s5">1</span><span class="s4">, </span><span class="s5">1</span><span class="s4">], [</span><span class="s5">2</span><span class="s4">, </span><span class="s5">2</span><span class="s4">, </span><span class="s5">2</span><span class="s4">], [</span><span class="s5">2</span><span class="s4">, </span><span class="s5">2</span><span class="s4">, </span><span class="s5">2</span><span class="s4">]])</span>
    <span class="s1">true_labels </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">array</span><span class="s4">([</span><span class="s5">0</span><span class="s4">, </span><span class="s5">0</span><span class="s4">, </span><span class="s5">1</span><span class="s4">, </span><span class="s5">1</span><span class="s4">, </span><span class="s5">2</span><span class="s4">, </span><span class="s5">2</span><span class="s4">])</span>
    <span class="s1">connectivity </span><span class="s4">= </span><span class="s1">kneighbors_graph</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">n_neighbors</span><span class="s4">=</span><span class="s5">3</span><span class="s4">, </span><span class="s1">include_self</span><span class="s4">=</span><span class="s3">False</span><span class="s4">)</span>
    <span class="s1">connectivity </span><span class="s4">= </span><span class="s5">0.5 </span><span class="s4">* (</span><span class="s1">connectivity </span><span class="s4">+ </span><span class="s1">connectivity</span><span class="s4">.</span><span class="s1">T</span><span class="s4">)</span>
    <span class="s1">connectivity</span><span class="s4">, </span><span class="s1">n_components </span><span class="s4">= </span><span class="s1">_fix_connectivity</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">connectivity</span><span class="s4">, </span><span class="s6">&quot;euclidean&quot;</span><span class="s4">)</span>

    <span class="s3">for </span><span class="s1">linkage </span><span class="s3">in </span><span class="s4">(</span><span class="s6">&quot;single&quot;</span><span class="s4">, </span><span class="s6">&quot;average&quot;</span><span class="s4">, </span><span class="s6">&quot;average&quot;</span><span class="s4">, </span><span class="s6">&quot;ward&quot;</span><span class="s4">):</span>
        <span class="s1">clustering </span><span class="s4">= </span><span class="s1">AgglomerativeClustering</span><span class="s4">(</span>
            <span class="s1">n_clusters</span><span class="s4">=</span><span class="s5">3</span><span class="s4">, </span><span class="s1">linkage</span><span class="s4">=</span><span class="s1">linkage</span><span class="s4">, </span><span class="s1">connectivity</span><span class="s4">=</span><span class="s1">connectivity</span>
        <span class="s4">)</span>
        <span class="s1">clustering</span><span class="s4">.</span><span class="s1">fit</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)</span>

        <span class="s1">assert_almost_equal</span><span class="s4">(</span>
            <span class="s1">normalized_mutual_info_score</span><span class="s4">(</span><span class="s1">clustering</span><span class="s4">.</span><span class="s1">labels_</span><span class="s4">, </span><span class="s1">true_labels</span><span class="s4">), </span><span class="s5">1</span>
        <span class="s4">)</span>


<span class="s3">def </span><span class="s1">test_connectivity_propagation</span><span class="s4">():</span>
    <span class="s2"># Check that connectivity in the ward tree is propagated correctly during</span>
    <span class="s2"># merging.</span>
    <span class="s1">X </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">array</span><span class="s4">(</span>
        <span class="s4">[</span>
            <span class="s4">(</span><span class="s5">0.014</span><span class="s4">, </span><span class="s5">0.120</span><span class="s4">),</span>
            <span class="s4">(</span><span class="s5">0.014</span><span class="s4">, </span><span class="s5">0.099</span><span class="s4">),</span>
            <span class="s4">(</span><span class="s5">0.014</span><span class="s4">, </span><span class="s5">0.097</span><span class="s4">),</span>
            <span class="s4">(</span><span class="s5">0.017</span><span class="s4">, </span><span class="s5">0.153</span><span class="s4">),</span>
            <span class="s4">(</span><span class="s5">0.017</span><span class="s4">, </span><span class="s5">0.153</span><span class="s4">),</span>
            <span class="s4">(</span><span class="s5">0.018</span><span class="s4">, </span><span class="s5">0.153</span><span class="s4">),</span>
            <span class="s4">(</span><span class="s5">0.018</span><span class="s4">, </span><span class="s5">0.153</span><span class="s4">),</span>
            <span class="s4">(</span><span class="s5">0.018</span><span class="s4">, </span><span class="s5">0.153</span><span class="s4">),</span>
            <span class="s4">(</span><span class="s5">0.018</span><span class="s4">, </span><span class="s5">0.153</span><span class="s4">),</span>
            <span class="s4">(</span><span class="s5">0.018</span><span class="s4">, </span><span class="s5">0.153</span><span class="s4">),</span>
            <span class="s4">(</span><span class="s5">0.018</span><span class="s4">, </span><span class="s5">0.153</span><span class="s4">),</span>
            <span class="s4">(</span><span class="s5">0.018</span><span class="s4">, </span><span class="s5">0.153</span><span class="s4">),</span>
            <span class="s4">(</span><span class="s5">0.018</span><span class="s4">, </span><span class="s5">0.152</span><span class="s4">),</span>
            <span class="s4">(</span><span class="s5">0.018</span><span class="s4">, </span><span class="s5">0.149</span><span class="s4">),</span>
            <span class="s4">(</span><span class="s5">0.018</span><span class="s4">, </span><span class="s5">0.144</span><span class="s4">),</span>
        <span class="s4">]</span>
    <span class="s4">)</span>
    <span class="s1">connectivity </span><span class="s4">= </span><span class="s1">kneighbors_graph</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s5">10</span><span class="s4">, </span><span class="s1">include_self</span><span class="s4">=</span><span class="s3">False</span><span class="s4">)</span>
    <span class="s1">ward </span><span class="s4">= </span><span class="s1">AgglomerativeClustering</span><span class="s4">(</span>
        <span class="s1">n_clusters</span><span class="s4">=</span><span class="s5">4</span><span class="s4">, </span><span class="s1">connectivity</span><span class="s4">=</span><span class="s1">connectivity</span><span class="s4">, </span><span class="s1">linkage</span><span class="s4">=</span><span class="s6">&quot;ward&quot;</span>
    <span class="s4">)</span>
    <span class="s2"># If changes are not propagated correctly, fit crashes with an</span>
    <span class="s2"># IndexError</span>
    <span class="s1">ward</span><span class="s4">.</span><span class="s1">fit</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">test_ward_tree_children_order</span><span class="s4">(</span><span class="s1">global_random_seed</span><span class="s4">):</span>
    <span class="s2"># Check that children are ordered in the same way for both structured and</span>
    <span class="s2"># unstructured versions of ward_tree.</span>

    <span class="s2"># test on five random datasets</span>
    <span class="s1">n</span><span class="s4">, </span><span class="s1">p </span><span class="s4">= </span><span class="s5">10</span><span class="s4">, </span><span class="s5">5</span>
    <span class="s1">rng </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">random</span><span class="s4">.</span><span class="s1">RandomState</span><span class="s4">(</span><span class="s1">global_random_seed</span><span class="s4">)</span>

    <span class="s1">connectivity </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">ones</span><span class="s4">((</span><span class="s1">n</span><span class="s4">, </span><span class="s1">n</span><span class="s4">))</span>
    <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range</span><span class="s4">(</span><span class="s5">5</span><span class="s4">):</span>
        <span class="s1">X </span><span class="s4">= </span><span class="s5">0.1 </span><span class="s4">* </span><span class="s1">rng</span><span class="s4">.</span><span class="s1">normal</span><span class="s4">(</span><span class="s1">size</span><span class="s4">=(</span><span class="s1">n</span><span class="s4">, </span><span class="s1">p</span><span class="s4">))</span>
        <span class="s1">X </span><span class="s4">-= </span><span class="s5">4.0 </span><span class="s4">* </span><span class="s1">np</span><span class="s4">.</span><span class="s1">arange</span><span class="s4">(</span><span class="s1">n</span><span class="s4">)[:, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">newaxis</span><span class="s4">]</span>
        <span class="s1">X </span><span class="s4">-= </span><span class="s1">X</span><span class="s4">.</span><span class="s1">mean</span><span class="s4">(</span><span class="s1">axis</span><span class="s4">=</span><span class="s5">1</span><span class="s4">)[:, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">newaxis</span><span class="s4">]</span>

        <span class="s1">out_unstructured </span><span class="s4">= </span><span class="s1">ward_tree</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)</span>
        <span class="s1">out_structured </span><span class="s4">= </span><span class="s1">ward_tree</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">connectivity</span><span class="s4">=</span><span class="s1">connectivity</span><span class="s4">)</span>

        <span class="s1">assert_array_equal</span><span class="s4">(</span><span class="s1">out_unstructured</span><span class="s4">[</span><span class="s5">0</span><span class="s4">], </span><span class="s1">out_structured</span><span class="s4">[</span><span class="s5">0</span><span class="s4">])</span>


<span class="s3">def </span><span class="s1">test_ward_linkage_tree_return_distance</span><span class="s4">(</span><span class="s1">global_random_seed</span><span class="s4">):</span>
    <span class="s2"># Test return_distance option on linkage and ward trees</span>

    <span class="s2"># test that return_distance when set true, gives same</span>
    <span class="s2"># output on both structured and unstructured clustering.</span>
    <span class="s1">n</span><span class="s4">, </span><span class="s1">p </span><span class="s4">= </span><span class="s5">10</span><span class="s4">, </span><span class="s5">5</span>
    <span class="s1">rng </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">random</span><span class="s4">.</span><span class="s1">RandomState</span><span class="s4">(</span><span class="s1">global_random_seed</span><span class="s4">)</span>

    <span class="s1">connectivity </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">ones</span><span class="s4">((</span><span class="s1">n</span><span class="s4">, </span><span class="s1">n</span><span class="s4">))</span>
    <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range</span><span class="s4">(</span><span class="s5">5</span><span class="s4">):</span>
        <span class="s1">X </span><span class="s4">= </span><span class="s5">0.1 </span><span class="s4">* </span><span class="s1">rng</span><span class="s4">.</span><span class="s1">normal</span><span class="s4">(</span><span class="s1">size</span><span class="s4">=(</span><span class="s1">n</span><span class="s4">, </span><span class="s1">p</span><span class="s4">))</span>
        <span class="s1">X </span><span class="s4">-= </span><span class="s5">4.0 </span><span class="s4">* </span><span class="s1">np</span><span class="s4">.</span><span class="s1">arange</span><span class="s4">(</span><span class="s1">n</span><span class="s4">)[:, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">newaxis</span><span class="s4">]</span>
        <span class="s1">X </span><span class="s4">-= </span><span class="s1">X</span><span class="s4">.</span><span class="s1">mean</span><span class="s4">(</span><span class="s1">axis</span><span class="s4">=</span><span class="s5">1</span><span class="s4">)[:, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">newaxis</span><span class="s4">]</span>

        <span class="s1">out_unstructured </span><span class="s4">= </span><span class="s1">ward_tree</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">return_distance</span><span class="s4">=</span><span class="s3">True</span><span class="s4">)</span>
        <span class="s1">out_structured </span><span class="s4">= </span><span class="s1">ward_tree</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">connectivity</span><span class="s4">=</span><span class="s1">connectivity</span><span class="s4">, </span><span class="s1">return_distance</span><span class="s4">=</span><span class="s3">True</span><span class="s4">)</span>

        <span class="s2"># get children</span>
        <span class="s1">children_unstructured </span><span class="s4">= </span><span class="s1">out_unstructured</span><span class="s4">[</span><span class="s5">0</span><span class="s4">]</span>
        <span class="s1">children_structured </span><span class="s4">= </span><span class="s1">out_structured</span><span class="s4">[</span><span class="s5">0</span><span class="s4">]</span>

        <span class="s2"># check if we got the same clusters</span>
        <span class="s1">assert_array_equal</span><span class="s4">(</span><span class="s1">children_unstructured</span><span class="s4">, </span><span class="s1">children_structured</span><span class="s4">)</span>

        <span class="s2"># check if the distances are the same</span>
        <span class="s1">dist_unstructured </span><span class="s4">= </span><span class="s1">out_unstructured</span><span class="s4">[-</span><span class="s5">1</span><span class="s4">]</span>
        <span class="s1">dist_structured </span><span class="s4">= </span><span class="s1">out_structured</span><span class="s4">[-</span><span class="s5">1</span><span class="s4">]</span>

        <span class="s1">assert_array_almost_equal</span><span class="s4">(</span><span class="s1">dist_unstructured</span><span class="s4">, </span><span class="s1">dist_structured</span><span class="s4">)</span>

        <span class="s3">for </span><span class="s1">linkage </span><span class="s3">in </span><span class="s4">[</span><span class="s6">&quot;average&quot;</span><span class="s4">, </span><span class="s6">&quot;complete&quot;</span><span class="s4">, </span><span class="s6">&quot;single&quot;</span><span class="s4">]:</span>
            <span class="s1">structured_items </span><span class="s4">= </span><span class="s1">linkage_tree</span><span class="s4">(</span>
                <span class="s1">X</span><span class="s4">, </span><span class="s1">connectivity</span><span class="s4">=</span><span class="s1">connectivity</span><span class="s4">, </span><span class="s1">linkage</span><span class="s4">=</span><span class="s1">linkage</span><span class="s4">, </span><span class="s1">return_distance</span><span class="s4">=</span><span class="s3">True</span>
            <span class="s4">)[-</span><span class="s5">1</span><span class="s4">]</span>
            <span class="s1">unstructured_items </span><span class="s4">= </span><span class="s1">linkage_tree</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">linkage</span><span class="s4">=</span><span class="s1">linkage</span><span class="s4">, </span><span class="s1">return_distance</span><span class="s4">=</span><span class="s3">True</span><span class="s4">)[</span>
                <span class="s4">-</span><span class="s5">1</span>
            <span class="s4">]</span>
            <span class="s1">structured_dist </span><span class="s4">= </span><span class="s1">structured_items</span><span class="s4">[-</span><span class="s5">1</span><span class="s4">]</span>
            <span class="s1">unstructured_dist </span><span class="s4">= </span><span class="s1">unstructured_items</span><span class="s4">[-</span><span class="s5">1</span><span class="s4">]</span>
            <span class="s1">structured_children </span><span class="s4">= </span><span class="s1">structured_items</span><span class="s4">[</span><span class="s5">0</span><span class="s4">]</span>
            <span class="s1">unstructured_children </span><span class="s4">= </span><span class="s1">unstructured_items</span><span class="s4">[</span><span class="s5">0</span><span class="s4">]</span>
            <span class="s1">assert_array_almost_equal</span><span class="s4">(</span><span class="s1">structured_dist</span><span class="s4">, </span><span class="s1">unstructured_dist</span><span class="s4">)</span>
            <span class="s1">assert_array_almost_equal</span><span class="s4">(</span><span class="s1">structured_children</span><span class="s4">, </span><span class="s1">unstructured_children</span><span class="s4">)</span>

    <span class="s2"># test on the following dataset where we know the truth</span>
    <span class="s2"># taken from scipy/cluster/tests/hierarchy_test_data.py</span>
    <span class="s1">X </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">array</span><span class="s4">(</span>
        <span class="s4">[</span>
            <span class="s4">[</span><span class="s5">1.43054825</span><span class="s4">, -</span><span class="s5">7.5693489</span><span class="s4">],</span>
            <span class="s4">[</span><span class="s5">6.95887839</span><span class="s4">, </span><span class="s5">6.82293382</span><span class="s4">],</span>
            <span class="s4">[</span><span class="s5">2.87137846</span><span class="s4">, -</span><span class="s5">9.68248579</span><span class="s4">],</span>
            <span class="s4">[</span><span class="s5">7.87974764</span><span class="s4">, -</span><span class="s5">6.05485803</span><span class="s4">],</span>
            <span class="s4">[</span><span class="s5">8.24018364</span><span class="s4">, -</span><span class="s5">6.09495602</span><span class="s4">],</span>
            <span class="s4">[</span><span class="s5">7.39020262</span><span class="s4">, </span><span class="s5">8.54004355</span><span class="s4">],</span>
        <span class="s4">]</span>
    <span class="s4">)</span>
    <span class="s2"># truth</span>
    <span class="s1">linkage_X_ward </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">array</span><span class="s4">(</span>
        <span class="s4">[</span>
            <span class="s4">[</span><span class="s5">3.0</span><span class="s4">, </span><span class="s5">4.0</span><span class="s4">, </span><span class="s5">0.36265956</span><span class="s4">, </span><span class="s5">2.0</span><span class="s4">],</span>
            <span class="s4">[</span><span class="s5">1.0</span><span class="s4">, </span><span class="s5">5.0</span><span class="s4">, </span><span class="s5">1.77045373</span><span class="s4">, </span><span class="s5">2.0</span><span class="s4">],</span>
            <span class="s4">[</span><span class="s5">0.0</span><span class="s4">, </span><span class="s5">2.0</span><span class="s4">, </span><span class="s5">2.55760419</span><span class="s4">, </span><span class="s5">2.0</span><span class="s4">],</span>
            <span class="s4">[</span><span class="s5">6.0</span><span class="s4">, </span><span class="s5">8.0</span><span class="s4">, </span><span class="s5">9.10208346</span><span class="s4">, </span><span class="s5">4.0</span><span class="s4">],</span>
            <span class="s4">[</span><span class="s5">7.0</span><span class="s4">, </span><span class="s5">9.0</span><span class="s4">, </span><span class="s5">24.7784379</span><span class="s4">, </span><span class="s5">6.0</span><span class="s4">],</span>
        <span class="s4">]</span>
    <span class="s4">)</span>

    <span class="s1">linkage_X_complete </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">array</span><span class="s4">(</span>
        <span class="s4">[</span>
            <span class="s4">[</span><span class="s5">3.0</span><span class="s4">, </span><span class="s5">4.0</span><span class="s4">, </span><span class="s5">0.36265956</span><span class="s4">, </span><span class="s5">2.0</span><span class="s4">],</span>
            <span class="s4">[</span><span class="s5">1.0</span><span class="s4">, </span><span class="s5">5.0</span><span class="s4">, </span><span class="s5">1.77045373</span><span class="s4">, </span><span class="s5">2.0</span><span class="s4">],</span>
            <span class="s4">[</span><span class="s5">0.0</span><span class="s4">, </span><span class="s5">2.0</span><span class="s4">, </span><span class="s5">2.55760419</span><span class="s4">, </span><span class="s5">2.0</span><span class="s4">],</span>
            <span class="s4">[</span><span class="s5">6.0</span><span class="s4">, </span><span class="s5">8.0</span><span class="s4">, </span><span class="s5">6.96742194</span><span class="s4">, </span><span class="s5">4.0</span><span class="s4">],</span>
            <span class="s4">[</span><span class="s5">7.0</span><span class="s4">, </span><span class="s5">9.0</span><span class="s4">, </span><span class="s5">18.77445997</span><span class="s4">, </span><span class="s5">6.0</span><span class="s4">],</span>
        <span class="s4">]</span>
    <span class="s4">)</span>

    <span class="s1">linkage_X_average </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">array</span><span class="s4">(</span>
        <span class="s4">[</span>
            <span class="s4">[</span><span class="s5">3.0</span><span class="s4">, </span><span class="s5">4.0</span><span class="s4">, </span><span class="s5">0.36265956</span><span class="s4">, </span><span class="s5">2.0</span><span class="s4">],</span>
            <span class="s4">[</span><span class="s5">1.0</span><span class="s4">, </span><span class="s5">5.0</span><span class="s4">, </span><span class="s5">1.77045373</span><span class="s4">, </span><span class="s5">2.0</span><span class="s4">],</span>
            <span class="s4">[</span><span class="s5">0.0</span><span class="s4">, </span><span class="s5">2.0</span><span class="s4">, </span><span class="s5">2.55760419</span><span class="s4">, </span><span class="s5">2.0</span><span class="s4">],</span>
            <span class="s4">[</span><span class="s5">6.0</span><span class="s4">, </span><span class="s5">8.0</span><span class="s4">, </span><span class="s5">6.55832839</span><span class="s4">, </span><span class="s5">4.0</span><span class="s4">],</span>
            <span class="s4">[</span><span class="s5">7.0</span><span class="s4">, </span><span class="s5">9.0</span><span class="s4">, </span><span class="s5">15.44089605</span><span class="s4">, </span><span class="s5">6.0</span><span class="s4">],</span>
        <span class="s4">]</span>
    <span class="s4">)</span>

    <span class="s1">n_samples</span><span class="s4">, </span><span class="s1">n_features </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)</span>
    <span class="s1">connectivity_X </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">ones</span><span class="s4">((</span><span class="s1">n_samples</span><span class="s4">, </span><span class="s1">n_samples</span><span class="s4">))</span>

    <span class="s1">out_X_unstructured </span><span class="s4">= </span><span class="s1">ward_tree</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">return_distance</span><span class="s4">=</span><span class="s3">True</span><span class="s4">)</span>
    <span class="s1">out_X_structured </span><span class="s4">= </span><span class="s1">ward_tree</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">connectivity</span><span class="s4">=</span><span class="s1">connectivity_X</span><span class="s4">, </span><span class="s1">return_distance</span><span class="s4">=</span><span class="s3">True</span><span class="s4">)</span>

    <span class="s2"># check that the labels are the same</span>
    <span class="s1">assert_array_equal</span><span class="s4">(</span><span class="s1">linkage_X_ward</span><span class="s4">[:, :</span><span class="s5">2</span><span class="s4">], </span><span class="s1">out_X_unstructured</span><span class="s4">[</span><span class="s5">0</span><span class="s4">])</span>
    <span class="s1">assert_array_equal</span><span class="s4">(</span><span class="s1">linkage_X_ward</span><span class="s4">[:, :</span><span class="s5">2</span><span class="s4">], </span><span class="s1">out_X_structured</span><span class="s4">[</span><span class="s5">0</span><span class="s4">])</span>

    <span class="s2"># check that the distances are correct</span>
    <span class="s1">assert_array_almost_equal</span><span class="s4">(</span><span class="s1">linkage_X_ward</span><span class="s4">[:, </span><span class="s5">2</span><span class="s4">], </span><span class="s1">out_X_unstructured</span><span class="s4">[</span><span class="s5">4</span><span class="s4">])</span>
    <span class="s1">assert_array_almost_equal</span><span class="s4">(</span><span class="s1">linkage_X_ward</span><span class="s4">[:, </span><span class="s5">2</span><span class="s4">], </span><span class="s1">out_X_structured</span><span class="s4">[</span><span class="s5">4</span><span class="s4">])</span>

    <span class="s1">linkage_options </span><span class="s4">= [</span><span class="s6">&quot;complete&quot;</span><span class="s4">, </span><span class="s6">&quot;average&quot;</span><span class="s4">, </span><span class="s6">&quot;single&quot;</span><span class="s4">]</span>
    <span class="s1">X_linkage_truth </span><span class="s4">= [</span><span class="s1">linkage_X_complete</span><span class="s4">, </span><span class="s1">linkage_X_average</span><span class="s4">]</span>
    <span class="s3">for </span><span class="s1">linkage</span><span class="s4">, </span><span class="s1">X_truth </span><span class="s3">in </span><span class="s1">zip</span><span class="s4">(</span><span class="s1">linkage_options</span><span class="s4">, </span><span class="s1">X_linkage_truth</span><span class="s4">):</span>
        <span class="s1">out_X_unstructured </span><span class="s4">= </span><span class="s1">linkage_tree</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">return_distance</span><span class="s4">=</span><span class="s3">True</span><span class="s4">, </span><span class="s1">linkage</span><span class="s4">=</span><span class="s1">linkage</span><span class="s4">)</span>
        <span class="s1">out_X_structured </span><span class="s4">= </span><span class="s1">linkage_tree</span><span class="s4">(</span>
            <span class="s1">X</span><span class="s4">, </span><span class="s1">connectivity</span><span class="s4">=</span><span class="s1">connectivity_X</span><span class="s4">, </span><span class="s1">linkage</span><span class="s4">=</span><span class="s1">linkage</span><span class="s4">, </span><span class="s1">return_distance</span><span class="s4">=</span><span class="s3">True</span>
        <span class="s4">)</span>

        <span class="s2"># check that the labels are the same</span>
        <span class="s1">assert_array_equal</span><span class="s4">(</span><span class="s1">X_truth</span><span class="s4">[:, :</span><span class="s5">2</span><span class="s4">], </span><span class="s1">out_X_unstructured</span><span class="s4">[</span><span class="s5">0</span><span class="s4">])</span>
        <span class="s1">assert_array_equal</span><span class="s4">(</span><span class="s1">X_truth</span><span class="s4">[:, :</span><span class="s5">2</span><span class="s4">], </span><span class="s1">out_X_structured</span><span class="s4">[</span><span class="s5">0</span><span class="s4">])</span>

        <span class="s2"># check that the distances are correct</span>
        <span class="s1">assert_array_almost_equal</span><span class="s4">(</span><span class="s1">X_truth</span><span class="s4">[:, </span><span class="s5">2</span><span class="s4">], </span><span class="s1">out_X_unstructured</span><span class="s4">[</span><span class="s5">4</span><span class="s4">])</span>
        <span class="s1">assert_array_almost_equal</span><span class="s4">(</span><span class="s1">X_truth</span><span class="s4">[:, </span><span class="s5">2</span><span class="s4">], </span><span class="s1">out_X_structured</span><span class="s4">[</span><span class="s5">4</span><span class="s4">])</span>


<span class="s3">def </span><span class="s1">test_connectivity_fixing_non_lil</span><span class="s4">():</span>
    <span class="s2"># Check non regression of a bug if a non item assignable connectivity is</span>
    <span class="s2"># provided with more than one component.</span>
    <span class="s2"># create dummy data</span>
    <span class="s1">x </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">array</span><span class="s4">([[</span><span class="s5">0</span><span class="s4">, </span><span class="s5">0</span><span class="s4">], [</span><span class="s5">1</span><span class="s4">, </span><span class="s5">1</span><span class="s4">]])</span>
    <span class="s2"># create a mask with several components to force connectivity fixing</span>
    <span class="s1">m </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">array</span><span class="s4">([[</span><span class="s3">True</span><span class="s4">, </span><span class="s3">False</span><span class="s4">], [</span><span class="s3">False</span><span class="s4">, </span><span class="s3">True</span><span class="s4">]])</span>
    <span class="s1">c </span><span class="s4">= </span><span class="s1">grid_to_graph</span><span class="s4">(</span><span class="s1">n_x</span><span class="s4">=</span><span class="s5">2</span><span class="s4">, </span><span class="s1">n_y</span><span class="s4">=</span><span class="s5">2</span><span class="s4">, </span><span class="s1">mask</span><span class="s4">=</span><span class="s1">m</span><span class="s4">)</span>
    <span class="s1">w </span><span class="s4">= </span><span class="s1">AgglomerativeClustering</span><span class="s4">(</span><span class="s1">connectivity</span><span class="s4">=</span><span class="s1">c</span><span class="s4">, </span><span class="s1">linkage</span><span class="s4">=</span><span class="s6">&quot;ward&quot;</span><span class="s4">)</span>
    <span class="s3">with </span><span class="s1">pytest</span><span class="s4">.</span><span class="s1">warns</span><span class="s4">(</span><span class="s1">UserWarning</span><span class="s4">):</span>
        <span class="s1">w</span><span class="s4">.</span><span class="s1">fit</span><span class="s4">(</span><span class="s1">x</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">test_int_float_dict</span><span class="s4">():</span>
    <span class="s1">rng </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">random</span><span class="s4">.</span><span class="s1">RandomState</span><span class="s4">(</span><span class="s5">0</span><span class="s4">)</span>
    <span class="s1">keys </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">unique</span><span class="s4">(</span><span class="s1">rng</span><span class="s4">.</span><span class="s1">randint</span><span class="s4">(</span><span class="s5">100</span><span class="s4">, </span><span class="s1">size</span><span class="s4">=</span><span class="s5">10</span><span class="s4">).</span><span class="s1">astype</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">intp</span><span class="s4">, </span><span class="s1">copy</span><span class="s4">=</span><span class="s3">False</span><span class="s4">))</span>
    <span class="s1">values </span><span class="s4">= </span><span class="s1">rng</span><span class="s4">.</span><span class="s1">rand</span><span class="s4">(</span><span class="s1">len</span><span class="s4">(</span><span class="s1">keys</span><span class="s4">))</span>

    <span class="s1">d </span><span class="s4">= </span><span class="s1">IntFloatDict</span><span class="s4">(</span><span class="s1">keys</span><span class="s4">, </span><span class="s1">values</span><span class="s4">)</span>
    <span class="s3">for </span><span class="s1">key</span><span class="s4">, </span><span class="s1">value </span><span class="s3">in </span><span class="s1">zip</span><span class="s4">(</span><span class="s1">keys</span><span class="s4">, </span><span class="s1">values</span><span class="s4">):</span>
        <span class="s3">assert </span><span class="s1">d</span><span class="s4">[</span><span class="s1">key</span><span class="s4">] == </span><span class="s1">value</span>

    <span class="s1">other_keys </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">arange</span><span class="s4">(</span><span class="s5">50</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">np</span><span class="s4">.</span><span class="s1">intp</span><span class="s4">)[::</span><span class="s5">2</span><span class="s4">]</span>
    <span class="s1">other_values </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">full</span><span class="s4">(</span><span class="s5">50</span><span class="s4">, </span><span class="s5">0.5</span><span class="s4">)[::</span><span class="s5">2</span><span class="s4">]</span>
    <span class="s1">other </span><span class="s4">= </span><span class="s1">IntFloatDict</span><span class="s4">(</span><span class="s1">other_keys</span><span class="s4">, </span><span class="s1">other_values</span><span class="s4">)</span>
    <span class="s2"># Complete smoke test</span>
    <span class="s1">max_merge</span><span class="s4">(</span><span class="s1">d</span><span class="s4">, </span><span class="s1">other</span><span class="s4">, </span><span class="s1">mask</span><span class="s4">=</span><span class="s1">np</span><span class="s4">.</span><span class="s1">ones</span><span class="s4">(</span><span class="s5">100</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">np</span><span class="s4">.</span><span class="s1">intp</span><span class="s4">), </span><span class="s1">n_a</span><span class="s4">=</span><span class="s5">1</span><span class="s4">, </span><span class="s1">n_b</span><span class="s4">=</span><span class="s5">1</span><span class="s4">)</span>
    <span class="s1">average_merge</span><span class="s4">(</span><span class="s1">d</span><span class="s4">, </span><span class="s1">other</span><span class="s4">, </span><span class="s1">mask</span><span class="s4">=</span><span class="s1">np</span><span class="s4">.</span><span class="s1">ones</span><span class="s4">(</span><span class="s5">100</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">np</span><span class="s4">.</span><span class="s1">intp</span><span class="s4">), </span><span class="s1">n_a</span><span class="s4">=</span><span class="s5">1</span><span class="s4">, </span><span class="s1">n_b</span><span class="s4">=</span><span class="s5">1</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">test_connectivity_callable</span><span class="s4">():</span>
    <span class="s1">rng </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">random</span><span class="s4">.</span><span class="s1">RandomState</span><span class="s4">(</span><span class="s5">0</span><span class="s4">)</span>
    <span class="s1">X </span><span class="s4">= </span><span class="s1">rng</span><span class="s4">.</span><span class="s1">rand</span><span class="s4">(</span><span class="s5">20</span><span class="s4">, </span><span class="s5">5</span><span class="s4">)</span>
    <span class="s1">connectivity </span><span class="s4">= </span><span class="s1">kneighbors_graph</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s5">3</span><span class="s4">, </span><span class="s1">include_self</span><span class="s4">=</span><span class="s3">False</span><span class="s4">)</span>
    <span class="s1">aglc1 </span><span class="s4">= </span><span class="s1">AgglomerativeClustering</span><span class="s4">(</span><span class="s1">connectivity</span><span class="s4">=</span><span class="s1">connectivity</span><span class="s4">)</span>
    <span class="s1">aglc2 </span><span class="s4">= </span><span class="s1">AgglomerativeClustering</span><span class="s4">(</span>
        <span class="s1">connectivity</span><span class="s4">=</span><span class="s1">partial</span><span class="s4">(</span><span class="s1">kneighbors_graph</span><span class="s4">, </span><span class="s1">n_neighbors</span><span class="s4">=</span><span class="s5">3</span><span class="s4">, </span><span class="s1">include_self</span><span class="s4">=</span><span class="s3">False</span><span class="s4">)</span>
    <span class="s4">)</span>
    <span class="s1">aglc1</span><span class="s4">.</span><span class="s1">fit</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)</span>
    <span class="s1">aglc2</span><span class="s4">.</span><span class="s1">fit</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)</span>
    <span class="s1">assert_array_equal</span><span class="s4">(</span><span class="s1">aglc1</span><span class="s4">.</span><span class="s1">labels_</span><span class="s4">, </span><span class="s1">aglc2</span><span class="s4">.</span><span class="s1">labels_</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">test_connectivity_ignores_diagonal</span><span class="s4">():</span>
    <span class="s1">rng </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">random</span><span class="s4">.</span><span class="s1">RandomState</span><span class="s4">(</span><span class="s5">0</span><span class="s4">)</span>
    <span class="s1">X </span><span class="s4">= </span><span class="s1">rng</span><span class="s4">.</span><span class="s1">rand</span><span class="s4">(</span><span class="s5">20</span><span class="s4">, </span><span class="s5">5</span><span class="s4">)</span>
    <span class="s1">connectivity </span><span class="s4">= </span><span class="s1">kneighbors_graph</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s5">3</span><span class="s4">, </span><span class="s1">include_self</span><span class="s4">=</span><span class="s3">False</span><span class="s4">)</span>
    <span class="s1">connectivity_include_self </span><span class="s4">= </span><span class="s1">kneighbors_graph</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s5">3</span><span class="s4">, </span><span class="s1">include_self</span><span class="s4">=</span><span class="s3">True</span><span class="s4">)</span>
    <span class="s1">aglc1 </span><span class="s4">= </span><span class="s1">AgglomerativeClustering</span><span class="s4">(</span><span class="s1">connectivity</span><span class="s4">=</span><span class="s1">connectivity</span><span class="s4">)</span>
    <span class="s1">aglc2 </span><span class="s4">= </span><span class="s1">AgglomerativeClustering</span><span class="s4">(</span><span class="s1">connectivity</span><span class="s4">=</span><span class="s1">connectivity_include_self</span><span class="s4">)</span>
    <span class="s1">aglc1</span><span class="s4">.</span><span class="s1">fit</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)</span>
    <span class="s1">aglc2</span><span class="s4">.</span><span class="s1">fit</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)</span>
    <span class="s1">assert_array_equal</span><span class="s4">(</span><span class="s1">aglc1</span><span class="s4">.</span><span class="s1">labels_</span><span class="s4">, </span><span class="s1">aglc2</span><span class="s4">.</span><span class="s1">labels_</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">test_compute_full_tree</span><span class="s4">():</span>
    <span class="s2"># Test that the full tree is computed if n_clusters is small</span>
    <span class="s1">rng </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">random</span><span class="s4">.</span><span class="s1">RandomState</span><span class="s4">(</span><span class="s5">0</span><span class="s4">)</span>
    <span class="s1">X </span><span class="s4">= </span><span class="s1">rng</span><span class="s4">.</span><span class="s1">randn</span><span class="s4">(</span><span class="s5">10</span><span class="s4">, </span><span class="s5">2</span><span class="s4">)</span>
    <span class="s1">connectivity </span><span class="s4">= </span><span class="s1">kneighbors_graph</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s5">5</span><span class="s4">, </span><span class="s1">include_self</span><span class="s4">=</span><span class="s3">False</span><span class="s4">)</span>

    <span class="s2"># When n_clusters is less, the full tree should be built</span>
    <span class="s2"># that is the number of merges should be n_samples - 1</span>
    <span class="s1">agc </span><span class="s4">= </span><span class="s1">AgglomerativeClustering</span><span class="s4">(</span><span class="s1">n_clusters</span><span class="s4">=</span><span class="s5">2</span><span class="s4">, </span><span class="s1">connectivity</span><span class="s4">=</span><span class="s1">connectivity</span><span class="s4">)</span>
    <span class="s1">agc</span><span class="s4">.</span><span class="s1">fit</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)</span>
    <span class="s1">n_samples </span><span class="s4">= </span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s5">0</span><span class="s4">]</span>
    <span class="s1">n_nodes </span><span class="s4">= </span><span class="s1">agc</span><span class="s4">.</span><span class="s1">children_</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s5">0</span><span class="s4">]</span>
    <span class="s3">assert </span><span class="s1">n_nodes </span><span class="s4">== </span><span class="s1">n_samples </span><span class="s4">- </span><span class="s5">1</span>

    <span class="s2"># When n_clusters is large, greater than max of 100 and 0.02 * n_samples.</span>
    <span class="s2"># we should stop when there are n_clusters.</span>
    <span class="s1">n_clusters </span><span class="s4">= </span><span class="s5">101</span>
    <span class="s1">X </span><span class="s4">= </span><span class="s1">rng</span><span class="s4">.</span><span class="s1">randn</span><span class="s4">(</span><span class="s5">200</span><span class="s4">, </span><span class="s5">2</span><span class="s4">)</span>
    <span class="s1">connectivity </span><span class="s4">= </span><span class="s1">kneighbors_graph</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s5">10</span><span class="s4">, </span><span class="s1">include_self</span><span class="s4">=</span><span class="s3">False</span><span class="s4">)</span>
    <span class="s1">agc </span><span class="s4">= </span><span class="s1">AgglomerativeClustering</span><span class="s4">(</span><span class="s1">n_clusters</span><span class="s4">=</span><span class="s1">n_clusters</span><span class="s4">, </span><span class="s1">connectivity</span><span class="s4">=</span><span class="s1">connectivity</span><span class="s4">)</span>
    <span class="s1">agc</span><span class="s4">.</span><span class="s1">fit</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)</span>
    <span class="s1">n_samples </span><span class="s4">= </span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s5">0</span><span class="s4">]</span>
    <span class="s1">n_nodes </span><span class="s4">= </span><span class="s1">agc</span><span class="s4">.</span><span class="s1">children_</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s5">0</span><span class="s4">]</span>
    <span class="s3">assert </span><span class="s1">n_nodes </span><span class="s4">== </span><span class="s1">n_samples </span><span class="s4">- </span><span class="s1">n_clusters</span>


<span class="s3">def </span><span class="s1">test_n_components</span><span class="s4">():</span>
    <span class="s2"># Test n_components returned by linkage, average and ward tree</span>
    <span class="s1">rng </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">random</span><span class="s4">.</span><span class="s1">RandomState</span><span class="s4">(</span><span class="s5">0</span><span class="s4">)</span>
    <span class="s1">X </span><span class="s4">= </span><span class="s1">rng</span><span class="s4">.</span><span class="s1">rand</span><span class="s4">(</span><span class="s5">5</span><span class="s4">, </span><span class="s5">5</span><span class="s4">)</span>

    <span class="s2"># Connectivity matrix having five components.</span>
    <span class="s1">connectivity </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">eye</span><span class="s4">(</span><span class="s5">5</span><span class="s4">)</span>

    <span class="s3">for </span><span class="s1">linkage_func </span><span class="s3">in </span><span class="s1">_TREE_BUILDERS</span><span class="s4">.</span><span class="s1">values</span><span class="s4">():</span>
        <span class="s3">assert </span><span class="s1">ignore_warnings</span><span class="s4">(</span><span class="s1">linkage_func</span><span class="s4">)(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">connectivity</span><span class="s4">=</span><span class="s1">connectivity</span><span class="s4">)[</span><span class="s5">1</span><span class="s4">] == </span><span class="s5">5</span>


<span class="s3">def </span><span class="s1">test_affinity_passed_to_fix_connectivity</span><span class="s4">():</span>
    <span class="s2"># Test that the affinity parameter is actually passed to the pairwise</span>
    <span class="s2"># function</span>

    <span class="s1">size </span><span class="s4">= </span><span class="s5">2</span>
    <span class="s1">rng </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">random</span><span class="s4">.</span><span class="s1">RandomState</span><span class="s4">(</span><span class="s5">0</span><span class="s4">)</span>
    <span class="s1">X </span><span class="s4">= </span><span class="s1">rng</span><span class="s4">.</span><span class="s1">randn</span><span class="s4">(</span><span class="s1">size</span><span class="s4">, </span><span class="s1">size</span><span class="s4">)</span>
    <span class="s1">mask </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">array</span><span class="s4">([</span><span class="s3">True</span><span class="s4">, </span><span class="s3">False</span><span class="s4">, </span><span class="s3">False</span><span class="s4">, </span><span class="s3">True</span><span class="s4">])</span>

    <span class="s1">connectivity </span><span class="s4">= </span><span class="s1">grid_to_graph</span><span class="s4">(</span><span class="s1">n_x</span><span class="s4">=</span><span class="s1">size</span><span class="s4">, </span><span class="s1">n_y</span><span class="s4">=</span><span class="s1">size</span><span class="s4">, </span><span class="s1">mask</span><span class="s4">=</span><span class="s1">mask</span><span class="s4">, </span><span class="s1">return_as</span><span class="s4">=</span><span class="s1">np</span><span class="s4">.</span><span class="s1">ndarray</span><span class="s4">)</span>

    <span class="s3">class </span><span class="s1">FakeAffinity</span><span class="s4">:</span>
        <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">counter </span><span class="s4">= </span><span class="s5">0</span>

        <span class="s3">def </span><span class="s1">increment</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, *</span><span class="s1">args</span><span class="s4">, **</span><span class="s1">kwargs</span><span class="s4">):</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">counter </span><span class="s4">+= </span><span class="s5">1</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">counter</span>

    <span class="s1">fa </span><span class="s4">= </span><span class="s1">FakeAffinity</span><span class="s4">()</span>

    <span class="s1">linkage_tree</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">connectivity</span><span class="s4">=</span><span class="s1">connectivity</span><span class="s4">, </span><span class="s1">affinity</span><span class="s4">=</span><span class="s1">fa</span><span class="s4">.</span><span class="s1">increment</span><span class="s4">)</span>

    <span class="s3">assert </span><span class="s1">fa</span><span class="s4">.</span><span class="s1">counter </span><span class="s4">== </span><span class="s5">3</span>


<span class="s4">@</span><span class="s1">pytest</span><span class="s4">.</span><span class="s1">mark</span><span class="s4">.</span><span class="s1">parametrize</span><span class="s4">(</span><span class="s6">&quot;linkage&quot;</span><span class="s4">, [</span><span class="s6">&quot;ward&quot;</span><span class="s4">, </span><span class="s6">&quot;complete&quot;</span><span class="s4">, </span><span class="s6">&quot;average&quot;</span><span class="s4">])</span>
<span class="s3">def </span><span class="s1">test_agglomerative_clustering_with_distance_threshold</span><span class="s4">(</span><span class="s1">linkage</span><span class="s4">, </span><span class="s1">global_random_seed</span><span class="s4">):</span>
    <span class="s2"># Check that we obtain the correct number of clusters with</span>
    <span class="s2"># agglomerative clustering with distance_threshold.</span>
    <span class="s1">rng </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">random</span><span class="s4">.</span><span class="s1">RandomState</span><span class="s4">(</span><span class="s1">global_random_seed</span><span class="s4">)</span>
    <span class="s1">mask </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">ones</span><span class="s4">([</span><span class="s5">10</span><span class="s4">, </span><span class="s5">10</span><span class="s4">], </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">bool</span><span class="s4">)</span>
    <span class="s1">n_samples </span><span class="s4">= </span><span class="s5">100</span>
    <span class="s1">X </span><span class="s4">= </span><span class="s1">rng</span><span class="s4">.</span><span class="s1">randn</span><span class="s4">(</span><span class="s1">n_samples</span><span class="s4">, </span><span class="s5">50</span><span class="s4">)</span>
    <span class="s1">connectivity </span><span class="s4">= </span><span class="s1">grid_to_graph</span><span class="s4">(*</span><span class="s1">mask</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">)</span>
    <span class="s2"># test when distance threshold is set to 10</span>
    <span class="s1">distance_threshold </span><span class="s4">= </span><span class="s5">10</span>
    <span class="s3">for </span><span class="s1">conn </span><span class="s3">in </span><span class="s4">[</span><span class="s3">None</span><span class="s4">, </span><span class="s1">connectivity</span><span class="s4">]:</span>
        <span class="s1">clustering </span><span class="s4">= </span><span class="s1">AgglomerativeClustering</span><span class="s4">(</span>
            <span class="s1">n_clusters</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
            <span class="s1">distance_threshold</span><span class="s4">=</span><span class="s1">distance_threshold</span><span class="s4">,</span>
            <span class="s1">connectivity</span><span class="s4">=</span><span class="s1">conn</span><span class="s4">,</span>
            <span class="s1">linkage</span><span class="s4">=</span><span class="s1">linkage</span><span class="s4">,</span>
        <span class="s4">)</span>
        <span class="s1">clustering</span><span class="s4">.</span><span class="s1">fit</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)</span>
        <span class="s1">clusters_produced </span><span class="s4">= </span><span class="s1">clustering</span><span class="s4">.</span><span class="s1">labels_</span>
        <span class="s1">num_clusters_produced </span><span class="s4">= </span><span class="s1">len</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">unique</span><span class="s4">(</span><span class="s1">clustering</span><span class="s4">.</span><span class="s1">labels_</span><span class="s4">))</span>
        <span class="s2"># test if the clusters produced match the point in the linkage tree</span>
        <span class="s2"># where the distance exceeds the threshold</span>
        <span class="s1">tree_builder </span><span class="s4">= </span><span class="s1">_TREE_BUILDERS</span><span class="s4">[</span><span class="s1">linkage</span><span class="s4">]</span>
        <span class="s1">children</span><span class="s4">, </span><span class="s1">n_components</span><span class="s4">, </span><span class="s1">n_leaves</span><span class="s4">, </span><span class="s1">parent</span><span class="s4">, </span><span class="s1">distances </span><span class="s4">= </span><span class="s1">tree_builder</span><span class="s4">(</span>
            <span class="s1">X</span><span class="s4">, </span><span class="s1">connectivity</span><span class="s4">=</span><span class="s1">conn</span><span class="s4">, </span><span class="s1">n_clusters</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">return_distance</span><span class="s4">=</span><span class="s3">True</span>
        <span class="s4">)</span>
        <span class="s1">num_clusters_at_threshold </span><span class="s4">= (</span>
            <span class="s1">np</span><span class="s4">.</span><span class="s1">count_nonzero</span><span class="s4">(</span><span class="s1">distances </span><span class="s4">&gt;= </span><span class="s1">distance_threshold</span><span class="s4">) + </span><span class="s5">1</span>
        <span class="s4">)</span>
        <span class="s2"># test number of clusters produced</span>
        <span class="s3">assert </span><span class="s1">num_clusters_at_threshold </span><span class="s4">== </span><span class="s1">num_clusters_produced</span>
        <span class="s2"># test clusters produced</span>
        <span class="s1">clusters_at_threshold </span><span class="s4">= </span><span class="s1">_hc_cut</span><span class="s4">(</span>
            <span class="s1">n_clusters</span><span class="s4">=</span><span class="s1">num_clusters_produced</span><span class="s4">, </span><span class="s1">children</span><span class="s4">=</span><span class="s1">children</span><span class="s4">, </span><span class="s1">n_leaves</span><span class="s4">=</span><span class="s1">n_leaves</span>
        <span class="s4">)</span>
        <span class="s3">assert </span><span class="s1">np</span><span class="s4">.</span><span class="s1">array_equiv</span><span class="s4">(</span><span class="s1">clusters_produced</span><span class="s4">, </span><span class="s1">clusters_at_threshold</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">test_small_distance_threshold</span><span class="s4">(</span><span class="s1">global_random_seed</span><span class="s4">):</span>
    <span class="s1">rng </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">random</span><span class="s4">.</span><span class="s1">RandomState</span><span class="s4">(</span><span class="s1">global_random_seed</span><span class="s4">)</span>
    <span class="s1">n_samples </span><span class="s4">= </span><span class="s5">10</span>
    <span class="s1">X </span><span class="s4">= </span><span class="s1">rng</span><span class="s4">.</span><span class="s1">randint</span><span class="s4">(-</span><span class="s5">300</span><span class="s4">, </span><span class="s5">300</span><span class="s4">, </span><span class="s1">size</span><span class="s4">=(</span><span class="s1">n_samples</span><span class="s4">, </span><span class="s5">3</span><span class="s4">))</span>
    <span class="s2"># this should result in all data in their own clusters, given that</span>
    <span class="s2"># their pairwise distances are bigger than .1 (which may not be the case</span>
    <span class="s2"># with a different random seed).</span>
    <span class="s1">clustering </span><span class="s4">= </span><span class="s1">AgglomerativeClustering</span><span class="s4">(</span>
        <span class="s1">n_clusters</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">distance_threshold</span><span class="s4">=</span><span class="s5">1.0</span><span class="s4">, </span><span class="s1">linkage</span><span class="s4">=</span><span class="s6">&quot;single&quot;</span>
    <span class="s4">).</span><span class="s1">fit</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)</span>
    <span class="s2"># check that the pairwise distances are indeed all larger than .1</span>
    <span class="s1">all_distances </span><span class="s4">= </span><span class="s1">pairwise_distances</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">metric</span><span class="s4">=</span><span class="s6">&quot;minkowski&quot;</span><span class="s4">, </span><span class="s1">p</span><span class="s4">=</span><span class="s5">2</span><span class="s4">)</span>
    <span class="s1">np</span><span class="s4">.</span><span class="s1">fill_diagonal</span><span class="s4">(</span><span class="s1">all_distances</span><span class="s4">, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">inf</span><span class="s4">)</span>
    <span class="s3">assert </span><span class="s1">np</span><span class="s4">.</span><span class="s1">all</span><span class="s4">(</span><span class="s1">all_distances </span><span class="s4">&gt; </span><span class="s5">0.1</span><span class="s4">)</span>
    <span class="s3">assert </span><span class="s1">clustering</span><span class="s4">.</span><span class="s1">n_clusters_ </span><span class="s4">== </span><span class="s1">n_samples</span>


<span class="s3">def </span><span class="s1">test_cluster_distances_with_distance_threshold</span><span class="s4">(</span><span class="s1">global_random_seed</span><span class="s4">):</span>
    <span class="s1">rng </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">random</span><span class="s4">.</span><span class="s1">RandomState</span><span class="s4">(</span><span class="s1">global_random_seed</span><span class="s4">)</span>
    <span class="s1">n_samples </span><span class="s4">= </span><span class="s5">100</span>
    <span class="s1">X </span><span class="s4">= </span><span class="s1">rng</span><span class="s4">.</span><span class="s1">randint</span><span class="s4">(-</span><span class="s5">10</span><span class="s4">, </span><span class="s5">10</span><span class="s4">, </span><span class="s1">size</span><span class="s4">=(</span><span class="s1">n_samples</span><span class="s4">, </span><span class="s5">3</span><span class="s4">))</span>
    <span class="s2"># check the distances within the clusters and with other clusters</span>
    <span class="s1">distance_threshold </span><span class="s4">= </span><span class="s5">4</span>
    <span class="s1">clustering </span><span class="s4">= </span><span class="s1">AgglomerativeClustering</span><span class="s4">(</span>
        <span class="s1">n_clusters</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">distance_threshold</span><span class="s4">=</span><span class="s1">distance_threshold</span><span class="s4">, </span><span class="s1">linkage</span><span class="s4">=</span><span class="s6">&quot;single&quot;</span>
    <span class="s4">).</span><span class="s1">fit</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)</span>
    <span class="s1">labels </span><span class="s4">= </span><span class="s1">clustering</span><span class="s4">.</span><span class="s1">labels_</span>
    <span class="s1">D </span><span class="s4">= </span><span class="s1">pairwise_distances</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">metric</span><span class="s4">=</span><span class="s6">&quot;minkowski&quot;</span><span class="s4">, </span><span class="s1">p</span><span class="s4">=</span><span class="s5">2</span><span class="s4">)</span>
    <span class="s2"># to avoid taking the 0 diagonal in min()</span>
    <span class="s1">np</span><span class="s4">.</span><span class="s1">fill_diagonal</span><span class="s4">(</span><span class="s1">D</span><span class="s4">, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">inf</span><span class="s4">)</span>
    <span class="s3">for </span><span class="s1">label </span><span class="s3">in </span><span class="s1">np</span><span class="s4">.</span><span class="s1">unique</span><span class="s4">(</span><span class="s1">labels</span><span class="s4">):</span>
        <span class="s1">in_cluster_mask </span><span class="s4">= </span><span class="s1">labels </span><span class="s4">== </span><span class="s1">label</span>
        <span class="s1">max_in_cluster_distance </span><span class="s4">= (</span>
            <span class="s1">D</span><span class="s4">[</span><span class="s1">in_cluster_mask</span><span class="s4">][:, </span><span class="s1">in_cluster_mask</span><span class="s4">].</span><span class="s1">min</span><span class="s4">(</span><span class="s1">axis</span><span class="s4">=</span><span class="s5">0</span><span class="s4">).</span><span class="s1">max</span><span class="s4">()</span>
        <span class="s4">)</span>
        <span class="s1">min_out_cluster_distance </span><span class="s4">= (</span>
            <span class="s1">D</span><span class="s4">[</span><span class="s1">in_cluster_mask</span><span class="s4">][:, ~</span><span class="s1">in_cluster_mask</span><span class="s4">].</span><span class="s1">min</span><span class="s4">(</span><span class="s1">axis</span><span class="s4">=</span><span class="s5">0</span><span class="s4">).</span><span class="s1">min</span><span class="s4">()</span>
        <span class="s4">)</span>
        <span class="s2"># single data point clusters only have that inf diagonal here</span>
        <span class="s3">if </span><span class="s1">in_cluster_mask</span><span class="s4">.</span><span class="s1">sum</span><span class="s4">() &gt; </span><span class="s5">1</span><span class="s4">:</span>
            <span class="s3">assert </span><span class="s1">max_in_cluster_distance </span><span class="s4">&lt; </span><span class="s1">distance_threshold</span>
        <span class="s3">assert </span><span class="s1">min_out_cluster_distance </span><span class="s4">&gt;= </span><span class="s1">distance_threshold</span>


<span class="s4">@</span><span class="s1">pytest</span><span class="s4">.</span><span class="s1">mark</span><span class="s4">.</span><span class="s1">parametrize</span><span class="s4">(</span><span class="s6">&quot;linkage&quot;</span><span class="s4">, [</span><span class="s6">&quot;ward&quot;</span><span class="s4">, </span><span class="s6">&quot;complete&quot;</span><span class="s4">, </span><span class="s6">&quot;average&quot;</span><span class="s4">])</span>
<span class="s4">@</span><span class="s1">pytest</span><span class="s4">.</span><span class="s1">mark</span><span class="s4">.</span><span class="s1">parametrize</span><span class="s4">(</span>
    <span class="s4">(</span><span class="s6">&quot;threshold&quot;</span><span class="s4">, </span><span class="s6">&quot;y_true&quot;</span><span class="s4">), [(</span><span class="s5">0.5</span><span class="s4">, [</span><span class="s5">1</span><span class="s4">, </span><span class="s5">0</span><span class="s4">]), (</span><span class="s5">1.0</span><span class="s4">, [</span><span class="s5">1</span><span class="s4">, </span><span class="s5">0</span><span class="s4">]), (</span><span class="s5">1.5</span><span class="s4">, [</span><span class="s5">0</span><span class="s4">, </span><span class="s5">0</span><span class="s4">])]</span>
<span class="s4">)</span>
<span class="s3">def </span><span class="s1">test_agglomerative_clustering_with_distance_threshold_edge_case</span><span class="s4">(</span>
    <span class="s1">linkage</span><span class="s4">, </span><span class="s1">threshold</span><span class="s4">, </span><span class="s1">y_true</span>
<span class="s4">):</span>
    <span class="s2"># test boundary case of distance_threshold matching the distance</span>
    <span class="s1">X </span><span class="s4">= [[</span><span class="s5">0</span><span class="s4">], [</span><span class="s5">1</span><span class="s4">]]</span>
    <span class="s1">clusterer </span><span class="s4">= </span><span class="s1">AgglomerativeClustering</span><span class="s4">(</span>
        <span class="s1">n_clusters</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">distance_threshold</span><span class="s4">=</span><span class="s1">threshold</span><span class="s4">, </span><span class="s1">linkage</span><span class="s4">=</span><span class="s1">linkage</span>
    <span class="s4">)</span>
    <span class="s1">y_pred </span><span class="s4">= </span><span class="s1">clusterer</span><span class="s4">.</span><span class="s1">fit_predict</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)</span>
    <span class="s3">assert </span><span class="s1">adjusted_rand_score</span><span class="s4">(</span><span class="s1">y_true</span><span class="s4">, </span><span class="s1">y_pred</span><span class="s4">) == </span><span class="s5">1</span>


<span class="s3">def </span><span class="s1">test_dist_threshold_invalid_parameters</span><span class="s4">():</span>
    <span class="s1">X </span><span class="s4">= [[</span><span class="s5">0</span><span class="s4">], [</span><span class="s5">1</span><span class="s4">]]</span>
    <span class="s3">with </span><span class="s1">pytest</span><span class="s4">.</span><span class="s1">raises</span><span class="s4">(</span><span class="s1">ValueError</span><span class="s4">, </span><span class="s1">match</span><span class="s4">=</span><span class="s6">&quot;Exactly one of &quot;</span><span class="s4">):</span>
        <span class="s1">AgglomerativeClustering</span><span class="s4">(</span><span class="s1">n_clusters</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">distance_threshold</span><span class="s4">=</span><span class="s3">None</span><span class="s4">).</span><span class="s1">fit</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)</span>

    <span class="s3">with </span><span class="s1">pytest</span><span class="s4">.</span><span class="s1">raises</span><span class="s4">(</span><span class="s1">ValueError</span><span class="s4">, </span><span class="s1">match</span><span class="s4">=</span><span class="s6">&quot;Exactly one of &quot;</span><span class="s4">):</span>
        <span class="s1">AgglomerativeClustering</span><span class="s4">(</span><span class="s1">n_clusters</span><span class="s4">=</span><span class="s5">2</span><span class="s4">, </span><span class="s1">distance_threshold</span><span class="s4">=</span><span class="s5">1</span><span class="s4">).</span><span class="s1">fit</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)</span>

    <span class="s1">X </span><span class="s4">= [[</span><span class="s5">0</span><span class="s4">], [</span><span class="s5">1</span><span class="s4">]]</span>
    <span class="s3">with </span><span class="s1">pytest</span><span class="s4">.</span><span class="s1">raises</span><span class="s4">(</span><span class="s1">ValueError</span><span class="s4">, </span><span class="s1">match</span><span class="s4">=</span><span class="s6">&quot;compute_full_tree must be True if&quot;</span><span class="s4">):</span>
        <span class="s1">AgglomerativeClustering</span><span class="s4">(</span>
            <span class="s1">n_clusters</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">distance_threshold</span><span class="s4">=</span><span class="s5">1</span><span class="s4">, </span><span class="s1">compute_full_tree</span><span class="s4">=</span><span class="s3">False</span>
        <span class="s4">).</span><span class="s1">fit</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">test_invalid_shape_precomputed_dist_matrix</span><span class="s4">():</span>
    <span class="s2"># Check that an error is raised when affinity='precomputed'</span>
    <span class="s2"># and a non square matrix is passed (PR #16257).</span>
    <span class="s1">rng </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">random</span><span class="s4">.</span><span class="s1">RandomState</span><span class="s4">(</span><span class="s5">0</span><span class="s4">)</span>
    <span class="s1">X </span><span class="s4">= </span><span class="s1">rng</span><span class="s4">.</span><span class="s1">rand</span><span class="s4">(</span><span class="s5">5</span><span class="s4">, </span><span class="s5">3</span><span class="s4">)</span>
    <span class="s3">with </span><span class="s1">pytest</span><span class="s4">.</span><span class="s1">raises</span><span class="s4">(</span>
        <span class="s1">ValueError</span><span class="s4">,</span>
        <span class="s1">match</span><span class="s4">=</span><span class="s6">r&quot;Distance matrix should be square, got matrix of shape \(5, 3\)&quot;</span><span class="s4">,</span>
    <span class="s4">):</span>
        <span class="s1">AgglomerativeClustering</span><span class="s4">(</span><span class="s1">metric</span><span class="s4">=</span><span class="s6">&quot;precomputed&quot;</span><span class="s4">, </span><span class="s1">linkage</span><span class="s4">=</span><span class="s6">&quot;complete&quot;</span><span class="s4">).</span><span class="s1">fit</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">test_precomputed_connectivity_metric_with_2_connected_components</span><span class="s4">():</span>
    <span class="s0">&quot;&quot;&quot;Check that connecting components works when connectivity and 
    affinity are both precomputed and the number of connected components is 
    greater than 1. Non-regression test for #16151. 
    &quot;&quot;&quot;</span>

    <span class="s1">connectivity_matrix </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">array</span><span class="s4">(</span>
        <span class="s4">[</span>
            <span class="s4">[</span><span class="s5">0</span><span class="s4">, </span><span class="s5">1</span><span class="s4">, </span><span class="s5">1</span><span class="s4">, </span><span class="s5">0</span><span class="s4">, </span><span class="s5">0</span><span class="s4">],</span>
            <span class="s4">[</span><span class="s5">0</span><span class="s4">, </span><span class="s5">0</span><span class="s4">, </span><span class="s5">1</span><span class="s4">, </span><span class="s5">0</span><span class="s4">, </span><span class="s5">0</span><span class="s4">],</span>
            <span class="s4">[</span><span class="s5">0</span><span class="s4">, </span><span class="s5">0</span><span class="s4">, </span><span class="s5">0</span><span class="s4">, </span><span class="s5">0</span><span class="s4">, </span><span class="s5">0</span><span class="s4">],</span>
            <span class="s4">[</span><span class="s5">0</span><span class="s4">, </span><span class="s5">0</span><span class="s4">, </span><span class="s5">0</span><span class="s4">, </span><span class="s5">0</span><span class="s4">, </span><span class="s5">1</span><span class="s4">],</span>
            <span class="s4">[</span><span class="s5">0</span><span class="s4">, </span><span class="s5">0</span><span class="s4">, </span><span class="s5">0</span><span class="s4">, </span><span class="s5">0</span><span class="s4">, </span><span class="s5">0</span><span class="s4">],</span>
        <span class="s4">]</span>
    <span class="s4">)</span>
    <span class="s2"># ensure that connectivity_matrix has two connected components</span>
    <span class="s3">assert </span><span class="s1">connected_components</span><span class="s4">(</span><span class="s1">connectivity_matrix</span><span class="s4">)[</span><span class="s5">0</span><span class="s4">] == </span><span class="s5">2</span>

    <span class="s1">rng </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">random</span><span class="s4">.</span><span class="s1">RandomState</span><span class="s4">(</span><span class="s5">0</span><span class="s4">)</span>
    <span class="s1">X </span><span class="s4">= </span><span class="s1">rng</span><span class="s4">.</span><span class="s1">randn</span><span class="s4">(</span><span class="s5">5</span><span class="s4">, </span><span class="s5">10</span><span class="s4">)</span>

    <span class="s1">X_dist </span><span class="s4">= </span><span class="s1">pairwise_distances</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)</span>
    <span class="s1">clusterer_precomputed </span><span class="s4">= </span><span class="s1">AgglomerativeClustering</span><span class="s4">(</span>
        <span class="s1">metric</span><span class="s4">=</span><span class="s6">&quot;precomputed&quot;</span><span class="s4">, </span><span class="s1">connectivity</span><span class="s4">=</span><span class="s1">connectivity_matrix</span><span class="s4">, </span><span class="s1">linkage</span><span class="s4">=</span><span class="s6">&quot;complete&quot;</span>
    <span class="s4">)</span>
    <span class="s1">msg </span><span class="s4">= </span><span class="s6">&quot;Completing it to avoid stopping the tree early&quot;</span>
    <span class="s3">with </span><span class="s1">pytest</span><span class="s4">.</span><span class="s1">warns</span><span class="s4">(</span><span class="s1">UserWarning</span><span class="s4">, </span><span class="s1">match</span><span class="s4">=</span><span class="s1">msg</span><span class="s4">):</span>
        <span class="s1">clusterer_precomputed</span><span class="s4">.</span><span class="s1">fit</span><span class="s4">(</span><span class="s1">X_dist</span><span class="s4">)</span>

    <span class="s1">clusterer </span><span class="s4">= </span><span class="s1">AgglomerativeClustering</span><span class="s4">(</span>
        <span class="s1">connectivity</span><span class="s4">=</span><span class="s1">connectivity_matrix</span><span class="s4">, </span><span class="s1">linkage</span><span class="s4">=</span><span class="s6">&quot;complete&quot;</span>
    <span class="s4">)</span>
    <span class="s3">with </span><span class="s1">pytest</span><span class="s4">.</span><span class="s1">warns</span><span class="s4">(</span><span class="s1">UserWarning</span><span class="s4">, </span><span class="s1">match</span><span class="s4">=</span><span class="s1">msg</span><span class="s4">):</span>
        <span class="s1">clusterer</span><span class="s4">.</span><span class="s1">fit</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)</span>

    <span class="s1">assert_array_equal</span><span class="s4">(</span><span class="s1">clusterer</span><span class="s4">.</span><span class="s1">labels_</span><span class="s4">, </span><span class="s1">clusterer_precomputed</span><span class="s4">.</span><span class="s1">labels_</span><span class="s4">)</span>
    <span class="s1">assert_array_equal</span><span class="s4">(</span><span class="s1">clusterer</span><span class="s4">.</span><span class="s1">children_</span><span class="s4">, </span><span class="s1">clusterer_precomputed</span><span class="s4">.</span><span class="s1">children_</span><span class="s4">)</span>


<span class="s2"># TODO(1.6): remove in 1.6</span>
<span class="s4">@</span><span class="s1">pytest</span><span class="s4">.</span><span class="s1">mark</span><span class="s4">.</span><span class="s1">parametrize</span><span class="s4">(</span>
    <span class="s6">&quot;Agglomeration&quot;</span><span class="s4">, [</span><span class="s1">AgglomerativeClustering</span><span class="s4">, </span><span class="s1">FeatureAgglomeration</span><span class="s4">]</span>
<span class="s4">)</span>
<span class="s3">def </span><span class="s1">test_deprecation_warning_metric_None</span><span class="s4">(</span><span class="s1">Agglomeration</span><span class="s4">):</span>
    <span class="s1">X </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">array</span><span class="s4">([[</span><span class="s5">1</span><span class="s4">, </span><span class="s5">2</span><span class="s4">], [</span><span class="s5">1</span><span class="s4">, </span><span class="s5">4</span><span class="s4">], [</span><span class="s5">1</span><span class="s4">, </span><span class="s5">0</span><span class="s4">], [</span><span class="s5">4</span><span class="s4">, </span><span class="s5">2</span><span class="s4">], [</span><span class="s5">4</span><span class="s4">, </span><span class="s5">4</span><span class="s4">], [</span><span class="s5">4</span><span class="s4">, </span><span class="s5">0</span><span class="s4">]])</span>
    <span class="s1">warn_msg </span><span class="s4">= </span><span class="s6">&quot;`metric=None` is deprecated in version 1.4 and will be removed&quot;</span>
    <span class="s3">with </span><span class="s1">pytest</span><span class="s4">.</span><span class="s1">warns</span><span class="s4">(</span><span class="s1">FutureWarning</span><span class="s4">, </span><span class="s1">match</span><span class="s4">=</span><span class="s1">warn_msg</span><span class="s4">):</span>
        <span class="s1">Agglomeration</span><span class="s4">(</span><span class="s1">metric</span><span class="s4">=</span><span class="s3">None</span><span class="s4">).</span><span class="s1">fit</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)</span>
</pre>
</body>
</html>