<html>
<head>
<title>_c_m_a_p.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #2aacb8;}
.s4 { color: #5f826b; font-style: italic;}
.s5 { color: #7a7e85;}
.s6 { color: #6aab73;}
.s7 { color: #a5c261;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_c_m_a_p.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">fontTools</span><span class="s2">.</span><span class="s1">misc</span><span class="s2">.</span><span class="s1">textTools </span><span class="s0">import </span><span class="s1">bytesjoin</span><span class="s2">, </span><span class="s1">safeEval</span><span class="s2">, </span><span class="s1">readHex</span>
<span class="s0">from </span><span class="s1">fontTools</span><span class="s2">.</span><span class="s1">misc</span><span class="s2">.</span><span class="s1">encodingTools </span><span class="s0">import </span><span class="s1">getEncoding</span>
<span class="s0">from </span><span class="s1">fontTools</span><span class="s2">.</span><span class="s1">ttLib </span><span class="s0">import </span><span class="s1">getSearchRange</span>
<span class="s0">from </span><span class="s1">fontTools</span><span class="s2">.</span><span class="s1">unicode </span><span class="s0">import </span><span class="s1">Unicode</span>
<span class="s0">from </span><span class="s2">. </span><span class="s0">import </span><span class="s1">DefaultTable</span>
<span class="s0">import </span><span class="s1">sys</span>
<span class="s0">import </span><span class="s1">struct</span>
<span class="s0">import </span><span class="s1">array</span>
<span class="s0">import </span><span class="s1">logging</span>


<span class="s1">log </span><span class="s2">= </span><span class="s1">logging</span><span class="s2">.</span><span class="s1">getLogger</span><span class="s2">(</span><span class="s1">__name__</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">_make_map</span><span class="s2">(</span><span class="s1">font</span><span class="s2">, </span><span class="s1">chars</span><span class="s2">, </span><span class="s1">gids</span><span class="s2">):</span>
    <span class="s0">assert </span><span class="s1">len</span><span class="s2">(</span><span class="s1">chars</span><span class="s2">) == </span><span class="s1">len</span><span class="s2">(</span><span class="s1">gids</span><span class="s2">)</span>
    <span class="s1">glyphNames </span><span class="s2">= </span><span class="s1">font</span><span class="s2">.</span><span class="s1">getGlyphNameMany</span><span class="s2">(</span><span class="s1">gids</span><span class="s2">)</span>
    <span class="s1">cmap </span><span class="s2">= {}</span>
    <span class="s0">for </span><span class="s1">char</span><span class="s2">, </span><span class="s1">gid</span><span class="s2">, </span><span class="s1">name </span><span class="s0">in </span><span class="s1">zip</span><span class="s2">(</span><span class="s1">chars</span><span class="s2">, </span><span class="s1">gids</span><span class="s2">, </span><span class="s1">glyphNames</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">gid </span><span class="s2">== </span><span class="s3">0</span><span class="s2">:</span>
            <span class="s0">continue</span>
        <span class="s1">cmap</span><span class="s2">[</span><span class="s1">char</span><span class="s2">] = </span><span class="s1">name</span>
    <span class="s0">return </span><span class="s1">cmap</span>


<span class="s0">class </span><span class="s1">table__c_m_a_p</span><span class="s2">(</span><span class="s1">DefaultTable</span><span class="s2">.</span><span class="s1">DefaultTable</span><span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot;Character to Glyph Index Mapping Table 
 
    This class represents the `cmap &lt;https://docs.microsoft.com/en-us/typography/opentype/spec/cmap&gt;`_ 
    table, which maps between input characters (in Unicode or other system encodings) 
    and glyphs within the font. The ``cmap`` table contains one or more subtables 
    which determine the mapping of of characters to glyphs across different platforms 
    and encoding systems. 
 
    ``table__c_m_a_p`` objects expose an accessor ``.tables`` which provides access 
    to the subtables, although it is normally easier to retrieve individual subtables 
    through the utility methods described below. To add new subtables to a font, 
    first determine the subtable format (if in doubt use format 4 for glyphs within 
    the BMP, format 12 for glyphs outside the BMP, and format 14 for Unicode Variation 
    Sequences) construct subtable objects with ``CmapSubtable.newSubtable(format)``, 
    and append them to the ``.tables`` list. 
 
    Within a subtable, the mapping of characters to glyphs is provided by the ``.cmap`` 
    attribute. 
 
    Example:: 
 
            cmap4_0_3 = CmapSubtable.newSubtable(4) 
            cmap4_0_3.platformID = 0 
            cmap4_0_3.platEncID = 3 
            cmap4_0_3.language = 0 
            cmap4_0_3.cmap = { 0xC1: &quot;Aacute&quot; } 
 
            cmap = newTable(&quot;cmap&quot;) 
            cmap.tableVersion = 0 
            cmap.tables = [cmap4_0_3] 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">getcmap</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">platformID</span><span class="s2">, </span><span class="s1">platEncID</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot;Returns the first subtable which matches the given platform and encoding. 
 
        Args: 
                platformID (int): The platform ID. Use 0 for Unicode, 1 for Macintosh 
                        (deprecated for new fonts), 2 for ISO (deprecated) and 3 for Windows. 
                encodingID (int): Encoding ID. Interpretation depends on the platform ID. 
                        See the OpenType specification for details. 
 
        Returns: 
                An object which is a subclass of :py:class:`CmapSubtable` if a matching 
                subtable is found within the font, or ``None`` otherwise. 
        &quot;&quot;&quot;</span>

        <span class="s0">for </span><span class="s1">subtable </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">tables</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">subtable</span><span class="s2">.</span><span class="s1">platformID </span><span class="s2">== </span><span class="s1">platformID </span><span class="s0">and </span><span class="s1">subtable</span><span class="s2">.</span><span class="s1">platEncID </span><span class="s2">== </span><span class="s1">platEncID</span><span class="s2">:</span>
                <span class="s0">return </span><span class="s1">subtable</span>
        <span class="s0">return None  </span><span class="s5"># not found</span>

    <span class="s0">def </span><span class="s1">getBestCmap</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">cmapPreferences</span><span class="s2">=(</span>
            <span class="s2">(</span><span class="s3">3</span><span class="s2">, </span><span class="s3">10</span><span class="s2">),</span>
            <span class="s2">(</span><span class="s3">0</span><span class="s2">, </span><span class="s3">6</span><span class="s2">),</span>
            <span class="s2">(</span><span class="s3">0</span><span class="s2">, </span><span class="s3">4</span><span class="s2">),</span>
            <span class="s2">(</span><span class="s3">3</span><span class="s2">, </span><span class="s3">1</span><span class="s2">),</span>
            <span class="s2">(</span><span class="s3">0</span><span class="s2">, </span><span class="s3">3</span><span class="s2">),</span>
            <span class="s2">(</span><span class="s3">0</span><span class="s2">, </span><span class="s3">2</span><span class="s2">),</span>
            <span class="s2">(</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">),</span>
            <span class="s2">(</span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">),</span>
        <span class="s2">),</span>
    <span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot;Returns the 'best' Unicode cmap dictionary available in the font 
        or ``None``, if no Unicode cmap subtable is available. 
 
        By default it will search for the following (platformID, platEncID) 
        pairs in order:: 
 
                        (3, 10), # Windows Unicode full repertoire 
                        (0, 6),  # Unicode full repertoire (format 13 subtable) 
                        (0, 4),  # Unicode 2.0 full repertoire 
                        (3, 1),  # Windows Unicode BMP 
                        (0, 3),  # Unicode 2.0 BMP 
                        (0, 2),  # Unicode ISO/IEC 10646 
                        (0, 1),  # Unicode 1.1 
                        (0, 0)   # Unicode 1.0 
 
        This particular order matches what HarfBuzz uses to choose what 
        subtable to use by default. This order prefers the largest-repertoire 
        subtable, and among those, prefers the Windows-platform over the 
        Unicode-platform as the former has wider support. 
 
        This order can be customized via the ``cmapPreferences`` argument. 
        &quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">platformID</span><span class="s2">, </span><span class="s1">platEncID </span><span class="s0">in </span><span class="s1">cmapPreferences</span><span class="s2">:</span>
            <span class="s1">cmapSubtable </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">getcmap</span><span class="s2">(</span><span class="s1">platformID</span><span class="s2">, </span><span class="s1">platEncID</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">cmapSubtable </span><span class="s0">is not None</span><span class="s2">:</span>
                <span class="s0">return </span><span class="s1">cmapSubtable</span><span class="s2">.</span><span class="s1">cmap</span>
        <span class="s0">return None  </span><span class="s5"># None of the requested cmap subtables were found</span>

    <span class="s0">def </span><span class="s1">buildReversed</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot;Builds a reverse mapping dictionary 
 
        Iterates over all Unicode cmap tables and returns a dictionary mapping 
        glyphs to sets of codepoints, such as:: 
 
                { 
                        'one': {0x31} 
                        'A': {0x41,0x391} 
                } 
 
        The values are sets of Unicode codepoints because 
        some fonts map different codepoints to the same glyph. 
        For example, ``U+0041 LATIN CAPITAL LETTER A`` and ``U+0391 
        GREEK CAPITAL LETTER ALPHA`` are sometimes the same glyph. 
        &quot;&quot;&quot;</span>
        <span class="s1">result </span><span class="s2">= {}</span>
        <span class="s0">for </span><span class="s1">subtable </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">tables</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">subtable</span><span class="s2">.</span><span class="s1">isUnicode</span><span class="s2">():</span>
                <span class="s0">for </span><span class="s1">codepoint</span><span class="s2">, </span><span class="s1">name </span><span class="s0">in </span><span class="s1">subtable</span><span class="s2">.</span><span class="s1">cmap</span><span class="s2">.</span><span class="s1">items</span><span class="s2">():</span>
                    <span class="s1">result</span><span class="s2">.</span><span class="s1">setdefault</span><span class="s2">(</span><span class="s1">name</span><span class="s2">, </span><span class="s1">set</span><span class="s2">()).</span><span class="s1">add</span><span class="s2">(</span><span class="s1">codepoint</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">result</span>

    <span class="s0">def </span><span class="s1">decompile</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">ttFont</span><span class="s2">):</span>
        <span class="s1">tableVersion</span><span class="s2">, </span><span class="s1">numSubTables </span><span class="s2">= </span><span class="s1">struct</span><span class="s2">.</span><span class="s1">unpack</span><span class="s2">(</span><span class="s6">&quot;&gt;HH&quot;</span><span class="s2">, </span><span class="s1">data</span><span class="s2">[:</span><span class="s3">4</span><span class="s2">])</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">tableVersion </span><span class="s2">= </span><span class="s1">int</span><span class="s2">(</span><span class="s1">tableVersion</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">tables </span><span class="s2">= </span><span class="s1">tables </span><span class="s2">= []</span>
        <span class="s1">seenOffsets </span><span class="s2">= {}</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">numSubTables</span><span class="s2">):</span>
            <span class="s1">platformID</span><span class="s2">, </span><span class="s1">platEncID</span><span class="s2">, </span><span class="s1">offset </span><span class="s2">= </span><span class="s1">struct</span><span class="s2">.</span><span class="s1">unpack</span><span class="s2">(</span>
                <span class="s6">&quot;&gt;HHl&quot;</span><span class="s2">, </span><span class="s1">data</span><span class="s2">[</span><span class="s3">4 </span><span class="s2">+ </span><span class="s1">i </span><span class="s2">* </span><span class="s3">8 </span><span class="s2">: </span><span class="s3">4 </span><span class="s2">+ (</span><span class="s1">i </span><span class="s2">+ </span><span class="s3">1</span><span class="s2">) * </span><span class="s3">8</span><span class="s2">]</span>
            <span class="s2">)</span>
            <span class="s1">platformID</span><span class="s2">, </span><span class="s1">platEncID </span><span class="s2">= </span><span class="s1">int</span><span class="s2">(</span><span class="s1">platformID</span><span class="s2">), </span><span class="s1">int</span><span class="s2">(</span><span class="s1">platEncID</span><span class="s2">)</span>
            <span class="s1">format</span><span class="s2">, </span><span class="s1">length </span><span class="s2">= </span><span class="s1">struct</span><span class="s2">.</span><span class="s1">unpack</span><span class="s2">(</span><span class="s6">&quot;&gt;HH&quot;</span><span class="s2">, </span><span class="s1">data</span><span class="s2">[</span><span class="s1">offset </span><span class="s2">: </span><span class="s1">offset </span><span class="s2">+ </span><span class="s3">4</span><span class="s2">])</span>
            <span class="s0">if </span><span class="s1">format </span><span class="s0">in </span><span class="s2">[</span><span class="s3">8</span><span class="s2">, </span><span class="s3">10</span><span class="s2">, </span><span class="s3">12</span><span class="s2">, </span><span class="s3">13</span><span class="s2">]:</span>
                <span class="s1">format</span><span class="s2">, </span><span class="s1">reserved</span><span class="s2">, </span><span class="s1">length </span><span class="s2">= </span><span class="s1">struct</span><span class="s2">.</span><span class="s1">unpack</span><span class="s2">(</span>
                    <span class="s6">&quot;&gt;HHL&quot;</span><span class="s2">, </span><span class="s1">data</span><span class="s2">[</span><span class="s1">offset </span><span class="s2">: </span><span class="s1">offset </span><span class="s2">+ </span><span class="s3">8</span><span class="s2">]</span>
                <span class="s2">)</span>
            <span class="s0">elif </span><span class="s1">format </span><span class="s0">in </span><span class="s2">[</span><span class="s3">14</span><span class="s2">]:</span>
                <span class="s1">format</span><span class="s2">, </span><span class="s1">length </span><span class="s2">= </span><span class="s1">struct</span><span class="s2">.</span><span class="s1">unpack</span><span class="s2">(</span><span class="s6">&quot;&gt;HL&quot;</span><span class="s2">, </span><span class="s1">data</span><span class="s2">[</span><span class="s1">offset </span><span class="s2">: </span><span class="s1">offset </span><span class="s2">+ </span><span class="s3">6</span><span class="s2">])</span>

            <span class="s0">if not </span><span class="s1">length</span><span class="s2">:</span>
                <span class="s1">log</span><span class="s2">.</span><span class="s1">error</span><span class="s2">(</span>
                    <span class="s6">&quot;cmap subtable is reported as having zero length: platformID %s, &quot;</span>
                    <span class="s6">&quot;platEncID %s, format %s offset %s. Skipping table.&quot;</span><span class="s2">,</span>
                    <span class="s1">platformID</span><span class="s2">,</span>
                    <span class="s1">platEncID</span><span class="s2">,</span>
                    <span class="s1">format</span><span class="s2">,</span>
                    <span class="s1">offset</span><span class="s2">,</span>
                <span class="s2">)</span>
                <span class="s0">continue</span>
            <span class="s1">table </span><span class="s2">= </span><span class="s1">CmapSubtable</span><span class="s2">.</span><span class="s1">newSubtable</span><span class="s2">(</span><span class="s1">format</span><span class="s2">)</span>
            <span class="s1">table</span><span class="s2">.</span><span class="s1">platformID </span><span class="s2">= </span><span class="s1">platformID</span>
            <span class="s1">table</span><span class="s2">.</span><span class="s1">platEncID </span><span class="s2">= </span><span class="s1">platEncID</span>
            <span class="s5"># Note that by default we decompile only the subtable header info;</span>
            <span class="s5"># any other data gets decompiled only when an attribute of the</span>
            <span class="s5"># subtable is referenced.</span>
            <span class="s1">table</span><span class="s2">.</span><span class="s1">decompileHeader</span><span class="s2">(</span><span class="s1">data</span><span class="s2">[</span><span class="s1">offset </span><span class="s2">: </span><span class="s1">offset </span><span class="s2">+ </span><span class="s1">int</span><span class="s2">(</span><span class="s1">length</span><span class="s2">)], </span><span class="s1">ttFont</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">offset </span><span class="s0">in </span><span class="s1">seenOffsets</span><span class="s2">:</span>
                <span class="s1">table</span><span class="s2">.</span><span class="s1">data </span><span class="s2">= </span><span class="s0">None  </span><span class="s5"># Mark as decompiled</span>
                <span class="s1">table</span><span class="s2">.</span><span class="s1">cmap </span><span class="s2">= </span><span class="s1">tables</span><span class="s2">[</span><span class="s1">seenOffsets</span><span class="s2">[</span><span class="s1">offset</span><span class="s2">]].</span><span class="s1">cmap</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">seenOffsets</span><span class="s2">[</span><span class="s1">offset</span><span class="s2">] = </span><span class="s1">i</span>
            <span class="s1">tables</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">table</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">ttFont</span><span class="s2">.</span><span class="s1">lazy </span><span class="s0">is False</span><span class="s2">:  </span><span class="s5"># Be lazy for None and True</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">ensureDecompiled</span><span class="s2">()</span>

    <span class="s0">def </span><span class="s1">ensureDecompiled</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">recurse</span><span class="s2">=</span><span class="s0">False</span><span class="s2">):</span>
        <span class="s5"># The recurse argument is unused, but part of the signature of</span>
        <span class="s5"># ensureDecompiled across the library.</span>
        <span class="s0">for </span><span class="s1">st </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">tables</span><span class="s2">:</span>
            <span class="s1">st</span><span class="s2">.</span><span class="s1">ensureDecompiled</span><span class="s2">()</span>

    <span class="s0">def </span><span class="s1">compile</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">ttFont</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">tables</span><span class="s2">.</span><span class="s1">sort</span><span class="s2">()  </span><span class="s5"># sort according to the spec; see CmapSubtable.__lt__()</span>
        <span class="s1">numSubTables </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">tables</span><span class="s2">)</span>
        <span class="s1">totalOffset </span><span class="s2">= </span><span class="s3">4 </span><span class="s2">+ </span><span class="s3">8 </span><span class="s2">* </span><span class="s1">numSubTables</span>
        <span class="s1">data </span><span class="s2">= </span><span class="s1">struct</span><span class="s2">.</span><span class="s1">pack</span><span class="s2">(</span><span class="s6">&quot;&gt;HH&quot;</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">tableVersion</span><span class="s2">, </span><span class="s1">numSubTables</span><span class="s2">)</span>
        <span class="s1">tableData </span><span class="s2">= </span><span class="s7">b&quot;&quot;</span>
        <span class="s1">seen </span><span class="s2">= (</span>
            <span class="s2">{}</span>
        <span class="s2">)  </span><span class="s5"># Some tables are the same object reference. Don't compile them twice.</span>
        <span class="s1">done </span><span class="s2">= (</span>
            <span class="s2">{}</span>
        <span class="s2">)  </span><span class="s5"># Some tables are different objects, but compile to the same data chunk</span>
        <span class="s0">for </span><span class="s1">table </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">tables</span><span class="s2">:</span>
            <span class="s1">offset </span><span class="s2">= </span><span class="s1">seen</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">id</span><span class="s2">(</span><span class="s1">table</span><span class="s2">.</span><span class="s1">cmap</span><span class="s2">))</span>
            <span class="s0">if </span><span class="s1">offset </span><span class="s0">is None</span><span class="s2">:</span>
                <span class="s1">chunk </span><span class="s2">= </span><span class="s1">table</span><span class="s2">.</span><span class="s1">compile</span><span class="s2">(</span><span class="s1">ttFont</span><span class="s2">)</span>
                <span class="s1">offset </span><span class="s2">= </span><span class="s1">done</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">chunk</span><span class="s2">)</span>
                <span class="s0">if </span><span class="s1">offset </span><span class="s0">is None</span><span class="s2">:</span>
                    <span class="s1">offset </span><span class="s2">= </span><span class="s1">seen</span><span class="s2">[</span><span class="s1">id</span><span class="s2">(</span><span class="s1">table</span><span class="s2">.</span><span class="s1">cmap</span><span class="s2">)] = </span><span class="s1">done</span><span class="s2">[</span><span class="s1">chunk</span><span class="s2">] = </span><span class="s1">totalOffset </span><span class="s2">+ </span><span class="s1">len</span><span class="s2">(</span>
                        <span class="s1">tableData</span>
                    <span class="s2">)</span>
                    <span class="s1">tableData </span><span class="s2">= </span><span class="s1">tableData </span><span class="s2">+ </span><span class="s1">chunk</span>
            <span class="s1">data </span><span class="s2">= </span><span class="s1">data </span><span class="s2">+ </span><span class="s1">struct</span><span class="s2">.</span><span class="s1">pack</span><span class="s2">(</span><span class="s6">&quot;&gt;HHl&quot;</span><span class="s2">, </span><span class="s1">table</span><span class="s2">.</span><span class="s1">platformID</span><span class="s2">, </span><span class="s1">table</span><span class="s2">.</span><span class="s1">platEncID</span><span class="s2">, </span><span class="s1">offset</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">data </span><span class="s2">+ </span><span class="s1">tableData</span>

    <span class="s0">def </span><span class="s1">toXML</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">writer</span><span class="s2">, </span><span class="s1">ttFont</span><span class="s2">):</span>
        <span class="s1">writer</span><span class="s2">.</span><span class="s1">simpletag</span><span class="s2">(</span><span class="s6">&quot;tableVersion&quot;</span><span class="s2">, </span><span class="s1">version</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">tableVersion</span><span class="s2">)</span>
        <span class="s1">writer</span><span class="s2">.</span><span class="s1">newline</span><span class="s2">()</span>
        <span class="s0">for </span><span class="s1">table </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">tables</span><span class="s2">:</span>
            <span class="s1">table</span><span class="s2">.</span><span class="s1">toXML</span><span class="s2">(</span><span class="s1">writer</span><span class="s2">, </span><span class="s1">ttFont</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">fromXML</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">attrs</span><span class="s2">, </span><span class="s1">content</span><span class="s2">, </span><span class="s1">ttFont</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">name </span><span class="s2">== </span><span class="s6">&quot;tableVersion&quot;</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">tableVersion </span><span class="s2">= </span><span class="s1">safeEval</span><span class="s2">(</span><span class="s1">attrs</span><span class="s2">[</span><span class="s6">&quot;version&quot;</span><span class="s2">])</span>
            <span class="s0">return</span>
        <span class="s0">if </span><span class="s1">name</span><span class="s2">[:</span><span class="s3">12</span><span class="s2">] != </span><span class="s6">&quot;cmap_format_&quot;</span><span class="s2">:</span>
            <span class="s0">return</span>
        <span class="s0">if not </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s6">&quot;tables&quot;</span><span class="s2">):</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">tables </span><span class="s2">= []</span>
        <span class="s1">format </span><span class="s2">= </span><span class="s1">safeEval</span><span class="s2">(</span><span class="s1">name</span><span class="s2">[</span><span class="s3">12</span><span class="s2">:])</span>
        <span class="s1">table </span><span class="s2">= </span><span class="s1">CmapSubtable</span><span class="s2">.</span><span class="s1">newSubtable</span><span class="s2">(</span><span class="s1">format</span><span class="s2">)</span>
        <span class="s1">table</span><span class="s2">.</span><span class="s1">platformID </span><span class="s2">= </span><span class="s1">safeEval</span><span class="s2">(</span><span class="s1">attrs</span><span class="s2">[</span><span class="s6">&quot;platformID&quot;</span><span class="s2">])</span>
        <span class="s1">table</span><span class="s2">.</span><span class="s1">platEncID </span><span class="s2">= </span><span class="s1">safeEval</span><span class="s2">(</span><span class="s1">attrs</span><span class="s2">[</span><span class="s6">&quot;platEncID&quot;</span><span class="s2">])</span>
        <span class="s1">table</span><span class="s2">.</span><span class="s1">fromXML</span><span class="s2">(</span><span class="s1">name</span><span class="s2">, </span><span class="s1">attrs</span><span class="s2">, </span><span class="s1">content</span><span class="s2">, </span><span class="s1">ttFont</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">tables</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">table</span><span class="s2">)</span>


<span class="s0">class </span><span class="s1">CmapSubtable</span><span class="s2">(</span><span class="s1">object</span><span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot;Base class for all cmap subtable formats. 
 
    Subclasses which handle the individual subtable formats are named 
    ``cmap_format_0``, ``cmap_format_2`` etc. Use :py:meth:`getSubtableClass` 
    to retrieve the concrete subclass, or :py:meth:`newSubtable` to get a 
    new subtable object for a given format. 
 
    The object exposes a ``.cmap`` attribute, which contains a dictionary mapping 
    character codepoints to glyph names. 
    &quot;&quot;&quot;</span>

    <span class="s2">@</span><span class="s1">staticmethod</span>
    <span class="s0">def </span><span class="s1">getSubtableClass</span><span class="s2">(</span><span class="s1">format</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot;Return the subtable class for a format.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">cmap_classes</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">format</span><span class="s2">, </span><span class="s1">cmap_format_unknown</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">staticmethod</span>
    <span class="s0">def </span><span class="s1">newSubtable</span><span class="s2">(</span><span class="s1">format</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot;Return a new instance of a subtable for the given format 
        .&quot;&quot;&quot;</span>
        <span class="s1">subtableClass </span><span class="s2">= </span><span class="s1">CmapSubtable</span><span class="s2">.</span><span class="s1">getSubtableClass</span><span class="s2">(</span><span class="s1">format</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">subtableClass</span><span class="s2">(</span><span class="s1">format</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">format</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">format </span><span class="s2">= </span><span class="s1">format</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">data </span><span class="s2">= </span><span class="s0">None</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">ttFont </span><span class="s2">= </span><span class="s0">None</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">platformID </span><span class="s2">= </span><span class="s0">None  </span><span class="s5">#: The platform ID of this subtable</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">platEncID </span><span class="s2">= </span><span class="s0">None  </span><span class="s5">#: The encoding ID of this subtable (interpretation depends on ``platformID``)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">language </span><span class="s2">= (</span>
            <span class="s0">None  </span><span class="s5">#: The language ID of this subtable (Macintosh platform only)</span>
        <span class="s2">)</span>

    <span class="s0">def </span><span class="s1">ensureDecompiled</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">recurse</span><span class="s2">=</span><span class="s0">False</span><span class="s2">):</span>
        <span class="s5"># The recurse argument is unused, but part of the signature of</span>
        <span class="s5"># ensureDecompiled across the library.</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s0">return</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">decompile</span><span class="s2">(</span><span class="s0">None</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)  </span><span class="s5"># use saved data.</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">data </span><span class="s2">= </span><span class="s0">None  </span><span class="s5"># Once this table has been decompiled, make sure we don't</span>
        <span class="s5"># just return the original data. Also avoids recursion when</span>
        <span class="s5"># called with an attribute that the cmap subtable doesn't have.</span>

    <span class="s0">def </span><span class="s1">__getattr__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">attr</span><span class="s2">):</span>
        <span class="s5"># allow lazy decompilation of subtables.</span>
        <span class="s0">if </span><span class="s1">attr</span><span class="s2">[:</span><span class="s3">2</span><span class="s2">] == </span><span class="s6">&quot;__&quot;</span><span class="s2">:  </span><span class="s5"># don't handle requests for member functions like '__lt__'</span>
            <span class="s0">raise </span><span class="s1">AttributeError</span><span class="s2">(</span><span class="s1">attr</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">AttributeError</span><span class="s2">(</span><span class="s1">attr</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">ensureDecompiled</span><span class="s2">()</span>
        <span class="s0">return </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">attr</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">decompileHeader</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">ttFont</span><span class="s2">):</span>
        <span class="s1">format</span><span class="s2">, </span><span class="s1">length</span><span class="s2">, </span><span class="s1">language </span><span class="s2">= </span><span class="s1">struct</span><span class="s2">.</span><span class="s1">unpack</span><span class="s2">(</span><span class="s6">&quot;&gt;HHH&quot;</span><span class="s2">, </span><span class="s1">data</span><span class="s2">[:</span><span class="s3">6</span><span class="s2">])</span>
        <span class="s0">assert </span><span class="s2">(</span>
            <span class="s1">len</span><span class="s2">(</span><span class="s1">data</span><span class="s2">) == </span><span class="s1">length</span>
        <span class="s2">), </span><span class="s6">&quot;corrupt cmap table format %d (data length: %d, header length: %d)&quot; </span><span class="s2">% (</span>
            <span class="s1">format</span><span class="s2">,</span>
            <span class="s1">len</span><span class="s2">(</span><span class="s1">data</span><span class="s2">),</span>
            <span class="s1">length</span><span class="s2">,</span>
        <span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">format </span><span class="s2">= </span><span class="s1">int</span><span class="s2">(</span><span class="s1">format</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">length </span><span class="s2">= </span><span class="s1">int</span><span class="s2">(</span><span class="s1">length</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">language </span><span class="s2">= </span><span class="s1">int</span><span class="s2">(</span><span class="s1">language</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">data </span><span class="s2">= </span><span class="s1">data</span><span class="s2">[</span><span class="s3">6</span><span class="s2">:]</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">ttFont </span><span class="s2">= </span><span class="s1">ttFont</span>

    <span class="s0">def </span><span class="s1">toXML</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">writer</span><span class="s2">, </span><span class="s1">ttFont</span><span class="s2">):</span>
        <span class="s1">writer</span><span class="s2">.</span><span class="s1">begintag</span><span class="s2">(</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">__class__</span><span class="s2">.</span><span class="s1">__name__</span><span class="s2">,</span>
            <span class="s2">[</span>
                <span class="s2">(</span><span class="s6">&quot;platformID&quot;</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">platformID</span><span class="s2">),</span>
                <span class="s2">(</span><span class="s6">&quot;platEncID&quot;</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">platEncID</span><span class="s2">),</span>
                <span class="s2">(</span><span class="s6">&quot;language&quot;</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">language</span><span class="s2">),</span>
            <span class="s2">],</span>
        <span class="s2">)</span>
        <span class="s1">writer</span><span class="s2">.</span><span class="s1">newline</span><span class="s2">()</span>
        <span class="s1">codes </span><span class="s2">= </span><span class="s1">sorted</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">cmap</span><span class="s2">.</span><span class="s1">items</span><span class="s2">())</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_writeCodes</span><span class="s2">(</span><span class="s1">codes</span><span class="s2">, </span><span class="s1">writer</span><span class="s2">)</span>
        <span class="s1">writer</span><span class="s2">.</span><span class="s1">endtag</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">__class__</span><span class="s2">.</span><span class="s1">__name__</span><span class="s2">)</span>
        <span class="s1">writer</span><span class="s2">.</span><span class="s1">newline</span><span class="s2">()</span>

    <span class="s0">def </span><span class="s1">getEncoding</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">default</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot;Returns the Python encoding name for this cmap subtable based on its platformID, 
        platEncID, and language.  If encoding for these values is not known, by default 
        ``None`` is returned.  That can be overridden by passing a value to the ``default`` 
        argument. 
 
        Note that if you want to choose a &quot;preferred&quot; cmap subtable, most of the time 
        ``self.isUnicode()`` is what you want as that one only returns true for the modern, 
        commonly used, Unicode-compatible triplets, not the legacy ones. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">getEncoding</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">platformID</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">platEncID</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">language</span><span class="s2">, </span><span class="s1">default</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">isUnicode</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot;Returns true if the characters are interpreted as Unicode codepoints.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">platformID </span><span class="s2">== </span><span class="s3">0 </span><span class="s0">or </span><span class="s2">(</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">platformID </span><span class="s2">== </span><span class="s3">3 </span><span class="s0">and </span><span class="s1">self</span><span class="s2">.</span><span class="s1">platEncID </span><span class="s0">in </span><span class="s2">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">10</span><span class="s2">]</span>
        <span class="s2">)</span>

    <span class="s0">def </span><span class="s1">isSymbol</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot;Returns true if the subtable is for the Symbol encoding (3,0)&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">platformID </span><span class="s2">== </span><span class="s3">3 </span><span class="s0">and </span><span class="s1">self</span><span class="s2">.</span><span class="s1">platEncID </span><span class="s2">== </span><span class="s3">0</span>

    <span class="s0">def </span><span class="s1">_writeCodes</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">codes</span><span class="s2">, </span><span class="s1">writer</span><span class="s2">):</span>
        <span class="s1">isUnicode </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">isUnicode</span><span class="s2">()</span>
        <span class="s0">for </span><span class="s1">code</span><span class="s2">, </span><span class="s1">name </span><span class="s0">in </span><span class="s1">codes</span><span class="s2">:</span>
            <span class="s1">writer</span><span class="s2">.</span><span class="s1">simpletag</span><span class="s2">(</span><span class="s6">&quot;map&quot;</span><span class="s2">, </span><span class="s1">code</span><span class="s2">=</span><span class="s1">hex</span><span class="s2">(</span><span class="s1">code</span><span class="s2">), </span><span class="s1">name</span><span class="s2">=</span><span class="s1">name</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">isUnicode</span><span class="s2">:</span>
                <span class="s1">writer</span><span class="s2">.</span><span class="s1">comment</span><span class="s2">(</span><span class="s1">Unicode</span><span class="s2">[</span><span class="s1">code</span><span class="s2">])</span>
            <span class="s1">writer</span><span class="s2">.</span><span class="s1">newline</span><span class="s2">()</span>

    <span class="s0">def </span><span class="s1">__lt__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">):</span>
        <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">other</span><span class="s2">, </span><span class="s1">CmapSubtable</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">NotImplemented</span>

        <span class="s5"># implemented so that list.sort() sorts according to the spec.</span>
        <span class="s1">selfTuple </span><span class="s2">= (</span>
            <span class="s1">getattr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s6">&quot;platformID&quot;</span><span class="s2">, </span><span class="s0">None</span><span class="s2">),</span>
            <span class="s1">getattr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s6">&quot;platEncID&quot;</span><span class="s2">, </span><span class="s0">None</span><span class="s2">),</span>
            <span class="s1">getattr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s6">&quot;language&quot;</span><span class="s2">, </span><span class="s0">None</span><span class="s2">),</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">__dict__</span><span class="s2">,</span>
        <span class="s2">)</span>
        <span class="s1">otherTuple </span><span class="s2">= (</span>
            <span class="s1">getattr</span><span class="s2">(</span><span class="s1">other</span><span class="s2">, </span><span class="s6">&quot;platformID&quot;</span><span class="s2">, </span><span class="s0">None</span><span class="s2">),</span>
            <span class="s1">getattr</span><span class="s2">(</span><span class="s1">other</span><span class="s2">, </span><span class="s6">&quot;platEncID&quot;</span><span class="s2">, </span><span class="s0">None</span><span class="s2">),</span>
            <span class="s1">getattr</span><span class="s2">(</span><span class="s1">other</span><span class="s2">, </span><span class="s6">&quot;language&quot;</span><span class="s2">, </span><span class="s0">None</span><span class="s2">),</span>
            <span class="s1">other</span><span class="s2">.</span><span class="s1">__dict__</span><span class="s2">,</span>
        <span class="s2">)</span>
        <span class="s0">return </span><span class="s1">selfTuple </span><span class="s2">&lt; </span><span class="s1">otherTuple</span>


<span class="s0">class </span><span class="s1">cmap_format_0</span><span class="s2">(</span><span class="s1">CmapSubtable</span><span class="s2">):</span>
    <span class="s0">def </span><span class="s1">decompile</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">ttFont</span><span class="s2">):</span>
        <span class="s5"># we usually get here indirectly from the subtable __getattr__ function, in which case both args must be None.</span>
        <span class="s5"># If not, someone is calling the subtable decompile() directly, and must provide both args.</span>
        <span class="s0">if </span><span class="s1">data </span><span class="s0">is not None and </span><span class="s1">ttFont </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">decompileHeader</span><span class="s2">(</span><span class="s1">data</span><span class="s2">, </span><span class="s1">ttFont</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">assert </span><span class="s2">(</span>
                <span class="s1">data </span><span class="s0">is None and </span><span class="s1">ttFont </span><span class="s0">is None</span>
            <span class="s2">), </span><span class="s6">&quot;Need both data and ttFont arguments&quot;</span>
        <span class="s1">data </span><span class="s2">= (</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">data</span>
        <span class="s2">)  </span><span class="s5"># decompileHeader assigns the data after the header to self.data</span>
        <span class="s0">assert </span><span class="s3">262 </span><span class="s2">== </span><span class="s1">self</span><span class="s2">.</span><span class="s1">length</span><span class="s2">, </span><span class="s6">&quot;Format 0 cmap subtable not 262 bytes&quot;</span>
        <span class="s1">gids </span><span class="s2">= </span><span class="s1">array</span><span class="s2">.</span><span class="s1">array</span><span class="s2">(</span><span class="s6">&quot;B&quot;</span><span class="s2">)</span>
        <span class="s1">gids</span><span class="s2">.</span><span class="s1">frombytes</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">)</span>
        <span class="s1">charCodes </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">range</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">gids</span><span class="s2">)))</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">cmap </span><span class="s2">= </span><span class="s1">_make_map</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">ttFont</span><span class="s2">, </span><span class="s1">charCodes</span><span class="s2">, </span><span class="s1">gids</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">compile</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">ttFont</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">struct</span><span class="s2">.</span><span class="s1">pack</span><span class="s2">(</span><span class="s6">&quot;&gt;HHH&quot;</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">262</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">language</span><span class="s2">) + </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span>

        <span class="s1">cmap </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">cmap</span>
        <span class="s0">assert </span><span class="s1">set</span><span class="s2">(</span><span class="s1">cmap</span><span class="s2">.</span><span class="s1">keys</span><span class="s2">()).</span><span class="s1">issubset</span><span class="s2">(</span><span class="s1">range</span><span class="s2">(</span><span class="s3">256</span><span class="s2">))</span>
        <span class="s1">getGlyphID </span><span class="s2">= </span><span class="s1">ttFont</span><span class="s2">.</span><span class="s1">getGlyphID</span>
        <span class="s1">valueList </span><span class="s2">= [</span><span class="s1">getGlyphID</span><span class="s2">(</span><span class="s1">cmap</span><span class="s2">[</span><span class="s1">i</span><span class="s2">]) </span><span class="s0">if </span><span class="s1">i </span><span class="s0">in </span><span class="s1">cmap </span><span class="s0">else </span><span class="s3">0 </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s3">256</span><span class="s2">)]</span>

        <span class="s1">gids </span><span class="s2">= </span><span class="s1">array</span><span class="s2">.</span><span class="s1">array</span><span class="s2">(</span><span class="s6">&quot;B&quot;</span><span class="s2">, </span><span class="s1">valueList</span><span class="s2">)</span>
        <span class="s1">data </span><span class="s2">= </span><span class="s1">struct</span><span class="s2">.</span><span class="s1">pack</span><span class="s2">(</span><span class="s6">&quot;&gt;HHH&quot;</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">262</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">language</span><span class="s2">) + </span><span class="s1">gids</span><span class="s2">.</span><span class="s1">tobytes</span><span class="s2">()</span>
        <span class="s0">assert </span><span class="s1">len</span><span class="s2">(</span><span class="s1">data</span><span class="s2">) == </span><span class="s3">262</span>
        <span class="s0">return </span><span class="s1">data</span>

    <span class="s0">def </span><span class="s1">fromXML</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">attrs</span><span class="s2">, </span><span class="s1">content</span><span class="s2">, </span><span class="s1">ttFont</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">language </span><span class="s2">= </span><span class="s1">safeEval</span><span class="s2">(</span><span class="s1">attrs</span><span class="s2">[</span><span class="s6">&quot;language&quot;</span><span class="s2">])</span>
        <span class="s0">if not </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s6">&quot;cmap&quot;</span><span class="s2">):</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">cmap </span><span class="s2">= {}</span>
        <span class="s1">cmap </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">cmap</span>
        <span class="s0">for </span><span class="s1">element </span><span class="s0">in </span><span class="s1">content</span><span class="s2">:</span>
            <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">element</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">):</span>
                <span class="s0">continue</span>
            <span class="s1">name</span><span class="s2">, </span><span class="s1">attrs</span><span class="s2">, </span><span class="s1">content </span><span class="s2">= </span><span class="s1">element</span>
            <span class="s0">if </span><span class="s1">name </span><span class="s2">!= </span><span class="s6">&quot;map&quot;</span><span class="s2">:</span>
                <span class="s0">continue</span>
            <span class="s1">cmap</span><span class="s2">[</span><span class="s1">safeEval</span><span class="s2">(</span><span class="s1">attrs</span><span class="s2">[</span><span class="s6">&quot;code&quot;</span><span class="s2">])] = </span><span class="s1">attrs</span><span class="s2">[</span><span class="s6">&quot;name&quot;</span><span class="s2">]</span>


<span class="s1">subHeaderFormat </span><span class="s2">= </span><span class="s6">&quot;&gt;HHhH&quot;</span>


<span class="s0">class </span><span class="s1">SubHeader</span><span class="s2">(</span><span class="s1">object</span><span class="s2">):</span>
    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">firstCode </span><span class="s2">= </span><span class="s0">None</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">entryCount </span><span class="s2">= </span><span class="s0">None</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">idDelta </span><span class="s2">= </span><span class="s0">None</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">idRangeOffset </span><span class="s2">= </span><span class="s0">None</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">glyphIndexArray </span><span class="s2">= []</span>


<span class="s0">class </span><span class="s1">cmap_format_2</span><span class="s2">(</span><span class="s1">CmapSubtable</span><span class="s2">):</span>
    <span class="s0">def </span><span class="s1">setIDDelta</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">subHeader</span><span class="s2">):</span>
        <span class="s1">subHeader</span><span class="s2">.</span><span class="s1">idDelta </span><span class="s2">= </span><span class="s3">0</span>
        <span class="s5"># find the minGI which is not zero.</span>
        <span class="s1">minGI </span><span class="s2">= </span><span class="s1">subHeader</span><span class="s2">.</span><span class="s1">glyphIndexArray</span><span class="s2">[</span><span class="s3">0</span><span class="s2">]</span>
        <span class="s0">for </span><span class="s1">gid </span><span class="s0">in </span><span class="s1">subHeader</span><span class="s2">.</span><span class="s1">glyphIndexArray</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s2">(</span><span class="s1">gid </span><span class="s2">!= </span><span class="s3">0</span><span class="s2">) </span><span class="s0">and </span><span class="s2">(</span><span class="s1">gid </span><span class="s2">&lt; </span><span class="s1">minGI</span><span class="s2">):</span>
                <span class="s1">minGI </span><span class="s2">= </span><span class="s1">gid</span>
        <span class="s5"># The lowest gid in glyphIndexArray, after subtracting idDelta, must be 1.</span>
        <span class="s5"># idDelta is a short, and must be between -32K and 32K. minGI can be between 1 and 64K.</span>
        <span class="s5"># We would like to pick an idDelta such that the first glyphArray GID is 1,</span>
        <span class="s5"># so that we are more likely to be able to combine glypharray GID subranges.</span>
        <span class="s5"># This means that we have a problem when minGI is &gt; 32K</span>
        <span class="s5"># Since the final gi is reconstructed from the glyphArray GID by:</span>
        <span class="s5">#    (short)finalGID = (gid + idDelta) % 0x10000),</span>
        <span class="s5"># we can get from a glypharray GID of 1 to a final GID of 65K by subtracting 2, and casting the</span>
        <span class="s5"># negative number to an unsigned short.</span>

        <span class="s0">if </span><span class="s1">minGI </span><span class="s2">&gt; </span><span class="s3">1</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">minGI </span><span class="s2">&gt; </span><span class="s3">0x7FFF</span><span class="s2">:</span>
                <span class="s1">subHeader</span><span class="s2">.</span><span class="s1">idDelta </span><span class="s2">= -(</span><span class="s3">0x10000 </span><span class="s2">- </span><span class="s1">minGI</span><span class="s2">) - </span><span class="s3">1</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">subHeader</span><span class="s2">.</span><span class="s1">idDelta </span><span class="s2">= </span><span class="s1">minGI </span><span class="s2">- </span><span class="s3">1</span>
            <span class="s1">idDelta </span><span class="s2">= </span><span class="s1">subHeader</span><span class="s2">.</span><span class="s1">idDelta</span>
            <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">subHeader</span><span class="s2">.</span><span class="s1">entryCount</span><span class="s2">):</span>
                <span class="s1">gid </span><span class="s2">= </span><span class="s1">subHeader</span><span class="s2">.</span><span class="s1">glyphIndexArray</span><span class="s2">[</span><span class="s1">i</span><span class="s2">]</span>
                <span class="s0">if </span><span class="s1">gid </span><span class="s2">&gt; </span><span class="s3">0</span><span class="s2">:</span>
                    <span class="s1">subHeader</span><span class="s2">.</span><span class="s1">glyphIndexArray</span><span class="s2">[</span><span class="s1">i</span><span class="s2">] = </span><span class="s1">gid </span><span class="s2">- </span><span class="s1">idDelta</span>

    <span class="s0">def </span><span class="s1">decompile</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">ttFont</span><span class="s2">):</span>
        <span class="s5"># we usually get here indirectly from the subtable __getattr__ function, in which case both args must be None.</span>
        <span class="s5"># If not, someone is calling the subtable decompile() directly, and must provide both args.</span>
        <span class="s0">if </span><span class="s1">data </span><span class="s0">is not None and </span><span class="s1">ttFont </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">decompileHeader</span><span class="s2">(</span><span class="s1">data</span><span class="s2">, </span><span class="s1">ttFont</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">assert </span><span class="s2">(</span>
                <span class="s1">data </span><span class="s0">is None and </span><span class="s1">ttFont </span><span class="s0">is None</span>
            <span class="s2">), </span><span class="s6">&quot;Need both data and ttFont arguments&quot;</span>

        <span class="s1">data </span><span class="s2">= (</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">data</span>
        <span class="s2">)  </span><span class="s5"># decompileHeader assigns the data after the header to self.data</span>
        <span class="s1">subHeaderKeys </span><span class="s2">= []</span>
        <span class="s1">maxSubHeaderindex </span><span class="s2">= </span><span class="s3">0</span>
        <span class="s5"># get the key array, and determine the number of subHeaders.</span>
        <span class="s1">allKeys </span><span class="s2">= </span><span class="s1">array</span><span class="s2">.</span><span class="s1">array</span><span class="s2">(</span><span class="s6">&quot;H&quot;</span><span class="s2">)</span>
        <span class="s1">allKeys</span><span class="s2">.</span><span class="s1">frombytes</span><span class="s2">(</span><span class="s1">data</span><span class="s2">[:</span><span class="s3">512</span><span class="s2">])</span>
        <span class="s1">data </span><span class="s2">= </span><span class="s1">data</span><span class="s2">[</span><span class="s3">512</span><span class="s2">:]</span>
        <span class="s0">if </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">byteorder </span><span class="s2">!= </span><span class="s6">&quot;big&quot;</span><span class="s2">:</span>
            <span class="s1">allKeys</span><span class="s2">.</span><span class="s1">byteswap</span><span class="s2">()</span>
        <span class="s1">subHeaderKeys </span><span class="s2">= [</span><span class="s1">key </span><span class="s2">// </span><span class="s3">8 </span><span class="s0">for </span><span class="s1">key </span><span class="s0">in </span><span class="s1">allKeys</span><span class="s2">]</span>
        <span class="s1">maxSubHeaderindex </span><span class="s2">= </span><span class="s1">max</span><span class="s2">(</span><span class="s1">subHeaderKeys</span><span class="s2">)</span>

        <span class="s5"># Load subHeaders</span>
        <span class="s1">subHeaderList </span><span class="s2">= []</span>
        <span class="s1">pos </span><span class="s2">= </span><span class="s3">0</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">maxSubHeaderindex </span><span class="s2">+ </span><span class="s3">1</span><span class="s2">):</span>
            <span class="s1">subHeader </span><span class="s2">= </span><span class="s1">SubHeader</span><span class="s2">()</span>
            <span class="s2">(</span>
                <span class="s1">subHeader</span><span class="s2">.</span><span class="s1">firstCode</span><span class="s2">,</span>
                <span class="s1">subHeader</span><span class="s2">.</span><span class="s1">entryCount</span><span class="s2">,</span>
                <span class="s1">subHeader</span><span class="s2">.</span><span class="s1">idDelta</span><span class="s2">,</span>
                <span class="s1">subHeader</span><span class="s2">.</span><span class="s1">idRangeOffset</span><span class="s2">,</span>
            <span class="s2">) = </span><span class="s1">struct</span><span class="s2">.</span><span class="s1">unpack</span><span class="s2">(</span><span class="s1">subHeaderFormat</span><span class="s2">, </span><span class="s1">data</span><span class="s2">[</span><span class="s1">pos </span><span class="s2">: </span><span class="s1">pos </span><span class="s2">+ </span><span class="s3">8</span><span class="s2">])</span>
            <span class="s1">pos </span><span class="s2">+= </span><span class="s3">8</span>
            <span class="s1">giDataPos </span><span class="s2">= </span><span class="s1">pos </span><span class="s2">+ </span><span class="s1">subHeader</span><span class="s2">.</span><span class="s1">idRangeOffset </span><span class="s2">- </span><span class="s3">2</span>
            <span class="s1">giList </span><span class="s2">= </span><span class="s1">array</span><span class="s2">.</span><span class="s1">array</span><span class="s2">(</span><span class="s6">&quot;H&quot;</span><span class="s2">)</span>
            <span class="s1">giList</span><span class="s2">.</span><span class="s1">frombytes</span><span class="s2">(</span><span class="s1">data</span><span class="s2">[</span><span class="s1">giDataPos </span><span class="s2">: </span><span class="s1">giDataPos </span><span class="s2">+ </span><span class="s1">subHeader</span><span class="s2">.</span><span class="s1">entryCount </span><span class="s2">* </span><span class="s3">2</span><span class="s2">])</span>
            <span class="s0">if </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">byteorder </span><span class="s2">!= </span><span class="s6">&quot;big&quot;</span><span class="s2">:</span>
                <span class="s1">giList</span><span class="s2">.</span><span class="s1">byteswap</span><span class="s2">()</span>
            <span class="s1">subHeader</span><span class="s2">.</span><span class="s1">glyphIndexArray </span><span class="s2">= </span><span class="s1">giList</span>
            <span class="s1">subHeaderList</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">subHeader</span><span class="s2">)</span>
        <span class="s5"># How this gets processed.</span>
        <span class="s5"># Charcodes may be one or two bytes.</span>
        <span class="s5"># The first byte of a charcode is mapped through the subHeaderKeys, to select</span>
        <span class="s5"># a subHeader. For any subheader but 0, the next byte is then mapped through the</span>
        <span class="s5"># selected subheader. If subheader Index 0 is selected, then the byte itself is</span>
        <span class="s5"># mapped through the subheader, and there is no second byte.</span>
        <span class="s5"># Then assume that the subsequent byte is the first byte of the next charcode,and repeat.</span>
        <span class="s5">#</span>
        <span class="s5"># Each subheader references a range in the glyphIndexArray whose length is entryCount.</span>
        <span class="s5"># The range in glyphIndexArray referenced by a sunheader may overlap with the range in glyphIndexArray</span>
        <span class="s5"># referenced by another subheader.</span>
        <span class="s5"># The only subheader that will be referenced by more than one first-byte value is the subheader</span>
        <span class="s5"># that maps the entire range of glyphID values to glyphIndex 0, e.g notdef:</span>
        <span class="s5">#    {firstChar 0, EntryCount 0,idDelta 0,idRangeOffset xx}</span>
        <span class="s5"># A byte being mapped though a subheader is treated as in index into a mapping of array index to font glyphIndex.</span>
        <span class="s5"># A subheader specifies a subrange within (0...256) by the</span>
        <span class="s5"># firstChar and EntryCount values. If the byte value is outside the subrange, then the glyphIndex is zero</span>
        <span class="s5"># (e.g. glyph not in font).</span>
        <span class="s5"># If the byte index is in the subrange, then an offset index is calculated as (byteIndex - firstChar).</span>
        <span class="s5"># The index to glyphIndex mapping is a subrange of the glyphIndexArray. You find the start of the subrange by</span>
        <span class="s5"># counting idRangeOffset bytes from the idRangeOffset word. The first value in this subrange is the</span>
        <span class="s5"># glyphIndex for the index firstChar. The offset index should then be used in this array to get the glyphIndex.</span>
        <span class="s5"># Example for Logocut-Medium</span>
        <span class="s5"># first byte of charcode = 129; selects subheader 1.</span>
        <span class="s5"># subheader 1 = {firstChar 64, EntryCount 108,idDelta 42,idRangeOffset 0252}</span>
        <span class="s5"># second byte of charCode = 66</span>
        <span class="s5"># the index offset = 66-64 = 2.</span>
        <span class="s5"># The subrange of the glyphIndexArray starting at 0x0252 bytes from the idRangeOffset word is:</span>
        <span class="s5"># [glyphIndexArray index], [subrange array index] = glyphIndex</span>
        <span class="s5"># [256], [0]=1  from charcode [129, 64]</span>
        <span class="s5"># [257], [1]=2      from charcode [129, 65]</span>
        <span class="s5"># [258], [2]=3      from charcode [129, 66]</span>
        <span class="s5"># [259], [3]=4      from charcode [129, 67]</span>
        <span class="s5"># So, the glyphIndex = 3 from the array. Then if idDelta is not zero and the glyph ID is not zero,</span>
        <span class="s5"># add it to the glyphID to get the final glyphIndex</span>
        <span class="s5"># value. In this case the final glyph index = 3+ 42 -&gt; 45 for the final glyphIndex. Whew!</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">data </span><span class="s2">= </span><span class="s7">b&quot;&quot;</span>
        <span class="s1">cmap </span><span class="s2">= {}</span>
        <span class="s1">notdefGI </span><span class="s2">= </span><span class="s3">0</span>
        <span class="s0">for </span><span class="s1">firstByte </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s3">256</span><span class="s2">):</span>
            <span class="s1">subHeadindex </span><span class="s2">= </span><span class="s1">subHeaderKeys</span><span class="s2">[</span><span class="s1">firstByte</span><span class="s2">]</span>
            <span class="s1">subHeader </span><span class="s2">= </span><span class="s1">subHeaderList</span><span class="s2">[</span><span class="s1">subHeadindex</span><span class="s2">]</span>
            <span class="s0">if </span><span class="s1">subHeadindex </span><span class="s2">== </span><span class="s3">0</span><span class="s2">:</span>
                <span class="s0">if </span><span class="s2">(</span><span class="s1">firstByte </span><span class="s2">&lt; </span><span class="s1">subHeader</span><span class="s2">.</span><span class="s1">firstCode</span><span class="s2">) </span><span class="s0">or </span><span class="s2">(</span>
                    <span class="s1">firstByte </span><span class="s2">&gt;= </span><span class="s1">subHeader</span><span class="s2">.</span><span class="s1">firstCode </span><span class="s2">+ </span><span class="s1">subHeader</span><span class="s2">.</span><span class="s1">entryCount</span>
                <span class="s2">):</span>
                    <span class="s0">continue  </span><span class="s5"># gi is notdef.</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s1">charCode </span><span class="s2">= </span><span class="s1">firstByte</span>
                    <span class="s1">offsetIndex </span><span class="s2">= </span><span class="s1">firstByte </span><span class="s2">- </span><span class="s1">subHeader</span><span class="s2">.</span><span class="s1">firstCode</span>
                    <span class="s1">gi </span><span class="s2">= </span><span class="s1">subHeader</span><span class="s2">.</span><span class="s1">glyphIndexArray</span><span class="s2">[</span><span class="s1">offsetIndex</span><span class="s2">]</span>
                    <span class="s0">if </span><span class="s1">gi </span><span class="s2">!= </span><span class="s3">0</span><span class="s2">:</span>
                        <span class="s1">gi </span><span class="s2">= (</span><span class="s1">gi </span><span class="s2">+ </span><span class="s1">subHeader</span><span class="s2">.</span><span class="s1">idDelta</span><span class="s2">) % </span><span class="s3">0x10000</span>
                    <span class="s0">else</span><span class="s2">:</span>
                        <span class="s0">continue  </span><span class="s5"># gi is notdef.</span>
                <span class="s1">cmap</span><span class="s2">[</span><span class="s1">charCode</span><span class="s2">] = </span><span class="s1">gi</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s0">if </span><span class="s1">subHeader</span><span class="s2">.</span><span class="s1">entryCount</span><span class="s2">:</span>
                    <span class="s1">charCodeOffset </span><span class="s2">= </span><span class="s1">firstByte </span><span class="s2">* </span><span class="s3">256 </span><span class="s2">+ </span><span class="s1">subHeader</span><span class="s2">.</span><span class="s1">firstCode</span>
                    <span class="s0">for </span><span class="s1">offsetIndex </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">subHeader</span><span class="s2">.</span><span class="s1">entryCount</span><span class="s2">):</span>
                        <span class="s1">charCode </span><span class="s2">= </span><span class="s1">charCodeOffset </span><span class="s2">+ </span><span class="s1">offsetIndex</span>
                        <span class="s1">gi </span><span class="s2">= </span><span class="s1">subHeader</span><span class="s2">.</span><span class="s1">glyphIndexArray</span><span class="s2">[</span><span class="s1">offsetIndex</span><span class="s2">]</span>
                        <span class="s0">if </span><span class="s1">gi </span><span class="s2">!= </span><span class="s3">0</span><span class="s2">:</span>
                            <span class="s1">gi </span><span class="s2">= (</span><span class="s1">gi </span><span class="s2">+ </span><span class="s1">subHeader</span><span class="s2">.</span><span class="s1">idDelta</span><span class="s2">) % </span><span class="s3">0x10000</span>
                        <span class="s0">else</span><span class="s2">:</span>
                            <span class="s0">continue</span>
                        <span class="s1">cmap</span><span class="s2">[</span><span class="s1">charCode</span><span class="s2">] = </span><span class="s1">gi</span>
                <span class="s5"># If not subHeader.entryCount, then all char codes with this first byte are</span>
                <span class="s5"># mapped to .notdef. We can skip this subtable, and leave the glyphs un-encoded, which is the</span>
                <span class="s5"># same as mapping it to .notdef.</span>

        <span class="s1">gids </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">cmap</span><span class="s2">.</span><span class="s1">values</span><span class="s2">())</span>
        <span class="s1">charCodes </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">cmap</span><span class="s2">.</span><span class="s1">keys</span><span class="s2">())</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">cmap </span><span class="s2">= </span><span class="s1">_make_map</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">ttFont</span><span class="s2">, </span><span class="s1">charCodes</span><span class="s2">, </span><span class="s1">gids</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">compile</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">ttFont</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s2">(</span>
                <span class="s1">struct</span><span class="s2">.</span><span class="s1">pack</span><span class="s2">(</span><span class="s6">&quot;&gt;HHH&quot;</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">format</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">length</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">language</span><span class="s2">) + </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span>
            <span class="s2">)</span>
        <span class="s1">kEmptyTwoCharCodeRange </span><span class="s2">= -</span><span class="s3">1</span>
        <span class="s1">notdefGI </span><span class="s2">= </span><span class="s3">0</span>

        <span class="s1">items </span><span class="s2">= </span><span class="s1">sorted</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">cmap</span><span class="s2">.</span><span class="s1">items</span><span class="s2">())</span>
        <span class="s1">charCodes </span><span class="s2">= [</span><span class="s1">item</span><span class="s2">[</span><span class="s3">0</span><span class="s2">] </span><span class="s0">for </span><span class="s1">item </span><span class="s0">in </span><span class="s1">items</span><span class="s2">]</span>
        <span class="s1">names </span><span class="s2">= [</span><span class="s1">item</span><span class="s2">[</span><span class="s3">1</span><span class="s2">] </span><span class="s0">for </span><span class="s1">item </span><span class="s0">in </span><span class="s1">items</span><span class="s2">]</span>
        <span class="s1">nameMap </span><span class="s2">= </span><span class="s1">ttFont</span><span class="s2">.</span><span class="s1">getReverseGlyphMap</span><span class="s2">()</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s1">gids </span><span class="s2">= [</span><span class="s1">nameMap</span><span class="s2">[</span><span class="s1">name</span><span class="s2">] </span><span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">names</span><span class="s2">]</span>
        <span class="s0">except </span><span class="s1">KeyError</span><span class="s2">:</span>
            <span class="s1">nameMap </span><span class="s2">= </span><span class="s1">ttFont</span><span class="s2">.</span><span class="s1">getReverseGlyphMap</span><span class="s2">(</span><span class="s1">rebuild</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
            <span class="s0">try</span><span class="s2">:</span>
                <span class="s1">gids </span><span class="s2">= [</span><span class="s1">nameMap</span><span class="s2">[</span><span class="s1">name</span><span class="s2">] </span><span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">names</span><span class="s2">]</span>
            <span class="s0">except </span><span class="s1">KeyError</span><span class="s2">:</span>
                <span class="s5"># allow virtual GIDs in format 2 tables</span>
                <span class="s1">gids </span><span class="s2">= []</span>
                <span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">names</span><span class="s2">:</span>
                    <span class="s0">try</span><span class="s2">:</span>
                        <span class="s1">gid </span><span class="s2">= </span><span class="s1">nameMap</span><span class="s2">[</span><span class="s1">name</span><span class="s2">]</span>
                    <span class="s0">except </span><span class="s1">KeyError</span><span class="s2">:</span>
                        <span class="s0">try</span><span class="s2">:</span>
                            <span class="s0">if </span><span class="s1">name</span><span class="s2">[:</span><span class="s3">3</span><span class="s2">] == </span><span class="s6">&quot;gid&quot;</span><span class="s2">:</span>
                                <span class="s1">gid </span><span class="s2">= </span><span class="s1">int</span><span class="s2">(</span><span class="s1">name</span><span class="s2">[</span><span class="s3">3</span><span class="s2">:])</span>
                            <span class="s0">else</span><span class="s2">:</span>
                                <span class="s1">gid </span><span class="s2">= </span><span class="s1">ttFont</span><span class="s2">.</span><span class="s1">getGlyphID</span><span class="s2">(</span><span class="s1">name</span><span class="s2">)</span>
                        <span class="s0">except</span><span class="s2">:</span>
                            <span class="s0">raise </span><span class="s1">KeyError</span><span class="s2">(</span><span class="s1">name</span><span class="s2">)</span>

                    <span class="s1">gids</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">gid</span><span class="s2">)</span>

        <span class="s5"># Process the (char code to gid) item list in char code order.</span>
        <span class="s5"># By definition, all one byte char codes map to subheader 0.</span>
        <span class="s5"># For all the two byte char codes, we assume that the first byte maps maps to the empty subhead (with an entry count of 0,</span>
        <span class="s5"># which defines all char codes in its range to map to notdef) unless proven otherwise.</span>
        <span class="s5"># Note that since the char code items are processed in char code order, all the char codes with the</span>
        <span class="s5"># same first byte are in sequential order.</span>

        <span class="s1">subHeaderKeys </span><span class="s2">= [</span>
            <span class="s1">kEmptyTwoCharCodeRange </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s3">256</span><span class="s2">)</span>
        <span class="s2">]  </span><span class="s5"># list of indices into subHeaderList.</span>
        <span class="s1">subHeaderList </span><span class="s2">= []</span>

        <span class="s5"># We force this subheader entry 0 to exist in the subHeaderList in the case where some one comes up</span>
        <span class="s5"># with a cmap where all the one byte char codes map to notdef,</span>
        <span class="s5"># with the result that the subhead 0 would not get created just by processing the item list.</span>
        <span class="s1">charCode </span><span class="s2">= </span><span class="s1">charCodes</span><span class="s2">[</span><span class="s3">0</span><span class="s2">]</span>
        <span class="s0">if </span><span class="s1">charCode </span><span class="s2">&gt; </span><span class="s3">255</span><span class="s2">:</span>
            <span class="s1">subHeader </span><span class="s2">= </span><span class="s1">SubHeader</span><span class="s2">()</span>
            <span class="s1">subHeader</span><span class="s2">.</span><span class="s1">firstCode </span><span class="s2">= </span><span class="s3">0</span>
            <span class="s1">subHeader</span><span class="s2">.</span><span class="s1">entryCount </span><span class="s2">= </span><span class="s3">0</span>
            <span class="s1">subHeader</span><span class="s2">.</span><span class="s1">idDelta </span><span class="s2">= </span><span class="s3">0</span>
            <span class="s1">subHeader</span><span class="s2">.</span><span class="s1">idRangeOffset </span><span class="s2">= </span><span class="s3">0</span>
            <span class="s1">subHeaderList</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">subHeader</span><span class="s2">)</span>

        <span class="s1">lastFirstByte </span><span class="s2">= -</span><span class="s3">1</span>
        <span class="s1">items </span><span class="s2">= </span><span class="s1">zip</span><span class="s2">(</span><span class="s1">charCodes</span><span class="s2">, </span><span class="s1">gids</span><span class="s2">)</span>
        <span class="s0">for </span><span class="s1">charCode</span><span class="s2">, </span><span class="s1">gid </span><span class="s0">in </span><span class="s1">items</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">gid </span><span class="s2">== </span><span class="s3">0</span><span class="s2">:</span>
                <span class="s0">continue</span>
            <span class="s1">firstbyte </span><span class="s2">= </span><span class="s1">charCode </span><span class="s2">&gt;&gt; </span><span class="s3">8</span>
            <span class="s1">secondByte </span><span class="s2">= </span><span class="s1">charCode </span><span class="s2">&amp; </span><span class="s3">0x00FF</span>

            <span class="s0">if </span><span class="s2">(</span>
                <span class="s1">firstbyte </span><span class="s2">!= </span><span class="s1">lastFirstByte</span>
            <span class="s2">):  </span><span class="s5"># Need to update the current subhead, and start a new one.</span>
                <span class="s0">if </span><span class="s1">lastFirstByte </span><span class="s2">&gt; -</span><span class="s3">1</span><span class="s2">:</span>
                    <span class="s5"># fix GI's and iDelta of current subheader.</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">setIDDelta</span><span class="s2">(</span><span class="s1">subHeader</span><span class="s2">)</span>

                    <span class="s5"># If it was sunheader 0 for one-byte charCodes, then we need to set the subHeaderKeys value to zero</span>
                    <span class="s5"># for the indices matching the char codes.</span>
                    <span class="s0">if </span><span class="s1">lastFirstByte </span><span class="s2">== </span><span class="s3">0</span><span class="s2">:</span>
                        <span class="s0">for </span><span class="s1">index </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">subHeader</span><span class="s2">.</span><span class="s1">entryCount</span><span class="s2">):</span>
                            <span class="s1">charCode </span><span class="s2">= </span><span class="s1">subHeader</span><span class="s2">.</span><span class="s1">firstCode </span><span class="s2">+ </span><span class="s1">index</span>
                            <span class="s1">subHeaderKeys</span><span class="s2">[</span><span class="s1">charCode</span><span class="s2">] = </span><span class="s3">0</span>

                    <span class="s0">assert </span><span class="s1">subHeader</span><span class="s2">.</span><span class="s1">entryCount </span><span class="s2">== </span><span class="s1">len</span><span class="s2">(</span>
                        <span class="s1">subHeader</span><span class="s2">.</span><span class="s1">glyphIndexArray</span>
                    <span class="s2">), </span><span class="s6">&quot;Error - subhead entry count does not match len of glyphID subrange.&quot;</span>
                <span class="s5"># init new subheader</span>
                <span class="s1">subHeader </span><span class="s2">= </span><span class="s1">SubHeader</span><span class="s2">()</span>
                <span class="s1">subHeader</span><span class="s2">.</span><span class="s1">firstCode </span><span class="s2">= </span><span class="s1">secondByte</span>
                <span class="s1">subHeader</span><span class="s2">.</span><span class="s1">entryCount </span><span class="s2">= </span><span class="s3">1</span>
                <span class="s1">subHeader</span><span class="s2">.</span><span class="s1">glyphIndexArray</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">gid</span><span class="s2">)</span>
                <span class="s1">subHeaderList</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">subHeader</span><span class="s2">)</span>
                <span class="s1">subHeaderKeys</span><span class="s2">[</span><span class="s1">firstbyte</span><span class="s2">] = </span><span class="s1">len</span><span class="s2">(</span><span class="s1">subHeaderList</span><span class="s2">) - </span><span class="s3">1</span>
                <span class="s1">lastFirstByte </span><span class="s2">= </span><span class="s1">firstbyte</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s5"># need to fill in with notdefs all the code points between the last charCode and the current charCode.</span>
                <span class="s1">codeDiff </span><span class="s2">= </span><span class="s1">secondByte </span><span class="s2">- (</span><span class="s1">subHeader</span><span class="s2">.</span><span class="s1">firstCode </span><span class="s2">+ </span><span class="s1">subHeader</span><span class="s2">.</span><span class="s1">entryCount</span><span class="s2">)</span>
                <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">codeDiff</span><span class="s2">):</span>
                    <span class="s1">subHeader</span><span class="s2">.</span><span class="s1">glyphIndexArray</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">notdefGI</span><span class="s2">)</span>
                <span class="s1">subHeader</span><span class="s2">.</span><span class="s1">glyphIndexArray</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">gid</span><span class="s2">)</span>
                <span class="s1">subHeader</span><span class="s2">.</span><span class="s1">entryCount </span><span class="s2">= </span><span class="s1">subHeader</span><span class="s2">.</span><span class="s1">entryCount </span><span class="s2">+ </span><span class="s1">codeDiff </span><span class="s2">+ </span><span class="s3">1</span>

        <span class="s5"># fix GI's and iDelta of last subheader that we we added to the subheader array.</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">setIDDelta</span><span class="s2">(</span><span class="s1">subHeader</span><span class="s2">)</span>

        <span class="s5"># Now we add a final subheader for the subHeaderKeys which maps to empty two byte charcode ranges.</span>
        <span class="s1">subHeader </span><span class="s2">= </span><span class="s1">SubHeader</span><span class="s2">()</span>
        <span class="s1">subHeader</span><span class="s2">.</span><span class="s1">firstCode </span><span class="s2">= </span><span class="s3">0</span>
        <span class="s1">subHeader</span><span class="s2">.</span><span class="s1">entryCount </span><span class="s2">= </span><span class="s3">0</span>
        <span class="s1">subHeader</span><span class="s2">.</span><span class="s1">idDelta </span><span class="s2">= </span><span class="s3">0</span>
        <span class="s1">subHeader</span><span class="s2">.</span><span class="s1">idRangeOffset </span><span class="s2">= </span><span class="s3">2</span>
        <span class="s1">subHeaderList</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">subHeader</span><span class="s2">)</span>
        <span class="s1">emptySubheadIndex </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">subHeaderList</span><span class="s2">) - </span><span class="s3">1</span>
        <span class="s0">for </span><span class="s1">index </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s3">256</span><span class="s2">):</span>
            <span class="s0">if </span><span class="s1">subHeaderKeys</span><span class="s2">[</span><span class="s1">index</span><span class="s2">] == </span><span class="s1">kEmptyTwoCharCodeRange</span><span class="s2">:</span>
                <span class="s1">subHeaderKeys</span><span class="s2">[</span><span class="s1">index</span><span class="s2">] = </span><span class="s1">emptySubheadIndex</span>
        <span class="s5"># Since this is the last subheader, the GlyphIndex Array starts two bytes after the start of the</span>
        <span class="s5"># idRangeOffset word of this subHeader. We can safely point to the first entry in the GlyphIndexArray,</span>
        <span class="s5"># since the first subrange of the GlyphIndexArray is for subHeader 0, which always starts with</span>
        <span class="s5"># charcode 0 and GID 0.</span>

        <span class="s1">idRangeOffset </span><span class="s2">= (</span>
            <span class="s1">len</span><span class="s2">(</span><span class="s1">subHeaderList</span><span class="s2">) - </span><span class="s3">1</span>
        <span class="s2">) * </span><span class="s3">8 </span><span class="s2">+ </span><span class="s3">2  </span><span class="s5"># offset to beginning of glyphIDArray from first subheader idRangeOffset.</span>
        <span class="s1">subheadRangeLen </span><span class="s2">= (</span>
            <span class="s1">len</span><span class="s2">(</span><span class="s1">subHeaderList</span><span class="s2">) - </span><span class="s3">1</span>
        <span class="s2">)  </span><span class="s5"># skip last special empty-set subheader; we've already hardocodes its idRangeOffset to 2.</span>
        <span class="s0">for </span><span class="s1">index </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">subheadRangeLen</span><span class="s2">):</span>
            <span class="s1">subHeader </span><span class="s2">= </span><span class="s1">subHeaderList</span><span class="s2">[</span><span class="s1">index</span><span class="s2">]</span>
            <span class="s1">subHeader</span><span class="s2">.</span><span class="s1">idRangeOffset </span><span class="s2">= </span><span class="s3">0</span>
            <span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">index</span><span class="s2">):</span>
                <span class="s1">prevSubhead </span><span class="s2">= </span><span class="s1">subHeaderList</span><span class="s2">[</span><span class="s1">j</span><span class="s2">]</span>
                <span class="s0">if </span><span class="s2">(</span>
                    <span class="s1">prevSubhead</span><span class="s2">.</span><span class="s1">glyphIndexArray </span><span class="s2">== </span><span class="s1">subHeader</span><span class="s2">.</span><span class="s1">glyphIndexArray</span>
                <span class="s2">):  </span><span class="s5"># use the glyphIndexArray subarray</span>
                    <span class="s1">subHeader</span><span class="s2">.</span><span class="s1">idRangeOffset </span><span class="s2">= (</span>
                        <span class="s1">prevSubhead</span><span class="s2">.</span><span class="s1">idRangeOffset </span><span class="s2">- (</span><span class="s1">index </span><span class="s2">- </span><span class="s1">j</span><span class="s2">) * </span><span class="s3">8</span>
                    <span class="s2">)</span>
                    <span class="s1">subHeader</span><span class="s2">.</span><span class="s1">glyphIndexArray </span><span class="s2">= []</span>
                    <span class="s0">break</span>
            <span class="s0">if </span><span class="s1">subHeader</span><span class="s2">.</span><span class="s1">idRangeOffset </span><span class="s2">== </span><span class="s3">0</span><span class="s2">:  </span><span class="s5"># didn't find one.</span>
                <span class="s1">subHeader</span><span class="s2">.</span><span class="s1">idRangeOffset </span><span class="s2">= </span><span class="s1">idRangeOffset</span>
                <span class="s1">idRangeOffset </span><span class="s2">= (</span>
                    <span class="s1">idRangeOffset </span><span class="s2">- </span><span class="s3">8</span>
                <span class="s2">) + </span><span class="s1">subHeader</span><span class="s2">.</span><span class="s1">entryCount </span><span class="s2">* </span><span class="s3">2  </span><span class="s5"># one less subheader, one more subArray.</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">idRangeOffset </span><span class="s2">= </span><span class="s1">idRangeOffset </span><span class="s2">- </span><span class="s3">8  </span><span class="s5"># one less subheader</span>

        <span class="s5"># Now we can write out the data!</span>
        <span class="s1">length </span><span class="s2">= (</span>
            <span class="s3">6 </span><span class="s2">+ </span><span class="s3">512 </span><span class="s2">+ </span><span class="s3">8 </span><span class="s2">* </span><span class="s1">len</span><span class="s2">(</span><span class="s1">subHeaderList</span><span class="s2">)</span>
        <span class="s2">)  </span><span class="s5"># header, 256 subHeaderKeys, and subheader array.</span>
        <span class="s0">for </span><span class="s1">subhead </span><span class="s0">in </span><span class="s1">subHeaderList</span><span class="s2">[:-</span><span class="s3">1</span><span class="s2">]:</span>
            <span class="s1">length </span><span class="s2">= (</span>
                <span class="s1">length </span><span class="s2">+ </span><span class="s1">len</span><span class="s2">(</span><span class="s1">subhead</span><span class="s2">.</span><span class="s1">glyphIndexArray</span><span class="s2">) * </span><span class="s3">2</span>
            <span class="s2">)  </span><span class="s5"># We can't use subhead.entryCount, as some of the subhead may share subArrays.</span>
        <span class="s1">dataList </span><span class="s2">= [</span><span class="s1">struct</span><span class="s2">.</span><span class="s1">pack</span><span class="s2">(</span><span class="s6">&quot;&gt;HHH&quot;</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s1">length</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">language</span><span class="s2">)]</span>
        <span class="s0">for </span><span class="s1">index </span><span class="s0">in </span><span class="s1">subHeaderKeys</span><span class="s2">:</span>
            <span class="s1">dataList</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">struct</span><span class="s2">.</span><span class="s1">pack</span><span class="s2">(</span><span class="s6">&quot;&gt;H&quot;</span><span class="s2">, </span><span class="s1">index </span><span class="s2">* </span><span class="s3">8</span><span class="s2">))</span>
        <span class="s0">for </span><span class="s1">subhead </span><span class="s0">in </span><span class="s1">subHeaderList</span><span class="s2">:</span>
            <span class="s1">dataList</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span>
                <span class="s1">struct</span><span class="s2">.</span><span class="s1">pack</span><span class="s2">(</span>
                    <span class="s1">subHeaderFormat</span><span class="s2">,</span>
                    <span class="s1">subhead</span><span class="s2">.</span><span class="s1">firstCode</span><span class="s2">,</span>
                    <span class="s1">subhead</span><span class="s2">.</span><span class="s1">entryCount</span><span class="s2">,</span>
                    <span class="s1">subhead</span><span class="s2">.</span><span class="s1">idDelta</span><span class="s2">,</span>
                    <span class="s1">subhead</span><span class="s2">.</span><span class="s1">idRangeOffset</span><span class="s2">,</span>
                <span class="s2">)</span>
            <span class="s2">)</span>
        <span class="s0">for </span><span class="s1">subhead </span><span class="s0">in </span><span class="s1">subHeaderList</span><span class="s2">[:-</span><span class="s3">1</span><span class="s2">]:</span>
            <span class="s0">for </span><span class="s1">gi </span><span class="s0">in </span><span class="s1">subhead</span><span class="s2">.</span><span class="s1">glyphIndexArray</span><span class="s2">:</span>
                <span class="s1">dataList</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">struct</span><span class="s2">.</span><span class="s1">pack</span><span class="s2">(</span><span class="s6">&quot;&gt;H&quot;</span><span class="s2">, </span><span class="s1">gi</span><span class="s2">))</span>
        <span class="s1">data </span><span class="s2">= </span><span class="s1">bytesjoin</span><span class="s2">(</span><span class="s1">dataList</span><span class="s2">)</span>
        <span class="s0">assert </span><span class="s1">len</span><span class="s2">(</span><span class="s1">data</span><span class="s2">) == </span><span class="s1">length</span><span class="s2">, (</span>
            <span class="s6">&quot;Error: cmap format 2 is not same length as calculated! actual: &quot;</span>
            <span class="s2">+ </span><span class="s1">str</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">data</span><span class="s2">))</span>
            <span class="s2">+ </span><span class="s6">&quot; calc : &quot;</span>
            <span class="s2">+ </span><span class="s1">str</span><span class="s2">(</span><span class="s1">length</span><span class="s2">)</span>
        <span class="s2">)</span>
        <span class="s0">return </span><span class="s1">data</span>

    <span class="s0">def </span><span class="s1">fromXML</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">attrs</span><span class="s2">, </span><span class="s1">content</span><span class="s2">, </span><span class="s1">ttFont</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">language </span><span class="s2">= </span><span class="s1">safeEval</span><span class="s2">(</span><span class="s1">attrs</span><span class="s2">[</span><span class="s6">&quot;language&quot;</span><span class="s2">])</span>
        <span class="s0">if not </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s6">&quot;cmap&quot;</span><span class="s2">):</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">cmap </span><span class="s2">= {}</span>
        <span class="s1">cmap </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">cmap</span>

        <span class="s0">for </span><span class="s1">element </span><span class="s0">in </span><span class="s1">content</span><span class="s2">:</span>
            <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">element</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">):</span>
                <span class="s0">continue</span>
            <span class="s1">name</span><span class="s2">, </span><span class="s1">attrs</span><span class="s2">, </span><span class="s1">content </span><span class="s2">= </span><span class="s1">element</span>
            <span class="s0">if </span><span class="s1">name </span><span class="s2">!= </span><span class="s6">&quot;map&quot;</span><span class="s2">:</span>
                <span class="s0">continue</span>
            <span class="s1">cmap</span><span class="s2">[</span><span class="s1">safeEval</span><span class="s2">(</span><span class="s1">attrs</span><span class="s2">[</span><span class="s6">&quot;code&quot;</span><span class="s2">])] = </span><span class="s1">attrs</span><span class="s2">[</span><span class="s6">&quot;name&quot;</span><span class="s2">]</span>


<span class="s1">cmap_format_4_format </span><span class="s2">= </span><span class="s6">&quot;&gt;7H&quot;</span>

<span class="s5"># uint16  endCode[segCount]          # Ending character code for each segment, last = 0xFFFF.</span>
<span class="s5"># uint16  reservedPad                # This value should be zero</span>
<span class="s5"># uint16  startCode[segCount]        # Starting character code for each segment</span>
<span class="s5"># uint16  idDelta[segCount]          # Delta for all character codes in segment</span>
<span class="s5"># uint16  idRangeOffset[segCount]    # Offset in bytes to glyph indexArray, or 0</span>
<span class="s5"># uint16  glyphIndexArray[variable]  # Glyph index array</span>


<span class="s0">def </span><span class="s1">splitRange</span><span class="s2">(</span><span class="s1">startCode</span><span class="s2">, </span><span class="s1">endCode</span><span class="s2">, </span><span class="s1">cmap</span><span class="s2">):</span>
    <span class="s5"># Try to split a range of character codes into subranges with consecutive</span>
    <span class="s5"># glyph IDs in such a way that the cmap4 subtable can be stored &quot;most&quot;</span>
    <span class="s5"># efficiently. I can't prove I've got the optimal solution, but it seems</span>
    <span class="s5"># to do well with the fonts I tested: none became bigger, many became smaller.</span>
    <span class="s0">if </span><span class="s1">startCode </span><span class="s2">== </span><span class="s1">endCode</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s2">[], [</span><span class="s1">endCode</span><span class="s2">]</span>

    <span class="s1">lastID </span><span class="s2">= </span><span class="s1">cmap</span><span class="s2">[</span><span class="s1">startCode</span><span class="s2">]</span>
    <span class="s1">lastCode </span><span class="s2">= </span><span class="s1">startCode</span>
    <span class="s1">inOrder </span><span class="s2">= </span><span class="s0">None</span>
    <span class="s1">orderedBegin </span><span class="s2">= </span><span class="s0">None</span>
    <span class="s1">subRanges </span><span class="s2">= []</span>

    <span class="s5"># Gather subranges in which the glyph IDs are consecutive.</span>
    <span class="s0">for </span><span class="s1">code </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">startCode </span><span class="s2">+ </span><span class="s3">1</span><span class="s2">, </span><span class="s1">endCode </span><span class="s2">+ </span><span class="s3">1</span><span class="s2">):</span>
        <span class="s1">glyphID </span><span class="s2">= </span><span class="s1">cmap</span><span class="s2">[</span><span class="s1">code</span><span class="s2">]</span>

        <span class="s0">if </span><span class="s1">glyphID </span><span class="s2">- </span><span class="s3">1 </span><span class="s2">== </span><span class="s1">lastID</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">inOrder </span><span class="s0">is None or not </span><span class="s1">inOrder</span><span class="s2">:</span>
                <span class="s1">inOrder </span><span class="s2">= </span><span class="s3">1</span>
                <span class="s1">orderedBegin </span><span class="s2">= </span><span class="s1">lastCode</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">inOrder</span><span class="s2">:</span>
                <span class="s1">inOrder </span><span class="s2">= </span><span class="s3">0</span>
                <span class="s1">subRanges</span><span class="s2">.</span><span class="s1">append</span><span class="s2">((</span><span class="s1">orderedBegin</span><span class="s2">, </span><span class="s1">lastCode</span><span class="s2">))</span>
                <span class="s1">orderedBegin </span><span class="s2">= </span><span class="s0">None</span>

        <span class="s1">lastID </span><span class="s2">= </span><span class="s1">glyphID</span>
        <span class="s1">lastCode </span><span class="s2">= </span><span class="s1">code</span>

    <span class="s0">if </span><span class="s1">inOrder</span><span class="s2">:</span>
        <span class="s1">subRanges</span><span class="s2">.</span><span class="s1">append</span><span class="s2">((</span><span class="s1">orderedBegin</span><span class="s2">, </span><span class="s1">lastCode</span><span class="s2">))</span>
    <span class="s0">assert </span><span class="s1">lastCode </span><span class="s2">== </span><span class="s1">endCode</span>

    <span class="s5"># Now filter out those new subranges that would only make the data bigger.</span>
    <span class="s5"># A new segment cost 8 bytes, not using a new segment costs 2 bytes per</span>
    <span class="s5"># character.</span>
    <span class="s1">newRanges </span><span class="s2">= []</span>
    <span class="s0">for </span><span class="s1">b</span><span class="s2">, </span><span class="s1">e </span><span class="s0">in </span><span class="s1">subRanges</span><span class="s2">:</span>
        <span class="s0">if </span><span class="s1">b </span><span class="s2">== </span><span class="s1">startCode </span><span class="s0">and </span><span class="s1">e </span><span class="s2">== </span><span class="s1">endCode</span><span class="s2">:</span>
            <span class="s0">break  </span><span class="s5"># the whole range, we're fine</span>
        <span class="s0">if </span><span class="s1">b </span><span class="s2">== </span><span class="s1">startCode </span><span class="s0">or </span><span class="s1">e </span><span class="s2">== </span><span class="s1">endCode</span><span class="s2">:</span>
            <span class="s1">threshold </span><span class="s2">= </span><span class="s3">4  </span><span class="s5"># split costs one more segment</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">threshold </span><span class="s2">= </span><span class="s3">8  </span><span class="s5"># split costs two more segments</span>
        <span class="s0">if </span><span class="s2">(</span><span class="s1">e </span><span class="s2">- </span><span class="s1">b </span><span class="s2">+ </span><span class="s3">1</span><span class="s2">) &gt; </span><span class="s1">threshold</span><span class="s2">:</span>
            <span class="s1">newRanges</span><span class="s2">.</span><span class="s1">append</span><span class="s2">((</span><span class="s1">b</span><span class="s2">, </span><span class="s1">e</span><span class="s2">))</span>
    <span class="s1">subRanges </span><span class="s2">= </span><span class="s1">newRanges</span>

    <span class="s0">if not </span><span class="s1">subRanges</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s2">[], [</span><span class="s1">endCode</span><span class="s2">]</span>

    <span class="s0">if </span><span class="s1">subRanges</span><span class="s2">[</span><span class="s3">0</span><span class="s2">][</span><span class="s3">0</span><span class="s2">] != </span><span class="s1">startCode</span><span class="s2">:</span>
        <span class="s1">subRanges</span><span class="s2">.</span><span class="s1">insert</span><span class="s2">(</span><span class="s3">0</span><span class="s2">, (</span><span class="s1">startCode</span><span class="s2">, </span><span class="s1">subRanges</span><span class="s2">[</span><span class="s3">0</span><span class="s2">][</span><span class="s3">0</span><span class="s2">] - </span><span class="s3">1</span><span class="s2">))</span>
    <span class="s0">if </span><span class="s1">subRanges</span><span class="s2">[-</span><span class="s3">1</span><span class="s2">][</span><span class="s3">1</span><span class="s2">] != </span><span class="s1">endCode</span><span class="s2">:</span>
        <span class="s1">subRanges</span><span class="s2">.</span><span class="s1">append</span><span class="s2">((</span><span class="s1">subRanges</span><span class="s2">[-</span><span class="s3">1</span><span class="s2">][</span><span class="s3">1</span><span class="s2">] + </span><span class="s3">1</span><span class="s2">, </span><span class="s1">endCode</span><span class="s2">))</span>

    <span class="s5"># Fill the &quot;holes&quot; in the segments list -- those are the segments in which</span>
    <span class="s5"># the glyph IDs are _not_ consecutive.</span>
    <span class="s1">i </span><span class="s2">= </span><span class="s3">1</span>
    <span class="s0">while </span><span class="s1">i </span><span class="s2">&lt; </span><span class="s1">len</span><span class="s2">(</span><span class="s1">subRanges</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">subRanges</span><span class="s2">[</span><span class="s1">i </span><span class="s2">- </span><span class="s3">1</span><span class="s2">][</span><span class="s3">1</span><span class="s2">] + </span><span class="s3">1 </span><span class="s2">!= </span><span class="s1">subRanges</span><span class="s2">[</span><span class="s1">i</span><span class="s2">][</span><span class="s3">0</span><span class="s2">]:</span>
            <span class="s1">subRanges</span><span class="s2">.</span><span class="s1">insert</span><span class="s2">(</span><span class="s1">i</span><span class="s2">, (</span><span class="s1">subRanges</span><span class="s2">[</span><span class="s1">i </span><span class="s2">- </span><span class="s3">1</span><span class="s2">][</span><span class="s3">1</span><span class="s2">] + </span><span class="s3">1</span><span class="s2">, </span><span class="s1">subRanges</span><span class="s2">[</span><span class="s1">i</span><span class="s2">][</span><span class="s3">0</span><span class="s2">] - </span><span class="s3">1</span><span class="s2">))</span>
            <span class="s1">i </span><span class="s2">= </span><span class="s1">i </span><span class="s2">+ </span><span class="s3">1</span>
        <span class="s1">i </span><span class="s2">= </span><span class="s1">i </span><span class="s2">+ </span><span class="s3">1</span>

    <span class="s5"># Transform the ranges into startCode/endCode lists.</span>
    <span class="s1">start </span><span class="s2">= []</span>
    <span class="s1">end </span><span class="s2">= []</span>
    <span class="s0">for </span><span class="s1">b</span><span class="s2">, </span><span class="s1">e </span><span class="s0">in </span><span class="s1">subRanges</span><span class="s2">:</span>
        <span class="s1">start</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">b</span><span class="s2">)</span>
        <span class="s1">end</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">e</span><span class="s2">)</span>
    <span class="s1">start</span><span class="s2">.</span><span class="s1">pop</span><span class="s2">(</span><span class="s3">0</span><span class="s2">)</span>

    <span class="s0">assert </span><span class="s1">len</span><span class="s2">(</span><span class="s1">start</span><span class="s2">) + </span><span class="s3">1 </span><span class="s2">== </span><span class="s1">len</span><span class="s2">(</span><span class="s1">end</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">start</span><span class="s2">, </span><span class="s1">end</span>


<span class="s0">class </span><span class="s1">cmap_format_4</span><span class="s2">(</span><span class="s1">CmapSubtable</span><span class="s2">):</span>
    <span class="s0">def </span><span class="s1">decompile</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">ttFont</span><span class="s2">):</span>
        <span class="s5"># we usually get here indirectly from the subtable __getattr__ function, in which case both args must be None.</span>
        <span class="s5"># If not, someone is calling the subtable decompile() directly, and must provide both args.</span>
        <span class="s0">if </span><span class="s1">data </span><span class="s0">is not None and </span><span class="s1">ttFont </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">decompileHeader</span><span class="s2">(</span><span class="s1">data</span><span class="s2">, </span><span class="s1">ttFont</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">assert </span><span class="s2">(</span>
                <span class="s1">data </span><span class="s0">is None and </span><span class="s1">ttFont </span><span class="s0">is None</span>
            <span class="s2">), </span><span class="s6">&quot;Need both data and ttFont arguments&quot;</span>

        <span class="s1">data </span><span class="s2">= (</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">data</span>
        <span class="s2">)  </span><span class="s5"># decompileHeader assigns the data after the header to self.data</span>
        <span class="s2">(</span><span class="s1">segCountX2</span><span class="s2">, </span><span class="s1">searchRange</span><span class="s2">, </span><span class="s1">entrySelector</span><span class="s2">, </span><span class="s1">rangeShift</span><span class="s2">) = </span><span class="s1">struct</span><span class="s2">.</span><span class="s1">unpack</span><span class="s2">(</span>
            <span class="s6">&quot;&gt;4H&quot;</span><span class="s2">, </span><span class="s1">data</span><span class="s2">[:</span><span class="s3">8</span><span class="s2">]</span>
        <span class="s2">)</span>
        <span class="s1">data </span><span class="s2">= </span><span class="s1">data</span><span class="s2">[</span><span class="s3">8</span><span class="s2">:]</span>
        <span class="s1">segCount </span><span class="s2">= </span><span class="s1">segCountX2 </span><span class="s2">// </span><span class="s3">2</span>

        <span class="s1">allCodes </span><span class="s2">= </span><span class="s1">array</span><span class="s2">.</span><span class="s1">array</span><span class="s2">(</span><span class="s6">&quot;H&quot;</span><span class="s2">)</span>
        <span class="s1">allCodes</span><span class="s2">.</span><span class="s1">frombytes</span><span class="s2">(</span><span class="s1">data</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">data </span><span class="s2">= </span><span class="s1">data </span><span class="s2">= </span><span class="s0">None</span>

        <span class="s0">if </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">byteorder </span><span class="s2">!= </span><span class="s6">&quot;big&quot;</span><span class="s2">:</span>
            <span class="s1">allCodes</span><span class="s2">.</span><span class="s1">byteswap</span><span class="s2">()</span>

        <span class="s5"># divide the data</span>
        <span class="s1">endCode </span><span class="s2">= </span><span class="s1">allCodes</span><span class="s2">[:</span><span class="s1">segCount</span><span class="s2">]</span>
        <span class="s1">allCodes </span><span class="s2">= </span><span class="s1">allCodes</span><span class="s2">[</span><span class="s1">segCount </span><span class="s2">+ </span><span class="s3">1 </span><span class="s2">:]  </span><span class="s5"># the +1 is skipping the reservedPad field</span>
        <span class="s1">startCode </span><span class="s2">= </span><span class="s1">allCodes</span><span class="s2">[:</span><span class="s1">segCount</span><span class="s2">]</span>
        <span class="s1">allCodes </span><span class="s2">= </span><span class="s1">allCodes</span><span class="s2">[</span><span class="s1">segCount</span><span class="s2">:]</span>
        <span class="s1">idDelta </span><span class="s2">= </span><span class="s1">allCodes</span><span class="s2">[:</span><span class="s1">segCount</span><span class="s2">]</span>
        <span class="s1">allCodes </span><span class="s2">= </span><span class="s1">allCodes</span><span class="s2">[</span><span class="s1">segCount</span><span class="s2">:]</span>
        <span class="s1">idRangeOffset </span><span class="s2">= </span><span class="s1">allCodes</span><span class="s2">[:</span><span class="s1">segCount</span><span class="s2">]</span>
        <span class="s1">glyphIndexArray </span><span class="s2">= </span><span class="s1">allCodes</span><span class="s2">[</span><span class="s1">segCount</span><span class="s2">:]</span>
        <span class="s1">lenGIArray </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">glyphIndexArray</span><span class="s2">)</span>

        <span class="s5"># build 2-byte character mapping</span>
        <span class="s1">charCodes </span><span class="s2">= []</span>
        <span class="s1">gids </span><span class="s2">= []</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">startCode</span><span class="s2">) - </span><span class="s3">1</span><span class="s2">):  </span><span class="s5"># don't do 0xffff!</span>
            <span class="s1">start </span><span class="s2">= </span><span class="s1">startCode</span><span class="s2">[</span><span class="s1">i</span><span class="s2">]</span>
            <span class="s1">delta </span><span class="s2">= </span><span class="s1">idDelta</span><span class="s2">[</span><span class="s1">i</span><span class="s2">]</span>
            <span class="s1">rangeOffset </span><span class="s2">= </span><span class="s1">idRangeOffset</span><span class="s2">[</span><span class="s1">i</span><span class="s2">]</span>
            <span class="s1">partial </span><span class="s2">= </span><span class="s1">rangeOffset </span><span class="s2">// </span><span class="s3">2 </span><span class="s2">- </span><span class="s1">start </span><span class="s2">+ </span><span class="s1">i </span><span class="s2">- </span><span class="s1">len</span><span class="s2">(</span><span class="s1">idRangeOffset</span><span class="s2">)</span>

            <span class="s1">rangeCharCodes </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">range</span><span class="s2">(</span><span class="s1">startCode</span><span class="s2">[</span><span class="s1">i</span><span class="s2">], </span><span class="s1">endCode</span><span class="s2">[</span><span class="s1">i</span><span class="s2">] + </span><span class="s3">1</span><span class="s2">))</span>
            <span class="s1">charCodes</span><span class="s2">.</span><span class="s1">extend</span><span class="s2">(</span><span class="s1">rangeCharCodes</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">rangeOffset </span><span class="s2">== </span><span class="s3">0</span><span class="s2">:</span>
                <span class="s1">gids</span><span class="s2">.</span><span class="s1">extend</span><span class="s2">(</span>
                    <span class="s2">[(</span><span class="s1">charCode </span><span class="s2">+ </span><span class="s1">delta</span><span class="s2">) &amp; </span><span class="s3">0xFFFF </span><span class="s0">for </span><span class="s1">charCode </span><span class="s0">in </span><span class="s1">rangeCharCodes</span><span class="s2">]</span>
                <span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s0">for </span><span class="s1">charCode </span><span class="s0">in </span><span class="s1">rangeCharCodes</span><span class="s2">:</span>
                    <span class="s1">index </span><span class="s2">= </span><span class="s1">charCode </span><span class="s2">+ </span><span class="s1">partial</span>
                    <span class="s0">assert </span><span class="s1">index </span><span class="s2">&lt; </span><span class="s1">lenGIArray</span><span class="s2">, (</span>
                        <span class="s6">&quot;In format 4 cmap, range (%d), the calculated index (%d) into the glyph index array is not less than the length of the array (%d) !&quot;</span>
                        <span class="s2">% (</span><span class="s1">i</span><span class="s2">, </span><span class="s1">index</span><span class="s2">, </span><span class="s1">lenGIArray</span><span class="s2">)</span>
                    <span class="s2">)</span>
                    <span class="s0">if </span><span class="s1">glyphIndexArray</span><span class="s2">[</span><span class="s1">index</span><span class="s2">] != </span><span class="s3">0</span><span class="s2">:  </span><span class="s5"># if not missing glyph</span>
                        <span class="s1">glyphID </span><span class="s2">= </span><span class="s1">glyphIndexArray</span><span class="s2">[</span><span class="s1">index</span><span class="s2">] + </span><span class="s1">delta</span>
                    <span class="s0">else</span><span class="s2">:</span>
                        <span class="s1">glyphID </span><span class="s2">= </span><span class="s3">0  </span><span class="s5"># missing glyph</span>
                    <span class="s1">gids</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">glyphID </span><span class="s2">&amp; </span><span class="s3">0xFFFF</span><span class="s2">)</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">cmap </span><span class="s2">= </span><span class="s1">_make_map</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">ttFont</span><span class="s2">, </span><span class="s1">charCodes</span><span class="s2">, </span><span class="s1">gids</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">compile</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">ttFont</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s2">(</span>
                <span class="s1">struct</span><span class="s2">.</span><span class="s1">pack</span><span class="s2">(</span><span class="s6">&quot;&gt;HHH&quot;</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">format</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">length</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">language</span><span class="s2">) + </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span>
            <span class="s2">)</span>

        <span class="s1">charCodes </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">cmap</span><span class="s2">.</span><span class="s1">keys</span><span class="s2">())</span>
        <span class="s0">if not </span><span class="s1">charCodes</span><span class="s2">:</span>
            <span class="s1">startCode </span><span class="s2">= [</span><span class="s3">0xFFFF</span><span class="s2">]</span>
            <span class="s1">endCode </span><span class="s2">= [</span><span class="s3">0xFFFF</span><span class="s2">]</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">charCodes</span><span class="s2">.</span><span class="s1">sort</span><span class="s2">()</span>
            <span class="s1">names </span><span class="s2">= [</span><span class="s1">self</span><span class="s2">.</span><span class="s1">cmap</span><span class="s2">[</span><span class="s1">code</span><span class="s2">] </span><span class="s0">for </span><span class="s1">code </span><span class="s0">in </span><span class="s1">charCodes</span><span class="s2">]</span>
            <span class="s1">nameMap </span><span class="s2">= </span><span class="s1">ttFont</span><span class="s2">.</span><span class="s1">getReverseGlyphMap</span><span class="s2">()</span>
            <span class="s0">try</span><span class="s2">:</span>
                <span class="s1">gids </span><span class="s2">= [</span><span class="s1">nameMap</span><span class="s2">[</span><span class="s1">name</span><span class="s2">] </span><span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">names</span><span class="s2">]</span>
            <span class="s0">except </span><span class="s1">KeyError</span><span class="s2">:</span>
                <span class="s1">nameMap </span><span class="s2">= </span><span class="s1">ttFont</span><span class="s2">.</span><span class="s1">getReverseGlyphMap</span><span class="s2">(</span><span class="s1">rebuild</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
                <span class="s0">try</span><span class="s2">:</span>
                    <span class="s1">gids </span><span class="s2">= [</span><span class="s1">nameMap</span><span class="s2">[</span><span class="s1">name</span><span class="s2">] </span><span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">names</span><span class="s2">]</span>
                <span class="s0">except </span><span class="s1">KeyError</span><span class="s2">:</span>
                    <span class="s5"># allow virtual GIDs in format 4 tables</span>
                    <span class="s1">gids </span><span class="s2">= []</span>
                    <span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">names</span><span class="s2">:</span>
                        <span class="s0">try</span><span class="s2">:</span>
                            <span class="s1">gid </span><span class="s2">= </span><span class="s1">nameMap</span><span class="s2">[</span><span class="s1">name</span><span class="s2">]</span>
                        <span class="s0">except </span><span class="s1">KeyError</span><span class="s2">:</span>
                            <span class="s0">try</span><span class="s2">:</span>
                                <span class="s0">if </span><span class="s1">name</span><span class="s2">[:</span><span class="s3">3</span><span class="s2">] == </span><span class="s6">&quot;gid&quot;</span><span class="s2">:</span>
                                    <span class="s1">gid </span><span class="s2">= </span><span class="s1">int</span><span class="s2">(</span><span class="s1">name</span><span class="s2">[</span><span class="s3">3</span><span class="s2">:])</span>
                                <span class="s0">else</span><span class="s2">:</span>
                                    <span class="s1">gid </span><span class="s2">= </span><span class="s1">ttFont</span><span class="s2">.</span><span class="s1">getGlyphID</span><span class="s2">(</span><span class="s1">name</span><span class="s2">)</span>
                            <span class="s0">except</span><span class="s2">:</span>
                                <span class="s0">raise </span><span class="s1">KeyError</span><span class="s2">(</span><span class="s1">name</span><span class="s2">)</span>

                        <span class="s1">gids</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">gid</span><span class="s2">)</span>
            <span class="s1">cmap </span><span class="s2">= {}  </span><span class="s5"># code:glyphID mapping</span>
            <span class="s0">for </span><span class="s1">code</span><span class="s2">, </span><span class="s1">gid </span><span class="s0">in </span><span class="s1">zip</span><span class="s2">(</span><span class="s1">charCodes</span><span class="s2">, </span><span class="s1">gids</span><span class="s2">):</span>
                <span class="s1">cmap</span><span class="s2">[</span><span class="s1">code</span><span class="s2">] = </span><span class="s1">gid</span>

            <span class="s5"># Build startCode and endCode lists.</span>
            <span class="s5"># Split the char codes in ranges of consecutive char codes, then split</span>
            <span class="s5"># each range in more ranges of consecutive/not consecutive glyph IDs.</span>
            <span class="s5"># See splitRange().</span>
            <span class="s1">lastCode </span><span class="s2">= </span><span class="s1">charCodes</span><span class="s2">[</span><span class="s3">0</span><span class="s2">]</span>
            <span class="s1">endCode </span><span class="s2">= []</span>
            <span class="s1">startCode </span><span class="s2">= [</span><span class="s1">lastCode</span><span class="s2">]</span>
            <span class="s0">for </span><span class="s1">charCode </span><span class="s0">in </span><span class="s1">charCodes</span><span class="s2">[</span>
                <span class="s3">1</span><span class="s2">:</span>
            <span class="s2">]:  </span><span class="s5"># skip the first code, it's the first start code</span>
                <span class="s0">if </span><span class="s1">charCode </span><span class="s2">== </span><span class="s1">lastCode </span><span class="s2">+ </span><span class="s3">1</span><span class="s2">:</span>
                    <span class="s1">lastCode </span><span class="s2">= </span><span class="s1">charCode</span>
                    <span class="s0">continue</span>
                <span class="s1">start</span><span class="s2">, </span><span class="s1">end </span><span class="s2">= </span><span class="s1">splitRange</span><span class="s2">(</span><span class="s1">startCode</span><span class="s2">[-</span><span class="s3">1</span><span class="s2">], </span><span class="s1">lastCode</span><span class="s2">, </span><span class="s1">cmap</span><span class="s2">)</span>
                <span class="s1">startCode</span><span class="s2">.</span><span class="s1">extend</span><span class="s2">(</span><span class="s1">start</span><span class="s2">)</span>
                <span class="s1">endCode</span><span class="s2">.</span><span class="s1">extend</span><span class="s2">(</span><span class="s1">end</span><span class="s2">)</span>
                <span class="s1">startCode</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">charCode</span><span class="s2">)</span>
                <span class="s1">lastCode </span><span class="s2">= </span><span class="s1">charCode</span>
            <span class="s1">start</span><span class="s2">, </span><span class="s1">end </span><span class="s2">= </span><span class="s1">splitRange</span><span class="s2">(</span><span class="s1">startCode</span><span class="s2">[-</span><span class="s3">1</span><span class="s2">], </span><span class="s1">lastCode</span><span class="s2">, </span><span class="s1">cmap</span><span class="s2">)</span>
            <span class="s1">startCode</span><span class="s2">.</span><span class="s1">extend</span><span class="s2">(</span><span class="s1">start</span><span class="s2">)</span>
            <span class="s1">endCode</span><span class="s2">.</span><span class="s1">extend</span><span class="s2">(</span><span class="s1">end</span><span class="s2">)</span>
            <span class="s1">startCode</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s3">0xFFFF</span><span class="s2">)</span>
            <span class="s1">endCode</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s3">0xFFFF</span><span class="s2">)</span>

        <span class="s5"># build up rest of cruft</span>
        <span class="s1">idDelta </span><span class="s2">= []</span>
        <span class="s1">idRangeOffset </span><span class="s2">= []</span>
        <span class="s1">glyphIndexArray </span><span class="s2">= []</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">endCode</span><span class="s2">) - </span><span class="s3">1</span><span class="s2">):  </span><span class="s5"># skip the closing codes (0xffff)</span>
            <span class="s1">indices </span><span class="s2">= []</span>
            <span class="s0">for </span><span class="s1">charCode </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">startCode</span><span class="s2">[</span><span class="s1">i</span><span class="s2">], </span><span class="s1">endCode</span><span class="s2">[</span><span class="s1">i</span><span class="s2">] + </span><span class="s3">1</span><span class="s2">):</span>
                <span class="s1">indices</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">cmap</span><span class="s2">[</span><span class="s1">charCode</span><span class="s2">])</span>
            <span class="s0">if </span><span class="s1">indices </span><span class="s2">== </span><span class="s1">list</span><span class="s2">(</span><span class="s1">range</span><span class="s2">(</span><span class="s1">indices</span><span class="s2">[</span><span class="s3">0</span><span class="s2">], </span><span class="s1">indices</span><span class="s2">[</span><span class="s3">0</span><span class="s2">] + </span><span class="s1">len</span><span class="s2">(</span><span class="s1">indices</span><span class="s2">))):</span>
                <span class="s1">idDelta</span><span class="s2">.</span><span class="s1">append</span><span class="s2">((</span><span class="s1">indices</span><span class="s2">[</span><span class="s3">0</span><span class="s2">] - </span><span class="s1">startCode</span><span class="s2">[</span><span class="s1">i</span><span class="s2">]) % </span><span class="s3">0x10000</span><span class="s2">)</span>
                <span class="s1">idRangeOffset</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s3">0</span><span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">idDelta</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s3">0</span><span class="s2">)</span>
                <span class="s1">idRangeOffset</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s3">2 </span><span class="s2">* (</span><span class="s1">len</span><span class="s2">(</span><span class="s1">endCode</span><span class="s2">) + </span><span class="s1">len</span><span class="s2">(</span><span class="s1">glyphIndexArray</span><span class="s2">) - </span><span class="s1">i</span><span class="s2">))</span>
                <span class="s1">glyphIndexArray</span><span class="s2">.</span><span class="s1">extend</span><span class="s2">(</span><span class="s1">indices</span><span class="s2">)</span>
        <span class="s1">idDelta</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s3">1</span><span class="s2">)  </span><span class="s5"># 0xffff + 1 == (tadaa!) 0. So this end code maps to .notdef</span>
        <span class="s1">idRangeOffset</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s3">0</span><span class="s2">)</span>

        <span class="s5"># Insane.</span>
        <span class="s1">segCount </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">endCode</span><span class="s2">)</span>
        <span class="s1">segCountX2 </span><span class="s2">= </span><span class="s1">segCount </span><span class="s2">* </span><span class="s3">2</span>
        <span class="s1">searchRange</span><span class="s2">, </span><span class="s1">entrySelector</span><span class="s2">, </span><span class="s1">rangeShift </span><span class="s2">= </span><span class="s1">getSearchRange</span><span class="s2">(</span><span class="s1">segCount</span><span class="s2">, </span><span class="s3">2</span><span class="s2">)</span>

        <span class="s1">charCodeArray </span><span class="s2">= </span><span class="s1">array</span><span class="s2">.</span><span class="s1">array</span><span class="s2">(</span><span class="s6">&quot;H&quot;</span><span class="s2">, </span><span class="s1">endCode </span><span class="s2">+ [</span><span class="s3">0</span><span class="s2">] + </span><span class="s1">startCode</span><span class="s2">)</span>
        <span class="s1">idDeltaArray </span><span class="s2">= </span><span class="s1">array</span><span class="s2">.</span><span class="s1">array</span><span class="s2">(</span><span class="s6">&quot;H&quot;</span><span class="s2">, </span><span class="s1">idDelta</span><span class="s2">)</span>
        <span class="s1">restArray </span><span class="s2">= </span><span class="s1">array</span><span class="s2">.</span><span class="s1">array</span><span class="s2">(</span><span class="s6">&quot;H&quot;</span><span class="s2">, </span><span class="s1">idRangeOffset </span><span class="s2">+ </span><span class="s1">glyphIndexArray</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">byteorder </span><span class="s2">!= </span><span class="s6">&quot;big&quot;</span><span class="s2">:</span>
            <span class="s1">charCodeArray</span><span class="s2">.</span><span class="s1">byteswap</span><span class="s2">()</span>
        <span class="s0">if </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">byteorder </span><span class="s2">!= </span><span class="s6">&quot;big&quot;</span><span class="s2">:</span>
            <span class="s1">idDeltaArray</span><span class="s2">.</span><span class="s1">byteswap</span><span class="s2">()</span>
        <span class="s0">if </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">byteorder </span><span class="s2">!= </span><span class="s6">&quot;big&quot;</span><span class="s2">:</span>
            <span class="s1">restArray</span><span class="s2">.</span><span class="s1">byteswap</span><span class="s2">()</span>
        <span class="s1">data </span><span class="s2">= </span><span class="s1">charCodeArray</span><span class="s2">.</span><span class="s1">tobytes</span><span class="s2">() + </span><span class="s1">idDeltaArray</span><span class="s2">.</span><span class="s1">tobytes</span><span class="s2">() + </span><span class="s1">restArray</span><span class="s2">.</span><span class="s1">tobytes</span><span class="s2">()</span>

        <span class="s1">length </span><span class="s2">= </span><span class="s1">struct</span><span class="s2">.</span><span class="s1">calcsize</span><span class="s2">(</span><span class="s1">cmap_format_4_format</span><span class="s2">) + </span><span class="s1">len</span><span class="s2">(</span><span class="s1">data</span><span class="s2">)</span>
        <span class="s1">header </span><span class="s2">= </span><span class="s1">struct</span><span class="s2">.</span><span class="s1">pack</span><span class="s2">(</span>
            <span class="s1">cmap_format_4_format</span><span class="s2">,</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">format</span><span class="s2">,</span>
            <span class="s1">length</span><span class="s2">,</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">language</span><span class="s2">,</span>
            <span class="s1">segCountX2</span><span class="s2">,</span>
            <span class="s1">searchRange</span><span class="s2">,</span>
            <span class="s1">entrySelector</span><span class="s2">,</span>
            <span class="s1">rangeShift</span><span class="s2">,</span>
        <span class="s2">)</span>
        <span class="s0">return </span><span class="s1">header </span><span class="s2">+ </span><span class="s1">data</span>

    <span class="s0">def </span><span class="s1">fromXML</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">attrs</span><span class="s2">, </span><span class="s1">content</span><span class="s2">, </span><span class="s1">ttFont</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">language </span><span class="s2">= </span><span class="s1">safeEval</span><span class="s2">(</span><span class="s1">attrs</span><span class="s2">[</span><span class="s6">&quot;language&quot;</span><span class="s2">])</span>
        <span class="s0">if not </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s6">&quot;cmap&quot;</span><span class="s2">):</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">cmap </span><span class="s2">= {}</span>
        <span class="s1">cmap </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">cmap</span>

        <span class="s0">for </span><span class="s1">element </span><span class="s0">in </span><span class="s1">content</span><span class="s2">:</span>
            <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">element</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">):</span>
                <span class="s0">continue</span>
            <span class="s1">nameMap</span><span class="s2">, </span><span class="s1">attrsMap</span><span class="s2">, </span><span class="s1">dummyContent </span><span class="s2">= </span><span class="s1">element</span>
            <span class="s0">if </span><span class="s1">nameMap </span><span class="s2">!= </span><span class="s6">&quot;map&quot;</span><span class="s2">:</span>
                <span class="s0">assert </span><span class="s3">0</span><span class="s2">, </span><span class="s6">&quot;Unrecognized keyword in cmap subtable&quot;</span>
            <span class="s1">cmap</span><span class="s2">[</span><span class="s1">safeEval</span><span class="s2">(</span><span class="s1">attrsMap</span><span class="s2">[</span><span class="s6">&quot;code&quot;</span><span class="s2">])] = </span><span class="s1">attrsMap</span><span class="s2">[</span><span class="s6">&quot;name&quot;</span><span class="s2">]</span>


<span class="s0">class </span><span class="s1">cmap_format_6</span><span class="s2">(</span><span class="s1">CmapSubtable</span><span class="s2">):</span>
    <span class="s0">def </span><span class="s1">decompile</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">ttFont</span><span class="s2">):</span>
        <span class="s5"># we usually get here indirectly from the subtable __getattr__ function, in which case both args must be None.</span>
        <span class="s5"># If not, someone is calling the subtable decompile() directly, and must provide both args.</span>
        <span class="s0">if </span><span class="s1">data </span><span class="s0">is not None and </span><span class="s1">ttFont </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">decompileHeader</span><span class="s2">(</span><span class="s1">data</span><span class="s2">, </span><span class="s1">ttFont</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">assert </span><span class="s2">(</span>
                <span class="s1">data </span><span class="s0">is None and </span><span class="s1">ttFont </span><span class="s0">is None</span>
            <span class="s2">), </span><span class="s6">&quot;Need both data and ttFont arguments&quot;</span>

        <span class="s1">data </span><span class="s2">= (</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">data</span>
        <span class="s2">)  </span><span class="s5"># decompileHeader assigns the data after the header to self.data</span>
        <span class="s1">firstCode</span><span class="s2">, </span><span class="s1">entryCount </span><span class="s2">= </span><span class="s1">struct</span><span class="s2">.</span><span class="s1">unpack</span><span class="s2">(</span><span class="s6">&quot;&gt;HH&quot;</span><span class="s2">, </span><span class="s1">data</span><span class="s2">[:</span><span class="s3">4</span><span class="s2">])</span>
        <span class="s1">firstCode </span><span class="s2">= </span><span class="s1">int</span><span class="s2">(</span><span class="s1">firstCode</span><span class="s2">)</span>
        <span class="s1">data </span><span class="s2">= </span><span class="s1">data</span><span class="s2">[</span><span class="s3">4</span><span class="s2">:]</span>
        <span class="s5"># assert len(data) == 2 * entryCount  # XXX not true in Apple's Helvetica!!!</span>
        <span class="s1">gids </span><span class="s2">= </span><span class="s1">array</span><span class="s2">.</span><span class="s1">array</span><span class="s2">(</span><span class="s6">&quot;H&quot;</span><span class="s2">)</span>
        <span class="s1">gids</span><span class="s2">.</span><span class="s1">frombytes</span><span class="s2">(</span><span class="s1">data</span><span class="s2">[: </span><span class="s3">2 </span><span class="s2">* </span><span class="s1">int</span><span class="s2">(</span><span class="s1">entryCount</span><span class="s2">)])</span>
        <span class="s0">if </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">byteorder </span><span class="s2">!= </span><span class="s6">&quot;big&quot;</span><span class="s2">:</span>
            <span class="s1">gids</span><span class="s2">.</span><span class="s1">byteswap</span><span class="s2">()</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">data </span><span class="s2">= </span><span class="s1">data </span><span class="s2">= </span><span class="s0">None</span>

        <span class="s1">charCodes </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">range</span><span class="s2">(</span><span class="s1">firstCode</span><span class="s2">, </span><span class="s1">firstCode </span><span class="s2">+ </span><span class="s1">len</span><span class="s2">(</span><span class="s1">gids</span><span class="s2">)))</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">cmap </span><span class="s2">= </span><span class="s1">_make_map</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">ttFont</span><span class="s2">, </span><span class="s1">charCodes</span><span class="s2">, </span><span class="s1">gids</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">compile</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">ttFont</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s2">(</span>
                <span class="s1">struct</span><span class="s2">.</span><span class="s1">pack</span><span class="s2">(</span><span class="s6">&quot;&gt;HHH&quot;</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">format</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">length</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">language</span><span class="s2">) + </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span>
            <span class="s2">)</span>
        <span class="s1">cmap </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">cmap</span>
        <span class="s1">codes </span><span class="s2">= </span><span class="s1">sorted</span><span class="s2">(</span><span class="s1">cmap</span><span class="s2">.</span><span class="s1">keys</span><span class="s2">())</span>
        <span class="s0">if </span><span class="s1">codes</span><span class="s2">:  </span><span class="s5"># yes, there are empty cmap tables.</span>
            <span class="s1">codes </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">range</span><span class="s2">(</span><span class="s1">codes</span><span class="s2">[</span><span class="s3">0</span><span class="s2">], </span><span class="s1">codes</span><span class="s2">[-</span><span class="s3">1</span><span class="s2">] + </span><span class="s3">1</span><span class="s2">))</span>
            <span class="s1">firstCode </span><span class="s2">= </span><span class="s1">codes</span><span class="s2">[</span><span class="s3">0</span><span class="s2">]</span>
            <span class="s1">valueList </span><span class="s2">= [</span>
                <span class="s1">ttFont</span><span class="s2">.</span><span class="s1">getGlyphID</span><span class="s2">(</span><span class="s1">cmap</span><span class="s2">[</span><span class="s1">code</span><span class="s2">]) </span><span class="s0">if </span><span class="s1">code </span><span class="s0">in </span><span class="s1">cmap </span><span class="s0">else </span><span class="s3">0 </span><span class="s0">for </span><span class="s1">code </span><span class="s0">in </span><span class="s1">codes</span>
            <span class="s2">]</span>
            <span class="s1">gids </span><span class="s2">= </span><span class="s1">array</span><span class="s2">.</span><span class="s1">array</span><span class="s2">(</span><span class="s6">&quot;H&quot;</span><span class="s2">, </span><span class="s1">valueList</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">byteorder </span><span class="s2">!= </span><span class="s6">&quot;big&quot;</span><span class="s2">:</span>
                <span class="s1">gids</span><span class="s2">.</span><span class="s1">byteswap</span><span class="s2">()</span>
            <span class="s1">data </span><span class="s2">= </span><span class="s1">gids</span><span class="s2">.</span><span class="s1">tobytes</span><span class="s2">()</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">data </span><span class="s2">= </span><span class="s7">b&quot;&quot;</span>
            <span class="s1">firstCode </span><span class="s2">= </span><span class="s3">0</span>
        <span class="s1">header </span><span class="s2">= </span><span class="s1">struct</span><span class="s2">.</span><span class="s1">pack</span><span class="s2">(</span>
            <span class="s6">&quot;&gt;HHHHH&quot;</span><span class="s2">, </span><span class="s3">6</span><span class="s2">, </span><span class="s1">len</span><span class="s2">(</span><span class="s1">data</span><span class="s2">) + </span><span class="s3">10</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">language</span><span class="s2">, </span><span class="s1">firstCode</span><span class="s2">, </span><span class="s1">len</span><span class="s2">(</span><span class="s1">codes</span><span class="s2">)</span>
        <span class="s2">)</span>
        <span class="s0">return </span><span class="s1">header </span><span class="s2">+ </span><span class="s1">data</span>

    <span class="s0">def </span><span class="s1">fromXML</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">attrs</span><span class="s2">, </span><span class="s1">content</span><span class="s2">, </span><span class="s1">ttFont</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">language </span><span class="s2">= </span><span class="s1">safeEval</span><span class="s2">(</span><span class="s1">attrs</span><span class="s2">[</span><span class="s6">&quot;language&quot;</span><span class="s2">])</span>
        <span class="s0">if not </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s6">&quot;cmap&quot;</span><span class="s2">):</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">cmap </span><span class="s2">= {}</span>
        <span class="s1">cmap </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">cmap</span>

        <span class="s0">for </span><span class="s1">element </span><span class="s0">in </span><span class="s1">content</span><span class="s2">:</span>
            <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">element</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">):</span>
                <span class="s0">continue</span>
            <span class="s1">name</span><span class="s2">, </span><span class="s1">attrs</span><span class="s2">, </span><span class="s1">content </span><span class="s2">= </span><span class="s1">element</span>
            <span class="s0">if </span><span class="s1">name </span><span class="s2">!= </span><span class="s6">&quot;map&quot;</span><span class="s2">:</span>
                <span class="s0">continue</span>
            <span class="s1">cmap</span><span class="s2">[</span><span class="s1">safeEval</span><span class="s2">(</span><span class="s1">attrs</span><span class="s2">[</span><span class="s6">&quot;code&quot;</span><span class="s2">])] = </span><span class="s1">attrs</span><span class="s2">[</span><span class="s6">&quot;name&quot;</span><span class="s2">]</span>


<span class="s0">class </span><span class="s1">cmap_format_12_or_13</span><span class="s2">(</span><span class="s1">CmapSubtable</span><span class="s2">):</span>
    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">format</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">format </span><span class="s2">= </span><span class="s1">format</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">reserved </span><span class="s2">= </span><span class="s3">0</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">data </span><span class="s2">= </span><span class="s0">None</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">ttFont </span><span class="s2">= </span><span class="s0">None</span>

    <span class="s0">def </span><span class="s1">decompileHeader</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">ttFont</span><span class="s2">):</span>
        <span class="s1">format</span><span class="s2">, </span><span class="s1">reserved</span><span class="s2">, </span><span class="s1">length</span><span class="s2">, </span><span class="s1">language</span><span class="s2">, </span><span class="s1">nGroups </span><span class="s2">= </span><span class="s1">struct</span><span class="s2">.</span><span class="s1">unpack</span><span class="s2">(</span><span class="s6">&quot;&gt;HHLLL&quot;</span><span class="s2">, </span><span class="s1">data</span><span class="s2">[:</span><span class="s3">16</span><span class="s2">])</span>
        <span class="s0">assert </span><span class="s2">(</span>
            <span class="s1">len</span><span class="s2">(</span><span class="s1">data</span><span class="s2">) == (</span><span class="s3">16 </span><span class="s2">+ </span><span class="s1">nGroups </span><span class="s2">* </span><span class="s3">12</span><span class="s2">) == (</span><span class="s1">length</span><span class="s2">)</span>
        <span class="s2">), </span><span class="s6">&quot;corrupt cmap table format %d (data length: %d, header length: %d)&quot; </span><span class="s2">% (</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">format</span><span class="s2">,</span>
            <span class="s1">len</span><span class="s2">(</span><span class="s1">data</span><span class="s2">),</span>
            <span class="s1">length</span><span class="s2">,</span>
        <span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">format </span><span class="s2">= </span><span class="s1">format</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">reserved </span><span class="s2">= </span><span class="s1">reserved</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">length </span><span class="s2">= </span><span class="s1">length</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">language </span><span class="s2">= </span><span class="s1">language</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">nGroups </span><span class="s2">= </span><span class="s1">nGroups</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">data </span><span class="s2">= </span><span class="s1">data</span><span class="s2">[</span><span class="s3">16</span><span class="s2">:]</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">ttFont </span><span class="s2">= </span><span class="s1">ttFont</span>

    <span class="s0">def </span><span class="s1">decompile</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">ttFont</span><span class="s2">):</span>
        <span class="s5"># we usually get here indirectly from the subtable __getattr__ function, in which case both args must be None.</span>
        <span class="s5"># If not, someone is calling the subtable decompile() directly, and must provide both args.</span>
        <span class="s0">if </span><span class="s1">data </span><span class="s0">is not None and </span><span class="s1">ttFont </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">decompileHeader</span><span class="s2">(</span><span class="s1">data</span><span class="s2">, </span><span class="s1">ttFont</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">assert </span><span class="s2">(</span>
                <span class="s1">data </span><span class="s0">is None and </span><span class="s1">ttFont </span><span class="s0">is None</span>
            <span class="s2">), </span><span class="s6">&quot;Need both data and ttFont arguments&quot;</span>

        <span class="s1">data </span><span class="s2">= (</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">data</span>
        <span class="s2">)  </span><span class="s5"># decompileHeader assigns the data after the header to self.data</span>
        <span class="s1">charCodes </span><span class="s2">= []</span>
        <span class="s1">gids </span><span class="s2">= []</span>
        <span class="s1">pos </span><span class="s2">= </span><span class="s3">0</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">nGroups</span><span class="s2">):</span>
            <span class="s1">startCharCode</span><span class="s2">, </span><span class="s1">endCharCode</span><span class="s2">, </span><span class="s1">glyphID </span><span class="s2">= </span><span class="s1">struct</span><span class="s2">.</span><span class="s1">unpack</span><span class="s2">(</span>
                <span class="s6">&quot;&gt;LLL&quot;</span><span class="s2">, </span><span class="s1">data</span><span class="s2">[</span><span class="s1">pos </span><span class="s2">: </span><span class="s1">pos </span><span class="s2">+ </span><span class="s3">12</span><span class="s2">]</span>
            <span class="s2">)</span>
            <span class="s1">pos </span><span class="s2">+= </span><span class="s3">12</span>
            <span class="s1">lenGroup </span><span class="s2">= </span><span class="s3">1 </span><span class="s2">+ </span><span class="s1">endCharCode </span><span class="s2">- </span><span class="s1">startCharCode</span>
            <span class="s1">charCodes</span><span class="s2">.</span><span class="s1">extend</span><span class="s2">(</span><span class="s1">list</span><span class="s2">(</span><span class="s1">range</span><span class="s2">(</span><span class="s1">startCharCode</span><span class="s2">, </span><span class="s1">endCharCode </span><span class="s2">+ </span><span class="s3">1</span><span class="s2">)))</span>
            <span class="s1">gids</span><span class="s2">.</span><span class="s1">extend</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_computeGIDs</span><span class="s2">(</span><span class="s1">glyphID</span><span class="s2">, </span><span class="s1">lenGroup</span><span class="s2">))</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">data </span><span class="s2">= </span><span class="s1">data </span><span class="s2">= </span><span class="s0">None</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">cmap </span><span class="s2">= </span><span class="s1">_make_map</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">ttFont</span><span class="s2">, </span><span class="s1">charCodes</span><span class="s2">, </span><span class="s1">gids</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">compile</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">ttFont</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s2">(</span>
                <span class="s1">struct</span><span class="s2">.</span><span class="s1">pack</span><span class="s2">(</span>
                    <span class="s6">&quot;&gt;HHLLL&quot;</span><span class="s2">,</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">format</span><span class="s2">,</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">reserved</span><span class="s2">,</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">length</span><span class="s2">,</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">language</span><span class="s2">,</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">nGroups</span><span class="s2">,</span>
                <span class="s2">)</span>
                <span class="s2">+ </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span>
            <span class="s2">)</span>
        <span class="s1">charCodes </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">cmap</span><span class="s2">.</span><span class="s1">keys</span><span class="s2">())</span>
        <span class="s1">names </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">cmap</span><span class="s2">.</span><span class="s1">values</span><span class="s2">())</span>
        <span class="s1">nameMap </span><span class="s2">= </span><span class="s1">ttFont</span><span class="s2">.</span><span class="s1">getReverseGlyphMap</span><span class="s2">()</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s1">gids </span><span class="s2">= [</span><span class="s1">nameMap</span><span class="s2">[</span><span class="s1">name</span><span class="s2">] </span><span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">names</span><span class="s2">]</span>
        <span class="s0">except </span><span class="s1">KeyError</span><span class="s2">:</span>
            <span class="s1">nameMap </span><span class="s2">= </span><span class="s1">ttFont</span><span class="s2">.</span><span class="s1">getReverseGlyphMap</span><span class="s2">(</span><span class="s1">rebuild</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
            <span class="s0">try</span><span class="s2">:</span>
                <span class="s1">gids </span><span class="s2">= [</span><span class="s1">nameMap</span><span class="s2">[</span><span class="s1">name</span><span class="s2">] </span><span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">names</span><span class="s2">]</span>
            <span class="s0">except </span><span class="s1">KeyError</span><span class="s2">:</span>
                <span class="s5"># allow virtual GIDs in format 12 tables</span>
                <span class="s1">gids </span><span class="s2">= []</span>
                <span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">names</span><span class="s2">:</span>
                    <span class="s0">try</span><span class="s2">:</span>
                        <span class="s1">gid </span><span class="s2">= </span><span class="s1">nameMap</span><span class="s2">[</span><span class="s1">name</span><span class="s2">]</span>
                    <span class="s0">except </span><span class="s1">KeyError</span><span class="s2">:</span>
                        <span class="s0">try</span><span class="s2">:</span>
                            <span class="s0">if </span><span class="s1">name</span><span class="s2">[:</span><span class="s3">3</span><span class="s2">] == </span><span class="s6">&quot;gid&quot;</span><span class="s2">:</span>
                                <span class="s1">gid </span><span class="s2">= </span><span class="s1">int</span><span class="s2">(</span><span class="s1">name</span><span class="s2">[</span><span class="s3">3</span><span class="s2">:])</span>
                            <span class="s0">else</span><span class="s2">:</span>
                                <span class="s1">gid </span><span class="s2">= </span><span class="s1">ttFont</span><span class="s2">.</span><span class="s1">getGlyphID</span><span class="s2">(</span><span class="s1">name</span><span class="s2">)</span>
                        <span class="s0">except</span><span class="s2">:</span>
                            <span class="s0">raise </span><span class="s1">KeyError</span><span class="s2">(</span><span class="s1">name</span><span class="s2">)</span>

                    <span class="s1">gids</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">gid</span><span class="s2">)</span>

        <span class="s1">cmap </span><span class="s2">= {}  </span><span class="s5"># code:glyphID mapping</span>
        <span class="s0">for </span><span class="s1">code</span><span class="s2">, </span><span class="s1">gid </span><span class="s0">in </span><span class="s1">zip</span><span class="s2">(</span><span class="s1">charCodes</span><span class="s2">, </span><span class="s1">gids</span><span class="s2">):</span>
            <span class="s1">cmap</span><span class="s2">[</span><span class="s1">code</span><span class="s2">] = </span><span class="s1">gid</span>

        <span class="s1">charCodes</span><span class="s2">.</span><span class="s1">sort</span><span class="s2">()</span>
        <span class="s1">index </span><span class="s2">= </span><span class="s3">0</span>
        <span class="s1">startCharCode </span><span class="s2">= </span><span class="s1">charCodes</span><span class="s2">[</span><span class="s3">0</span><span class="s2">]</span>
        <span class="s1">startGlyphID </span><span class="s2">= </span><span class="s1">cmap</span><span class="s2">[</span><span class="s1">startCharCode</span><span class="s2">]</span>
        <span class="s1">lastGlyphID </span><span class="s2">= </span><span class="s1">startGlyphID </span><span class="s2">- </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_format_step</span>
        <span class="s1">lastCharCode </span><span class="s2">= </span><span class="s1">startCharCode </span><span class="s2">- </span><span class="s3">1</span>
        <span class="s1">nGroups </span><span class="s2">= </span><span class="s3">0</span>
        <span class="s1">dataList </span><span class="s2">= []</span>
        <span class="s1">maxIndex </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">charCodes</span><span class="s2">)</span>
        <span class="s0">for </span><span class="s1">index </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">maxIndex</span><span class="s2">):</span>
            <span class="s1">charCode </span><span class="s2">= </span><span class="s1">charCodes</span><span class="s2">[</span><span class="s1">index</span><span class="s2">]</span>
            <span class="s1">glyphID </span><span class="s2">= </span><span class="s1">cmap</span><span class="s2">[</span><span class="s1">charCode</span><span class="s2">]</span>
            <span class="s0">if not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_IsInSameRun</span><span class="s2">(</span><span class="s1">glyphID</span><span class="s2">, </span><span class="s1">lastGlyphID</span><span class="s2">, </span><span class="s1">charCode</span><span class="s2">, </span><span class="s1">lastCharCode</span><span class="s2">):</span>
                <span class="s1">dataList</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span>
                    <span class="s1">struct</span><span class="s2">.</span><span class="s1">pack</span><span class="s2">(</span><span class="s6">&quot;&gt;LLL&quot;</span><span class="s2">, </span><span class="s1">startCharCode</span><span class="s2">, </span><span class="s1">lastCharCode</span><span class="s2">, </span><span class="s1">startGlyphID</span><span class="s2">)</span>
                <span class="s2">)</span>
                <span class="s1">startCharCode </span><span class="s2">= </span><span class="s1">charCode</span>
                <span class="s1">startGlyphID </span><span class="s2">= </span><span class="s1">glyphID</span>
                <span class="s1">nGroups </span><span class="s2">= </span><span class="s1">nGroups </span><span class="s2">+ </span><span class="s3">1</span>
            <span class="s1">lastGlyphID </span><span class="s2">= </span><span class="s1">glyphID</span>
            <span class="s1">lastCharCode </span><span class="s2">= </span><span class="s1">charCode</span>
        <span class="s1">dataList</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">struct</span><span class="s2">.</span><span class="s1">pack</span><span class="s2">(</span><span class="s6">&quot;&gt;LLL&quot;</span><span class="s2">, </span><span class="s1">startCharCode</span><span class="s2">, </span><span class="s1">lastCharCode</span><span class="s2">, </span><span class="s1">startGlyphID</span><span class="s2">))</span>
        <span class="s1">nGroups </span><span class="s2">= </span><span class="s1">nGroups </span><span class="s2">+ </span><span class="s3">1</span>
        <span class="s1">data </span><span class="s2">= </span><span class="s1">bytesjoin</span><span class="s2">(</span><span class="s1">dataList</span><span class="s2">)</span>
        <span class="s1">lengthSubtable </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">data</span><span class="s2">) + </span><span class="s3">16</span>
        <span class="s0">assert </span><span class="s1">len</span><span class="s2">(</span><span class="s1">data</span><span class="s2">) == (</span><span class="s1">nGroups </span><span class="s2">* </span><span class="s3">12</span><span class="s2">) == (</span><span class="s1">lengthSubtable </span><span class="s2">- </span><span class="s3">16</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s2">(</span>
            <span class="s1">struct</span><span class="s2">.</span><span class="s1">pack</span><span class="s2">(</span>
                <span class="s6">&quot;&gt;HHLLL&quot;</span><span class="s2">,</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">format</span><span class="s2">,</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">reserved</span><span class="s2">,</span>
                <span class="s1">lengthSubtable</span><span class="s2">,</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">language</span><span class="s2">,</span>
                <span class="s1">nGroups</span><span class="s2">,</span>
            <span class="s2">)</span>
            <span class="s2">+ </span><span class="s1">data</span>
        <span class="s2">)</span>

    <span class="s0">def </span><span class="s1">toXML</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">writer</span><span class="s2">, </span><span class="s1">ttFont</span><span class="s2">):</span>
        <span class="s1">writer</span><span class="s2">.</span><span class="s1">begintag</span><span class="s2">(</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">__class__</span><span class="s2">.</span><span class="s1">__name__</span><span class="s2">,</span>
            <span class="s2">[</span>
                <span class="s2">(</span><span class="s6">&quot;platformID&quot;</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">platformID</span><span class="s2">),</span>
                <span class="s2">(</span><span class="s6">&quot;platEncID&quot;</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">platEncID</span><span class="s2">),</span>
                <span class="s2">(</span><span class="s6">&quot;format&quot;</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">format</span><span class="s2">),</span>
                <span class="s2">(</span><span class="s6">&quot;reserved&quot;</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">reserved</span><span class="s2">),</span>
                <span class="s2">(</span><span class="s6">&quot;length&quot;</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">length</span><span class="s2">),</span>
                <span class="s2">(</span><span class="s6">&quot;language&quot;</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">language</span><span class="s2">),</span>
                <span class="s2">(</span><span class="s6">&quot;nGroups&quot;</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">nGroups</span><span class="s2">),</span>
            <span class="s2">],</span>
        <span class="s2">)</span>
        <span class="s1">writer</span><span class="s2">.</span><span class="s1">newline</span><span class="s2">()</span>
        <span class="s1">codes </span><span class="s2">= </span><span class="s1">sorted</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">cmap</span><span class="s2">.</span><span class="s1">items</span><span class="s2">())</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_writeCodes</span><span class="s2">(</span><span class="s1">codes</span><span class="s2">, </span><span class="s1">writer</span><span class="s2">)</span>
        <span class="s1">writer</span><span class="s2">.</span><span class="s1">endtag</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">__class__</span><span class="s2">.</span><span class="s1">__name__</span><span class="s2">)</span>
        <span class="s1">writer</span><span class="s2">.</span><span class="s1">newline</span><span class="s2">()</span>

    <span class="s0">def </span><span class="s1">fromXML</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">attrs</span><span class="s2">, </span><span class="s1">content</span><span class="s2">, </span><span class="s1">ttFont</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">format </span><span class="s2">= </span><span class="s1">safeEval</span><span class="s2">(</span><span class="s1">attrs</span><span class="s2">[</span><span class="s6">&quot;format&quot;</span><span class="s2">])</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">reserved </span><span class="s2">= </span><span class="s1">safeEval</span><span class="s2">(</span><span class="s1">attrs</span><span class="s2">[</span><span class="s6">&quot;reserved&quot;</span><span class="s2">])</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">length </span><span class="s2">= </span><span class="s1">safeEval</span><span class="s2">(</span><span class="s1">attrs</span><span class="s2">[</span><span class="s6">&quot;length&quot;</span><span class="s2">])</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">language </span><span class="s2">= </span><span class="s1">safeEval</span><span class="s2">(</span><span class="s1">attrs</span><span class="s2">[</span><span class="s6">&quot;language&quot;</span><span class="s2">])</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">nGroups </span><span class="s2">= </span><span class="s1">safeEval</span><span class="s2">(</span><span class="s1">attrs</span><span class="s2">[</span><span class="s6">&quot;nGroups&quot;</span><span class="s2">])</span>
        <span class="s0">if not </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s6">&quot;cmap&quot;</span><span class="s2">):</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">cmap </span><span class="s2">= {}</span>
        <span class="s1">cmap </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">cmap</span>

        <span class="s0">for </span><span class="s1">element </span><span class="s0">in </span><span class="s1">content</span><span class="s2">:</span>
            <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">element</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">):</span>
                <span class="s0">continue</span>
            <span class="s1">name</span><span class="s2">, </span><span class="s1">attrs</span><span class="s2">, </span><span class="s1">content </span><span class="s2">= </span><span class="s1">element</span>
            <span class="s0">if </span><span class="s1">name </span><span class="s2">!= </span><span class="s6">&quot;map&quot;</span><span class="s2">:</span>
                <span class="s0">continue</span>
            <span class="s1">cmap</span><span class="s2">[</span><span class="s1">safeEval</span><span class="s2">(</span><span class="s1">attrs</span><span class="s2">[</span><span class="s6">&quot;code&quot;</span><span class="s2">])] = </span><span class="s1">attrs</span><span class="s2">[</span><span class="s6">&quot;name&quot;</span><span class="s2">]</span>


<span class="s0">class </span><span class="s1">cmap_format_12</span><span class="s2">(</span><span class="s1">cmap_format_12_or_13</span><span class="s2">):</span>
    <span class="s1">_format_step </span><span class="s2">= </span><span class="s3">1</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">format</span><span class="s2">=</span><span class="s3">12</span><span class="s2">):</span>
        <span class="s1">cmap_format_12_or_13</span><span class="s2">.</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">format</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_computeGIDs</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">startingGlyph</span><span class="s2">, </span><span class="s1">numberOfGlyphs</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">list</span><span class="s2">(</span><span class="s1">range</span><span class="s2">(</span><span class="s1">startingGlyph</span><span class="s2">, </span><span class="s1">startingGlyph </span><span class="s2">+ </span><span class="s1">numberOfGlyphs</span><span class="s2">))</span>

    <span class="s0">def </span><span class="s1">_IsInSameRun</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">glyphID</span><span class="s2">, </span><span class="s1">lastGlyphID</span><span class="s2">, </span><span class="s1">charCode</span><span class="s2">, </span><span class="s1">lastCharCode</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s2">(</span><span class="s1">glyphID </span><span class="s2">== </span><span class="s3">1 </span><span class="s2">+ </span><span class="s1">lastGlyphID</span><span class="s2">) </span><span class="s0">and </span><span class="s2">(</span><span class="s1">charCode </span><span class="s2">== </span><span class="s3">1 </span><span class="s2">+ </span><span class="s1">lastCharCode</span><span class="s2">)</span>


<span class="s0">class </span><span class="s1">cmap_format_13</span><span class="s2">(</span><span class="s1">cmap_format_12_or_13</span><span class="s2">):</span>
    <span class="s1">_format_step </span><span class="s2">= </span><span class="s3">0</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">format</span><span class="s2">=</span><span class="s3">13</span><span class="s2">):</span>
        <span class="s1">cmap_format_12_or_13</span><span class="s2">.</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">format</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_computeGIDs</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">startingGlyph</span><span class="s2">, </span><span class="s1">numberOfGlyphs</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s2">[</span><span class="s1">startingGlyph</span><span class="s2">] * </span><span class="s1">numberOfGlyphs</span>

    <span class="s0">def </span><span class="s1">_IsInSameRun</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">glyphID</span><span class="s2">, </span><span class="s1">lastGlyphID</span><span class="s2">, </span><span class="s1">charCode</span><span class="s2">, </span><span class="s1">lastCharCode</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s2">(</span><span class="s1">glyphID </span><span class="s2">== </span><span class="s1">lastGlyphID</span><span class="s2">) </span><span class="s0">and </span><span class="s2">(</span><span class="s1">charCode </span><span class="s2">== </span><span class="s3">1 </span><span class="s2">+ </span><span class="s1">lastCharCode</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">cvtToUVS</span><span class="s2">(</span><span class="s1">threeByteString</span><span class="s2">):</span>
    <span class="s1">data </span><span class="s2">= </span><span class="s7">b&quot;</span><span class="s0">\0</span><span class="s7">&quot; </span><span class="s2">+ </span><span class="s1">threeByteString</span>
    <span class="s2">(</span><span class="s1">val</span><span class="s2">,) = </span><span class="s1">struct</span><span class="s2">.</span><span class="s1">unpack</span><span class="s2">(</span><span class="s6">&quot;&gt;L&quot;</span><span class="s2">, </span><span class="s1">data</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">val</span>


<span class="s0">def </span><span class="s1">cvtFromUVS</span><span class="s2">(</span><span class="s1">val</span><span class="s2">):</span>
    <span class="s0">assert </span><span class="s3">0 </span><span class="s2">&lt;= </span><span class="s1">val </span><span class="s2">&lt; </span><span class="s3">0x1000000</span>
    <span class="s1">fourByteString </span><span class="s2">= </span><span class="s1">struct</span><span class="s2">.</span><span class="s1">pack</span><span class="s2">(</span><span class="s6">&quot;&gt;L&quot;</span><span class="s2">, </span><span class="s1">val</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">fourByteString</span><span class="s2">[</span><span class="s3">1</span><span class="s2">:]</span>


<span class="s0">class </span><span class="s1">cmap_format_14</span><span class="s2">(</span><span class="s1">CmapSubtable</span><span class="s2">):</span>
    <span class="s0">def </span><span class="s1">decompileHeader</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">ttFont</span><span class="s2">):</span>
        <span class="s1">format</span><span class="s2">, </span><span class="s1">length</span><span class="s2">, </span><span class="s1">numVarSelectorRecords </span><span class="s2">= </span><span class="s1">struct</span><span class="s2">.</span><span class="s1">unpack</span><span class="s2">(</span><span class="s6">&quot;&gt;HLL&quot;</span><span class="s2">, </span><span class="s1">data</span><span class="s2">[:</span><span class="s3">10</span><span class="s2">])</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">data </span><span class="s2">= </span><span class="s1">data</span><span class="s2">[</span><span class="s3">10</span><span class="s2">:]</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">length </span><span class="s2">= </span><span class="s1">length</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">numVarSelectorRecords </span><span class="s2">= </span><span class="s1">numVarSelectorRecords</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">ttFont </span><span class="s2">= </span><span class="s1">ttFont</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">language </span><span class="s2">= </span><span class="s3">0xFF  </span><span class="s5"># has no language.</span>

    <span class="s0">def </span><span class="s1">decompile</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">ttFont</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">data </span><span class="s0">is not None and </span><span class="s1">ttFont </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">decompileHeader</span><span class="s2">(</span><span class="s1">data</span><span class="s2">, </span><span class="s1">ttFont</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">assert </span><span class="s2">(</span>
                <span class="s1">data </span><span class="s0">is None and </span><span class="s1">ttFont </span><span class="s0">is None</span>
            <span class="s2">), </span><span class="s6">&quot;Need both data and ttFont arguments&quot;</span>
        <span class="s1">data </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">cmap </span><span class="s2">= (</span>
            <span class="s2">{}</span>
        <span class="s2">)  </span><span class="s5"># so that clients that expect this to exist in a cmap table won't fail.</span>
        <span class="s1">uvsDict </span><span class="s2">= {}</span>
        <span class="s1">recOffset </span><span class="s2">= </span><span class="s3">0</span>
        <span class="s0">for </span><span class="s1">n </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">numVarSelectorRecords</span><span class="s2">):</span>
            <span class="s1">uvs</span><span class="s2">, </span><span class="s1">defOVSOffset</span><span class="s2">, </span><span class="s1">nonDefUVSOffset </span><span class="s2">= </span><span class="s1">struct</span><span class="s2">.</span><span class="s1">unpack</span><span class="s2">(</span>
                <span class="s6">&quot;&gt;3sLL&quot;</span><span class="s2">, </span><span class="s1">data</span><span class="s2">[</span><span class="s1">recOffset </span><span class="s2">: </span><span class="s1">recOffset </span><span class="s2">+ </span><span class="s3">11</span><span class="s2">]</span>
            <span class="s2">)</span>
            <span class="s1">recOffset </span><span class="s2">+= </span><span class="s3">11</span>
            <span class="s1">varUVS </span><span class="s2">= </span><span class="s1">cvtToUVS</span><span class="s2">(</span><span class="s1">uvs</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">defOVSOffset</span><span class="s2">:</span>
                <span class="s1">startOffset </span><span class="s2">= </span><span class="s1">defOVSOffset </span><span class="s2">- </span><span class="s3">10</span>
                <span class="s2">(</span><span class="s1">numValues</span><span class="s2">,) = </span><span class="s1">struct</span><span class="s2">.</span><span class="s1">unpack</span><span class="s2">(</span><span class="s6">&quot;&gt;L&quot;</span><span class="s2">, </span><span class="s1">data</span><span class="s2">[</span><span class="s1">startOffset </span><span class="s2">: </span><span class="s1">startOffset </span><span class="s2">+ </span><span class="s3">4</span><span class="s2">])</span>
                <span class="s1">startOffset </span><span class="s2">+= </span><span class="s3">4</span>
                <span class="s0">for </span><span class="s1">r </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">numValues</span><span class="s2">):</span>
                    <span class="s1">uv</span><span class="s2">, </span><span class="s1">addtlCnt </span><span class="s2">= </span><span class="s1">struct</span><span class="s2">.</span><span class="s1">unpack</span><span class="s2">(</span>
                        <span class="s6">&quot;&gt;3sB&quot;</span><span class="s2">, </span><span class="s1">data</span><span class="s2">[</span><span class="s1">startOffset </span><span class="s2">: </span><span class="s1">startOffset </span><span class="s2">+ </span><span class="s3">4</span><span class="s2">]</span>
                    <span class="s2">)</span>
                    <span class="s1">startOffset </span><span class="s2">+= </span><span class="s3">4</span>
                    <span class="s1">firstBaseUV </span><span class="s2">= </span><span class="s1">cvtToUVS</span><span class="s2">(</span><span class="s1">uv</span><span class="s2">)</span>
                    <span class="s1">cnt </span><span class="s2">= </span><span class="s1">addtlCnt </span><span class="s2">+ </span><span class="s3">1</span>
                    <span class="s1">baseUVList </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">range</span><span class="s2">(</span><span class="s1">firstBaseUV</span><span class="s2">, </span><span class="s1">firstBaseUV </span><span class="s2">+ </span><span class="s1">cnt</span><span class="s2">))</span>
                    <span class="s1">glyphList </span><span class="s2">= [</span><span class="s0">None</span><span class="s2">] * </span><span class="s1">cnt</span>
                    <span class="s1">localUVList </span><span class="s2">= </span><span class="s1">zip</span><span class="s2">(</span><span class="s1">baseUVList</span><span class="s2">, </span><span class="s1">glyphList</span><span class="s2">)</span>
                    <span class="s0">try</span><span class="s2">:</span>
                        <span class="s1">uvsDict</span><span class="s2">[</span><span class="s1">varUVS</span><span class="s2">].</span><span class="s1">extend</span><span class="s2">(</span><span class="s1">localUVList</span><span class="s2">)</span>
                    <span class="s0">except </span><span class="s1">KeyError</span><span class="s2">:</span>
                        <span class="s1">uvsDict</span><span class="s2">[</span><span class="s1">varUVS</span><span class="s2">] = </span><span class="s1">list</span><span class="s2">(</span><span class="s1">localUVList</span><span class="s2">)</span>

            <span class="s0">if </span><span class="s1">nonDefUVSOffset</span><span class="s2">:</span>
                <span class="s1">startOffset </span><span class="s2">= </span><span class="s1">nonDefUVSOffset </span><span class="s2">- </span><span class="s3">10</span>
                <span class="s2">(</span><span class="s1">numRecs</span><span class="s2">,) = </span><span class="s1">struct</span><span class="s2">.</span><span class="s1">unpack</span><span class="s2">(</span><span class="s6">&quot;&gt;L&quot;</span><span class="s2">, </span><span class="s1">data</span><span class="s2">[</span><span class="s1">startOffset </span><span class="s2">: </span><span class="s1">startOffset </span><span class="s2">+ </span><span class="s3">4</span><span class="s2">])</span>
                <span class="s1">startOffset </span><span class="s2">+= </span><span class="s3">4</span>
                <span class="s1">localUVList </span><span class="s2">= []</span>
                <span class="s0">for </span><span class="s1">r </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">numRecs</span><span class="s2">):</span>
                    <span class="s1">uv</span><span class="s2">, </span><span class="s1">gid </span><span class="s2">= </span><span class="s1">struct</span><span class="s2">.</span><span class="s1">unpack</span><span class="s2">(</span><span class="s6">&quot;&gt;3sH&quot;</span><span class="s2">, </span><span class="s1">data</span><span class="s2">[</span><span class="s1">startOffset </span><span class="s2">: </span><span class="s1">startOffset </span><span class="s2">+ </span><span class="s3">5</span><span class="s2">])</span>
                    <span class="s1">startOffset </span><span class="s2">+= </span><span class="s3">5</span>
                    <span class="s1">uv </span><span class="s2">= </span><span class="s1">cvtToUVS</span><span class="s2">(</span><span class="s1">uv</span><span class="s2">)</span>
                    <span class="s1">glyphName </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ttFont</span><span class="s2">.</span><span class="s1">getGlyphName</span><span class="s2">(</span><span class="s1">gid</span><span class="s2">)</span>
                    <span class="s1">localUVList</span><span class="s2">.</span><span class="s1">append</span><span class="s2">((</span><span class="s1">uv</span><span class="s2">, </span><span class="s1">glyphName</span><span class="s2">))</span>
                <span class="s0">try</span><span class="s2">:</span>
                    <span class="s1">uvsDict</span><span class="s2">[</span><span class="s1">varUVS</span><span class="s2">].</span><span class="s1">extend</span><span class="s2">(</span><span class="s1">localUVList</span><span class="s2">)</span>
                <span class="s0">except </span><span class="s1">KeyError</span><span class="s2">:</span>
                    <span class="s1">uvsDict</span><span class="s2">[</span><span class="s1">varUVS</span><span class="s2">] = </span><span class="s1">localUVList</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">uvsDict </span><span class="s2">= </span><span class="s1">uvsDict</span>

    <span class="s0">def </span><span class="s1">toXML</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">writer</span><span class="s2">, </span><span class="s1">ttFont</span><span class="s2">):</span>
        <span class="s1">writer</span><span class="s2">.</span><span class="s1">begintag</span><span class="s2">(</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">__class__</span><span class="s2">.</span><span class="s1">__name__</span><span class="s2">,</span>
            <span class="s2">[</span>
                <span class="s2">(</span><span class="s6">&quot;platformID&quot;</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">platformID</span><span class="s2">),</span>
                <span class="s2">(</span><span class="s6">&quot;platEncID&quot;</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">platEncID</span><span class="s2">),</span>
            <span class="s2">],</span>
        <span class="s2">)</span>
        <span class="s1">writer</span><span class="s2">.</span><span class="s1">newline</span><span class="s2">()</span>
        <span class="s1">uvsDict </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">uvsDict</span>
        <span class="s1">uvsList </span><span class="s2">= </span><span class="s1">sorted</span><span class="s2">(</span><span class="s1">uvsDict</span><span class="s2">.</span><span class="s1">keys</span><span class="s2">())</span>
        <span class="s0">for </span><span class="s1">uvs </span><span class="s0">in </span><span class="s1">uvsList</span><span class="s2">:</span>
            <span class="s1">uvList </span><span class="s2">= </span><span class="s1">uvsDict</span><span class="s2">[</span><span class="s1">uvs</span><span class="s2">]</span>
            <span class="s1">uvList</span><span class="s2">.</span><span class="s1">sort</span><span class="s2">(</span><span class="s1">key</span><span class="s2">=</span><span class="s0">lambda </span><span class="s1">item</span><span class="s2">: (</span><span class="s1">item</span><span class="s2">[</span><span class="s3">1</span><span class="s2">] </span><span class="s0">is not None</span><span class="s2">, </span><span class="s1">item</span><span class="s2">[</span><span class="s3">0</span><span class="s2">], </span><span class="s1">item</span><span class="s2">[</span><span class="s3">1</span><span class="s2">]))</span>
            <span class="s0">for </span><span class="s1">uv</span><span class="s2">, </span><span class="s1">gname </span><span class="s0">in </span><span class="s1">uvList</span><span class="s2">:</span>
                <span class="s1">attrs </span><span class="s2">= [(</span><span class="s6">&quot;uv&quot;</span><span class="s2">, </span><span class="s1">hex</span><span class="s2">(</span><span class="s1">uv</span><span class="s2">)), (</span><span class="s6">&quot;uvs&quot;</span><span class="s2">, </span><span class="s1">hex</span><span class="s2">(</span><span class="s1">uvs</span><span class="s2">))]</span>
                <span class="s0">if </span><span class="s1">gname </span><span class="s0">is not None</span><span class="s2">:</span>
                    <span class="s1">attrs</span><span class="s2">.</span><span class="s1">append</span><span class="s2">((</span><span class="s6">&quot;name&quot;</span><span class="s2">, </span><span class="s1">gname</span><span class="s2">))</span>
                <span class="s1">writer</span><span class="s2">.</span><span class="s1">simpletag</span><span class="s2">(</span><span class="s6">&quot;map&quot;</span><span class="s2">, </span><span class="s1">attrs</span><span class="s2">)</span>
                <span class="s1">writer</span><span class="s2">.</span><span class="s1">newline</span><span class="s2">()</span>
        <span class="s1">writer</span><span class="s2">.</span><span class="s1">endtag</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">__class__</span><span class="s2">.</span><span class="s1">__name__</span><span class="s2">)</span>
        <span class="s1">writer</span><span class="s2">.</span><span class="s1">newline</span><span class="s2">()</span>

    <span class="s0">def </span><span class="s1">fromXML</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">attrs</span><span class="s2">, </span><span class="s1">content</span><span class="s2">, </span><span class="s1">ttFont</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">language </span><span class="s2">= </span><span class="s3">0xFF  </span><span class="s5"># provide a value so that CmapSubtable.__lt__() won't fail</span>
        <span class="s0">if not </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s6">&quot;cmap&quot;</span><span class="s2">):</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">cmap </span><span class="s2">= (</span>
                <span class="s2">{}</span>
            <span class="s2">)  </span><span class="s5"># so that clients that expect this to exist in a cmap table won't fail.</span>
        <span class="s0">if not </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s6">&quot;uvsDict&quot;</span><span class="s2">):</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">uvsDict </span><span class="s2">= {}</span>
            <span class="s1">uvsDict </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">uvsDict</span>

        <span class="s5"># For backwards compatibility reasons we accept &quot;None&quot; as an indicator</span>
        <span class="s5"># for &quot;default mapping&quot;, unless the font actually has a glyph named</span>
        <span class="s5"># &quot;None&quot;.</span>
        <span class="s1">_hasGlyphNamedNone </span><span class="s2">= </span><span class="s0">None</span>

        <span class="s0">for </span><span class="s1">element </span><span class="s0">in </span><span class="s1">content</span><span class="s2">:</span>
            <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">element</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">):</span>
                <span class="s0">continue</span>
            <span class="s1">name</span><span class="s2">, </span><span class="s1">attrs</span><span class="s2">, </span><span class="s1">content </span><span class="s2">= </span><span class="s1">element</span>
            <span class="s0">if </span><span class="s1">name </span><span class="s2">!= </span><span class="s6">&quot;map&quot;</span><span class="s2">:</span>
                <span class="s0">continue</span>
            <span class="s1">uvs </span><span class="s2">= </span><span class="s1">safeEval</span><span class="s2">(</span><span class="s1">attrs</span><span class="s2">[</span><span class="s6">&quot;uvs&quot;</span><span class="s2">])</span>
            <span class="s1">uv </span><span class="s2">= </span><span class="s1">safeEval</span><span class="s2">(</span><span class="s1">attrs</span><span class="s2">[</span><span class="s6">&quot;uv&quot;</span><span class="s2">])</span>
            <span class="s1">gname </span><span class="s2">= </span><span class="s1">attrs</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s6">&quot;name&quot;</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">gname </span><span class="s2">== </span><span class="s6">&quot;None&quot;</span><span class="s2">:</span>
                <span class="s0">if </span><span class="s1">_hasGlyphNamedNone </span><span class="s0">is None</span><span class="s2">:</span>
                    <span class="s1">_hasGlyphNamedNone </span><span class="s2">= </span><span class="s6">&quot;None&quot; </span><span class="s0">in </span><span class="s1">ttFont</span><span class="s2">.</span><span class="s1">getGlyphOrder</span><span class="s2">()</span>
                <span class="s0">if not </span><span class="s1">_hasGlyphNamedNone</span><span class="s2">:</span>
                    <span class="s1">gname </span><span class="s2">= </span><span class="s0">None</span>
            <span class="s0">try</span><span class="s2">:</span>
                <span class="s1">uvsDict</span><span class="s2">[</span><span class="s1">uvs</span><span class="s2">].</span><span class="s1">append</span><span class="s2">((</span><span class="s1">uv</span><span class="s2">, </span><span class="s1">gname</span><span class="s2">))</span>
            <span class="s0">except </span><span class="s1">KeyError</span><span class="s2">:</span>
                <span class="s1">uvsDict</span><span class="s2">[</span><span class="s1">uvs</span><span class="s2">] = [(</span><span class="s1">uv</span><span class="s2">, </span><span class="s1">gname</span><span class="s2">)]</span>

    <span class="s0">def </span><span class="s1">compile</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">ttFont</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s2">(</span>
                <span class="s1">struct</span><span class="s2">.</span><span class="s1">pack</span><span class="s2">(</span>
                    <span class="s6">&quot;&gt;HLL&quot;</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">format</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">length</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">numVarSelectorRecords</span>
                <span class="s2">)</span>
                <span class="s2">+ </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span>
            <span class="s2">)</span>

        <span class="s1">uvsDict </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">uvsDict</span>
        <span class="s1">uvsList </span><span class="s2">= </span><span class="s1">sorted</span><span class="s2">(</span><span class="s1">uvsDict</span><span class="s2">.</span><span class="s1">keys</span><span class="s2">())</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">numVarSelectorRecords </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">uvsList</span><span class="s2">)</span>
        <span class="s1">offset </span><span class="s2">= (</span>
            <span class="s3">10 </span><span class="s2">+ </span><span class="s1">self</span><span class="s2">.</span><span class="s1">numVarSelectorRecords </span><span class="s2">* </span><span class="s3">11</span>
        <span class="s2">)  </span><span class="s5"># current value is end of VarSelectorRecords block.</span>
        <span class="s1">data </span><span class="s2">= []</span>
        <span class="s1">varSelectorRecords </span><span class="s2">= []</span>
        <span class="s0">for </span><span class="s1">uvs </span><span class="s0">in </span><span class="s1">uvsList</span><span class="s2">:</span>
            <span class="s1">entryList </span><span class="s2">= </span><span class="s1">uvsDict</span><span class="s2">[</span><span class="s1">uvs</span><span class="s2">]</span>

            <span class="s1">defList </span><span class="s2">= [</span><span class="s1">entry </span><span class="s0">for </span><span class="s1">entry </span><span class="s0">in </span><span class="s1">entryList </span><span class="s0">if </span><span class="s1">entry</span><span class="s2">[</span><span class="s3">1</span><span class="s2">] </span><span class="s0">is None</span><span class="s2">]</span>
            <span class="s0">if </span><span class="s1">defList</span><span class="s2">:</span>
                <span class="s1">defList </span><span class="s2">= [</span><span class="s1">entry</span><span class="s2">[</span><span class="s3">0</span><span class="s2">] </span><span class="s0">for </span><span class="s1">entry </span><span class="s0">in </span><span class="s1">defList</span><span class="s2">]</span>
                <span class="s1">defOVSOffset </span><span class="s2">= </span><span class="s1">offset</span>
                <span class="s1">defList</span><span class="s2">.</span><span class="s1">sort</span><span class="s2">()</span>

                <span class="s1">lastUV </span><span class="s2">= </span><span class="s1">defList</span><span class="s2">[</span><span class="s3">0</span><span class="s2">]</span>
                <span class="s1">cnt </span><span class="s2">= -</span><span class="s3">1</span>
                <span class="s1">defRecs </span><span class="s2">= []</span>
                <span class="s0">for </span><span class="s1">defEntry </span><span class="s0">in </span><span class="s1">defList</span><span class="s2">:</span>
                    <span class="s1">cnt </span><span class="s2">+= </span><span class="s3">1</span>
                    <span class="s0">if </span><span class="s2">(</span><span class="s1">lastUV </span><span class="s2">+ </span><span class="s1">cnt</span><span class="s2">) != </span><span class="s1">defEntry</span><span class="s2">:</span>
                        <span class="s1">rec </span><span class="s2">= </span><span class="s1">struct</span><span class="s2">.</span><span class="s1">pack</span><span class="s2">(</span><span class="s6">&quot;&gt;3sB&quot;</span><span class="s2">, </span><span class="s1">cvtFromUVS</span><span class="s2">(</span><span class="s1">lastUV</span><span class="s2">), </span><span class="s1">cnt </span><span class="s2">- </span><span class="s3">1</span><span class="s2">)</span>
                        <span class="s1">lastUV </span><span class="s2">= </span><span class="s1">defEntry</span>
                        <span class="s1">defRecs</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">rec</span><span class="s2">)</span>
                        <span class="s1">cnt </span><span class="s2">= </span><span class="s3">0</span>

                <span class="s1">rec </span><span class="s2">= </span><span class="s1">struct</span><span class="s2">.</span><span class="s1">pack</span><span class="s2">(</span><span class="s6">&quot;&gt;3sB&quot;</span><span class="s2">, </span><span class="s1">cvtFromUVS</span><span class="s2">(</span><span class="s1">lastUV</span><span class="s2">), </span><span class="s1">cnt</span><span class="s2">)</span>
                <span class="s1">defRecs</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">rec</span><span class="s2">)</span>

                <span class="s1">numDefRecs </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">defRecs</span><span class="s2">)</span>
                <span class="s1">data</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">struct</span><span class="s2">.</span><span class="s1">pack</span><span class="s2">(</span><span class="s6">&quot;&gt;L&quot;</span><span class="s2">, </span><span class="s1">numDefRecs</span><span class="s2">))</span>
                <span class="s1">data</span><span class="s2">.</span><span class="s1">extend</span><span class="s2">(</span><span class="s1">defRecs</span><span class="s2">)</span>
                <span class="s1">offset </span><span class="s2">+= </span><span class="s3">4 </span><span class="s2">+ </span><span class="s1">numDefRecs </span><span class="s2">* </span><span class="s3">4</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">defOVSOffset </span><span class="s2">= </span><span class="s3">0</span>

            <span class="s1">ndefList </span><span class="s2">= [</span><span class="s1">entry </span><span class="s0">for </span><span class="s1">entry </span><span class="s0">in </span><span class="s1">entryList </span><span class="s0">if </span><span class="s1">entry</span><span class="s2">[</span><span class="s3">1</span><span class="s2">] </span><span class="s0">is not None</span><span class="s2">]</span>
            <span class="s0">if </span><span class="s1">ndefList</span><span class="s2">:</span>
                <span class="s1">nonDefUVSOffset </span><span class="s2">= </span><span class="s1">offset</span>
                <span class="s1">ndefList</span><span class="s2">.</span><span class="s1">sort</span><span class="s2">()</span>
                <span class="s1">numNonDefRecs </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">ndefList</span><span class="s2">)</span>
                <span class="s1">data</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">struct</span><span class="s2">.</span><span class="s1">pack</span><span class="s2">(</span><span class="s6">&quot;&gt;L&quot;</span><span class="s2">, </span><span class="s1">numNonDefRecs</span><span class="s2">))</span>
                <span class="s1">offset </span><span class="s2">+= </span><span class="s3">4 </span><span class="s2">+ </span><span class="s1">numNonDefRecs </span><span class="s2">* </span><span class="s3">5</span>

                <span class="s0">for </span><span class="s1">uv</span><span class="s2">, </span><span class="s1">gname </span><span class="s0">in </span><span class="s1">ndefList</span><span class="s2">:</span>
                    <span class="s1">gid </span><span class="s2">= </span><span class="s1">ttFont</span><span class="s2">.</span><span class="s1">getGlyphID</span><span class="s2">(</span><span class="s1">gname</span><span class="s2">)</span>
                    <span class="s1">ndrec </span><span class="s2">= </span><span class="s1">struct</span><span class="s2">.</span><span class="s1">pack</span><span class="s2">(</span><span class="s6">&quot;&gt;3sH&quot;</span><span class="s2">, </span><span class="s1">cvtFromUVS</span><span class="s2">(</span><span class="s1">uv</span><span class="s2">), </span><span class="s1">gid</span><span class="s2">)</span>
                    <span class="s1">data</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">ndrec</span><span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">nonDefUVSOffset </span><span class="s2">= </span><span class="s3">0</span>

            <span class="s1">vrec </span><span class="s2">= </span><span class="s1">struct</span><span class="s2">.</span><span class="s1">pack</span><span class="s2">(</span><span class="s6">&quot;&gt;3sLL&quot;</span><span class="s2">, </span><span class="s1">cvtFromUVS</span><span class="s2">(</span><span class="s1">uvs</span><span class="s2">), </span><span class="s1">defOVSOffset</span><span class="s2">, </span><span class="s1">nonDefUVSOffset</span><span class="s2">)</span>
            <span class="s1">varSelectorRecords</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">vrec</span><span class="s2">)</span>

        <span class="s1">data </span><span class="s2">= </span><span class="s1">bytesjoin</span><span class="s2">(</span><span class="s1">varSelectorRecords</span><span class="s2">) + </span><span class="s1">bytesjoin</span><span class="s2">(</span><span class="s1">data</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">length </span><span class="s2">= </span><span class="s3">10 </span><span class="s2">+ </span><span class="s1">len</span><span class="s2">(</span><span class="s1">data</span><span class="s2">)</span>
        <span class="s1">headerdata </span><span class="s2">= </span><span class="s1">struct</span><span class="s2">.</span><span class="s1">pack</span><span class="s2">(</span>
            <span class="s6">&quot;&gt;HLL&quot;</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">format</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">length</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">numVarSelectorRecords</span>
        <span class="s2">)</span>

        <span class="s0">return </span><span class="s1">headerdata </span><span class="s2">+ </span><span class="s1">data</span>


<span class="s0">class </span><span class="s1">cmap_format_unknown</span><span class="s2">(</span><span class="s1">CmapSubtable</span><span class="s2">):</span>
    <span class="s0">def </span><span class="s1">toXML</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">writer</span><span class="s2">, </span><span class="s1">ttFont</span><span class="s2">):</span>
        <span class="s1">cmapName </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__class__</span><span class="s2">.</span><span class="s1">__name__</span><span class="s2">[:</span><span class="s3">12</span><span class="s2">] + </span><span class="s1">str</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">format</span><span class="s2">)</span>
        <span class="s1">writer</span><span class="s2">.</span><span class="s1">begintag</span><span class="s2">(</span>
            <span class="s1">cmapName</span><span class="s2">,</span>
            <span class="s2">[</span>
                <span class="s2">(</span><span class="s6">&quot;platformID&quot;</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">platformID</span><span class="s2">),</span>
                <span class="s2">(</span><span class="s6">&quot;platEncID&quot;</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">platEncID</span><span class="s2">),</span>
            <span class="s2">],</span>
        <span class="s2">)</span>
        <span class="s1">writer</span><span class="s2">.</span><span class="s1">newline</span><span class="s2">()</span>
        <span class="s1">writer</span><span class="s2">.</span><span class="s1">dumphex</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">)</span>
        <span class="s1">writer</span><span class="s2">.</span><span class="s1">endtag</span><span class="s2">(</span><span class="s1">cmapName</span><span class="s2">)</span>
        <span class="s1">writer</span><span class="s2">.</span><span class="s1">newline</span><span class="s2">()</span>

    <span class="s0">def </span><span class="s1">fromXML</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">attrs</span><span class="s2">, </span><span class="s1">content</span><span class="s2">, </span><span class="s1">ttFont</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">data </span><span class="s2">= </span><span class="s1">readHex</span><span class="s2">(</span><span class="s1">content</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">cmap </span><span class="s2">= {}</span>

    <span class="s0">def </span><span class="s1">decompileHeader</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">ttFont</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">language </span><span class="s2">= </span><span class="s3">0  </span><span class="s5"># dummy value</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">data </span><span class="s2">= </span><span class="s1">data</span>

    <span class="s0">def </span><span class="s1">decompile</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">ttFont</span><span class="s2">):</span>
        <span class="s5"># we usually get here indirectly from the subtable __getattr__ function, in which case both args must be None.</span>
        <span class="s5"># If not, someone is calling the subtable decompile() directly, and must provide both args.</span>
        <span class="s0">if </span><span class="s1">data </span><span class="s0">is not None and </span><span class="s1">ttFont </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">decompileHeader</span><span class="s2">(</span><span class="s1">data</span><span class="s2">, </span><span class="s1">ttFont</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">assert </span><span class="s2">(</span>
                <span class="s1">data </span><span class="s0">is None and </span><span class="s1">ttFont </span><span class="s0">is None</span>
            <span class="s2">), </span><span class="s6">&quot;Need both data and ttFont arguments&quot;</span>

    <span class="s0">def </span><span class="s1">compile</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">ttFont</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">return None</span>


<span class="s1">cmap_classes </span><span class="s2">= {</span>
    <span class="s3">0</span><span class="s2">: </span><span class="s1">cmap_format_0</span><span class="s2">,</span>
    <span class="s3">2</span><span class="s2">: </span><span class="s1">cmap_format_2</span><span class="s2">,</span>
    <span class="s3">4</span><span class="s2">: </span><span class="s1">cmap_format_4</span><span class="s2">,</span>
    <span class="s3">6</span><span class="s2">: </span><span class="s1">cmap_format_6</span><span class="s2">,</span>
    <span class="s3">12</span><span class="s2">: </span><span class="s1">cmap_format_12</span><span class="s2">,</span>
    <span class="s3">13</span><span class="s2">: </span><span class="s1">cmap_format_13</span><span class="s2">,</span>
    <span class="s3">14</span><span class="s2">: </span><span class="s1">cmap_format_14</span><span class="s2">,</span>
<span class="s2">}</span>
</pre>
</body>
</html>