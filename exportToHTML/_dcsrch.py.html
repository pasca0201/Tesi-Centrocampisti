<html>
<head>
<title>_dcsrch.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #6aab73;}
.s3 { color: #7a7e85;}
.s4 { color: #bcbec4;}
.s5 { color: #5f826b; font-style: italic;}
.s6 { color: #2aacb8;}
.s7 { color: #a5c261;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_dcsrch.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>

<span class="s2">&quot;&quot;&quot; 
# 2023 - ported from minpack2.dcsrch, dcstep (Fortran) to Python 
c     MINPACK-1 Project. June 1983. 
c     Argonne National Laboratory. 
c     Jorge J. More' and David J. Thuente. 
c 
c     MINPACK-2 Project. November 1993. 
c     Argonne National Laboratory and University of Minnesota. 
c     Brett M. Averick, Richard G. Carter, and Jorge J. More'. 
&quot;&quot;&quot;</span>

<span class="s3"># NOTE this file was linted by black on first commit, and can be kept that way.</span>


<span class="s0">class </span><span class="s1">DCSRCH</span><span class="s4">:</span>
    <span class="s5">&quot;&quot;&quot; 
    Parameters 
    ---------- 
    phi : callable phi(alpha) 
        Function at point `alpha` 
    derphi : callable phi'(alpha) 
        Objective function derivative. Returns a scalar. 
    ftol : float 
        A nonnegative tolerance for the sufficient decrease condition. 
    gtol : float 
        A nonnegative tolerance for the curvature condition. 
    xtol : float 
        A nonnegative relative tolerance for an acceptable step. The 
        subroutine exits with a warning if the relative difference between 
        sty and stx is less than xtol. 
    stpmin : float 
        A nonnegative lower bound for the step. 
    stpmax : 
        A nonnegative upper bound for the step. 
 
    Notes 
    ----- 
 
    This subroutine finds a step that satisfies a sufficient 
    decrease condition and a curvature condition. 
 
    Each call of the subroutine updates an interval with 
    endpoints stx and sty. The interval is initially chosen 
    so that it contains a minimizer of the modified function 
 
           psi(stp) = f(stp) - f(0) - ftol*stp*f'(0). 
 
    If psi(stp) &lt;= 0 and f'(stp) &gt;= 0 for some step, then the 
    interval is chosen so that it contains a minimizer of f. 
 
    The algorithm is designed to find a step that satisfies 
    the sufficient decrease condition 
 
           f(stp) &lt;= f(0) + ftol*stp*f'(0), 
 
    and the curvature condition 
 
           abs(f'(stp)) &lt;= gtol*abs(f'(0)). 
 
    If ftol is less than gtol and if, for example, the function 
    is bounded below, then there is always a step which satisfies 
    both conditions. 
 
    If no step can be found that satisfies both conditions, then 
    the algorithm stops with a warning. In this case stp only 
    satisfies the sufficient decrease condition. 
 
    A typical invocation of dcsrch has the following outline: 
 
    Evaluate the function at stp = 0.0d0; store in f. 
    Evaluate the gradient at stp = 0.0d0; store in g. 
    Choose a starting step stp. 
 
    task = 'START' 
    10 continue 
        call dcsrch(stp,f,g,ftol,gtol,xtol,task,stpmin,stpmax, 
                   isave,dsave) 
        if (task .eq. 'FG') then 
           Evaluate the function and the gradient at stp 
           go to 10 
           end if 
 
    NOTE: The user must not alter work arrays between calls. 
 
    The subroutine statement is 
 
        subroutine dcsrch(f,g,stp,ftol,gtol,xtol,stpmin,stpmax, 
                         task,isave,dsave) 
        where 
 
    stp is a double precision variable. 
        On entry stp is the current estimate of a satisfactory 
            step. On initial entry, a positive initial estimate 
            must be provided. 
        On exit stp is the current estimate of a satisfactory step 
            if task = 'FG'. If task = 'CONV' then stp satisfies 
            the sufficient decrease and curvature condition. 
 
    f is a double precision variable. 
        On initial entry f is the value of the function at 0. 
        On subsequent entries f is the value of the 
            function at stp. 
        On exit f is the value of the function at stp. 
 
    g is a double precision variable. 
        On initial entry g is the derivative of the function at 0. 
        On subsequent entries g is the derivative of the 
           function at stp. 
        On exit g is the derivative of the function at stp. 
 
    ftol is a double precision variable. 
        On entry ftol specifies a nonnegative tolerance for the 
           sufficient decrease condition. 
        On exit ftol is unchanged. 
 
    gtol is a double precision variable. 
        On entry gtol specifies a nonnegative tolerance for the 
           curvature condition. 
        On exit gtol is unchanged. 
 
    xtol is a double precision variable. 
        On entry xtol specifies a nonnegative relative tolerance 
          for an acceptable step. The subroutine exits with a 
          warning if the relative difference between sty and stx 
          is less than xtol. 
 
        On exit xtol is unchanged. 
 
    task is a character variable of length at least 60. 
        On initial entry task must be set to 'START'. 
        On exit task indicates the required action: 
 
           If task(1:2) = 'FG' then evaluate the function and 
           derivative at stp and call dcsrch again. 
 
           If task(1:4) = 'CONV' then the search is successful. 
 
           If task(1:4) = 'WARN' then the subroutine is not able 
           to satisfy the convergence conditions. The exit value of 
           stp contains the best point found during the search. 
 
          If task(1:5) = 'ERROR' then there is an error in the 
          input arguments. 
 
        On exit with convergence, a warning or an error, the 
           variable task contains additional information. 
 
    stpmin is a double precision variable. 
        On entry stpmin is a nonnegative lower bound for the step. 
        On exit stpmin is unchanged. 
 
    stpmax is a double precision variable. 
        On entry stpmax is a nonnegative upper bound for the step. 
        On exit stpmax is unchanged. 
 
    isave is an integer work array of dimension 2. 
 
    dsave is a double precision work array of dimension 13. 
 
    Subprograms called 
 
      MINPACK-2 ... dcstep 
    MINPACK-1 Project. June 1983. 
    Argonne National Laboratory. 
    Jorge J. More' and David J. Thuente. 
 
    MINPACK-2 Project. November 1993. 
    Argonne National Laboratory and University of Minnesota. 
    Brett M. Averick, Richard G. Carter, and Jorge J. More'. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">phi</span><span class="s4">, </span><span class="s1">derphi</span><span class="s4">, </span><span class="s1">ftol</span><span class="s4">, </span><span class="s1">gtol</span><span class="s4">, </span><span class="s1">xtol</span><span class="s4">, </span><span class="s1">stpmin</span><span class="s4">, </span><span class="s1">stpmax</span><span class="s4">):</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">stage </span><span class="s4">= </span><span class="s0">None</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">ginit </span><span class="s4">= </span><span class="s0">None</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">gtest </span><span class="s4">= </span><span class="s0">None</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">gx </span><span class="s4">= </span><span class="s0">None</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">gy </span><span class="s4">= </span><span class="s0">None</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">finit </span><span class="s4">= </span><span class="s0">None</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">fx </span><span class="s4">= </span><span class="s0">None</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">fy </span><span class="s4">= </span><span class="s0">None</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">stx </span><span class="s4">= </span><span class="s0">None</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">sty </span><span class="s4">= </span><span class="s0">None</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">stmin </span><span class="s4">= </span><span class="s0">None</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">stmax </span><span class="s4">= </span><span class="s0">None</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">width </span><span class="s4">= </span><span class="s0">None</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">width1 </span><span class="s4">= </span><span class="s0">None</span>

        <span class="s3"># leave all assessment of tolerances/limits to the first call of</span>
        <span class="s3"># this object</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">ftol </span><span class="s4">= </span><span class="s1">ftol</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">gtol </span><span class="s4">= </span><span class="s1">gtol</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">xtol </span><span class="s4">= </span><span class="s1">xtol</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">stpmin </span><span class="s4">= </span><span class="s1">stpmin</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">stpmax </span><span class="s4">= </span><span class="s1">stpmax</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">phi </span><span class="s4">= </span><span class="s1">phi</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">derphi </span><span class="s4">= </span><span class="s1">derphi</span>

    <span class="s0">def </span><span class="s1">__call__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">alpha1</span><span class="s4">, </span><span class="s1">phi0</span><span class="s4">=</span><span class="s0">None</span><span class="s4">, </span><span class="s1">derphi0</span><span class="s4">=</span><span class="s0">None</span><span class="s4">, </span><span class="s1">maxiter</span><span class="s4">=</span><span class="s6">100</span><span class="s4">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        alpha1 : float 
            alpha1 is the current estimate of a satisfactory 
            step. A positive initial estimate must be provided. 
        phi0 : float 
            the value of `phi` at 0 (if known). 
        derphi0 : float 
            the derivative of `derphi` at 0 (if known). 
        maxiter : int 
 
        Returns 
        ------- 
        alpha : float 
            Step size, or None if no suitable step was found. 
        phi : float 
            Value of `phi` at the new point `alpha`. 
        phi0 : float 
            Value of `phi` at `alpha=0`. 
        task : bytes 
            On exit task indicates status information. 
 
           If task[:4] == b'CONV' then the search is successful. 
 
           If task[:4] == b'WARN' then the subroutine is not able 
           to satisfy the convergence conditions. The exit value of 
           stp contains the best point found during the search. 
 
           If task[:5] == b'ERROR' then there is an error in the 
           input arguments. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">phi0 </span><span class="s0">is None</span><span class="s4">:</span>
            <span class="s1">phi0 </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">phi</span><span class="s4">(</span><span class="s6">0.0</span><span class="s4">)</span>
        <span class="s0">if </span><span class="s1">derphi0 </span><span class="s0">is None</span><span class="s4">:</span>
            <span class="s1">derphi0 </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">derphi</span><span class="s4">(</span><span class="s6">0.0</span><span class="s4">)</span>

        <span class="s1">phi1 </span><span class="s4">= </span><span class="s1">phi0</span>
        <span class="s1">derphi1 </span><span class="s4">= </span><span class="s1">derphi0</span>

        <span class="s1">task </span><span class="s4">= </span><span class="s7">b&quot;START&quot;</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s4">(</span><span class="s1">maxiter</span><span class="s4">):</span>
            <span class="s1">stp</span><span class="s4">, </span><span class="s1">phi1</span><span class="s4">, </span><span class="s1">derphi1</span><span class="s4">, </span><span class="s1">task </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_iterate</span><span class="s4">(</span>
                <span class="s1">alpha1</span><span class="s4">, </span><span class="s1">phi1</span><span class="s4">, </span><span class="s1">derphi1</span><span class="s4">, </span><span class="s1">task</span>
            <span class="s4">)</span>

            <span class="s0">if not </span><span class="s1">np</span><span class="s4">.</span><span class="s1">isfinite</span><span class="s4">(</span><span class="s1">stp</span><span class="s4">):</span>
                <span class="s1">task </span><span class="s4">= </span><span class="s7">b&quot;WARN&quot;</span>
                <span class="s1">stp </span><span class="s4">= </span><span class="s0">None</span>
                <span class="s0">break</span>

            <span class="s0">if </span><span class="s1">task</span><span class="s4">[:</span><span class="s6">2</span><span class="s4">] == </span><span class="s7">b&quot;FG&quot;</span><span class="s4">:</span>
                <span class="s1">alpha1 </span><span class="s4">= </span><span class="s1">stp</span>
                <span class="s1">phi1 </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">phi</span><span class="s4">(</span><span class="s1">stp</span><span class="s4">)</span>
                <span class="s1">derphi1 </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">derphi</span><span class="s4">(</span><span class="s1">stp</span><span class="s4">)</span>
            <span class="s0">else</span><span class="s4">:</span>
                <span class="s0">break</span>
        <span class="s0">else</span><span class="s4">:</span>
            <span class="s3"># maxiter reached, the line search did not converge</span>
            <span class="s1">stp </span><span class="s4">= </span><span class="s0">None</span>
            <span class="s1">task </span><span class="s4">= </span><span class="s7">b&quot;WARNING: dcsrch did not converge within max iterations&quot;</span>

        <span class="s0">if </span><span class="s1">task</span><span class="s4">[:</span><span class="s6">5</span><span class="s4">] == </span><span class="s7">b&quot;ERROR&quot; </span><span class="s0">or </span><span class="s1">task</span><span class="s4">[:</span><span class="s6">4</span><span class="s4">] == </span><span class="s7">b&quot;WARN&quot;</span><span class="s4">:</span>
            <span class="s1">stp </span><span class="s4">= </span><span class="s0">None  </span><span class="s3"># failed</span>

        <span class="s0">return </span><span class="s1">stp</span><span class="s4">, </span><span class="s1">phi1</span><span class="s4">, </span><span class="s1">phi0</span><span class="s4">, </span><span class="s1">task</span>

    <span class="s0">def </span><span class="s1">_iterate</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">stp</span><span class="s4">, </span><span class="s1">f</span><span class="s4">, </span><span class="s1">g</span><span class="s4">, </span><span class="s1">task</span><span class="s4">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        stp : float 
            The current estimate of a satisfactory step. On initial entry, a 
            positive initial estimate must be provided. 
        f : float 
            On first call f is the value of the function at 0. On subsequent 
            entries f should be the value of the function at stp. 
        g : float 
            On initial entry g is the derivative of the function at 0. On 
            subsequent entries g is the derivative of the function at stp. 
        task : bytes 
            On initial entry task must be set to 'START'. 
 
        On exit with convergence, a warning or an error, the 
           variable task contains additional information. 
 
 
        Returns 
        ------- 
        stp, f, g, task: tuple 
 
            stp : float 
                the current estimate of a satisfactory step if task = 'FG'. If 
                task = 'CONV' then stp satisfies the sufficient decrease and 
                curvature condition. 
            f : float 
                the value of the function at stp. 
            g : float 
                the derivative of the function at stp. 
            task : bytes 
                On exit task indicates the required action: 
 
               If task(1:2) == b'FG' then evaluate the function and 
               derivative at stp and call dcsrch again. 
 
               If task(1:4) == b'CONV' then the search is successful. 
 
               If task(1:4) == b'WARN' then the subroutine is not able 
               to satisfy the convergence conditions. The exit value of 
               stp contains the best point found during the search. 
 
              If task(1:5) == b'ERROR' then there is an error in the 
              input arguments. 
        &quot;&quot;&quot;</span>
        <span class="s1">p5 </span><span class="s4">= </span><span class="s6">0.5</span>
        <span class="s1">p66 </span><span class="s4">= </span><span class="s6">0.66</span>
        <span class="s1">xtrapl </span><span class="s4">= </span><span class="s6">1.1</span>
        <span class="s1">xtrapu </span><span class="s4">= </span><span class="s6">4.0</span>

        <span class="s0">if </span><span class="s1">task</span><span class="s4">[:</span><span class="s6">5</span><span class="s4">] == </span><span class="s7">b&quot;START&quot;</span><span class="s4">:</span>
            <span class="s0">if </span><span class="s1">stp </span><span class="s4">&lt; </span><span class="s1">self</span><span class="s4">.</span><span class="s1">stpmin</span><span class="s4">:</span>
                <span class="s1">task </span><span class="s4">= </span><span class="s7">b&quot;ERROR: STP .LT. STPMIN&quot;</span>
            <span class="s0">if </span><span class="s1">stp </span><span class="s4">&gt; </span><span class="s1">self</span><span class="s4">.</span><span class="s1">stpmax</span><span class="s4">:</span>
                <span class="s1">task </span><span class="s4">= </span><span class="s7">b&quot;ERROR: STP .GT. STPMAX&quot;</span>
            <span class="s0">if </span><span class="s1">g </span><span class="s4">&gt;= </span><span class="s6">0</span><span class="s4">:</span>
                <span class="s1">task </span><span class="s4">= </span><span class="s7">b&quot;ERROR: INITIAL G .GE. ZERO&quot;</span>
            <span class="s0">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">ftol </span><span class="s4">&lt; </span><span class="s6">0</span><span class="s4">:</span>
                <span class="s1">task </span><span class="s4">= </span><span class="s7">b&quot;ERROR: FTOL .LT. ZERO&quot;</span>
            <span class="s0">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">gtol </span><span class="s4">&lt; </span><span class="s6">0</span><span class="s4">:</span>
                <span class="s1">task </span><span class="s4">= </span><span class="s7">b&quot;ERROR: GTOL .LT. ZERO&quot;</span>
            <span class="s0">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">xtol </span><span class="s4">&lt; </span><span class="s6">0</span><span class="s4">:</span>
                <span class="s1">task </span><span class="s4">= </span><span class="s7">b&quot;ERROR: XTOL .LT. ZERO&quot;</span>
            <span class="s0">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">stpmin </span><span class="s4">&lt; </span><span class="s6">0</span><span class="s4">:</span>
                <span class="s1">task </span><span class="s4">= </span><span class="s7">b&quot;ERROR: STPMIN .LT. ZERO&quot;</span>
            <span class="s0">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">stpmax </span><span class="s4">&lt; </span><span class="s1">self</span><span class="s4">.</span><span class="s1">stpmin</span><span class="s4">:</span>
                <span class="s1">task </span><span class="s4">= </span><span class="s7">b&quot;ERROR: STPMAX .LT. STPMIN&quot;</span>

            <span class="s0">if </span><span class="s1">task</span><span class="s4">[:</span><span class="s6">5</span><span class="s4">] == </span><span class="s7">b&quot;ERROR&quot;</span><span class="s4">:</span>
                <span class="s0">return </span><span class="s1">stp</span><span class="s4">, </span><span class="s1">f</span><span class="s4">, </span><span class="s1">g</span><span class="s4">, </span><span class="s1">task</span>

            <span class="s3"># Initialize local variables.</span>

            <span class="s1">self</span><span class="s4">.</span><span class="s1">brackt </span><span class="s4">= </span><span class="s0">False</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">stage </span><span class="s4">= </span><span class="s6">1</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">finit </span><span class="s4">= </span><span class="s1">f</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">ginit </span><span class="s4">= </span><span class="s1">g</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">gtest </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">ftol </span><span class="s4">* </span><span class="s1">self</span><span class="s4">.</span><span class="s1">ginit</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">width </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">stpmax </span><span class="s4">- </span><span class="s1">self</span><span class="s4">.</span><span class="s1">stpmin</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">width1 </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">width </span><span class="s4">/ </span><span class="s1">p5</span>

            <span class="s3"># The variables stx, fx, gx contain the values of the step,</span>
            <span class="s3"># function, and derivative at the best step.</span>
            <span class="s3"># The variables sty, fy, gy contain the value of the step,</span>
            <span class="s3"># function, and derivative at sty.</span>
            <span class="s3"># The variables stp, f, g contain the values of the step,</span>
            <span class="s3"># function, and derivative at stp.</span>

            <span class="s1">self</span><span class="s4">.</span><span class="s1">stx </span><span class="s4">= </span><span class="s6">0.0</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">fx </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">finit</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">gx </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">ginit</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">sty </span><span class="s4">= </span><span class="s6">0.0</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">fy </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">finit</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">gy </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">ginit</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">stmin </span><span class="s4">= </span><span class="s6">0</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">stmax </span><span class="s4">= </span><span class="s1">stp </span><span class="s4">+ </span><span class="s1">xtrapu </span><span class="s4">* </span><span class="s1">stp</span>
            <span class="s1">task </span><span class="s4">= </span><span class="s7">b&quot;FG&quot;</span>
            <span class="s0">return </span><span class="s1">stp</span><span class="s4">, </span><span class="s1">f</span><span class="s4">, </span><span class="s1">g</span><span class="s4">, </span><span class="s1">task</span>

        <span class="s3"># in the original Fortran this was a location to restore variables</span>
        <span class="s3"># we don't need to do that because they're attributes.</span>

        <span class="s3"># If psi(stp) &lt;= 0 and f'(stp) &gt;= 0 for some step, then the</span>
        <span class="s3"># algorithm enters the second stage.</span>
        <span class="s1">ftest </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">finit </span><span class="s4">+ </span><span class="s1">stp </span><span class="s4">* </span><span class="s1">self</span><span class="s4">.</span><span class="s1">gtest</span>

        <span class="s0">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">stage </span><span class="s4">== </span><span class="s6">1 </span><span class="s0">and </span><span class="s1">f </span><span class="s4">&lt;= </span><span class="s1">ftest </span><span class="s0">and </span><span class="s1">g </span><span class="s4">&gt;= </span><span class="s6">0</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">stage </span><span class="s4">= </span><span class="s6">2</span>

        <span class="s3"># test for warnings</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">brackt </span><span class="s0">and </span><span class="s4">(</span><span class="s1">stp </span><span class="s4">&lt;= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">stmin </span><span class="s0">or </span><span class="s1">stp </span><span class="s4">&gt;= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">stmax</span><span class="s4">):</span>
            <span class="s1">task </span><span class="s4">= </span><span class="s7">b&quot;WARNING: ROUNDING ERRORS PREVENT PROGRESS&quot;</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">brackt </span><span class="s0">and </span><span class="s1">self</span><span class="s4">.</span><span class="s1">stmax </span><span class="s4">- </span><span class="s1">self</span><span class="s4">.</span><span class="s1">stmin </span><span class="s4">&lt;= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">xtol </span><span class="s4">* </span><span class="s1">self</span><span class="s4">.</span><span class="s1">stmax</span><span class="s4">:</span>
            <span class="s1">task </span><span class="s4">= </span><span class="s7">b&quot;WARNING: XTOL TEST SATISFIED&quot;</span>
        <span class="s0">if </span><span class="s1">stp </span><span class="s4">== </span><span class="s1">self</span><span class="s4">.</span><span class="s1">stpmax </span><span class="s0">and </span><span class="s1">f </span><span class="s4">&lt;= </span><span class="s1">ftest </span><span class="s0">and </span><span class="s1">g </span><span class="s4">&lt;= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">gtest</span><span class="s4">:</span>
            <span class="s1">task </span><span class="s4">= </span><span class="s7">b&quot;WARNING: STP = STPMAX&quot;</span>
        <span class="s0">if </span><span class="s1">stp </span><span class="s4">== </span><span class="s1">self</span><span class="s4">.</span><span class="s1">stpmin </span><span class="s0">and </span><span class="s4">(</span><span class="s1">f </span><span class="s4">&gt; </span><span class="s1">ftest </span><span class="s0">or </span><span class="s1">g </span><span class="s4">&gt;= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">gtest</span><span class="s4">):</span>
            <span class="s1">task </span><span class="s4">= </span><span class="s7">b&quot;WARNING: STP = STPMIN&quot;</span>

        <span class="s3"># test for convergence</span>
        <span class="s0">if </span><span class="s1">f </span><span class="s4">&lt;= </span><span class="s1">ftest </span><span class="s0">and </span><span class="s1">abs</span><span class="s4">(</span><span class="s1">g</span><span class="s4">) &lt;= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">gtol </span><span class="s4">* -</span><span class="s1">self</span><span class="s4">.</span><span class="s1">ginit</span><span class="s4">:</span>
            <span class="s1">task </span><span class="s4">= </span><span class="s7">b&quot;CONVERGENCE&quot;</span>

        <span class="s3"># test for termination</span>
        <span class="s0">if </span><span class="s1">task</span><span class="s4">[:</span><span class="s6">4</span><span class="s4">] == </span><span class="s7">b&quot;WARN&quot; </span><span class="s0">or </span><span class="s1">task</span><span class="s4">[:</span><span class="s6">4</span><span class="s4">] == </span><span class="s7">b&quot;CONV&quot;</span><span class="s4">:</span>
            <span class="s0">return </span><span class="s1">stp</span><span class="s4">, </span><span class="s1">f</span><span class="s4">, </span><span class="s1">g</span><span class="s4">, </span><span class="s1">task</span>

        <span class="s3"># A modified function is used to predict the step during the</span>
        <span class="s3"># first stage if a lower function value has been obtained but</span>
        <span class="s3"># the decrease is not sufficient.</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">stage </span><span class="s4">== </span><span class="s6">1 </span><span class="s0">and </span><span class="s1">f </span><span class="s4">&lt;= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">fx </span><span class="s0">and </span><span class="s1">f </span><span class="s4">&gt; </span><span class="s1">ftest</span><span class="s4">:</span>
            <span class="s3"># Define the modified function and derivative values.</span>
            <span class="s1">fm </span><span class="s4">= </span><span class="s1">f </span><span class="s4">- </span><span class="s1">stp </span><span class="s4">* </span><span class="s1">self</span><span class="s4">.</span><span class="s1">gtest</span>
            <span class="s1">fxm </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">fx </span><span class="s4">- </span><span class="s1">self</span><span class="s4">.</span><span class="s1">stx </span><span class="s4">* </span><span class="s1">self</span><span class="s4">.</span><span class="s1">gtest</span>
            <span class="s1">fym </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">fy </span><span class="s4">- </span><span class="s1">self</span><span class="s4">.</span><span class="s1">sty </span><span class="s4">* </span><span class="s1">self</span><span class="s4">.</span><span class="s1">gtest</span>
            <span class="s1">gm </span><span class="s4">= </span><span class="s1">g </span><span class="s4">- </span><span class="s1">self</span><span class="s4">.</span><span class="s1">gtest</span>
            <span class="s1">gxm </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">gx </span><span class="s4">- </span><span class="s1">self</span><span class="s4">.</span><span class="s1">gtest</span>
            <span class="s1">gym </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">gy </span><span class="s4">- </span><span class="s1">self</span><span class="s4">.</span><span class="s1">gtest</span>

            <span class="s3"># Call dcstep to update stx, sty, and to compute the new step.</span>
            <span class="s3"># dcstep can have several operations which can produce NaN</span>
            <span class="s3"># e.g. inf/inf. Filter these out.</span>
            <span class="s0">with </span><span class="s1">np</span><span class="s4">.</span><span class="s1">errstate</span><span class="s4">(</span><span class="s1">invalid</span><span class="s4">=</span><span class="s2">&quot;ignore&quot;</span><span class="s4">, </span><span class="s1">over</span><span class="s4">=</span><span class="s2">&quot;ignore&quot;</span><span class="s4">):</span>
                <span class="s1">tup </span><span class="s4">= </span><span class="s1">dcstep</span><span class="s4">(</span>
                    <span class="s1">self</span><span class="s4">.</span><span class="s1">stx</span><span class="s4">,</span>
                    <span class="s1">fxm</span><span class="s4">,</span>
                    <span class="s1">gxm</span><span class="s4">,</span>
                    <span class="s1">self</span><span class="s4">.</span><span class="s1">sty</span><span class="s4">,</span>
                    <span class="s1">fym</span><span class="s4">,</span>
                    <span class="s1">gym</span><span class="s4">,</span>
                    <span class="s1">stp</span><span class="s4">,</span>
                    <span class="s1">fm</span><span class="s4">,</span>
                    <span class="s1">gm</span><span class="s4">,</span>
                    <span class="s1">self</span><span class="s4">.</span><span class="s1">brackt</span><span class="s4">,</span>
                    <span class="s1">self</span><span class="s4">.</span><span class="s1">stmin</span><span class="s4">,</span>
                    <span class="s1">self</span><span class="s4">.</span><span class="s1">stmax</span><span class="s4">,</span>
                <span class="s4">)</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">stx</span><span class="s4">, </span><span class="s1">fxm</span><span class="s4">, </span><span class="s1">gxm</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">sty</span><span class="s4">, </span><span class="s1">fym</span><span class="s4">, </span><span class="s1">gym</span><span class="s4">, </span><span class="s1">stp</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">brackt </span><span class="s4">= </span><span class="s1">tup</span>

            <span class="s3"># Reset the function and derivative values for f</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">fx </span><span class="s4">= </span><span class="s1">fxm </span><span class="s4">+ </span><span class="s1">self</span><span class="s4">.</span><span class="s1">stx </span><span class="s4">* </span><span class="s1">self</span><span class="s4">.</span><span class="s1">gtest</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">fy </span><span class="s4">= </span><span class="s1">fym </span><span class="s4">+ </span><span class="s1">self</span><span class="s4">.</span><span class="s1">sty </span><span class="s4">* </span><span class="s1">self</span><span class="s4">.</span><span class="s1">gtest</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">gx </span><span class="s4">= </span><span class="s1">gxm </span><span class="s4">+ </span><span class="s1">self</span><span class="s4">.</span><span class="s1">gtest</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">gy </span><span class="s4">= </span><span class="s1">gym </span><span class="s4">+ </span><span class="s1">self</span><span class="s4">.</span><span class="s1">gtest</span>

        <span class="s0">else</span><span class="s4">:</span>
            <span class="s3"># Call dcstep to update stx, sty, and to compute the new step.</span>
            <span class="s3"># dcstep can have several operations which can produce NaN</span>
            <span class="s3"># e.g. inf/inf. Filter these out.</span>

            <span class="s0">with </span><span class="s1">np</span><span class="s4">.</span><span class="s1">errstate</span><span class="s4">(</span><span class="s1">invalid</span><span class="s4">=</span><span class="s2">&quot;ignore&quot;</span><span class="s4">, </span><span class="s1">over</span><span class="s4">=</span><span class="s2">&quot;ignore&quot;</span><span class="s4">):</span>
                <span class="s1">tup </span><span class="s4">= </span><span class="s1">dcstep</span><span class="s4">(</span>
                    <span class="s1">self</span><span class="s4">.</span><span class="s1">stx</span><span class="s4">,</span>
                    <span class="s1">self</span><span class="s4">.</span><span class="s1">fx</span><span class="s4">,</span>
                    <span class="s1">self</span><span class="s4">.</span><span class="s1">gx</span><span class="s4">,</span>
                    <span class="s1">self</span><span class="s4">.</span><span class="s1">sty</span><span class="s4">,</span>
                    <span class="s1">self</span><span class="s4">.</span><span class="s1">fy</span><span class="s4">,</span>
                    <span class="s1">self</span><span class="s4">.</span><span class="s1">gy</span><span class="s4">,</span>
                    <span class="s1">stp</span><span class="s4">,</span>
                    <span class="s1">f</span><span class="s4">,</span>
                    <span class="s1">g</span><span class="s4">,</span>
                    <span class="s1">self</span><span class="s4">.</span><span class="s1">brackt</span><span class="s4">,</span>
                    <span class="s1">self</span><span class="s4">.</span><span class="s1">stmin</span><span class="s4">,</span>
                    <span class="s1">self</span><span class="s4">.</span><span class="s1">stmax</span><span class="s4">,</span>
                <span class="s4">)</span>
            <span class="s4">(</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">stx</span><span class="s4">,</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">fx</span><span class="s4">,</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">gx</span><span class="s4">,</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">sty</span><span class="s4">,</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">fy</span><span class="s4">,</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">gy</span><span class="s4">,</span>
                <span class="s1">stp</span><span class="s4">,</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">brackt</span><span class="s4">,</span>
            <span class="s4">) = </span><span class="s1">tup</span>

        <span class="s3"># Decide if a bisection step is needed</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">brackt</span><span class="s4">:</span>
            <span class="s0">if </span><span class="s1">abs</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">sty </span><span class="s4">- </span><span class="s1">self</span><span class="s4">.</span><span class="s1">stx</span><span class="s4">) &gt;= </span><span class="s1">p66 </span><span class="s4">* </span><span class="s1">self</span><span class="s4">.</span><span class="s1">width1</span><span class="s4">:</span>
                <span class="s1">stp </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">stx </span><span class="s4">+ </span><span class="s1">p5 </span><span class="s4">* (</span><span class="s1">self</span><span class="s4">.</span><span class="s1">sty </span><span class="s4">- </span><span class="s1">self</span><span class="s4">.</span><span class="s1">stx</span><span class="s4">)</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">width1 </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">width</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">width </span><span class="s4">= </span><span class="s1">abs</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">sty </span><span class="s4">- </span><span class="s1">self</span><span class="s4">.</span><span class="s1">stx</span><span class="s4">)</span>

        <span class="s3"># Set the minimum and maximum steps allowed for stp.</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">brackt</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">stmin </span><span class="s4">= </span><span class="s1">min</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">stx</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">sty</span><span class="s4">)</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">stmax </span><span class="s4">= </span><span class="s1">max</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">stx</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">sty</span><span class="s4">)</span>
        <span class="s0">else</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">stmin </span><span class="s4">= </span><span class="s1">stp </span><span class="s4">+ </span><span class="s1">xtrapl </span><span class="s4">* (</span><span class="s1">stp </span><span class="s4">- </span><span class="s1">self</span><span class="s4">.</span><span class="s1">stx</span><span class="s4">)</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">stmax </span><span class="s4">= </span><span class="s1">stp </span><span class="s4">+ </span><span class="s1">xtrapu </span><span class="s4">* (</span><span class="s1">stp </span><span class="s4">- </span><span class="s1">self</span><span class="s4">.</span><span class="s1">stx</span><span class="s4">)</span>

        <span class="s3"># Force the step to be within the bounds stpmax and stpmin.</span>
        <span class="s1">stp </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">clip</span><span class="s4">(</span><span class="s1">stp</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">stpmin</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">stpmax</span><span class="s4">)</span>

        <span class="s3"># If further progress is not possible, let stp be the best</span>
        <span class="s3"># point obtained during the search.</span>
        <span class="s0">if </span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">brackt</span>
            <span class="s0">and </span><span class="s4">(</span><span class="s1">stp </span><span class="s4">&lt;= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">stmin </span><span class="s0">or </span><span class="s1">stp </span><span class="s4">&gt;= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">stmax</span><span class="s4">)</span>
            <span class="s0">or </span><span class="s4">(</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">brackt</span>
                <span class="s0">and </span><span class="s1">self</span><span class="s4">.</span><span class="s1">stmax </span><span class="s4">- </span><span class="s1">self</span><span class="s4">.</span><span class="s1">stmin </span><span class="s4">&lt;= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">xtol </span><span class="s4">* </span><span class="s1">self</span><span class="s4">.</span><span class="s1">stmax</span>
            <span class="s4">)</span>
        <span class="s4">):</span>
            <span class="s1">stp </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">stx</span>

        <span class="s3"># Obtain another function and derivative</span>
        <span class="s1">task </span><span class="s4">= </span><span class="s7">b&quot;FG&quot;</span>
        <span class="s0">return </span><span class="s1">stp</span><span class="s4">, </span><span class="s1">f</span><span class="s4">, </span><span class="s1">g</span><span class="s4">, </span><span class="s1">task</span>


<span class="s0">def </span><span class="s1">dcstep</span><span class="s4">(</span><span class="s1">stx</span><span class="s4">, </span><span class="s1">fx</span><span class="s4">, </span><span class="s1">dx</span><span class="s4">, </span><span class="s1">sty</span><span class="s4">, </span><span class="s1">fy</span><span class="s4">, </span><span class="s1">dy</span><span class="s4">, </span><span class="s1">stp</span><span class="s4">, </span><span class="s1">fp</span><span class="s4">, </span><span class="s1">dp</span><span class="s4">, </span><span class="s1">brackt</span><span class="s4">, </span><span class="s1">stpmin</span><span class="s4">, </span><span class="s1">stpmax</span><span class="s4">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Subroutine dcstep 
 
    This subroutine computes a safeguarded step for a search 
    procedure and updates an interval that contains a step that 
    satisfies a sufficient decrease and a curvature condition. 
 
    The parameter stx contains the step with the least function 
    value. If brackt is set to .true. then a minimizer has 
    been bracketed in an interval with endpoints stx and sty. 
    The parameter stp contains the current step. 
    The subroutine assumes that if brackt is set to .true. then 
 
        min(stx,sty) &lt; stp &lt; max(stx,sty), 
 
    and that the derivative at stx is negative in the direction 
    of the step. 
 
    The subroutine statement is 
 
      subroutine dcstep(stx,fx,dx,sty,fy,dy,stp,fp,dp,brackt, 
                        stpmin,stpmax) 
 
    where 
 
    stx is a double precision variable. 
        On entry stx is the best step obtained so far and is an 
          endpoint of the interval that contains the minimizer. 
        On exit stx is the updated best step. 
 
    fx is a double precision variable. 
        On entry fx is the function at stx. 
        On exit fx is the function at stx. 
 
    dx is a double precision variable. 
        On entry dx is the derivative of the function at 
          stx. The derivative must be negative in the direction of 
          the step, that is, dx and stp - stx must have opposite 
          signs. 
        On exit dx is the derivative of the function at stx. 
 
    sty is a double precision variable. 
        On entry sty is the second endpoint of the interval that 
          contains the minimizer. 
        On exit sty is the updated endpoint of the interval that 
          contains the minimizer. 
 
    fy is a double precision variable. 
        On entry fy is the function at sty. 
        On exit fy is the function at sty. 
 
    dy is a double precision variable. 
        On entry dy is the derivative of the function at sty. 
        On exit dy is the derivative of the function at the exit sty. 
 
    stp is a double precision variable. 
        On entry stp is the current step. If brackt is set to .true. 
          then on input stp must be between stx and sty. 
        On exit stp is a new trial step. 
 
    fp is a double precision variable. 
        On entry fp is the function at stp 
        On exit fp is unchanged. 
 
    dp is a double precision variable. 
        On entry dp is the derivative of the function at stp. 
        On exit dp is unchanged. 
 
    brackt is an logical variable. 
        On entry brackt specifies if a minimizer has been bracketed. 
            Initially brackt must be set to .false. 
        On exit brackt specifies if a minimizer has been bracketed. 
            When a minimizer is bracketed brackt is set to .true. 
 
    stpmin is a double precision variable. 
        On entry stpmin is a lower bound for the step. 
        On exit stpmin is unchanged. 
 
    stpmax is a double precision variable. 
        On entry stpmax is an upper bound for the step. 
        On exit stpmax is unchanged. 
 
    MINPACK-1 Project. June 1983 
    Argonne National Laboratory. 
    Jorge J. More' and David J. Thuente. 
 
    MINPACK-2 Project. November 1993. 
    Argonne National Laboratory and University of Minnesota. 
    Brett M. Averick and Jorge J. More'. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">sgn_dp </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">sign</span><span class="s4">(</span><span class="s1">dp</span><span class="s4">)</span>
    <span class="s1">sgn_dx </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">sign</span><span class="s4">(</span><span class="s1">dx</span><span class="s4">)</span>

    <span class="s3"># sgnd = dp * (dx / abs(dx))</span>
    <span class="s1">sgnd </span><span class="s4">= </span><span class="s1">sgn_dp </span><span class="s4">* </span><span class="s1">sgn_dx</span>

    <span class="s3"># First case: A higher function value. The minimum is bracketed.</span>
    <span class="s3"># If the cubic step is closer to stx than the quadratic step, the</span>
    <span class="s3"># cubic step is taken, otherwise the average of the cubic and</span>
    <span class="s3"># quadratic steps is taken.</span>
    <span class="s0">if </span><span class="s1">fp </span><span class="s4">&gt; </span><span class="s1">fx</span><span class="s4">:</span>
        <span class="s1">theta </span><span class="s4">= </span><span class="s6">3.0 </span><span class="s4">* (</span><span class="s1">fx </span><span class="s4">- </span><span class="s1">fp</span><span class="s4">) / (</span><span class="s1">stp </span><span class="s4">- </span><span class="s1">stx</span><span class="s4">) + </span><span class="s1">dx </span><span class="s4">+ </span><span class="s1">dp</span>
        <span class="s1">s </span><span class="s4">= </span><span class="s1">max</span><span class="s4">(</span><span class="s1">abs</span><span class="s4">(</span><span class="s1">theta</span><span class="s4">), </span><span class="s1">abs</span><span class="s4">(</span><span class="s1">dx</span><span class="s4">), </span><span class="s1">abs</span><span class="s4">(</span><span class="s1">dp</span><span class="s4">))</span>
        <span class="s1">gamma </span><span class="s4">= </span><span class="s1">s </span><span class="s4">* </span><span class="s1">np</span><span class="s4">.</span><span class="s1">sqrt</span><span class="s4">((</span><span class="s1">theta </span><span class="s4">/ </span><span class="s1">s</span><span class="s4">) ** </span><span class="s6">2 </span><span class="s4">- (</span><span class="s1">dx </span><span class="s4">/ </span><span class="s1">s</span><span class="s4">) * (</span><span class="s1">dp </span><span class="s4">/ </span><span class="s1">s</span><span class="s4">))</span>
        <span class="s0">if </span><span class="s1">stp </span><span class="s4">&lt; </span><span class="s1">stx</span><span class="s4">:</span>
            <span class="s1">gamma </span><span class="s4">*= -</span><span class="s6">1</span>
        <span class="s1">p </span><span class="s4">= (</span><span class="s1">gamma </span><span class="s4">- </span><span class="s1">dx</span><span class="s4">) + </span><span class="s1">theta</span>
        <span class="s1">q </span><span class="s4">= ((</span><span class="s1">gamma </span><span class="s4">- </span><span class="s1">dx</span><span class="s4">) + </span><span class="s1">gamma</span><span class="s4">) + </span><span class="s1">dp</span>
        <span class="s1">r </span><span class="s4">= </span><span class="s1">p </span><span class="s4">/ </span><span class="s1">q</span>
        <span class="s1">stpc </span><span class="s4">= </span><span class="s1">stx </span><span class="s4">+ </span><span class="s1">r </span><span class="s4">* (</span><span class="s1">stp </span><span class="s4">- </span><span class="s1">stx</span><span class="s4">)</span>
        <span class="s1">stpq </span><span class="s4">= </span><span class="s1">stx </span><span class="s4">+ ((</span><span class="s1">dx </span><span class="s4">/ ((</span><span class="s1">fx </span><span class="s4">- </span><span class="s1">fp</span><span class="s4">) / (</span><span class="s1">stp </span><span class="s4">- </span><span class="s1">stx</span><span class="s4">) + </span><span class="s1">dx</span><span class="s4">)) / </span><span class="s6">2.0</span><span class="s4">) * (</span><span class="s1">stp </span><span class="s4">- </span><span class="s1">stx</span><span class="s4">)</span>
        <span class="s0">if </span><span class="s1">abs</span><span class="s4">(</span><span class="s1">stpc </span><span class="s4">- </span><span class="s1">stx</span><span class="s4">) &lt;= </span><span class="s1">abs</span><span class="s4">(</span><span class="s1">stpq </span><span class="s4">- </span><span class="s1">stx</span><span class="s4">):</span>
            <span class="s1">stpf </span><span class="s4">= </span><span class="s1">stpc</span>
        <span class="s0">else</span><span class="s4">:</span>
            <span class="s1">stpf </span><span class="s4">= </span><span class="s1">stpc </span><span class="s4">+ (</span><span class="s1">stpq </span><span class="s4">- </span><span class="s1">stpc</span><span class="s4">) / </span><span class="s6">2.0</span>
        <span class="s1">brackt </span><span class="s4">= </span><span class="s0">True</span>
    <span class="s0">elif </span><span class="s1">sgnd </span><span class="s4">&lt; </span><span class="s6">0.0</span><span class="s4">:</span>
        <span class="s3"># Second case: A lower function value and derivatives of opposite</span>
        <span class="s3"># sign. The minimum is bracketed. If the cubic step is farther from</span>
        <span class="s3"># stp than the secant step, the cubic step is taken, otherwise the</span>
        <span class="s3"># secant step is taken.</span>
        <span class="s1">theta </span><span class="s4">= </span><span class="s6">3 </span><span class="s4">* (</span><span class="s1">fx </span><span class="s4">- </span><span class="s1">fp</span><span class="s4">) / (</span><span class="s1">stp </span><span class="s4">- </span><span class="s1">stx</span><span class="s4">) + </span><span class="s1">dx </span><span class="s4">+ </span><span class="s1">dp</span>
        <span class="s1">s </span><span class="s4">= </span><span class="s1">max</span><span class="s4">(</span><span class="s1">abs</span><span class="s4">(</span><span class="s1">theta</span><span class="s4">), </span><span class="s1">abs</span><span class="s4">(</span><span class="s1">dx</span><span class="s4">), </span><span class="s1">abs</span><span class="s4">(</span><span class="s1">dp</span><span class="s4">))</span>
        <span class="s1">gamma </span><span class="s4">= </span><span class="s1">s </span><span class="s4">* </span><span class="s1">np</span><span class="s4">.</span><span class="s1">sqrt</span><span class="s4">((</span><span class="s1">theta </span><span class="s4">/ </span><span class="s1">s</span><span class="s4">) ** </span><span class="s6">2 </span><span class="s4">- (</span><span class="s1">dx </span><span class="s4">/ </span><span class="s1">s</span><span class="s4">) * (</span><span class="s1">dp </span><span class="s4">/ </span><span class="s1">s</span><span class="s4">))</span>
        <span class="s0">if </span><span class="s1">stp </span><span class="s4">&gt; </span><span class="s1">stx</span><span class="s4">:</span>
            <span class="s1">gamma </span><span class="s4">*= -</span><span class="s6">1</span>
        <span class="s1">p </span><span class="s4">= (</span><span class="s1">gamma </span><span class="s4">- </span><span class="s1">dp</span><span class="s4">) + </span><span class="s1">theta</span>
        <span class="s1">q </span><span class="s4">= ((</span><span class="s1">gamma </span><span class="s4">- </span><span class="s1">dp</span><span class="s4">) + </span><span class="s1">gamma</span><span class="s4">) + </span><span class="s1">dx</span>
        <span class="s1">r </span><span class="s4">= </span><span class="s1">p </span><span class="s4">/ </span><span class="s1">q</span>
        <span class="s1">stpc </span><span class="s4">= </span><span class="s1">stp </span><span class="s4">+ </span><span class="s1">r </span><span class="s4">* (</span><span class="s1">stx </span><span class="s4">- </span><span class="s1">stp</span><span class="s4">)</span>
        <span class="s1">stpq </span><span class="s4">= </span><span class="s1">stp </span><span class="s4">+ (</span><span class="s1">dp </span><span class="s4">/ (</span><span class="s1">dp </span><span class="s4">- </span><span class="s1">dx</span><span class="s4">)) * (</span><span class="s1">stx </span><span class="s4">- </span><span class="s1">stp</span><span class="s4">)</span>
        <span class="s0">if </span><span class="s1">abs</span><span class="s4">(</span><span class="s1">stpc </span><span class="s4">- </span><span class="s1">stp</span><span class="s4">) &gt; </span><span class="s1">abs</span><span class="s4">(</span><span class="s1">stpq </span><span class="s4">- </span><span class="s1">stp</span><span class="s4">):</span>
            <span class="s1">stpf </span><span class="s4">= </span><span class="s1">stpc</span>
        <span class="s0">else</span><span class="s4">:</span>
            <span class="s1">stpf </span><span class="s4">= </span><span class="s1">stpq</span>
        <span class="s1">brackt </span><span class="s4">= </span><span class="s0">True</span>
    <span class="s0">elif </span><span class="s1">abs</span><span class="s4">(</span><span class="s1">dp</span><span class="s4">) &lt; </span><span class="s1">abs</span><span class="s4">(</span><span class="s1">dx</span><span class="s4">):</span>
        <span class="s3"># Third case: A lower function value, derivatives of the same sign,</span>
        <span class="s3"># and the magnitude of the derivative decreases.</span>

        <span class="s3"># The cubic step is computed only if the cubic tends to infinity</span>
        <span class="s3"># in the direction of the step or if the minimum of the cubic</span>
        <span class="s3"># is beyond stp. Otherwise the cubic step is defined to be the</span>
        <span class="s3"># secant step.</span>
        <span class="s1">theta </span><span class="s4">= </span><span class="s6">3 </span><span class="s4">* (</span><span class="s1">fx </span><span class="s4">- </span><span class="s1">fp</span><span class="s4">) / (</span><span class="s1">stp </span><span class="s4">- </span><span class="s1">stx</span><span class="s4">) + </span><span class="s1">dx </span><span class="s4">+ </span><span class="s1">dp</span>
        <span class="s1">s </span><span class="s4">= </span><span class="s1">max</span><span class="s4">(</span><span class="s1">abs</span><span class="s4">(</span><span class="s1">theta</span><span class="s4">), </span><span class="s1">abs</span><span class="s4">(</span><span class="s1">dx</span><span class="s4">), </span><span class="s1">abs</span><span class="s4">(</span><span class="s1">dp</span><span class="s4">))</span>

        <span class="s3"># The case gamma = 0 only arises if the cubic does not tend</span>
        <span class="s3"># to infinity in the direction of the step.</span>
        <span class="s1">gamma </span><span class="s4">= </span><span class="s1">s </span><span class="s4">* </span><span class="s1">np</span><span class="s4">.</span><span class="s1">sqrt</span><span class="s4">(</span><span class="s1">max</span><span class="s4">(</span><span class="s6">0</span><span class="s4">, (</span><span class="s1">theta </span><span class="s4">/ </span><span class="s1">s</span><span class="s4">) ** </span><span class="s6">2 </span><span class="s4">- (</span><span class="s1">dx </span><span class="s4">/ </span><span class="s1">s</span><span class="s4">) * (</span><span class="s1">dp </span><span class="s4">/ </span><span class="s1">s</span><span class="s4">)))</span>
        <span class="s0">if </span><span class="s1">stp </span><span class="s4">&gt; </span><span class="s1">stx</span><span class="s4">:</span>
            <span class="s1">gamma </span><span class="s4">= -</span><span class="s1">gamma</span>
        <span class="s1">p </span><span class="s4">= (</span><span class="s1">gamma </span><span class="s4">- </span><span class="s1">dp</span><span class="s4">) + </span><span class="s1">theta</span>
        <span class="s1">q </span><span class="s4">= (</span><span class="s1">gamma </span><span class="s4">+ (</span><span class="s1">dx </span><span class="s4">- </span><span class="s1">dp</span><span class="s4">)) + </span><span class="s1">gamma</span>
        <span class="s1">r </span><span class="s4">= </span><span class="s1">p </span><span class="s4">/ </span><span class="s1">q</span>
        <span class="s0">if </span><span class="s1">r </span><span class="s4">&lt; </span><span class="s6">0 </span><span class="s0">and </span><span class="s1">gamma </span><span class="s4">!= </span><span class="s6">0</span><span class="s4">:</span>
            <span class="s1">stpc </span><span class="s4">= </span><span class="s1">stp </span><span class="s4">+ </span><span class="s1">r </span><span class="s4">* (</span><span class="s1">stx </span><span class="s4">- </span><span class="s1">stp</span><span class="s4">)</span>
        <span class="s0">elif </span><span class="s1">stp </span><span class="s4">&gt; </span><span class="s1">stx</span><span class="s4">:</span>
            <span class="s1">stpc </span><span class="s4">= </span><span class="s1">stpmax</span>
        <span class="s0">else</span><span class="s4">:</span>
            <span class="s1">stpc </span><span class="s4">= </span><span class="s1">stpmin</span>
        <span class="s1">stpq </span><span class="s4">= </span><span class="s1">stp </span><span class="s4">+ (</span><span class="s1">dp </span><span class="s4">/ (</span><span class="s1">dp </span><span class="s4">- </span><span class="s1">dx</span><span class="s4">)) * (</span><span class="s1">stx </span><span class="s4">- </span><span class="s1">stp</span><span class="s4">)</span>

        <span class="s0">if </span><span class="s1">brackt</span><span class="s4">:</span>
            <span class="s3"># A minimizer has been bracketed. If the cubic step is</span>
            <span class="s3"># closer to stp than the secant step, the cubic step is</span>
            <span class="s3"># taken, otherwise the secant step is taken.</span>
            <span class="s0">if </span><span class="s1">abs</span><span class="s4">(</span><span class="s1">stpc </span><span class="s4">- </span><span class="s1">stp</span><span class="s4">) &lt; </span><span class="s1">abs</span><span class="s4">(</span><span class="s1">stpq </span><span class="s4">- </span><span class="s1">stp</span><span class="s4">):</span>
                <span class="s1">stpf </span><span class="s4">= </span><span class="s1">stpc</span>
            <span class="s0">else</span><span class="s4">:</span>
                <span class="s1">stpf </span><span class="s4">= </span><span class="s1">stpq</span>

            <span class="s0">if </span><span class="s1">stp </span><span class="s4">&gt; </span><span class="s1">stx</span><span class="s4">:</span>
                <span class="s1">stpf </span><span class="s4">= </span><span class="s1">min</span><span class="s4">(</span><span class="s1">stp </span><span class="s4">+ </span><span class="s6">0.66 </span><span class="s4">* (</span><span class="s1">sty </span><span class="s4">- </span><span class="s1">stp</span><span class="s4">), </span><span class="s1">stpf</span><span class="s4">)</span>
            <span class="s0">else</span><span class="s4">:</span>
                <span class="s1">stpf </span><span class="s4">= </span><span class="s1">max</span><span class="s4">(</span><span class="s1">stp </span><span class="s4">+ </span><span class="s6">0.66 </span><span class="s4">* (</span><span class="s1">sty </span><span class="s4">- </span><span class="s1">stp</span><span class="s4">), </span><span class="s1">stpf</span><span class="s4">)</span>
        <span class="s0">else</span><span class="s4">:</span>
            <span class="s3"># A minimizer has not been bracketed. If the cubic step is</span>
            <span class="s3"># farther from stp than the secant step, the cubic step is</span>
            <span class="s3"># taken, otherwise the secant step is taken.</span>
            <span class="s0">if </span><span class="s1">abs</span><span class="s4">(</span><span class="s1">stpc </span><span class="s4">- </span><span class="s1">stp</span><span class="s4">) &gt; </span><span class="s1">abs</span><span class="s4">(</span><span class="s1">stpq </span><span class="s4">- </span><span class="s1">stp</span><span class="s4">):</span>
                <span class="s1">stpf </span><span class="s4">= </span><span class="s1">stpc</span>
            <span class="s0">else</span><span class="s4">:</span>
                <span class="s1">stpf </span><span class="s4">= </span><span class="s1">stpq</span>
            <span class="s1">stpf </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">clip</span><span class="s4">(</span><span class="s1">stpf</span><span class="s4">, </span><span class="s1">stpmin</span><span class="s4">, </span><span class="s1">stpmax</span><span class="s4">)</span>

    <span class="s0">else</span><span class="s4">:</span>
        <span class="s3"># Fourth case: A lower function value, derivatives of the same sign,</span>
        <span class="s3"># and the magnitude of the derivative does not decrease. If the</span>
        <span class="s3"># minimum is not bracketed, the step is either stpmin or stpmax,</span>
        <span class="s3"># otherwise the cubic step is taken.</span>
        <span class="s0">if </span><span class="s1">brackt</span><span class="s4">:</span>
            <span class="s1">theta </span><span class="s4">= </span><span class="s6">3.0 </span><span class="s4">* (</span><span class="s1">fp </span><span class="s4">- </span><span class="s1">fy</span><span class="s4">) / (</span><span class="s1">sty </span><span class="s4">- </span><span class="s1">stp</span><span class="s4">) + </span><span class="s1">dy </span><span class="s4">+ </span><span class="s1">dp</span>
            <span class="s1">s </span><span class="s4">= </span><span class="s1">max</span><span class="s4">(</span><span class="s1">abs</span><span class="s4">(</span><span class="s1">theta</span><span class="s4">), </span><span class="s1">abs</span><span class="s4">(</span><span class="s1">dy</span><span class="s4">), </span><span class="s1">abs</span><span class="s4">(</span><span class="s1">dp</span><span class="s4">))</span>
            <span class="s1">gamma </span><span class="s4">= </span><span class="s1">s </span><span class="s4">* </span><span class="s1">np</span><span class="s4">.</span><span class="s1">sqrt</span><span class="s4">((</span><span class="s1">theta </span><span class="s4">/ </span><span class="s1">s</span><span class="s4">) ** </span><span class="s6">2 </span><span class="s4">- (</span><span class="s1">dy </span><span class="s4">/ </span><span class="s1">s</span><span class="s4">) * (</span><span class="s1">dp </span><span class="s4">/ </span><span class="s1">s</span><span class="s4">))</span>
            <span class="s0">if </span><span class="s1">stp </span><span class="s4">&gt; </span><span class="s1">sty</span><span class="s4">:</span>
                <span class="s1">gamma </span><span class="s4">= -</span><span class="s1">gamma</span>
            <span class="s1">p </span><span class="s4">= (</span><span class="s1">gamma </span><span class="s4">- </span><span class="s1">dp</span><span class="s4">) + </span><span class="s1">theta</span>
            <span class="s1">q </span><span class="s4">= ((</span><span class="s1">gamma </span><span class="s4">- </span><span class="s1">dp</span><span class="s4">) + </span><span class="s1">gamma</span><span class="s4">) + </span><span class="s1">dy</span>
            <span class="s1">r </span><span class="s4">= </span><span class="s1">p </span><span class="s4">/ </span><span class="s1">q</span>
            <span class="s1">stpc </span><span class="s4">= </span><span class="s1">stp </span><span class="s4">+ </span><span class="s1">r </span><span class="s4">* (</span><span class="s1">sty </span><span class="s4">- </span><span class="s1">stp</span><span class="s4">)</span>
            <span class="s1">stpf </span><span class="s4">= </span><span class="s1">stpc</span>
        <span class="s0">elif </span><span class="s1">stp </span><span class="s4">&gt; </span><span class="s1">stx</span><span class="s4">:</span>
            <span class="s1">stpf </span><span class="s4">= </span><span class="s1">stpmax</span>
        <span class="s0">else</span><span class="s4">:</span>
            <span class="s1">stpf </span><span class="s4">= </span><span class="s1">stpmin</span>

    <span class="s3"># Update the interval which contains a minimizer.</span>
    <span class="s0">if </span><span class="s1">fp </span><span class="s4">&gt; </span><span class="s1">fx</span><span class="s4">:</span>
        <span class="s1">sty </span><span class="s4">= </span><span class="s1">stp</span>
        <span class="s1">fy </span><span class="s4">= </span><span class="s1">fp</span>
        <span class="s1">dy </span><span class="s4">= </span><span class="s1">dp</span>
    <span class="s0">else</span><span class="s4">:</span>
        <span class="s0">if </span><span class="s1">sgnd </span><span class="s4">&lt; </span><span class="s6">0</span><span class="s4">:</span>
            <span class="s1">sty </span><span class="s4">= </span><span class="s1">stx</span>
            <span class="s1">fy </span><span class="s4">= </span><span class="s1">fx</span>
            <span class="s1">dy </span><span class="s4">= </span><span class="s1">dx</span>
        <span class="s1">stx </span><span class="s4">= </span><span class="s1">stp</span>
        <span class="s1">fx </span><span class="s4">= </span><span class="s1">fp</span>
        <span class="s1">dx </span><span class="s4">= </span><span class="s1">dp</span>

    <span class="s3"># Compute the new step.</span>
    <span class="s1">stp </span><span class="s4">= </span><span class="s1">stpf</span>

    <span class="s0">return </span><span class="s1">stx</span><span class="s4">, </span><span class="s1">fx</span><span class="s4">, </span><span class="s1">dx</span><span class="s4">, </span><span class="s1">sty</span><span class="s4">, </span><span class="s1">fy</span><span class="s4">, </span><span class="s1">dy</span><span class="s4">, </span><span class="s1">stp</span><span class="s4">, </span><span class="s1">brackt</span>
</pre>
</body>
</html>