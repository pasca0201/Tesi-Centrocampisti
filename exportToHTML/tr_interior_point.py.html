<html>
<head>
<title>tr_interior_point.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #6aab73;}
.s5 { color: #7a7e85;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
tr_interior_point.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Trust-region interior point method. 
 
References 
---------- 
.. [1] Byrd, Richard H., Mary E. Hribar, and Jorge Nocedal. 
       &quot;An interior point algorithm for large-scale nonlinear 
       programming.&quot; SIAM Journal on Optimization 9.4 (1999): 877-900. 
.. [2] Byrd, Richard H., Guanghui Liu, and Jorge Nocedal. 
       &quot;On the local behavior of an interior point method for 
       nonlinear programming.&quot; Numerical analysis 1997 (1997): 37-56. 
.. [3] Nocedal, Jorge, and Stephen J. Wright. &quot;Numerical optimization&quot; 
       Second Edition (2006). 
&quot;&quot;&quot;</span>

<span class="s2">import </span><span class="s1">scipy</span><span class="s3">.</span><span class="s1">sparse </span><span class="s2">as </span><span class="s1">sps</span>
<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">equality_constrained_sqp </span><span class="s2">import </span><span class="s1">equality_constrained_sqp</span>
<span class="s2">from </span><span class="s1">scipy</span><span class="s3">.</span><span class="s1">sparse</span><span class="s3">.</span><span class="s1">linalg </span><span class="s2">import </span><span class="s1">LinearOperator</span>

<span class="s1">__all__ </span><span class="s3">= [</span><span class="s4">'tr_interior_point'</span><span class="s3">]</span>


<span class="s2">class </span><span class="s1">BarrierSubproblem</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot; 
    Barrier optimization problem: 
        minimize fun(x) - barrier_parameter*sum(log(s)) 
        subject to: constr_eq(x)     = 0 
                  constr_ineq(x) + s = 0 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">x0</span><span class="s3">, </span><span class="s1">s0</span><span class="s3">, </span><span class="s1">fun</span><span class="s3">, </span><span class="s1">grad</span><span class="s3">, </span><span class="s1">lagr_hess</span><span class="s3">, </span><span class="s1">n_vars</span><span class="s3">, </span><span class="s1">n_ineq</span><span class="s3">, </span><span class="s1">n_eq</span><span class="s3">,</span>
                 <span class="s1">constr</span><span class="s3">, </span><span class="s1">jac</span><span class="s3">, </span><span class="s1">barrier_parameter</span><span class="s3">, </span><span class="s1">tolerance</span><span class="s3">,</span>
                 <span class="s1">enforce_feasibility</span><span class="s3">, </span><span class="s1">global_stop_criteria</span><span class="s3">,</span>
                 <span class="s1">xtol</span><span class="s3">, </span><span class="s1">fun0</span><span class="s3">, </span><span class="s1">grad0</span><span class="s3">, </span><span class="s1">constr_ineq0</span><span class="s3">, </span><span class="s1">jac_ineq0</span><span class="s3">, </span><span class="s1">constr_eq0</span><span class="s3">,</span>
                 <span class="s1">jac_eq0</span><span class="s3">):</span>
        <span class="s5"># Store parameters</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">n_vars </span><span class="s3">= </span><span class="s1">n_vars</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">x0 </span><span class="s3">= </span><span class="s1">x0</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">s0 </span><span class="s3">= </span><span class="s1">s0</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">fun </span><span class="s3">= </span><span class="s1">fun</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">grad </span><span class="s3">= </span><span class="s1">grad</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">lagr_hess </span><span class="s3">= </span><span class="s1">lagr_hess</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">constr </span><span class="s3">= </span><span class="s1">constr</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">jac </span><span class="s3">= </span><span class="s1">jac</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">barrier_parameter </span><span class="s3">= </span><span class="s1">barrier_parameter</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">tolerance </span><span class="s3">= </span><span class="s1">tolerance</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">n_eq </span><span class="s3">= </span><span class="s1">n_eq</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">n_ineq </span><span class="s3">= </span><span class="s1">n_ineq</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">enforce_feasibility </span><span class="s3">= </span><span class="s1">enforce_feasibility</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">global_stop_criteria </span><span class="s3">= </span><span class="s1">global_stop_criteria</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">xtol </span><span class="s3">= </span><span class="s1">xtol</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">fun0 </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_compute_function</span><span class="s3">(</span><span class="s1">fun0</span><span class="s3">, </span><span class="s1">constr_ineq0</span><span class="s3">, </span><span class="s1">s0</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">grad0 </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_compute_gradient</span><span class="s3">(</span><span class="s1">grad0</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">constr0 </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_compute_constr</span><span class="s3">(</span><span class="s1">constr_ineq0</span><span class="s3">, </span><span class="s1">constr_eq0</span><span class="s3">, </span><span class="s1">s0</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">jac0 </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_compute_jacobian</span><span class="s3">(</span><span class="s1">jac_eq0</span><span class="s3">, </span><span class="s1">jac_ineq0</span><span class="s3">, </span><span class="s1">s0</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">terminate </span><span class="s3">= </span><span class="s2">False</span>

    <span class="s2">def </span><span class="s1">update</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">barrier_parameter</span><span class="s3">, </span><span class="s1">tolerance</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">barrier_parameter </span><span class="s3">= </span><span class="s1">barrier_parameter</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">tolerance </span><span class="s3">= </span><span class="s1">tolerance</span>

    <span class="s2">def </span><span class="s1">get_slack</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">z</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">z</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_vars</span><span class="s3">:</span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_vars</span><span class="s3">+</span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_ineq</span><span class="s3">]</span>

    <span class="s2">def </span><span class="s1">get_variables</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">z</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">z</span><span class="s3">[:</span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_vars</span><span class="s3">]</span>

    <span class="s2">def </span><span class="s1">function_and_constraints</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">z</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Returns barrier function and constraints at given point. 
 
        For z = [x, s], returns barrier function: 
            function(z) = fun(x) - barrier_parameter*sum(log(s)) 
        and barrier constraints: 
            constraints(z) = [   constr_eq(x)     ] 
                             [ constr_ineq(x) + s ] 
 
        &quot;&quot;&quot;</span>
        <span class="s5"># Get variables and slack variables</span>
        <span class="s1">x </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">get_variables</span><span class="s3">(</span><span class="s1">z</span><span class="s3">)</span>
        <span class="s1">s </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">get_slack</span><span class="s3">(</span><span class="s1">z</span><span class="s3">)</span>
        <span class="s5"># Compute function and constraints</span>
        <span class="s1">f </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">fun</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
        <span class="s1">c_eq</span><span class="s3">, </span><span class="s1">c_ineq </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">constr</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
        <span class="s5"># Return objective function and constraints</span>
        <span class="s2">return </span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_compute_function</span><span class="s3">(</span><span class="s1">f</span><span class="s3">, </span><span class="s1">c_ineq</span><span class="s3">, </span><span class="s1">s</span><span class="s3">),</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">_compute_constr</span><span class="s3">(</span><span class="s1">c_ineq</span><span class="s3">, </span><span class="s1">c_eq</span><span class="s3">, </span><span class="s1">s</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">_compute_function</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">f</span><span class="s3">, </span><span class="s1">c_ineq</span><span class="s3">, </span><span class="s1">s</span><span class="s3">):</span>
        <span class="s5"># Use technique from Nocedal and Wright book, ref [3]_, p.576,</span>
        <span class="s5"># to guarantee constraints from `enforce_feasibility`</span>
        <span class="s5"># stay feasible along iterations.</span>
        <span class="s1">s</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">enforce_feasibility</span><span class="s3">] = -</span><span class="s1">c_ineq</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">enforce_feasibility</span><span class="s3">]</span>
        <span class="s1">log_s </span><span class="s3">= [</span><span class="s1">np</span><span class="s3">.</span><span class="s1">log</span><span class="s3">(</span><span class="s1">s_i</span><span class="s3">) </span><span class="s2">if </span><span class="s1">s_i </span><span class="s3">&gt; </span><span class="s6">0 </span><span class="s2">else </span><span class="s3">-</span><span class="s1">np</span><span class="s3">.</span><span class="s1">inf </span><span class="s2">for </span><span class="s1">s_i </span><span class="s2">in </span><span class="s1">s</span><span class="s3">]</span>
        <span class="s5"># Compute barrier objective function</span>
        <span class="s2">return </span><span class="s1">f </span><span class="s3">- </span><span class="s1">self</span><span class="s3">.</span><span class="s1">barrier_parameter</span><span class="s3">*</span><span class="s1">np</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">(</span><span class="s1">log_s</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_compute_constr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">c_ineq</span><span class="s3">, </span><span class="s1">c_eq</span><span class="s3">, </span><span class="s1">s</span><span class="s3">):</span>
        <span class="s5"># Compute barrier constraint</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">hstack</span><span class="s3">((</span><span class="s1">c_eq</span><span class="s3">,</span>
                          <span class="s1">c_ineq </span><span class="s3">+ </span><span class="s1">s</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">scaling</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">z</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Returns scaling vector. 
        Given by: 
            scaling = [ones(n_vars), s] 
        &quot;&quot;&quot;</span>
        <span class="s1">s </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">get_slack</span><span class="s3">(</span><span class="s1">z</span><span class="s3">)</span>
        <span class="s1">diag_elements </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">hstack</span><span class="s3">((</span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_vars</span><span class="s3">), </span><span class="s1">s</span><span class="s3">))</span>

        <span class="s5"># Diagonal matrix</span>
        <span class="s2">def </span><span class="s1">matvec</span><span class="s3">(</span><span class="s1">vec</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">diag_elements</span><span class="s3">*</span><span class="s1">vec</span>
        <span class="s2">return </span><span class="s1">LinearOperator</span><span class="s3">((</span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_vars</span><span class="s3">+</span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_ineq</span><span class="s3">,</span>
                               <span class="s1">self</span><span class="s3">.</span><span class="s1">n_vars</span><span class="s3">+</span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_ineq</span><span class="s3">),</span>
                              <span class="s1">matvec</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">gradient_and_jacobian</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">z</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Returns scaled gradient. 
 
        Return scaled gradient: 
            gradient = [             grad(x)             ] 
                       [ -barrier_parameter*ones(n_ineq) ] 
        and scaled Jacobian matrix: 
            jacobian = [  jac_eq(x)  0  ] 
                       [ jac_ineq(x) S  ] 
        Both of them scaled by the previously defined scaling factor. 
        &quot;&quot;&quot;</span>
        <span class="s5"># Get variables and slack variables</span>
        <span class="s1">x </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">get_variables</span><span class="s3">(</span><span class="s1">z</span><span class="s3">)</span>
        <span class="s1">s </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">get_slack</span><span class="s3">(</span><span class="s1">z</span><span class="s3">)</span>
        <span class="s5"># Compute first derivatives</span>
        <span class="s1">g </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">grad</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
        <span class="s1">J_eq</span><span class="s3">, </span><span class="s1">J_ineq </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">jac</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
        <span class="s5"># Return gradient and Jacobian</span>
        <span class="s2">return </span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_compute_gradient</span><span class="s3">(</span><span class="s1">g</span><span class="s3">),</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">_compute_jacobian</span><span class="s3">(</span><span class="s1">J_eq</span><span class="s3">, </span><span class="s1">J_ineq</span><span class="s3">, </span><span class="s1">s</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">_compute_gradient</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">g</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">hstack</span><span class="s3">((</span><span class="s1">g</span><span class="s3">, -</span><span class="s1">self</span><span class="s3">.</span><span class="s1">barrier_parameter</span><span class="s3">*</span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_ineq</span><span class="s3">)))</span>

    <span class="s2">def </span><span class="s1">_compute_jacobian</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">J_eq</span><span class="s3">, </span><span class="s1">J_ineq</span><span class="s3">, </span><span class="s1">s</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_ineq </span><span class="s3">== </span><span class="s6">0</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">J_eq</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">sps</span><span class="s3">.</span><span class="s1">issparse</span><span class="s3">(</span><span class="s1">J_eq</span><span class="s3">) </span><span class="s2">or </span><span class="s1">sps</span><span class="s3">.</span><span class="s1">issparse</span><span class="s3">(</span><span class="s1">J_ineq</span><span class="s3">):</span>
                <span class="s5"># It is expected that J_eq and J_ineq</span>
                <span class="s5"># are already `csr_matrix` because of</span>
                <span class="s5"># the way ``BoxConstraint``, ``NonlinearConstraint``</span>
                <span class="s5"># and ``LinearConstraint`` are defined.</span>
                <span class="s1">J_eq </span><span class="s3">= </span><span class="s1">sps</span><span class="s3">.</span><span class="s1">csr_matrix</span><span class="s3">(</span><span class="s1">J_eq</span><span class="s3">)</span>
                <span class="s1">J_ineq </span><span class="s3">= </span><span class="s1">sps</span><span class="s3">.</span><span class="s1">csr_matrix</span><span class="s3">(</span><span class="s1">J_ineq</span><span class="s3">)</span>
                <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_assemble_sparse_jacobian</span><span class="s3">(</span><span class="s1">J_eq</span><span class="s3">, </span><span class="s1">J_ineq</span><span class="s3">, </span><span class="s1">s</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">S </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">diag</span><span class="s3">(</span><span class="s1">s</span><span class="s3">)</span>
                <span class="s1">zeros </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">((</span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_eq</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_ineq</span><span class="s3">))</span>
                <span class="s5"># Convert to matrix</span>
                <span class="s2">if </span><span class="s1">sps</span><span class="s3">.</span><span class="s1">issparse</span><span class="s3">(</span><span class="s1">J_ineq</span><span class="s3">):</span>
                    <span class="s1">J_ineq </span><span class="s3">= </span><span class="s1">J_ineq</span><span class="s3">.</span><span class="s1">toarray</span><span class="s3">()</span>
                <span class="s2">if </span><span class="s1">sps</span><span class="s3">.</span><span class="s1">issparse</span><span class="s3">(</span><span class="s1">J_eq</span><span class="s3">):</span>
                    <span class="s1">J_eq </span><span class="s3">= </span><span class="s1">J_eq</span><span class="s3">.</span><span class="s1">toarray</span><span class="s3">()</span>
                <span class="s5"># Concatenate matrices</span>
                <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">block</span><span class="s3">([[</span><span class="s1">J_eq</span><span class="s3">, </span><span class="s1">zeros</span><span class="s3">],</span>
                                 <span class="s3">[</span><span class="s1">J_ineq</span><span class="s3">, </span><span class="s1">S</span><span class="s3">]])</span>

    <span class="s2">def </span><span class="s1">_assemble_sparse_jacobian</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">J_eq</span><span class="s3">, </span><span class="s1">J_ineq</span><span class="s3">, </span><span class="s1">s</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Assemble sparse Jacobian given its components. 
 
        Given ``J_eq``, ``J_ineq`` and ``s`` returns: 
            jacobian = [ J_eq,     0     ] 
                       [ J_ineq, diag(s) ] 
 
        It is equivalent to: 
            sps.bmat([[ J_eq,   None    ], 
                      [ J_ineq, diag(s) ]], &quot;csr&quot;) 
        but significantly more efficient for this 
        given structure. 
        &quot;&quot;&quot;</span>
        <span class="s1">n_vars</span><span class="s3">, </span><span class="s1">n_ineq</span><span class="s3">, </span><span class="s1">n_eq </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_vars</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_ineq</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_eq</span>
        <span class="s1">J_aux </span><span class="s3">= </span><span class="s1">sps</span><span class="s3">.</span><span class="s1">vstack</span><span class="s3">([</span><span class="s1">J_eq</span><span class="s3">, </span><span class="s1">J_ineq</span><span class="s3">], </span><span class="s4">&quot;csr&quot;</span><span class="s3">)</span>
        <span class="s1">indptr</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">, </span><span class="s1">data </span><span class="s3">= </span><span class="s1">J_aux</span><span class="s3">.</span><span class="s1">indptr</span><span class="s3">, </span><span class="s1">J_aux</span><span class="s3">.</span><span class="s1">indices</span><span class="s3">, </span><span class="s1">J_aux</span><span class="s3">.</span><span class="s1">data</span>
        <span class="s1">new_indptr </span><span class="s3">= </span><span class="s1">indptr </span><span class="s3">+ </span><span class="s1">np</span><span class="s3">.</span><span class="s1">hstack</span><span class="s3">((</span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">n_eq</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">int</span><span class="s3">),</span>
                                         <span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s1">n_ineq</span><span class="s3">+</span><span class="s6">1</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">int</span><span class="s3">)))</span>
        <span class="s1">size </span><span class="s3">= </span><span class="s1">indices</span><span class="s3">.</span><span class="s1">size</span><span class="s3">+</span><span class="s1">n_ineq</span>
        <span class="s1">new_indices </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">size</span><span class="s3">)</span>
        <span class="s1">new_data </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">size</span><span class="s3">)</span>
        <span class="s1">mask </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">full</span><span class="s3">(</span><span class="s1">size</span><span class="s3">, </span><span class="s2">False</span><span class="s3">, </span><span class="s1">bool</span><span class="s3">)</span>
        <span class="s1">mask</span><span class="s3">[</span><span class="s1">new_indptr</span><span class="s3">[-</span><span class="s1">n_ineq</span><span class="s3">:]-</span><span class="s6">1</span><span class="s3">] = </span><span class="s2">True</span>
        <span class="s1">new_indices</span><span class="s3">[</span><span class="s1">mask</span><span class="s3">] = </span><span class="s1">n_vars</span><span class="s3">+</span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s1">n_ineq</span><span class="s3">)</span>
        <span class="s1">new_indices</span><span class="s3">[~</span><span class="s1">mask</span><span class="s3">] = </span><span class="s1">indices</span>
        <span class="s1">new_data</span><span class="s3">[</span><span class="s1">mask</span><span class="s3">] = </span><span class="s1">s</span>
        <span class="s1">new_data</span><span class="s3">[~</span><span class="s1">mask</span><span class="s3">] = </span><span class="s1">data</span>
        <span class="s1">J </span><span class="s3">= </span><span class="s1">sps</span><span class="s3">.</span><span class="s1">csr_matrix</span><span class="s3">((</span><span class="s1">new_data</span><span class="s3">, </span><span class="s1">new_indices</span><span class="s3">, </span><span class="s1">new_indptr</span><span class="s3">),</span>
                           <span class="s3">(</span><span class="s1">n_eq </span><span class="s3">+ </span><span class="s1">n_ineq</span><span class="s3">, </span><span class="s1">n_vars </span><span class="s3">+ </span><span class="s1">n_ineq</span><span class="s3">))</span>
        <span class="s2">return </span><span class="s1">J</span>

    <span class="s2">def </span><span class="s1">lagrangian_hessian_x</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">z</span><span class="s3">, </span><span class="s1">v</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Returns Lagrangian Hessian (in relation to `x`) -&gt; Hx&quot;&quot;&quot;</span>
        <span class="s1">x </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">get_variables</span><span class="s3">(</span><span class="s1">z</span><span class="s3">)</span>
        <span class="s5"># Get lagrange multipliers related to nonlinear equality constraints</span>
        <span class="s1">v_eq </span><span class="s3">= </span><span class="s1">v</span><span class="s3">[:</span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_eq</span><span class="s3">]</span>
        <span class="s5"># Get lagrange multipliers related to nonlinear ineq. constraints</span>
        <span class="s1">v_ineq </span><span class="s3">= </span><span class="s1">v</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_eq</span><span class="s3">:</span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_eq</span><span class="s3">+</span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_ineq</span><span class="s3">]</span>
        <span class="s1">lagr_hess </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">lagr_hess</span>
        <span class="s2">return </span><span class="s1">lagr_hess</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">v_eq</span><span class="s3">, </span><span class="s1">v_ineq</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">lagrangian_hessian_s</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">z</span><span class="s3">, </span><span class="s1">v</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Returns scaled Lagrangian Hessian (in relation to`s`) -&gt; S Hs S&quot;&quot;&quot;</span>
        <span class="s1">s </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">get_slack</span><span class="s3">(</span><span class="s1">z</span><span class="s3">)</span>
        <span class="s5"># Using the primal formulation:</span>
        <span class="s5">#     S Hs S = diag(s)*diag(barrier_parameter/s**2)*diag(s).</span>
        <span class="s5"># Reference [1]_ p. 882, formula (3.1)</span>
        <span class="s1">primal </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">barrier_parameter</span>
        <span class="s5"># Using the primal-dual formulation</span>
        <span class="s5">#     S Hs S = diag(s)*diag(v/s)*diag(s)</span>
        <span class="s5"># Reference [1]_ p. 883, formula (3.11)</span>
        <span class="s1">primal_dual </span><span class="s3">= </span><span class="s1">v</span><span class="s3">[-</span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_ineq</span><span class="s3">:]*</span><span class="s1">s</span>
        <span class="s5"># Uses the primal-dual formulation for</span>
        <span class="s5"># positives values of v_ineq, and primal</span>
        <span class="s5"># formulation for the remaining ones.</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">where</span><span class="s3">(</span><span class="s1">v</span><span class="s3">[-</span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_ineq</span><span class="s3">:] &gt; </span><span class="s6">0</span><span class="s3">, </span><span class="s1">primal_dual</span><span class="s3">, </span><span class="s1">primal</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">lagrangian_hessian</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">z</span><span class="s3">, </span><span class="s1">v</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Returns scaled Lagrangian Hessian&quot;&quot;&quot;</span>
        <span class="s5"># Compute Hessian in relation to x and s</span>
        <span class="s1">Hx </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">lagrangian_hessian_x</span><span class="s3">(</span><span class="s1">z</span><span class="s3">, </span><span class="s1">v</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_ineq </span><span class="s3">&gt; </span><span class="s6">0</span><span class="s3">:</span>
            <span class="s1">S_Hs_S </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">lagrangian_hessian_s</span><span class="s3">(</span><span class="s1">z</span><span class="s3">, </span><span class="s1">v</span><span class="s3">)</span>

        <span class="s5"># The scaled Lagragian Hessian is:</span>
        <span class="s5">#     [ Hx    0    ]</span>
        <span class="s5">#     [ 0   S Hs S ]</span>
        <span class="s2">def </span><span class="s1">matvec</span><span class="s3">(</span><span class="s1">vec</span><span class="s3">):</span>
            <span class="s1">vec_x </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">get_variables</span><span class="s3">(</span><span class="s1">vec</span><span class="s3">)</span>
            <span class="s1">vec_s </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">get_slack</span><span class="s3">(</span><span class="s1">vec</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_ineq </span><span class="s3">&gt; </span><span class="s6">0</span><span class="s3">:</span>
                <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">hstack</span><span class="s3">((</span><span class="s1">Hx</span><span class="s3">.</span><span class="s1">dot</span><span class="s3">(</span><span class="s1">vec_x</span><span class="s3">), </span><span class="s1">S_Hs_S</span><span class="s3">*</span><span class="s1">vec_s</span><span class="s3">))</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s2">return </span><span class="s1">Hx</span><span class="s3">.</span><span class="s1">dot</span><span class="s3">(</span><span class="s1">vec_x</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">LinearOperator</span><span class="s3">((</span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_vars</span><span class="s3">+</span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_ineq</span><span class="s3">,</span>
                               <span class="s1">self</span><span class="s3">.</span><span class="s1">n_vars</span><span class="s3">+</span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_ineq</span><span class="s3">),</span>
                              <span class="s1">matvec</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">stop_criteria</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">state</span><span class="s3">, </span><span class="s1">z</span><span class="s3">, </span><span class="s1">last_iteration_failed</span><span class="s3">,</span>
                      <span class="s1">optimality</span><span class="s3">, </span><span class="s1">constr_violation</span><span class="s3">,</span>
                      <span class="s1">trust_radius</span><span class="s3">, </span><span class="s1">penalty</span><span class="s3">, </span><span class="s1">cg_info</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Stop criteria to the barrier problem. 
        The criteria here proposed is similar to formula (2.3) 
        from [1]_, p.879. 
        &quot;&quot;&quot;</span>
        <span class="s1">x </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">get_variables</span><span class="s3">(</span><span class="s1">z</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">global_stop_criteria</span><span class="s3">(</span><span class="s1">state</span><span class="s3">, </span><span class="s1">x</span><span class="s3">,</span>
                                     <span class="s1">last_iteration_failed</span><span class="s3">,</span>
                                     <span class="s1">trust_radius</span><span class="s3">, </span><span class="s1">penalty</span><span class="s3">,</span>
                                     <span class="s1">cg_info</span><span class="s3">,</span>
                                     <span class="s1">self</span><span class="s3">.</span><span class="s1">barrier_parameter</span><span class="s3">,</span>
                                     <span class="s1">self</span><span class="s3">.</span><span class="s1">tolerance</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">terminate </span><span class="s3">= </span><span class="s2">True</span>
            <span class="s2">return True</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">g_cond </span><span class="s3">= (</span><span class="s1">optimality </span><span class="s3">&lt; </span><span class="s1">self</span><span class="s3">.</span><span class="s1">tolerance </span><span class="s2">and</span>
                      <span class="s1">constr_violation </span><span class="s3">&lt; </span><span class="s1">self</span><span class="s3">.</span><span class="s1">tolerance</span><span class="s3">)</span>
            <span class="s1">x_cond </span><span class="s3">= </span><span class="s1">trust_radius </span><span class="s3">&lt; </span><span class="s1">self</span><span class="s3">.</span><span class="s1">xtol</span>
            <span class="s2">return </span><span class="s1">g_cond </span><span class="s2">or </span><span class="s1">x_cond</span>


<span class="s2">def </span><span class="s1">tr_interior_point</span><span class="s3">(</span><span class="s1">fun</span><span class="s3">, </span><span class="s1">grad</span><span class="s3">, </span><span class="s1">lagr_hess</span><span class="s3">, </span><span class="s1">n_vars</span><span class="s3">, </span><span class="s1">n_ineq</span><span class="s3">, </span><span class="s1">n_eq</span><span class="s3">,</span>
                      <span class="s1">constr</span><span class="s3">, </span><span class="s1">jac</span><span class="s3">, </span><span class="s1">x0</span><span class="s3">, </span><span class="s1">fun0</span><span class="s3">, </span><span class="s1">grad0</span><span class="s3">,</span>
                      <span class="s1">constr_ineq0</span><span class="s3">, </span><span class="s1">jac_ineq0</span><span class="s3">, </span><span class="s1">constr_eq0</span><span class="s3">,</span>
                      <span class="s1">jac_eq0</span><span class="s3">, </span><span class="s1">stop_criteria</span><span class="s3">,</span>
                      <span class="s1">enforce_feasibility</span><span class="s3">, </span><span class="s1">xtol</span><span class="s3">, </span><span class="s1">state</span><span class="s3">,</span>
                      <span class="s1">initial_barrier_parameter</span><span class="s3">,</span>
                      <span class="s1">initial_tolerance</span><span class="s3">,</span>
                      <span class="s1">initial_penalty</span><span class="s3">,</span>
                      <span class="s1">initial_trust_radius</span><span class="s3">,</span>
                      <span class="s1">factorization_method</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Trust-region interior points method. 
 
    Solve problem: 
        minimize fun(x) 
        subject to: constr_ineq(x) &lt;= 0 
                    constr_eq(x) = 0 
    using trust-region interior point method described in [1]_. 
    &quot;&quot;&quot;</span>
    <span class="s5"># BOUNDARY_PARAMETER controls the decrease on the slack</span>
    <span class="s5"># variables. Represents ``tau`` from [1]_ p.885, formula (3.18).</span>
    <span class="s1">BOUNDARY_PARAMETER </span><span class="s3">= </span><span class="s6">0.995</span>
    <span class="s5"># BARRIER_DECAY_RATIO controls the decay of the barrier parameter</span>
    <span class="s5"># and of the subproblem toloerance. Represents ``theta`` from [1]_ p.879.</span>
    <span class="s1">BARRIER_DECAY_RATIO </span><span class="s3">= </span><span class="s6">0.2</span>
    <span class="s5"># TRUST_ENLARGEMENT controls the enlargement on trust radius</span>
    <span class="s5"># after each iteration</span>
    <span class="s1">TRUST_ENLARGEMENT </span><span class="s3">= </span><span class="s6">5</span>

    <span class="s5"># Default enforce_feasibility</span>
    <span class="s2">if </span><span class="s1">enforce_feasibility </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">enforce_feasibility </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">n_ineq</span><span class="s3">, </span><span class="s1">bool</span><span class="s3">)</span>
    <span class="s5"># Initial Values</span>
    <span class="s1">barrier_parameter </span><span class="s3">= </span><span class="s1">initial_barrier_parameter</span>
    <span class="s1">tolerance </span><span class="s3">= </span><span class="s1">initial_tolerance</span>
    <span class="s1">trust_radius </span><span class="s3">= </span><span class="s1">initial_trust_radius</span>
    <span class="s5"># Define initial value for the slack variables</span>
    <span class="s1">s0 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">maximum</span><span class="s3">(-</span><span class="s6">1.5</span><span class="s3">*</span><span class="s1">constr_ineq0</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">n_ineq</span><span class="s3">))</span>
    <span class="s5"># Define barrier subproblem</span>
    <span class="s1">subprob </span><span class="s3">= </span><span class="s1">BarrierSubproblem</span><span class="s3">(</span>
        <span class="s1">x0</span><span class="s3">, </span><span class="s1">s0</span><span class="s3">, </span><span class="s1">fun</span><span class="s3">, </span><span class="s1">grad</span><span class="s3">, </span><span class="s1">lagr_hess</span><span class="s3">, </span><span class="s1">n_vars</span><span class="s3">, </span><span class="s1">n_ineq</span><span class="s3">, </span><span class="s1">n_eq</span><span class="s3">, </span><span class="s1">constr</span><span class="s3">, </span><span class="s1">jac</span><span class="s3">,</span>
        <span class="s1">barrier_parameter</span><span class="s3">, </span><span class="s1">tolerance</span><span class="s3">, </span><span class="s1">enforce_feasibility</span><span class="s3">,</span>
        <span class="s1">stop_criteria</span><span class="s3">, </span><span class="s1">xtol</span><span class="s3">, </span><span class="s1">fun0</span><span class="s3">, </span><span class="s1">grad0</span><span class="s3">, </span><span class="s1">constr_ineq0</span><span class="s3">, </span><span class="s1">jac_ineq0</span><span class="s3">,</span>
        <span class="s1">constr_eq0</span><span class="s3">, </span><span class="s1">jac_eq0</span><span class="s3">)</span>
    <span class="s5"># Define initial parameter for the first iteration.</span>
    <span class="s1">z </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">hstack</span><span class="s3">((</span><span class="s1">x0</span><span class="s3">, </span><span class="s1">s0</span><span class="s3">))</span>
    <span class="s1">fun0_subprob</span><span class="s3">, </span><span class="s1">constr0_subprob </span><span class="s3">= </span><span class="s1">subprob</span><span class="s3">.</span><span class="s1">fun0</span><span class="s3">, </span><span class="s1">subprob</span><span class="s3">.</span><span class="s1">constr0</span>
    <span class="s1">grad0_subprob</span><span class="s3">, </span><span class="s1">jac0_subprob </span><span class="s3">= </span><span class="s1">subprob</span><span class="s3">.</span><span class="s1">grad0</span><span class="s3">, </span><span class="s1">subprob</span><span class="s3">.</span><span class="s1">jac0</span>
    <span class="s5"># Define trust region bounds</span>
    <span class="s1">trust_lb </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">hstack</span><span class="s3">((</span><span class="s1">np</span><span class="s3">.</span><span class="s1">full</span><span class="s3">(</span><span class="s1">subprob</span><span class="s3">.</span><span class="s1">n_vars</span><span class="s3">, -</span><span class="s1">np</span><span class="s3">.</span><span class="s1">inf</span><span class="s3">),</span>
                          <span class="s1">np</span><span class="s3">.</span><span class="s1">full</span><span class="s3">(</span><span class="s1">subprob</span><span class="s3">.</span><span class="s1">n_ineq</span><span class="s3">, -</span><span class="s1">BOUNDARY_PARAMETER</span><span class="s3">)))</span>
    <span class="s1">trust_ub </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">full</span><span class="s3">(</span><span class="s1">subprob</span><span class="s3">.</span><span class="s1">n_vars</span><span class="s3">+</span><span class="s1">subprob</span><span class="s3">.</span><span class="s1">n_ineq</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">inf</span><span class="s3">)</span>

    <span class="s5"># Solves a sequence of barrier problems</span>
    <span class="s2">while True</span><span class="s3">:</span>
        <span class="s5"># Solve SQP subproblem</span>
        <span class="s1">z</span><span class="s3">, </span><span class="s1">state </span><span class="s3">= </span><span class="s1">equality_constrained_sqp</span><span class="s3">(</span>
            <span class="s1">subprob</span><span class="s3">.</span><span class="s1">function_and_constraints</span><span class="s3">,</span>
            <span class="s1">subprob</span><span class="s3">.</span><span class="s1">gradient_and_jacobian</span><span class="s3">,</span>
            <span class="s1">subprob</span><span class="s3">.</span><span class="s1">lagrangian_hessian</span><span class="s3">,</span>
            <span class="s1">z</span><span class="s3">, </span><span class="s1">fun0_subprob</span><span class="s3">, </span><span class="s1">grad0_subprob</span><span class="s3">,</span>
            <span class="s1">constr0_subprob</span><span class="s3">, </span><span class="s1">jac0_subprob</span><span class="s3">, </span><span class="s1">subprob</span><span class="s3">.</span><span class="s1">stop_criteria</span><span class="s3">,</span>
            <span class="s1">state</span><span class="s3">, </span><span class="s1">initial_penalty</span><span class="s3">, </span><span class="s1">trust_radius</span><span class="s3">,</span>
            <span class="s1">factorization_method</span><span class="s3">, </span><span class="s1">trust_lb</span><span class="s3">, </span><span class="s1">trust_ub</span><span class="s3">, </span><span class="s1">subprob</span><span class="s3">.</span><span class="s1">scaling</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">subprob</span><span class="s3">.</span><span class="s1">terminate</span><span class="s3">:</span>
            <span class="s2">break</span>
        <span class="s5"># Update parameters</span>
        <span class="s1">trust_radius </span><span class="s3">= </span><span class="s1">max</span><span class="s3">(</span><span class="s1">initial_trust_radius</span><span class="s3">,</span>
                           <span class="s1">TRUST_ENLARGEMENT</span><span class="s3">*</span><span class="s1">state</span><span class="s3">.</span><span class="s1">tr_radius</span><span class="s3">)</span>
        <span class="s5"># TODO: Use more advanced strategies from [2]_</span>
        <span class="s5"># to update this parameters.</span>
        <span class="s1">barrier_parameter </span><span class="s3">*= </span><span class="s1">BARRIER_DECAY_RATIO</span>
        <span class="s1">tolerance </span><span class="s3">*= </span><span class="s1">BARRIER_DECAY_RATIO</span>
        <span class="s5"># Update Barrier Problem</span>
        <span class="s1">subprob</span><span class="s3">.</span><span class="s1">update</span><span class="s3">(</span><span class="s1">barrier_parameter</span><span class="s3">, </span><span class="s1">tolerance</span><span class="s3">)</span>
        <span class="s5"># Compute initial values for next iteration</span>
        <span class="s1">fun0_subprob</span><span class="s3">, </span><span class="s1">constr0_subprob </span><span class="s3">= </span><span class="s1">subprob</span><span class="s3">.</span><span class="s1">function_and_constraints</span><span class="s3">(</span><span class="s1">z</span><span class="s3">)</span>
        <span class="s1">grad0_subprob</span><span class="s3">, </span><span class="s1">jac0_subprob </span><span class="s3">= </span><span class="s1">subprob</span><span class="s3">.</span><span class="s1">gradient_and_jacobian</span><span class="s3">(</span><span class="s1">z</span><span class="s3">)</span>

    <span class="s5"># Get x and s</span>
    <span class="s1">x </span><span class="s3">= </span><span class="s1">subprob</span><span class="s3">.</span><span class="s1">get_variables</span><span class="s3">(</span><span class="s1">z</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">x</span><span class="s3">, </span><span class="s1">state</span>
</pre>
</body>
</html>