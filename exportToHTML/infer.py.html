<html>
<head>
<title>infer.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #5f826b; font-style: italic;}
.s5 { color: #2aacb8;}
.s6 { color: #6aab73;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
infer.py</font>
</center></td></tr></table>
<pre><span class="s0"># ext/mypy/infer.py</span>
<span class="s0"># Copyright (C) 2021-2024 the SQLAlchemy authors and contributors</span>
<span class="s0"># &lt;see AUTHORS file&gt;</span>
<span class="s0">#</span>
<span class="s0"># This module is part of SQLAlchemy and is released under</span>
<span class="s0"># the MIT License: https://www.opensource.org/licenses/mit-license.php</span>

<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">annotations</span>

<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Optional</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Sequence</span>

<span class="s2">from </span><span class="s1">mypy</span><span class="s3">.</span><span class="s1">maptype </span><span class="s2">import </span><span class="s1">map_instance_to_supertype</span>
<span class="s2">from </span><span class="s1">mypy</span><span class="s3">.</span><span class="s1">nodes </span><span class="s2">import </span><span class="s1">AssignmentStmt</span>
<span class="s2">from </span><span class="s1">mypy</span><span class="s3">.</span><span class="s1">nodes </span><span class="s2">import </span><span class="s1">CallExpr</span>
<span class="s2">from </span><span class="s1">mypy</span><span class="s3">.</span><span class="s1">nodes </span><span class="s2">import </span><span class="s1">Expression</span>
<span class="s2">from </span><span class="s1">mypy</span><span class="s3">.</span><span class="s1">nodes </span><span class="s2">import </span><span class="s1">FuncDef</span>
<span class="s2">from </span><span class="s1">mypy</span><span class="s3">.</span><span class="s1">nodes </span><span class="s2">import </span><span class="s1">LambdaExpr</span>
<span class="s2">from </span><span class="s1">mypy</span><span class="s3">.</span><span class="s1">nodes </span><span class="s2">import </span><span class="s1">MemberExpr</span>
<span class="s2">from </span><span class="s1">mypy</span><span class="s3">.</span><span class="s1">nodes </span><span class="s2">import </span><span class="s1">NameExpr</span>
<span class="s2">from </span><span class="s1">mypy</span><span class="s3">.</span><span class="s1">nodes </span><span class="s2">import </span><span class="s1">RefExpr</span>
<span class="s2">from </span><span class="s1">mypy</span><span class="s3">.</span><span class="s1">nodes </span><span class="s2">import </span><span class="s1">StrExpr</span>
<span class="s2">from </span><span class="s1">mypy</span><span class="s3">.</span><span class="s1">nodes </span><span class="s2">import </span><span class="s1">TypeInfo</span>
<span class="s2">from </span><span class="s1">mypy</span><span class="s3">.</span><span class="s1">nodes </span><span class="s2">import </span><span class="s1">Var</span>
<span class="s2">from </span><span class="s1">mypy</span><span class="s3">.</span><span class="s1">plugin </span><span class="s2">import </span><span class="s1">SemanticAnalyzerPluginInterface</span>
<span class="s2">from </span><span class="s1">mypy</span><span class="s3">.</span><span class="s1">subtypes </span><span class="s2">import </span><span class="s1">is_subtype</span>
<span class="s2">from </span><span class="s1">mypy</span><span class="s3">.</span><span class="s1">types </span><span class="s2">import </span><span class="s1">AnyType</span>
<span class="s2">from </span><span class="s1">mypy</span><span class="s3">.</span><span class="s1">types </span><span class="s2">import </span><span class="s1">CallableType</span>
<span class="s2">from </span><span class="s1">mypy</span><span class="s3">.</span><span class="s1">types </span><span class="s2">import </span><span class="s1">get_proper_type</span>
<span class="s2">from </span><span class="s1">mypy</span><span class="s3">.</span><span class="s1">types </span><span class="s2">import </span><span class="s1">Instance</span>
<span class="s2">from </span><span class="s1">mypy</span><span class="s3">.</span><span class="s1">types </span><span class="s2">import </span><span class="s1">NoneType</span>
<span class="s2">from </span><span class="s1">mypy</span><span class="s3">.</span><span class="s1">types </span><span class="s2">import </span><span class="s1">ProperType</span>
<span class="s2">from </span><span class="s1">mypy</span><span class="s3">.</span><span class="s1">types </span><span class="s2">import </span><span class="s1">TypeOfAny</span>
<span class="s2">from </span><span class="s1">mypy</span><span class="s3">.</span><span class="s1">types </span><span class="s2">import </span><span class="s1">UnionType</span>

<span class="s2">from </span><span class="s3">. </span><span class="s2">import </span><span class="s1">names</span>
<span class="s2">from </span><span class="s3">. </span><span class="s2">import </span><span class="s1">util</span>


<span class="s2">def </span><span class="s1">infer_type_from_right_hand_nameexpr</span><span class="s3">(</span>
    <span class="s1">api</span><span class="s3">: </span><span class="s1">SemanticAnalyzerPluginInterface</span><span class="s3">,</span>
    <span class="s1">stmt</span><span class="s3">: </span><span class="s1">AssignmentStmt</span><span class="s3">,</span>
    <span class="s1">node</span><span class="s3">: </span><span class="s1">Var</span><span class="s3">,</span>
    <span class="s1">left_hand_explicit_type</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">ProperType</span><span class="s3">],</span>
    <span class="s1">infer_from_right_side</span><span class="s3">: </span><span class="s1">RefExpr</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; Optional</span><span class="s3">[</span><span class="s1">ProperType</span><span class="s3">]:</span>
    <span class="s1">type_id </span><span class="s3">= </span><span class="s1">names</span><span class="s3">.</span><span class="s1">type_id_for_callee</span><span class="s3">(</span><span class="s1">infer_from_right_side</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">type_id </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s2">return None</span>
    <span class="s2">elif </span><span class="s1">type_id </span><span class="s2">is </span><span class="s1">names</span><span class="s3">.</span><span class="s1">MAPPED</span><span class="s3">:</span>
        <span class="s1">python_type_for_type </span><span class="s3">= </span><span class="s1">_infer_type_from_mapped</span><span class="s3">(</span>
            <span class="s1">api</span><span class="s3">, </span><span class="s1">stmt</span><span class="s3">, </span><span class="s1">node</span><span class="s3">, </span><span class="s1">left_hand_explicit_type</span><span class="s3">, </span><span class="s1">infer_from_right_side</span>
        <span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">type_id </span><span class="s2">is </span><span class="s1">names</span><span class="s3">.</span><span class="s1">COLUMN</span><span class="s3">:</span>
        <span class="s1">python_type_for_type </span><span class="s3">= </span><span class="s1">_infer_type_from_decl_column</span><span class="s3">(</span>
            <span class="s1">api</span><span class="s3">, </span><span class="s1">stmt</span><span class="s3">, </span><span class="s1">node</span><span class="s3">, </span><span class="s1">left_hand_explicit_type</span>
        <span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">type_id </span><span class="s2">is </span><span class="s1">names</span><span class="s3">.</span><span class="s1">RELATIONSHIP</span><span class="s3">:</span>
        <span class="s1">python_type_for_type </span><span class="s3">= </span><span class="s1">_infer_type_from_relationship</span><span class="s3">(</span>
            <span class="s1">api</span><span class="s3">, </span><span class="s1">stmt</span><span class="s3">, </span><span class="s1">node</span><span class="s3">, </span><span class="s1">left_hand_explicit_type</span>
        <span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">type_id </span><span class="s2">is </span><span class="s1">names</span><span class="s3">.</span><span class="s1">COLUMN_PROPERTY</span><span class="s3">:</span>
        <span class="s1">python_type_for_type </span><span class="s3">= </span><span class="s1">_infer_type_from_decl_column_property</span><span class="s3">(</span>
            <span class="s1">api</span><span class="s3">, </span><span class="s1">stmt</span><span class="s3">, </span><span class="s1">node</span><span class="s3">, </span><span class="s1">left_hand_explicit_type</span>
        <span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">type_id </span><span class="s2">is </span><span class="s1">names</span><span class="s3">.</span><span class="s1">SYNONYM_PROPERTY</span><span class="s3">:</span>
        <span class="s1">python_type_for_type </span><span class="s3">= </span><span class="s1">infer_type_from_left_hand_type_only</span><span class="s3">(</span>
            <span class="s1">api</span><span class="s3">, </span><span class="s1">node</span><span class="s3">, </span><span class="s1">left_hand_explicit_type</span>
        <span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">type_id </span><span class="s2">is </span><span class="s1">names</span><span class="s3">.</span><span class="s1">COMPOSITE_PROPERTY</span><span class="s3">:</span>
        <span class="s1">python_type_for_type </span><span class="s3">= </span><span class="s1">_infer_type_from_decl_composite_property</span><span class="s3">(</span>
            <span class="s1">api</span><span class="s3">, </span><span class="s1">stmt</span><span class="s3">, </span><span class="s1">node</span><span class="s3">, </span><span class="s1">left_hand_explicit_type</span>
        <span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">return None</span>

    <span class="s2">return </span><span class="s1">python_type_for_type</span>


<span class="s2">def </span><span class="s1">_infer_type_from_relationship</span><span class="s3">(</span>
    <span class="s1">api</span><span class="s3">: </span><span class="s1">SemanticAnalyzerPluginInterface</span><span class="s3">,</span>
    <span class="s1">stmt</span><span class="s3">: </span><span class="s1">AssignmentStmt</span><span class="s3">,</span>
    <span class="s1">node</span><span class="s3">: </span><span class="s1">Var</span><span class="s3">,</span>
    <span class="s1">left_hand_explicit_type</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">ProperType</span><span class="s3">],</span>
<span class="s3">) </span><span class="s1">-&gt; Optional</span><span class="s3">[</span><span class="s1">ProperType</span><span class="s3">]:</span>
    <span class="s4">&quot;&quot;&quot;Infer the type of mapping from a relationship. 
 
    E.g.:: 
 
        @reg.mapped 
        class MyClass: 
            # ... 
 
            addresses = relationship(Address, uselist=True) 
 
            order: Mapped[&quot;Order&quot;] = relationship(&quot;Order&quot;) 
 
    Will resolve in mypy as:: 
 
        @reg.mapped 
        class MyClass: 
            # ... 
 
            addresses: Mapped[List[Address]] 
 
            order: Mapped[&quot;Order&quot;] 
 
    &quot;&quot;&quot;</span>

    <span class="s2">assert </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">rvalue</span><span class="s3">, </span><span class="s1">CallExpr</span><span class="s3">)</span>
    <span class="s1">target_cls_arg </span><span class="s3">= </span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">rvalue</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
    <span class="s1">python_type_for_type</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">ProperType</span><span class="s3">] = </span><span class="s2">None</span>

    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">target_cls_arg</span><span class="s3">, </span><span class="s1">NameExpr</span><span class="s3">) </span><span class="s2">and </span><span class="s1">isinstance</span><span class="s3">(</span>
        <span class="s1">target_cls_arg</span><span class="s3">.</span><span class="s1">node</span><span class="s3">, </span><span class="s1">TypeInfo</span>
    <span class="s3">):</span>
        <span class="s0"># type</span>
        <span class="s1">related_object_type </span><span class="s3">= </span><span class="s1">target_cls_arg</span><span class="s3">.</span><span class="s1">node</span>
        <span class="s1">python_type_for_type </span><span class="s3">= </span><span class="s1">Instance</span><span class="s3">(</span><span class="s1">related_object_type</span><span class="s3">, [])</span>

    <span class="s0"># other cases not covered - an error message directs the user</span>
    <span class="s0"># to set an explicit type annotation</span>
    <span class="s0">#</span>
    <span class="s0"># node.type == str, it's a string</span>
    <span class="s0"># if isinstance(target_cls_arg, NameExpr) and isinstance(</span>
    <span class="s0">#     target_cls_arg.node, Var</span>
    <span class="s0"># )</span>
    <span class="s0"># points to a type</span>
    <span class="s0"># isinstance(target_cls_arg, NameExpr) and isinstance(</span>
    <span class="s0">#     target_cls_arg.node, TypeAlias</span>
    <span class="s0"># )</span>
    <span class="s0"># string expression</span>
    <span class="s0"># isinstance(target_cls_arg, StrExpr)</span>

    <span class="s1">uselist_arg </span><span class="s3">= </span><span class="s1">util</span><span class="s3">.</span><span class="s1">get_callexpr_kwarg</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">rvalue</span><span class="s3">, </span><span class="s6">&quot;uselist&quot;</span><span class="s3">)</span>
    <span class="s1">collection_cls_arg</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">Expression</span><span class="s3">] = </span><span class="s1">util</span><span class="s3">.</span><span class="s1">get_callexpr_kwarg</span><span class="s3">(</span>
        <span class="s1">stmt</span><span class="s3">.</span><span class="s1">rvalue</span><span class="s3">, </span><span class="s6">&quot;collection_class&quot;</span>
    <span class="s3">)</span>
    <span class="s1">type_is_a_collection </span><span class="s3">= </span><span class="s2">False</span>

    <span class="s0"># this can be used to determine Optional for a many-to-one</span>
    <span class="s0"># in the same way nullable=False could be used, if we start supporting</span>
    <span class="s0"># that.</span>
    <span class="s0"># innerjoin_arg = util.get_callexpr_kwarg(stmt.rvalue, &quot;innerjoin&quot;)</span>

    <span class="s2">if </span><span class="s3">(</span>
        <span class="s1">uselist_arg </span><span class="s2">is not None</span>
        <span class="s2">and </span><span class="s1">api</span><span class="s3">.</span><span class="s1">parse_bool</span><span class="s3">(</span><span class="s1">uselist_arg</span><span class="s3">) </span><span class="s2">is True</span>
        <span class="s2">and </span><span class="s1">collection_cls_arg </span><span class="s2">is None</span>
    <span class="s3">):</span>
        <span class="s1">type_is_a_collection </span><span class="s3">= </span><span class="s2">True</span>
        <span class="s2">if </span><span class="s1">python_type_for_type </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s1">python_type_for_type </span><span class="s3">= </span><span class="s1">api</span><span class="s3">.</span><span class="s1">named_type</span><span class="s3">(</span>
                <span class="s1">names</span><span class="s3">.</span><span class="s1">NAMED_TYPE_BUILTINS_LIST</span><span class="s3">, [</span><span class="s1">python_type_for_type</span><span class="s3">]</span>
            <span class="s3">)</span>
    <span class="s2">elif </span><span class="s3">(</span>
        <span class="s1">uselist_arg </span><span class="s2">is None or </span><span class="s1">api</span><span class="s3">.</span><span class="s1">parse_bool</span><span class="s3">(</span><span class="s1">uselist_arg</span><span class="s3">) </span><span class="s2">is True</span>
    <span class="s3">) </span><span class="s2">and </span><span class="s1">collection_cls_arg </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s1">type_is_a_collection </span><span class="s3">= </span><span class="s2">True</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">collection_cls_arg</span><span class="s3">, </span><span class="s1">CallExpr</span><span class="s3">):</span>
            <span class="s1">collection_cls_arg </span><span class="s3">= </span><span class="s1">collection_cls_arg</span><span class="s3">.</span><span class="s1">callee</span>

        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">collection_cls_arg</span><span class="s3">, </span><span class="s1">NameExpr</span><span class="s3">) </span><span class="s2">and </span><span class="s1">isinstance</span><span class="s3">(</span>
            <span class="s1">collection_cls_arg</span><span class="s3">.</span><span class="s1">node</span><span class="s3">, </span><span class="s1">TypeInfo</span>
        <span class="s3">):</span>
            <span class="s2">if </span><span class="s1">python_type_for_type </span><span class="s2">is not None</span><span class="s3">:</span>
                <span class="s0"># this can still be overridden by the left hand side</span>
                <span class="s0"># within _infer_Type_from_left_and_inferred_right</span>
                <span class="s1">python_type_for_type </span><span class="s3">= </span><span class="s1">Instance</span><span class="s3">(</span>
                    <span class="s1">collection_cls_arg</span><span class="s3">.</span><span class="s1">node</span><span class="s3">, [</span><span class="s1">python_type_for_type</span><span class="s3">]</span>
                <span class="s3">)</span>
        <span class="s2">elif </span><span class="s3">(</span>
            <span class="s1">isinstance</span><span class="s3">(</span><span class="s1">collection_cls_arg</span><span class="s3">, </span><span class="s1">NameExpr</span><span class="s3">)</span>
            <span class="s2">and </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">collection_cls_arg</span><span class="s3">.</span><span class="s1">node</span><span class="s3">, </span><span class="s1">FuncDef</span><span class="s3">)</span>
            <span class="s2">and </span><span class="s1">collection_cls_arg</span><span class="s3">.</span><span class="s1">node</span><span class="s3">.</span><span class="s1">type </span><span class="s2">is not None</span>
        <span class="s3">):</span>
            <span class="s2">if </span><span class="s1">python_type_for_type </span><span class="s2">is not None</span><span class="s3">:</span>
                <span class="s0"># this can still be overridden by the left hand side</span>
                <span class="s0"># within _infer_Type_from_left_and_inferred_right</span>

                <span class="s0"># TODO: handle mypy.types.Overloaded</span>
                <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">collection_cls_arg</span><span class="s3">.</span><span class="s1">node</span><span class="s3">.</span><span class="s1">type</span><span class="s3">, </span><span class="s1">CallableType</span><span class="s3">):</span>
                    <span class="s1">rt </span><span class="s3">= </span><span class="s1">get_proper_type</span><span class="s3">(</span><span class="s1">collection_cls_arg</span><span class="s3">.</span><span class="s1">node</span><span class="s3">.</span><span class="s1">type</span><span class="s3">.</span><span class="s1">ret_type</span><span class="s3">)</span>

                    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">rt</span><span class="s3">, </span><span class="s1">CallableType</span><span class="s3">):</span>
                        <span class="s1">callable_ret_type </span><span class="s3">= </span><span class="s1">get_proper_type</span><span class="s3">(</span><span class="s1">rt</span><span class="s3">.</span><span class="s1">ret_type</span><span class="s3">)</span>
                        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">callable_ret_type</span><span class="s3">, </span><span class="s1">Instance</span><span class="s3">):</span>
                            <span class="s1">python_type_for_type </span><span class="s3">= </span><span class="s1">Instance</span><span class="s3">(</span>
                                <span class="s1">callable_ret_type</span><span class="s3">.</span><span class="s1">type</span><span class="s3">,</span>
                                <span class="s3">[</span><span class="s1">python_type_for_type</span><span class="s3">],</span>
                            <span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">util</span><span class="s3">.</span><span class="s1">fail</span><span class="s3">(</span>
                <span class="s1">api</span><span class="s3">,</span>
                <span class="s6">&quot;Expected Python collection type for &quot;</span>
                <span class="s6">&quot;collection_class parameter&quot;</span><span class="s3">,</span>
                <span class="s1">stmt</span><span class="s3">.</span><span class="s1">rvalue</span><span class="s3">,</span>
            <span class="s3">)</span>
            <span class="s1">python_type_for_type </span><span class="s3">= </span><span class="s2">None</span>
    <span class="s2">elif </span><span class="s1">uselist_arg </span><span class="s2">is not None and </span><span class="s1">api</span><span class="s3">.</span><span class="s1">parse_bool</span><span class="s3">(</span><span class="s1">uselist_arg</span><span class="s3">) </span><span class="s2">is False</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">collection_cls_arg </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s1">util</span><span class="s3">.</span><span class="s1">fail</span><span class="s3">(</span>
                <span class="s1">api</span><span class="s3">,</span>
                <span class="s6">&quot;Sending uselist=False and collection_class at the same time &quot;</span>
                <span class="s6">&quot;does not make sense&quot;</span><span class="s3">,</span>
                <span class="s1">stmt</span><span class="s3">.</span><span class="s1">rvalue</span><span class="s3">,</span>
            <span class="s3">)</span>
        <span class="s2">if </span><span class="s1">python_type_for_type </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s1">python_type_for_type </span><span class="s3">= </span><span class="s1">UnionType</span><span class="s3">(</span>
                <span class="s3">[</span><span class="s1">python_type_for_type</span><span class="s3">, </span><span class="s1">NoneType</span><span class="s3">()]</span>
            <span class="s3">)</span>

    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">left_hand_explicit_type </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s1">msg </span><span class="s3">= (</span>
                <span class="s6">&quot;Can't infer scalar or collection for ORM mapped expression &quot;</span>
                <span class="s6">&quot;assigned to attribute '{}' if both 'uselist' and &quot;</span>
                <span class="s6">&quot;'collection_class' arguments are absent from the &quot;</span>
                <span class="s6">&quot;relationship(); please specify a &quot;</span>
                <span class="s6">&quot;type annotation on the left hand side.&quot;</span>
            <span class="s3">)</span>
            <span class="s1">util</span><span class="s3">.</span><span class="s1">fail</span><span class="s3">(</span><span class="s1">api</span><span class="s3">, </span><span class="s1">msg</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">name</span><span class="s3">), </span><span class="s1">node</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">python_type_for_type </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">infer_type_from_left_hand_type_only</span><span class="s3">(</span>
            <span class="s1">api</span><span class="s3">, </span><span class="s1">node</span><span class="s3">, </span><span class="s1">left_hand_explicit_type</span>
        <span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">left_hand_explicit_type </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">type_is_a_collection</span><span class="s3">:</span>
            <span class="s2">assert </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">left_hand_explicit_type</span><span class="s3">, </span><span class="s1">Instance</span><span class="s3">)</span>
            <span class="s2">assert </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">python_type_for_type</span><span class="s3">, </span><span class="s1">Instance</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">_infer_collection_type_from_left_and_inferred_right</span><span class="s3">(</span>
                <span class="s1">api</span><span class="s3">, </span><span class="s1">node</span><span class="s3">, </span><span class="s1">left_hand_explicit_type</span><span class="s3">, </span><span class="s1">python_type_for_type</span>
            <span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">_infer_type_from_left_and_inferred_right</span><span class="s3">(</span>
                <span class="s1">api</span><span class="s3">,</span>
                <span class="s1">node</span><span class="s3">,</span>
                <span class="s1">left_hand_explicit_type</span><span class="s3">,</span>
                <span class="s1">python_type_for_type</span><span class="s3">,</span>
            <span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">python_type_for_type</span>


<span class="s2">def </span><span class="s1">_infer_type_from_decl_composite_property</span><span class="s3">(</span>
    <span class="s1">api</span><span class="s3">: </span><span class="s1">SemanticAnalyzerPluginInterface</span><span class="s3">,</span>
    <span class="s1">stmt</span><span class="s3">: </span><span class="s1">AssignmentStmt</span><span class="s3">,</span>
    <span class="s1">node</span><span class="s3">: </span><span class="s1">Var</span><span class="s3">,</span>
    <span class="s1">left_hand_explicit_type</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">ProperType</span><span class="s3">],</span>
<span class="s3">) </span><span class="s1">-&gt; Optional</span><span class="s3">[</span><span class="s1">ProperType</span><span class="s3">]:</span>
    <span class="s4">&quot;&quot;&quot;Infer the type of mapping from a Composite.&quot;&quot;&quot;</span>

    <span class="s2">assert </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">rvalue</span><span class="s3">, </span><span class="s1">CallExpr</span><span class="s3">)</span>
    <span class="s1">target_cls_arg </span><span class="s3">= </span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">rvalue</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
    <span class="s1">python_type_for_type </span><span class="s3">= </span><span class="s2">None</span>

    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">target_cls_arg</span><span class="s3">, </span><span class="s1">NameExpr</span><span class="s3">) </span><span class="s2">and </span><span class="s1">isinstance</span><span class="s3">(</span>
        <span class="s1">target_cls_arg</span><span class="s3">.</span><span class="s1">node</span><span class="s3">, </span><span class="s1">TypeInfo</span>
    <span class="s3">):</span>
        <span class="s1">related_object_type </span><span class="s3">= </span><span class="s1">target_cls_arg</span><span class="s3">.</span><span class="s1">node</span>
        <span class="s1">python_type_for_type </span><span class="s3">= </span><span class="s1">Instance</span><span class="s3">(</span><span class="s1">related_object_type</span><span class="s3">, [])</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">python_type_for_type </span><span class="s3">= </span><span class="s2">None</span>

    <span class="s2">if </span><span class="s1">python_type_for_type </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">infer_type_from_left_hand_type_only</span><span class="s3">(</span>
            <span class="s1">api</span><span class="s3">, </span><span class="s1">node</span><span class="s3">, </span><span class="s1">left_hand_explicit_type</span>
        <span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">left_hand_explicit_type </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">_infer_type_from_left_and_inferred_right</span><span class="s3">(</span>
            <span class="s1">api</span><span class="s3">, </span><span class="s1">node</span><span class="s3">, </span><span class="s1">left_hand_explicit_type</span><span class="s3">, </span><span class="s1">python_type_for_type</span>
        <span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">python_type_for_type</span>


<span class="s2">def </span><span class="s1">_infer_type_from_mapped</span><span class="s3">(</span>
    <span class="s1">api</span><span class="s3">: </span><span class="s1">SemanticAnalyzerPluginInterface</span><span class="s3">,</span>
    <span class="s1">stmt</span><span class="s3">: </span><span class="s1">AssignmentStmt</span><span class="s3">,</span>
    <span class="s1">node</span><span class="s3">: </span><span class="s1">Var</span><span class="s3">,</span>
    <span class="s1">left_hand_explicit_type</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">ProperType</span><span class="s3">],</span>
    <span class="s1">infer_from_right_side</span><span class="s3">: </span><span class="s1">RefExpr</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; Optional</span><span class="s3">[</span><span class="s1">ProperType</span><span class="s3">]:</span>
    <span class="s4">&quot;&quot;&quot;Infer the type of mapping from a right side expression 
    that returns Mapped. 
 
 
    &quot;&quot;&quot;</span>
    <span class="s2">assert </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">rvalue</span><span class="s3">, </span><span class="s1">CallExpr</span><span class="s3">)</span>

    <span class="s0"># (Pdb) print(stmt.rvalue.callee)</span>
    <span class="s0"># NameExpr(query_expression [sqlalchemy.orm._orm_constructors.query_expression])  # noqa: E501</span>
    <span class="s0"># (Pdb) stmt.rvalue.callee.node</span>
    <span class="s0"># &lt;mypy.nodes.FuncDef object at 0x7f8d92fb5940&gt;</span>
    <span class="s0"># (Pdb) stmt.rvalue.callee.node.type</span>
    <span class="s0"># def [_T] (default_expr: sqlalchemy.sql.elements.ColumnElement[_T`-1] =) -&gt; sqlalchemy.orm.base.Mapped[_T`-1]  # noqa: E501</span>
    <span class="s0"># sqlalchemy.orm.base.Mapped[_T`-1]</span>
    <span class="s0"># the_mapped_type = stmt.rvalue.callee.node.type.ret_type</span>

    <span class="s0"># TODO: look at generic ref and either use that,</span>
    <span class="s0"># or reconcile w/ what's present, etc.</span>
    <span class="s1">the_mapped_type </span><span class="s3">= </span><span class="s1">util</span><span class="s3">.</span><span class="s1">type_for_callee</span><span class="s3">(</span><span class="s1">infer_from_right_side</span><span class="s3">)  </span><span class="s0"># noqa</span>

    <span class="s2">return </span><span class="s1">infer_type_from_left_hand_type_only</span><span class="s3">(</span>
        <span class="s1">api</span><span class="s3">, </span><span class="s1">node</span><span class="s3">, </span><span class="s1">left_hand_explicit_type</span>
    <span class="s3">)</span>


<span class="s2">def </span><span class="s1">_infer_type_from_decl_column_property</span><span class="s3">(</span>
    <span class="s1">api</span><span class="s3">: </span><span class="s1">SemanticAnalyzerPluginInterface</span><span class="s3">,</span>
    <span class="s1">stmt</span><span class="s3">: </span><span class="s1">AssignmentStmt</span><span class="s3">,</span>
    <span class="s1">node</span><span class="s3">: </span><span class="s1">Var</span><span class="s3">,</span>
    <span class="s1">left_hand_explicit_type</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">ProperType</span><span class="s3">],</span>
<span class="s3">) </span><span class="s1">-&gt; Optional</span><span class="s3">[</span><span class="s1">ProperType</span><span class="s3">]:</span>
    <span class="s4">&quot;&quot;&quot;Infer the type of mapping from a ColumnProperty. 
 
    This includes mappings against ``column_property()`` as well as the 
    ``deferred()`` function. 
 
    &quot;&quot;&quot;</span>
    <span class="s2">assert </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">rvalue</span><span class="s3">, </span><span class="s1">CallExpr</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">rvalue</span><span class="s3">.</span><span class="s1">args</span><span class="s3">:</span>
        <span class="s1">first_prop_arg </span><span class="s3">= </span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">rvalue</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>

        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">first_prop_arg</span><span class="s3">, </span><span class="s1">CallExpr</span><span class="s3">):</span>
            <span class="s1">type_id </span><span class="s3">= </span><span class="s1">names</span><span class="s3">.</span><span class="s1">type_id_for_callee</span><span class="s3">(</span><span class="s1">first_prop_arg</span><span class="s3">.</span><span class="s1">callee</span><span class="s3">)</span>

            <span class="s0"># look for column_property() / deferred() etc with Column as first</span>
            <span class="s0"># argument</span>
            <span class="s2">if </span><span class="s1">type_id </span><span class="s2">is </span><span class="s1">names</span><span class="s3">.</span><span class="s1">COLUMN</span><span class="s3">:</span>
                <span class="s2">return </span><span class="s1">_infer_type_from_decl_column</span><span class="s3">(</span>
                    <span class="s1">api</span><span class="s3">,</span>
                    <span class="s1">stmt</span><span class="s3">,</span>
                    <span class="s1">node</span><span class="s3">,</span>
                    <span class="s1">left_hand_explicit_type</span><span class="s3">,</span>
                    <span class="s1">right_hand_expression</span><span class="s3">=</span><span class="s1">first_prop_arg</span><span class="s3">,</span>
                <span class="s3">)</span>

    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">rvalue</span><span class="s3">, </span><span class="s1">CallExpr</span><span class="s3">):</span>
        <span class="s1">type_id </span><span class="s3">= </span><span class="s1">names</span><span class="s3">.</span><span class="s1">type_id_for_callee</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">rvalue</span><span class="s3">.</span><span class="s1">callee</span><span class="s3">)</span>
        <span class="s0"># this is probably not strictly necessary as we have to use the left</span>
        <span class="s0"># hand type for query expression in any case.  any other no-arg</span>
        <span class="s0"># column prop objects would go here also</span>
        <span class="s2">if </span><span class="s1">type_id </span><span class="s2">is </span><span class="s1">names</span><span class="s3">.</span><span class="s1">QUERY_EXPRESSION</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">_infer_type_from_decl_column</span><span class="s3">(</span>
                <span class="s1">api</span><span class="s3">,</span>
                <span class="s1">stmt</span><span class="s3">,</span>
                <span class="s1">node</span><span class="s3">,</span>
                <span class="s1">left_hand_explicit_type</span><span class="s3">,</span>
            <span class="s3">)</span>

    <span class="s2">return </span><span class="s1">infer_type_from_left_hand_type_only</span><span class="s3">(</span>
        <span class="s1">api</span><span class="s3">, </span><span class="s1">node</span><span class="s3">, </span><span class="s1">left_hand_explicit_type</span>
    <span class="s3">)</span>


<span class="s2">def </span><span class="s1">_infer_type_from_decl_column</span><span class="s3">(</span>
    <span class="s1">api</span><span class="s3">: </span><span class="s1">SemanticAnalyzerPluginInterface</span><span class="s3">,</span>
    <span class="s1">stmt</span><span class="s3">: </span><span class="s1">AssignmentStmt</span><span class="s3">,</span>
    <span class="s1">node</span><span class="s3">: </span><span class="s1">Var</span><span class="s3">,</span>
    <span class="s1">left_hand_explicit_type</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">ProperType</span><span class="s3">],</span>
    <span class="s1">right_hand_expression</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">CallExpr</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; Optional</span><span class="s3">[</span><span class="s1">ProperType</span><span class="s3">]:</span>
    <span class="s4">&quot;&quot;&quot;Infer the type of mapping from a Column. 
 
    E.g.:: 
 
        @reg.mapped 
        class MyClass: 
            # ... 
 
            a = Column(Integer) 
 
            b = Column(&quot;b&quot;, String) 
 
            c: Mapped[int] = Column(Integer) 
 
            d: bool = Column(Boolean) 
 
    Will resolve in MyPy as:: 
 
        @reg.mapped 
        class MyClass: 
            # ... 
 
            a : Mapped[int] 
 
            b : Mapped[str] 
 
            c: Mapped[int] 
 
            d: Mapped[bool] 
 
    &quot;&quot;&quot;</span>
    <span class="s2">assert </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">node</span><span class="s3">, </span><span class="s1">Var</span><span class="s3">)</span>

    <span class="s1">callee </span><span class="s3">= </span><span class="s2">None</span>

    <span class="s2">if </span><span class="s1">right_hand_expression </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">rvalue</span><span class="s3">, </span><span class="s1">CallExpr</span><span class="s3">):</span>
            <span class="s2">return None</span>

        <span class="s1">right_hand_expression </span><span class="s3">= </span><span class="s1">stmt</span><span class="s3">.</span><span class="s1">rvalue</span>

    <span class="s2">for </span><span class="s1">column_arg </span><span class="s2">in </span><span class="s1">right_hand_expression</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[</span><span class="s5">0</span><span class="s3">:</span><span class="s5">2</span><span class="s3">]:</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">column_arg</span><span class="s3">, </span><span class="s1">CallExpr</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">column_arg</span><span class="s3">.</span><span class="s1">callee</span><span class="s3">, </span><span class="s1">RefExpr</span><span class="s3">):</span>
                <span class="s0"># x = Column(String(50))</span>
                <span class="s1">callee </span><span class="s3">= </span><span class="s1">column_arg</span><span class="s3">.</span><span class="s1">callee</span>
                <span class="s1">type_args</span><span class="s3">: </span><span class="s1">Sequence</span><span class="s3">[</span><span class="s1">Expression</span><span class="s3">] = </span><span class="s1">column_arg</span><span class="s3">.</span><span class="s1">args</span>
                <span class="s2">break</span>
        <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">column_arg</span><span class="s3">, (</span><span class="s1">NameExpr</span><span class="s3">, </span><span class="s1">MemberExpr</span><span class="s3">)):</span>
            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">column_arg</span><span class="s3">.</span><span class="s1">node</span><span class="s3">, </span><span class="s1">TypeInfo</span><span class="s3">):</span>
                <span class="s0"># x = Column(String)</span>
                <span class="s1">callee </span><span class="s3">= </span><span class="s1">column_arg</span>
                <span class="s1">type_args </span><span class="s3">= ()</span>
                <span class="s2">break</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s0"># x = Column(some_name, String), go to next argument</span>
                <span class="s2">continue</span>
        <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">column_arg</span><span class="s3">, (</span><span class="s1">StrExpr</span><span class="s3">,)):</span>
            <span class="s0"># x = Column(&quot;name&quot;, String), go to next argument</span>
            <span class="s2">continue</span>
        <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">column_arg</span><span class="s3">, (</span><span class="s1">LambdaExpr</span><span class="s3">,)):</span>
            <span class="s0"># x = Column(&quot;name&quot;, String, default=lambda: uuid.uuid4())</span>
            <span class="s0"># go to next argument</span>
            <span class="s2">continue</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">assert False</span>

    <span class="s2">if </span><span class="s1">callee </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s2">return None</span>

    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">callee</span><span class="s3">.</span><span class="s1">node</span><span class="s3">, </span><span class="s1">TypeInfo</span><span class="s3">) </span><span class="s2">and </span><span class="s1">names</span><span class="s3">.</span><span class="s1">mro_has_id</span><span class="s3">(</span>
        <span class="s1">callee</span><span class="s3">.</span><span class="s1">node</span><span class="s3">.</span><span class="s1">mro</span><span class="s3">, </span><span class="s1">names</span><span class="s3">.</span><span class="s1">TYPEENGINE</span>
    <span class="s3">):</span>
        <span class="s1">python_type_for_type </span><span class="s3">= </span><span class="s1">extract_python_type_from_typeengine</span><span class="s3">(</span>
            <span class="s1">api</span><span class="s3">, </span><span class="s1">callee</span><span class="s3">.</span><span class="s1">node</span><span class="s3">, </span><span class="s1">type_args</span>
        <span class="s3">)</span>

        <span class="s2">if </span><span class="s1">left_hand_explicit_type </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">_infer_type_from_left_and_inferred_right</span><span class="s3">(</span>
                <span class="s1">api</span><span class="s3">, </span><span class="s1">node</span><span class="s3">, </span><span class="s1">left_hand_explicit_type</span><span class="s3">, </span><span class="s1">python_type_for_type</span>
            <span class="s3">)</span>

        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">UnionType</span><span class="s3">([</span><span class="s1">python_type_for_type</span><span class="s3">, </span><span class="s1">NoneType</span><span class="s3">()])</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s0"># it's not TypeEngine, it's typically implicitly typed</span>
        <span class="s0"># like ForeignKey.  we can't infer from the right side.</span>
        <span class="s2">return </span><span class="s1">infer_type_from_left_hand_type_only</span><span class="s3">(</span>
            <span class="s1">api</span><span class="s3">, </span><span class="s1">node</span><span class="s3">, </span><span class="s1">left_hand_explicit_type</span>
        <span class="s3">)</span>


<span class="s2">def </span><span class="s1">_infer_type_from_left_and_inferred_right</span><span class="s3">(</span>
    <span class="s1">api</span><span class="s3">: </span><span class="s1">SemanticAnalyzerPluginInterface</span><span class="s3">,</span>
    <span class="s1">node</span><span class="s3">: </span><span class="s1">Var</span><span class="s3">,</span>
    <span class="s1">left_hand_explicit_type</span><span class="s3">: </span><span class="s1">ProperType</span><span class="s3">,</span>
    <span class="s1">python_type_for_type</span><span class="s3">: </span><span class="s1">ProperType</span><span class="s3">,</span>
    <span class="s1">orig_left_hand_type</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">ProperType</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">orig_python_type_for_type</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">ProperType</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; Optional</span><span class="s3">[</span><span class="s1">ProperType</span><span class="s3">]:</span>
    <span class="s4">&quot;&quot;&quot;Validate type when a left hand annotation is present and we also 
    could infer the right hand side:: 
 
        attrname: SomeType = Column(SomeDBType) 
 
    &quot;&quot;&quot;</span>

    <span class="s2">if </span><span class="s1">orig_left_hand_type </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">orig_left_hand_type </span><span class="s3">= </span><span class="s1">left_hand_explicit_type</span>
    <span class="s2">if </span><span class="s1">orig_python_type_for_type </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">orig_python_type_for_type </span><span class="s3">= </span><span class="s1">python_type_for_type</span>

    <span class="s2">if not </span><span class="s1">is_subtype</span><span class="s3">(</span><span class="s1">left_hand_explicit_type</span><span class="s3">, </span><span class="s1">python_type_for_type</span><span class="s3">):</span>
        <span class="s1">effective_type </span><span class="s3">= </span><span class="s1">api</span><span class="s3">.</span><span class="s1">named_type</span><span class="s3">(</span>
            <span class="s1">names</span><span class="s3">.</span><span class="s1">NAMED_TYPE_SQLA_MAPPED</span><span class="s3">, [</span><span class="s1">orig_python_type_for_type</span><span class="s3">]</span>
        <span class="s3">)</span>

        <span class="s1">msg </span><span class="s3">= (</span>
            <span class="s6">&quot;Left hand assignment '{}: {}' not compatible &quot;</span>
            <span class="s6">&quot;with ORM mapped expression of type {}&quot;</span>
        <span class="s3">)</span>
        <span class="s1">util</span><span class="s3">.</span><span class="s1">fail</span><span class="s3">(</span>
            <span class="s1">api</span><span class="s3">,</span>
            <span class="s1">msg</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span>
                <span class="s1">node</span><span class="s3">.</span><span class="s1">name</span><span class="s3">,</span>
                <span class="s1">util</span><span class="s3">.</span><span class="s1">format_type</span><span class="s3">(</span><span class="s1">orig_left_hand_type</span><span class="s3">, </span><span class="s1">api</span><span class="s3">.</span><span class="s1">options</span><span class="s3">),</span>
                <span class="s1">util</span><span class="s3">.</span><span class="s1">format_type</span><span class="s3">(</span><span class="s1">effective_type</span><span class="s3">, </span><span class="s1">api</span><span class="s3">.</span><span class="s1">options</span><span class="s3">),</span>
            <span class="s3">),</span>
            <span class="s1">node</span><span class="s3">,</span>
        <span class="s3">)</span>

    <span class="s2">return </span><span class="s1">orig_left_hand_type</span>


<span class="s2">def </span><span class="s1">_infer_collection_type_from_left_and_inferred_right</span><span class="s3">(</span>
    <span class="s1">api</span><span class="s3">: </span><span class="s1">SemanticAnalyzerPluginInterface</span><span class="s3">,</span>
    <span class="s1">node</span><span class="s3">: </span><span class="s1">Var</span><span class="s3">,</span>
    <span class="s1">left_hand_explicit_type</span><span class="s3">: </span><span class="s1">Instance</span><span class="s3">,</span>
    <span class="s1">python_type_for_type</span><span class="s3">: </span><span class="s1">Instance</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; Optional</span><span class="s3">[</span><span class="s1">ProperType</span><span class="s3">]:</span>
    <span class="s1">orig_left_hand_type </span><span class="s3">= </span><span class="s1">left_hand_explicit_type</span>
    <span class="s1">orig_python_type_for_type </span><span class="s3">= </span><span class="s1">python_type_for_type</span>

    <span class="s2">if </span><span class="s1">left_hand_explicit_type</span><span class="s3">.</span><span class="s1">args</span><span class="s3">:</span>
        <span class="s1">left_hand_arg </span><span class="s3">= </span><span class="s1">get_proper_type</span><span class="s3">(</span><span class="s1">left_hand_explicit_type</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[</span><span class="s5">0</span><span class="s3">])</span>
        <span class="s1">python_type_arg </span><span class="s3">= </span><span class="s1">get_proper_type</span><span class="s3">(</span><span class="s1">python_type_for_type</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[</span><span class="s5">0</span><span class="s3">])</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">left_hand_arg </span><span class="s3">= </span><span class="s1">left_hand_explicit_type</span>
        <span class="s1">python_type_arg </span><span class="s3">= </span><span class="s1">python_type_for_type</span>

    <span class="s2">assert </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">left_hand_arg</span><span class="s3">, (</span><span class="s1">Instance</span><span class="s3">, </span><span class="s1">UnionType</span><span class="s3">))</span>
    <span class="s2">assert </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">python_type_arg</span><span class="s3">, (</span><span class="s1">Instance</span><span class="s3">, </span><span class="s1">UnionType</span><span class="s3">))</span>

    <span class="s2">return </span><span class="s1">_infer_type_from_left_and_inferred_right</span><span class="s3">(</span>
        <span class="s1">api</span><span class="s3">,</span>
        <span class="s1">node</span><span class="s3">,</span>
        <span class="s1">left_hand_arg</span><span class="s3">,</span>
        <span class="s1">python_type_arg</span><span class="s3">,</span>
        <span class="s1">orig_left_hand_type</span><span class="s3">=</span><span class="s1">orig_left_hand_type</span><span class="s3">,</span>
        <span class="s1">orig_python_type_for_type</span><span class="s3">=</span><span class="s1">orig_python_type_for_type</span><span class="s3">,</span>
    <span class="s3">)</span>


<span class="s2">def </span><span class="s1">infer_type_from_left_hand_type_only</span><span class="s3">(</span>
    <span class="s1">api</span><span class="s3">: </span><span class="s1">SemanticAnalyzerPluginInterface</span><span class="s3">,</span>
    <span class="s1">node</span><span class="s3">: </span><span class="s1">Var</span><span class="s3">,</span>
    <span class="s1">left_hand_explicit_type</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">ProperType</span><span class="s3">],</span>
<span class="s3">) </span><span class="s1">-&gt; Optional</span><span class="s3">[</span><span class="s1">ProperType</span><span class="s3">]:</span>
    <span class="s4">&quot;&quot;&quot;Determine the type based on explicit annotation only. 
 
    if no annotation were present, note that we need one there to know 
    the type. 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">left_hand_explicit_type </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">msg </span><span class="s3">= (</span>
            <span class="s6">&quot;Can't infer type from ORM mapped expression &quot;</span>
            <span class="s6">&quot;assigned to attribute '{}'; please specify a &quot;</span>
            <span class="s6">&quot;Python type or &quot;</span>
            <span class="s6">&quot;Mapped[&lt;python type&gt;] on the left hand side.&quot;</span>
        <span class="s3">)</span>
        <span class="s1">util</span><span class="s3">.</span><span class="s1">fail</span><span class="s3">(</span><span class="s1">api</span><span class="s3">, </span><span class="s1">msg</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">node</span><span class="s3">.</span><span class="s1">name</span><span class="s3">), </span><span class="s1">node</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">api</span><span class="s3">.</span><span class="s1">named_type</span><span class="s3">(</span>
            <span class="s1">names</span><span class="s3">.</span><span class="s1">NAMED_TYPE_SQLA_MAPPED</span><span class="s3">, [</span><span class="s1">AnyType</span><span class="s3">(</span><span class="s1">TypeOfAny</span><span class="s3">.</span><span class="s1">special_form</span><span class="s3">)]</span>
        <span class="s3">)</span>

    <span class="s2">else</span><span class="s3">:</span>
        <span class="s0"># use type from the left hand side</span>
        <span class="s2">return </span><span class="s1">left_hand_explicit_type</span>


<span class="s2">def </span><span class="s1">extract_python_type_from_typeengine</span><span class="s3">(</span>
    <span class="s1">api</span><span class="s3">: </span><span class="s1">SemanticAnalyzerPluginInterface</span><span class="s3">,</span>
    <span class="s1">node</span><span class="s3">: </span><span class="s1">TypeInfo</span><span class="s3">,</span>
    <span class="s1">type_args</span><span class="s3">: </span><span class="s1">Sequence</span><span class="s3">[</span><span class="s1">Expression</span><span class="s3">],</span>
<span class="s3">) </span><span class="s1">-&gt; ProperType</span><span class="s3">:</span>
    <span class="s2">if </span><span class="s1">node</span><span class="s3">.</span><span class="s1">fullname </span><span class="s3">== </span><span class="s6">&quot;sqlalchemy.sql.sqltypes.Enum&quot; </span><span class="s2">and </span><span class="s1">type_args</span><span class="s3">:</span>
        <span class="s1">first_arg </span><span class="s3">= </span><span class="s1">type_args</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">first_arg</span><span class="s3">, </span><span class="s1">RefExpr</span><span class="s3">) </span><span class="s2">and </span><span class="s1">isinstance</span><span class="s3">(</span>
            <span class="s1">first_arg</span><span class="s3">.</span><span class="s1">node</span><span class="s3">, </span><span class="s1">TypeInfo</span>
        <span class="s3">):</span>
            <span class="s2">for </span><span class="s1">base_ </span><span class="s2">in </span><span class="s1">first_arg</span><span class="s3">.</span><span class="s1">node</span><span class="s3">.</span><span class="s1">mro</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">base_</span><span class="s3">.</span><span class="s1">fullname </span><span class="s3">== </span><span class="s6">&quot;enum.Enum&quot;</span><span class="s3">:</span>
                    <span class="s2">return </span><span class="s1">Instance</span><span class="s3">(</span><span class="s1">first_arg</span><span class="s3">.</span><span class="s1">node</span><span class="s3">, [])</span>
            <span class="s0"># TODO: support other pep-435 types here</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">api</span><span class="s3">.</span><span class="s1">named_type</span><span class="s3">(</span><span class="s1">names</span><span class="s3">.</span><span class="s1">NAMED_TYPE_BUILTINS_STR</span><span class="s3">, [])</span>

    <span class="s2">assert </span><span class="s1">node</span><span class="s3">.</span><span class="s1">has_base</span><span class="s3">(</span><span class="s6">&quot;sqlalchemy.sql.type_api.TypeEngine&quot;</span><span class="s3">), (</span>
        <span class="s6">&quot;could not extract Python type from node: %s&quot; </span><span class="s3">% </span><span class="s1">node</span>
    <span class="s3">)</span>

    <span class="s1">type_engine_sym </span><span class="s3">= </span><span class="s1">api</span><span class="s3">.</span><span class="s1">lookup_fully_qualified_or_none</span><span class="s3">(</span>
        <span class="s6">&quot;sqlalchemy.sql.type_api.TypeEngine&quot;</span>
    <span class="s3">)</span>

    <span class="s2">assert </span><span class="s1">type_engine_sym </span><span class="s2">is not None and </span><span class="s1">isinstance</span><span class="s3">(</span>
        <span class="s1">type_engine_sym</span><span class="s3">.</span><span class="s1">node</span><span class="s3">, </span><span class="s1">TypeInfo</span>
    <span class="s3">)</span>
    <span class="s1">type_engine </span><span class="s3">= </span><span class="s1">map_instance_to_supertype</span><span class="s3">(</span>
        <span class="s1">Instance</span><span class="s3">(</span><span class="s1">node</span><span class="s3">, []),</span>
        <span class="s1">type_engine_sym</span><span class="s3">.</span><span class="s1">node</span><span class="s3">,</span>
    <span class="s3">)</span>
    <span class="s2">return </span><span class="s1">get_proper_type</span><span class="s3">(</span><span class="s1">type_engine</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">])</span>
</pre>
</body>
</html>