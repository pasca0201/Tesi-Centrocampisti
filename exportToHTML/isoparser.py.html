<html>
<head>
<title>isoparser.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #5f826b; font-style: italic;}
.s3 { color: #cf8e6d;}
.s4 { color: #bcbec4;}
.s5 { color: #6aab73;}
.s6 { color: #2aacb8;}
.s7 { color: #a5c261;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
isoparser.py</font>
</center></td></tr></table>
<pre><span class="s0"># -*- coding: utf-8 -*-</span>
<span class="s2">&quot;&quot;&quot; 
This module offers a parser for ISO-8601 strings 
 
It is intended to support all valid date, time and datetime formats per the 
ISO-8601 specification. 
 
..versionadded:: 2.7.0 
&quot;&quot;&quot;</span>
<span class="s3">from </span><span class="s1">datetime </span><span class="s3">import </span><span class="s1">datetime</span><span class="s4">, </span><span class="s1">timedelta</span><span class="s4">, </span><span class="s1">time</span><span class="s4">, </span><span class="s1">date</span>
<span class="s3">import </span><span class="s1">calendar</span>
<span class="s3">from </span><span class="s1">dateutil </span><span class="s3">import </span><span class="s1">tz</span>

<span class="s3">from </span><span class="s1">functools </span><span class="s3">import </span><span class="s1">wraps</span>

<span class="s3">import </span><span class="s1">re</span>
<span class="s3">import </span><span class="s1">six</span>

<span class="s1">__all__ </span><span class="s4">= [</span><span class="s5">&quot;isoparse&quot;</span><span class="s4">, </span><span class="s5">&quot;isoparser&quot;</span><span class="s4">]</span>


<span class="s3">def </span><span class="s1">_takes_ascii</span><span class="s4">(</span><span class="s1">f</span><span class="s4">):</span>
    <span class="s4">@</span><span class="s1">wraps</span><span class="s4">(</span><span class="s1">f</span><span class="s4">)</span>
    <span class="s3">def </span><span class="s1">func</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">str_in</span><span class="s4">, *</span><span class="s1">args</span><span class="s4">, **</span><span class="s1">kwargs</span><span class="s4">):</span>
        <span class="s0"># If it's a stream, read the whole thing</span>
        <span class="s1">str_in </span><span class="s4">= </span><span class="s1">getattr</span><span class="s4">(</span><span class="s1">str_in</span><span class="s4">, </span><span class="s5">'read'</span><span class="s4">, </span><span class="s3">lambda</span><span class="s4">: </span><span class="s1">str_in</span><span class="s4">)()</span>

        <span class="s0"># If it's unicode, turn it into bytes, since ISO-8601 only covers ASCII</span>
        <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">str_in</span><span class="s4">, </span><span class="s1">six</span><span class="s4">.</span><span class="s1">text_type</span><span class="s4">):</span>
            <span class="s0"># ASCII is the same in UTF-8</span>
            <span class="s3">try</span><span class="s4">:</span>
                <span class="s1">str_in </span><span class="s4">= </span><span class="s1">str_in</span><span class="s4">.</span><span class="s1">encode</span><span class="s4">(</span><span class="s5">'ascii'</span><span class="s4">)</span>
            <span class="s3">except </span><span class="s1">UnicodeEncodeError </span><span class="s3">as </span><span class="s1">e</span><span class="s4">:</span>
                <span class="s1">msg </span><span class="s4">= </span><span class="s5">'ISO-8601 strings should contain only ASCII characters'</span>
                <span class="s1">six</span><span class="s4">.</span><span class="s1">raise_from</span><span class="s4">(</span><span class="s1">ValueError</span><span class="s4">(</span><span class="s1">msg</span><span class="s4">), </span><span class="s1">e</span><span class="s4">)</span>

        <span class="s3">return </span><span class="s1">f</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">str_in</span><span class="s4">, *</span><span class="s1">args</span><span class="s4">, **</span><span class="s1">kwargs</span><span class="s4">)</span>

    <span class="s3">return </span><span class="s1">func</span>


<span class="s3">class </span><span class="s1">isoparser</span><span class="s4">(</span><span class="s1">object</span><span class="s4">):</span>
    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">sep</span><span class="s4">=</span><span class="s3">None</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot; 
        :param sep: 
            A single character that separates date and time portions. If 
            ``None``, the parser will accept any single character. 
            For strict ISO-8601 adherence, pass ``'T'``. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">sep </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s4">(</span><span class="s1">len</span><span class="s4">(</span><span class="s1">sep</span><span class="s4">) != </span><span class="s6">1 </span><span class="s3">or </span><span class="s1">ord</span><span class="s4">(</span><span class="s1">sep</span><span class="s4">) &gt;= </span><span class="s6">128 </span><span class="s3">or </span><span class="s1">sep </span><span class="s3">in </span><span class="s5">'0123456789'</span><span class="s4">):</span>
                <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">'Separator must be a single, non-numeric ' </span><span class="s4">+</span>
                                 <span class="s5">'ASCII character'</span><span class="s4">)</span>

            <span class="s1">sep </span><span class="s4">= </span><span class="s1">sep</span><span class="s4">.</span><span class="s1">encode</span><span class="s4">(</span><span class="s5">'ascii'</span><span class="s4">)</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">_sep </span><span class="s4">= </span><span class="s1">sep</span>

    <span class="s4">@</span><span class="s1">_takes_ascii</span>
    <span class="s3">def </span><span class="s1">isoparse</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">dt_str</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Parse an ISO-8601 datetime string into a :class:`datetime.datetime`. 
 
        An ISO-8601 datetime string consists of a date portion, followed 
        optionally by a time portion - the date and time portions are separated 
        by a single character separator, which is ``T`` in the official 
        standard. Incomplete date formats (such as ``YYYY-MM``) may *not* be 
        combined with a time portion. 
 
        Supported date formats are: 
 
        Common: 
 
        - ``YYYY`` 
        - ``YYYY-MM`` 
        - ``YYYY-MM-DD`` or ``YYYYMMDD`` 
 
        Uncommon: 
 
        - ``YYYY-Www`` or ``YYYYWww`` - ISO week (day defaults to 0) 
        - ``YYYY-Www-D`` or ``YYYYWwwD`` - ISO week and day 
 
        The ISO week and day numbering follows the same logic as 
        :func:`datetime.date.isocalendar`. 
 
        Supported time formats are: 
 
        - ``hh`` 
        - ``hh:mm`` or ``hhmm`` 
        - ``hh:mm:ss`` or ``hhmmss`` 
        - ``hh:mm:ss.ssssss`` (Up to 6 sub-second digits) 
 
        Midnight is a special case for `hh`, as the standard supports both 
        00:00 and 24:00 as a representation. The decimal separator can be 
        either a dot or a comma. 
 
 
        .. caution:: 
 
            Support for fractional components other than seconds is part of the 
            ISO-8601 standard, but is not currently implemented in this parser. 
 
        Supported time zone offset formats are: 
 
        - `Z` (UTC) 
        - `±HH:MM` 
        - `±HHMM` 
        - `±HH` 
 
        Offsets will be represented as :class:`dateutil.tz.tzoffset` objects, 
        with the exception of UTC, which will be represented as 
        :class:`dateutil.tz.tzutc`. Time zone offsets equivalent to UTC (such 
        as `+00:00`) will also be represented as :class:`dateutil.tz.tzutc`. 
 
        :param dt_str: 
            A string or stream containing only an ISO-8601 datetime string 
 
        :return: 
            Returns a :class:`datetime.datetime` representing the string. 
            Unspecified components default to their lowest value. 
 
        .. warning:: 
 
            As of version 2.7.0, the strictness of the parser should not be 
            considered a stable part of the contract. Any valid ISO-8601 string 
            that parses correctly with the default settings will continue to 
            parse correctly in future versions, but invalid strings that 
            currently fail (e.g. ``2017-01-01T00:00+00:00:00``) are not 
            guaranteed to continue failing in future versions if they encode 
            a valid date. 
 
        .. versionadded:: 2.7.0 
        &quot;&quot;&quot;</span>
        <span class="s1">components</span><span class="s4">, </span><span class="s1">pos </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_parse_isodate</span><span class="s4">(</span><span class="s1">dt_str</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">dt_str</span><span class="s4">) &gt; </span><span class="s1">pos</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_sep </span><span class="s3">is None or </span><span class="s1">dt_str</span><span class="s4">[</span><span class="s1">pos</span><span class="s4">:</span><span class="s1">pos </span><span class="s4">+ </span><span class="s6">1</span><span class="s4">] == </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_sep</span><span class="s4">:</span>
                <span class="s1">components </span><span class="s4">+= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_parse_isotime</span><span class="s4">(</span><span class="s1">dt_str</span><span class="s4">[</span><span class="s1">pos </span><span class="s4">+ </span><span class="s6">1</span><span class="s4">:])</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">'String contains unknown ISO components'</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">components</span><span class="s4">) &gt; </span><span class="s6">3 </span><span class="s3">and </span><span class="s1">components</span><span class="s4">[</span><span class="s6">3</span><span class="s4">] == </span><span class="s6">24</span><span class="s4">:</span>
            <span class="s1">components</span><span class="s4">[</span><span class="s6">3</span><span class="s4">] = </span><span class="s6">0</span>
            <span class="s3">return </span><span class="s1">datetime</span><span class="s4">(*</span><span class="s1">components</span><span class="s4">) + </span><span class="s1">timedelta</span><span class="s4">(</span><span class="s1">days</span><span class="s4">=</span><span class="s6">1</span><span class="s4">)</span>

        <span class="s3">return </span><span class="s1">datetime</span><span class="s4">(*</span><span class="s1">components</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">_takes_ascii</span>
    <span class="s3">def </span><span class="s1">parse_isodate</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">datestr</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Parse the date portion of an ISO string. 
 
        :param datestr: 
            The string portion of an ISO string, without a separator 
 
        :return: 
            Returns a :class:`datetime.date` object 
        &quot;&quot;&quot;</span>
        <span class="s1">components</span><span class="s4">, </span><span class="s1">pos </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_parse_isodate</span><span class="s4">(</span><span class="s1">datestr</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">pos </span><span class="s4">&lt; </span><span class="s1">len</span><span class="s4">(</span><span class="s1">datestr</span><span class="s4">):</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">'String contains unknown ISO ' </span><span class="s4">+</span>
                             <span class="s5">'components: {!r}'</span><span class="s4">.</span><span class="s1">format</span><span class="s4">(</span><span class="s1">datestr</span><span class="s4">.</span><span class="s1">decode</span><span class="s4">(</span><span class="s5">'ascii'</span><span class="s4">)))</span>
        <span class="s3">return </span><span class="s1">date</span><span class="s4">(*</span><span class="s1">components</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">_takes_ascii</span>
    <span class="s3">def </span><span class="s1">parse_isotime</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">timestr</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Parse the time portion of an ISO string. 
 
        :param timestr: 
            The time portion of an ISO string, without a separator 
 
        :return: 
            Returns a :class:`datetime.time` object 
        &quot;&quot;&quot;</span>
        <span class="s1">components </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_parse_isotime</span><span class="s4">(</span><span class="s1">timestr</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">components</span><span class="s4">[</span><span class="s6">0</span><span class="s4">] == </span><span class="s6">24</span><span class="s4">:</span>
            <span class="s1">components</span><span class="s4">[</span><span class="s6">0</span><span class="s4">] = </span><span class="s6">0</span>
        <span class="s3">return </span><span class="s1">time</span><span class="s4">(*</span><span class="s1">components</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">_takes_ascii</span>
    <span class="s3">def </span><span class="s1">parse_tzstr</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">tzstr</span><span class="s4">, </span><span class="s1">zero_as_utc</span><span class="s4">=</span><span class="s3">True</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Parse a valid ISO time zone string. 
 
        See :func:`isoparser.isoparse` for details on supported formats. 
 
        :param tzstr: 
            A string representing an ISO time zone offset 
 
        :param zero_as_utc: 
            Whether to return :class:`dateutil.tz.tzutc` for zero-offset zones 
 
        :return: 
            Returns :class:`dateutil.tz.tzoffset` for offsets and 
            :class:`dateutil.tz.tzutc` for ``Z`` and (if ``zero_as_utc`` is 
            specified) offsets equivalent to UTC. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_parse_tzstr</span><span class="s4">(</span><span class="s1">tzstr</span><span class="s4">, </span><span class="s1">zero_as_utc</span><span class="s4">=</span><span class="s1">zero_as_utc</span><span class="s4">)</span>

    <span class="s0"># Constants</span>
    <span class="s1">_DATE_SEP </span><span class="s4">= </span><span class="s7">b'-'</span>
    <span class="s1">_TIME_SEP </span><span class="s4">= </span><span class="s7">b':'</span>
    <span class="s1">_FRACTION_REGEX </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span><span class="s7">b'[</span><span class="s3">\\</span><span class="s7">.,]([0-9]+)'</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_parse_isodate</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">dt_str</span><span class="s4">):</span>
        <span class="s3">try</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_parse_isodate_common</span><span class="s4">(</span><span class="s1">dt_str</span><span class="s4">)</span>
        <span class="s3">except </span><span class="s1">ValueError</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_parse_isodate_uncommon</span><span class="s4">(</span><span class="s1">dt_str</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_parse_isodate_common</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">dt_str</span><span class="s4">):</span>
        <span class="s1">len_str </span><span class="s4">= </span><span class="s1">len</span><span class="s4">(</span><span class="s1">dt_str</span><span class="s4">)</span>
        <span class="s1">components </span><span class="s4">= [</span><span class="s6">1</span><span class="s4">, </span><span class="s6">1</span><span class="s4">, </span><span class="s6">1</span><span class="s4">]</span>

        <span class="s3">if </span><span class="s1">len_str </span><span class="s4">&lt; </span><span class="s6">4</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">'ISO string too short'</span><span class="s4">)</span>

        <span class="s0"># Year</span>
        <span class="s1">components</span><span class="s4">[</span><span class="s6">0</span><span class="s4">] = </span><span class="s1">int</span><span class="s4">(</span><span class="s1">dt_str</span><span class="s4">[</span><span class="s6">0</span><span class="s4">:</span><span class="s6">4</span><span class="s4">])</span>
        <span class="s1">pos </span><span class="s4">= </span><span class="s6">4</span>
        <span class="s3">if </span><span class="s1">pos </span><span class="s4">&gt;= </span><span class="s1">len_str</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">components</span><span class="s4">, </span><span class="s1">pos</span>

        <span class="s1">has_sep </span><span class="s4">= </span><span class="s1">dt_str</span><span class="s4">[</span><span class="s1">pos</span><span class="s4">:</span><span class="s1">pos </span><span class="s4">+ </span><span class="s6">1</span><span class="s4">] == </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_DATE_SEP</span>
        <span class="s3">if </span><span class="s1">has_sep</span><span class="s4">:</span>
            <span class="s1">pos </span><span class="s4">+= </span><span class="s6">1</span>

        <span class="s0"># Month</span>
        <span class="s3">if </span><span class="s1">len_str </span><span class="s4">- </span><span class="s1">pos </span><span class="s4">&lt; </span><span class="s6">2</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">'Invalid common month'</span><span class="s4">)</span>

        <span class="s1">components</span><span class="s4">[</span><span class="s6">1</span><span class="s4">] = </span><span class="s1">int</span><span class="s4">(</span><span class="s1">dt_str</span><span class="s4">[</span><span class="s1">pos</span><span class="s4">:</span><span class="s1">pos </span><span class="s4">+ </span><span class="s6">2</span><span class="s4">])</span>
        <span class="s1">pos </span><span class="s4">+= </span><span class="s6">2</span>

        <span class="s3">if </span><span class="s1">pos </span><span class="s4">&gt;= </span><span class="s1">len_str</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">has_sep</span><span class="s4">:</span>
                <span class="s3">return </span><span class="s1">components</span><span class="s4">, </span><span class="s1">pos</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">'Invalid ISO format'</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s1">has_sep</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">dt_str</span><span class="s4">[</span><span class="s1">pos</span><span class="s4">:</span><span class="s1">pos </span><span class="s4">+ </span><span class="s6">1</span><span class="s4">] != </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_DATE_SEP</span><span class="s4">:</span>
                <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">'Invalid separator in ISO string'</span><span class="s4">)</span>
            <span class="s1">pos </span><span class="s4">+= </span><span class="s6">1</span>

        <span class="s0"># Day</span>
        <span class="s3">if </span><span class="s1">len_str </span><span class="s4">- </span><span class="s1">pos </span><span class="s4">&lt; </span><span class="s6">2</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">'Invalid common day'</span><span class="s4">)</span>
        <span class="s1">components</span><span class="s4">[</span><span class="s6">2</span><span class="s4">] = </span><span class="s1">int</span><span class="s4">(</span><span class="s1">dt_str</span><span class="s4">[</span><span class="s1">pos</span><span class="s4">:</span><span class="s1">pos </span><span class="s4">+ </span><span class="s6">2</span><span class="s4">])</span>
        <span class="s3">return </span><span class="s1">components</span><span class="s4">, </span><span class="s1">pos </span><span class="s4">+ </span><span class="s6">2</span>

    <span class="s3">def </span><span class="s1">_parse_isodate_uncommon</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">dt_str</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">dt_str</span><span class="s4">) &lt; </span><span class="s6">4</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">'ISO string too short'</span><span class="s4">)</span>

        <span class="s0"># All ISO formats start with the year</span>
        <span class="s1">year </span><span class="s4">= </span><span class="s1">int</span><span class="s4">(</span><span class="s1">dt_str</span><span class="s4">[</span><span class="s6">0</span><span class="s4">:</span><span class="s6">4</span><span class="s4">])</span>

        <span class="s1">has_sep </span><span class="s4">= </span><span class="s1">dt_str</span><span class="s4">[</span><span class="s6">4</span><span class="s4">:</span><span class="s6">5</span><span class="s4">] == </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_DATE_SEP</span>

        <span class="s1">pos </span><span class="s4">= </span><span class="s6">4 </span><span class="s4">+ </span><span class="s1">has_sep       </span><span class="s0"># Skip '-' if it's there</span>
        <span class="s3">if </span><span class="s1">dt_str</span><span class="s4">[</span><span class="s1">pos</span><span class="s4">:</span><span class="s1">pos </span><span class="s4">+ </span><span class="s6">1</span><span class="s4">] == </span><span class="s7">b'W'</span><span class="s4">:</span>
            <span class="s0"># YYYY-?Www-?D?</span>
            <span class="s1">pos </span><span class="s4">+= </span><span class="s6">1</span>
            <span class="s1">weekno </span><span class="s4">= </span><span class="s1">int</span><span class="s4">(</span><span class="s1">dt_str</span><span class="s4">[</span><span class="s1">pos</span><span class="s4">:</span><span class="s1">pos </span><span class="s4">+ </span><span class="s6">2</span><span class="s4">])</span>
            <span class="s1">pos </span><span class="s4">+= </span><span class="s6">2</span>

            <span class="s1">dayno </span><span class="s4">= </span><span class="s6">1</span>
            <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">dt_str</span><span class="s4">) &gt; </span><span class="s1">pos</span><span class="s4">:</span>
                <span class="s3">if </span><span class="s4">(</span><span class="s1">dt_str</span><span class="s4">[</span><span class="s1">pos</span><span class="s4">:</span><span class="s1">pos </span><span class="s4">+ </span><span class="s6">1</span><span class="s4">] == </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_DATE_SEP</span><span class="s4">) != </span><span class="s1">has_sep</span><span class="s4">:</span>
                    <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">'Inconsistent use of dash separator'</span><span class="s4">)</span>

                <span class="s1">pos </span><span class="s4">+= </span><span class="s1">has_sep</span>

                <span class="s1">dayno </span><span class="s4">= </span><span class="s1">int</span><span class="s4">(</span><span class="s1">dt_str</span><span class="s4">[</span><span class="s1">pos</span><span class="s4">:</span><span class="s1">pos </span><span class="s4">+ </span><span class="s6">1</span><span class="s4">])</span>
                <span class="s1">pos </span><span class="s4">+= </span><span class="s6">1</span>

            <span class="s1">base_date </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_calculate_weekdate</span><span class="s4">(</span><span class="s1">year</span><span class="s4">, </span><span class="s1">weekno</span><span class="s4">, </span><span class="s1">dayno</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s0"># YYYYDDD or YYYY-DDD</span>
            <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">dt_str</span><span class="s4">) - </span><span class="s1">pos </span><span class="s4">&lt; </span><span class="s6">3</span><span class="s4">:</span>
                <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">'Invalid ordinal day'</span><span class="s4">)</span>

            <span class="s1">ordinal_day </span><span class="s4">= </span><span class="s1">int</span><span class="s4">(</span><span class="s1">dt_str</span><span class="s4">[</span><span class="s1">pos</span><span class="s4">:</span><span class="s1">pos </span><span class="s4">+ </span><span class="s6">3</span><span class="s4">])</span>
            <span class="s1">pos </span><span class="s4">+= </span><span class="s6">3</span>

            <span class="s3">if </span><span class="s1">ordinal_day </span><span class="s4">&lt; </span><span class="s6">1 </span><span class="s3">or </span><span class="s1">ordinal_day </span><span class="s4">&gt; (</span><span class="s6">365 </span><span class="s4">+ </span><span class="s1">calendar</span><span class="s4">.</span><span class="s1">isleap</span><span class="s4">(</span><span class="s1">year</span><span class="s4">)):</span>
                <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">'Invalid ordinal day' </span><span class="s4">+</span>
                                 <span class="s5">' {} for year {}'</span><span class="s4">.</span><span class="s1">format</span><span class="s4">(</span><span class="s1">ordinal_day</span><span class="s4">, </span><span class="s1">year</span><span class="s4">))</span>

            <span class="s1">base_date </span><span class="s4">= </span><span class="s1">date</span><span class="s4">(</span><span class="s1">year</span><span class="s4">, </span><span class="s6">1</span><span class="s4">, </span><span class="s6">1</span><span class="s4">) + </span><span class="s1">timedelta</span><span class="s4">(</span><span class="s1">days</span><span class="s4">=</span><span class="s1">ordinal_day </span><span class="s4">- </span><span class="s6">1</span><span class="s4">)</span>

        <span class="s1">components </span><span class="s4">= [</span><span class="s1">base_date</span><span class="s4">.</span><span class="s1">year</span><span class="s4">, </span><span class="s1">base_date</span><span class="s4">.</span><span class="s1">month</span><span class="s4">, </span><span class="s1">base_date</span><span class="s4">.</span><span class="s1">day</span><span class="s4">]</span>
        <span class="s3">return </span><span class="s1">components</span><span class="s4">, </span><span class="s1">pos</span>

    <span class="s3">def </span><span class="s1">_calculate_weekdate</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">year</span><span class="s4">, </span><span class="s1">week</span><span class="s4">, </span><span class="s1">day</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Calculate the day of corresponding to the ISO year-week-day calendar. 
 
        This function is effectively the inverse of 
        :func:`datetime.date.isocalendar`. 
 
        :param year: 
            The year in the ISO calendar 
 
        :param week: 
            The week in the ISO calendar - range is [1, 53] 
 
        :param day: 
            The day in the ISO calendar - range is [1 (MON), 7 (SUN)] 
 
        :return: 
            Returns a :class:`datetime.date` 
        &quot;&quot;&quot;</span>
        <span class="s3">if not </span><span class="s6">0 </span><span class="s4">&lt; </span><span class="s1">week </span><span class="s4">&lt; </span><span class="s6">54</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">'Invalid week: {}'</span><span class="s4">.</span><span class="s1">format</span><span class="s4">(</span><span class="s1">week</span><span class="s4">))</span>

        <span class="s3">if not </span><span class="s6">0 </span><span class="s4">&lt; </span><span class="s1">day </span><span class="s4">&lt; </span><span class="s6">8</span><span class="s4">:     </span><span class="s0"># Range is 1-7</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">'Invalid weekday: {}'</span><span class="s4">.</span><span class="s1">format</span><span class="s4">(</span><span class="s1">day</span><span class="s4">))</span>

        <span class="s0"># Get week 1 for the specific year:</span>
        <span class="s1">jan_4 </span><span class="s4">= </span><span class="s1">date</span><span class="s4">(</span><span class="s1">year</span><span class="s4">, </span><span class="s6">1</span><span class="s4">, </span><span class="s6">4</span><span class="s4">)   </span><span class="s0"># Week 1 always has January 4th in it</span>
        <span class="s1">week_1 </span><span class="s4">= </span><span class="s1">jan_4 </span><span class="s4">- </span><span class="s1">timedelta</span><span class="s4">(</span><span class="s1">days</span><span class="s4">=</span><span class="s1">jan_4</span><span class="s4">.</span><span class="s1">isocalendar</span><span class="s4">()[</span><span class="s6">2</span><span class="s4">] - </span><span class="s6">1</span><span class="s4">)</span>

        <span class="s0"># Now add the specific number of weeks and days to get what we want</span>
        <span class="s1">week_offset </span><span class="s4">= (</span><span class="s1">week </span><span class="s4">- </span><span class="s6">1</span><span class="s4">) * </span><span class="s6">7 </span><span class="s4">+ (</span><span class="s1">day </span><span class="s4">- </span><span class="s6">1</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">week_1 </span><span class="s4">+ </span><span class="s1">timedelta</span><span class="s4">(</span><span class="s1">days</span><span class="s4">=</span><span class="s1">week_offset</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_parse_isotime</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">timestr</span><span class="s4">):</span>
        <span class="s1">len_str </span><span class="s4">= </span><span class="s1">len</span><span class="s4">(</span><span class="s1">timestr</span><span class="s4">)</span>
        <span class="s1">components </span><span class="s4">= [</span><span class="s6">0</span><span class="s4">, </span><span class="s6">0</span><span class="s4">, </span><span class="s6">0</span><span class="s4">, </span><span class="s6">0</span><span class="s4">, </span><span class="s3">None</span><span class="s4">]</span>
        <span class="s1">pos </span><span class="s4">= </span><span class="s6">0</span>
        <span class="s1">comp </span><span class="s4">= -</span><span class="s6">1</span>

        <span class="s3">if </span><span class="s1">len_str </span><span class="s4">&lt; </span><span class="s6">2</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">'ISO time too short'</span><span class="s4">)</span>

        <span class="s1">has_sep </span><span class="s4">= </span><span class="s3">False</span>

        <span class="s3">while </span><span class="s1">pos </span><span class="s4">&lt; </span><span class="s1">len_str </span><span class="s3">and </span><span class="s1">comp </span><span class="s4">&lt; </span><span class="s6">5</span><span class="s4">:</span>
            <span class="s1">comp </span><span class="s4">+= </span><span class="s6">1</span>

            <span class="s3">if </span><span class="s1">timestr</span><span class="s4">[</span><span class="s1">pos</span><span class="s4">:</span><span class="s1">pos </span><span class="s4">+ </span><span class="s6">1</span><span class="s4">] </span><span class="s3">in </span><span class="s7">b'-+Zz'</span><span class="s4">:</span>
                <span class="s0"># Detect time zone boundary</span>
                <span class="s1">components</span><span class="s4">[-</span><span class="s6">1</span><span class="s4">] = </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_parse_tzstr</span><span class="s4">(</span><span class="s1">timestr</span><span class="s4">[</span><span class="s1">pos</span><span class="s4">:])</span>
                <span class="s1">pos </span><span class="s4">= </span><span class="s1">len_str</span>
                <span class="s3">break</span>

            <span class="s3">if </span><span class="s1">comp </span><span class="s4">== </span><span class="s6">1 </span><span class="s3">and </span><span class="s1">timestr</span><span class="s4">[</span><span class="s1">pos</span><span class="s4">:</span><span class="s1">pos</span><span class="s4">+</span><span class="s6">1</span><span class="s4">] == </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_TIME_SEP</span><span class="s4">:</span>
                <span class="s1">has_sep </span><span class="s4">= </span><span class="s3">True</span>
                <span class="s1">pos </span><span class="s4">+= </span><span class="s6">1</span>
            <span class="s3">elif </span><span class="s1">comp </span><span class="s4">== </span><span class="s6">2 </span><span class="s3">and </span><span class="s1">has_sep</span><span class="s4">:</span>
                <span class="s3">if </span><span class="s1">timestr</span><span class="s4">[</span><span class="s1">pos</span><span class="s4">:</span><span class="s1">pos</span><span class="s4">+</span><span class="s6">1</span><span class="s4">] != </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_TIME_SEP</span><span class="s4">:</span>
                    <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">'Inconsistent use of colon separator'</span><span class="s4">)</span>
                <span class="s1">pos </span><span class="s4">+= </span><span class="s6">1</span>

            <span class="s3">if </span><span class="s1">comp </span><span class="s4">&lt; </span><span class="s6">3</span><span class="s4">:</span>
                <span class="s0"># Hour, minute, second</span>
                <span class="s1">components</span><span class="s4">[</span><span class="s1">comp</span><span class="s4">] = </span><span class="s1">int</span><span class="s4">(</span><span class="s1">timestr</span><span class="s4">[</span><span class="s1">pos</span><span class="s4">:</span><span class="s1">pos </span><span class="s4">+ </span><span class="s6">2</span><span class="s4">])</span>
                <span class="s1">pos </span><span class="s4">+= </span><span class="s6">2</span>

            <span class="s3">if </span><span class="s1">comp </span><span class="s4">== </span><span class="s6">3</span><span class="s4">:</span>
                <span class="s0"># Fraction of a second</span>
                <span class="s1">frac </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_FRACTION_REGEX</span><span class="s4">.</span><span class="s1">match</span><span class="s4">(</span><span class="s1">timestr</span><span class="s4">[</span><span class="s1">pos</span><span class="s4">:])</span>
                <span class="s3">if not </span><span class="s1">frac</span><span class="s4">:</span>
                    <span class="s3">continue</span>

                <span class="s1">us_str </span><span class="s4">= </span><span class="s1">frac</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">1</span><span class="s4">)[:</span><span class="s6">6</span><span class="s4">]  </span><span class="s0"># Truncate to microseconds</span>
                <span class="s1">components</span><span class="s4">[</span><span class="s1">comp</span><span class="s4">] = </span><span class="s1">int</span><span class="s4">(</span><span class="s1">us_str</span><span class="s4">) * </span><span class="s6">10</span><span class="s4">**(</span><span class="s6">6 </span><span class="s4">- </span><span class="s1">len</span><span class="s4">(</span><span class="s1">us_str</span><span class="s4">))</span>
                <span class="s1">pos </span><span class="s4">+= </span><span class="s1">len</span><span class="s4">(</span><span class="s1">frac</span><span class="s4">.</span><span class="s1">group</span><span class="s4">())</span>

        <span class="s3">if </span><span class="s1">pos </span><span class="s4">&lt; </span><span class="s1">len_str</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">'Unused components in ISO string'</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s1">components</span><span class="s4">[</span><span class="s6">0</span><span class="s4">] == </span><span class="s6">24</span><span class="s4">:</span>
            <span class="s0"># Standard supports 00:00 and 24:00 as representations of midnight</span>
            <span class="s3">if </span><span class="s1">any</span><span class="s4">(</span><span class="s1">component </span><span class="s4">!= </span><span class="s6">0 </span><span class="s3">for </span><span class="s1">component </span><span class="s3">in </span><span class="s1">components</span><span class="s4">[</span><span class="s6">1</span><span class="s4">:</span><span class="s6">4</span><span class="s4">]):</span>
                <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">'Hour may only be 24 at 24:00:00.000'</span><span class="s4">)</span>

        <span class="s3">return </span><span class="s1">components</span>

    <span class="s3">def </span><span class="s1">_parse_tzstr</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">tzstr</span><span class="s4">, </span><span class="s1">zero_as_utc</span><span class="s4">=</span><span class="s3">True</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">tzstr </span><span class="s4">== </span><span class="s7">b'Z' </span><span class="s3">or </span><span class="s1">tzstr </span><span class="s4">== </span><span class="s7">b'z'</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">tz</span><span class="s4">.</span><span class="s1">UTC</span>

        <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">tzstr</span><span class="s4">) </span><span class="s3">not in </span><span class="s4">{</span><span class="s6">3</span><span class="s4">, </span><span class="s6">5</span><span class="s4">, </span><span class="s6">6</span><span class="s4">}:</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">'Time zone offset must be 1, 3, 5 or 6 characters'</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s1">tzstr</span><span class="s4">[</span><span class="s6">0</span><span class="s4">:</span><span class="s6">1</span><span class="s4">] == </span><span class="s7">b'-'</span><span class="s4">:</span>
            <span class="s1">mult </span><span class="s4">= -</span><span class="s6">1</span>
        <span class="s3">elif </span><span class="s1">tzstr</span><span class="s4">[</span><span class="s6">0</span><span class="s4">:</span><span class="s6">1</span><span class="s4">] == </span><span class="s7">b'+'</span><span class="s4">:</span>
            <span class="s1">mult </span><span class="s4">= </span><span class="s6">1</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">'Time zone offset requires sign'</span><span class="s4">)</span>

        <span class="s1">hours </span><span class="s4">= </span><span class="s1">int</span><span class="s4">(</span><span class="s1">tzstr</span><span class="s4">[</span><span class="s6">1</span><span class="s4">:</span><span class="s6">3</span><span class="s4">])</span>
        <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">tzstr</span><span class="s4">) == </span><span class="s6">3</span><span class="s4">:</span>
            <span class="s1">minutes </span><span class="s4">= </span><span class="s6">0</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">minutes </span><span class="s4">= </span><span class="s1">int</span><span class="s4">(</span><span class="s1">tzstr</span><span class="s4">[(</span><span class="s6">4 </span><span class="s3">if </span><span class="s1">tzstr</span><span class="s4">[</span><span class="s6">3</span><span class="s4">:</span><span class="s6">4</span><span class="s4">] == </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_TIME_SEP </span><span class="s3">else </span><span class="s6">3</span><span class="s4">):])</span>

        <span class="s3">if </span><span class="s1">zero_as_utc </span><span class="s3">and </span><span class="s1">hours </span><span class="s4">== </span><span class="s6">0 </span><span class="s3">and </span><span class="s1">minutes </span><span class="s4">== </span><span class="s6">0</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">tz</span><span class="s4">.</span><span class="s1">UTC</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">minutes </span><span class="s4">&gt; </span><span class="s6">59</span><span class="s4">:</span>
                <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">'Invalid minutes in time zone offset'</span><span class="s4">)</span>

            <span class="s3">if </span><span class="s1">hours </span><span class="s4">&gt; </span><span class="s6">23</span><span class="s4">:</span>
                <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">'Invalid hours in time zone offset'</span><span class="s4">)</span>

            <span class="s3">return </span><span class="s1">tz</span><span class="s4">.</span><span class="s1">tzoffset</span><span class="s4">(</span><span class="s3">None</span><span class="s4">, </span><span class="s1">mult </span><span class="s4">* (</span><span class="s1">hours </span><span class="s4">* </span><span class="s6">60 </span><span class="s4">+ </span><span class="s1">minutes</span><span class="s4">) * </span><span class="s6">60</span><span class="s4">)</span>


<span class="s1">DEFAULT_ISOPARSER </span><span class="s4">= </span><span class="s1">isoparser</span><span class="s4">()</span>
<span class="s1">isoparse </span><span class="s4">= </span><span class="s1">DEFAULT_ISOPARSER</span><span class="s4">.</span><span class="s1">isoparse</span>
</pre>
</body>
</html>