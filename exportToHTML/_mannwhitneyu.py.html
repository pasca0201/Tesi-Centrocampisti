<html>
<head>
<title>_mannwhitneyu.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #5f826b; font-style: italic;}
.s4 { color: #2aacb8;}
.s5 { color: #7a7e85;}
.s6 { color: #6aab73;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_mannwhitneyu.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">from </span><span class="s1">collections </span><span class="s0">import </span><span class="s1">namedtuple</span>
<span class="s0">from </span><span class="s1">scipy </span><span class="s0">import </span><span class="s1">special</span>
<span class="s0">from </span><span class="s1">scipy </span><span class="s0">import </span><span class="s1">stats</span>
<span class="s0">from </span><span class="s1">scipy</span><span class="s2">.</span><span class="s1">stats</span><span class="s2">.</span><span class="s1">_stats_py </span><span class="s0">import </span><span class="s1">_rankdata</span>
<span class="s0">from </span><span class="s2">.</span><span class="s1">_axis_nan_policy </span><span class="s0">import </span><span class="s1">_axis_nan_policy_factory</span>


<span class="s0">def </span><span class="s1">_broadcast_concatenate</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">):</span>
    <span class="s3">'''Broadcast then concatenate arrays, leaving concatenation axis last'''</span>
    <span class="s1">x </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">moveaxis</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, -</span><span class="s4">1</span><span class="s2">)</span>
    <span class="s1">y </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">moveaxis</span><span class="s2">(</span><span class="s1">y</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, -</span><span class="s4">1</span><span class="s2">)</span>
    <span class="s1">z </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">broadcast</span><span class="s2">(</span><span class="s1">x</span><span class="s2">[..., </span><span class="s4">0</span><span class="s2">], </span><span class="s1">y</span><span class="s2">[..., </span><span class="s4">0</span><span class="s2">])</span>
    <span class="s1">x </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">broadcast_to</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">z</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">+ (</span><span class="s1">x</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[-</span><span class="s4">1</span><span class="s2">],))</span>
    <span class="s1">y </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">broadcast_to</span><span class="s2">(</span><span class="s1">y</span><span class="s2">, </span><span class="s1">z</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">+ (</span><span class="s1">y</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[-</span><span class="s4">1</span><span class="s2">],))</span>
    <span class="s1">z </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">concatenate</span><span class="s2">((</span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">), </span><span class="s1">axis</span><span class="s2">=-</span><span class="s4">1</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">z</span>


<span class="s0">class </span><span class="s1">_MWU</span><span class="s2">:</span>
    <span class="s3">'''Distribution of MWU statistic under the null hypothesis'''</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">n1</span><span class="s2">, </span><span class="s1">n2</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_reset</span><span class="s2">(</span><span class="s1">n1</span><span class="s2">, </span><span class="s1">n2</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">set_shapes</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">n1</span><span class="s2">, </span><span class="s1">n2</span><span class="s2">):</span>
        <span class="s1">n1</span><span class="s2">, </span><span class="s1">n2 </span><span class="s2">= </span><span class="s1">min</span><span class="s2">(</span><span class="s1">n1</span><span class="s2">, </span><span class="s1">n2</span><span class="s2">), </span><span class="s1">max</span><span class="s2">(</span><span class="s1">n1</span><span class="s2">, </span><span class="s1">n2</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s2">(</span><span class="s1">n1</span><span class="s2">, </span><span class="s1">n2</span><span class="s2">) == (</span><span class="s1">self</span><span class="s2">.</span><span class="s1">n1</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">n2</span><span class="s2">):</span>
            <span class="s0">return</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">n1 </span><span class="s2">= </span><span class="s1">n1</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">n2 </span><span class="s2">= </span><span class="s1">n2</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">s_array </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">int</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">configurations </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">uint64</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">reset</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_reset</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">n1</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">n2</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_reset</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">n1</span><span class="s2">, </span><span class="s1">n2</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">n1 </span><span class="s2">= </span><span class="s0">None</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">n2 </span><span class="s2">= </span><span class="s0">None</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">set_shapes</span><span class="s2">(</span><span class="s1">n1</span><span class="s2">, </span><span class="s1">n2</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">pmf</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">k</span><span class="s2">):</span>

        <span class="s5"># In practice, `pmf` is never called with k &gt; m*n/2.</span>
        <span class="s5"># If it were, we'd exploit symmetry here:</span>
        <span class="s5"># k = np.array(k, copy=True)</span>
        <span class="s5"># k2 = m*n - k</span>
        <span class="s5"># i = k2 &lt; k</span>
        <span class="s5"># k[i] = k2[i]</span>

        <span class="s1">pmfs </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">build_u_freqs_array</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">max</span><span class="s2">(</span><span class="s1">k</span><span class="s2">))</span>
        <span class="s0">return </span><span class="s1">pmfs</span><span class="s2">[</span><span class="s1">k</span><span class="s2">]</span>

    <span class="s0">def </span><span class="s1">cdf</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">k</span><span class="s2">):</span>
        <span class="s3">'''Cumulative distribution function'''</span>

        <span class="s5"># In practice, `cdf` is never called with k &gt; m*n/2.</span>
        <span class="s5"># If it were, we'd exploit symmetry here rather than in `sf`</span>
        <span class="s1">pmfs </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">build_u_freqs_array</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">max</span><span class="s2">(</span><span class="s1">k</span><span class="s2">))</span>
        <span class="s1">cdfs </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">cumsum</span><span class="s2">(</span><span class="s1">pmfs</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">cdfs</span><span class="s2">[</span><span class="s1">k</span><span class="s2">]</span>

    <span class="s0">def </span><span class="s1">sf</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">k</span><span class="s2">):</span>
        <span class="s3">'''Survival function'''</span>
        <span class="s5"># Note that both CDF and SF include the PMF at k. The p-value is</span>
        <span class="s5"># calculated from the SF and should include the mass at k, so this</span>
        <span class="s5"># is desirable</span>

        <span class="s5"># Use the fact that the distribution is symmetric and sum from the left</span>
        <span class="s1">kc </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">n1</span><span class="s2">*</span><span class="s1">self</span><span class="s2">.</span><span class="s1">n2 </span><span class="s2">- </span><span class="s1">k</span><span class="s2">)  </span><span class="s5"># complement of k</span>
        <span class="s1">i </span><span class="s2">= </span><span class="s1">k </span><span class="s2">&lt; </span><span class="s1">kc</span>
        <span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">any</span><span class="s2">(</span><span class="s1">i</span><span class="s2">):</span>
            <span class="s1">kc</span><span class="s2">[</span><span class="s1">i</span><span class="s2">] = </span><span class="s1">k</span><span class="s2">[</span><span class="s1">i</span><span class="s2">]</span>
            <span class="s1">cdfs </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">cdf</span><span class="s2">(</span><span class="s1">kc</span><span class="s2">))</span>
            <span class="s1">cdfs</span><span class="s2">[</span><span class="s1">i</span><span class="s2">] = </span><span class="s4">1. </span><span class="s2">- </span><span class="s1">cdfs</span><span class="s2">[</span><span class="s1">i</span><span class="s2">] + </span><span class="s1">self</span><span class="s2">.</span><span class="s1">pmf</span><span class="s2">(</span><span class="s1">kc</span><span class="s2">[</span><span class="s1">i</span><span class="s2">])</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">cdfs </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">cdf</span><span class="s2">(</span><span class="s1">kc</span><span class="s2">))</span>
        <span class="s0">return </span><span class="s1">cdfs</span><span class="s2">[()]</span>

    <span class="s5"># build_sigma_array and build_u_freqs_array adapted from code</span>
    <span class="s5"># by @toobaz with permission. Thanks to @andreasloe for the suggestion.</span>
    <span class="s5"># See https://github.com/scipy/scipy/pull/4933#issuecomment-1898082691</span>
    <span class="s0">def </span><span class="s1">build_sigma_array</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">a</span><span class="s2">):</span>
        <span class="s1">n1</span><span class="s2">, </span><span class="s1">n2 </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">n1</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">n2</span>
        <span class="s0">if </span><span class="s1">a </span><span class="s2">+ </span><span class="s4">1 </span><span class="s2">&lt;= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">s_array</span><span class="s2">.</span><span class="s1">size</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">s_array</span><span class="s2">[</span><span class="s4">1</span><span class="s2">:</span><span class="s1">a</span><span class="s2">+</span><span class="s4">1</span><span class="s2">]</span>

        <span class="s1">s_array </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">(</span><span class="s1">a </span><span class="s2">+ </span><span class="s4">1</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">int</span><span class="s2">)</span>

        <span class="s0">for </span><span class="s1">d </span><span class="s0">in </span><span class="s1">np</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">n1 </span><span class="s2">+ </span><span class="s4">1</span><span class="s2">):</span>
            <span class="s5"># All multiples of d, except 0:</span>
            <span class="s1">indices </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(</span><span class="s1">d</span><span class="s2">, </span><span class="s1">a </span><span class="s2">+ </span><span class="s4">1</span><span class="s2">, </span><span class="s1">d</span><span class="s2">)</span>
            <span class="s5"># \epsilon_d = 1:</span>
            <span class="s1">s_array</span><span class="s2">[</span><span class="s1">indices</span><span class="s2">] += </span><span class="s1">d</span>

        <span class="s0">for </span><span class="s1">d </span><span class="s0">in </span><span class="s1">np</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(</span><span class="s1">n2 </span><span class="s2">+ </span><span class="s4">1</span><span class="s2">, </span><span class="s1">n2 </span><span class="s2">+ </span><span class="s1">n1 </span><span class="s2">+ </span><span class="s4">1</span><span class="s2">):</span>
            <span class="s5"># All multiples of d, except 0:</span>
            <span class="s1">indices </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(</span><span class="s1">d</span><span class="s2">, </span><span class="s1">a </span><span class="s2">+ </span><span class="s4">1</span><span class="s2">, </span><span class="s1">d</span><span class="s2">)</span>
            <span class="s5"># \epsilon_d = -1:</span>
            <span class="s1">s_array</span><span class="s2">[</span><span class="s1">indices</span><span class="s2">] -= </span><span class="s1">d</span>

        <span class="s5"># We don't need 0:</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">s_array </span><span class="s2">= </span><span class="s1">s_array</span>
        <span class="s0">return </span><span class="s1">s_array</span><span class="s2">[</span><span class="s4">1</span><span class="s2">:]</span>

    <span class="s0">def </span><span class="s1">build_u_freqs_array</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">maxu</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Build all the array of frequencies for u from 0 to maxu. 
        Assumptions: 
          n1 &lt;= n2 
          maxu &lt;= n1 * n2 / 2 
        &quot;&quot;&quot;</span>
        <span class="s1">n1</span><span class="s2">, </span><span class="s1">n2 </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">n1</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">n2</span>
        <span class="s1">total </span><span class="s2">= </span><span class="s1">special</span><span class="s2">.</span><span class="s1">binom</span><span class="s2">(</span><span class="s1">n1 </span><span class="s2">+ </span><span class="s1">n2</span><span class="s2">, </span><span class="s1">n1</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">maxu </span><span class="s2">+ </span><span class="s4">1 </span><span class="s2">&lt;= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">configurations</span><span class="s2">.</span><span class="s1">size</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">configurations</span><span class="s2">[:</span><span class="s1">maxu </span><span class="s2">+ </span><span class="s4">1</span><span class="s2">] / </span><span class="s1">total</span>

        <span class="s1">s_array </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">build_sigma_array</span><span class="s2">(</span><span class="s1">maxu</span><span class="s2">)</span>

        <span class="s5"># Start working with ints, for maximum precision and efficiency:</span>
        <span class="s1">configurations </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">(</span><span class="s1">maxu </span><span class="s2">+ </span><span class="s4">1</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">uint64</span><span class="s2">)</span>
        <span class="s1">configurations_is_uint </span><span class="s2">= </span><span class="s0">True</span>
        <span class="s1">uint_max </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">iinfo</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">uint64</span><span class="s2">).</span><span class="s1">max</span>
        <span class="s5"># How many ways to have U=0? 1</span>
        <span class="s1">configurations</span><span class="s2">[</span><span class="s4">0</span><span class="s2">] = </span><span class="s4">1</span>

        <span class="s0">for </span><span class="s1">u </span><span class="s0">in </span><span class="s1">np</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">maxu </span><span class="s2">+ </span><span class="s4">1</span><span class="s2">):</span>
            <span class="s1">coeffs </span><span class="s2">= </span><span class="s1">s_array</span><span class="s2">[</span><span class="s1">u </span><span class="s2">- </span><span class="s4">1</span><span class="s2">::-</span><span class="s4">1</span><span class="s2">]</span>
            <span class="s1">new_val </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">dot</span><span class="s2">(</span><span class="s1">configurations</span><span class="s2">[:</span><span class="s1">u</span><span class="s2">], </span><span class="s1">coeffs</span><span class="s2">) / </span><span class="s1">u</span>
            <span class="s0">if </span><span class="s1">new_val </span><span class="s2">&gt; </span><span class="s1">uint_max </span><span class="s0">and </span><span class="s1">configurations_is_uint</span><span class="s2">:</span>
                <span class="s5"># OK, we got into numbers too big for uint64.</span>
                <span class="s5"># So now we start working with floats.</span>
                <span class="s5"># By doing this since the beginning, we would have lost precision.</span>
                <span class="s5"># (And working on python long ints would be unbearably slow)</span>
                <span class="s1">configurations </span><span class="s2">= </span><span class="s1">configurations</span><span class="s2">.</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">float</span><span class="s2">)</span>
                <span class="s1">configurations_is_uint </span><span class="s2">= </span><span class="s0">False</span>
            <span class="s1">configurations</span><span class="s2">[</span><span class="s1">u</span><span class="s2">] = </span><span class="s1">new_val</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">configurations </span><span class="s2">= </span><span class="s1">configurations</span>
        <span class="s0">return </span><span class="s1">configurations </span><span class="s2">/ </span><span class="s1">total</span>


<span class="s1">_mwu_state </span><span class="s2">= </span><span class="s1">_MWU</span><span class="s2">(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">_get_mwu_z</span><span class="s2">(</span><span class="s1">U</span><span class="s2">, </span><span class="s1">n1</span><span class="s2">, </span><span class="s1">n2</span><span class="s2">, </span><span class="s1">t</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">continuity</span><span class="s2">=</span><span class="s0">True</span><span class="s2">):</span>
    <span class="s3">'''Standardized MWU statistic'''</span>
    <span class="s5"># Follows mannwhitneyu [2]</span>
    <span class="s1">mu </span><span class="s2">= </span><span class="s1">n1 </span><span class="s2">* </span><span class="s1">n2 </span><span class="s2">/ </span><span class="s4">2</span>
    <span class="s1">n </span><span class="s2">= </span><span class="s1">n1 </span><span class="s2">+ </span><span class="s1">n2</span>

    <span class="s5"># Tie correction according to [2], &quot;Normal approximation and tie correction&quot;</span>
    <span class="s5"># &quot;A more computationally-efficient form...&quot;</span>
    <span class="s1">tie_term </span><span class="s2">= (</span><span class="s1">t</span><span class="s2">**</span><span class="s4">3 </span><span class="s2">- </span><span class="s1">t</span><span class="s2">).</span><span class="s1">sum</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">=-</span><span class="s4">1</span><span class="s2">)</span>
    <span class="s1">s </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sqrt</span><span class="s2">(</span><span class="s1">n1</span><span class="s2">*</span><span class="s1">n2</span><span class="s2">/</span><span class="s4">12 </span><span class="s2">* ((</span><span class="s1">n </span><span class="s2">+ </span><span class="s4">1</span><span class="s2">) - </span><span class="s1">tie_term</span><span class="s2">/(</span><span class="s1">n</span><span class="s2">*(</span><span class="s1">n</span><span class="s2">-</span><span class="s4">1</span><span class="s2">))))</span>

    <span class="s1">numerator </span><span class="s2">= </span><span class="s1">U </span><span class="s2">- </span><span class="s1">mu</span>

    <span class="s5"># Continuity correction.</span>
    <span class="s5"># Because SF is always used to calculate the p-value, we can always</span>
    <span class="s5"># _subtract_ 0.5 for the continuity correction. This always increases the</span>
    <span class="s5"># p-value to account for the rest of the probability mass _at_ q = U.</span>
    <span class="s0">if </span><span class="s1">continuity</span><span class="s2">:</span>
        <span class="s1">numerator </span><span class="s2">-= </span><span class="s4">0.5</span>

    <span class="s5"># no problem evaluating the norm SF at an infinity</span>
    <span class="s0">with </span><span class="s1">np</span><span class="s2">.</span><span class="s1">errstate</span><span class="s2">(</span><span class="s1">divide</span><span class="s2">=</span><span class="s6">'ignore'</span><span class="s2">, </span><span class="s1">invalid</span><span class="s2">=</span><span class="s6">'ignore'</span><span class="s2">):</span>
        <span class="s1">z </span><span class="s2">= </span><span class="s1">numerator </span><span class="s2">/ </span><span class="s1">s</span>
    <span class="s0">return </span><span class="s1">z</span>


<span class="s0">def </span><span class="s1">_mwu_input_validation</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">use_continuity</span><span class="s2">, </span><span class="s1">alternative</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">method</span><span class="s2">):</span>
    <span class="s3">''' Input validation and standardization for mannwhitneyu '''</span>
    <span class="s5"># Would use np.asarray_chkfinite, but infs are OK</span>
    <span class="s1">x</span><span class="s2">, </span><span class="s1">y </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">atleast_1d</span><span class="s2">(</span><span class="s1">x</span><span class="s2">), </span><span class="s1">np</span><span class="s2">.</span><span class="s1">atleast_1d</span><span class="s2">(</span><span class="s1">y</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isnan</span><span class="s2">(</span><span class="s1">x</span><span class="s2">).</span><span class="s1">any</span><span class="s2">() </span><span class="s0">or </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isnan</span><span class="s2">(</span><span class="s1">y</span><span class="s2">).</span><span class="s1">any</span><span class="s2">():</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s6">'`x` and `y` must not contain NaNs.'</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">size</span><span class="s2">(</span><span class="s1">x</span><span class="s2">) == </span><span class="s4">0 </span><span class="s0">or </span><span class="s1">np</span><span class="s2">.</span><span class="s1">size</span><span class="s2">(</span><span class="s1">y</span><span class="s2">) == </span><span class="s4">0</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s6">'`x` and `y` must be of nonzero size.'</span><span class="s2">)</span>

    <span class="s1">bools </span><span class="s2">= {</span><span class="s0">True</span><span class="s2">, </span><span class="s0">False</span><span class="s2">}</span>
    <span class="s0">if </span><span class="s1">use_continuity </span><span class="s0">not in </span><span class="s1">bools</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s6">f'`use_continuity` must be one of </span><span class="s0">{</span><span class="s1">bools</span><span class="s0">}</span><span class="s6">.'</span><span class="s2">)</span>

    <span class="s1">alternatives </span><span class="s2">= {</span><span class="s6">&quot;two-sided&quot;</span><span class="s2">, </span><span class="s6">&quot;less&quot;</span><span class="s2">, </span><span class="s6">&quot;greater&quot;</span><span class="s2">}</span>
    <span class="s1">alternative </span><span class="s2">= </span><span class="s1">alternative</span><span class="s2">.</span><span class="s1">lower</span><span class="s2">()</span>
    <span class="s0">if </span><span class="s1">alternative </span><span class="s0">not in </span><span class="s1">alternatives</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s6">f'`alternative` must be one of </span><span class="s0">{</span><span class="s1">alternatives</span><span class="s0">}</span><span class="s6">.'</span><span class="s2">)</span>

    <span class="s1">axis_int </span><span class="s2">= </span><span class="s1">int</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">axis </span><span class="s2">!= </span><span class="s1">axis_int</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s6">'`axis` must be an integer.'</span><span class="s2">)</span>

    <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">method</span><span class="s2">, </span><span class="s1">stats</span><span class="s2">.</span><span class="s1">PermutationMethod</span><span class="s2">):</span>
        <span class="s1">methods </span><span class="s2">= {</span><span class="s6">&quot;asymptotic&quot;</span><span class="s2">, </span><span class="s6">&quot;exact&quot;</span><span class="s2">, </span><span class="s6">&quot;auto&quot;</span><span class="s2">}</span>
        <span class="s1">method </span><span class="s2">= </span><span class="s1">method</span><span class="s2">.</span><span class="s1">lower</span><span class="s2">()</span>
        <span class="s0">if </span><span class="s1">method </span><span class="s0">not in </span><span class="s1">methods</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s6">f'`method` must be one of </span><span class="s0">{</span><span class="s1">methods</span><span class="s0">}</span><span class="s6">.'</span><span class="s2">)</span>

    <span class="s0">return </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">use_continuity</span><span class="s2">, </span><span class="s1">alternative</span><span class="s2">, </span><span class="s1">axis_int</span><span class="s2">, </span><span class="s1">method</span>


<span class="s0">def </span><span class="s1">_mwu_choose_method</span><span class="s2">(</span><span class="s1">n1</span><span class="s2">, </span><span class="s1">n2</span><span class="s2">, </span><span class="s1">ties</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot;Choose method 'asymptotic' or 'exact' depending on input size, ties&quot;&quot;&quot;</span>

    <span class="s5"># if both inputs are large, asymptotic is OK</span>
    <span class="s0">if </span><span class="s1">n1 </span><span class="s2">&gt; </span><span class="s4">8 </span><span class="s0">and </span><span class="s1">n2 </span><span class="s2">&gt; </span><span class="s4">8</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s6">&quot;asymptotic&quot;</span>

    <span class="s5"># if there are any ties, asymptotic is preferred</span>
    <span class="s0">if </span><span class="s1">ties</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s6">&quot;asymptotic&quot;</span>

    <span class="s0">return </span><span class="s6">&quot;exact&quot;</span>


<span class="s1">MannwhitneyuResult </span><span class="s2">= </span><span class="s1">namedtuple</span><span class="s2">(</span><span class="s6">'MannwhitneyuResult'</span><span class="s2">, (</span><span class="s6">'statistic'</span><span class="s2">, </span><span class="s6">'pvalue'</span><span class="s2">))</span>


<span class="s2">@</span><span class="s1">_axis_nan_policy_factory</span><span class="s2">(</span><span class="s1">MannwhitneyuResult</span><span class="s2">, </span><span class="s1">n_samples</span><span class="s2">=</span><span class="s4">2</span><span class="s2">)</span>
<span class="s0">def </span><span class="s1">mannwhitneyu</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">use_continuity</span><span class="s2">=</span><span class="s0">True</span><span class="s2">, </span><span class="s1">alternative</span><span class="s2">=</span><span class="s6">&quot;two-sided&quot;</span><span class="s2">,</span>
                 <span class="s1">axis</span><span class="s2">=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">method</span><span class="s2">=</span><span class="s6">&quot;auto&quot;</span><span class="s2">):</span>
    <span class="s3">r'''Perform the Mann-Whitney U rank test on two independent samples. 
 
    The Mann-Whitney U test is a nonparametric test of the null hypothesis 
    that the distribution underlying sample `x` is the same as the 
    distribution underlying sample `y`. It is often used as a test of 
    difference in location between distributions. 
 
    Parameters 
    ---------- 
    x, y : array-like 
        N-d arrays of samples. The arrays must be broadcastable except along 
        the dimension given by `axis`. 
    use_continuity : bool, optional 
            Whether a continuity correction (1/2) should be applied. 
            Default is True when `method` is ``'asymptotic'``; has no effect 
            otherwise. 
    alternative : {'two-sided', 'less', 'greater'}, optional 
        Defines the alternative hypothesis. Default is 'two-sided'. 
        Let *F(u)* and *G(u)* be the cumulative distribution functions of the 
        distributions underlying `x` and `y`, respectively. Then the following 
        alternative hypotheses are available: 
 
        * 'two-sided': the distributions are not equal, i.e. *F(u) ≠ G(u)* for 
          at least one *u*. 
        * 'less': the distribution underlying `x` is stochastically less 
          than the distribution underlying `y`, i.e. *F(u) &gt; G(u)* for all *u*. 
        * 'greater': the distribution underlying `x` is stochastically greater 
          than the distribution underlying `y`, i.e. *F(u) &lt; G(u)* for all *u*. 
 
        Note that the mathematical expressions in the alternative hypotheses 
        above describe the CDFs of the underlying distributions. The directions 
        of the inequalities appear inconsistent with the natural language 
        description at first glance, but they are not. For example, suppose 
        *X* and *Y* are random variables that follow distributions with CDFs 
        *F* and *G*, respectively. If *F(u) &gt; G(u)* for all *u*, samples drawn 
        from *X* tend to be less than those drawn from *Y*. 
 
        Under a more restrictive set of assumptions, the alternative hypotheses 
        can be expressed in terms of the locations of the distributions; 
        see [5] section 5.1. 
    axis : int, optional 
        Axis along which to perform the test. Default is 0. 
    method : {'auto', 'asymptotic', 'exact'} or `PermutationMethod` instance, optional 
        Selects the method used to calculate the *p*-value. 
        Default is 'auto'. The following options are available. 
 
        * ``'asymptotic'``: compares the standardized test statistic 
          against the normal distribution, correcting for ties. 
        * ``'exact'``: computes the exact *p*-value by comparing the observed 
          :math:`U` statistic against the exact distribution of the :math:`U` 
          statistic under the null hypothesis. No correction is made for ties. 
        * ``'auto'``: chooses ``'exact'`` when the size of one of the samples 
          is less than or equal to 8 and there are no ties; 
          chooses ``'asymptotic'`` otherwise. 
        * `PermutationMethod` instance. In this case, the p-value 
          is computed using `permutation_test` with the provided 
          configuration options and other appropriate settings. 
 
    Returns 
    ------- 
    res : MannwhitneyuResult 
        An object containing attributes: 
 
        statistic : float 
            The Mann-Whitney U statistic corresponding with sample `x`. See 
            Notes for the test statistic corresponding with sample `y`. 
        pvalue : float 
            The associated *p*-value for the chosen `alternative`. 
 
    Notes 
    ----- 
    If ``U1`` is the statistic corresponding with sample `x`, then the 
    statistic corresponding with sample `y` is 
    ``U2 = x.shape[axis] * y.shape[axis] - U1``. 
 
    `mannwhitneyu` is for independent samples. For related / paired samples, 
    consider `scipy.stats.wilcoxon`. 
 
    `method` ``'exact'`` is recommended when there are no ties and when either 
    sample size is less than 8 [1]_. The implementation follows the algorithm 
    reported in [3]_. 
    Note that the exact method is *not* corrected for ties, but 
    `mannwhitneyu` will not raise errors or warnings if there are ties in the 
    data. If there are ties and either samples is small (fewer than ~10 
    observations), consider passing an instance of `PermutationMethod` 
    as the `method` to perform a permutation test. 
 
    The Mann-Whitney U test is a non-parametric version of the t-test for 
    independent samples. When the means of samples from the populations 
    are normally distributed, consider `scipy.stats.ttest_ind`. 
 
    See Also 
    -------- 
    scipy.stats.wilcoxon, scipy.stats.ranksums, scipy.stats.ttest_ind 
 
    References 
    ---------- 
    .. [1] H.B. Mann and D.R. Whitney, &quot;On a test of whether one of two random 
           variables is stochastically larger than the other&quot;, The Annals of 
           Mathematical Statistics, Vol. 18, pp. 50-60, 1947. 
    .. [2] Mann-Whitney U Test, Wikipedia, 
           http://en.wikipedia.org/wiki/Mann-Whitney_U_test 
    .. [3] Andreas Löffler, 
           &quot;Über eine Partition der nat. Zahlen und ihr Anwendung beim U-Test&quot;, 
           Wiss. Z. Univ. Halle, XXXII'83 pp. 87-89. 
    .. [4] Rosie Shier, &quot;Statistics: 2.3 The Mann-Whitney U Test&quot;, Mathematics 
           Learning Support Centre, 2004. 
    .. [5] Michael P. Fay and Michael A. Proschan. &quot;Wilcoxon-Mann-Whitney 
           or t-test? On assumptions for hypothesis tests and multiple \ 
           interpretations of decision rules.&quot; Statistics surveys, Vol. 4, pp. 
           1-39, 2010. https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2857732/ 
 
    Examples 
    -------- 
    We follow the example from [4]_: nine randomly sampled young adults were 
    diagnosed with type II diabetes at the ages below. 
 
    &gt;&gt;&gt; males = [19, 22, 16, 29, 24] 
    &gt;&gt;&gt; females = [20, 11, 17, 12] 
 
    We use the Mann-Whitney U test to assess whether there is a statistically 
    significant difference in the diagnosis age of males and females. 
    The null hypothesis is that the distribution of male diagnosis ages is 
    the same as the distribution of female diagnosis ages. We decide 
    that a confidence level of 95% is required to reject the null hypothesis 
    in favor of the alternative that the distributions are different. 
    Since the number of samples is very small and there are no ties in the 
    data, we can compare the observed test statistic against the *exact* 
    distribution of the test statistic under the null hypothesis. 
 
    &gt;&gt;&gt; from scipy.stats import mannwhitneyu 
    &gt;&gt;&gt; U1, p = mannwhitneyu(males, females, method=&quot;exact&quot;) 
    &gt;&gt;&gt; print(U1) 
    17.0 
 
    `mannwhitneyu` always reports the statistic associated with the first 
    sample, which, in this case, is males. This agrees with :math:`U_M = 17` 
    reported in [4]_. The statistic associated with the second statistic 
    can be calculated: 
 
    &gt;&gt;&gt; nx, ny = len(males), len(females) 
    &gt;&gt;&gt; U2 = nx*ny - U1 
    &gt;&gt;&gt; print(U2) 
    3.0 
 
    This agrees with :math:`U_F = 3` reported in [4]_. The two-sided 
    *p*-value can be calculated from either statistic, and the value produced 
    by `mannwhitneyu` agrees with :math:`p = 0.11` reported in [4]_. 
 
    &gt;&gt;&gt; print(p) 
    0.1111111111111111 
 
    The exact distribution of the test statistic is asymptotically normal, so 
    the example continues by comparing the exact *p*-value against the 
    *p*-value produced using the normal approximation. 
 
    &gt;&gt;&gt; _, pnorm = mannwhitneyu(males, females, method=&quot;asymptotic&quot;) 
    &gt;&gt;&gt; print(pnorm) 
    0.11134688653314041 
 
    Here `mannwhitneyu`'s reported *p*-value appears to conflict with the 
    value :math:`p = 0.09` given in [4]_. The reason is that [4]_ 
    does not apply the continuity correction performed by `mannwhitneyu`; 
    `mannwhitneyu` reduces the distance between the test statistic and the 
    mean :math:`\mu = n_x n_y / 2` by 0.5 to correct for the fact that the 
    discrete statistic is being compared against a continuous distribution. 
    Here, the :math:`U` statistic used is less than the mean, so we reduce 
    the distance by adding 0.5 in the numerator. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.stats import norm 
    &gt;&gt;&gt; U = min(U1, U2) 
    &gt;&gt;&gt; N = nx + ny 
    &gt;&gt;&gt; z = (U - nx*ny/2 + 0.5) / np.sqrt(nx*ny * (N + 1)/ 12) 
    &gt;&gt;&gt; p = 2 * norm.cdf(z)  # use CDF to get p-value from smaller statistic 
    &gt;&gt;&gt; print(p) 
    0.11134688653314041 
 
    If desired, we can disable the continuity correction to get a result 
    that agrees with that reported in [4]_. 
 
    &gt;&gt;&gt; _, pnorm = mannwhitneyu(males, females, use_continuity=False, 
    ...                         method=&quot;asymptotic&quot;) 
    &gt;&gt;&gt; print(pnorm) 
    0.0864107329737 
 
    Regardless of whether we perform an exact or asymptotic test, the 
    probability of the test statistic being as extreme or more extreme by 
    chance exceeds 5%, so we do not consider the results statistically 
    significant. 
 
    Suppose that, before seeing the data, we had hypothesized that females 
    would tend to be diagnosed at a younger age than males. 
    In that case, it would be natural to provide the female ages as the 
    first input, and we would have performed a one-sided test using 
    ``alternative = 'less'``: females are diagnosed at an age that is 
    stochastically less than that of males. 
 
    &gt;&gt;&gt; res = mannwhitneyu(females, males, alternative=&quot;less&quot;, method=&quot;exact&quot;) 
    &gt;&gt;&gt; print(res) 
    MannwhitneyuResult(statistic=3.0, pvalue=0.05555555555555555) 
 
    Again, the probability of getting a sufficiently low value of the 
    test statistic by chance under the null hypothesis is greater than 5%, 
    so we do not reject the null hypothesis in favor of our alternative. 
 
    If it is reasonable to assume that the means of samples from the 
    populations are normally distributed, we could have used a t-test to 
    perform the analysis. 
 
    &gt;&gt;&gt; from scipy.stats import ttest_ind 
    &gt;&gt;&gt; res = ttest_ind(females, males, alternative=&quot;less&quot;) 
    &gt;&gt;&gt; print(res) 
    TtestResult(statistic=-2.239334696520584, 
                pvalue=0.030068441095757924, 
                df=7.0) 
 
    Under this assumption, the *p*-value would be low enough to reject the 
    null hypothesis in favor of the alternative. 
 
    '''</span>

    <span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">use_continuity</span><span class="s2">, </span><span class="s1">alternative</span><span class="s2">, </span><span class="s1">axis_int</span><span class="s2">, </span><span class="s1">method </span><span class="s2">= (</span>
        <span class="s1">_mwu_input_validation</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">use_continuity</span><span class="s2">, </span><span class="s1">alternative</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">method</span><span class="s2">))</span>

    <span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">xy </span><span class="s2">= </span><span class="s1">_broadcast_concatenate</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">)</span>

    <span class="s1">n1</span><span class="s2">, </span><span class="s1">n2 </span><span class="s2">= </span><span class="s1">x</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[-</span><span class="s4">1</span><span class="s2">], </span><span class="s1">y</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[-</span><span class="s4">1</span><span class="s2">]</span>

    <span class="s5"># Follows [2]</span>
    <span class="s1">ranks</span><span class="s2">, </span><span class="s1">t </span><span class="s2">= </span><span class="s1">_rankdata</span><span class="s2">(</span><span class="s1">xy</span><span class="s2">, </span><span class="s6">'average'</span><span class="s2">, </span><span class="s1">return_ties</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)  </span><span class="s5"># method 2, step 1</span>
    <span class="s1">R1 </span><span class="s2">= </span><span class="s1">ranks</span><span class="s2">[..., :</span><span class="s1">n1</span><span class="s2">].</span><span class="s1">sum</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">=-</span><span class="s4">1</span><span class="s2">)                      </span><span class="s5"># method 2, step 2</span>
    <span class="s1">U1 </span><span class="s2">= </span><span class="s1">R1 </span><span class="s2">- </span><span class="s1">n1</span><span class="s2">*(</span><span class="s1">n1</span><span class="s2">+</span><span class="s4">1</span><span class="s2">)/</span><span class="s4">2                                  </span><span class="s5"># method 2, step 3</span>
    <span class="s1">U2 </span><span class="s2">= </span><span class="s1">n1 </span><span class="s2">* </span><span class="s1">n2 </span><span class="s2">- </span><span class="s1">U1                                      </span><span class="s5"># as U1 + U2 = n1 * n2</span>

    <span class="s0">if </span><span class="s1">alternative </span><span class="s2">== </span><span class="s6">&quot;greater&quot;</span><span class="s2">:</span>
        <span class="s1">U</span><span class="s2">, </span><span class="s1">f </span><span class="s2">= </span><span class="s1">U1</span><span class="s2">, </span><span class="s4">1  </span><span class="s5"># U is the statistic to use for p-value, f is a factor</span>
    <span class="s0">elif </span><span class="s1">alternative </span><span class="s2">== </span><span class="s6">&quot;less&quot;</span><span class="s2">:</span>
        <span class="s1">U</span><span class="s2">, </span><span class="s1">f </span><span class="s2">= </span><span class="s1">U2</span><span class="s2">, </span><span class="s4">1  </span><span class="s5"># Due to symmetry, use SF of U2 rather than CDF of U1</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">U</span><span class="s2">, </span><span class="s1">f </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">maximum</span><span class="s2">(</span><span class="s1">U1</span><span class="s2">, </span><span class="s1">U2</span><span class="s2">), </span><span class="s4">2  </span><span class="s5"># multiply SF by two for two-sided test</span>

    <span class="s0">if </span><span class="s1">method </span><span class="s2">== </span><span class="s6">&quot;auto&quot;</span><span class="s2">:</span>
        <span class="s1">method </span><span class="s2">= </span><span class="s1">_mwu_choose_method</span><span class="s2">(</span><span class="s1">n1</span><span class="s2">, </span><span class="s1">n2</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">any</span><span class="s2">(</span><span class="s1">t </span><span class="s2">&gt; </span><span class="s4">1</span><span class="s2">))</span>

    <span class="s0">if </span><span class="s1">method </span><span class="s2">== </span><span class="s6">&quot;exact&quot;</span><span class="s2">:</span>
        <span class="s1">_mwu_state</span><span class="s2">.</span><span class="s1">set_shapes</span><span class="s2">(</span><span class="s1">n1</span><span class="s2">, </span><span class="s1">n2</span><span class="s2">)</span>
        <span class="s1">p </span><span class="s2">= </span><span class="s1">_mwu_state</span><span class="s2">.</span><span class="s1">sf</span><span class="s2">(</span><span class="s1">U</span><span class="s2">.</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">int</span><span class="s2">))</span>
    <span class="s0">elif </span><span class="s1">method </span><span class="s2">== </span><span class="s6">&quot;asymptotic&quot;</span><span class="s2">:</span>
        <span class="s1">z </span><span class="s2">= </span><span class="s1">_get_mwu_z</span><span class="s2">(</span><span class="s1">U</span><span class="s2">, </span><span class="s1">n1</span><span class="s2">, </span><span class="s1">n2</span><span class="s2">, </span><span class="s1">t</span><span class="s2">, </span><span class="s1">continuity</span><span class="s2">=</span><span class="s1">use_continuity</span><span class="s2">)</span>
        <span class="s1">p </span><span class="s2">= </span><span class="s1">stats</span><span class="s2">.</span><span class="s1">norm</span><span class="s2">.</span><span class="s1">sf</span><span class="s2">(</span><span class="s1">z</span><span class="s2">)</span>
    <span class="s0">else</span><span class="s2">:  </span><span class="s5"># `PermutationMethod` instance (already validated)</span>
        <span class="s0">def </span><span class="s1">statistic</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">mannwhitneyu</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">use_continuity</span><span class="s2">=</span><span class="s1">use_continuity</span><span class="s2">,</span>
                                <span class="s1">alternative</span><span class="s2">=</span><span class="s1">alternative</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s1">axis</span><span class="s2">,</span>
                                <span class="s1">method</span><span class="s2">=</span><span class="s6">&quot;asymptotic&quot;</span><span class="s2">).</span><span class="s1">statistic</span>

        <span class="s1">res </span><span class="s2">= </span><span class="s1">stats</span><span class="s2">.</span><span class="s1">permutation_test</span><span class="s2">((</span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">), </span><span class="s1">statistic</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s1">axis</span><span class="s2">,</span>
                                     <span class="s2">**</span><span class="s1">method</span><span class="s2">.</span><span class="s1">_asdict</span><span class="s2">(), </span><span class="s1">alternative</span><span class="s2">=</span><span class="s1">alternative</span><span class="s2">)</span>
        <span class="s1">p </span><span class="s2">= </span><span class="s1">res</span><span class="s2">.</span><span class="s1">pvalue</span>
        <span class="s1">f </span><span class="s2">= </span><span class="s4">1</span>

    <span class="s1">p </span><span class="s2">*= </span><span class="s1">f</span>

    <span class="s5"># Ensure that test statistic is not greater than 1</span>
    <span class="s5"># This could happen for exact test when U = m*n/2</span>
    <span class="s1">p </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">clip</span><span class="s2">(</span><span class="s1">p</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">)</span>

    <span class="s0">return </span><span class="s1">MannwhitneyuResult</span><span class="s2">(</span><span class="s1">U1</span><span class="s2">, </span><span class="s1">p</span><span class="s2">)</span>
</pre>
</body>
</html>