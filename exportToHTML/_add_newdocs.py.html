<html>
<head>
<title>_add_newdocs.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #cf8e6d;}
.s4 { color: #6aab73;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_add_newdocs.py</font>
</center></td></tr></table>
<pre><span class="s0"># Docstrings for generated ufuncs</span>
<span class="s0">#</span>
<span class="s0"># The syntax is designed to look like the function add_newdoc is being</span>
<span class="s0"># called from numpy.lib, but in this file add_newdoc puts the</span>
<span class="s0"># docstrings in a dictionary. This dictionary is used in</span>
<span class="s0"># _generate_pyx.py to generate the docstrings for the ufuncs in</span>
<span class="s0"># scipy.special at the C level when the ufuncs are created at compile</span>
<span class="s0"># time.</span>

<span class="s1">docdict</span><span class="s2">: </span><span class="s1">dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">str</span><span class="s2">] = {}</span>


<span class="s3">def </span><span class="s1">get</span><span class="s2">(</span><span class="s1">name</span><span class="s2">):</span>
    <span class="s3">return </span><span class="s1">docdict</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">name</span><span class="s2">)</span>


<span class="s3">def </span><span class="s1">add_newdoc</span><span class="s2">(</span><span class="s1">name</span><span class="s2">, </span><span class="s1">doc</span><span class="s2">):</span>
    <span class="s1">docdict</span><span class="s2">[</span><span class="s1">name</span><span class="s2">] = </span><span class="s1">doc</span>


<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;_sf_error_test_function&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    Private function; do not use. 
    &quot;&quot;&quot;</span><span class="s2">)</span>


<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;_cosine_cdf&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    _cosine_cdf(x) 
 
    Cumulative distribution function (CDF) of the cosine distribution:: 
 
                 {             0,              x &lt; -pi 
        cdf(x) = { (pi + x + sin(x))/(2*pi),   -pi &lt;= x &lt;= pi 
                 {             1,              x &gt; pi 
 
    Parameters 
    ---------- 
    x : array_like 
        `x` must contain real numbers. 
 
    Returns 
    ------- 
    scalar or ndarray 
        The cosine distribution CDF evaluated at `x`. 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;_cosine_invcdf&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    _cosine_invcdf(p) 
 
    Inverse of the cumulative distribution function (CDF) of the cosine 
    distribution. 
 
    The CDF of the cosine distribution is:: 
 
        cdf(x) = (pi + x + sin(x))/(2*pi) 
 
    This function computes the inverse of cdf(x). 
 
    Parameters 
    ---------- 
    p : array_like 
        `p` must contain real numbers in the interval ``0 &lt;= p &lt;= 1``. 
        `nan` is returned for values of `p` outside the interval [0, 1]. 
 
    Returns 
    ------- 
    scalar or ndarray 
        The inverse of the cosine distribution CDF evaluated at `p`. 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;_ellip_harm&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    Internal function, use `ellip_harm` instead. 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;_ellip_norm&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    Internal function, use `ellip_norm` instead. 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;voigt_profile&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    voigt_profile(x, sigma, gamma, out=None) 
 
    Voigt profile. 
 
    The Voigt profile is a convolution of a 1-D Normal distribution with 
    standard deviation ``sigma`` and a 1-D Cauchy distribution with half-width at 
    half-maximum ``gamma``. 
 
    If ``sigma = 0``, PDF of Cauchy distribution is returned. 
    Conversely, if ``gamma = 0``, PDF of Normal distribution is returned. 
    If ``sigma = gamma = 0``, the return value is ``Inf`` for ``x = 0``, 
    and ``0`` for all other ``x``. 
 
    Parameters 
    ---------- 
    x : array_like 
        Real argument 
    sigma : array_like 
        The standard deviation of the Normal distribution part 
    gamma : array_like 
        The half-width at half-maximum of the Cauchy distribution part 
    out : ndarray, optional 
        Optional output array for the function values 
 
    Returns 
    ------- 
    scalar or ndarray 
        The Voigt profile at the given arguments 
 
    See Also 
    -------- 
    wofz : Faddeeva function 
 
    Notes 
    ----- 
    It can be expressed in terms of Faddeeva function 
 
    .. math:: V(x; \sigma, \gamma) = \frac{Re[w(z)]}{\sigma\sqrt{2\pi}}, 
    .. math:: z = \frac{x + i\gamma}{\sqrt{2}\sigma} 
 
    where :math:`w(z)` is the Faddeeva function. 
 
    References 
    ---------- 
    .. [1] https://en.wikipedia.org/wiki/Voigt_profile 
 
    Examples 
    -------- 
    Calculate the function at point 2 for ``sigma=1`` and ``gamma=1``. 
 
    &gt;&gt;&gt; from scipy.special import voigt_profile 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; voigt_profile(2, 1., 1.) 
    0.09071519942627544 
 
    Calculate the function at several points by providing a NumPy array 
    for `x`. 
 
    &gt;&gt;&gt; values = np.array([-2., 0., 5]) 
    &gt;&gt;&gt; voigt_profile(values, 1., 1.) 
    array([0.0907152 , 0.20870928, 0.01388492]) 
 
    Plot the function for different parameter sets. 
 
    &gt;&gt;&gt; fig, ax = plt.subplots(figsize=(8, 8)) 
    &gt;&gt;&gt; x = np.linspace(-10, 10, 500) 
    &gt;&gt;&gt; parameters_list = [(1.5, 0., &quot;solid&quot;), (1.3, 0.5, &quot;dashed&quot;), 
    ...                    (0., 1.8, &quot;dotted&quot;), (1., 1., &quot;dashdot&quot;)] 
    &gt;&gt;&gt; for params in parameters_list: 
    ...     sigma, gamma, linestyle = params 
    ...     voigt = voigt_profile(x, sigma, gamma) 
    ...     ax.plot(x, voigt, label=rf&quot;$\sigma={sigma},\, \gamma={gamma}$&quot;, 
    ...             ls=linestyle) 
    &gt;&gt;&gt; ax.legend() 
    &gt;&gt;&gt; plt.show() 
 
    Verify visually that the Voigt profile indeed arises as the convolution 
    of a normal and a Cauchy distribution. 
 
    &gt;&gt;&gt; from scipy.signal import convolve 
    &gt;&gt;&gt; x, dx = np.linspace(-10, 10, 500, retstep=True) 
    &gt;&gt;&gt; def gaussian(x, sigma): 
    ...     return np.exp(-0.5 * x**2/sigma**2)/(sigma * np.sqrt(2*np.pi)) 
    &gt;&gt;&gt; def cauchy(x, gamma): 
    ...     return gamma/(np.pi * (np.square(x)+gamma**2)) 
    &gt;&gt;&gt; sigma = 2 
    &gt;&gt;&gt; gamma = 1 
    &gt;&gt;&gt; gauss_profile = gaussian(x, sigma) 
    &gt;&gt;&gt; cauchy_profile = cauchy(x, gamma) 
    &gt;&gt;&gt; convolved = dx * convolve(cauchy_profile, gauss_profile, mode=&quot;same&quot;) 
    &gt;&gt;&gt; voigt = voigt_profile(x, sigma, gamma) 
    &gt;&gt;&gt; fig, ax = plt.subplots(figsize=(8, 8)) 
    &gt;&gt;&gt; ax.plot(x, gauss_profile, label=&quot;Gauss: $G$&quot;, c='b') 
    &gt;&gt;&gt; ax.plot(x, cauchy_profile, label=&quot;Cauchy: $C$&quot;, c='y', ls=&quot;dashed&quot;) 
    &gt;&gt;&gt; xx = 0.5*(x[1:] + x[:-1])  # midpoints 
    &gt;&gt;&gt; ax.plot(xx, convolved[1:], label=&quot;Convolution: $G * C$&quot;, ls='dashdot', 
    ...         c='k') 
    &gt;&gt;&gt; ax.plot(x, voigt, label=&quot;Voigt&quot;, ls='dotted', c='r') 
    &gt;&gt;&gt; ax.legend() 
    &gt;&gt;&gt; plt.show() 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;wrightomega&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    wrightomega(z, out=None) 
 
    Wright Omega function. 
 
    Defined as the solution to 
 
    .. math:: 
 
        \omega + \log(\omega) = z 
 
    where :math:`\log` is the principal branch of the complex logarithm. 
 
    Parameters 
    ---------- 
    z : array_like 
        Points at which to evaluate the Wright Omega function 
    out : ndarray, optional 
        Optional output array for the function values 
 
    Returns 
    ------- 
    omega : scalar or ndarray 
        Values of the Wright Omega function 
 
    See Also 
    -------- 
    lambertw : The Lambert W function 
 
    Notes 
    ----- 
    .. versionadded:: 0.19.0 
 
    The function can also be defined as 
 
    .. math:: 
 
        \omega(z) = W_{K(z)}(e^z) 
 
    where :math:`K(z) = \lceil (\Im(z) - \pi)/(2\pi) \rceil` is the 
    unwinding number and :math:`W` is the Lambert W function. 
 
    The implementation here is taken from [1]_. 
 
    References 
    ---------- 
    .. [1] Lawrence, Corless, and Jeffrey, &quot;Algorithm 917: Complex 
           Double-Precision Evaluation of the Wright :math:`\omega` 
           Function.&quot; ACM Transactions on Mathematical Software, 
           2012. :doi:`10.1145/2168773.2168779`. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.special import wrightomega, lambertw 
 
    &gt;&gt;&gt; wrightomega([-2, -1, 0, 1, 2]) 
    array([0.12002824, 0.27846454, 0.56714329, 1.        , 1.5571456 ]) 
 
    Complex input: 
 
    &gt;&gt;&gt; wrightomega(3 + 5j) 
    (1.5804428632097158+3.8213626783287937j) 
 
    Verify that ``wrightomega(z)`` satisfies ``w + log(w) = z``: 
 
    &gt;&gt;&gt; w = -5 + 4j 
    &gt;&gt;&gt; wrightomega(w + np.log(w)) 
    (-5+4j) 
 
    Verify the connection to ``lambertw``: 
 
    &gt;&gt;&gt; z = 0.5 + 3j 
    &gt;&gt;&gt; wrightomega(z) 
    (0.0966015889280649+1.4937828458191993j) 
    &gt;&gt;&gt; lambertw(np.exp(z)) 
    (0.09660158892806493+1.4937828458191993j) 
 
    &gt;&gt;&gt; z = 0.5 + 4j 
    &gt;&gt;&gt; wrightomega(z) 
    (-0.3362123489037213+2.282986001579032j) 
    &gt;&gt;&gt; lambertw(np.exp(z), k=1) 
    (-0.33621234890372115+2.282986001579032j) 
    &quot;&quot;&quot;</span><span class="s2">)</span>


<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;agm&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    agm(a, b, out=None) 
 
    Compute the arithmetic-geometric mean of `a` and `b`. 
 
    Start with a_0 = a and b_0 = b and iteratively compute:: 
 
        a_{n+1} = (a_n + b_n)/2 
        b_{n+1} = sqrt(a_n*b_n) 
 
    a_n and b_n converge to the same limit as n increases; their common 
    limit is agm(a, b). 
 
    Parameters 
    ---------- 
    a, b : array_like 
        Real values only. If the values are both negative, the result 
        is negative. If one value is negative and the other is positive, 
        `nan` is returned. 
    out : ndarray, optional 
        Optional output array for the function values 
 
    Returns 
    ------- 
    scalar or ndarray 
        The arithmetic-geometric mean of `a` and `b`. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.special import agm 
    &gt;&gt;&gt; a, b = 24.0, 6.0 
    &gt;&gt;&gt; agm(a, b) 
    13.458171481725614 
 
    Compare that result to the iteration: 
 
    &gt;&gt;&gt; while a != b: 
    ...     a, b = (a + b)/2, np.sqrt(a*b) 
    ...     print(&quot;a = %19.16f  b=%19.16f&quot; % (a, b)) 
    ... 
    a = 15.0000000000000000  b=12.0000000000000000 
    a = 13.5000000000000000  b=13.4164078649987388 
    a = 13.4582039324993694  b=13.4581390309909850 
    a = 13.4581714817451772  b=13.4581714817060547 
    a = 13.4581714817256159  b=13.4581714817256159 
 
    When array-like arguments are given, broadcasting applies: 
 
    &gt;&gt;&gt; a = np.array([[1.5], [3], [6]])  # a has shape (3, 1). 
    &gt;&gt;&gt; b = np.array([6, 12, 24, 48])    # b has shape (4,). 
    &gt;&gt;&gt; agm(a, b) 
    array([[  3.36454287,   5.42363427,   9.05798751,  15.53650756], 
           [  4.37037309,   6.72908574,  10.84726853,  18.11597502], 
           [  6.        ,   8.74074619,  13.45817148,  21.69453707]]) 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;airy&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    airy(z, out=None) 
 
    Airy functions and their derivatives. 
 
    Parameters 
    ---------- 
    z : array_like 
        Real or complex argument. 
    out : tuple of ndarray, optional 
        Optional output arrays for the function values 
 
    Returns 
    ------- 
    Ai, Aip, Bi, Bip : 4-tuple of scalar or ndarray 
        Airy functions Ai and Bi, and their derivatives Aip and Bip. 
 
    See Also 
    -------- 
    airye : exponentially scaled Airy functions. 
 
    Notes 
    ----- 
    The Airy functions Ai and Bi are two independent solutions of 
 
    .. math:: y''(x) = x y(x). 
 
    For real `z` in [-10, 10], the computation is carried out by calling 
    the Cephes [1]_ `airy` routine, which uses power series summation 
    for small `z` and rational minimax approximations for large `z`. 
 
    Outside this range, the AMOS [2]_ `zairy` and `zbiry` routines are 
    employed.  They are computed using power series for :math:`|z| &lt; 1` and 
    the following relations to modified Bessel functions for larger `z` 
    (where :math:`t \equiv 2 z^{3/2}/3`): 
 
    .. math:: 
 
        Ai(z) = \frac{1}{\pi \sqrt{3}} K_{1/3}(t) 
 
        Ai'(z) = -\frac{z}{\pi \sqrt{3}} K_{2/3}(t) 
 
        Bi(z) = \sqrt{\frac{z}{3}} \left(I_{-1/3}(t) + I_{1/3}(t) \right) 
 
        Bi'(z) = \frac{z}{\sqrt{3}} \left(I_{-2/3}(t) + I_{2/3}(t)\right) 
 
    References 
    ---------- 
    .. [1] Cephes Mathematical Functions Library, 
           http://www.netlib.org/cephes/ 
    .. [2] Donald E. Amos, &quot;AMOS, A Portable Package for Bessel Functions 
           of a Complex Argument and Nonnegative Order&quot;, 
           http://netlib.org/amos/ 
 
    Examples 
    -------- 
    Compute the Airy functions on the interval [-15, 5]. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import special 
    &gt;&gt;&gt; x = np.linspace(-15, 5, 201) 
    &gt;&gt;&gt; ai, aip, bi, bip = special.airy(x) 
 
    Plot Ai(x) and Bi(x). 
 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; plt.plot(x, ai, 'r', label='Ai(x)') 
    &gt;&gt;&gt; plt.plot(x, bi, 'b--', label='Bi(x)') 
    &gt;&gt;&gt; plt.ylim(-0.5, 1.0) 
    &gt;&gt;&gt; plt.grid() 
    &gt;&gt;&gt; plt.legend(loc='upper left') 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;airye&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    airye(z, out=None) 
 
    Exponentially scaled Airy functions and their derivatives. 
 
    Scaling:: 
 
        eAi  = Ai  * exp(2.0/3.0*z*sqrt(z)) 
        eAip = Aip * exp(2.0/3.0*z*sqrt(z)) 
        eBi  = Bi  * exp(-abs(2.0/3.0*(z*sqrt(z)).real)) 
        eBip = Bip * exp(-abs(2.0/3.0*(z*sqrt(z)).real)) 
 
    Parameters 
    ---------- 
    z : array_like 
        Real or complex argument. 
    out : tuple of ndarray, optional 
        Optional output arrays for the function values 
 
    Returns 
    ------- 
    eAi, eAip, eBi, eBip : 4-tuple of scalar or ndarray 
        Exponentially scaled Airy functions eAi and eBi, and their derivatives 
        eAip and eBip 
 
    See Also 
    -------- 
    airy 
 
    Notes 
    ----- 
    Wrapper for the AMOS [1]_ routines `zairy` and `zbiry`. 
 
    References 
    ---------- 
    .. [1] Donald E. Amos, &quot;AMOS, A Portable Package for Bessel Functions 
           of a Complex Argument and Nonnegative Order&quot;, 
           http://netlib.org/amos/ 
 
    Examples 
    -------- 
    We can compute exponentially scaled Airy functions and their derivatives: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.special import airye 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; z = np.linspace(0, 50, 500) 
    &gt;&gt;&gt; eAi, eAip, eBi, eBip = airye(z) 
    &gt;&gt;&gt; f, ax = plt.subplots(2, 1, sharex=True) 
    &gt;&gt;&gt; for ind, data in enumerate([[eAi, eAip, [&quot;eAi&quot;, &quot;eAip&quot;]], 
    ...                             [eBi, eBip, [&quot;eBi&quot;, &quot;eBip&quot;]]]): 
    ...     ax[ind].plot(z, data[0], &quot;-r&quot;, z, data[1], &quot;-b&quot;) 
    ...     ax[ind].legend(data[2]) 
    ...     ax[ind].grid(True) 
    &gt;&gt;&gt; plt.show() 
 
    We can compute these using usual non-scaled Airy functions by: 
 
    &gt;&gt;&gt; from scipy.special import airy 
    &gt;&gt;&gt; Ai, Aip, Bi, Bip = airy(z) 
    &gt;&gt;&gt; np.allclose(eAi, Ai * np.exp(2.0 / 3.0 * z * np.sqrt(z))) 
    True 
    &gt;&gt;&gt; np.allclose(eAip, Aip * np.exp(2.0 / 3.0 * z * np.sqrt(z))) 
    True 
    &gt;&gt;&gt; np.allclose(eBi, Bi * np.exp(-abs(np.real(2.0 / 3.0 * z * np.sqrt(z))))) 
    True 
    &gt;&gt;&gt; np.allclose(eBip, Bip * np.exp(-abs(np.real(2.0 / 3.0 * z * np.sqrt(z))))) 
    True 
 
    Comparing non-scaled and exponentially scaled ones, the usual non-scaled 
    function quickly underflows for large values, whereas the exponentially 
    scaled function does not. 
 
    &gt;&gt;&gt; airy(200) 
    (0.0, 0.0, nan, nan) 
    &gt;&gt;&gt; airye(200) 
    (0.07501041684381093, -1.0609012305109042, 0.15003188417418148, 2.1215836725571093) 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;bdtr&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    bdtr(k, n, p, out=None) 
 
    Binomial distribution cumulative distribution function. 
 
    Sum of the terms 0 through `floor(k)` of the Binomial probability density. 
 
    .. math:: 
        \mathrm{bdtr}(k, n, p) = 
        \sum_{j=0}^{\lfloor k \rfloor} {{n}\choose{j}} p^j (1-p)^{n-j} 
 
    Parameters 
    ---------- 
    k : array_like 
        Number of successes (double), rounded down to the nearest integer. 
    n : array_like 
        Number of events (int). 
    p : array_like 
        Probability of success in a single event (float). 
    out : ndarray, optional 
        Optional output array for the function values 
 
    Returns 
    ------- 
    y : scalar or ndarray 
        Probability of `floor(k)` or fewer successes in `n` independent events with 
        success probabilities of `p`. 
 
    Notes 
    ----- 
    The terms are not summed directly; instead the regularized incomplete beta 
    function is employed, according to the formula, 
 
    .. math:: 
        \mathrm{bdtr}(k, n, p) = 
        I_{1 - p}(n - \lfloor k \rfloor, \lfloor k \rfloor + 1). 
 
    Wrapper for the Cephes [1]_ routine `bdtr`. 
 
    References 
    ---------- 
    .. [1] Cephes Mathematical Functions Library, 
           http://www.netlib.org/cephes/ 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;bdtrc&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    bdtrc(k, n, p, out=None) 
 
    Binomial distribution survival function. 
 
    Sum of the terms `floor(k) + 1` through `n` of the binomial probability 
    density, 
 
    .. math:: 
        \mathrm{bdtrc}(k, n, p) = 
        \sum_{j=\lfloor k \rfloor +1}^n {{n}\choose{j}} p^j (1-p)^{n-j} 
 
    Parameters 
    ---------- 
    k : array_like 
        Number of successes (double), rounded down to nearest integer. 
    n : array_like 
        Number of events (int) 
    p : array_like 
        Probability of success in a single event. 
    out : ndarray, optional 
        Optional output array for the function values 
 
    Returns 
    ------- 
    y : scalar or ndarray 
        Probability of `floor(k) + 1` or more successes in `n` independent 
        events with success probabilities of `p`. 
 
    See Also 
    -------- 
    bdtr 
    betainc 
 
    Notes 
    ----- 
    The terms are not summed directly; instead the regularized incomplete beta 
    function is employed, according to the formula, 
 
    .. math:: 
        \mathrm{bdtrc}(k, n, p) = I_{p}(\lfloor k \rfloor + 1, n - \lfloor k \rfloor). 
 
    Wrapper for the Cephes [1]_ routine `bdtrc`. 
 
    References 
    ---------- 
    .. [1] Cephes Mathematical Functions Library, 
           http://www.netlib.org/cephes/ 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;bdtri&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    bdtri(k, n, y, out=None) 
 
    Inverse function to `bdtr` with respect to `p`. 
 
    Finds the event probability `p` such that the sum of the terms 0 through 
    `k` of the binomial probability density is equal to the given cumulative 
    probability `y`. 
 
    Parameters 
    ---------- 
    k : array_like 
        Number of successes (float), rounded down to the nearest integer. 
    n : array_like 
        Number of events (float) 
    y : array_like 
        Cumulative probability (probability of `k` or fewer successes in `n` 
        events). 
    out : ndarray, optional 
        Optional output array for the function values 
 
    Returns 
    ------- 
    p : scalar or ndarray 
        The event probability such that `bdtr(\lfloor k \rfloor, n, p) = y`. 
 
    See Also 
    -------- 
    bdtr 
    betaincinv 
 
    Notes 
    ----- 
    The computation is carried out using the inverse beta integral function 
    and the relation,:: 
 
        1 - p = betaincinv(n - k, k + 1, y). 
 
    Wrapper for the Cephes [1]_ routine `bdtri`. 
 
    References 
    ---------- 
    .. [1] Cephes Mathematical Functions Library, 
           http://www.netlib.org/cephes/ 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;bdtrik&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    bdtrik(y, n, p, out=None) 
 
    Inverse function to `bdtr` with respect to `k`. 
 
    Finds the number of successes `k` such that the sum of the terms 0 through 
    `k` of the Binomial probability density for `n` events with probability 
    `p` is equal to the given cumulative probability `y`. 
 
    Parameters 
    ---------- 
    y : array_like 
        Cumulative probability (probability of `k` or fewer successes in `n` 
        events). 
    n : array_like 
        Number of events (float). 
    p : array_like 
        Success probability (float). 
    out : ndarray, optional 
        Optional output array for the function values 
 
    Returns 
    ------- 
    k : scalar or ndarray 
        The number of successes `k` such that `bdtr(k, n, p) = y`. 
 
    See Also 
    -------- 
    bdtr 
 
    Notes 
    ----- 
    Formula 26.5.24 of [1]_ is used to reduce the binomial distribution to the 
    cumulative incomplete beta distribution. 
 
    Computation of `k` involves a search for a value that produces the desired 
    value of `y`. The search relies on the monotonicity of `y` with `k`. 
 
    Wrapper for the CDFLIB [2]_ Fortran routine `cdfbin`. 
 
    References 
    ---------- 
    .. [1] Milton Abramowitz and Irene A. Stegun, eds. 
           Handbook of Mathematical Functions with Formulas, 
           Graphs, and Mathematical Tables. New York: Dover, 1972. 
    .. [2] Barry Brown, James Lovato, and Kathy Russell, 
           CDFLIB: Library of Fortran Routines for Cumulative Distribution 
           Functions, Inverses, and Other Parameters. 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;bdtrin&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    bdtrin(k, y, p, out=None) 
 
    Inverse function to `bdtr` with respect to `n`. 
 
    Finds the number of events `n` such that the sum of the terms 0 through 
    `k` of the Binomial probability density for events with probability `p` is 
    equal to the given cumulative probability `y`. 
 
    Parameters 
    ---------- 
    k : array_like 
        Number of successes (float). 
    y : array_like 
        Cumulative probability (probability of `k` or fewer successes in `n` 
        events). 
    p : array_like 
        Success probability (float). 
    out : ndarray, optional 
        Optional output array for the function values 
 
    Returns 
    ------- 
    n : scalar or ndarray 
        The number of events `n` such that `bdtr(k, n, p) = y`. 
 
    See Also 
    -------- 
    bdtr 
 
    Notes 
    ----- 
    Formula 26.5.24 of [1]_ is used to reduce the binomial distribution to the 
    cumulative incomplete beta distribution. 
 
    Computation of `n` involves a search for a value that produces the desired 
    value of `y`. The search relies on the monotonicity of `y` with `n`. 
 
    Wrapper for the CDFLIB [2]_ Fortran routine `cdfbin`. 
 
    References 
    ---------- 
    .. [1] Milton Abramowitz and Irene A. Stegun, eds. 
           Handbook of Mathematical Functions with Formulas, 
           Graphs, and Mathematical Tables. New York: Dover, 1972. 
    .. [2] Barry Brown, James Lovato, and Kathy Russell, 
           CDFLIB: Library of Fortran Routines for Cumulative Distribution 
           Functions, Inverses, and Other Parameters. 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;btdtria&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    btdtria(p, b, x, out=None) 
 
    Inverse of `btdtr` with respect to `a`. 
 
    This is the inverse of the beta cumulative distribution function, `btdtr`, 
    considered as a function of `a`, returning the value of `a` for which 
    `btdtr(a, b, x) = p`, or 
 
    .. math:: 
        p = \int_0^x \frac{\Gamma(a + b)}{\Gamma(a)\Gamma(b)} t^{a-1} (1-t)^{b-1}\,dt 
 
    Parameters 
    ---------- 
    p : array_like 
        Cumulative probability, in [0, 1]. 
    b : array_like 
        Shape parameter (`b` &gt; 0). 
    x : array_like 
        The quantile, in [0, 1]. 
    out : ndarray, optional 
        Optional output array for the function values 
 
    Returns 
    ------- 
    a : scalar or ndarray 
        The value of the shape parameter `a` such that `btdtr(a, b, x) = p`. 
 
    See Also 
    -------- 
    btdtr : Cumulative distribution function of the beta distribution. 
    btdtri : Inverse with respect to `x`. 
    btdtrib : Inverse with respect to `b`. 
 
    Notes 
    ----- 
    Wrapper for the CDFLIB [1]_ Fortran routine `cdfbet`. 
 
    The cumulative distribution function `p` is computed using a routine by 
    DiDinato and Morris [2]_. Computation of `a` involves a search for a value 
    that produces the desired value of `p`. The search relies on the 
    monotonicity of `p` with `a`. 
 
    References 
    ---------- 
    .. [1] Barry Brown, James Lovato, and Kathy Russell, 
           CDFLIB: Library of Fortran Routines for Cumulative Distribution 
           Functions, Inverses, and Other Parameters. 
    .. [2] DiDinato, A. R. and Morris, A. H., 
           Algorithm 708: Significant Digit Computation of the Incomplete Beta 
           Function Ratios. ACM Trans. Math. Softw. 18 (1993), 360-373. 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;btdtrib&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    btdtria(a, p, x, out=None) 
 
    Inverse of `btdtr` with respect to `b`. 
 
    This is the inverse of the beta cumulative distribution function, `btdtr`, 
    considered as a function of `b`, returning the value of `b` for which 
    `btdtr(a, b, x) = p`, or 
 
    .. math:: 
        p = \int_0^x \frac{\Gamma(a + b)}{\Gamma(a)\Gamma(b)} t^{a-1} (1-t)^{b-1}\,dt 
 
    Parameters 
    ---------- 
    a : array_like 
        Shape parameter (`a` &gt; 0). 
    p : array_like 
        Cumulative probability, in [0, 1]. 
    x : array_like 
        The quantile, in [0, 1]. 
    out : ndarray, optional 
        Optional output array for the function values 
 
    Returns 
    ------- 
    b : scalar or ndarray 
        The value of the shape parameter `b` such that `btdtr(a, b, x) = p`. 
 
    See Also 
    -------- 
    btdtr : Cumulative distribution function of the beta distribution. 
    btdtri : Inverse with respect to `x`. 
    btdtria : Inverse with respect to `a`. 
 
    Notes 
    ----- 
    Wrapper for the CDFLIB [1]_ Fortran routine `cdfbet`. 
 
    The cumulative distribution function `p` is computed using a routine by 
    DiDinato and Morris [2]_. Computation of `b` involves a search for a value 
    that produces the desired value of `p`. The search relies on the 
    monotonicity of `p` with `b`. 
 
    References 
    ---------- 
    .. [1] Barry Brown, James Lovato, and Kathy Russell, 
           CDFLIB: Library of Fortran Routines for Cumulative Distribution 
           Functions, Inverses, and Other Parameters. 
    .. [2] DiDinato, A. R. and Morris, A. H., 
           Algorithm 708: Significant Digit Computation of the Incomplete Beta 
           Function Ratios. ACM Trans. Math. Softw. 18 (1993), 360-373. 
 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;besselpoly&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    besselpoly(a, lmb, nu, out=None) 
 
    Weighted integral of the Bessel function of the first kind. 
 
    Computes 
 
    .. math:: 
 
       \int_0^1 x^\lambda J_\nu(2 a x) \, dx 
 
    where :math:`J_\nu` is a Bessel function and :math:`\lambda=lmb`, 
    :math:`\nu=nu`. 
 
    Parameters 
    ---------- 
    a : array_like 
        Scale factor inside the Bessel function. 
    lmb : array_like 
        Power of `x` 
    nu : array_like 
        Order of the Bessel function. 
    out : ndarray, optional 
        Optional output array for the function results. 
 
    Returns 
    ------- 
    scalar or ndarray 
        Value of the integral. 
 
    References 
    ---------- 
    .. [1] Cephes Mathematical Functions Library, 
           http://www.netlib.org/cephes/ 
 
    Examples 
    -------- 
    Evaluate the function for one parameter set. 
 
    &gt;&gt;&gt; from scipy.special import besselpoly 
    &gt;&gt;&gt; besselpoly(1, 1, 1) 
    0.24449718372863877 
 
    Evaluate the function for different scale factors. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; factors = np.array([0., 3., 6.]) 
    &gt;&gt;&gt; besselpoly(factors, 1, 1) 
    array([ 0.        , -0.00549029,  0.00140174]) 
 
    Plot the function for varying powers, orders and scales. 
 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; fig, ax = plt.subplots() 
    &gt;&gt;&gt; powers = np.linspace(0, 10, 100) 
    &gt;&gt;&gt; orders = [1, 2, 3] 
    &gt;&gt;&gt; scales = [1, 2] 
    &gt;&gt;&gt; all_combinations = [(order, scale) for order in orders 
    ...                     for scale in scales] 
    &gt;&gt;&gt; for order, scale in all_combinations: 
    ...     ax.plot(powers, besselpoly(scale, powers, order), 
    ...             label=rf&quot;$\nu={order}, a={scale}$&quot;) 
    &gt;&gt;&gt; ax.legend() 
    &gt;&gt;&gt; ax.set_xlabel(r&quot;$\lambda$&quot;) 
    &gt;&gt;&gt; ax.set_ylabel(r&quot;$\int_0^1 x^{\lambda} J_{\nu}(2ax)\,dx$&quot;) 
    &gt;&gt;&gt; plt.show() 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;beta&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    beta(a, b, out=None) 
 
    Beta function. 
 
    This function is defined in [1]_ as 
 
    .. math:: 
 
        B(a, b) = \int_0^1 t^{a-1}(1-t)^{b-1}dt 
                = \frac{\Gamma(a)\Gamma(b)}{\Gamma(a+b)}, 
 
    where :math:`\Gamma` is the gamma function. 
 
    Parameters 
    ---------- 
    a, b : array_like 
        Real-valued arguments 
    out : ndarray, optional 
        Optional output array for the function result 
 
    Returns 
    ------- 
    scalar or ndarray 
        Value of the beta function 
 
    See Also 
    -------- 
    gamma : the gamma function 
    betainc :  the regularized incomplete beta function 
    betaln : the natural logarithm of the absolute 
             value of the beta function 
 
    References 
    ---------- 
    .. [1] NIST Digital Library of Mathematical Functions, 
           Eq. 5.12.1. https://dlmf.nist.gov/5.12 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import scipy.special as sc 
 
    The beta function relates to the gamma function by the 
    definition given above: 
 
    &gt;&gt;&gt; sc.beta(2, 3) 
    0.08333333333333333 
    &gt;&gt;&gt; sc.gamma(2)*sc.gamma(3)/sc.gamma(2 + 3) 
    0.08333333333333333 
 
    As this relationship demonstrates, the beta function 
    is symmetric: 
 
    &gt;&gt;&gt; sc.beta(1.7, 2.4) 
    0.16567527689031739 
    &gt;&gt;&gt; sc.beta(2.4, 1.7) 
    0.16567527689031739 
 
    This function satisfies :math:`B(1, b) = 1/b`: 
 
    &gt;&gt;&gt; sc.beta(1, 4) 
    0.25 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span>
    <span class="s4">&quot;betainc&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    betainc(a, b, x, out=None) 
 
    Regularized incomplete beta function. 
 
    Computes the regularized incomplete beta function, defined as [1]_: 
 
    .. math:: 
 
        I_x(a, b) = \frac{\Gamma(a+b)}{\Gamma(a)\Gamma(b)} \int_0^x 
        t^{a-1}(1-t)^{b-1}dt, 
 
    for :math:`0 \leq x \leq 1`. 
 
    This function is the cumulative distribution function for the beta 
    distribution; its range is [0, 1]. 
 
    Parameters 
    ---------- 
    a, b : array_like 
           Positive, real-valued parameters 
    x : array_like 
        Real-valued such that :math:`0 \leq x \leq 1`, 
        the upper limit of integration 
    out : ndarray, optional 
        Optional output array for the function values 
 
    Returns 
    ------- 
    scalar or ndarray 
        Value of the regularized incomplete beta function 
 
    See Also 
    -------- 
    beta : beta function 
    betaincinv : inverse of the regularized incomplete beta function 
    betaincc : complement of the regularized incomplete beta function 
    scipy.stats.beta : beta distribution 
 
    Notes 
    ----- 
    The term *regularized* in the name of this function refers to the 
    scaling of the function by the gamma function terms shown in the 
    formula.  When not qualified as *regularized*, the name *incomplete 
    beta function* often refers to just the integral expression, 
    without the gamma terms.  One can use the function `beta` from 
    `scipy.special` to get this &quot;nonregularized&quot; incomplete beta 
    function by multiplying the result of ``betainc(a, b, x)`` by 
    ``beta(a, b)``. 
 
    References 
    ---------- 
    .. [1] NIST Digital Library of Mathematical Functions 
           https://dlmf.nist.gov/8.17 
 
    Examples 
    -------- 
 
    Let :math:`B(a, b)` be the `beta` function. 
 
    &gt;&gt;&gt; import scipy.special as sc 
 
    The coefficient in terms of `gamma` is equal to 
    :math:`1/B(a, b)`. Also, when :math:`x=1` 
    the integral is equal to :math:`B(a, b)`. 
    Therefore, :math:`I_{x=1}(a, b) = 1` for any :math:`a, b`. 
 
    &gt;&gt;&gt; sc.betainc(0.2, 3.5, 1.0) 
    1.0 
 
    It satisfies 
    :math:`I_x(a, b) = x^a F(a, 1-b, a+1, x)/ (aB(a, b))`, 
    where :math:`F` is the hypergeometric function `hyp2f1`: 
 
    &gt;&gt;&gt; a, b, x = 1.4, 3.1, 0.5 
    &gt;&gt;&gt; x**a * sc.hyp2f1(a, 1 - b, a + 1, x)/(a * sc.beta(a, b)) 
    0.8148904036225295 
    &gt;&gt;&gt; sc.betainc(a, b, x) 
    0.8148904036225296 
 
    This functions satisfies the relationship 
    :math:`I_x(a, b) = 1 - I_{1-x}(b, a)`: 
 
    &gt;&gt;&gt; sc.betainc(2.2, 3.1, 0.4) 
    0.49339638807619446 
    &gt;&gt;&gt; 1 - sc.betainc(3.1, 2.2, 1 - 0.4) 
    0.49339638807619446 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>


<span class="s1">add_newdoc</span><span class="s2">(</span>
    <span class="s4">&quot;betaincc&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    betaincc(a, b, x, out=None) 
 
    Complement of the regularized incomplete beta function. 
 
    Computes the complement of the regularized incomplete beta function, 
    defined as [1]_: 
 
    .. math:: 
 
        \bar{I}_x(a, b) = 1 - I_x(a, b) 
                        = 1 - \frac{\Gamma(a+b)}{\Gamma(a)\Gamma(b)} \int_0^x 
                                  t^{a-1}(1-t)^{b-1}dt, 
 
    for :math:`0 \leq x \leq 1`. 
 
    Parameters 
    ---------- 
    a, b : array_like 
           Positive, real-valued parameters 
    x : array_like 
        Real-valued such that :math:`0 \leq x \leq 1`, 
        the upper limit of integration 
    out : ndarray, optional 
        Optional output array for the function values 
 
    Returns 
    ------- 
    scalar or ndarray 
        Value of the regularized incomplete beta function 
 
    See Also 
    -------- 
    betainc : regularized incomplete beta function 
    betaincinv : inverse of the regularized incomplete beta function 
    betainccinv : 
        inverse of the complement of the regularized incomplete beta function 
    beta : beta function 
    scipy.stats.beta : beta distribution 
 
    Notes 
    ----- 
    .. versionadded:: 1.11.0 
 
    References 
    ---------- 
    .. [1] NIST Digital Library of Mathematical Functions 
           https://dlmf.nist.gov/8.17 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.special import betaincc, betainc 
 
    The naive calculation ``1 - betainc(a, b, x)`` loses precision when 
    the values of ``betainc(a, b, x)`` are close to 1: 
 
    &gt;&gt;&gt; 1 - betainc(0.5, 8, [0.9, 0.99, 0.999]) 
    array([2.0574632e-09, 0.0000000e+00, 0.0000000e+00]) 
 
    By using ``betaincc``, we get the correct values: 
 
    &gt;&gt;&gt; betaincc(0.5, 8, [0.9, 0.99, 0.999]) 
    array([2.05746321e-09, 1.97259354e-17, 1.96467954e-25]) 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span>
    <span class="s4">&quot;betaincinv&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    betaincinv(a, b, y, out=None) 
 
    Inverse of the regularized incomplete beta function. 
 
    Computes :math:`x` such that: 
 
    .. math:: 
 
        y = I_x(a, b) = \frac{\Gamma(a+b)}{\Gamma(a)\Gamma(b)} 
        \int_0^x t^{a-1}(1-t)^{b-1}dt, 
 
    where :math:`I_x` is the normalized incomplete beta function `betainc` 
    and :math:`\Gamma` is the `gamma` function [1]_. 
 
    Parameters 
    ---------- 
    a, b : array_like 
        Positive, real-valued parameters 
    y : array_like 
        Real-valued input 
    out : ndarray, optional 
        Optional output array for function values 
 
    Returns 
    ------- 
    scalar or ndarray 
        Value of the inverse of the regularized incomplete beta function 
 
    See Also 
    -------- 
    betainc : regularized incomplete beta function 
    gamma : gamma function 
 
    References 
    ---------- 
    .. [1] NIST Digital Library of Mathematical Functions 
           https://dlmf.nist.gov/8.17 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import scipy.special as sc 
 
    This function is the inverse of `betainc` for fixed 
    values of :math:`a` and :math:`b`. 
 
    &gt;&gt;&gt; a, b = 1.2, 3.1 
    &gt;&gt;&gt; y = sc.betainc(a, b, 0.2) 
    &gt;&gt;&gt; sc.betaincinv(a, b, y) 
    0.2 
    &gt;&gt;&gt; 
    &gt;&gt;&gt; a, b = 7.5, 0.4 
    &gt;&gt;&gt; x = sc.betaincinv(a, b, 0.5) 
    &gt;&gt;&gt; sc.betainc(a, b, x) 
    0.5 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>


<span class="s1">add_newdoc</span><span class="s2">(</span>
    <span class="s4">&quot;betainccinv&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    betainccinv(a, b, y, out=None) 
 
    Inverse of the complemented regularized incomplete beta function. 
 
    Computes :math:`x` such that: 
 
    .. math:: 
 
        y = 1 - I_x(a, b) = 1 - \frac{\Gamma(a+b)}{\Gamma(a)\Gamma(b)} 
        \int_0^x t^{a-1}(1-t)^{b-1}dt, 
 
    where :math:`I_x` is the normalized incomplete beta function `betainc` 
    and :math:`\Gamma` is the `gamma` function [1]_. 
 
    Parameters 
    ---------- 
    a, b : array_like 
        Positive, real-valued parameters 
    y : array_like 
        Real-valued input 
    out : ndarray, optional 
        Optional output array for function values 
 
    Returns 
    ------- 
    scalar or ndarray 
        Value of the inverse of the regularized incomplete beta function 
 
    See Also 
    -------- 
    betainc : regularized incomplete beta function 
    betaincc : complement of the regularized incomplete beta function 
 
    Notes 
    ----- 
    .. versionadded:: 1.11.0 
 
    References 
    ---------- 
    .. [1] NIST Digital Library of Mathematical Functions 
           https://dlmf.nist.gov/8.17 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.special import betainccinv, betaincc 
 
    This function is the inverse of `betaincc` for fixed 
    values of :math:`a` and :math:`b`. 
 
    &gt;&gt;&gt; a, b = 1.2, 3.1 
    &gt;&gt;&gt; y = betaincc(a, b, 0.2) 
    &gt;&gt;&gt; betainccinv(a, b, y) 
    0.2 
 
    &gt;&gt;&gt; a, b = 7, 2.5 
    &gt;&gt;&gt; x = betainccinv(a, b, 0.875) 
    &gt;&gt;&gt; betaincc(a, b, x) 
    0.875 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;betaln&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    betaln(a, b, out=None) 
 
    Natural logarithm of absolute value of beta function. 
 
    Computes ``ln(abs(beta(a, b)))``. 
 
    Parameters 
    ---------- 
    a, b : array_like 
        Positive, real-valued parameters 
    out : ndarray, optional 
        Optional output array for function values 
 
    Returns 
    ------- 
    scalar or ndarray 
        Value of the betaln function 
 
    See Also 
    -------- 
    gamma : the gamma function 
    betainc :  the regularized incomplete beta function 
    beta : the beta function 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.special import betaln, beta 
 
    Verify that, for moderate values of ``a`` and ``b``, ``betaln(a, b)`` 
    is the same as ``log(beta(a, b))``: 
 
    &gt;&gt;&gt; betaln(3, 4) 
    -4.0943445622221 
 
    &gt;&gt;&gt; np.log(beta(3, 4)) 
    -4.0943445622221 
 
    In the following ``beta(a, b)`` underflows to 0, so we can't compute 
    the logarithm of the actual value. 
 
    &gt;&gt;&gt; a = 400 
    &gt;&gt;&gt; b = 900 
    &gt;&gt;&gt; beta(a, b) 
    0.0 
 
    We can compute the logarithm of ``beta(a, b)`` by using `betaln`: 
 
    &gt;&gt;&gt; betaln(a, b) 
    -804.3069951764146 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;boxcox&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    boxcox(x, lmbda, out=None) 
 
    Compute the Box-Cox transformation. 
 
    The Box-Cox transformation is:: 
 
        y = (x**lmbda - 1) / lmbda  if lmbda != 0 
            log(x)                  if lmbda == 0 
 
    Returns `nan` if ``x &lt; 0``. 
    Returns `-inf` if ``x == 0`` and ``lmbda &lt; 0``. 
 
    Parameters 
    ---------- 
    x : array_like 
        Data to be transformed. 
    lmbda : array_like 
        Power parameter of the Box-Cox transform. 
    out : ndarray, optional 
        Optional output array for the function values 
 
    Returns 
    ------- 
    y : scalar or ndarray 
        Transformed data. 
 
    Notes 
    ----- 
 
    .. versionadded:: 0.14.0 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.special import boxcox 
    &gt;&gt;&gt; boxcox([1, 4, 10], 2.5) 
    array([   0.        ,   12.4       ,  126.09110641]) 
    &gt;&gt;&gt; boxcox(2, [0, 1, 2]) 
    array([ 0.69314718,  1.        ,  1.5       ]) 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;boxcox1p&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    boxcox1p(x, lmbda, out=None) 
 
    Compute the Box-Cox transformation of 1 + `x`. 
 
    The Box-Cox transformation computed by `boxcox1p` is:: 
 
        y = ((1+x)**lmbda - 1) / lmbda  if lmbda != 0 
            log(1+x)                    if lmbda == 0 
 
    Returns `nan` if ``x &lt; -1``. 
    Returns `-inf` if ``x == -1`` and ``lmbda &lt; 0``. 
 
    Parameters 
    ---------- 
    x : array_like 
        Data to be transformed. 
    lmbda : array_like 
        Power parameter of the Box-Cox transform. 
    out : ndarray, optional 
        Optional output array for the function values 
 
    Returns 
    ------- 
    y : scalar or ndarray 
        Transformed data. 
 
    Notes 
    ----- 
 
    .. versionadded:: 0.14.0 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.special import boxcox1p 
    &gt;&gt;&gt; boxcox1p(1e-4, [0, 0.5, 1]) 
    array([  9.99950003e-05,   9.99975001e-05,   1.00000000e-04]) 
    &gt;&gt;&gt; boxcox1p([0.01, 0.1], 0.25) 
    array([ 0.00996272,  0.09645476]) 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;inv_boxcox&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    inv_boxcox(y, lmbda, out=None) 
 
    Compute the inverse of the Box-Cox transformation. 
 
    Find ``x`` such that:: 
 
        y = (x**lmbda - 1) / lmbda  if lmbda != 0 
            log(x)                  if lmbda == 0 
 
    Parameters 
    ---------- 
    y : array_like 
        Data to be transformed. 
    lmbda : array_like 
        Power parameter of the Box-Cox transform. 
    out : ndarray, optional 
        Optional output array for the function values 
 
    Returns 
    ------- 
    x : scalar or ndarray 
        Transformed data. 
 
    Notes 
    ----- 
 
    .. versionadded:: 0.16.0 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.special import boxcox, inv_boxcox 
    &gt;&gt;&gt; y = boxcox([1, 4, 10], 2.5) 
    &gt;&gt;&gt; inv_boxcox(y, 2.5) 
    array([1., 4., 10.]) 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;inv_boxcox1p&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    inv_boxcox1p(y, lmbda, out=None) 
 
    Compute the inverse of the Box-Cox transformation. 
 
    Find ``x`` such that:: 
 
        y = ((1+x)**lmbda - 1) / lmbda  if lmbda != 0 
            log(1+x)                    if lmbda == 0 
 
    Parameters 
    ---------- 
    y : array_like 
        Data to be transformed. 
    lmbda : array_like 
        Power parameter of the Box-Cox transform. 
    out : ndarray, optional 
        Optional output array for the function values 
 
    Returns 
    ------- 
    x : scalar or ndarray 
        Transformed data. 
 
    Notes 
    ----- 
 
    .. versionadded:: 0.16.0 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.special import boxcox1p, inv_boxcox1p 
    &gt;&gt;&gt; y = boxcox1p([1, 4, 10], 2.5) 
    &gt;&gt;&gt; inv_boxcox1p(y, 2.5) 
    array([1., 4., 10.]) 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;btdtr&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    btdtr(a, b, x, out=None) 
 
    Cumulative distribution function of the beta distribution. 
 
    Returns the integral from zero to `x` of the beta probability density 
    function, 
 
    .. math:: 
        I = \int_0^x \frac{\Gamma(a + b)}{\Gamma(a)\Gamma(b)} t^{a-1} (1-t)^{b-1}\,dt 
 
    where :math:`\Gamma` is the gamma function. 
 
    .. deprecated:: 1.12.0 
        This function is deprecated and will be removed from SciPy 1.14.0. 
        Use `scipy.special.betainc` instead. 
 
    Parameters 
    ---------- 
    a : array_like 
        Shape parameter (a &gt; 0). 
    b : array_like 
        Shape parameter (b &gt; 0). 
    x : array_like 
        Upper limit of integration, in [0, 1]. 
    out : ndarray, optional 
        Optional output array for the function values 
 
    Returns 
    ------- 
    I : scalar or ndarray 
        Cumulative distribution function of the beta distribution with 
        parameters `a` and `b` at `x`. 
 
    See Also 
    -------- 
    betainc 
 
    Notes 
    ----- 
    This function is identical to the incomplete beta integral function 
    `betainc`. 
 
    Wrapper for the Cephes [1]_ routine `btdtr`. 
 
    References 
    ---------- 
    .. [1] Cephes Mathematical Functions Library, 
           http://www.netlib.org/cephes/ 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;btdtri&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    btdtri(a, b, p, out=None) 
 
    The `p`-th quantile of the beta distribution. 
 
    This function is the inverse of the beta cumulative distribution function, 
    `btdtr`, returning the value of `x` for which `btdtr(a, b, x) = p`, or 
 
    .. math:: 
        p = \int_0^x \frac{\Gamma(a + b)}{\Gamma(a)\Gamma(b)} t^{a-1} (1-t)^{b-1}\,dt 
 
    .. deprecated:: 1.12.0 
        This function is deprecated and will be removed from SciPy 1.14.0. 
        Use `scipy.special.betaincinv` instead. 
 
    Parameters 
    ---------- 
    a : array_like 
        Shape parameter (`a` &gt; 0). 
    b : array_like 
        Shape parameter (`b` &gt; 0). 
    p : array_like 
        Cumulative probability, in [0, 1]. 
    out : ndarray, optional 
        Optional output array for the function values 
 
    Returns 
    ------- 
    x : scalar or ndarray 
        The quantile corresponding to `p`. 
 
    See Also 
    -------- 
    betaincinv 
    btdtr 
 
    Notes 
    ----- 
    The value of `x` is found by interval halving or Newton iterations. 
 
    Wrapper for the Cephes [1]_ routine `incbi`, which solves the equivalent 
    problem of finding the inverse of the incomplete beta integral. 
 
    References 
    ---------- 
    .. [1] Cephes Mathematical Functions Library, 
           http://www.netlib.org/cephes/ 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;cbrt&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    cbrt(x, out=None) 
 
    Element-wise cube root of `x`. 
 
    Parameters 
    ---------- 
    x : array_like 
        `x` must contain real numbers. 
    out : ndarray, optional 
        Optional output array for the function values 
 
    Returns 
    ------- 
    scalar or ndarray 
        The cube root of each value in `x`. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.special import cbrt 
 
    &gt;&gt;&gt; cbrt(8) 
    2.0 
    &gt;&gt;&gt; cbrt([-8, -3, 0.125, 1.331]) 
    array([-2.        , -1.44224957,  0.5       ,  1.1       ]) 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;chdtr&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    chdtr(v, x, out=None) 
 
    Chi square cumulative distribution function. 
 
    Returns the area under the left tail (from 0 to `x`) of the Chi 
    square probability density function with `v` degrees of freedom: 
 
    .. math:: 
 
        \frac{1}{2^{v/2} \Gamma(v/2)} \int_0^x t^{v/2 - 1} e^{-t/2} dt 
 
    Here :math:`\Gamma` is the Gamma function; see `gamma`. This 
    integral can be expressed in terms of the regularized lower 
    incomplete gamma function `gammainc` as 
    ``gammainc(v / 2, x / 2)``. [1]_ 
 
    Parameters 
    ---------- 
    v : array_like 
        Degrees of freedom. 
    x : array_like 
        Upper bound of the integral. 
    out : ndarray, optional 
        Optional output array for the function results. 
 
    Returns 
    ------- 
    scalar or ndarray 
        Values of the cumulative distribution function. 
 
    See Also 
    -------- 
    chdtrc, chdtri, chdtriv, gammainc 
 
    References 
    ---------- 
    .. [1] Chi-Square distribution, 
        https://www.itl.nist.gov/div898/handbook/eda/section3/eda3666.htm 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; import scipy.special as sc 
 
    It can be expressed in terms of the regularized lower incomplete 
    gamma function. 
 
    &gt;&gt;&gt; v = 1 
    &gt;&gt;&gt; x = np.arange(4) 
    &gt;&gt;&gt; sc.chdtr(v, x) 
    array([0.        , 0.68268949, 0.84270079, 0.91673548]) 
    &gt;&gt;&gt; sc.gammainc(v / 2, x / 2) 
    array([0.        , 0.68268949, 0.84270079, 0.91673548]) 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;chdtrc&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    chdtrc(v, x, out=None) 
 
    Chi square survival function. 
 
    Returns the area under the right hand tail (from `x` to infinity) 
    of the Chi square probability density function with `v` degrees of 
    freedom: 
 
    .. math:: 
 
        \frac{1}{2^{v/2} \Gamma(v/2)} \int_x^\infty t^{v/2 - 1} e^{-t/2} dt 
 
    Here :math:`\Gamma` is the Gamma function; see `gamma`. This 
    integral can be expressed in terms of the regularized upper 
    incomplete gamma function `gammaincc` as 
    ``gammaincc(v / 2, x / 2)``. [1]_ 
 
    Parameters 
    ---------- 
    v : array_like 
        Degrees of freedom. 
    x : array_like 
        Lower bound of the integral. 
    out : ndarray, optional 
        Optional output array for the function results. 
 
    Returns 
    ------- 
    scalar or ndarray 
        Values of the survival function. 
 
    See Also 
    -------- 
    chdtr, chdtri, chdtriv, gammaincc 
 
    References 
    ---------- 
    .. [1] Chi-Square distribution, 
        https://www.itl.nist.gov/div898/handbook/eda/section3/eda3666.htm 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; import scipy.special as sc 
 
    It can be expressed in terms of the regularized upper incomplete 
    gamma function. 
 
    &gt;&gt;&gt; v = 1 
    &gt;&gt;&gt; x = np.arange(4) 
    &gt;&gt;&gt; sc.chdtrc(v, x) 
    array([1.        , 0.31731051, 0.15729921, 0.08326452]) 
    &gt;&gt;&gt; sc.gammaincc(v / 2, x / 2) 
    array([1.        , 0.31731051, 0.15729921, 0.08326452]) 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;chdtri&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    chdtri(v, p, out=None) 
 
    Inverse to `chdtrc` with respect to `x`. 
 
    Returns `x` such that ``chdtrc(v, x) == p``. 
 
    Parameters 
    ---------- 
    v : array_like 
        Degrees of freedom. 
    p : array_like 
        Probability. 
    out : ndarray, optional 
        Optional output array for the function results. 
 
    Returns 
    ------- 
    x : scalar or ndarray 
        Value so that the probability a Chi square random variable 
        with `v` degrees of freedom is greater than `x` equals `p`. 
 
    See Also 
    -------- 
    chdtrc, chdtr, chdtriv 
 
    References 
    ---------- 
    .. [1] Chi-Square distribution, 
        https://www.itl.nist.gov/div898/handbook/eda/section3/eda3666.htm 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import scipy.special as sc 
 
    It inverts `chdtrc`. 
 
    &gt;&gt;&gt; v, p = 1, 0.3 
    &gt;&gt;&gt; sc.chdtrc(v, sc.chdtri(v, p)) 
    0.3 
    &gt;&gt;&gt; x = 1 
    &gt;&gt;&gt; sc.chdtri(v, sc.chdtrc(v, x)) 
    1.0 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;chdtriv&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    chdtriv(p, x, out=None) 
 
    Inverse to `chdtr` with respect to `v`. 
 
    Returns `v` such that ``chdtr(v, x) == p``. 
 
    Parameters 
    ---------- 
    p : array_like 
        Probability that the Chi square random variable is less than 
        or equal to `x`. 
    x : array_like 
        Nonnegative input. 
    out : ndarray, optional 
        Optional output array for the function results. 
 
    Returns 
    ------- 
    scalar or ndarray 
        Degrees of freedom. 
 
    See Also 
    -------- 
    chdtr, chdtrc, chdtri 
 
    References 
    ---------- 
    .. [1] Chi-Square distribution, 
        https://www.itl.nist.gov/div898/handbook/eda/section3/eda3666.htm 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import scipy.special as sc 
 
    It inverts `chdtr`. 
 
    &gt;&gt;&gt; p, x = 0.5, 1 
    &gt;&gt;&gt; sc.chdtr(sc.chdtriv(p, x), x) 
    0.5000000000202172 
    &gt;&gt;&gt; v = 1 
    &gt;&gt;&gt; sc.chdtriv(sc.chdtr(v, x), v) 
    1.0000000000000013 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;chndtr&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    chndtr(x, df, nc, out=None) 
 
    Non-central chi square cumulative distribution function 
 
    The cumulative distribution function is given by: 
 
    .. math:: 
 
        P(\chi^{\prime 2} \vert \nu, \lambda) =\sum_{j=0}^{\infty} 
        e^{-\lambda /2} 
        \frac{(\lambda /2)^j}{j!} P(\chi^{\prime 2} \vert \nu + 2j), 
 
    where :math:`\nu &gt; 0` is the degrees of freedom (``df``) and 
    :math:`\lambda \geq 0` is the non-centrality parameter (``nc``). 
 
    Parameters 
    ---------- 
    x : array_like 
        Upper bound of the integral; must satisfy ``x &gt;= 0`` 
    df : array_like 
        Degrees of freedom; must satisfy ``df &gt; 0`` 
    nc : array_like 
        Non-centrality parameter; must satisfy ``nc &gt;= 0`` 
    out : ndarray, optional 
        Optional output array for the function results 
 
    Returns 
    ------- 
    x : scalar or ndarray 
        Value of the non-central chi square cumulative distribution function. 
 
    See Also 
    -------- 
    chndtrix, chndtridf, chndtrinc 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;chndtrix&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    chndtrix(p, df, nc, out=None) 
 
    Inverse to `chndtr` vs `x` 
 
    Calculated using a search to find a value for `x` that produces the 
    desired value of `p`. 
 
    Parameters 
    ---------- 
    p : array_like 
        Probability; must satisfy ``0 &lt;= p &lt; 1`` 
    df : array_like 
        Degrees of freedom; must satisfy ``df &gt; 0`` 
    nc : array_like 
        Non-centrality parameter; must satisfy ``nc &gt;= 0`` 
    out : ndarray, optional 
        Optional output array for the function results 
 
    Returns 
    ------- 
    x : scalar or ndarray 
        Value so that the probability a non-central Chi square random variable 
        with `df` degrees of freedom and non-centrality, `nc`, is greater than 
        `x` equals `p`. 
 
    See Also 
    -------- 
    chndtr, chndtridf, chndtrinc 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;chndtridf&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    chndtridf(x, p, nc, out=None) 
 
    Inverse to `chndtr` vs `df` 
 
    Calculated using a search to find a value for `df` that produces the 
    desired value of `p`. 
 
    Parameters 
    ---------- 
    x : array_like 
        Upper bound of the integral; must satisfy ``x &gt;= 0`` 
    p : array_like 
        Probability; must satisfy ``0 &lt;= p &lt; 1`` 
    nc : array_like 
        Non-centrality parameter; must satisfy ``nc &gt;= 0`` 
    out : ndarray, optional 
        Optional output array for the function results 
 
    Returns 
    ------- 
    df : scalar or ndarray 
        Degrees of freedom 
 
    See Also 
    -------- 
    chndtr, chndtrix, chndtrinc 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;chndtrinc&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    chndtrinc(x, df, p, out=None) 
 
    Inverse to `chndtr` vs `nc` 
 
    Calculated using a search to find a value for `df` that produces the 
    desired value of `p`. 
 
    Parameters 
    ---------- 
    x : array_like 
        Upper bound of the integral; must satisfy ``x &gt;= 0`` 
    df : array_like 
        Degrees of freedom; must satisfy ``df &gt; 0`` 
    p : array_like 
        Probability; must satisfy ``0 &lt;= p &lt; 1`` 
    out : ndarray, optional 
        Optional output array for the function results 
 
    Returns 
    ------- 
    nc : scalar or ndarray 
        Non-centrality 
 
    See Also 
    -------- 
    chndtr, chndtrix, chndtrinc 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;cosdg&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    cosdg(x, out=None) 
 
    Cosine of the angle `x` given in degrees. 
 
    Parameters 
    ---------- 
    x : array_like 
        Angle, given in degrees. 
    out : ndarray, optional 
        Optional output array for the function results. 
 
    Returns 
    ------- 
    scalar or ndarray 
        Cosine of the input. 
 
    See Also 
    -------- 
    sindg, tandg, cotdg 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; import scipy.special as sc 
 
    It is more accurate than using cosine directly. 
 
    &gt;&gt;&gt; x = 90 + 180 * np.arange(3) 
    &gt;&gt;&gt; sc.cosdg(x) 
    array([-0.,  0., -0.]) 
    &gt;&gt;&gt; np.cos(x * np.pi / 180) 
    array([ 6.1232340e-17, -1.8369702e-16,  3.0616170e-16]) 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;cosm1&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    cosm1(x, out=None) 
 
    cos(x) - 1 for use when `x` is near zero. 
 
    Parameters 
    ---------- 
    x : array_like 
        Real valued argument. 
    out : ndarray, optional 
        Optional output array for the function results. 
 
    Returns 
    ------- 
    scalar or ndarray 
        Values of ``cos(x) - 1``. 
 
    See Also 
    -------- 
    expm1, log1p 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; import scipy.special as sc 
 
    It is more accurate than computing ``cos(x) - 1`` directly for 
    ``x`` around 0. 
 
    &gt;&gt;&gt; x = 1e-30 
    &gt;&gt;&gt; np.cos(x) - 1 
    0.0 
    &gt;&gt;&gt; sc.cosm1(x) 
    -5.0000000000000005e-61 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;cotdg&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    cotdg(x, out=None) 
 
    Cotangent of the angle `x` given in degrees. 
 
    Parameters 
    ---------- 
    x : array_like 
        Angle, given in degrees. 
    out : ndarray, optional 
        Optional output array for the function results. 
 
    Returns 
    ------- 
    scalar or ndarray 
        Cotangent at the input. 
 
    See Also 
    -------- 
    sindg, cosdg, tandg 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; import scipy.special as sc 
 
    It is more accurate than using cotangent directly. 
 
    &gt;&gt;&gt; x = 90 + 180 * np.arange(3) 
    &gt;&gt;&gt; sc.cotdg(x) 
    array([0., 0., 0.]) 
    &gt;&gt;&gt; 1 / np.tan(x * np.pi / 180) 
    array([6.1232340e-17, 1.8369702e-16, 3.0616170e-16]) 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;dawsn&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    dawsn(x, out=None) 
 
    Dawson's integral. 
 
    Computes:: 
 
        exp(-x**2) * integral(exp(t**2), t=0..x). 
 
    Parameters 
    ---------- 
    x : array_like 
        Function parameter. 
    out : ndarray, optional 
        Optional output array for the function values 
 
    Returns 
    ------- 
    y : scalar or ndarray 
        Value of the integral. 
 
    See Also 
    -------- 
    wofz, erf, erfc, erfcx, erfi 
 
    References 
    ---------- 
    .. [1] Steven G. Johnson, Faddeeva W function implementation. 
       http://ab-initio.mit.edu/Faddeeva 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import special 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; x = np.linspace(-15, 15, num=1000) 
    &gt;&gt;&gt; plt.plot(x, special.dawsn(x)) 
    &gt;&gt;&gt; plt.xlabel('$x$') 
    &gt;&gt;&gt; plt.ylabel('$dawsn(x)$') 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;ellipe&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    ellipe(m, out=None) 
 
    Complete elliptic integral of the second kind 
 
    This function is defined as 
 
    .. math:: E(m) = \int_0^{\pi/2} [1 - m \sin(t)^2]^{1/2} dt 
 
    Parameters 
    ---------- 
    m : array_like 
        Defines the parameter of the elliptic integral. 
    out : ndarray, optional 
        Optional output array for the function values 
 
    Returns 
    ------- 
    E : scalar or ndarray 
        Value of the elliptic integral. 
 
    See Also 
    -------- 
    ellipkm1 : Complete elliptic integral of the first kind, near `m` = 1 
    ellipk : Complete elliptic integral of the first kind 
    ellipkinc : Incomplete elliptic integral of the first kind 
    ellipeinc : Incomplete elliptic integral of the second kind 
    elliprd : Symmetric elliptic integral of the second kind. 
    elliprg : Completely-symmetric elliptic integral of the second kind. 
 
    Notes 
    ----- 
    Wrapper for the Cephes [1]_ routine `ellpe`. 
 
    For `m &gt; 0` the computation uses the approximation, 
 
    .. math:: E(m) \approx P(1-m) - (1-m) \log(1-m) Q(1-m), 
 
    where :math:`P` and :math:`Q` are tenth-order polynomials.  For 
    `m &lt; 0`, the relation 
 
    .. math:: E(m) = E(m/(m - 1)) \sqrt(1-m) 
 
    is used. 
 
    The parameterization in terms of :math:`m` follows that of section 
    17.2 in [2]_. Other parameterizations in terms of the 
    complementary parameter :math:`1 - m`, modular angle 
    :math:`\sin^2(\alpha) = m`, or modulus :math:`k^2 = m` are also 
    used, so be careful that you choose the correct parameter. 
 
    The Legendre E integral is related to Carlson's symmetric R_D or R_G 
    functions in multiple ways [3]_. For example, 
 
    .. math:: E(m) = 2 R_G(0, 1-k^2, 1) . 
 
    References 
    ---------- 
    .. [1] Cephes Mathematical Functions Library, 
           http://www.netlib.org/cephes/ 
    .. [2] Milton Abramowitz and Irene A. Stegun, eds. 
           Handbook of Mathematical Functions with Formulas, 
           Graphs, and Mathematical Tables. New York: Dover, 1972. 
    .. [3] NIST Digital Library of Mathematical 
           Functions. http://dlmf.nist.gov/, Release 1.0.28 of 
           2020-09-15. See Sec. 19.25(i) https://dlmf.nist.gov/19.25#i 
 
    Examples 
    -------- 
    This function is used in finding the circumference of an 
    ellipse with semi-major axis `a` and semi-minor axis `b`. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import special 
 
    &gt;&gt;&gt; a = 3.5 
    &gt;&gt;&gt; b = 2.1 
    &gt;&gt;&gt; e_sq = 1.0 - b**2/a**2  # eccentricity squared 
 
    Then the circumference is found using the following: 
 
    &gt;&gt;&gt; C = 4*a*special.ellipe(e_sq)  # circumference formula 
    &gt;&gt;&gt; C 
    17.868899204378693 
 
    When `a` and `b` are the same (meaning eccentricity is 0), 
    this reduces to the circumference of a circle. 
 
    &gt;&gt;&gt; 4*a*special.ellipe(0.0)  # formula for ellipse with a = b 
    21.991148575128552 
    &gt;&gt;&gt; 2*np.pi*a  # formula for circle of radius a 
    21.991148575128552 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;ellipeinc&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    ellipeinc(phi, m, out=None) 
 
    Incomplete elliptic integral of the second kind 
 
    This function is defined as 
 
    .. math:: E(\phi, m) = \int_0^{\phi} [1 - m \sin(t)^2]^{1/2} dt 
 
    Parameters 
    ---------- 
    phi : array_like 
        amplitude of the elliptic integral. 
    m : array_like 
        parameter of the elliptic integral. 
    out : ndarray, optional 
        Optional output array for the function values 
 
    Returns 
    ------- 
    E : scalar or ndarray 
        Value of the elliptic integral. 
 
    See Also 
    -------- 
    ellipkm1 : Complete elliptic integral of the first kind, near `m` = 1 
    ellipk : Complete elliptic integral of the first kind 
    ellipkinc : Incomplete elliptic integral of the first kind 
    ellipe : Complete elliptic integral of the second kind 
    elliprd : Symmetric elliptic integral of the second kind. 
    elliprf : Completely-symmetric elliptic integral of the first kind. 
    elliprg : Completely-symmetric elliptic integral of the second kind. 
 
    Notes 
    ----- 
    Wrapper for the Cephes [1]_ routine `ellie`. 
 
    Computation uses arithmetic-geometric means algorithm. 
 
    The parameterization in terms of :math:`m` follows that of section 
    17.2 in [2]_. Other parameterizations in terms of the 
    complementary parameter :math:`1 - m`, modular angle 
    :math:`\sin^2(\alpha) = m`, or modulus :math:`k^2 = m` are also 
    used, so be careful that you choose the correct parameter. 
 
    The Legendre E incomplete integral can be related to combinations 
    of Carlson's symmetric integrals R_D, R_F, and R_G in multiple 
    ways [3]_. For example, with :math:`c = \csc^2\phi`, 
 
    .. math:: 
      E(\phi, m) = R_F(c-1, c-k^2, c) 
        - \frac{1}{3} k^2 R_D(c-1, c-k^2, c) . 
 
    References 
    ---------- 
    .. [1] Cephes Mathematical Functions Library, 
           http://www.netlib.org/cephes/ 
    .. [2] Milton Abramowitz and Irene A. Stegun, eds. 
           Handbook of Mathematical Functions with Formulas, 
           Graphs, and Mathematical Tables. New York: Dover, 1972. 
    .. [3] NIST Digital Library of Mathematical 
           Functions. http://dlmf.nist.gov/, Release 1.0.28 of 
           2020-09-15. See Sec. 19.25(i) https://dlmf.nist.gov/19.25#i 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;ellipj&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    ellipj(u, m, out=None) 
 
    Jacobian elliptic functions 
 
    Calculates the Jacobian elliptic functions of parameter `m` between 
    0 and 1, and real argument `u`. 
 
    Parameters 
    ---------- 
    m : array_like 
        Parameter. 
    u : array_like 
        Argument. 
    out : tuple of ndarray, optional 
        Optional output arrays for the function values 
 
    Returns 
    ------- 
    sn, cn, dn, ph : 4-tuple of scalar or ndarray 
        The returned functions:: 
 
            sn(u|m), cn(u|m), dn(u|m) 
 
        The value `ph` is such that if `u = ellipkinc(ph, m)`, 
        then `sn(u|m) = sin(ph)` and `cn(u|m) = cos(ph)`. 
 
    See Also 
    -------- 
    ellipk : Complete elliptic integral of the first kind 
    ellipkinc : Incomplete elliptic integral of the first kind 
 
    Notes 
    ----- 
    Wrapper for the Cephes [1]_ routine `ellpj`. 
 
    These functions are periodic, with quarter-period on the real axis 
    equal to the complete elliptic integral `ellipk(m)`. 
 
    Relation to incomplete elliptic integral: If `u = ellipkinc(phi,m)`, then 
    `sn(u|m) = sin(phi)`, and `cn(u|m) = cos(phi)`. The `phi` is called 
    the amplitude of `u`. 
 
    Computation is by means of the arithmetic-geometric mean algorithm, 
    except when `m` is within 1e-9 of 0 or 1. In the latter case with `m` 
    close to 1, the approximation applies only for `phi &lt; pi/2`. 
 
    References 
    ---------- 
    .. [1] Cephes Mathematical Functions Library, 
           http://www.netlib.org/cephes/ 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;ellipkm1&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    ellipkm1(p, out=None) 
 
    Complete elliptic integral of the first kind around `m` = 1 
 
    This function is defined as 
 
    .. math:: K(p) = </span><span class="s3">\\</span><span class="s4">int_0^{</span><span class="s3">\\</span><span class="s4">pi/2} [1 - m </span><span class="s3">\\</span><span class="s4">sin(t)^2]^{-1/2} dt 
 
    where `m = 1 - p`. 
 
    Parameters 
    ---------- 
    p : array_like 
        Defines the parameter of the elliptic integral as `m = 1 - p`. 
    out : ndarray, optional 
        Optional output array for the function values 
 
    Returns 
    ------- 
    K : scalar or ndarray 
        Value of the elliptic integral. 
 
    See Also 
    -------- 
    ellipk : Complete elliptic integral of the first kind 
    ellipkinc : Incomplete elliptic integral of the first kind 
    ellipe : Complete elliptic integral of the second kind 
    ellipeinc : Incomplete elliptic integral of the second kind 
    elliprf : Completely-symmetric elliptic integral of the first kind. 
 
    Notes 
    ----- 
    Wrapper for the Cephes [1]_ routine `ellpk`. 
 
    For `p &lt;= 1`, computation uses the approximation, 
 
    .. math:: K(p) </span><span class="s3">\\</span><span class="s4">approx P(p) - </span><span class="s3">\\</span><span class="s4">log(p) Q(p), 
 
    where :math:`P` and :math:`Q` are tenth-order polynomials.  The 
    argument `p` is used internally rather than `m` so that the logarithmic 
    singularity at `m = 1` will be shifted to the origin; this preserves 
    maximum accuracy.  For `p &gt; 1`, the identity 
 
    .. math:: K(p) = K(1/p)/</span><span class="s3">\\</span><span class="s4">sqrt(p) 
 
    is used. 
 
    References 
    ---------- 
    .. [1] Cephes Mathematical Functions Library, 
           http://www.netlib.org/cephes/ 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;ellipk&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    ellipk(m, out=None) 
 
    Complete elliptic integral of the first kind. 
 
    This function is defined as 
 
    .. math:: K(m) = \int_0^{\pi/2} [1 - m \sin(t)^2]^{-1/2} dt 
 
    Parameters 
    ---------- 
    m : array_like 
        The parameter of the elliptic integral. 
    out : ndarray, optional 
        Optional output array for the function values 
 
    Returns 
    ------- 
    K : scalar or ndarray 
        Value of the elliptic integral. 
 
    See Also 
    -------- 
    ellipkm1 : Complete elliptic integral of the first kind around m = 1 
    ellipkinc : Incomplete elliptic integral of the first kind 
    ellipe : Complete elliptic integral of the second kind 
    ellipeinc : Incomplete elliptic integral of the second kind 
    elliprf : Completely-symmetric elliptic integral of the first kind. 
 
    Notes 
    ----- 
    For more precision around point m = 1, use `ellipkm1`, which this 
    function calls. 
 
    The parameterization in terms of :math:`m` follows that of section 
    17.2 in [1]_. Other parameterizations in terms of the 
    complementary parameter :math:`1 - m`, modular angle 
    :math:`\sin^2(\alpha) = m`, or modulus :math:`k^2 = m` are also 
    used, so be careful that you choose the correct parameter. 
 
    The Legendre K integral is related to Carlson's symmetric R_F 
    function by [2]_: 
 
    .. math:: K(m) = R_F(0, 1-k^2, 1) . 
 
    References 
    ---------- 
    .. [1] Milton Abramowitz and Irene A. Stegun, eds. 
           Handbook of Mathematical Functions with Formulas, 
           Graphs, and Mathematical Tables. New York: Dover, 1972. 
    .. [2] NIST Digital Library of Mathematical 
           Functions. http://dlmf.nist.gov/, Release 1.0.28 of 
           2020-09-15. See Sec. 19.25(i) https://dlmf.nist.gov/19.25#i 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;ellipkinc&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    ellipkinc(phi, m, out=None) 
 
    Incomplete elliptic integral of the first kind 
 
    This function is defined as 
 
    .. math:: K(\phi, m) = \int_0^{\phi} [1 - m \sin(t)^2]^{-1/2} dt 
 
    This function is also called :math:`F(\phi, m)`. 
 
    Parameters 
    ---------- 
    phi : array_like 
        amplitude of the elliptic integral 
    m : array_like 
        parameter of the elliptic integral 
    out : ndarray, optional 
        Optional output array for the function values 
 
    Returns 
    ------- 
    K : scalar or ndarray 
        Value of the elliptic integral 
 
    See Also 
    -------- 
    ellipkm1 : Complete elliptic integral of the first kind, near `m` = 1 
    ellipk : Complete elliptic integral of the first kind 
    ellipe : Complete elliptic integral of the second kind 
    ellipeinc : Incomplete elliptic integral of the second kind 
    elliprf : Completely-symmetric elliptic integral of the first kind. 
 
    Notes 
    ----- 
    Wrapper for the Cephes [1]_ routine `ellik`.  The computation is 
    carried out using the arithmetic-geometric mean algorithm. 
 
    The parameterization in terms of :math:`m` follows that of section 
    17.2 in [2]_. Other parameterizations in terms of the 
    complementary parameter :math:`1 - m`, modular angle 
    :math:`\sin^2(\alpha) = m`, or modulus :math:`k^2 = m` are also 
    used, so be careful that you choose the correct parameter. 
 
    The Legendre K incomplete integral (or F integral) is related to 
    Carlson's symmetric R_F function [3]_. 
    Setting :math:`c = \csc^2\phi`, 
 
    .. math:: F(\phi, m) = R_F(c-1, c-k^2, c) . 
 
    References 
    ---------- 
    .. [1] Cephes Mathematical Functions Library, 
           http://www.netlib.org/cephes/ 
    .. [2] Milton Abramowitz and Irene A. Stegun, eds. 
           Handbook of Mathematical Functions with Formulas, 
           Graphs, and Mathematical Tables. New York: Dover, 1972. 
    .. [3] NIST Digital Library of Mathematical 
           Functions. http://dlmf.nist.gov/, Release 1.0.28 of 
           2020-09-15. See Sec. 19.25(i) https://dlmf.nist.gov/19.25#i 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span>
    <span class="s4">&quot;elliprc&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    elliprc(x, y, out=None) 
 
    Degenerate symmetric elliptic integral. 
 
    The function RC is defined as [1]_ 
 
    .. math:: 
 
        R_{\mathrm{C}}(x, y) = 
           \frac{1}{2} \int_0^{+\infty} (t + x)^{-1/2} (t + y)^{-1} dt 
           = R_{\mathrm{F}}(x, y, y) 
 
    Parameters 
    ---------- 
    x, y : array_like 
        Real or complex input parameters. `x` can be any number in the 
        complex plane cut along the negative real axis. `y` must be non-zero. 
    out : ndarray, optional 
        Optional output array for the function values 
 
    Returns 
    ------- 
    R : scalar or ndarray 
        Value of the integral. If `y` is real and negative, the Cauchy 
        principal value is returned. If both of `x` and `y` are real, the 
        return value is real. Otherwise, the return value is complex. 
 
    See Also 
    -------- 
    elliprf : Completely-symmetric elliptic integral of the first kind. 
    elliprd : Symmetric elliptic integral of the second kind. 
    elliprg : Completely-symmetric elliptic integral of the second kind. 
    elliprj : Symmetric elliptic integral of the third kind. 
 
    Notes 
    ----- 
    RC is a degenerate case of the symmetric integral RF: ``elliprc(x, y) == 
    elliprf(x, y, y)``. It is an elementary function rather than an elliptic 
    integral. 
 
    The code implements Carlson's algorithm based on the duplication theorems 
    and series expansion up to the 7th order. [2]_ 
 
    .. versionadded:: 1.8.0 
 
    References 
    ---------- 
    .. [1] B. C. Carlson, ed., Chapter 19 in &quot;Digital Library of Mathematical 
           Functions,&quot; NIST, US Dept. of Commerce. 
           https://dlmf.nist.gov/19.16.E6 
    .. [2] B. C. Carlson, &quot;Numerical computation of real or complex elliptic 
           integrals,&quot; Numer. Algorithm, vol. 10, no. 1, pp. 13-26, 1995. 
           https://arxiv.org/abs/math/9409227 
           https://doi.org/10.1007/BF02198293 
 
    Examples 
    -------- 
    Basic homogeneity property: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.special import elliprc 
 
    &gt;&gt;&gt; x = 1.2 + 3.4j 
    &gt;&gt;&gt; y = 5. 
    &gt;&gt;&gt; scale = 0.3 + 0.4j 
    &gt;&gt;&gt; elliprc(scale*x, scale*y) 
    (0.5484493976710874-0.4169557678995833j) 
 
    &gt;&gt;&gt; elliprc(x, y)/np.sqrt(scale) 
    (0.5484493976710874-0.41695576789958333j) 
 
    When the two arguments coincide, the integral is particularly 
    simple: 
 
    &gt;&gt;&gt; x = 1.2 + 3.4j 
    &gt;&gt;&gt; elliprc(x, x) 
    (0.4299173120614631-0.3041729818745595j) 
 
    &gt;&gt;&gt; 1/np.sqrt(x) 
    (0.4299173120614631-0.30417298187455954j) 
 
    Another simple case: the first argument vanishes: 
 
    &gt;&gt;&gt; y = 1.2 + 3.4j 
    &gt;&gt;&gt; elliprc(0, y) 
    (0.6753125346116815-0.47779380263880866j) 
 
    &gt;&gt;&gt; np.pi/2/np.sqrt(y) 
    (0.6753125346116815-0.4777938026388088j) 
 
    When `x` and `y` are both positive, we can express 
    :math:`R_C(x,y)` in terms of more elementary functions.  For the 
    case :math:`0 \le x &lt; y`, 
 
    &gt;&gt;&gt; x = 3.2 
    &gt;&gt;&gt; y = 6. 
    &gt;&gt;&gt; elliprc(x, y) 
    0.44942991498453444 
 
    &gt;&gt;&gt; np.arctan(np.sqrt((y-x)/x))/np.sqrt(y-x) 
    0.44942991498453433 
 
    And for the case :math:`0 \le y &lt; x`, 
 
    &gt;&gt;&gt; x = 6. 
    &gt;&gt;&gt; y = 3.2 
    &gt;&gt;&gt; elliprc(x,y) 
    0.4989837501576147 
 
    &gt;&gt;&gt; np.log((np.sqrt(x)+np.sqrt(x-y))/np.sqrt(y))/np.sqrt(x-y) 
    0.49898375015761476 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span>
    <span class="s4">&quot;elliprd&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    elliprd(x, y, z, out=None) 
 
    Symmetric elliptic integral of the second kind. 
 
    The function RD is defined as [1]_ 
 
    .. math:: 
 
        R_{\mathrm{D}}(x, y, z) = 
           \frac{3}{2} \int_0^{+\infty} [(t + x) (t + y)]^{-1/2} (t + z)^{-3/2} 
           dt 
 
    Parameters 
    ---------- 
    x, y, z : array_like 
        Real or complex input parameters. `x` or `y` can be any number in the 
        complex plane cut along the negative real axis, but at most one of them 
        can be zero, while `z` must be non-zero. 
    out : ndarray, optional 
        Optional output array for the function values 
 
    Returns 
    ------- 
    R : scalar or ndarray 
        Value of the integral. If all of `x`, `y`, and `z` are real, the 
        return value is real. Otherwise, the return value is complex. 
 
    See Also 
    -------- 
    elliprc : Degenerate symmetric elliptic integral. 
    elliprf : Completely-symmetric elliptic integral of the first kind. 
    elliprg : Completely-symmetric elliptic integral of the second kind. 
    elliprj : Symmetric elliptic integral of the third kind. 
 
    Notes 
    ----- 
    RD is a degenerate case of the elliptic integral RJ: ``elliprd(x, y, z) == 
    elliprj(x, y, z, z)``. 
 
    The code implements Carlson's algorithm based on the duplication theorems 
    and series expansion up to the 7th order. [2]_ 
 
    .. versionadded:: 1.8.0 
 
    References 
    ---------- 
    .. [1] B. C. Carlson, ed., Chapter 19 in &quot;Digital Library of Mathematical 
           Functions,&quot; NIST, US Dept. of Commerce. 
           https://dlmf.nist.gov/19.16.E5 
    .. [2] B. C. Carlson, &quot;Numerical computation of real or complex elliptic 
           integrals,&quot; Numer. Algorithm, vol. 10, no. 1, pp. 13-26, 1995. 
           https://arxiv.org/abs/math/9409227 
           https://doi.org/10.1007/BF02198293 
 
    Examples 
    -------- 
    Basic homogeneity property: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.special import elliprd 
 
    &gt;&gt;&gt; x = 1.2 + 3.4j 
    &gt;&gt;&gt; y = 5. 
    &gt;&gt;&gt; z = 6. 
    &gt;&gt;&gt; scale = 0.3 + 0.4j 
    &gt;&gt;&gt; elliprd(scale*x, scale*y, scale*z) 
    (-0.03703043835680379-0.24500934665683802j) 
 
    &gt;&gt;&gt; elliprd(x, y, z)*np.power(scale, -1.5) 
    (-0.0370304383568038-0.24500934665683805j) 
 
    All three arguments coincide: 
 
    &gt;&gt;&gt; x = 1.2 + 3.4j 
    &gt;&gt;&gt; elliprd(x, x, x) 
    (-0.03986825876151896-0.14051741840449586j) 
 
    &gt;&gt;&gt; np.power(x, -1.5) 
    (-0.03986825876151894-0.14051741840449583j) 
 
    The so-called &quot;second lemniscate constant&quot;: 
 
    &gt;&gt;&gt; elliprd(0, 2, 1)/3 
    0.5990701173677961 
 
    &gt;&gt;&gt; from scipy.special import gamma 
    &gt;&gt;&gt; gamma(0.75)**2/np.sqrt(2*np.pi) 
    0.5990701173677959 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span>
    <span class="s4">&quot;elliprf&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    elliprf(x, y, z, out=None) 
 
    Completely-symmetric elliptic integral of the first kind. 
 
    The function RF is defined as [1]_ 
 
    .. math:: 
 
        R_{\mathrm{F}}(x, y, z) = 
           \frac{1}{2} \int_0^{+\infty} [(t + x) (t + y) (t + z)]^{-1/2} dt 
 
    Parameters 
    ---------- 
    x, y, z : array_like 
        Real or complex input parameters. `x`, `y`, or `z` can be any number in 
        the complex plane cut along the negative real axis, but at most one of 
        them can be zero. 
    out : ndarray, optional 
        Optional output array for the function values 
 
    Returns 
    ------- 
    R : scalar or ndarray 
        Value of the integral. If all of `x`, `y`, and `z` are real, the return 
        value is real. Otherwise, the return value is complex. 
 
    See Also 
    -------- 
    elliprc : Degenerate symmetric integral. 
    elliprd : Symmetric elliptic integral of the second kind. 
    elliprg : Completely-symmetric elliptic integral of the second kind. 
    elliprj : Symmetric elliptic integral of the third kind. 
 
    Notes 
    ----- 
    The code implements Carlson's algorithm based on the duplication theorems 
    and series expansion up to the 7th order (cf.: 
    https://dlmf.nist.gov/19.36.i) and the AGM algorithm for the complete 
    integral. [2]_ 
 
    .. versionadded:: 1.8.0 
 
    References 
    ---------- 
    .. [1] B. C. Carlson, ed., Chapter 19 in &quot;Digital Library of Mathematical 
           Functions,&quot; NIST, US Dept. of Commerce. 
           https://dlmf.nist.gov/19.16.E1 
    .. [2] B. C. Carlson, &quot;Numerical computation of real or complex elliptic 
           integrals,&quot; Numer. Algorithm, vol. 10, no. 1, pp. 13-26, 1995. 
           https://arxiv.org/abs/math/9409227 
           https://doi.org/10.1007/BF02198293 
 
    Examples 
    -------- 
    Basic homogeneity property: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.special import elliprf 
 
    &gt;&gt;&gt; x = 1.2 + 3.4j 
    &gt;&gt;&gt; y = 5. 
    &gt;&gt;&gt; z = 6. 
    &gt;&gt;&gt; scale = 0.3 + 0.4j 
    &gt;&gt;&gt; elliprf(scale*x, scale*y, scale*z) 
    (0.5328051227278146-0.4008623567957094j) 
 
    &gt;&gt;&gt; elliprf(x, y, z)/np.sqrt(scale) 
    (0.5328051227278147-0.4008623567957095j) 
 
    All three arguments coincide: 
 
    &gt;&gt;&gt; x = 1.2 + 3.4j 
    &gt;&gt;&gt; elliprf(x, x, x) 
    (0.42991731206146316-0.30417298187455954j) 
 
    &gt;&gt;&gt; 1/np.sqrt(x) 
    (0.4299173120614631-0.30417298187455954j) 
 
    The so-called &quot;first lemniscate constant&quot;: 
 
    &gt;&gt;&gt; elliprf(0, 1, 2) 
    1.3110287771460598 
 
    &gt;&gt;&gt; from scipy.special import gamma 
    &gt;&gt;&gt; gamma(0.25)**2/(4*np.sqrt(2*np.pi)) 
    1.3110287771460598 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span>
    <span class="s4">&quot;elliprg&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    elliprg(x, y, z, out=None) 
 
    Completely-symmetric elliptic integral of the second kind. 
 
    The function RG is defined as [1]_ 
 
    .. math:: 
 
        R_{\mathrm{G}}(x, y, z) = 
           \frac{1}{4} \int_0^{+\infty} [(t + x) (t + y) (t + z)]^{-1/2} 
           \left(\frac{x}{t + x} + \frac{y}{t + y} + \frac{z}{t + z}\right) t 
           dt 
 
    Parameters 
    ---------- 
    x, y, z : array_like 
        Real or complex input parameters. `x`, `y`, or `z` can be any number in 
        the complex plane cut along the negative real axis. 
    out : ndarray, optional 
        Optional output array for the function values 
 
    Returns 
    ------- 
    R : scalar or ndarray 
        Value of the integral. If all of `x`, `y`, and `z` are real, the return 
        value is real. Otherwise, the return value is complex. 
 
    See Also 
    -------- 
    elliprc : Degenerate symmetric integral. 
    elliprd : Symmetric elliptic integral of the second kind. 
    elliprf : Completely-symmetric elliptic integral of the first kind. 
    elliprj : Symmetric elliptic integral of the third kind. 
 
    Notes 
    ----- 
    The implementation uses the relation [1]_ 
 
    .. math:: 
 
        2 R_{\mathrm{G}}(x, y, z) = 
           z R_{\mathrm{F}}(x, y, z) - 
           \frac{1}{3} (x - z) (y - z) R_{\mathrm{D}}(x, y, z) + 
           \sqrt{\frac{x y}{z}} 
 
    and the symmetry of `x`, `y`, `z` when at least one non-zero parameter can 
    be chosen as the pivot. When one of the arguments is close to zero, the AGM 
    method is applied instead. Other special cases are computed following Ref. 
    [2]_ 
 
    .. versionadded:: 1.8.0 
 
    References 
    ---------- 
    .. [1] B. C. Carlson, &quot;Numerical computation of real or complex elliptic 
           integrals,&quot; Numer. Algorithm, vol. 10, no. 1, pp. 13-26, 1995. 
           https://arxiv.org/abs/math/9409227 
           https://doi.org/10.1007/BF02198293 
    .. [2] B. C. Carlson, ed., Chapter 19 in &quot;Digital Library of Mathematical 
           Functions,&quot; NIST, US Dept. of Commerce. 
           https://dlmf.nist.gov/19.16.E1 
           https://dlmf.nist.gov/19.20.ii 
 
    Examples 
    -------- 
    Basic homogeneity property: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.special import elliprg 
 
    &gt;&gt;&gt; x = 1.2 + 3.4j 
    &gt;&gt;&gt; y = 5. 
    &gt;&gt;&gt; z = 6. 
    &gt;&gt;&gt; scale = 0.3 + 0.4j 
    &gt;&gt;&gt; elliprg(scale*x, scale*y, scale*z) 
    (1.195936862005246+0.8470988320464167j) 
 
    &gt;&gt;&gt; elliprg(x, y, z)*np.sqrt(scale) 
    (1.195936862005246+0.8470988320464165j) 
 
    Simplifications: 
 
    &gt;&gt;&gt; elliprg(0, y, y) 
    1.756203682760182 
 
    &gt;&gt;&gt; 0.25*np.pi*np.sqrt(y) 
    1.7562036827601817 
 
    &gt;&gt;&gt; elliprg(0, 0, z) 
    1.224744871391589 
 
    &gt;&gt;&gt; 0.5*np.sqrt(z) 
    1.224744871391589 
 
    The surface area of a triaxial ellipsoid with semiaxes ``a``, ``b``, and 
    ``c`` is given by 
 
    .. math:: 
 
        S = 4 \pi a b c R_{\mathrm{G}}(1 / a^2, 1 / b^2, 1 / c^2). 
 
    &gt;&gt;&gt; def ellipsoid_area(a, b, c): 
    ...     r = 4.0 * np.pi * a * b * c 
    ...     return r * elliprg(1.0 / (a * a), 1.0 / (b * b), 1.0 / (c * c)) 
    &gt;&gt;&gt; print(ellipsoid_area(1, 3, 5)) 
    108.62688289491807 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span>
    <span class="s4">&quot;elliprj&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    elliprj(x, y, z, p, out=None) 
 
    Symmetric elliptic integral of the third kind. 
 
    The function RJ is defined as [1]_ 
 
    .. math:: 
 
        R_{\mathrm{J}}(x, y, z, p) = 
           \frac{3}{2} \int_0^{+\infty} [(t + x) (t + y) (t + z)]^{-1/2} 
           (t + p)^{-1} dt 
 
    .. warning:: 
        This function should be considered experimental when the inputs are 
        unbalanced.  Check correctness with another independent implementation. 
 
    Parameters 
    ---------- 
    x, y, z, p : array_like 
        Real or complex input parameters. `x`, `y`, or `z` are numbers in 
        the complex plane cut along the negative real axis (subject to further 
        constraints, see Notes), and at most one of them can be zero. `p` must 
        be non-zero. 
    out : ndarray, optional 
        Optional output array for the function values 
 
    Returns 
    ------- 
    R : scalar or ndarray 
        Value of the integral. If all of `x`, `y`, `z`, and `p` are real, the 
        return value is real. Otherwise, the return value is complex. 
 
        If `p` is real and negative, while `x`, `y`, and `z` are real, 
        non-negative, and at most one of them is zero, the Cauchy principal 
        value is returned. [1]_ [2]_ 
 
    See Also 
    -------- 
    elliprc : Degenerate symmetric integral. 
    elliprd : Symmetric elliptic integral of the second kind. 
    elliprf : Completely-symmetric elliptic integral of the first kind. 
    elliprg : Completely-symmetric elliptic integral of the second kind. 
 
    Notes 
    ----- 
    The code implements Carlson's algorithm based on the duplication theorems 
    and series expansion up to the 7th order. [3]_ The algorithm is slightly 
    different from its earlier incarnation as it appears in [1]_, in that the 
    call to `elliprc` (or ``atan``/``atanh``, see [4]_) is no longer needed in 
    the inner loop. Asymptotic approximations are used where arguments differ 
    widely in the order of magnitude. [5]_ 
 
    The input values are subject to certain sufficient but not necessary 
    constraints when input arguments are complex. Notably, ``x``, ``y``, and 
    ``z`` must have non-negative real parts, unless two of them are 
    non-negative and complex-conjugates to each other while the other is a real 
    non-negative number. [1]_ If the inputs do not satisfy the sufficient 
    condition described in Ref. [1]_ they are rejected outright with the output 
    set to NaN. 
 
    In the case where one of ``x``, ``y``, and ``z`` is equal to ``p``, the 
    function ``elliprd`` should be preferred because of its less restrictive 
    domain. 
 
    .. versionadded:: 1.8.0 
 
    References 
    ---------- 
    .. [1] B. C. Carlson, &quot;Numerical computation of real or complex elliptic 
           integrals,&quot; Numer. Algorithm, vol. 10, no. 1, pp. 13-26, 1995. 
           https://arxiv.org/abs/math/9409227 
           https://doi.org/10.1007/BF02198293 
    .. [2] B. C. Carlson, ed., Chapter 19 in &quot;Digital Library of Mathematical 
           Functions,&quot; NIST, US Dept. of Commerce. 
           https://dlmf.nist.gov/19.20.iii 
    .. [3] B. C. Carlson, J. FitzSimmons, &quot;Reduction Theorems for Elliptic 
           Integrands with the Square Root of Two Quadratic Factors,&quot; J. 
           Comput. Appl. Math., vol. 118, nos. 1-2, pp. 71-85, 2000. 
           https://doi.org/10.1016/S0377-0427(00)00282-X 
    .. [4] F. Johansson, &quot;Numerical Evaluation of Elliptic Functions, Elliptic 
           Integrals and Modular Forms,&quot; in J. Blumlein, C. Schneider, P. 
           Paule, eds., &quot;Elliptic Integrals, Elliptic Functions and Modular 
           Forms in Quantum Field Theory,&quot; pp. 269-293, 2019 (Cham, 
           Switzerland: Springer Nature Switzerland) 
           https://arxiv.org/abs/1806.06725 
           https://doi.org/10.1007/978-3-030-04480-0 
    .. [5] B. C. Carlson, J. L. Gustafson, &quot;Asymptotic Approximations for 
           Symmetric Elliptic Integrals,&quot; SIAM J. Math. Anls., vol. 25, no. 2, 
           pp. 288-303, 1994. 
           https://arxiv.org/abs/math/9310223 
           https://doi.org/10.1137/S0036141092228477 
 
    Examples 
    -------- 
    Basic homogeneity property: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.special import elliprj 
 
    &gt;&gt;&gt; x = 1.2 + 3.4j 
    &gt;&gt;&gt; y = 5. 
    &gt;&gt;&gt; z = 6. 
    &gt;&gt;&gt; p = 7. 
    &gt;&gt;&gt; scale = 0.3 - 0.4j 
    &gt;&gt;&gt; elliprj(scale*x, scale*y, scale*z, scale*p) 
    (0.10834905565679157+0.19694950747103812j) 
 
    &gt;&gt;&gt; elliprj(x, y, z, p)*np.power(scale, -1.5) 
    (0.10834905565679556+0.19694950747103854j) 
 
    Reduction to simpler elliptic integral: 
 
    &gt;&gt;&gt; elliprj(x, y, z, z) 
    (0.08288462362195129-0.028376809745123258j) 
 
    &gt;&gt;&gt; from scipy.special import elliprd 
    &gt;&gt;&gt; elliprd(x, y, z) 
    (0.08288462362195136-0.028376809745123296j) 
 
    All arguments coincide: 
 
    &gt;&gt;&gt; elliprj(x, x, x, x) 
    (-0.03986825876151896-0.14051741840449586j) 
 
    &gt;&gt;&gt; np.power(x, -1.5) 
    (-0.03986825876151894-0.14051741840449583j) 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;entr&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    entr(x, out=None) 
 
    Elementwise function for computing entropy. 
 
    .. math:: \text{entr}(x) = \begin{cases} - x \log(x) &amp; x &gt; 0  \\ 0 &amp; x = 0 
              \\ -\infty &amp; \text{otherwise} \end{cases} 
 
    Parameters 
    ---------- 
    x : ndarray 
        Input array. 
    out : ndarray, optional 
        Optional output array for the function values 
 
    Returns 
    ------- 
    res : scalar or ndarray 
        The value of the elementwise entropy function at the given points `x`. 
 
    See Also 
    -------- 
    kl_div, rel_entr, scipy.stats.entropy 
 
    Notes 
    ----- 
    .. versionadded:: 0.15.0 
 
    This function is concave. 
 
    The origin of this function is in convex programming; see [1]_. 
    Given a probability distribution :math:`p_1, \ldots, p_n`, 
    the definition of entropy in the context of *information theory* is 
 
    .. math:: 
 
        \sum_{i = 1}^n \mathrm{entr}(p_i). 
 
    To compute the latter quantity, use `scipy.stats.entropy`. 
 
    References 
    ---------- 
    .. [1] Boyd, Stephen and Lieven Vandenberghe. *Convex optimization*. 
           Cambridge University Press, 2004. 
           :doi:`https://doi.org/10.1017/CBO9780511804441` 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;erf&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    erf(z, out=None) 
 
    Returns the error function of complex argument. 
 
    It is defined as ``2/sqrt(pi)*integral(exp(-t**2), t=0..z)``. 
 
    Parameters 
    ---------- 
    x : ndarray 
        Input array. 
    out : ndarray, optional 
        Optional output array for the function values 
 
    Returns 
    ------- 
    res : scalar or ndarray 
        The values of the error function at the given points `x`. 
 
    See Also 
    -------- 
    erfc, erfinv, erfcinv, wofz, erfcx, erfi 
 
    Notes 
    ----- 
    The cumulative of the unit normal distribution is given by 
    ``Phi(z) = 1/2[1 + erf(z/sqrt(2))]``. 
 
    References 
    ---------- 
    .. [1] https://en.wikipedia.org/wiki/Error_function 
    .. [2] Milton Abramowitz and Irene A. Stegun, eds. 
        Handbook of Mathematical Functions with Formulas, 
        Graphs, and Mathematical Tables. New York: Dover, 
        1972. http://www.math.sfu.ca/~cbm/aands/page_297.htm 
    .. [3] Steven G. Johnson, Faddeeva W function implementation. 
       http://ab-initio.mit.edu/Faddeeva 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import special 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; x = np.linspace(-3, 3) 
    &gt;&gt;&gt; plt.plot(x, special.erf(x)) 
    &gt;&gt;&gt; plt.xlabel('$x$') 
    &gt;&gt;&gt; plt.ylabel('$erf(x)$') 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;erfc&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    erfc(x, out=None) 
 
    Complementary error function, ``1 - erf(x)``. 
 
    Parameters 
    ---------- 
    x : array_like 
        Real or complex valued argument 
    out : ndarray, optional 
        Optional output array for the function results 
 
    Returns 
    ------- 
    scalar or ndarray 
        Values of the complementary error function 
 
    See Also 
    -------- 
    erf, erfi, erfcx, dawsn, wofz 
 
    References 
    ---------- 
    .. [1] Steven G. Johnson, Faddeeva W function implementation. 
       http://ab-initio.mit.edu/Faddeeva 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import special 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; x = np.linspace(-3, 3) 
    &gt;&gt;&gt; plt.plot(x, special.erfc(x)) 
    &gt;&gt;&gt; plt.xlabel('$x$') 
    &gt;&gt;&gt; plt.ylabel('$erfc(x)$') 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;erfi&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    erfi(z, out=None) 
 
    Imaginary error function, ``-i erf(i z)``. 
 
    Parameters 
    ---------- 
    z : array_like 
        Real or complex valued argument 
    out : ndarray, optional 
        Optional output array for the function results 
 
    Returns 
    ------- 
    scalar or ndarray 
        Values of the imaginary error function 
 
    See Also 
    -------- 
    erf, erfc, erfcx, dawsn, wofz 
 
    Notes 
    ----- 
 
    .. versionadded:: 0.12.0 
 
    References 
    ---------- 
    .. [1] Steven G. Johnson, Faddeeva W function implementation. 
       http://ab-initio.mit.edu/Faddeeva 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import special 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; x = np.linspace(-3, 3) 
    &gt;&gt;&gt; plt.plot(x, special.erfi(x)) 
    &gt;&gt;&gt; plt.xlabel('$x$') 
    &gt;&gt;&gt; plt.ylabel('$erfi(x)$') 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;erfcx&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    erfcx(x, out=None) 
 
    Scaled complementary error function, ``exp(x**2) * erfc(x)``. 
 
    Parameters 
    ---------- 
    x : array_like 
        Real or complex valued argument 
    out : ndarray, optional 
        Optional output array for the function results 
 
    Returns 
    ------- 
    scalar or ndarray 
        Values of the scaled complementary error function 
 
 
    See Also 
    -------- 
    erf, erfc, erfi, dawsn, wofz 
 
    Notes 
    ----- 
 
    .. versionadded:: 0.12.0 
 
    References 
    ---------- 
    .. [1] Steven G. Johnson, Faddeeva W function implementation. 
       http://ab-initio.mit.edu/Faddeeva 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import special 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; x = np.linspace(-3, 3) 
    &gt;&gt;&gt; plt.plot(x, special.erfcx(x)) 
    &gt;&gt;&gt; plt.xlabel('$x$') 
    &gt;&gt;&gt; plt.ylabel('$erfcx(x)$') 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span>
    <span class="s4">&quot;erfinv&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    erfinv(y, out=None) 
 
    Inverse of the error function. 
 
    Computes the inverse of the error function. 
 
    In the complex domain, there is no unique complex number w satisfying 
    erf(w)=z. This indicates a true inverse function would be multivalued. 
    When the domain restricts to the real, -1 &lt; x &lt; 1, there is a unique real 
    number satisfying erf(erfinv(x)) = x. 
 
    Parameters 
    ---------- 
    y : ndarray 
        Argument at which to evaluate. Domain: [-1, 1] 
    out : ndarray, optional 
        Optional output array for the function values 
 
    Returns 
    ------- 
    erfinv : scalar or ndarray 
        The inverse of erf of y, element-wise 
 
    See Also 
    -------- 
    erf : Error function of a complex argument 
    erfc : Complementary error function, ``1 - erf(x)`` 
    erfcinv : Inverse of the complementary error function 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; from scipy.special import erfinv, erf 
 
    &gt;&gt;&gt; erfinv(0.5) 
    0.4769362762044699 
 
    &gt;&gt;&gt; y = np.linspace(-1.0, 1.0, num=9) 
    &gt;&gt;&gt; x = erfinv(y) 
    &gt;&gt;&gt; x 
    array([       -inf, -0.81341985, -0.47693628, -0.22531206,  0.        , 
            0.22531206,  0.47693628,  0.81341985,         inf]) 
 
    Verify that ``erf(erfinv(y))`` is ``y``. 
 
    &gt;&gt;&gt; erf(x) 
    array([-1.  , -0.75, -0.5 , -0.25,  0.  ,  0.25,  0.5 ,  0.75,  1.  ]) 
 
    Plot the function: 
 
    &gt;&gt;&gt; y = np.linspace(-1, 1, 200) 
    &gt;&gt;&gt; fig, ax = plt.subplots() 
    &gt;&gt;&gt; ax.plot(y, erfinv(y)) 
    &gt;&gt;&gt; ax.grid(True) 
    &gt;&gt;&gt; ax.set_xlabel('y') 
    &gt;&gt;&gt; ax.set_title('erfinv(y)') 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span>
    <span class="s4">&quot;erfcinv&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    erfcinv(y, out=None) 
 
    Inverse of the complementary error function. 
 
    Computes the inverse of the complementary error function. 
 
    In the complex domain, there is no unique complex number w satisfying 
    erfc(w)=z. This indicates a true inverse function would be multivalued. 
    When the domain restricts to the real, 0 &lt; x &lt; 2, there is a unique real 
    number satisfying erfc(erfcinv(x)) = erfcinv(erfc(x)). 
 
    It is related to inverse of the error function by erfcinv(1-x) = erfinv(x) 
 
    Parameters 
    ---------- 
    y : ndarray 
        Argument at which to evaluate. Domain: [0, 2] 
    out : ndarray, optional 
        Optional output array for the function values 
 
    Returns 
    ------- 
    erfcinv : scalar or ndarray 
        The inverse of erfc of y, element-wise 
 
    See Also 
    -------- 
    erf : Error function of a complex argument 
    erfc : Complementary error function, ``1 - erf(x)`` 
    erfinv : Inverse of the error function 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; from scipy.special import erfcinv 
 
    &gt;&gt;&gt; erfcinv(0.5) 
    0.4769362762044699 
 
    &gt;&gt;&gt; y = np.linspace(0.0, 2.0, num=11) 
    &gt;&gt;&gt; erfcinv(y) 
    array([        inf,  0.9061938 ,  0.59511608,  0.37080716,  0.17914345, 
           -0.        , -0.17914345, -0.37080716, -0.59511608, -0.9061938 , 
                  -inf]) 
 
    Plot the function: 
 
    &gt;&gt;&gt; y = np.linspace(0, 2, 200) 
    &gt;&gt;&gt; fig, ax = plt.subplots() 
    &gt;&gt;&gt; ax.plot(y, erfcinv(y)) 
    &gt;&gt;&gt; ax.grid(True) 
    &gt;&gt;&gt; ax.set_xlabel('y') 
    &gt;&gt;&gt; ax.set_title('erfcinv(y)') 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;eval_jacobi&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    eval_jacobi(n, alpha, beta, x, out=None) 
 
    Evaluate Jacobi polynomial at a point. 
 
    The Jacobi polynomials can be defined via the Gauss hypergeometric 
    function :math:`{}_2F_1` as 
 
    .. math:: 
 
        P_n^{(\alpha, \beta)}(x) = \frac{(\alpha + 1)_n}{\Gamma(n + 1)} 
          {}_2F_1(-n, 1 + \alpha + \beta + n; \alpha + 1; (1 - z)/2) 
 
    where :math:`(\cdot)_n` is the Pochhammer symbol; see `poch`. When 
    :math:`n` is an integer the result is a polynomial of degree 
    :math:`n`. See 22.5.42 in [AS]_ for details. 
 
    Parameters 
    ---------- 
    n : array_like 
        Degree of the polynomial. If not an integer the result is 
        determined via the relation to the Gauss hypergeometric 
        function. 
    alpha : array_like 
        Parameter 
    beta : array_like 
        Parameter 
    x : array_like 
        Points at which to evaluate the polynomial 
    out : ndarray, optional 
        Optional output array for the function values 
 
    Returns 
    ------- 
    P : scalar or ndarray 
        Values of the Jacobi polynomial 
 
    See Also 
    -------- 
    roots_jacobi : roots and quadrature weights of Jacobi polynomials 
    jacobi : Jacobi polynomial object 
    hyp2f1 : Gauss hypergeometric function 
 
    References 
    ---------- 
    .. [AS] Milton Abramowitz and Irene A. Stegun, eds. 
        Handbook of Mathematical Functions with Formulas, 
        Graphs, and Mathematical Tables. New York: Dover, 1972. 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;eval_sh_jacobi&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    eval_sh_jacobi(n, p, q, x, out=None) 
 
    Evaluate shifted Jacobi polynomial at a point. 
 
    Defined by 
 
    .. math:: 
 
        G_n^{(p, q)}(x) 
          = \binom{2n + p - 1}{n}^{-1} P_n^{(p - q, q - 1)}(2x - 1), 
 
    where :math:`P_n^{(\cdot, \cdot)}` is the n-th Jacobi 
    polynomial. See 22.5.2 in [AS]_ for details. 
 
    Parameters 
    ---------- 
    n : int 
        Degree of the polynomial. If not an integer, the result is 
        determined via the relation to `binom` and `eval_jacobi`. 
    p : float 
        Parameter 
    q : float 
        Parameter 
    out : ndarray, optional 
        Optional output array for the function values 
 
    Returns 
    ------- 
    G : scalar or ndarray 
        Values of the shifted Jacobi polynomial. 
 
    See Also 
    -------- 
    roots_sh_jacobi : roots and quadrature weights of shifted Jacobi 
                      polynomials 
    sh_jacobi : shifted Jacobi polynomial object 
    eval_jacobi : evaluate Jacobi polynomials 
 
    References 
    ---------- 
    .. [AS] Milton Abramowitz and Irene A. Stegun, eds. 
        Handbook of Mathematical Functions with Formulas, 
        Graphs, and Mathematical Tables. New York: Dover, 1972. 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;eval_gegenbauer&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    eval_gegenbauer(n, alpha, x, out=None) 
 
    Evaluate Gegenbauer polynomial at a point. 
 
    The Gegenbauer polynomials can be defined via the Gauss 
    hypergeometric function :math:`{}_2F_1` as 
 
    .. math:: 
 
        C_n^{(\alpha)} = \frac{(2\alpha)_n}{\Gamma(n + 1)} 
          {}_2F_1(-n, 2\alpha + n; \alpha + 1/2; (1 - z)/2). 
 
    When :math:`n` is an integer the result is a polynomial of degree 
    :math:`n`. See 22.5.46 in [AS]_ for details. 
 
    Parameters 
    ---------- 
    n : array_like 
        Degree of the polynomial. If not an integer, the result is 
        determined via the relation to the Gauss hypergeometric 
        function. 
    alpha : array_like 
        Parameter 
    x : array_like 
        Points at which to evaluate the Gegenbauer polynomial 
    out : ndarray, optional 
        Optional output array for the function values 
 
    Returns 
    ------- 
    C : scalar or ndarray 
        Values of the Gegenbauer polynomial 
 
    See Also 
    -------- 
    roots_gegenbauer : roots and quadrature weights of Gegenbauer 
                       polynomials 
    gegenbauer : Gegenbauer polynomial object 
    hyp2f1 : Gauss hypergeometric function 
 
    References 
    ---------- 
    .. [AS] Milton Abramowitz and Irene A. Stegun, eds. 
        Handbook of Mathematical Functions with Formulas, 
        Graphs, and Mathematical Tables. New York: Dover, 1972. 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;eval_chebyt&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    eval_chebyt(n, x, out=None) 
 
    Evaluate Chebyshev polynomial of the first kind at a point. 
 
    The Chebyshev polynomials of the first kind can be defined via the 
    Gauss hypergeometric function :math:`{}_2F_1` as 
 
    .. math:: 
 
        T_n(x) = {}_2F_1(n, -n; 1/2; (1 - x)/2). 
 
    When :math:`n` is an integer the result is a polynomial of degree 
    :math:`n`. See 22.5.47 in [AS]_ for details. 
 
    Parameters 
    ---------- 
    n : array_like 
        Degree of the polynomial. If not an integer, the result is 
        determined via the relation to the Gauss hypergeometric 
        function. 
    x : array_like 
        Points at which to evaluate the Chebyshev polynomial 
    out : ndarray, optional 
        Optional output array for the function values 
 
    Returns 
    ------- 
    T : scalar or ndarray 
        Values of the Chebyshev polynomial 
 
    See Also 
    -------- 
    roots_chebyt : roots and quadrature weights of Chebyshev 
                   polynomials of the first kind 
    chebyu : Chebychev polynomial object 
    eval_chebyu : evaluate Chebyshev polynomials of the second kind 
    hyp2f1 : Gauss hypergeometric function 
    numpy.polynomial.chebyshev.Chebyshev : Chebyshev series 
 
    Notes 
    ----- 
    This routine is numerically stable for `x` in ``[-1, 1]`` at least 
    up to order ``10000``. 
 
    References 
    ---------- 
    .. [AS] Milton Abramowitz and Irene A. Stegun, eds. 
        Handbook of Mathematical Functions with Formulas, 
        Graphs, and Mathematical Tables. New York: Dover, 1972. 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;eval_chebyu&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    eval_chebyu(n, x, out=None) 
 
    Evaluate Chebyshev polynomial of the second kind at a point. 
 
    The Chebyshev polynomials of the second kind can be defined via 
    the Gauss hypergeometric function :math:`{}_2F_1` as 
 
    .. math:: 
 
        U_n(x) = (n + 1) {}_2F_1(-n, n + 2; 3/2; (1 - x)/2). 
 
    When :math:`n` is an integer the result is a polynomial of degree 
    :math:`n`. See 22.5.48 in [AS]_ for details. 
 
    Parameters 
    ---------- 
    n : array_like 
        Degree of the polynomial. If not an integer, the result is 
        determined via the relation to the Gauss hypergeometric 
        function. 
    x : array_like 
        Points at which to evaluate the Chebyshev polynomial 
    out : ndarray, optional 
        Optional output array for the function values 
 
    Returns 
    ------- 
    U : scalar or ndarray 
        Values of the Chebyshev polynomial 
 
    See Also 
    -------- 
    roots_chebyu : roots and quadrature weights of Chebyshev 
                   polynomials of the second kind 
    chebyu : Chebyshev polynomial object 
    eval_chebyt : evaluate Chebyshev polynomials of the first kind 
    hyp2f1 : Gauss hypergeometric function 
 
    References 
    ---------- 
    .. [AS] Milton Abramowitz and Irene A. Stegun, eds. 
        Handbook of Mathematical Functions with Formulas, 
        Graphs, and Mathematical Tables. New York: Dover, 1972. 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;eval_chebys&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    eval_chebys(n, x, out=None) 
 
    Evaluate Chebyshev polynomial of the second kind on [-2, 2] at a 
    point. 
 
    These polynomials are defined as 
 
    .. math:: 
 
        S_n(x) = U_n(x/2) 
 
    where :math:`U_n` is a Chebyshev polynomial of the second 
    kind. See 22.5.13 in [AS]_ for details. 
 
    Parameters 
    ---------- 
    n : array_like 
        Degree of the polynomial. If not an integer, the result is 
        determined via the relation to `eval_chebyu`. 
    x : array_like 
        Points at which to evaluate the Chebyshev polynomial 
    out : ndarray, optional 
        Optional output array for the function values 
 
    Returns 
    ------- 
    S : scalar or ndarray 
        Values of the Chebyshev polynomial 
 
    See Also 
    -------- 
    roots_chebys : roots and quadrature weights of Chebyshev 
                   polynomials of the second kind on [-2, 2] 
    chebys : Chebyshev polynomial object 
    eval_chebyu : evaluate Chebyshev polynomials of the second kind 
 
    References 
    ---------- 
    .. [AS] Milton Abramowitz and Irene A. Stegun, eds. 
        Handbook of Mathematical Functions with Formulas, 
        Graphs, and Mathematical Tables. New York: Dover, 1972. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; import scipy.special as sc 
 
    They are a scaled version of the Chebyshev polynomials of the 
    second kind. 
 
    &gt;&gt;&gt; x = np.linspace(-2, 2, 6) 
    &gt;&gt;&gt; sc.eval_chebys(3, x) 
    array([-4.   ,  0.672,  0.736, -0.736, -0.672,  4.   ]) 
    &gt;&gt;&gt; sc.eval_chebyu(3, x / 2) 
    array([-4.   ,  0.672,  0.736, -0.736, -0.672,  4.   ]) 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;eval_chebyc&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    eval_chebyc(n, x, out=None) 
 
    Evaluate Chebyshev polynomial of the first kind on [-2, 2] at a 
    point. 
 
    These polynomials are defined as 
 
    .. math:: 
 
        C_n(x) = 2 T_n(x/2) 
 
    where :math:`T_n` is a Chebyshev polynomial of the first kind. See 
    22.5.11 in [AS]_ for details. 
 
    Parameters 
    ---------- 
    n : array_like 
        Degree of the polynomial. If not an integer, the result is 
        determined via the relation to `eval_chebyt`. 
    x : array_like 
        Points at which to evaluate the Chebyshev polynomial 
    out : ndarray, optional 
        Optional output array for the function values 
 
    Returns 
    ------- 
    C : scalar or ndarray 
        Values of the Chebyshev polynomial 
 
    See Also 
    -------- 
    roots_chebyc : roots and quadrature weights of Chebyshev 
                   polynomials of the first kind on [-2, 2] 
    chebyc : Chebyshev polynomial object 
    numpy.polynomial.chebyshev.Chebyshev : Chebyshev series 
    eval_chebyt : evaluate Chebycshev polynomials of the first kind 
 
    References 
    ---------- 
    .. [AS] Milton Abramowitz and Irene A. Stegun, eds. 
        Handbook of Mathematical Functions with Formulas, 
        Graphs, and Mathematical Tables. New York: Dover, 1972. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; import scipy.special as sc 
 
    They are a scaled version of the Chebyshev polynomials of the 
    first kind. 
 
    &gt;&gt;&gt; x = np.linspace(-2, 2, 6) 
    &gt;&gt;&gt; sc.eval_chebyc(3, x) 
    array([-2.   ,  1.872,  1.136, -1.136, -1.872,  2.   ]) 
    &gt;&gt;&gt; 2 * sc.eval_chebyt(3, x / 2) 
    array([-2.   ,  1.872,  1.136, -1.136, -1.872,  2.   ]) 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;eval_sh_chebyt&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    eval_sh_chebyt(n, x, out=None) 
 
    Evaluate shifted Chebyshev polynomial of the first kind at a 
    point. 
 
    These polynomials are defined as 
 
    .. math:: 
 
        T_n^*(x) = T_n(2x - 1) 
 
    where :math:`T_n` is a Chebyshev polynomial of the first kind. See 
    22.5.14 in [AS]_ for details. 
 
    Parameters 
    ---------- 
    n : array_like 
        Degree of the polynomial. If not an integer, the result is 
        determined via the relation to `eval_chebyt`. 
    x : array_like 
        Points at which to evaluate the shifted Chebyshev polynomial 
    out : ndarray, optional 
        Optional output array for the function values 
 
    Returns 
    ------- 
    T : scalar or ndarray 
        Values of the shifted Chebyshev polynomial 
 
    See Also 
    -------- 
    roots_sh_chebyt : roots and quadrature weights of shifted 
                      Chebyshev polynomials of the first kind 
    sh_chebyt : shifted Chebyshev polynomial object 
    eval_chebyt : evaluate Chebyshev polynomials of the first kind 
    numpy.polynomial.chebyshev.Chebyshev : Chebyshev series 
 
    References 
    ---------- 
    .. [AS] Milton Abramowitz and Irene A. Stegun, eds. 
        Handbook of Mathematical Functions with Formulas, 
        Graphs, and Mathematical Tables. New York: Dover, 1972. 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;eval_sh_chebyu&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    eval_sh_chebyu(n, x, out=None) 
 
    Evaluate shifted Chebyshev polynomial of the second kind at a 
    point. 
 
    These polynomials are defined as 
 
    .. math:: 
 
        U_n^*(x) = U_n(2x - 1) 
 
    where :math:`U_n` is a Chebyshev polynomial of the first kind. See 
    22.5.15 in [AS]_ for details. 
 
    Parameters 
    ---------- 
    n : array_like 
        Degree of the polynomial. If not an integer, the result is 
        determined via the relation to `eval_chebyu`. 
    x : array_like 
        Points at which to evaluate the shifted Chebyshev polynomial 
    out : ndarray, optional 
        Optional output array for the function values 
 
    Returns 
    ------- 
    U : scalar or ndarray 
        Values of the shifted Chebyshev polynomial 
 
    See Also 
    -------- 
    roots_sh_chebyu : roots and quadrature weights of shifted 
                      Chebychev polynomials of the second kind 
    sh_chebyu : shifted Chebyshev polynomial object 
    eval_chebyu : evaluate Chebyshev polynomials of the second kind 
 
    References 
    ---------- 
    .. [AS] Milton Abramowitz and Irene A. Stegun, eds. 
        Handbook of Mathematical Functions with Formulas, 
        Graphs, and Mathematical Tables. New York: Dover, 1972. 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;eval_legendre&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    eval_legendre(n, x, out=None) 
 
    Evaluate Legendre polynomial at a point. 
 
    The Legendre polynomials can be defined via the Gauss 
    hypergeometric function :math:`{}_2F_1` as 
 
    .. math:: 
 
        P_n(x) = {}_2F_1(-n, n + 1; 1; (1 - x)/2). 
 
    When :math:`n` is an integer the result is a polynomial of degree 
    :math:`n`. See 22.5.49 in [AS]_ for details. 
 
    Parameters 
    ---------- 
    n : array_like 
        Degree of the polynomial. If not an integer, the result is 
        determined via the relation to the Gauss hypergeometric 
        function. 
    x : array_like 
        Points at which to evaluate the Legendre polynomial 
    out : ndarray, optional 
        Optional output array for the function values 
 
    Returns 
    ------- 
    P : scalar or ndarray 
        Values of the Legendre polynomial 
 
    See Also 
    -------- 
    roots_legendre : roots and quadrature weights of Legendre 
                     polynomials 
    legendre : Legendre polynomial object 
    hyp2f1 : Gauss hypergeometric function 
    numpy.polynomial.legendre.Legendre : Legendre series 
 
    References 
    ---------- 
    .. [AS] Milton Abramowitz and Irene A. Stegun, eds. 
        Handbook of Mathematical Functions with Formulas, 
        Graphs, and Mathematical Tables. New York: Dover, 1972. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.special import eval_legendre 
 
    Evaluate the zero-order Legendre polynomial at x = 0 
 
    &gt;&gt;&gt; eval_legendre(0, 0) 
    1.0 
 
    Evaluate the first-order Legendre polynomial between -1 and 1 
 
    &gt;&gt;&gt; X = np.linspace(-1, 1, 5)  # Domain of Legendre polynomials 
    &gt;&gt;&gt; eval_legendre(1, X) 
    array([-1. , -0.5,  0. ,  0.5,  1. ]) 
 
    Evaluate Legendre polynomials of order 0 through 4 at x = 0 
 
    &gt;&gt;&gt; N = range(0, 5) 
    &gt;&gt;&gt; eval_legendre(N, 0) 
    array([ 1.   ,  0.   , -0.5  ,  0.   ,  0.375]) 
 
    Plot Legendre polynomials of order 0 through 4 
 
    &gt;&gt;&gt; X = np.linspace(-1, 1) 
 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; for n in range(0, 5): 
    ...     y = eval_legendre(n, X) 
    ...     plt.plot(X, y, label=r'$P_{}(x)$'.format(n)) 
 
    &gt;&gt;&gt; plt.title(&quot;Legendre Polynomials&quot;) 
    &gt;&gt;&gt; plt.xlabel(&quot;x&quot;) 
    &gt;&gt;&gt; plt.ylabel(r'$P_n(x)$') 
    &gt;&gt;&gt; plt.legend(loc='lower right') 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;eval_sh_legendre&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    eval_sh_legendre(n, x, out=None) 
 
    Evaluate shifted Legendre polynomial at a point. 
 
    These polynomials are defined as 
 
    .. math:: 
 
        P_n^*(x) = P_n(2x - 1) 
 
    where :math:`P_n` is a Legendre polynomial. See 2.2.11 in [AS]_ 
    for details. 
 
    Parameters 
    ---------- 
    n : array_like 
        Degree of the polynomial. If not an integer, the value is 
        determined via the relation to `eval_legendre`. 
    x : array_like 
        Points at which to evaluate the shifted Legendre polynomial 
    out : ndarray, optional 
        Optional output array for the function values 
 
    Returns 
    ------- 
    P : scalar or ndarray 
        Values of the shifted Legendre polynomial 
 
    See Also 
    -------- 
    roots_sh_legendre : roots and quadrature weights of shifted 
                        Legendre polynomials 
    sh_legendre : shifted Legendre polynomial object 
    eval_legendre : evaluate Legendre polynomials 
    numpy.polynomial.legendre.Legendre : Legendre series 
 
    References 
    ---------- 
    .. [AS] Milton Abramowitz and Irene A. Stegun, eds. 
        Handbook of Mathematical Functions with Formulas, 
        Graphs, and Mathematical Tables. New York: Dover, 1972. 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;eval_genlaguerre&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    eval_genlaguerre(n, alpha, x, out=None) 
 
    Evaluate generalized Laguerre polynomial at a point. 
 
    The generalized Laguerre polynomials can be defined via the 
    confluent hypergeometric function :math:`{}_1F_1` as 
 
    .. math:: 
 
        L_n^{(\alpha)}(x) = \binom{n + \alpha}{n} 
          {}_1F_1(-n, \alpha + 1, x). 
 
    When :math:`n` is an integer the result is a polynomial of degree 
    :math:`n`. See 22.5.54 in [AS]_ for details. The Laguerre 
    polynomials are the special case where :math:`\alpha = 0`. 
 
    Parameters 
    ---------- 
    n : array_like 
        Degree of the polynomial. If not an integer, the result is 
        determined via the relation to the confluent hypergeometric 
        function. 
    alpha : array_like 
        Parameter; must have ``alpha &gt; -1`` 
    x : array_like 
        Points at which to evaluate the generalized Laguerre 
        polynomial 
    out : ndarray, optional 
        Optional output array for the function values 
 
    Returns 
    ------- 
    L : scalar or ndarray 
        Values of the generalized Laguerre polynomial 
 
    See Also 
    -------- 
    roots_genlaguerre : roots and quadrature weights of generalized 
                        Laguerre polynomials 
    genlaguerre : generalized Laguerre polynomial object 
    hyp1f1 : confluent hypergeometric function 
    eval_laguerre : evaluate Laguerre polynomials 
 
    References 
    ---------- 
    .. [AS] Milton Abramowitz and Irene A. Stegun, eds. 
        Handbook of Mathematical Functions with Formulas, 
        Graphs, and Mathematical Tables. New York: Dover, 1972. 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;eval_laguerre&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    eval_laguerre(n, x, out=None) 
 
    Evaluate Laguerre polynomial at a point. 
 
    The Laguerre polynomials can be defined via the confluent 
    hypergeometric function :math:`{}_1F_1` as 
 
    .. math:: 
 
        L_n(x) = {}_1F_1(-n, 1, x). 
 
    See 22.5.16 and 22.5.54 in [AS]_ for details. When :math:`n` is an 
    integer the result is a polynomial of degree :math:`n`. 
 
    Parameters 
    ---------- 
    n : array_like 
        Degree of the polynomial. If not an integer the result is 
        determined via the relation to the confluent hypergeometric 
        function. 
    x : array_like 
        Points at which to evaluate the Laguerre polynomial 
    out : ndarray, optional 
        Optional output array for the function values 
 
    Returns 
    ------- 
    L : scalar or ndarray 
        Values of the Laguerre polynomial 
 
    See Also 
    -------- 
    roots_laguerre : roots and quadrature weights of Laguerre 
                     polynomials 
    laguerre : Laguerre polynomial object 
    numpy.polynomial.laguerre.Laguerre : Laguerre series 
    eval_genlaguerre : evaluate generalized Laguerre polynomials 
 
    References 
    ---------- 
    .. [AS] Milton Abramowitz and Irene A. Stegun, eds. 
        Handbook of Mathematical Functions with Formulas, 
        Graphs, and Mathematical Tables. New York: Dover, 1972. 
 
     &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;eval_hermite&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    eval_hermite(n, x, out=None) 
 
    Evaluate physicist's Hermite polynomial at a point. 
 
    Defined by 
 
    .. math:: 
 
        H_n(x) = (-1)^n e^{x^2} \frac{d^n}{dx^n} e^{-x^2}; 
 
    :math:`H_n` is a polynomial of degree :math:`n`. See 22.11.7 in 
    [AS]_ for details. 
 
    Parameters 
    ---------- 
    n : array_like 
        Degree of the polynomial 
    x : array_like 
        Points at which to evaluate the Hermite polynomial 
    out : ndarray, optional 
        Optional output array for the function values 
 
    Returns 
    ------- 
    H : scalar or ndarray 
        Values of the Hermite polynomial 
 
    See Also 
    -------- 
    roots_hermite : roots and quadrature weights of physicist's 
                    Hermite polynomials 
    hermite : physicist's Hermite polynomial object 
    numpy.polynomial.hermite.Hermite : Physicist's Hermite series 
    eval_hermitenorm : evaluate Probabilist's Hermite polynomials 
 
    References 
    ---------- 
    .. [AS] Milton Abramowitz and Irene A. Stegun, eds. 
        Handbook of Mathematical Functions with Formulas, 
        Graphs, and Mathematical Tables. New York: Dover, 1972. 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;eval_hermitenorm&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    eval_hermitenorm(n, x, out=None) 
 
    Evaluate probabilist's (normalized) Hermite polynomial at a 
    point. 
 
    Defined by 
 
    .. math:: 
 
        He_n(x) = (-1)^n e^{x^2/2} \frac{d^n}{dx^n} e^{-x^2/2}; 
 
    :math:`He_n` is a polynomial of degree :math:`n`. See 22.11.8 in 
    [AS]_ for details. 
 
    Parameters 
    ---------- 
    n : array_like 
        Degree of the polynomial 
    x : array_like 
        Points at which to evaluate the Hermite polynomial 
    out : ndarray, optional 
        Optional output array for the function values 
 
    Returns 
    ------- 
    He : scalar or ndarray 
        Values of the Hermite polynomial 
 
    See Also 
    -------- 
    roots_hermitenorm : roots and quadrature weights of probabilist's 
                        Hermite polynomials 
    hermitenorm : probabilist's Hermite polynomial object 
    numpy.polynomial.hermite_e.HermiteE : Probabilist's Hermite series 
    eval_hermite : evaluate physicist's Hermite polynomials 
 
    References 
    ---------- 
    .. [AS] Milton Abramowitz and Irene A. Stegun, eds. 
        Handbook of Mathematical Functions with Formulas, 
        Graphs, and Mathematical Tables. New York: Dover, 1972. 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>


<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;exp10&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    exp10(x, out=None) 
 
    Compute ``10**x`` element-wise. 
 
    Parameters 
    ---------- 
    x : array_like 
        `x` must contain real numbers. 
    out : ndarray, optional 
        Optional output array for the function values 
 
    Returns 
    ------- 
    scalar or ndarray 
        ``10**x``, computed element-wise. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.special import exp10 
 
    &gt;&gt;&gt; exp10(3) 
    1000.0 
    &gt;&gt;&gt; x = np.array([[-1, -0.5, 0], [0.5, 1, 1.5]]) 
    &gt;&gt;&gt; exp10(x) 
    array([[  0.1       ,   0.31622777,   1.        ], 
           [  3.16227766,  10.        ,  31.6227766 ]]) 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;exp2&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    exp2(x, out=None) 
 
    Compute ``2**x`` element-wise. 
 
    Parameters 
    ---------- 
    x : array_like 
        `x` must contain real numbers. 
    out : ndarray, optional 
        Optional output array for the function values 
 
    Returns 
    ------- 
    scalar or ndarray 
        ``2**x``, computed element-wise. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.special import exp2 
 
    &gt;&gt;&gt; exp2(3) 
    8.0 
    &gt;&gt;&gt; x = np.array([[-1, -0.5, 0], [0.5, 1, 1.5]]) 
    &gt;&gt;&gt; exp2(x) 
    array([[ 0.5       ,  0.70710678,  1.        ], 
           [ 1.41421356,  2.        ,  2.82842712]]) 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;expm1&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    expm1(x, out=None) 
 
    Compute ``exp(x) - 1``. 
 
    When `x` is near zero, ``exp(x)`` is near 1, so the numerical calculation 
    of ``exp(x) - 1`` can suffer from catastrophic loss of precision. 
    ``expm1(x)`` is implemented to avoid the loss of precision that occurs when 
    `x` is near zero. 
 
    Parameters 
    ---------- 
    x : array_like 
        `x` must contain real numbers. 
    out : ndarray, optional 
        Optional output array for the function values 
 
    Returns 
    ------- 
    scalar or ndarray 
        ``exp(x) - 1`` computed element-wise. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.special import expm1 
 
    &gt;&gt;&gt; expm1(1.0) 
    1.7182818284590451 
    &gt;&gt;&gt; expm1([-0.2, -0.1, 0, 0.1, 0.2]) 
    array([-0.18126925, -0.09516258,  0.        ,  0.10517092,  0.22140276]) 
 
    The exact value of ``exp(7.5e-13) - 1`` is:: 
 
        7.5000000000028125000000007031250000001318...*10**-13. 
 
    Here is what ``expm1(7.5e-13)`` gives: 
 
    &gt;&gt;&gt; expm1(7.5e-13) 
    7.5000000000028135e-13 
 
    Compare that to ``exp(7.5e-13) - 1``, where the subtraction results in 
    a &quot;catastrophic&quot; loss of precision: 
 
    &gt;&gt;&gt; np.exp(7.5e-13) - 1 
    7.5006667543675576e-13 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;expn&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    expn(n, x, out=None) 
 
    Generalized exponential integral En. 
 
    For integer :math:`n \geq 0` and real :math:`x \geq 0` the 
    generalized exponential integral is defined as [dlmf]_ 
 
    .. math:: 
 
        E_n(x) = x^{n - 1} \int_x^\infty \frac{e^{-t}}{t^n} dt. 
 
    Parameters 
    ---------- 
    n : array_like 
        Non-negative integers 
    x : array_like 
        Real argument 
    out : ndarray, optional 
        Optional output array for the function results 
 
    Returns 
    ------- 
    scalar or ndarray 
        Values of the generalized exponential integral 
 
    See Also 
    -------- 
    exp1 : special case of :math:`E_n` for :math:`n = 1` 
    expi : related to :math:`E_n` when :math:`n = 1` 
 
    References 
    ---------- 
    .. [dlmf] Digital Library of Mathematical Functions, 8.19.2 
              https://dlmf.nist.gov/8.19#E2 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; import scipy.special as sc 
 
    Its domain is nonnegative n and x. 
 
    &gt;&gt;&gt; sc.expn(-1, 1.0), sc.expn(1, -1.0) 
    (nan, nan) 
 
    It has a pole at ``x = 0`` for ``n = 1, 2``; for larger ``n`` it 
    is equal to ``1 / (n - 1)``. 
 
    &gt;&gt;&gt; sc.expn([0, 1, 2, 3, 4], 0) 
    array([       inf,        inf, 1.        , 0.5       , 0.33333333]) 
 
    For n equal to 0 it reduces to ``exp(-x) / x``. 
 
    &gt;&gt;&gt; x = np.array([1, 2, 3, 4]) 
    &gt;&gt;&gt; sc.expn(0, x) 
    array([0.36787944, 0.06766764, 0.01659569, 0.00457891]) 
    &gt;&gt;&gt; np.exp(-x) / x 
    array([0.36787944, 0.06766764, 0.01659569, 0.00457891]) 
 
    For n equal to 1 it reduces to `exp1`. 
 
    &gt;&gt;&gt; sc.expn(1, x) 
    array([0.21938393, 0.04890051, 0.01304838, 0.00377935]) 
    &gt;&gt;&gt; sc.exp1(x) 
    array([0.21938393, 0.04890051, 0.01304838, 0.00377935]) 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;fdtr&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    fdtr(dfn, dfd, x, out=None) 
 
    F cumulative distribution function. 
 
    Returns the value of the cumulative distribution function of the 
    F-distribution, also known as Snedecor's F-distribution or the 
    Fisher-Snedecor distribution. 
 
    The F-distribution with parameters :math:`d_n` and :math:`d_d` is the 
    distribution of the random variable, 
 
    .. math:: 
        X = \frac{U_n/d_n}{U_d/d_d}, 
 
    where :math:`U_n` and :math:`U_d` are random variables distributed 
    :math:`\chi^2`, with :math:`d_n` and :math:`d_d` degrees of freedom, 
    respectively. 
 
    Parameters 
    ---------- 
    dfn : array_like 
        First parameter (positive float). 
    dfd : array_like 
        Second parameter (positive float). 
    x : array_like 
        Argument (nonnegative float). 
    out : ndarray, optional 
        Optional output array for the function values 
 
    Returns 
    ------- 
    y : scalar or ndarray 
        The CDF of the F-distribution with parameters `dfn` and `dfd` at `x`. 
 
    See Also 
    -------- 
    fdtrc : F distribution survival function 
    fdtri : F distribution inverse cumulative distribution 
    scipy.stats.f : F distribution 
 
    Notes 
    ----- 
    The regularized incomplete beta function is used, according to the 
    formula, 
 
    .. math:: 
        F(d_n, d_d; x) = I_{xd_n/(d_d + xd_n)}(d_n/2, d_d/2). 
 
    Wrapper for the Cephes [1]_ routine `fdtr`. The F distribution is also 
    available as `scipy.stats.f`. Calling `fdtr` directly can improve 
    performance compared to the ``cdf`` method of `scipy.stats.f` (see last 
    example below). 
 
    References 
    ---------- 
    .. [1] Cephes Mathematical Functions Library, 
           http://www.netlib.org/cephes/ 
 
    Examples 
    -------- 
    Calculate the function for ``dfn=1`` and ``dfd=2`` at ``x=1``. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.special import fdtr 
    &gt;&gt;&gt; fdtr(1, 2, 1) 
    0.5773502691896258 
 
    Calculate the function at several points by providing a NumPy array for 
    `x`. 
 
    &gt;&gt;&gt; x = np.array([0.5, 2., 3.]) 
    &gt;&gt;&gt; fdtr(1, 2, x) 
    array([0.4472136 , 0.70710678, 0.77459667]) 
 
    Plot the function for several parameter sets. 
 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; dfn_parameters = [1, 5, 10, 50] 
    &gt;&gt;&gt; dfd_parameters = [1, 1, 2, 3] 
    &gt;&gt;&gt; linestyles = ['solid', 'dashed', 'dotted', 'dashdot'] 
    &gt;&gt;&gt; parameters_list = list(zip(dfn_parameters, dfd_parameters, 
    ...                            linestyles)) 
    &gt;&gt;&gt; x = np.linspace(0, 30, 1000) 
    &gt;&gt;&gt; fig, ax = plt.subplots() 
    &gt;&gt;&gt; for parameter_set in parameters_list: 
    ...     dfn, dfd, style = parameter_set 
    ...     fdtr_vals = fdtr(dfn, dfd, x) 
    ...     ax.plot(x, fdtr_vals, label=rf&quot;$d_n={dfn},\, d_d={dfd}$&quot;, 
    ...             ls=style) 
    &gt;&gt;&gt; ax.legend() 
    &gt;&gt;&gt; ax.set_xlabel(&quot;$x$&quot;) 
    &gt;&gt;&gt; ax.set_title(&quot;F distribution cumulative distribution function&quot;) 
    &gt;&gt;&gt; plt.show() 
 
    The F distribution is also available as `scipy.stats.f`. Using `fdtr` 
    directly can be much faster than calling the ``cdf`` method of 
    `scipy.stats.f`, especially for small arrays or individual values. 
    To get the same results one must use the following parametrization: 
    ``stats.f(dfn, dfd).cdf(x)=fdtr(dfn, dfd, x)``. 
 
    &gt;&gt;&gt; from scipy.stats import f 
    &gt;&gt;&gt; dfn, dfd = 1, 2 
    &gt;&gt;&gt; x = 1 
    &gt;&gt;&gt; fdtr_res = fdtr(dfn, dfd, x)  # this will often be faster than below 
    &gt;&gt;&gt; f_dist_res = f(dfn, dfd).cdf(x) 
    &gt;&gt;&gt; fdtr_res == f_dist_res  # test that results are equal 
    True 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;fdtrc&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    fdtrc(dfn, dfd, x, out=None) 
 
    F survival function. 
 
    Returns the complemented F-distribution function (the integral of the 
    density from `x` to infinity). 
 
    Parameters 
    ---------- 
    dfn : array_like 
        First parameter (positive float). 
    dfd : array_like 
        Second parameter (positive float). 
    x : array_like 
        Argument (nonnegative float). 
    out : ndarray, optional 
        Optional output array for the function values 
 
    Returns 
    ------- 
    y : scalar or ndarray 
        The complemented F-distribution function with parameters `dfn` and 
        `dfd` at `x`. 
 
    See Also 
    -------- 
    fdtr : F distribution cumulative distribution function 
    fdtri : F distribution inverse cumulative distribution function 
    scipy.stats.f : F distribution 
 
    Notes 
    ----- 
    The regularized incomplete beta function is used, according to the 
    formula, 
 
    .. math:: 
        F(d_n, d_d; x) = I_{d_d/(d_d + xd_n)}(d_d/2, d_n/2). 
 
    Wrapper for the Cephes [1]_ routine `fdtrc`. The F distribution is also 
    available as `scipy.stats.f`. Calling `fdtrc` directly can improve 
    performance compared to the ``sf`` method of `scipy.stats.f` (see last 
    example below). 
 
    References 
    ---------- 
    .. [1] Cephes Mathematical Functions Library, 
           http://www.netlib.org/cephes/ 
 
    Examples 
    -------- 
    Calculate the function for ``dfn=1`` and ``dfd=2`` at ``x=1``. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.special import fdtrc 
    &gt;&gt;&gt; fdtrc(1, 2, 1) 
    0.42264973081037427 
 
    Calculate the function at several points by providing a NumPy array for 
    `x`. 
 
    &gt;&gt;&gt; x = np.array([0.5, 2., 3.]) 
    &gt;&gt;&gt; fdtrc(1, 2, x) 
    array([0.5527864 , 0.29289322, 0.22540333]) 
 
    Plot the function for several parameter sets. 
 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; dfn_parameters = [1, 5, 10, 50] 
    &gt;&gt;&gt; dfd_parameters = [1, 1, 2, 3] 
    &gt;&gt;&gt; linestyles = ['solid', 'dashed', 'dotted', 'dashdot'] 
    &gt;&gt;&gt; parameters_list = list(zip(dfn_parameters, dfd_parameters, 
    ...                            linestyles)) 
    &gt;&gt;&gt; x = np.linspace(0, 30, 1000) 
    &gt;&gt;&gt; fig, ax = plt.subplots() 
    &gt;&gt;&gt; for parameter_set in parameters_list: 
    ...     dfn, dfd, style = parameter_set 
    ...     fdtrc_vals = fdtrc(dfn, dfd, x) 
    ...     ax.plot(x, fdtrc_vals, label=rf&quot;$d_n={dfn},\, d_d={dfd}$&quot;, 
    ...             ls=style) 
    &gt;&gt;&gt; ax.legend() 
    &gt;&gt;&gt; ax.set_xlabel(&quot;$x$&quot;) 
    &gt;&gt;&gt; ax.set_title(&quot;F distribution survival function&quot;) 
    &gt;&gt;&gt; plt.show() 
 
    The F distribution is also available as `scipy.stats.f`. Using `fdtrc` 
    directly can be much faster than calling the ``sf`` method of 
    `scipy.stats.f`, especially for small arrays or individual values. 
    To get the same results one must use the following parametrization: 
    ``stats.f(dfn, dfd).sf(x)=fdtrc(dfn, dfd, x)``. 
 
    &gt;&gt;&gt; from scipy.stats import f 
    &gt;&gt;&gt; dfn, dfd = 1, 2 
    &gt;&gt;&gt; x = 1 
    &gt;&gt;&gt; fdtrc_res = fdtrc(dfn, dfd, x)  # this will often be faster than below 
    &gt;&gt;&gt; f_dist_res = f(dfn, dfd).sf(x) 
    &gt;&gt;&gt; f_dist_res == fdtrc_res  # test that results are equal 
    True 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;fdtri&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    fdtri(dfn, dfd, p, out=None) 
 
    The `p`-th quantile of the F-distribution. 
 
    This function is the inverse of the F-distribution CDF, `fdtr`, returning 
    the `x` such that `fdtr(dfn, dfd, x) = p`. 
 
    Parameters 
    ---------- 
    dfn : array_like 
        First parameter (positive float). 
    dfd : array_like 
        Second parameter (positive float). 
    p : array_like 
        Cumulative probability, in [0, 1]. 
    out : ndarray, optional 
        Optional output array for the function values 
 
    Returns 
    ------- 
    x : scalar or ndarray 
        The quantile corresponding to `p`. 
 
    See Also 
    -------- 
    fdtr : F distribution cumulative distribution function 
    fdtrc : F distribution survival function 
    scipy.stats.f : F distribution 
 
    Notes 
    ----- 
    The computation is carried out using the relation to the inverse 
    regularized beta function, :math:`I^{-1}_x(a, b)`.  Let 
    :math:`z = I^{-1}_p(d_d/2, d_n/2).`  Then, 
 
    .. math:: 
        x = \frac{d_d (1 - z)}{d_n z}. 
 
    If `p` is such that :math:`x &lt; 0.5`, the following relation is used 
    instead for improved stability: let 
    :math:`z' = I^{-1}_{1 - p}(d_n/2, d_d/2).` Then, 
 
    .. math:: 
        x = \frac{d_d z'}{d_n (1 - z')}. 
 
    Wrapper for the Cephes [1]_ routine `fdtri`. 
 
    The F distribution is also available as `scipy.stats.f`. Calling 
    `fdtri` directly can improve performance compared to the ``ppf`` 
    method of `scipy.stats.f` (see last example below). 
 
    References 
    ---------- 
    .. [1] Cephes Mathematical Functions Library, 
           http://www.netlib.org/cephes/ 
 
    Examples 
    -------- 
    `fdtri` represents the inverse of the F distribution CDF which is 
    available as `fdtr`. Here, we calculate the CDF for ``df1=1``, ``df2=2`` 
    at ``x=3``. `fdtri` then returns ``3`` given the same values for `df1`, 
    `df2` and the computed CDF value. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.special import fdtri, fdtr 
    &gt;&gt;&gt; df1, df2 = 1, 2 
    &gt;&gt;&gt; x = 3 
    &gt;&gt;&gt; cdf_value =  fdtr(df1, df2, x) 
    &gt;&gt;&gt; fdtri(df1, df2, cdf_value) 
    3.000000000000006 
 
    Calculate the function at several points by providing a NumPy array for 
    `x`. 
 
    &gt;&gt;&gt; x = np.array([0.1, 0.4, 0.7]) 
    &gt;&gt;&gt; fdtri(1, 2, x) 
    array([0.02020202, 0.38095238, 1.92156863]) 
 
    Plot the function for several parameter sets. 
 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; dfn_parameters = [50, 10, 1, 50] 
    &gt;&gt;&gt; dfd_parameters = [0.5, 1, 1, 5] 
    &gt;&gt;&gt; linestyles = ['solid', 'dashed', 'dotted', 'dashdot'] 
    &gt;&gt;&gt; parameters_list = list(zip(dfn_parameters, dfd_parameters, 
    ...                            linestyles)) 
    &gt;&gt;&gt; x = np.linspace(0, 1, 1000) 
    &gt;&gt;&gt; fig, ax = plt.subplots() 
    &gt;&gt;&gt; for parameter_set in parameters_list: 
    ...     dfn, dfd, style = parameter_set 
    ...     fdtri_vals = fdtri(dfn, dfd, x) 
    ...     ax.plot(x, fdtri_vals, label=rf&quot;$d_n={dfn},\, d_d={dfd}$&quot;, 
    ...             ls=style) 
    &gt;&gt;&gt; ax.legend() 
    &gt;&gt;&gt; ax.set_xlabel(&quot;$x$&quot;) 
    &gt;&gt;&gt; title = &quot;F distribution inverse cumulative distribution function&quot; 
    &gt;&gt;&gt; ax.set_title(title) 
    &gt;&gt;&gt; ax.set_ylim(0, 30) 
    &gt;&gt;&gt; plt.show() 
 
    The F distribution is also available as `scipy.stats.f`. Using `fdtri` 
    directly can be much faster than calling the ``ppf`` method of 
    `scipy.stats.f`, especially for small arrays or individual values. 
    To get the same results one must use the following parametrization: 
    ``stats.f(dfn, dfd).ppf(x)=fdtri(dfn, dfd, x)``. 
 
    &gt;&gt;&gt; from scipy.stats import f 
    &gt;&gt;&gt; dfn, dfd = 1, 2 
    &gt;&gt;&gt; x = 0.7 
    &gt;&gt;&gt; fdtri_res = fdtri(dfn, dfd, x)  # this will often be faster than below 
    &gt;&gt;&gt; f_dist_res = f(dfn, dfd).ppf(x) 
    &gt;&gt;&gt; f_dist_res == fdtri_res  # test that results are equal 
    True 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;fdtridfd&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    fdtridfd(dfn, p, x, out=None) 
 
    Inverse to `fdtr` vs dfd 
 
    Finds the F density argument dfd such that ``fdtr(dfn, dfd, x) == p``. 
 
    Parameters 
    ---------- 
    dfn : array_like 
        First parameter (positive float). 
    p : array_like 
        Cumulative probability, in [0, 1]. 
    x : array_like 
        Argument (nonnegative float). 
    out : ndarray, optional 
        Optional output array for the function values 
 
    Returns 
    ------- 
    dfd : scalar or ndarray 
        `dfd` such that ``fdtr(dfn, dfd, x) == p``. 
 
    See Also 
    -------- 
    fdtr : F distribution cumulative distribution function 
    fdtrc : F distribution survival function 
    fdtri : F distribution quantile function 
    scipy.stats.f : F distribution 
 
    Examples 
    -------- 
    Compute the F distribution cumulative distribution function for one 
    parameter set. 
 
    &gt;&gt;&gt; from scipy.special import fdtridfd, fdtr 
    &gt;&gt;&gt; dfn, dfd, x = 10, 5, 2 
    &gt;&gt;&gt; cdf_value = fdtr(dfn, dfd, x) 
    &gt;&gt;&gt; cdf_value 
    0.7700248806501017 
 
    Verify that `fdtridfd` recovers the original value for `dfd`: 
 
    &gt;&gt;&gt; fdtridfd(dfn, cdf_value, x) 
    5.0 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s4">''' 
commented out as fdtridfn seems to have bugs and is not in functions.json 
see: https://github.com/scipy/scipy/pull/15622#discussion_r811440983 
 
add_newdoc( 
    &quot;fdtridfn&quot;, 
    &quot;&quot;&quot; 
    fdtridfn(p, dfd, x, out=None) 
 
    Inverse to `fdtr` vs dfn 
 
    finds the F density argument dfn such that ``fdtr(dfn, dfd, x) == p``. 
 
 
    Parameters 
    ---------- 
    p : array_like 
        Cumulative probability, in [0, 1]. 
    dfd : array_like 
        Second parameter (positive float). 
    x : array_like 
        Argument (nonnegative float). 
    out : ndarray, optional 
        Optional output array for the function values 
 
    Returns 
    ------- 
    dfn : scalar or ndarray 
        `dfn` such that ``fdtr(dfn, dfd, x) == p``. 
 
    See Also 
    -------- 
    fdtr, fdtrc, fdtri, fdtridfd 
 
 
    &quot;&quot;&quot;) 
'''</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;fresnel&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    fresnel(z, out=None) 
 
    Fresnel integrals. 
 
    The Fresnel integrals are defined as 
 
    .. math:: 
 
       S(z) &amp;= \int_0^z \sin(\pi t^2 /2) dt \\ 
       C(z) &amp;= \int_0^z \cos(\pi t^2 /2) dt. 
 
    See [dlmf]_ for details. 
 
    Parameters 
    ---------- 
    z : array_like 
        Real or complex valued argument 
    out : 2-tuple of ndarrays, optional 
        Optional output arrays for the function results 
 
    Returns 
    ------- 
    S, C : 2-tuple of scalar or ndarray 
        Values of the Fresnel integrals 
 
    See Also 
    -------- 
    fresnel_zeros : zeros of the Fresnel integrals 
 
    References 
    ---------- 
    .. [dlmf] NIST Digital Library of Mathematical Functions 
              https://dlmf.nist.gov/7.2#iii 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; import scipy.special as sc 
 
    As z goes to infinity along the real axis, S and C converge to 0.5. 
 
    &gt;&gt;&gt; S, C = sc.fresnel([0.1, 1, 10, 100, np.inf]) 
    &gt;&gt;&gt; S 
    array([0.00052359, 0.43825915, 0.46816998, 0.4968169 , 0.5       ]) 
    &gt;&gt;&gt; C 
    array([0.09999753, 0.7798934 , 0.49989869, 0.4999999 , 0.5       ]) 
 
    They are related to the error function `erf`. 
 
    &gt;&gt;&gt; z = np.array([1, 2, 3, 4]) 
    &gt;&gt;&gt; zeta = 0.5 * np.sqrt(np.pi) * (1 - 1j) * z 
    &gt;&gt;&gt; S, C = sc.fresnel(z) 
    &gt;&gt;&gt; C + 1j*S 
    array([0.7798934 +0.43825915j, 0.48825341+0.34341568j, 
           0.60572079+0.496313j  , 0.49842603+0.42051575j]) 
    &gt;&gt;&gt; 0.5 * (1 + 1j) * sc.erf(zeta) 
    array([0.7798934 +0.43825915j, 0.48825341+0.34341568j, 
           0.60572079+0.496313j  , 0.49842603+0.42051575j]) 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;gammainc&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    gammainc(a, x, out=None) 
 
    Regularized lower incomplete gamma function. 
 
    It is defined as 
 
    .. math:: 
 
        P(a, x) = \frac{1}{\Gamma(a)} \int_0^x t^{a - 1}e^{-t} dt 
 
    for :math:`a &gt; 0` and :math:`x \geq 0`. See [dlmf]_ for details. 
 
    Parameters 
    ---------- 
    a : array_like 
        Positive parameter 
    x : array_like 
        Nonnegative argument 
    out : ndarray, optional 
        Optional output array for the function values 
 
    Returns 
    ------- 
    scalar or ndarray 
        Values of the lower incomplete gamma function 
 
    See Also 
    -------- 
    gammaincc : regularized upper incomplete gamma function 
    gammaincinv : inverse of the regularized lower incomplete gamma function 
    gammainccinv : inverse of the regularized upper incomplete gamma function 
 
    Notes 
    ----- 
    The function satisfies the relation ``gammainc(a, x) + 
    gammaincc(a, x) = 1`` where `gammaincc` is the regularized upper 
    incomplete gamma function. 
 
    The implementation largely follows that of [boost]_. 
 
    References 
    ---------- 
    .. [dlmf] NIST Digital Library of Mathematical functions 
              https://dlmf.nist.gov/8.2#E4 
    .. [boost] Maddock et. al., &quot;Incomplete Gamma Functions&quot;, 
       https://www.boost.org/doc/libs/1_61_0/libs/math/doc/html/math_toolkit/sf_gamma/igamma.html 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import scipy.special as sc 
 
    It is the CDF of the gamma distribution, so it starts at 0 and 
    monotonically increases to 1. 
 
    &gt;&gt;&gt; sc.gammainc(0.5, [0, 1, 10, 100]) 
    array([0.        , 0.84270079, 0.99999226, 1.        ]) 
 
    It is equal to one minus the upper incomplete gamma function. 
 
    &gt;&gt;&gt; a, x = 0.5, 0.4 
    &gt;&gt;&gt; sc.gammainc(a, x) 
    0.6289066304773024 
    &gt;&gt;&gt; 1 - sc.gammaincc(a, x) 
    0.6289066304773024 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;gammaincc&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    gammaincc(a, x, out=None) 
 
    Regularized upper incomplete gamma function. 
 
    It is defined as 
 
    .. math:: 
 
        Q(a, x) = \frac{1}{\Gamma(a)} \int_x^\infty t^{a - 1}e^{-t} dt 
 
    for :math:`a &gt; 0` and :math:`x \geq 0`. See [dlmf]_ for details. 
 
    Parameters 
    ---------- 
    a : array_like 
        Positive parameter 
    x : array_like 
        Nonnegative argument 
    out : ndarray, optional 
        Optional output array for the function values 
 
    Returns 
    ------- 
    scalar or ndarray 
        Values of the upper incomplete gamma function 
 
    See Also 
    -------- 
    gammainc : regularized lower incomplete gamma function 
    gammaincinv : inverse of the regularized lower incomplete gamma function 
    gammainccinv : inverse of the regularized upper incomplete gamma function 
 
    Notes 
    ----- 
    The function satisfies the relation ``gammainc(a, x) + 
    gammaincc(a, x) = 1`` where `gammainc` is the regularized lower 
    incomplete gamma function. 
 
    The implementation largely follows that of [boost]_. 
 
    References 
    ---------- 
    .. [dlmf] NIST Digital Library of Mathematical functions 
              https://dlmf.nist.gov/8.2#E4 
    .. [boost] Maddock et. al., &quot;Incomplete Gamma Functions&quot;, 
       https://www.boost.org/doc/libs/1_61_0/libs/math/doc/html/math_toolkit/sf_gamma/igamma.html 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import scipy.special as sc 
 
    It is the survival function of the gamma distribution, so it 
    starts at 1 and monotonically decreases to 0. 
 
    &gt;&gt;&gt; sc.gammaincc(0.5, [0, 1, 10, 100, 1000]) 
    array([1.00000000e+00, 1.57299207e-01, 7.74421643e-06, 2.08848758e-45, 
           0.00000000e+00]) 
 
    It is equal to one minus the lower incomplete gamma function. 
 
    &gt;&gt;&gt; a, x = 0.5, 0.4 
    &gt;&gt;&gt; sc.gammaincc(a, x) 
    0.37109336952269756 
    &gt;&gt;&gt; 1 - sc.gammainc(a, x) 
    0.37109336952269756 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;gammainccinv&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    gammainccinv(a, y, out=None) 
 
    Inverse of the regularized upper incomplete gamma function. 
 
    Given an input :math:`y` between 0 and 1, returns :math:`x` such 
    that :math:`y = Q(a, x)`. Here :math:`Q` is the regularized upper 
    incomplete gamma function; see `gammaincc`. This is well-defined 
    because the upper incomplete gamma function is monotonic as can 
    be seen from its definition in [dlmf]_. 
 
    Parameters 
    ---------- 
    a : array_like 
        Positive parameter 
    y : array_like 
        Argument between 0 and 1, inclusive 
    out : ndarray, optional 
        Optional output array for the function values 
 
    Returns 
    ------- 
    scalar or ndarray 
        Values of the inverse of the upper incomplete gamma function 
 
    See Also 
    -------- 
    gammaincc : regularized upper incomplete gamma function 
    gammainc : regularized lower incomplete gamma function 
    gammaincinv : inverse of the regularized lower incomplete gamma function 
 
    References 
    ---------- 
    .. [dlmf] NIST Digital Library of Mathematical Functions 
              https://dlmf.nist.gov/8.2#E4 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import scipy.special as sc 
 
    It starts at infinity and monotonically decreases to 0. 
 
    &gt;&gt;&gt; sc.gammainccinv(0.5, [0, 0.1, 0.5, 1]) 
    array([       inf, 1.35277173, 0.22746821, 0.        ]) 
 
    It inverts the upper incomplete gamma function. 
 
    &gt;&gt;&gt; a, x = 0.5, [0, 0.1, 0.5, 1] 
    &gt;&gt;&gt; sc.gammaincc(a, sc.gammainccinv(a, x)) 
    array([0. , 0.1, 0.5, 1. ]) 
 
    &gt;&gt;&gt; a, x = 0.5, [0, 10, 50] 
    &gt;&gt;&gt; sc.gammainccinv(a, sc.gammaincc(a, x)) 
    array([ 0., 10., 50.]) 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;gammaincinv&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    gammaincinv(a, y, out=None) 
 
    Inverse to the regularized lower incomplete gamma function. 
 
    Given an input :math:`y` between 0 and 1, returns :math:`x` such 
    that :math:`y = P(a, x)`. Here :math:`P` is the regularized lower 
    incomplete gamma function; see `gammainc`. This is well-defined 
    because the lower incomplete gamma function is monotonic as can be 
    seen from its definition in [dlmf]_. 
 
    Parameters 
    ---------- 
    a : array_like 
        Positive parameter 
    y : array_like 
        Parameter between 0 and 1, inclusive 
    out : ndarray, optional 
        Optional output array for the function values 
 
    Returns 
    ------- 
    scalar or ndarray 
        Values of the inverse of the lower incomplete gamma function 
 
    See Also 
    -------- 
    gammainc : regularized lower incomplete gamma function 
    gammaincc : regularized upper incomplete gamma function 
    gammainccinv : inverse of the regularized upper incomplete gamma function 
 
    References 
    ---------- 
    .. [dlmf] NIST Digital Library of Mathematical Functions 
              https://dlmf.nist.gov/8.2#E4 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import scipy.special as sc 
 
    It starts at 0 and monotonically increases to infinity. 
 
    &gt;&gt;&gt; sc.gammaincinv(0.5, [0, 0.1 ,0.5, 1]) 
    array([0.        , 0.00789539, 0.22746821,        inf]) 
 
    It inverts the lower incomplete gamma function. 
 
    &gt;&gt;&gt; a, x = 0.5, [0, 0.1, 0.5, 1] 
    &gt;&gt;&gt; sc.gammainc(a, sc.gammaincinv(a, x)) 
    array([0. , 0.1, 0.5, 1. ]) 
 
    &gt;&gt;&gt; a, x = 0.5, [0, 10, 25] 
    &gt;&gt;&gt; sc.gammaincinv(a, sc.gammainc(a, x)) 
    array([ 0.        , 10.        , 25.00001465]) 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;gammasgn&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    gammasgn(x, out=None) 
 
    Sign of the gamma function. 
 
    It is defined as 
 
    .. math:: 
 
       \text{gammasgn}(x) = 
       \begin{cases} 
         +1 &amp; \Gamma(x) &gt; 0 \\ 
         -1 &amp; \Gamma(x) &lt; 0 
       \end{cases} 
 
    where :math:`\Gamma` is the gamma function; see `gamma`. This 
    definition is complete since the gamma function is never zero; 
    see the discussion after [dlmf]_. 
 
    Parameters 
    ---------- 
    x : array_like 
        Real argument 
    out : ndarray, optional 
        Optional output array for the function values 
 
    Returns 
    ------- 
    scalar or ndarray 
        Sign of the gamma function 
 
    See Also 
    -------- 
    gamma : the gamma function 
    gammaln : log of the absolute value of the gamma function 
    loggamma : analytic continuation of the log of the gamma function 
 
    Notes 
    ----- 
    The gamma function can be computed as ``gammasgn(x) * 
    np.exp(gammaln(x))``. 
 
    References 
    ---------- 
    .. [dlmf] NIST Digital Library of Mathematical Functions 
              https://dlmf.nist.gov/5.2#E1 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; import scipy.special as sc 
 
    It is 1 for `x &gt; 0`. 
 
    &gt;&gt;&gt; sc.gammasgn([1, 2, 3, 4]) 
    array([1., 1., 1., 1.]) 
 
    It alternates between -1 and 1 for negative integers. 
 
    &gt;&gt;&gt; sc.gammasgn([-0.5, -1.5, -2.5, -3.5]) 
    array([-1.,  1., -1.,  1.]) 
 
    It can be used to compute the gamma function. 
 
    &gt;&gt;&gt; x = [1.5, 0.5, -0.5, -1.5] 
    &gt;&gt;&gt; sc.gammasgn(x) * np.exp(sc.gammaln(x)) 
    array([ 0.88622693,  1.77245385, -3.5449077 ,  2.3632718 ]) 
    &gt;&gt;&gt; sc.gamma(x) 
    array([ 0.88622693,  1.77245385, -3.5449077 ,  2.3632718 ]) 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;gdtr&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    gdtr(a, b, x, out=None) 
 
    Gamma distribution cumulative distribution function. 
 
    Returns the integral from zero to `x` of the gamma probability density 
    function, 
 
    .. math:: 
 
        F = \int_0^x \frac{a^b}{\Gamma(b)} t^{b-1} e^{-at}\,dt, 
 
    where :math:`\Gamma` is the gamma function. 
 
    Parameters 
    ---------- 
    a : array_like 
        The rate parameter of the gamma distribution, sometimes denoted 
        :math:`\beta` (float).  It is also the reciprocal of the scale 
        parameter :math:`\theta`. 
    b : array_like 
        The shape parameter of the gamma distribution, sometimes denoted 
        :math:`\alpha` (float). 
    x : array_like 
        The quantile (upper limit of integration; float). 
    out : ndarray, optional 
        Optional output array for the function values 
 
    Returns 
    ------- 
    F : scalar or ndarray 
        The CDF of the gamma distribution with parameters `a` and `b` 
        evaluated at `x`. 
 
    See Also 
    -------- 
    gdtrc : 1 - CDF of the gamma distribution. 
    scipy.stats.gamma: Gamma distribution 
 
    Notes 
    ----- 
    The evaluation is carried out using the relation to the incomplete gamma 
    integral (regularized gamma function). 
 
    Wrapper for the Cephes [1]_ routine `gdtr`. Calling `gdtr` directly can 
    improve performance compared to the ``cdf`` method of `scipy.stats.gamma` 
    (see last example below). 
 
    References 
    ---------- 
    .. [1] Cephes Mathematical Functions Library, 
           http://www.netlib.org/cephes/ 
 
    Examples 
    -------- 
    Compute the function for ``a=1``, ``b=2`` at ``x=5``. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.special import gdtr 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; gdtr(1., 2., 5.) 
    0.9595723180054873 
 
    Compute the function for ``a=1`` and ``b=2`` at several points by 
    providing a NumPy array for `x`. 
 
    &gt;&gt;&gt; xvalues = np.array([1., 2., 3., 4]) 
    &gt;&gt;&gt; gdtr(1., 1., xvalues) 
    array([0.63212056, 0.86466472, 0.95021293, 0.98168436]) 
 
    `gdtr` can evaluate different parameter sets by providing arrays with 
    broadcasting compatible shapes for `a`, `b` and `x`. Here we compute the 
    function for three different `a` at four positions `x` and ``b=3``, 
    resulting in a 3x4 array. 
 
    &gt;&gt;&gt; a = np.array([[0.5], [1.5], [2.5]]) 
    &gt;&gt;&gt; x = np.array([1., 2., 3., 4]) 
    &gt;&gt;&gt; a.shape, x.shape 
    ((3, 1), (4,)) 
 
    &gt;&gt;&gt; gdtr(a, 3., x) 
    array([[0.01438768, 0.0803014 , 0.19115317, 0.32332358], 
           [0.19115317, 0.57680992, 0.82642193, 0.9380312 ], 
           [0.45618688, 0.87534798, 0.97974328, 0.9972306 ]]) 
 
    Plot the function for four different parameter sets. 
 
    &gt;&gt;&gt; a_parameters = [0.3, 1, 2, 6] 
    &gt;&gt;&gt; b_parameters = [2, 10, 15, 20] 
    &gt;&gt;&gt; linestyles = ['solid', 'dashed', 'dotted', 'dashdot'] 
    &gt;&gt;&gt; parameters_list = list(zip(a_parameters, b_parameters, linestyles)) 
    &gt;&gt;&gt; x = np.linspace(0, 30, 1000) 
    &gt;&gt;&gt; fig, ax = plt.subplots() 
    &gt;&gt;&gt; for parameter_set in parameters_list: 
    ...     a, b, style = parameter_set 
    ...     gdtr_vals = gdtr(a, b, x) 
    ...     ax.plot(x, gdtr_vals, label=fr&quot;$a= {a},\, b={b}$&quot;, ls=style) 
    &gt;&gt;&gt; ax.legend() 
    &gt;&gt;&gt; ax.set_xlabel(&quot;$x$&quot;) 
    &gt;&gt;&gt; ax.set_title(&quot;Gamma distribution cumulative distribution function&quot;) 
    &gt;&gt;&gt; plt.show() 
 
    The gamma distribution is also available as `scipy.stats.gamma`. Using 
    `gdtr` directly can be much faster than calling the ``cdf`` method of 
    `scipy.stats.gamma`, especially for small arrays or individual values. 
    To get the same results one must use the following parametrization: 
    ``stats.gamma(b, scale=1/a).cdf(x)=gdtr(a, b, x)``. 
 
    &gt;&gt;&gt; from scipy.stats import gamma 
    &gt;&gt;&gt; a = 2. 
    &gt;&gt;&gt; b = 3 
    &gt;&gt;&gt; x = 1. 
    &gt;&gt;&gt; gdtr_result = gdtr(a, b, x)  # this will often be faster than below 
    &gt;&gt;&gt; gamma_dist_result = gamma(b, scale=1/a).cdf(x) 
    &gt;&gt;&gt; gdtr_result == gamma_dist_result  # test that results are equal 
    True 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;gdtrc&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    gdtrc(a, b, x, out=None) 
 
    Gamma distribution survival function. 
 
    Integral from `x` to infinity of the gamma probability density function, 
 
    .. math:: 
 
        F = \int_x^\infty \frac{a^b}{\Gamma(b)} t^{b-1} e^{-at}\,dt, 
 
    where :math:`\Gamma` is the gamma function. 
 
    Parameters 
    ---------- 
    a : array_like 
        The rate parameter of the gamma distribution, sometimes denoted 
        :math:`\beta` (float). It is also the reciprocal of the scale 
        parameter :math:`\theta`. 
    b : array_like 
        The shape parameter of the gamma distribution, sometimes denoted 
        :math:`\alpha` (float). 
    x : array_like 
        The quantile (lower limit of integration; float). 
    out : ndarray, optional 
        Optional output array for the function values 
 
    Returns 
    ------- 
    F : scalar or ndarray 
        The survival function of the gamma distribution with parameters `a` 
        and `b` evaluated at `x`. 
 
    See Also 
    -------- 
    gdtr: Gamma distribution cumulative distribution function 
    scipy.stats.gamma: Gamma distribution 
    gdtrix 
 
    Notes 
    ----- 
    The evaluation is carried out using the relation to the incomplete gamma 
    integral (regularized gamma function). 
 
    Wrapper for the Cephes [1]_ routine `gdtrc`. Calling `gdtrc` directly can 
    improve performance compared to the ``sf`` method of `scipy.stats.gamma` 
    (see last example below). 
 
    References 
    ---------- 
    .. [1] Cephes Mathematical Functions Library, 
           http://www.netlib.org/cephes/ 
 
    Examples 
    -------- 
    Compute the function for ``a=1`` and ``b=2`` at ``x=5``. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.special import gdtrc 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; gdtrc(1., 2., 5.) 
    0.04042768199451279 
 
    Compute the function for ``a=1``, ``b=2`` at several points by providing 
    a NumPy array for `x`. 
 
    &gt;&gt;&gt; xvalues = np.array([1., 2., 3., 4]) 
    &gt;&gt;&gt; gdtrc(1., 1., xvalues) 
    array([0.36787944, 0.13533528, 0.04978707, 0.01831564]) 
 
    `gdtrc` can evaluate different parameter sets by providing arrays with 
    broadcasting compatible shapes for `a`, `b` and `x`. Here we compute the 
    function for three different `a` at four positions `x` and ``b=3``, 
    resulting in a 3x4 array. 
 
    &gt;&gt;&gt; a = np.array([[0.5], [1.5], [2.5]]) 
    &gt;&gt;&gt; x = np.array([1., 2., 3., 4]) 
    &gt;&gt;&gt; a.shape, x.shape 
    ((3, 1), (4,)) 
 
    &gt;&gt;&gt; gdtrc(a, 3., x) 
    array([[0.98561232, 0.9196986 , 0.80884683, 0.67667642], 
           [0.80884683, 0.42319008, 0.17357807, 0.0619688 ], 
           [0.54381312, 0.12465202, 0.02025672, 0.0027694 ]]) 
 
    Plot the function for four different parameter sets. 
 
    &gt;&gt;&gt; a_parameters = [0.3, 1, 2, 6] 
    &gt;&gt;&gt; b_parameters = [2, 10, 15, 20] 
    &gt;&gt;&gt; linestyles = ['solid', 'dashed', 'dotted', 'dashdot'] 
    &gt;&gt;&gt; parameters_list = list(zip(a_parameters, b_parameters, linestyles)) 
    &gt;&gt;&gt; x = np.linspace(0, 30, 1000) 
    &gt;&gt;&gt; fig, ax = plt.subplots() 
    &gt;&gt;&gt; for parameter_set in parameters_list: 
    ...     a, b, style = parameter_set 
    ...     gdtrc_vals = gdtrc(a, b, x) 
    ...     ax.plot(x, gdtrc_vals, label=fr&quot;$a= {a},\, b={b}$&quot;, ls=style) 
    &gt;&gt;&gt; ax.legend() 
    &gt;&gt;&gt; ax.set_xlabel(&quot;$x$&quot;) 
    &gt;&gt;&gt; ax.set_title(&quot;Gamma distribution survival function&quot;) 
    &gt;&gt;&gt; plt.show() 
 
    The gamma distribution is also available as `scipy.stats.gamma`. 
    Using `gdtrc` directly can be much faster than calling the ``sf`` method 
    of `scipy.stats.gamma`, especially for small arrays or individual 
    values. To get the same results one must use the following parametrization: 
    ``stats.gamma(b, scale=1/a).sf(x)=gdtrc(a, b, x)``. 
 
    &gt;&gt;&gt; from scipy.stats import gamma 
    &gt;&gt;&gt; a = 2 
    &gt;&gt;&gt; b = 3 
    &gt;&gt;&gt; x = 1. 
    &gt;&gt;&gt; gdtrc_result = gdtrc(a, b, x)  # this will often be faster than below 
    &gt;&gt;&gt; gamma_dist_result = gamma(b, scale=1/a).sf(x) 
    &gt;&gt;&gt; gdtrc_result == gamma_dist_result  # test that results are equal 
    True 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;gdtria&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    gdtria(p, b, x, out=None) 
 
    Inverse of `gdtr` vs a. 
 
    Returns the inverse with respect to the parameter `a` of ``p = 
    gdtr(a, b, x)``, the cumulative distribution function of the gamma 
    distribution. 
 
    Parameters 
    ---------- 
    p : array_like 
        Probability values. 
    b : array_like 
        `b` parameter values of `gdtr(a, b, x)`. `b` is the &quot;shape&quot; parameter 
        of the gamma distribution. 
    x : array_like 
        Nonnegative real values, from the domain of the gamma distribution. 
    out : ndarray, optional 
        If a fourth argument is given, it must be a numpy.ndarray whose size 
        matches the broadcast result of `a`, `b` and `x`.  `out` is then the 
        array returned by the function. 
 
    Returns 
    ------- 
    a : scalar or ndarray 
        Values of the `a` parameter such that `p = gdtr(a, b, x)`.  `1/a` 
        is the &quot;scale&quot; parameter of the gamma distribution. 
 
    See Also 
    -------- 
    gdtr : CDF of the gamma distribution. 
    gdtrib : Inverse with respect to `b` of `gdtr(a, b, x)`. 
    gdtrix : Inverse with respect to `x` of `gdtr(a, b, x)`. 
 
    Notes 
    ----- 
    Wrapper for the CDFLIB [1]_ Fortran routine `cdfgam`. 
 
    The cumulative distribution function `p` is computed using a routine by 
    DiDinato and Morris [2]_. Computation of `a` involves a search for a value 
    that produces the desired value of `p`. The search relies on the 
    monotonicity of `p` with `a`. 
 
    References 
    ---------- 
    .. [1] Barry Brown, James Lovato, and Kathy Russell, 
           CDFLIB: Library of Fortran Routines for Cumulative Distribution 
           Functions, Inverses, and Other Parameters. 
    .. [2] DiDinato, A. R. and Morris, A. H., 
           Computation of the incomplete gamma function ratios and their 
           inverse.  ACM Trans. Math. Softw. 12 (1986), 377-393. 
 
    Examples 
    -------- 
    First evaluate `gdtr`. 
 
    &gt;&gt;&gt; from scipy.special import gdtr, gdtria 
    &gt;&gt;&gt; p = gdtr(1.2, 3.4, 5.6) 
    &gt;&gt;&gt; print(p) 
    0.94378087442 
 
    Verify the inverse. 
 
    &gt;&gt;&gt; gdtria(p, 3.4, 5.6) 
    1.2 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;gdtrib&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    gdtrib(a, p, x, out=None) 
 
    Inverse of `gdtr` vs b. 
 
    Returns the inverse with respect to the parameter `b` of ``p = 
    gdtr(a, b, x)``, the cumulative distribution function of the gamma 
    distribution. 
 
    Parameters 
    ---------- 
    a : array_like 
        `a` parameter values of `gdtr(a, b, x)`. `1/a` is the &quot;scale&quot; 
        parameter of the gamma distribution. 
    p : array_like 
        Probability values. 
    x : array_like 
        Nonnegative real values, from the domain of the gamma distribution. 
    out : ndarray, optional 
        If a fourth argument is given, it must be a numpy.ndarray whose size 
        matches the broadcast result of `a`, `b` and `x`.  `out` is then the 
        array returned by the function. 
 
    Returns 
    ------- 
    b : scalar or ndarray 
        Values of the `b` parameter such that `p = gdtr(a, b, x)`.  `b` is 
        the &quot;shape&quot; parameter of the gamma distribution. 
 
    See Also 
    -------- 
    gdtr : CDF of the gamma distribution. 
    gdtria : Inverse with respect to `a` of `gdtr(a, b, x)`. 
    gdtrix : Inverse with respect to `x` of `gdtr(a, b, x)`. 
 
    Notes 
    ----- 
    Wrapper for the CDFLIB [1]_ Fortran routine `cdfgam`. 
 
    The cumulative distribution function `p` is computed using a routine by 
    DiDinato and Morris [2]_. Computation of `b` involves a search for a value 
    that produces the desired value of `p`. The search relies on the 
    monotonicity of `p` with `b`. 
 
    References 
    ---------- 
    .. [1] Barry Brown, James Lovato, and Kathy Russell, 
           CDFLIB: Library of Fortran Routines for Cumulative Distribution 
           Functions, Inverses, and Other Parameters. 
    .. [2] DiDinato, A. R. and Morris, A. H., 
           Computation of the incomplete gamma function ratios and their 
           inverse.  ACM Trans. Math. Softw. 12 (1986), 377-393. 
 
    Examples 
    -------- 
    First evaluate `gdtr`. 
 
    &gt;&gt;&gt; from scipy.special import gdtr, gdtrib 
    &gt;&gt;&gt; p = gdtr(1.2, 3.4, 5.6) 
    &gt;&gt;&gt; print(p) 
    0.94378087442 
 
    Verify the inverse. 
 
    &gt;&gt;&gt; gdtrib(1.2, p, 5.6) 
    3.3999999999723882 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;gdtrix&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    gdtrix(a, b, p, out=None) 
 
    Inverse of `gdtr` vs x. 
 
    Returns the inverse with respect to the parameter `x` of ``p = 
    gdtr(a, b, x)``, the cumulative distribution function of the gamma 
    distribution. This is also known as the pth quantile of the 
    distribution. 
 
    Parameters 
    ---------- 
    a : array_like 
        `a` parameter values of `gdtr(a, b, x)`. `1/a` is the &quot;scale&quot; 
        parameter of the gamma distribution. 
    b : array_like 
        `b` parameter values of `gdtr(a, b, x)`. `b` is the &quot;shape&quot; parameter 
        of the gamma distribution. 
    p : array_like 
        Probability values. 
    out : ndarray, optional 
        If a fourth argument is given, it must be a numpy.ndarray whose size 
        matches the broadcast result of `a`, `b` and `x`. `out` is then the 
        array returned by the function. 
 
    Returns 
    ------- 
    x : scalar or ndarray 
        Values of the `x` parameter such that `p = gdtr(a, b, x)`. 
 
    See Also 
    -------- 
    gdtr : CDF of the gamma distribution. 
    gdtria : Inverse with respect to `a` of `gdtr(a, b, x)`. 
    gdtrib : Inverse with respect to `b` of `gdtr(a, b, x)`. 
 
    Notes 
    ----- 
    Wrapper for the CDFLIB [1]_ Fortran routine `cdfgam`. 
 
    The cumulative distribution function `p` is computed using a routine by 
    DiDinato and Morris [2]_. Computation of `x` involves a search for a value 
    that produces the desired value of `p`. The search relies on the 
    monotonicity of `p` with `x`. 
 
    References 
    ---------- 
    .. [1] Barry Brown, James Lovato, and Kathy Russell, 
           CDFLIB: Library of Fortran Routines for Cumulative Distribution 
           Functions, Inverses, and Other Parameters. 
    .. [2] DiDinato, A. R. and Morris, A. H., 
           Computation of the incomplete gamma function ratios and their 
           inverse.  ACM Trans. Math. Softw. 12 (1986), 377-393. 
 
    Examples 
    -------- 
    First evaluate `gdtr`. 
 
    &gt;&gt;&gt; from scipy.special import gdtr, gdtrix 
    &gt;&gt;&gt; p = gdtr(1.2, 3.4, 5.6) 
    &gt;&gt;&gt; print(p) 
    0.94378087442 
 
    Verify the inverse. 
 
    &gt;&gt;&gt; gdtrix(1.2, 3.4, p) 
    5.5999999999999996 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;hankel1&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    hankel1(v, z, out=None) 
 
    Hankel function of the first kind 
 
    Parameters 
    ---------- 
    v : array_like 
        Order (float). 
    z : array_like 
        Argument (float or complex). 
    out : ndarray, optional 
        Optional output array for the function values 
 
    Returns 
    ------- 
    scalar or ndarray 
        Values of the Hankel function of the first kind. 
 
    See Also 
    -------- 
    hankel1e : ndarray 
        This function with leading exponential behavior stripped off. 
 
    Notes 
    ----- 
    A wrapper for the AMOS [1]_ routine `zbesh`, which carries out the 
    computation using the relation, 
 
    .. math:: H^{(1)}_v(z) = 
              \frac{2}{\imath\pi} \exp(-\imath \pi v/2) K_v(z \exp(-\imath\pi/2)) 
 
    where :math:`K_v` is the modified Bessel function of the second kind. 
    For negative orders, the relation 
 
    .. math:: H^{(1)}_{-v}(z) = H^{(1)}_v(z) \exp(\imath\pi v) 
 
    is used. 
 
    References 
    ---------- 
    .. [1] Donald E. Amos, &quot;AMOS, A Portable Package for Bessel Functions 
           of a Complex Argument and Nonnegative Order&quot;, 
           http://netlib.org/amos/ 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;hankel1e&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    hankel1e(v, z, out=None) 
 
    Exponentially scaled Hankel function of the first kind 
 
    Defined as:: 
 
        hankel1e(v, z) = hankel1(v, z) * exp(-1j * z) 
 
    Parameters 
    ---------- 
    v : array_like 
        Order (float). 
    z : array_like 
        Argument (float or complex). 
    out : ndarray, optional 
        Optional output array for the function values 
 
    Returns 
    ------- 
    scalar or ndarray 
        Values of the exponentially scaled Hankel function. 
 
    Notes 
    ----- 
    A wrapper for the AMOS [1]_ routine `zbesh`, which carries out the 
    computation using the relation, 
 
    .. math:: H^{(1)}_v(z) = 
              \frac{2}{\imath\pi} \exp(-\imath \pi v/2) K_v(z \exp(-\imath\pi/2)) 
 
    where :math:`K_v` is the modified Bessel function of the second kind. 
    For negative orders, the relation 
 
    .. math:: H^{(1)}_{-v}(z) = H^{(1)}_v(z) \exp(\imath\pi v) 
 
    is used. 
 
    References 
    ---------- 
    .. [1] Donald E. Amos, &quot;AMOS, A Portable Package for Bessel Functions 
           of a Complex Argument and Nonnegative Order&quot;, 
           http://netlib.org/amos/ 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;hankel2&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    hankel2(v, z, out=None) 
 
    Hankel function of the second kind 
 
    Parameters 
    ---------- 
    v : array_like 
        Order (float). 
    z : array_like 
        Argument (float or complex). 
    out : ndarray, optional 
        Optional output array for the function values 
 
    Returns 
    ------- 
    scalar or ndarray 
        Values of the Hankel function of the second kind. 
 
    See Also 
    -------- 
    hankel2e : this function with leading exponential behavior stripped off. 
 
    Notes 
    ----- 
    A wrapper for the AMOS [1]_ routine `zbesh`, which carries out the 
    computation using the relation, 
 
    .. math:: H^{(2)}_v(z) = 
              -\frac{2}{\imath\pi} \exp(\imath \pi v/2) K_v(z \exp(\imath\pi/2)) 
 
    where :math:`K_v` is the modified Bessel function of the second kind. 
    For negative orders, the relation 
 
    .. math:: H^{(2)}_{-v}(z) = H^{(2)}_v(z) \exp(-\imath\pi v) 
 
    is used. 
 
    References 
    ---------- 
    .. [1] Donald E. Amos, &quot;AMOS, A Portable Package for Bessel Functions 
           of a Complex Argument and Nonnegative Order&quot;, 
           http://netlib.org/amos/ 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;hankel2e&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    hankel2e(v, z, out=None) 
 
    Exponentially scaled Hankel function of the second kind 
 
    Defined as:: 
 
        hankel2e(v, z) = hankel2(v, z) * exp(1j * z) 
 
    Parameters 
    ---------- 
    v : array_like 
        Order (float). 
    z : array_like 
        Argument (float or complex). 
    out : ndarray, optional 
        Optional output array for the function values 
 
    Returns 
    ------- 
    scalar or ndarray 
        Values of the exponentially scaled Hankel function of the second kind. 
 
    Notes 
    ----- 
    A wrapper for the AMOS [1]_ routine `zbesh`, which carries out the 
    computation using the relation, 
 
    .. math:: H^{(2)}_v(z) = -\frac{2}{\imath\pi} 
              \exp(\frac{\imath \pi v}{2}) K_v(z exp(\frac{\imath\pi}{2})) 
 
    where :math:`K_v` is the modified Bessel function of the second kind. 
    For negative orders, the relation 
 
    .. math:: H^{(2)}_{-v}(z) = H^{(2)}_v(z) \exp(-\imath\pi v) 
 
    is used. 
 
    References 
    ---------- 
    .. [1] Donald E. Amos, &quot;AMOS, A Portable Package for Bessel Functions 
           of a Complex Argument and Nonnegative Order&quot;, 
           http://netlib.org/amos/ 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;huber&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    huber(delta, r, out=None) 
 
    Huber loss function. 
 
    .. math:: \text{huber}(\delta, r) = \begin{cases} \infty &amp; \delta &lt; 0  \\ 
              \frac{1}{2}r^2 &amp; 0 \le \delta, | r | \le \delta \\ 
              \delta ( |r| - \frac{1}{2}\delta ) &amp; \text{otherwise} \end{cases} 
 
    Parameters 
    ---------- 
    delta : ndarray 
        Input array, indicating the quadratic vs. linear loss changepoint. 
    r : ndarray 
        Input array, possibly representing residuals. 
    out : ndarray, optional 
        Optional output array for the function values 
 
    Returns 
    ------- 
    scalar or ndarray 
        The computed Huber loss function values. 
 
    See Also 
    -------- 
    pseudo_huber : smooth approximation of this function 
 
    Notes 
    ----- 
    `huber` is useful as a loss function in robust statistics or machine 
    learning to reduce the influence of outliers as compared to the common 
    squared error loss, residuals with a magnitude higher than `delta` are 
    not squared [1]_. 
 
    Typically, `r` represents residuals, the difference 
    between a model prediction and data. Then, for :math:`|r|\leq\delta`, 
    `huber` resembles the squared error and for :math:`|r|&gt;\delta` the 
    absolute error. This way, the Huber loss often achieves 
    a fast convergence in model fitting for small residuals like the squared 
    error loss function and still reduces the influence of outliers 
    (:math:`|r|&gt;\delta`) like the absolute error loss. As :math:`\delta` is 
    the cutoff between squared and absolute error regimes, it has 
    to be tuned carefully for each problem. `huber` is also 
    convex, making it suitable for gradient based optimization. 
 
    .. versionadded:: 0.15.0 
 
    References 
    ---------- 
    .. [1] Peter Huber. &quot;Robust Estimation of a Location Parameter&quot;, 
           1964. Annals of Statistics. 53 (1): 73 - 101. 
 
    Examples 
    -------- 
    Import all necessary modules. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.special import huber 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
 
    Compute the function for ``delta=1`` at ``r=2`` 
 
    &gt;&gt;&gt; huber(1., 2.) 
    1.5 
 
    Compute the function for different `delta` by providing a NumPy array or 
    list for `delta`. 
 
    &gt;&gt;&gt; huber([1., 3., 5.], 4.) 
    array([3.5, 7.5, 8. ]) 
 
    Compute the function at different points by providing a NumPy array or 
    list for `r`. 
 
    &gt;&gt;&gt; huber(2., np.array([1., 1.5, 3.])) 
    array([0.5  , 1.125, 4.   ]) 
 
    The function can be calculated for different `delta` and `r` by 
    providing arrays for both with compatible shapes for broadcasting. 
 
    &gt;&gt;&gt; r = np.array([1., 2.5, 8., 10.]) 
    &gt;&gt;&gt; deltas = np.array([[1.], [5.], [9.]]) 
    &gt;&gt;&gt; print(r.shape, deltas.shape) 
    (4,) (3, 1) 
 
    &gt;&gt;&gt; huber(deltas, r) 
    array([[ 0.5  ,  2.   ,  7.5  ,  9.5  ], 
           [ 0.5  ,  3.125, 27.5  , 37.5  ], 
           [ 0.5  ,  3.125, 32.   , 49.5  ]]) 
 
    Plot the function for different `delta`. 
 
    &gt;&gt;&gt; x = np.linspace(-4, 4, 500) 
    &gt;&gt;&gt; deltas = [1, 2, 3] 
    &gt;&gt;&gt; linestyles = [&quot;dashed&quot;, &quot;dotted&quot;, &quot;dashdot&quot;] 
    &gt;&gt;&gt; fig, ax = plt.subplots() 
    &gt;&gt;&gt; combined_plot_parameters = list(zip(deltas, linestyles)) 
    &gt;&gt;&gt; for delta, style in combined_plot_parameters: 
    ...     ax.plot(x, huber(delta, x), label=fr&quot;$\delta={delta}$&quot;, ls=style) 
    &gt;&gt;&gt; ax.legend(loc=&quot;upper center&quot;) 
    &gt;&gt;&gt; ax.set_xlabel(&quot;$x$&quot;) 
    &gt;&gt;&gt; ax.set_title(r&quot;Huber loss function $h_{\delta}(x)$&quot;) 
    &gt;&gt;&gt; ax.set_xlim(-4, 4) 
    &gt;&gt;&gt; ax.set_ylim(0, 8) 
    &gt;&gt;&gt; plt.show() 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;hyp0f1&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    hyp0f1(v, z, out=None) 
 
    Confluent hypergeometric limit function 0F1. 
 
    Parameters 
    ---------- 
    v : array_like 
        Real-valued parameter 
    z : array_like 
        Real- or complex-valued argument 
    out : ndarray, optional 
        Optional output array for the function results 
 
    Returns 
    ------- 
    scalar or ndarray 
        The confluent hypergeometric limit function 
 
    Notes 
    ----- 
    This function is defined as: 
 
    .. math:: _0F_1(v, z) = \sum_{k=0}^{\infty}\frac{z^k}{(v)_k k!}. 
 
    It's also the limit as :math:`q \to \infty` of :math:`_1F_1(q; v; z/q)`, 
    and satisfies the differential equation :math:`f''(z) + vf'(z) = 
    f(z)`. See [1]_ for more information. 
 
    References 
    ---------- 
    .. [1] Wolfram MathWorld, &quot;Confluent Hypergeometric Limit Function&quot;, 
           http://mathworld.wolfram.com/ConfluentHypergeometricLimitFunction.html 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; import scipy.special as sc 
 
    It is one when `z` is zero. 
 
    &gt;&gt;&gt; sc.hyp0f1(1, 0) 
    1.0 
 
    It is the limit of the confluent hypergeometric function as `q` 
    goes to infinity. 
 
    &gt;&gt;&gt; q = np.array([1, 10, 100, 1000]) 
    &gt;&gt;&gt; v = 1 
    &gt;&gt;&gt; z = 1 
    &gt;&gt;&gt; sc.hyp1f1(q, v, z / q) 
    array([2.71828183, 2.31481985, 2.28303778, 2.27992985]) 
    &gt;&gt;&gt; sc.hyp0f1(v, z) 
    2.2795853023360673 
 
    It is related to Bessel functions. 
 
    &gt;&gt;&gt; n = 1 
    &gt;&gt;&gt; x = np.linspace(0, 1, 5) 
    &gt;&gt;&gt; sc.jv(n, x) 
    array([0.        , 0.12402598, 0.24226846, 0.3492436 , 0.44005059]) 
    &gt;&gt;&gt; (0.5 * x)**n / sc.factorial(n) * sc.hyp0f1(n + 1, -0.25 * x**2) 
    array([0.        , 0.12402598, 0.24226846, 0.3492436 , 0.44005059]) 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;hyp1f1&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    hyp1f1(a, b, x, out=None) 
 
    Confluent hypergeometric function 1F1. 
 
    The confluent hypergeometric function is defined by the series 
 
    .. math:: 
 
       {}_1F_1(a; b; x) = \sum_{k = 0}^\infty \frac{(a)_k}{(b)_k k!} x^k. 
 
    See [dlmf]_ for more details. Here :math:`(\cdot)_k` is the 
    Pochhammer symbol; see `poch`. 
 
    Parameters 
    ---------- 
    a, b : array_like 
        Real parameters 
    x : array_like 
        Real or complex argument 
    out : ndarray, optional 
        Optional output array for the function results 
 
    Returns 
    ------- 
    scalar or ndarray 
        Values of the confluent hypergeometric function 
 
    See Also 
    -------- 
    hyperu : another confluent hypergeometric function 
    hyp0f1 : confluent hypergeometric limit function 
    hyp2f1 : Gaussian hypergeometric function 
 
    References 
    ---------- 
    .. [dlmf] NIST Digital Library of Mathematical Functions 
              https://dlmf.nist.gov/13.2#E2 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; import scipy.special as sc 
 
    It is one when `x` is zero: 
 
    &gt;&gt;&gt; sc.hyp1f1(0.5, 0.5, 0) 
    1.0 
 
    It is singular when `b` is a nonpositive integer. 
 
    &gt;&gt;&gt; sc.hyp1f1(0.5, -1, 0) 
    inf 
 
    It is a polynomial when `a` is a nonpositive integer. 
 
    &gt;&gt;&gt; a, b, x = -1, 0.5, np.array([1.0, 2.0, 3.0, 4.0]) 
    &gt;&gt;&gt; sc.hyp1f1(a, b, x) 
    array([-1., -3., -5., -7.]) 
    &gt;&gt;&gt; 1 + (a / b) * x 
    array([-1., -3., -5., -7.]) 
 
    It reduces to the exponential function when `a = b`. 
 
    &gt;&gt;&gt; sc.hyp1f1(2, 2, [1, 2, 3, 4]) 
    array([ 2.71828183,  7.3890561 , 20.08553692, 54.59815003]) 
    &gt;&gt;&gt; np.exp([1, 2, 3, 4]) 
    array([ 2.71828183,  7.3890561 , 20.08553692, 54.59815003]) 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;hyperu&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    hyperu(a, b, x, out=None) 
 
    Confluent hypergeometric function U 
 
    It is defined as the solution to the equation 
 
    .. math:: 
 
       x \frac{d^2w}{dx^2} + (b - x) \frac{dw}{dx} - aw = 0 
 
    which satisfies the property 
 
    .. math:: 
 
       U(a, b, x) \sim x^{-a} 
 
    as :math:`x \to \infty`. See [dlmf]_ for more details. 
 
    Parameters 
    ---------- 
    a, b : array_like 
        Real-valued parameters 
    x : array_like 
        Real-valued argument 
    out : ndarray, optional 
        Optional output array for the function values 
 
    Returns 
    ------- 
    scalar or ndarray 
        Values of `U` 
 
    References 
    ---------- 
    .. [dlmf] NIST Digital Library of Mathematics Functions 
              https://dlmf.nist.gov/13.2#E6 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; import scipy.special as sc 
 
    It has a branch cut along the negative `x` axis. 
 
    &gt;&gt;&gt; x = np.linspace(-0.1, -10, 5) 
    &gt;&gt;&gt; sc.hyperu(1, 1, x) 
    array([nan, nan, nan, nan, nan]) 
 
    It approaches zero as `x` goes to infinity. 
 
    &gt;&gt;&gt; x = np.array([1, 10, 100]) 
    &gt;&gt;&gt; sc.hyperu(1, 1, x) 
    array([0.59634736, 0.09156333, 0.00990194]) 
 
    It satisfies Kummer's transformation. 
 
    &gt;&gt;&gt; a, b, x = 2, 1, 1 
    &gt;&gt;&gt; sc.hyperu(a, b, x) 
    0.1926947246463881 
    &gt;&gt;&gt; x**(1 - b) * sc.hyperu(a - b + 1, 2 - b, x) 
    0.1926947246463881 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;i0&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    i0(x, out=None) 
 
    Modified Bessel function of order 0. 
 
    Defined as, 
 
    .. math:: 
        I_0(x) = \sum_{k=0}^\infty \frac{(x^2/4)^k}{(k!)^2} = J_0(\imath x), 
 
    where :math:`J_0` is the Bessel function of the first kind of order 0. 
 
    Parameters 
    ---------- 
    x : array_like 
        Argument (float) 
    out : ndarray, optional 
        Optional output array for the function values 
 
    Returns 
    ------- 
    I : scalar or ndarray 
        Value of the modified Bessel function of order 0 at `x`. 
 
    See Also 
    -------- 
    iv: Modified Bessel function of any order 
    i0e: Exponentially scaled modified Bessel function of order 0 
 
    Notes 
    ----- 
    The range is partitioned into the two intervals [0, 8] and (8, infinity). 
    Chebyshev polynomial expansions are employed in each interval. 
 
    This function is a wrapper for the Cephes [1]_ routine `i0`. 
 
    References 
    ---------- 
    .. [1] Cephes Mathematical Functions Library, 
           http://www.netlib.org/cephes/ 
 
    Examples 
    -------- 
    Calculate the function at one point: 
 
    &gt;&gt;&gt; from scipy.special import i0 
    &gt;&gt;&gt; i0(1.) 
    1.2660658777520082 
 
    Calculate at several points: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; i0(np.array([-2., 0., 3.5])) 
    array([2.2795853 , 1.        , 7.37820343]) 
 
    Plot the function from -10 to 10. 
 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; fig, ax = plt.subplots() 
    &gt;&gt;&gt; x = np.linspace(-10., 10., 1000) 
    &gt;&gt;&gt; y = i0(x) 
    &gt;&gt;&gt; ax.plot(x, y) 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;i0e&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    i0e(x, out=None) 
 
    Exponentially scaled modified Bessel function of order 0. 
 
    Defined as:: 
 
        i0e(x) = exp(-abs(x)) * i0(x). 
 
    Parameters 
    ---------- 
    x : array_like 
        Argument (float) 
    out : ndarray, optional 
        Optional output array for the function values 
 
    Returns 
    ------- 
    I : scalar or ndarray 
        Value of the exponentially scaled modified Bessel function of order 0 
        at `x`. 
 
    See Also 
    -------- 
    iv: Modified Bessel function of the first kind 
    i0: Modified Bessel function of order 0 
 
    Notes 
    ----- 
    The range is partitioned into the two intervals [0, 8] and (8, infinity). 
    Chebyshev polynomial expansions are employed in each interval. The 
    polynomial expansions used are the same as those in `i0`, but 
    they are not multiplied by the dominant exponential factor. 
 
    This function is a wrapper for the Cephes [1]_ routine `i0e`. `i0e` 
    is useful for large arguments `x`: for these, `i0` quickly overflows. 
 
    References 
    ---------- 
    .. [1] Cephes Mathematical Functions Library, 
           http://www.netlib.org/cephes/ 
 
    Examples 
    -------- 
    In the following example `i0` returns infinity whereas `i0e` still returns 
    a finite number. 
 
    &gt;&gt;&gt; from scipy.special import i0, i0e 
    &gt;&gt;&gt; i0(1000.), i0e(1000.) 
    (inf, 0.012617240455891257) 
 
    Calculate the function at several points by providing a NumPy array or 
    list for `x`: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; i0e(np.array([-2., 0., 3.])) 
    array([0.30850832, 1.        , 0.24300035]) 
 
    Plot the function from -10 to 10. 
 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; fig, ax = plt.subplots() 
    &gt;&gt;&gt; x = np.linspace(-10., 10., 1000) 
    &gt;&gt;&gt; y = i0e(x) 
    &gt;&gt;&gt; ax.plot(x, y) 
    &gt;&gt;&gt; plt.show() 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;i1&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    i1(x, out=None) 
 
    Modified Bessel function of order 1. 
 
    Defined as, 
 
    .. math:: 
        I_1(x) = \frac{1}{2}x \sum_{k=0}^\infty \frac{(x^2/4)^k}{k! (k + 1)!} 
               = -\imath J_1(\imath x), 
 
    where :math:`J_1` is the Bessel function of the first kind of order 1. 
 
    Parameters 
    ---------- 
    x : array_like 
        Argument (float) 
    out : ndarray, optional 
        Optional output array for the function values 
 
    Returns 
    ------- 
    I : scalar or ndarray 
        Value of the modified Bessel function of order 1 at `x`. 
 
    See Also 
    -------- 
    iv: Modified Bessel function of the first kind 
    i1e: Exponentially scaled modified Bessel function of order 1 
 
    Notes 
    ----- 
    The range is partitioned into the two intervals [0, 8] and (8, infinity). 
    Chebyshev polynomial expansions are employed in each interval. 
 
    This function is a wrapper for the Cephes [1]_ routine `i1`. 
 
    References 
    ---------- 
    .. [1] Cephes Mathematical Functions Library, 
           http://www.netlib.org/cephes/ 
 
    Examples 
    -------- 
    Calculate the function at one point: 
 
    &gt;&gt;&gt; from scipy.special import i1 
    &gt;&gt;&gt; i1(1.) 
    0.5651591039924851 
 
    Calculate the function at several points: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; i1(np.array([-2., 0., 6.])) 
    array([-1.59063685,  0.        , 61.34193678]) 
 
    Plot the function between -10 and 10. 
 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; fig, ax = plt.subplots() 
    &gt;&gt;&gt; x = np.linspace(-10., 10., 1000) 
    &gt;&gt;&gt; y = i1(x) 
    &gt;&gt;&gt; ax.plot(x, y) 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;i1e&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    i1e(x, out=None) 
 
    Exponentially scaled modified Bessel function of order 1. 
 
    Defined as:: 
 
        i1e(x) = exp(-abs(x)) * i1(x) 
 
    Parameters 
    ---------- 
    x : array_like 
        Argument (float) 
    out : ndarray, optional 
        Optional output array for the function values 
 
    Returns 
    ------- 
    I : scalar or ndarray 
        Value of the exponentially scaled modified Bessel function of order 1 
        at `x`. 
 
    See Also 
    -------- 
    iv: Modified Bessel function of the first kind 
    i1: Modified Bessel function of order 1 
 
    Notes 
    ----- 
    The range is partitioned into the two intervals [0, 8] and (8, infinity). 
    Chebyshev polynomial expansions are employed in each interval. The 
    polynomial expansions used are the same as those in `i1`, but 
    they are not multiplied by the dominant exponential factor. 
 
    This function is a wrapper for the Cephes [1]_ routine `i1e`. `i1e` 
    is useful for large arguments `x`: for these, `i1` quickly overflows. 
 
    References 
    ---------- 
    .. [1] Cephes Mathematical Functions Library, 
           http://www.netlib.org/cephes/ 
 
    Examples 
    -------- 
    In the following example `i1` returns infinity whereas `i1e` still returns 
    a finite number. 
 
    &gt;&gt;&gt; from scipy.special import i1, i1e 
    &gt;&gt;&gt; i1(1000.), i1e(1000.) 
    (inf, 0.01261093025692863) 
 
    Calculate the function at several points by providing a NumPy array or 
    list for `x`: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; i1e(np.array([-2., 0., 6.])) 
    array([-0.21526929,  0.        ,  0.15205146]) 
 
    Plot the function between -10 and 10. 
 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; fig, ax = plt.subplots() 
    &gt;&gt;&gt; x = np.linspace(-10., 10., 1000) 
    &gt;&gt;&gt; y = i1e(x) 
    &gt;&gt;&gt; ax.plot(x, y) 
    &gt;&gt;&gt; plt.show() 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;_igam_fac&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    Internal function, do not use. 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;iv&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    iv(v, z, out=None) 
 
    Modified Bessel function of the first kind of real order. 
 
    Parameters 
    ---------- 
    v : array_like 
        Order. If `z` is of real type and negative, `v` must be integer 
        valued. 
    z : array_like of float or complex 
        Argument. 
    out : ndarray, optional 
        Optional output array for the function values 
 
    Returns 
    ------- 
    scalar or ndarray 
        Values of the modified Bessel function. 
 
    See Also 
    -------- 
    ive : This function with leading exponential behavior stripped off. 
    i0 : Faster version of this function for order 0. 
    i1 : Faster version of this function for order 1. 
 
    Notes 
    ----- 
    For real `z` and :math:`v \in [-50, 50]`, the evaluation is carried out 
    using Temme's method [1]_.  For larger orders, uniform asymptotic 
    expansions are applied. 
 
    For complex `z` and positive `v`, the AMOS [2]_ `zbesi` routine is 
    called. It uses a power series for small `z`, the asymptotic expansion 
    for large `abs(z)`, the Miller algorithm normalized by the Wronskian 
    and a Neumann series for intermediate magnitudes, and the uniform 
    asymptotic expansions for :math:`I_v(z)` and :math:`J_v(z)` for large 
    orders. Backward recurrence is used to generate sequences or reduce 
    orders when necessary. 
 
    The calculations above are done in the right half plane and continued 
    into the left half plane by the formula, 
 
    .. math:: I_v(z \exp(\pm\imath\pi)) = \exp(\pm\pi v) I_v(z) 
 
    (valid when the real part of `z` is positive).  For negative `v`, the 
    formula 
 
    .. math:: I_{-v}(z) = I_v(z) + \frac{2}{\pi} \sin(\pi v) K_v(z) 
 
    is used, where :math:`K_v(z)` is the modified Bessel function of the 
    second kind, evaluated using the AMOS routine `zbesk`. 
 
    References 
    ---------- 
    .. [1] Temme, Journal of Computational Physics, vol 21, 343 (1976) 
    .. [2] Donald E. Amos, &quot;AMOS, A Portable Package for Bessel Functions 
           of a Complex Argument and Nonnegative Order&quot;, 
           http://netlib.org/amos/ 
 
    Examples 
    -------- 
    Evaluate the function of order 0 at one point. 
 
    &gt;&gt;&gt; from scipy.special import iv 
    &gt;&gt;&gt; iv(0, 1.) 
    1.2660658777520084 
 
    Evaluate the function at one point for different orders. 
 
    &gt;&gt;&gt; iv(0, 1.), iv(1, 1.), iv(1.5, 1.) 
    (1.2660658777520084, 0.565159103992485, 0.2935253263474798) 
 
    The evaluation for different orders can be carried out in one call by 
    providing a list or NumPy array as argument for the `v` parameter: 
 
    &gt;&gt;&gt; iv([0, 1, 1.5], 1.) 
    array([1.26606588, 0.5651591 , 0.29352533]) 
 
    Evaluate the function at several points for order 0 by providing an 
    array for `z`. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; points = np.array([-2., 0., 3.]) 
    &gt;&gt;&gt; iv(0, points) 
    array([2.2795853 , 1.        , 4.88079259]) 
 
    If `z` is an array, the order parameter `v` must be broadcastable to 
    the correct shape if different orders shall be computed in one call. 
    To calculate the orders 0 and 1 for an 1D array: 
 
    &gt;&gt;&gt; orders = np.array([[0], [1]]) 
    &gt;&gt;&gt; orders.shape 
    (2, 1) 
 
    &gt;&gt;&gt; iv(orders, points) 
    array([[ 2.2795853 ,  1.        ,  4.88079259], 
           [-1.59063685,  0.        ,  3.95337022]]) 
 
    Plot the functions of order 0 to 3 from -5 to 5. 
 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; fig, ax = plt.subplots() 
    &gt;&gt;&gt; x = np.linspace(-5., 5., 1000) 
    &gt;&gt;&gt; for i in range(4): 
    ...     ax.plot(x, iv(i, x), label=f'$I_{i!r}$') 
    &gt;&gt;&gt; ax.legend() 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;ive&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    ive(v, z, out=None) 
 
    Exponentially scaled modified Bessel function of the first kind. 
 
    Defined as:: 
 
        ive(v, z) = iv(v, z) * exp(-abs(z.real)) 
 
    For imaginary numbers without a real part, returns the unscaled 
    Bessel function of the first kind `iv`. 
 
    Parameters 
    ---------- 
    v : array_like of float 
        Order. 
    z : array_like of float or complex 
        Argument. 
    out : ndarray, optional 
        Optional output array for the function values 
 
    Returns 
    ------- 
    scalar or ndarray 
        Values of the exponentially scaled modified Bessel function. 
 
    See Also 
    -------- 
    iv: Modified Bessel function of the first kind 
    i0e: Faster implementation of this function for order 0 
    i1e: Faster implementation of this function for order 1 
 
    Notes 
    ----- 
    For positive `v`, the AMOS [1]_ `zbesi` routine is called. It uses a 
    power series for small `z`, the asymptotic expansion for large 
    `abs(z)`, the Miller algorithm normalized by the Wronskian and a 
    Neumann series for intermediate magnitudes, and the uniform asymptotic 
    expansions for :math:`I_v(z)` and :math:`J_v(z)` for large orders. 
    Backward recurrence is used to generate sequences or reduce orders when 
    necessary. 
 
    The calculations above are done in the right half plane and continued 
    into the left half plane by the formula, 
 
    .. math:: I_v(z \exp(\pm\imath\pi)) = \exp(\pm\pi v) I_v(z) 
 
    (valid when the real part of `z` is positive).  For negative `v`, the 
    formula 
 
    .. math:: I_{-v}(z) = I_v(z) + \frac{2}{\pi} \sin(\pi v) K_v(z) 
 
    is used, where :math:`K_v(z)` is the modified Bessel function of the 
    second kind, evaluated using the AMOS routine `zbesk`. 
 
    `ive` is useful for large arguments `z`: for these, `iv` easily overflows, 
    while `ive` does not due to the exponential scaling. 
 
    References 
    ---------- 
    .. [1] Donald E. Amos, &quot;AMOS, A Portable Package for Bessel Functions 
           of a Complex Argument and Nonnegative Order&quot;, 
           http://netlib.org/amos/ 
 
    Examples 
    -------- 
    In the following example `iv` returns infinity whereas `ive` still returns 
    a finite number. 
 
    &gt;&gt;&gt; from scipy.special import iv, ive 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; iv(3, 1000.), ive(3, 1000.) 
    (inf, 0.01256056218254712) 
 
    Evaluate the function at one point for different orders by 
    providing a list or NumPy array as argument for the `v` parameter: 
 
    &gt;&gt;&gt; ive([0, 1, 1.5], 1.) 
    array([0.46575961, 0.20791042, 0.10798193]) 
 
    Evaluate the function at several points for order 0 by providing an 
    array for `z`. 
 
    &gt;&gt;&gt; points = np.array([-2., 0., 3.]) 
    &gt;&gt;&gt; ive(0, points) 
    array([0.30850832, 1.        , 0.24300035]) 
 
    Evaluate the function at several points for different orders by 
    providing arrays for both `v` for `z`. Both arrays have to be 
    broadcastable to the correct shape. To calculate the orders 0, 1 
    and 2 for a 1D array of points: 
 
    &gt;&gt;&gt; ive([[0], [1], [2]], points) 
    array([[ 0.30850832,  1.        ,  0.24300035], 
           [-0.21526929,  0.        ,  0.19682671], 
           [ 0.09323903,  0.        ,  0.11178255]]) 
 
    Plot the functions of order 0 to 3 from -5 to 5. 
 
    &gt;&gt;&gt; fig, ax = plt.subplots() 
    &gt;&gt;&gt; x = np.linspace(-5., 5., 1000) 
    &gt;&gt;&gt; for i in range(4): 
    ...     ax.plot(x, ive(i, x), label=fr'$I_{i!r}(z)\cdot e^{{-|z|}}$') 
    &gt;&gt;&gt; ax.legend() 
    &gt;&gt;&gt; ax.set_xlabel(r&quot;$z$&quot;) 
    &gt;&gt;&gt; plt.show() 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;j0&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    j0(x, out=None) 
 
    Bessel function of the first kind of order 0. 
 
    Parameters 
    ---------- 
    x : array_like 
        Argument (float). 
    out : ndarray, optional 
        Optional output array for the function values 
 
    Returns 
    ------- 
    J : scalar or ndarray 
        Value of the Bessel function of the first kind of order 0 at `x`. 
 
    See Also 
    -------- 
    jv : Bessel function of real order and complex argument. 
    spherical_jn : spherical Bessel functions. 
 
    Notes 
    ----- 
    The domain is divided into the intervals [0, 5] and (5, infinity). In the 
    first interval the following rational approximation is used: 
 
    .. math:: 
 
        J_0(x) \approx (w - r_1^2)(w - r_2^2) \frac{P_3(w)}{Q_8(w)}, 
 
    where :math:`w = x^2` and :math:`r_1`, :math:`r_2` are the zeros of 
    :math:`J_0`, and :math:`P_3` and :math:`Q_8` are polynomials of degrees 3 
    and 8, respectively. 
 
    In the second interval, the Hankel asymptotic expansion is employed with 
    two rational functions of degree 6/6 and 7/7. 
 
    This function is a wrapper for the Cephes [1]_ routine `j0`. 
    It should not be confused with the spherical Bessel functions (see 
    `spherical_jn`). 
 
    References 
    ---------- 
    .. [1] Cephes Mathematical Functions Library, 
           http://www.netlib.org/cephes/ 
 
    Examples 
    -------- 
    Calculate the function at one point: 
 
    &gt;&gt;&gt; from scipy.special import j0 
    &gt;&gt;&gt; j0(1.) 
    0.7651976865579665 
 
    Calculate the function at several points: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; j0(np.array([-2., 0., 4.])) 
    array([ 0.22389078,  1.        , -0.39714981]) 
 
    Plot the function from -20 to 20. 
 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; fig, ax = plt.subplots() 
    &gt;&gt;&gt; x = np.linspace(-20., 20., 1000) 
    &gt;&gt;&gt; y = j0(x) 
    &gt;&gt;&gt; ax.plot(x, y) 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;j1&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    j1(x, out=None) 
 
    Bessel function of the first kind of order 1. 
 
    Parameters 
    ---------- 
    x : array_like 
        Argument (float). 
    out : ndarray, optional 
        Optional output array for the function values 
 
    Returns 
    ------- 
    J : scalar or ndarray 
        Value of the Bessel function of the first kind of order 1 at `x`. 
 
    See Also 
    -------- 
    jv: Bessel function of the first kind 
    spherical_jn: spherical Bessel functions. 
 
    Notes 
    ----- 
    The domain is divided into the intervals [0, 8] and (8, infinity). In the 
    first interval a 24 term Chebyshev expansion is used. In the second, the 
    asymptotic trigonometric representation is employed using two rational 
    functions of degree 5/5. 
 
    This function is a wrapper for the Cephes [1]_ routine `j1`. 
    It should not be confused with the spherical Bessel functions (see 
    `spherical_jn`). 
 
    References 
    ---------- 
    .. [1] Cephes Mathematical Functions Library, 
           http://www.netlib.org/cephes/ 
 
    Examples 
    -------- 
    Calculate the function at one point: 
 
    &gt;&gt;&gt; from scipy.special import j1 
    &gt;&gt;&gt; j1(1.) 
    0.44005058574493355 
 
    Calculate the function at several points: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; j1(np.array([-2., 0., 4.])) 
    array([-0.57672481,  0.        , -0.06604333]) 
 
    Plot the function from -20 to 20. 
 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; fig, ax = plt.subplots() 
    &gt;&gt;&gt; x = np.linspace(-20., 20., 1000) 
    &gt;&gt;&gt; y = j1(x) 
    &gt;&gt;&gt; ax.plot(x, y) 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;jn&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    jn(n, x, out=None) 
 
    Bessel function of the first kind of integer order and real argument. 
 
    Parameters 
    ---------- 
    n : array_like 
        order of the Bessel function 
    x : array_like 
        argument of the Bessel function 
    out : ndarray, optional 
        Optional output array for the function values 
 
    Returns 
    ------- 
    scalar or ndarray 
        The value of the bessel function 
 
    See Also 
    -------- 
    jv 
    spherical_jn : spherical Bessel functions. 
 
    Notes 
    ----- 
    `jn` is an alias of `jv`. 
    Not to be confused with the spherical Bessel functions (see 
    `spherical_jn`). 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;jv&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    jv(v, z, out=None) 
 
    Bessel function of the first kind of real order and complex argument. 
 
    Parameters 
    ---------- 
    v : array_like 
        Order (float). 
    z : array_like 
        Argument (float or complex). 
    out : ndarray, optional 
        Optional output array for the function values 
 
    Returns 
    ------- 
    J : scalar or ndarray 
        Value of the Bessel function, :math:`J_v(z)`. 
 
    See Also 
    -------- 
    jve : :math:`J_v` with leading exponential behavior stripped off. 
    spherical_jn : spherical Bessel functions. 
    j0 : faster version of this function for order 0. 
    j1 : faster version of this function for order 1. 
 
    Notes 
    ----- 
    For positive `v` values, the computation is carried out using the AMOS 
    [1]_ `zbesj` routine, which exploits the connection to the modified 
    Bessel function :math:`I_v`, 
 
    .. math:: 
        J_v(z) = \exp(v\pi\imath/2) I_v(-\imath z)\qquad (\Im z &gt; 0) 
 
        J_v(z) = \exp(-v\pi\imath/2) I_v(\imath z)\qquad (\Im z &lt; 0) 
 
    For negative `v` values the formula, 
 
    .. math:: J_{-v}(z) = J_v(z) \cos(\pi v) - Y_v(z) \sin(\pi v) 
 
    is used, where :math:`Y_v(z)` is the Bessel function of the second 
    kind, computed using the AMOS routine `zbesy`.  Note that the second 
    term is exactly zero for integer `v`; to improve accuracy the second 
    term is explicitly omitted for `v` values such that `v = floor(v)`. 
 
    Not to be confused with the spherical Bessel functions (see `spherical_jn`). 
 
    References 
    ---------- 
    .. [1] Donald E. Amos, &quot;AMOS, A Portable Package for Bessel Functions 
           of a Complex Argument and Nonnegative Order&quot;, 
           http://netlib.org/amos/ 
 
    Examples 
    -------- 
    Evaluate the function of order 0 at one point. 
 
    &gt;&gt;&gt; from scipy.special import jv 
    &gt;&gt;&gt; jv(0, 1.) 
    0.7651976865579666 
 
    Evaluate the function at one point for different orders. 
 
    &gt;&gt;&gt; jv(0, 1.), jv(1, 1.), jv(1.5, 1.) 
    (0.7651976865579666, 0.44005058574493355, 0.24029783912342725) 
 
    The evaluation for different orders can be carried out in one call by 
    providing a list or NumPy array as argument for the `v` parameter: 
 
    &gt;&gt;&gt; jv([0, 1, 1.5], 1.) 
    array([0.76519769, 0.44005059, 0.24029784]) 
 
    Evaluate the function at several points for order 0 by providing an 
    array for `z`. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; points = np.array([-2., 0., 3.]) 
    &gt;&gt;&gt; jv(0, points) 
    array([ 0.22389078,  1.        , -0.26005195]) 
 
    If `z` is an array, the order parameter `v` must be broadcastable to 
    the correct shape if different orders shall be computed in one call. 
    To calculate the orders 0 and 1 for an 1D array: 
 
    &gt;&gt;&gt; orders = np.array([[0], [1]]) 
    &gt;&gt;&gt; orders.shape 
    (2, 1) 
 
    &gt;&gt;&gt; jv(orders, points) 
    array([[ 0.22389078,  1.        , -0.26005195], 
           [-0.57672481,  0.        ,  0.33905896]]) 
 
    Plot the functions of order 0 to 3 from -10 to 10. 
 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; fig, ax = plt.subplots() 
    &gt;&gt;&gt; x = np.linspace(-10., 10., 1000) 
    &gt;&gt;&gt; for i in range(4): 
    ...     ax.plot(x, jv(i, x), label=f'$J_{i!r}$') 
    &gt;&gt;&gt; ax.legend() 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;jve&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    jve(v, z, out=None) 
 
    Exponentially scaled Bessel function of the first kind of order `v`. 
 
    Defined as:: 
 
        jve(v, z) = jv(v, z) * exp(-abs(z.imag)) 
 
    Parameters 
    ---------- 
    v : array_like 
        Order (float). 
    z : array_like 
        Argument (float or complex). 
    out : ndarray, optional 
        Optional output array for the function values 
 
    Returns 
    ------- 
    J : scalar or ndarray 
        Value of the exponentially scaled Bessel function. 
 
    See Also 
    -------- 
    jv: Unscaled Bessel function of the first kind 
 
    Notes 
    ----- 
    For positive `v` values, the computation is carried out using the AMOS 
    [1]_ `zbesj` routine, which exploits the connection to the modified 
    Bessel function :math:`I_v`, 
 
    .. math:: 
        J_v(z) = \exp(v\pi\imath/2) I_v(-\imath z)\qquad (\Im z &gt; 0) 
 
        J_v(z) = \exp(-v\pi\imath/2) I_v(\imath z)\qquad (\Im z &lt; 0) 
 
    For negative `v` values the formula, 
 
    .. math:: J_{-v}(z) = J_v(z) \cos(\pi v) - Y_v(z) \sin(\pi v) 
 
    is used, where :math:`Y_v(z)` is the Bessel function of the second 
    kind, computed using the AMOS routine `zbesy`.  Note that the second 
    term is exactly zero for integer `v`; to improve accuracy the second 
    term is explicitly omitted for `v` values such that `v = floor(v)`. 
 
    Exponentially scaled Bessel functions are useful for large arguments `z`: 
    for these, the unscaled Bessel functions can easily under-or overflow. 
 
    References 
    ---------- 
    .. [1] Donald E. Amos, &quot;AMOS, A Portable Package for Bessel Functions 
           of a Complex Argument and Nonnegative Order&quot;, 
           http://netlib.org/amos/ 
 
    Examples 
    -------- 
    Compare the output of `jv` and `jve` for large complex arguments for `z` 
    by computing their values for order ``v=1`` at ``z=1000j``. We see that 
    `jv` overflows but `jve` returns a finite number: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.special import jv, jve 
    &gt;&gt;&gt; v = 1 
    &gt;&gt;&gt; z = 1000j 
    &gt;&gt;&gt; jv(v, z), jve(v, z) 
    ((inf+infj), (7.721967686709077e-19+0.012610930256928629j)) 
 
    For real arguments for `z`, `jve` returns the same as `jv`. 
 
    &gt;&gt;&gt; v, z = 1, 1000 
    &gt;&gt;&gt; jv(v, z), jve(v, z) 
    (0.004728311907089523, 0.004728311907089523) 
 
    The function can be evaluated for several orders at the same time by 
    providing a list or NumPy array for `v`: 
 
    &gt;&gt;&gt; jve([1, 3, 5], 1j) 
    array([1.27304208e-17+2.07910415e-01j, -4.99352086e-19-8.15530777e-03j, 
           6.11480940e-21+9.98657141e-05j]) 
 
    In the same way, the function can be evaluated at several points in one 
    call by providing a list or NumPy array for `z`: 
 
    &gt;&gt;&gt; jve(1, np.array([1j, 2j, 3j])) 
    array([1.27308412e-17+0.20791042j, 1.31814423e-17+0.21526929j, 
           1.20521602e-17+0.19682671j]) 
 
    It is also possible to evaluate several orders at several points 
    at the same time by providing arrays for `v` and `z` with 
    compatible shapes for broadcasting. Compute `jve` for two different orders 
    `v` and three points `z` resulting in a 2x3 array. 
 
    &gt;&gt;&gt; v = np.array([[1], [3]]) 
    &gt;&gt;&gt; z = np.array([1j, 2j, 3j]) 
    &gt;&gt;&gt; v.shape, z.shape 
    ((2, 1), (3,)) 
 
    &gt;&gt;&gt; jve(v, z) 
    array([[1.27304208e-17+0.20791042j,  1.31810070e-17+0.21526929j, 
            1.20517622e-17+0.19682671j], 
           [-4.99352086e-19-0.00815531j, -1.76289571e-18-0.02879122j, 
            -2.92578784e-18-0.04778332j]]) 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;k0&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    k0(x, out=None) 
 
    Modified Bessel function of the second kind of order 0, :math:`K_0`. 
 
    This function is also sometimes referred to as the modified Bessel 
    function of the third kind of order 0. 
 
    Parameters 
    ---------- 
    x : array_like 
        Argument (float). 
    out : ndarray, optional 
        Optional output array for the function values 
 
    Returns 
    ------- 
    K : scalar or ndarray 
        Value of the modified Bessel function :math:`K_0` at `x`. 
 
    See Also 
    -------- 
    kv: Modified Bessel function of the second kind of any order 
    k0e: Exponentially scaled modified Bessel function of the second kind 
 
    Notes 
    ----- 
    The range is partitioned into the two intervals [0, 2] and (2, infinity). 
    Chebyshev polynomial expansions are employed in each interval. 
 
    This function is a wrapper for the Cephes [1]_ routine `k0`. 
 
    References 
    ---------- 
    .. [1] Cephes Mathematical Functions Library, 
           http://www.netlib.org/cephes/ 
 
    Examples 
    -------- 
    Calculate the function at one point: 
 
    &gt;&gt;&gt; from scipy.special import k0 
    &gt;&gt;&gt; k0(1.) 
    0.42102443824070823 
 
    Calculate the function at several points: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; k0(np.array([0.5, 2., 3.])) 
    array([0.92441907, 0.11389387, 0.0347395 ]) 
 
    Plot the function from 0 to 10. 
 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; fig, ax = plt.subplots() 
    &gt;&gt;&gt; x = np.linspace(0., 10., 1000) 
    &gt;&gt;&gt; y = k0(x) 
    &gt;&gt;&gt; ax.plot(x, y) 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;k0e&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    k0e(x, out=None) 
 
    Exponentially scaled modified Bessel function K of order 0 
 
    Defined as:: 
 
        k0e(x) = exp(x) * k0(x). 
 
    Parameters 
    ---------- 
    x : array_like 
        Argument (float) 
    out : ndarray, optional 
        Optional output array for the function values 
 
    Returns 
    ------- 
    K : scalar or ndarray 
        Value of the exponentially scaled modified Bessel function K of order 
        0 at `x`. 
 
    See Also 
    -------- 
    kv: Modified Bessel function of the second kind of any order 
    k0: Modified Bessel function of the second kind 
 
    Notes 
    ----- 
    The range is partitioned into the two intervals [0, 2] and (2, infinity). 
    Chebyshev polynomial expansions are employed in each interval. 
 
    This function is a wrapper for the Cephes [1]_ routine `k0e`. `k0e` is 
    useful for large arguments: for these, `k0` easily underflows. 
 
    References 
    ---------- 
    .. [1] Cephes Mathematical Functions Library, 
           http://www.netlib.org/cephes/ 
 
    Examples 
    -------- 
    In the following example `k0` returns 0 whereas `k0e` still returns a 
    useful finite number: 
 
    &gt;&gt;&gt; from scipy.special import k0, k0e 
    &gt;&gt;&gt; k0(1000.), k0e(1000) 
    (0., 0.03962832160075422) 
 
    Calculate the function at several points by providing a NumPy array or 
    list for `x`: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; k0e(np.array([0.5, 2., 3.])) 
    array([1.52410939, 0.84156822, 0.6977616 ]) 
 
    Plot the function from 0 to 10. 
 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; fig, ax = plt.subplots() 
    &gt;&gt;&gt; x = np.linspace(0., 10., 1000) 
    &gt;&gt;&gt; y = k0e(x) 
    &gt;&gt;&gt; ax.plot(x, y) 
    &gt;&gt;&gt; plt.show() 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;k1&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    k1(x, out=None) 
 
    Modified Bessel function of the second kind of order 1, :math:`K_1(x)`. 
 
    Parameters 
    ---------- 
    x : array_like 
        Argument (float) 
    out : ndarray, optional 
        Optional output array for the function values 
 
    Returns 
    ------- 
    K : scalar or ndarray 
        Value of the modified Bessel function K of order 1 at `x`. 
 
    See Also 
    -------- 
    kv: Modified Bessel function of the second kind of any order 
    k1e: Exponentially scaled modified Bessel function K of order 1 
 
    Notes 
    ----- 
    The range is partitioned into the two intervals [0, 2] and (2, infinity). 
    Chebyshev polynomial expansions are employed in each interval. 
 
    This function is a wrapper for the Cephes [1]_ routine `k1`. 
 
    References 
    ---------- 
    .. [1] Cephes Mathematical Functions Library, 
           http://www.netlib.org/cephes/ 
 
    Examples 
    -------- 
    Calculate the function at one point: 
 
    &gt;&gt;&gt; from scipy.special import k1 
    &gt;&gt;&gt; k1(1.) 
    0.6019072301972346 
 
    Calculate the function at several points: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; k1(np.array([0.5, 2., 3.])) 
    array([1.65644112, 0.13986588, 0.04015643]) 
 
    Plot the function from 0 to 10. 
 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; fig, ax = plt.subplots() 
    &gt;&gt;&gt; x = np.linspace(0., 10., 1000) 
    &gt;&gt;&gt; y = k1(x) 
    &gt;&gt;&gt; ax.plot(x, y) 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;k1e&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    k1e(x, out=None) 
 
    Exponentially scaled modified Bessel function K of order 1 
 
    Defined as:: 
 
        k1e(x) = exp(x) * k1(x) 
 
    Parameters 
    ---------- 
    x : array_like 
        Argument (float) 
    out : ndarray, optional 
        Optional output array for the function values 
 
    Returns 
    ------- 
    K : scalar or ndarray 
        Value of the exponentially scaled modified Bessel function K of order 
        1 at `x`. 
 
    See Also 
    -------- 
    kv: Modified Bessel function of the second kind of any order 
    k1: Modified Bessel function of the second kind of order 1 
 
    Notes 
    ----- 
    The range is partitioned into the two intervals [0, 2] and (2, infinity). 
    Chebyshev polynomial expansions are employed in each interval. 
 
    This function is a wrapper for the Cephes [1]_ routine `k1e`. 
 
    References 
    ---------- 
    .. [1] Cephes Mathematical Functions Library, 
           http://www.netlib.org/cephes/ 
 
    Examples 
    -------- 
    In the following example `k1` returns 0 whereas `k1e` still returns a 
    useful floating point number. 
 
    &gt;&gt;&gt; from scipy.special import k1, k1e 
    &gt;&gt;&gt; k1(1000.), k1e(1000.) 
    (0., 0.03964813081296021) 
 
    Calculate the function at several points by providing a NumPy array or 
    list for `x`: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; k1e(np.array([0.5, 2., 3.])) 
    array([2.73100971, 1.03347685, 0.80656348]) 
 
    Plot the function from 0 to 10. 
 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; fig, ax = plt.subplots() 
    &gt;&gt;&gt; x = np.linspace(0., 10., 1000) 
    &gt;&gt;&gt; y = k1e(x) 
    &gt;&gt;&gt; ax.plot(x, y) 
    &gt;&gt;&gt; plt.show() 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;kelvin&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    kelvin(x, out=None) 
 
    Kelvin functions as complex numbers 
 
    Parameters 
    ---------- 
    x : array_like 
        Argument 
    out : tuple of ndarray, optional 
        Optional output arrays for the function values 
 
    Returns 
    ------- 
    Be, Ke, Bep, Kep : 4-tuple of scalar or ndarray 
        The tuple (Be, Ke, Bep, Kep) contains complex numbers 
        representing the real and imaginary Kelvin functions and their 
        derivatives evaluated at `x`.  For example, kelvin(x)[0].real = 
        ber x and kelvin(x)[0].imag = bei x with similar relationships 
        for ker and kei. 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;ker&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    ker(x, out=None) 
 
    Kelvin function ker. 
 
    Defined as 
 
    .. math:: 
 
        \mathrm{ker}(x) = \Re[K_0(x e^{\pi i / 4})] 
 
    Where :math:`K_0` is the modified Bessel function of the second 
    kind (see `kv`). See [dlmf]_ for more details. 
 
    Parameters 
    ---------- 
    x : array_like 
        Real argument. 
    out : ndarray, optional 
        Optional output array for the function results. 
 
    Returns 
    ------- 
    scalar or ndarray 
        Values of the Kelvin function. 
 
    See Also 
    -------- 
    kei : the corresponding imaginary part 
    kerp : the derivative of ker 
    kv : modified Bessel function of the second kind 
 
    References 
    ---------- 
    .. [dlmf] NIST, Digital Library of Mathematical Functions, 
        https://dlmf.nist.gov/10.61 
 
    Examples 
    -------- 
    It can be expressed using the modified Bessel function of the 
    second kind. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; import scipy.special as sc 
    &gt;&gt;&gt; x = np.array([1.0, 2.0, 3.0, 4.0]) 
    &gt;&gt;&gt; sc.kv(0, x * np.exp(np.pi * 1j / 4)).real 
    array([ 0.28670621, -0.04166451, -0.06702923, -0.03617885]) 
    &gt;&gt;&gt; sc.ker(x) 
    array([ 0.28670621, -0.04166451, -0.06702923, -0.03617885]) 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;kerp&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    kerp(x, out=None) 
 
    Derivative of the Kelvin function ker. 
 
    Parameters 
    ---------- 
    x : array_like 
        Real argument. 
    out : ndarray, optional 
        Optional output array for the function results. 
 
    Returns 
    ------- 
    scalar or ndarray 
        Values of the derivative of ker. 
 
    See Also 
    -------- 
    ker 
 
    References 
    ---------- 
    .. [dlmf] NIST, Digital Library of Mathematical Functions, 
        https://dlmf.nist.gov/10#PT5 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;kl_div&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    kl_div(x, y, out=None) 
 
    Elementwise function for computing Kullback-Leibler divergence. 
 
    .. math:: 
 
        \mathrm{kl\_div}(x, y) = 
          \begin{cases} 
            x \log(x / y) - x + y &amp; x &gt; 0, y &gt; 0 \\ 
            y &amp; x = 0, y \ge 0 \\ 
            \infty &amp; \text{otherwise} 
          \end{cases} 
 
    Parameters 
    ---------- 
    x, y : array_like 
        Real arguments 
    out : ndarray, optional 
        Optional output array for the function results 
 
    Returns 
    ------- 
    scalar or ndarray 
        Values of the Kullback-Liebler divergence. 
 
    See Also 
    -------- 
    entr, rel_entr, scipy.stats.entropy 
 
    Notes 
    ----- 
    .. versionadded:: 0.15.0 
 
    This function is non-negative and is jointly convex in `x` and `y`. 
 
    The origin of this function is in convex programming; see [1]_ for 
    details. This is why the function contains the extra :math:`-x 
    + y` terms over what might be expected from the Kullback-Leibler 
    divergence. For a version of the function without the extra terms, 
    see `rel_entr`. 
 
    References 
    ---------- 
    .. [1] Boyd, Stephen and Lieven Vandenberghe. *Convex optimization*. 
           Cambridge University Press, 2004. 
           :doi:`https://doi.org/10.1017/CBO9780511804441` 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;kn&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    kn(n, x, out=None) 
 
    Modified Bessel function of the second kind of integer order `n` 
 
    Returns the modified Bessel function of the second kind for integer order 
    `n` at real `z`. 
 
    These are also sometimes called functions of the third kind, Basset 
    functions, or Macdonald functions. 
 
    Parameters 
    ---------- 
    n : array_like of int 
        Order of Bessel functions (floats will truncate with a warning) 
    x : array_like of float 
        Argument at which to evaluate the Bessel functions 
    out : ndarray, optional 
        Optional output array for the function results. 
 
    Returns 
    ------- 
    scalar or ndarray 
        Value of the Modified Bessel function of the second kind, 
        :math:`K_n(x)`. 
 
    See Also 
    -------- 
    kv : Same function, but accepts real order and complex argument 
    kvp : Derivative of this function 
 
    Notes 
    ----- 
    Wrapper for AMOS [1]_ routine `zbesk`.  For a discussion of the 
    algorithm used, see [2]_ and the references therein. 
 
    References 
    ---------- 
    .. [1] Donald E. Amos, &quot;AMOS, A Portable Package for Bessel Functions 
           of a Complex Argument and Nonnegative Order&quot;, 
           http://netlib.org/amos/ 
    .. [2] Donald E. Amos, &quot;Algorithm 644: A portable package for Bessel 
           functions of a complex argument and nonnegative order&quot;, ACM 
           TOMS Vol. 12 Issue 3, Sept. 1986, p. 265 
 
    Examples 
    -------- 
    Plot the function of several orders for real input: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.special import kn 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; x = np.linspace(0, 5, 1000) 
    &gt;&gt;&gt; for N in range(6): 
    ...     plt.plot(x, kn(N, x), label='$K_{}(x)$'.format(N)) 
    &gt;&gt;&gt; plt.ylim(0, 10) 
    &gt;&gt;&gt; plt.legend() 
    &gt;&gt;&gt; plt.title(r'Modified Bessel function of the second kind $K_n(x)$') 
    &gt;&gt;&gt; plt.show() 
 
    Calculate for a single value at multiple orders: 
 
    &gt;&gt;&gt; kn([4, 5, 6], 1) 
    array([   44.23241585,   360.9605896 ,  3653.83831186]) 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;kolmogi&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    kolmogi(p, out=None) 
 
    Inverse Survival Function of Kolmogorov distribution 
 
    It is the inverse function to `kolmogorov`. 
    Returns y such that ``kolmogorov(y) == p``. 
 
    Parameters 
    ---------- 
    p : float array_like 
        Probability 
    out : ndarray, optional 
        Optional output array for the function results 
 
    Returns 
    ------- 
    scalar or ndarray 
        The value(s) of kolmogi(p) 
 
    See Also 
    -------- 
    kolmogorov : The Survival Function for the distribution 
    scipy.stats.kstwobign : Provides the functionality as a continuous distribution 
    smirnov, smirnovi : Functions for the one-sided distribution 
 
    Notes 
    ----- 
    `kolmogorov` is used by `stats.kstest` in the application of the 
    Kolmogorov-Smirnov Goodness of Fit test. For historical reasons this 
    function is exposed in `scpy.special`, but the recommended way to achieve 
    the most accurate CDF/SF/PDF/PPF/ISF computations is to use the 
    `stats.kstwobign` distribution. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.special import kolmogi 
    &gt;&gt;&gt; kolmogi([0, 0.1, 0.25, 0.5, 0.75, 0.9, 1.0]) 
    array([        inf,  1.22384787,  1.01918472,  0.82757356,  0.67644769, 
            0.57117327,  0.        ]) 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;kolmogorov&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    kolmogorov(y, out=None) 
 
    Complementary cumulative distribution (Survival Function) function of 
    Kolmogorov distribution. 
 
    Returns the complementary cumulative distribution function of 
    Kolmogorov's limiting distribution (``D_n*\sqrt(n)`` as n goes to infinity) 
    of a two-sided test for equality between an empirical and a theoretical 
    distribution. It is equal to the (limit as n-&gt;infinity of the) 
    probability that ``sqrt(n) * max absolute deviation &gt; y``. 
 
    Parameters 
    ---------- 
    y : float array_like 
      Absolute deviation between the Empirical CDF (ECDF) and the target CDF, 
      multiplied by sqrt(n). 
    out : ndarray, optional 
        Optional output array for the function results 
 
    Returns 
    ------- 
    scalar or ndarray 
        The value(s) of kolmogorov(y) 
 
    See Also 
    -------- 
    kolmogi : The Inverse Survival Function for the distribution 
    scipy.stats.kstwobign : Provides the functionality as a continuous distribution 
    smirnov, smirnovi : Functions for the one-sided distribution 
 
    Notes 
    ----- 
    `kolmogorov` is used by `stats.kstest` in the application of the 
    Kolmogorov-Smirnov Goodness of Fit test. For historical reasons this 
    function is exposed in `scpy.special`, but the recommended way to achieve 
    the most accurate CDF/SF/PDF/PPF/ISF computations is to use the 
    `stats.kstwobign` distribution. 
 
    Examples 
    -------- 
    Show the probability of a gap at least as big as 0, 0.5 and 1.0. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.special import kolmogorov 
    &gt;&gt;&gt; from scipy.stats import kstwobign 
    &gt;&gt;&gt; kolmogorov([0, 0.5, 1.0]) 
    array([ 1.        ,  0.96394524,  0.26999967]) 
 
    Compare a sample of size 1000 drawn from a Laplace(0, 1) distribution against 
    the target distribution, a Normal(0, 1) distribution. 
 
    &gt;&gt;&gt; from scipy.stats import norm, laplace 
    &gt;&gt;&gt; rng = np.random.default_rng() 
    &gt;&gt;&gt; n = 1000 
    &gt;&gt;&gt; lap01 = laplace(0, 1) 
    &gt;&gt;&gt; x = np.sort(lap01.rvs(n, random_state=rng)) 
    &gt;&gt;&gt; np.mean(x), np.std(x) 
    (-0.05841730131499543, 1.3968109101997568) 
 
    Construct the Empirical CDF and the K-S statistic Dn. 
 
    &gt;&gt;&gt; target = norm(0,1)  # Normal mean 0, stddev 1 
    &gt;&gt;&gt; cdfs = target.cdf(x) 
    &gt;&gt;&gt; ecdfs = np.arange(n+1, dtype=float)/n 
    &gt;&gt;&gt; gaps = np.column_stack([cdfs - ecdfs[:n], ecdfs[1:] - cdfs]) 
    &gt;&gt;&gt; Dn = np.max(gaps) 
    &gt;&gt;&gt; Kn = np.sqrt(n) * Dn 
    &gt;&gt;&gt; print('Dn=%f, sqrt(n)*Dn=%f' % (Dn, Kn)) 
    Dn=0.043363, sqrt(n)*Dn=1.371265 
    &gt;&gt;&gt; print(chr(10).join(['For a sample of size n drawn from a N(0, 1) distribution:', 
    ...   ' the approximate Kolmogorov probability that sqrt(n)*Dn&gt;=%f is %f' % 
    ...    (Kn, kolmogorov(Kn)), 
    ...   ' the approximate Kolmogorov probability that sqrt(n)*Dn&lt;=%f is %f' % 
    ...    (Kn, kstwobign.cdf(Kn))])) 
    For a sample of size n drawn from a N(0, 1) distribution: 
     the approximate Kolmogorov probability that sqrt(n)*Dn&gt;=1.371265 is 0.046533 
     the approximate Kolmogorov probability that sqrt(n)*Dn&lt;=1.371265 is 0.953467 
 
    Plot the Empirical CDF against the target N(0, 1) CDF. 
 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; plt.step(np.concatenate([[-3], x]), ecdfs, where='post', label='Empirical CDF') 
    &gt;&gt;&gt; x3 = np.linspace(-3, 3, 100) 
    &gt;&gt;&gt; plt.plot(x3, target.cdf(x3), label='CDF for N(0, 1)') 
    &gt;&gt;&gt; plt.ylim([0, 1]); plt.grid(True); plt.legend(); 
    &gt;&gt;&gt; # Add vertical lines marking Dn+ and Dn- 
    &gt;&gt;&gt; iminus, iplus = np.argmax(gaps, axis=0) 
    &gt;&gt;&gt; plt.vlines([x[iminus]], ecdfs[iminus], cdfs[iminus], 
    ...            color='r', linestyle='dashed', lw=4) 
    &gt;&gt;&gt; plt.vlines([x[iplus]], cdfs[iplus], ecdfs[iplus+1], 
    ...            color='r', linestyle='dashed', lw=4) 
    &gt;&gt;&gt; plt.show() 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;_kolmogc&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    Internal function, do not use. 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;_kolmogci&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    Internal function, do not use. 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;_kolmogp&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    Internal function, do not use. 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;kv&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    kv(v, z, out=None) 
 
    Modified Bessel function of the second kind of real order `v` 
 
    Returns the modified Bessel function of the second kind for real order 
    `v` at complex `z`. 
 
    These are also sometimes called functions of the third kind, Basset 
    functions, or Macdonald functions.  They are defined as those solutions 
    of the modified Bessel equation for which, 
 
    .. math:: 
        K_v(x) \sim \sqrt{\pi/(2x)} \exp(-x) 
 
    as :math:`x \to \infty` [3]_. 
 
    Parameters 
    ---------- 
    v : array_like of float 
        Order of Bessel functions 
    z : array_like of complex 
        Argument at which to evaluate the Bessel functions 
    out : ndarray, optional 
        Optional output array for the function results 
 
    Returns 
    ------- 
    scalar or ndarray 
        The results. Note that input must be of complex type to get complex 
        output, e.g. ``kv(3, -2+0j)`` instead of ``kv(3, -2)``. 
 
    See Also 
    -------- 
    kve : This function with leading exponential behavior stripped off. 
    kvp : Derivative of this function 
 
    Notes 
    ----- 
    Wrapper for AMOS [1]_ routine `zbesk`.  For a discussion of the 
    algorithm used, see [2]_ and the references therein. 
 
    References 
    ---------- 
    .. [1] Donald E. Amos, &quot;AMOS, A Portable Package for Bessel Functions 
           of a Complex Argument and Nonnegative Order&quot;, 
           http://netlib.org/amos/ 
    .. [2] Donald E. Amos, &quot;Algorithm 644: A portable package for Bessel 
           functions of a complex argument and nonnegative order&quot;, ACM 
           TOMS Vol. 12 Issue 3, Sept. 1986, p. 265 
    .. [3] NIST Digital Library of Mathematical Functions, 
           Eq. 10.25.E3. https://dlmf.nist.gov/10.25.E3 
 
    Examples 
    -------- 
    Plot the function of several orders for real input: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.special import kv 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; x = np.linspace(0, 5, 1000) 
    &gt;&gt;&gt; for N in np.linspace(0, 6, 5): 
    ...     plt.plot(x, kv(N, x), label='$K_{{{}}}(x)$'.format(N)) 
    &gt;&gt;&gt; plt.ylim(0, 10) 
    &gt;&gt;&gt; plt.legend() 
    &gt;&gt;&gt; plt.title(r'Modified Bessel function of the second kind $K_\nu(x)$') 
    &gt;&gt;&gt; plt.show() 
 
    Calculate for a single value at multiple orders: 
 
    &gt;&gt;&gt; kv([4, 4.5, 5], 1+2j) 
    array([ 0.1992+2.3892j,  2.3493+3.6j   ,  7.2827+3.8104j]) 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;kve&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    kve(v, z, out=None) 
 
    Exponentially scaled modified Bessel function of the second kind. 
 
    Returns the exponentially scaled, modified Bessel function of the 
    second kind (sometimes called the third kind) for real order `v` at 
    complex `z`:: 
 
        kve(v, z) = kv(v, z) * exp(z) 
 
    Parameters 
    ---------- 
    v : array_like of float 
        Order of Bessel functions 
    z : array_like of complex 
        Argument at which to evaluate the Bessel functions 
    out : ndarray, optional 
        Optional output array for the function results 
 
    Returns 
    ------- 
    scalar or ndarray 
        The exponentially scaled modified Bessel function of the second kind. 
 
    See Also 
    -------- 
    kv : This function without exponential scaling. 
    k0e : Faster version of this function for order 0. 
    k1e : Faster version of this function for order 1. 
 
    Notes 
    ----- 
    Wrapper for AMOS [1]_ routine `zbesk`.  For a discussion of the 
    algorithm used, see [2]_ and the references therein. 
 
    References 
    ---------- 
    .. [1] Donald E. Amos, &quot;AMOS, A Portable Package for Bessel Functions 
           of a Complex Argument and Nonnegative Order&quot;, 
           http://netlib.org/amos/ 
    .. [2] Donald E. Amos, &quot;Algorithm 644: A portable package for Bessel 
           functions of a complex argument and nonnegative order&quot;, ACM 
           TOMS Vol. 12 Issue 3, Sept. 1986, p. 265 
 
    Examples 
    -------- 
    In the following example `kv` returns 0 whereas `kve` still returns 
    a useful finite number. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.special import kv, kve 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; kv(3, 1000.), kve(3, 1000.) 
    (0.0, 0.03980696128440973) 
 
    Evaluate the function at one point for different orders by 
    providing a list or NumPy array as argument for the `v` parameter: 
 
    &gt;&gt;&gt; kve([0, 1, 1.5], 1.) 
    array([1.14446308, 1.63615349, 2.50662827]) 
 
    Evaluate the function at several points for order 0 by providing an 
    array for `z`. 
 
    &gt;&gt;&gt; points = np.array([1., 3., 10.]) 
    &gt;&gt;&gt; kve(0, points) 
    array([1.14446308, 0.6977616 , 0.39163193]) 
 
    Evaluate the function at several points for different orders by 
    providing arrays for both `v` for `z`. Both arrays have to be 
    broadcastable to the correct shape. To calculate the orders 0, 1 
    and 2 for a 1D array of points: 
 
    &gt;&gt;&gt; kve([[0], [1], [2]], points) 
    array([[1.14446308, 0.6977616 , 0.39163193], 
           [1.63615349, 0.80656348, 0.41076657], 
           [4.41677005, 1.23547058, 0.47378525]]) 
 
    Plot the functions of order 0 to 3 from 0 to 5. 
 
    &gt;&gt;&gt; fig, ax = plt.subplots() 
    &gt;&gt;&gt; x = np.linspace(0., 5., 1000) 
    &gt;&gt;&gt; for i in range(4): 
    ...     ax.plot(x, kve(i, x), label=fr'$K_{i!r}(z)\cdot e^z$') 
    &gt;&gt;&gt; ax.legend() 
    &gt;&gt;&gt; ax.set_xlabel(r&quot;$z$&quot;) 
    &gt;&gt;&gt; ax.set_ylim(0, 4) 
    &gt;&gt;&gt; ax.set_xlim(0, 5) 
    &gt;&gt;&gt; plt.show() 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;_lanczos_sum_expg_scaled&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    Internal function, do not use. 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;_lgam1p&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    Internal function, do not use. 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;log1p&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    log1p(x, out=None) 
 
    Calculates log(1 + x) for use when `x` is near zero. 
 
    Parameters 
    ---------- 
    x : array_like 
        Real or complex valued input. 
    out : ndarray, optional 
        Optional output array for the function results. 
 
    Returns 
    ------- 
    scalar or ndarray 
        Values of ``log(1 + x)``. 
 
    See Also 
    -------- 
    expm1, cosm1 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; import scipy.special as sc 
 
    It is more accurate than using ``log(1 + x)`` directly for ``x`` 
    near 0. Note that in the below example ``1 + 1e-17 == 1`` to 
    double precision. 
 
    &gt;&gt;&gt; sc.log1p(1e-17) 
    1e-17 
    &gt;&gt;&gt; np.log(1 + 1e-17) 
    0.0 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;_log1pmx&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    Internal function, do not use. 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;lpmv&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    lpmv(m, v, x, out=None) 
 
    Associated Legendre function of integer order and real degree. 
 
    Defined as 
 
    .. math:: 
 
        P_v^m = (-1)^m (1 - x^2)^{m/2} \frac{d^m}{dx^m} P_v(x) 
 
    where 
 
    .. math:: 
 
        P_v = \sum_{k = 0}^\infty \frac{(-v)_k (v + 1)_k}{(k!)^2} 
                \left(\frac{1 - x}{2}\right)^k 
 
    is the Legendre function of the first kind. Here :math:`(\cdot)_k` 
    is the Pochhammer symbol; see `poch`. 
 
    Parameters 
    ---------- 
    m : array_like 
        Order (int or float). If passed a float not equal to an 
        integer the function returns NaN. 
    v : array_like 
        Degree (float). 
    x : array_like 
        Argument (float). Must have ``|x| &lt;= 1``. 
    out : ndarray, optional 
        Optional output array for the function results 
 
    Returns 
    ------- 
    pmv : scalar or ndarray 
        Value of the associated Legendre function. 
 
    See Also 
    -------- 
    lpmn : Compute the associated Legendre function for all orders 
           ``0, ..., m`` and degrees ``0, ..., n``. 
    clpmn : Compute the associated Legendre function at complex 
            arguments. 
 
    Notes 
    ----- 
    Note that this implementation includes the Condon-Shortley phase. 
 
    References 
    ---------- 
    .. [1] Zhang, Jin, &quot;Computation of Special Functions&quot;, John Wiley 
           and Sons, Inc, 1996. 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;modstruve&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    modstruve(v, x, out=None) 
 
    Modified Struve function. 
 
    Return the value of the modified Struve function of order `v` at `x`.  The 
    modified Struve function is defined as, 
 
    .. math:: 
        L_v(x) = -\imath \exp(-\pi\imath v/2) H_v(\imath x), 
 
    where :math:`H_v` is the Struve function. 
 
    Parameters 
    ---------- 
    v : array_like 
        Order of the modified Struve function (float). 
    x : array_like 
        Argument of the Struve function (float; must be positive unless `v` is 
        an integer). 
    out : ndarray, optional 
        Optional output array for the function results 
 
    Returns 
    ------- 
    L : scalar or ndarray 
        Value of the modified Struve function of order `v` at `x`. 
 
    See Also 
    -------- 
    struve 
 
    Notes 
    ----- 
    Three methods discussed in [1]_ are used to evaluate the function: 
 
    - power series 
    - expansion in Bessel functions (if :math:`|x| &lt; |v| + 20`) 
    - asymptotic large-x expansion (if :math:`x \geq 0.7v + 12`) 
 
    Rounding errors are estimated based on the largest terms in the sums, and 
    the result associated with the smallest error is returned. 
 
    References 
    ---------- 
    .. [1] NIST Digital Library of Mathematical Functions 
           https://dlmf.nist.gov/11 
 
    Examples 
    -------- 
    Calculate the modified Struve function of order 1 at 2. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.special import modstruve 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; modstruve(1, 2.) 
    1.102759787367716 
 
    Calculate the modified Struve function at 2 for orders 1, 2 and 3 by 
    providing a list for the order parameter `v`. 
 
    &gt;&gt;&gt; modstruve([1, 2, 3], 2.) 
    array([1.10275979, 0.41026079, 0.11247294]) 
 
    Calculate the modified Struve function of order 1 for several points 
    by providing an array for `x`. 
 
    &gt;&gt;&gt; points = np.array([2., 5., 8.]) 
    &gt;&gt;&gt; modstruve(1, points) 
    array([  1.10275979,  23.72821578, 399.24709139]) 
 
    Compute the modified Struve function for several orders at several 
    points by providing arrays for `v` and `z`. The arrays have to be 
    broadcastable to the correct shapes. 
 
    &gt;&gt;&gt; orders = np.array([[1], [2], [3]]) 
    &gt;&gt;&gt; points.shape, orders.shape 
    ((3,), (3, 1)) 
 
    &gt;&gt;&gt; modstruve(orders, points) 
    array([[1.10275979e+00, 2.37282158e+01, 3.99247091e+02], 
           [4.10260789e-01, 1.65535979e+01, 3.25973609e+02], 
           [1.12472937e-01, 9.42430454e+00, 2.33544042e+02]]) 
 
    Plot the modified Struve functions of order 0 to 3 from -5 to 5. 
 
    &gt;&gt;&gt; fig, ax = plt.subplots() 
    &gt;&gt;&gt; x = np.linspace(-5., 5., 1000) 
    &gt;&gt;&gt; for i in range(4): 
    ...     ax.plot(x, modstruve(i, x), label=f'$L_{i!r}$') 
    &gt;&gt;&gt; ax.legend(ncol=2) 
    &gt;&gt;&gt; ax.set_xlim(-5, 5) 
    &gt;&gt;&gt; ax.set_title(r&quot;Modified Struve functions $L_{\nu}$&quot;) 
    &gt;&gt;&gt; plt.show() 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;nbdtr&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    nbdtr(k, n, p, out=None) 
 
    Negative binomial cumulative distribution function. 
 
    Returns the sum of the terms 0 through `k` of the negative binomial 
    distribution probability mass function, 
 
    .. math:: 
 
        F = \sum_{j=0}^k {{n + j - 1}\choose{j}} p^n (1 - p)^j. 
 
    In a sequence of Bernoulli trials with individual success probabilities 
    `p`, this is the probability that `k` or fewer failures precede the nth 
    success. 
 
    Parameters 
    ---------- 
    k : array_like 
        The maximum number of allowed failures (nonnegative int). 
    n : array_like 
        The target number of successes (positive int). 
    p : array_like 
        Probability of success in a single event (float). 
    out : ndarray, optional 
        Optional output array for the function results 
 
    Returns 
    ------- 
    F : scalar or ndarray 
        The probability of `k` or fewer failures before `n` successes in a 
        sequence of events with individual success probability `p`. 
 
    See Also 
    -------- 
    nbdtrc : Negative binomial survival function 
    nbdtrik : Negative binomial quantile function 
    scipy.stats.nbinom : Negative binomial distribution 
 
    Notes 
    ----- 
    If floating point values are passed for `k` or `n`, they will be truncated 
    to integers. 
 
    The terms are not summed directly; instead the regularized incomplete beta 
    function is employed, according to the formula, 
 
    .. math:: 
        \mathrm{nbdtr}(k, n, p) = I_{p}(n, k + 1). 
 
    Wrapper for the Cephes [1]_ routine `nbdtr`. 
 
    The negative binomial distribution is also available as 
    `scipy.stats.nbinom`. Using `nbdtr` directly can improve performance 
    compared to the ``cdf`` method of `scipy.stats.nbinom` (see last example). 
 
    References 
    ---------- 
    .. [1] Cephes Mathematical Functions Library, 
           http://www.netlib.org/cephes/ 
 
    Examples 
    -------- 
    Compute the function for ``k=10`` and ``n=5`` at ``p=0.5``. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.special import nbdtr 
    &gt;&gt;&gt; nbdtr(10, 5, 0.5) 
    0.940765380859375 
 
    Compute the function for ``n=10`` and ``p=0.5`` at several points by 
    providing a NumPy array or list for `k`. 
 
    &gt;&gt;&gt; nbdtr([5, 10, 15], 10, 0.5) 
    array([0.15087891, 0.58809853, 0.88523853]) 
 
    Plot the function for four different parameter sets. 
 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; k = np.arange(130) 
    &gt;&gt;&gt; n_parameters = [20, 20, 20, 80] 
    &gt;&gt;&gt; p_parameters = [0.2, 0.5, 0.8, 0.5] 
    &gt;&gt;&gt; linestyles = ['solid', 'dashed', 'dotted', 'dashdot'] 
    &gt;&gt;&gt; parameters_list = list(zip(p_parameters, n_parameters, 
    ...                            linestyles)) 
    &gt;&gt;&gt; fig, ax = plt.subplots(figsize=(8, 8)) 
    &gt;&gt;&gt; for parameter_set in parameters_list: 
    ...     p, n, style = parameter_set 
    ...     nbdtr_vals = nbdtr(k, n, p) 
    ...     ax.plot(k, nbdtr_vals, label=rf&quot;$n={n},\, p={p}$&quot;, 
    ...             ls=style) 
    &gt;&gt;&gt; ax.legend() 
    &gt;&gt;&gt; ax.set_xlabel(&quot;$k$&quot;) 
    &gt;&gt;&gt; ax.set_title(&quot;Negative binomial cumulative distribution function&quot;) 
    &gt;&gt;&gt; plt.show() 
 
    The negative binomial distribution is also available as 
    `scipy.stats.nbinom`. Using `nbdtr` directly can be much faster than 
    calling the ``cdf`` method of `scipy.stats.nbinom`, especially for small 
    arrays or individual values. To get the same results one must use the 
    following parametrization: ``nbinom(n, p).cdf(k)=nbdtr(k, n, p)``. 
 
    &gt;&gt;&gt; from scipy.stats import nbinom 
    &gt;&gt;&gt; k, n, p = 5, 3, 0.5 
    &gt;&gt;&gt; nbdtr_res = nbdtr(k, n, p)  # this will often be faster than below 
    &gt;&gt;&gt; stats_res = nbinom(n, p).cdf(k) 
    &gt;&gt;&gt; stats_res, nbdtr_res  # test that results are equal 
    (0.85546875, 0.85546875) 
 
    `nbdtr` can evaluate different parameter sets by providing arrays with 
    shapes compatible for broadcasting for `k`, `n` and `p`. Here we compute 
    the function for three different `k` at four locations `p`, resulting in 
    a 3x4 array. 
 
    &gt;&gt;&gt; k = np.array([[5], [10], [15]]) 
    &gt;&gt;&gt; p = np.array([0.3, 0.5, 0.7, 0.9]) 
    &gt;&gt;&gt; k.shape, p.shape 
    ((3, 1), (4,)) 
 
    &gt;&gt;&gt; nbdtr(k, 5, p) 
    array([[0.15026833, 0.62304687, 0.95265101, 0.9998531 ], 
           [0.48450894, 0.94076538, 0.99932777, 0.99999999], 
           [0.76249222, 0.99409103, 0.99999445, 1.        ]]) 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;nbdtrc&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    nbdtrc(k, n, p, out=None) 
 
    Negative binomial survival function. 
 
    Returns the sum of the terms `k + 1` to infinity of the negative binomial 
    distribution probability mass function, 
 
    .. math:: 
 
        F = \sum_{j=k + 1}^\infty {{n + j - 1}\choose{j}} p^n (1 - p)^j. 
 
    In a sequence of Bernoulli trials with individual success probabilities 
    `p`, this is the probability that more than `k` failures precede the nth 
    success. 
 
    Parameters 
    ---------- 
    k : array_like 
        The maximum number of allowed failures (nonnegative int). 
    n : array_like 
        The target number of successes (positive int). 
    p : array_like 
        Probability of success in a single event (float). 
    out : ndarray, optional 
        Optional output array for the function results 
 
    Returns 
    ------- 
    F : scalar or ndarray 
        The probability of `k + 1` or more failures before `n` successes in a 
        sequence of events with individual success probability `p`. 
 
    See Also 
    -------- 
    nbdtr : Negative binomial cumulative distribution function 
    nbdtrik : Negative binomial percentile function 
    scipy.stats.nbinom : Negative binomial distribution 
 
    Notes 
    ----- 
    If floating point values are passed for `k` or `n`, they will be truncated 
    to integers. 
 
    The terms are not summed directly; instead the regularized incomplete beta 
    function is employed, according to the formula, 
 
    .. math:: 
        \mathrm{nbdtrc}(k, n, p) = I_{1 - p}(k + 1, n). 
 
    Wrapper for the Cephes [1]_ routine `nbdtrc`. 
 
    The negative binomial distribution is also available as 
    `scipy.stats.nbinom`. Using `nbdtrc` directly can improve performance 
    compared to the ``sf`` method of `scipy.stats.nbinom` (see last example). 
 
    References 
    ---------- 
    .. [1] Cephes Mathematical Functions Library, 
           http://www.netlib.org/cephes/ 
 
    Examples 
    -------- 
    Compute the function for ``k=10`` and ``n=5`` at ``p=0.5``. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.special import nbdtrc 
    &gt;&gt;&gt; nbdtrc(10, 5, 0.5) 
    0.059234619140624986 
 
    Compute the function for ``n=10`` and ``p=0.5`` at several points by 
    providing a NumPy array or list for `k`. 
 
    &gt;&gt;&gt; nbdtrc([5, 10, 15], 10, 0.5) 
    array([0.84912109, 0.41190147, 0.11476147]) 
 
    Plot the function for four different parameter sets. 
 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; k = np.arange(130) 
    &gt;&gt;&gt; n_parameters = [20, 20, 20, 80] 
    &gt;&gt;&gt; p_parameters = [0.2, 0.5, 0.8, 0.5] 
    &gt;&gt;&gt; linestyles = ['solid', 'dashed', 'dotted', 'dashdot'] 
    &gt;&gt;&gt; parameters_list = list(zip(p_parameters, n_parameters, 
    ...                            linestyles)) 
    &gt;&gt;&gt; fig, ax = plt.subplots(figsize=(8, 8)) 
    &gt;&gt;&gt; for parameter_set in parameters_list: 
    ...     p, n, style = parameter_set 
    ...     nbdtrc_vals = nbdtrc(k, n, p) 
    ...     ax.plot(k, nbdtrc_vals, label=rf&quot;$n={n},\, p={p}$&quot;, 
    ...             ls=style) 
    &gt;&gt;&gt; ax.legend() 
    &gt;&gt;&gt; ax.set_xlabel(&quot;$k$&quot;) 
    &gt;&gt;&gt; ax.set_title(&quot;Negative binomial distribution survival function&quot;) 
    &gt;&gt;&gt; plt.show() 
 
    The negative binomial distribution is also available as 
    `scipy.stats.nbinom`. Using `nbdtrc` directly can be much faster than 
    calling the ``sf`` method of `scipy.stats.nbinom`, especially for small 
    arrays or individual values. To get the same results one must use the 
    following parametrization: ``nbinom(n, p).sf(k)=nbdtrc(k, n, p)``. 
 
    &gt;&gt;&gt; from scipy.stats import nbinom 
    &gt;&gt;&gt; k, n, p = 3, 5, 0.5 
    &gt;&gt;&gt; nbdtr_res = nbdtrc(k, n, p)  # this will often be faster than below 
    &gt;&gt;&gt; stats_res = nbinom(n, p).sf(k) 
    &gt;&gt;&gt; stats_res, nbdtr_res  # test that results are equal 
    (0.6367187499999999, 0.6367187499999999) 
 
    `nbdtrc` can evaluate different parameter sets by providing arrays with 
    shapes compatible for broadcasting for `k`, `n` and `p`. Here we compute 
    the function for three different `k` at four locations `p`, resulting in 
    a 3x4 array. 
 
    &gt;&gt;&gt; k = np.array([[5], [10], [15]]) 
    &gt;&gt;&gt; p = np.array([0.3, 0.5, 0.7, 0.9]) 
    &gt;&gt;&gt; k.shape, p.shape 
    ((3, 1), (4,)) 
 
    &gt;&gt;&gt; nbdtrc(k, 5, p) 
    array([[8.49731667e-01, 3.76953125e-01, 4.73489874e-02, 1.46902600e-04], 
           [5.15491059e-01, 5.92346191e-02, 6.72234070e-04, 9.29610100e-09], 
           [2.37507779e-01, 5.90896606e-03, 5.55025308e-06, 3.26346760e-13]]) 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span>
    <span class="s4">&quot;nbdtri&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    nbdtri(k, n, y, out=None) 
 
    Returns the inverse with respect to the parameter `p` of 
    `y = nbdtr(k, n, p)`, the negative binomial cumulative distribution 
    function. 
 
    Parameters 
    ---------- 
    k : array_like 
        The maximum number of allowed failures (nonnegative int). 
    n : array_like 
        The target number of successes (positive int). 
    y : array_like 
        The probability of `k` or fewer failures before `n` successes (float). 
    out : ndarray, optional 
        Optional output array for the function results 
 
    Returns 
    ------- 
    p : scalar or ndarray 
        Probability of success in a single event (float) such that 
        `nbdtr(k, n, p) = y`. 
 
    See Also 
    -------- 
    nbdtr : Cumulative distribution function of the negative binomial. 
    nbdtrc : Negative binomial survival function. 
    scipy.stats.nbinom : negative binomial distribution. 
    nbdtrik : Inverse with respect to `k` of `nbdtr(k, n, p)`. 
    nbdtrin : Inverse with respect to `n` of `nbdtr(k, n, p)`. 
    scipy.stats.nbinom : Negative binomial distribution 
 
    Notes 
    ----- 
    Wrapper for the Cephes [1]_ routine `nbdtri`. 
 
    The negative binomial distribution is also available as 
    `scipy.stats.nbinom`. Using `nbdtri` directly can improve performance 
    compared to the ``ppf`` method of `scipy.stats.nbinom`. 
 
    References 
    ---------- 
    .. [1] Cephes Mathematical Functions Library, 
           http://www.netlib.org/cephes/ 
 
    Examples 
    -------- 
    `nbdtri` is the inverse of `nbdtr` with respect to `p`. 
    Up to floating point errors the following holds: 
    ``nbdtri(k, n, nbdtr(k, n, p))=p``. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.special import nbdtri, nbdtr 
    &gt;&gt;&gt; k, n, y = 5, 10, 0.2 
    &gt;&gt;&gt; cdf_val = nbdtr(k, n, y) 
    &gt;&gt;&gt; nbdtri(k, n, cdf_val) 
    0.20000000000000004 
 
    Compute the function for ``k=10`` and ``n=5`` at several points by 
    providing a NumPy array or list for `y`. 
 
    &gt;&gt;&gt; y = np.array([0.1, 0.4, 0.8]) 
    &gt;&gt;&gt; nbdtri(3, 5, y) 
    array([0.34462319, 0.51653095, 0.69677416]) 
 
    Plot the function for three different parameter sets. 
 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; n_parameters = [5, 20, 30, 30] 
    &gt;&gt;&gt; k_parameters = [20, 20, 60, 80] 
    &gt;&gt;&gt; linestyles = ['solid', 'dashed', 'dotted', 'dashdot'] 
    &gt;&gt;&gt; parameters_list = list(zip(n_parameters, k_parameters, linestyles)) 
    &gt;&gt;&gt; cdf_vals = np.linspace(0, 1, 1000) 
    &gt;&gt;&gt; fig, ax = plt.subplots(figsize=(8, 8)) 
    &gt;&gt;&gt; for parameter_set in parameters_list: 
    ...     n, k, style = parameter_set 
    ...     nbdtri_vals = nbdtri(k, n, cdf_vals) 
    ...     ax.plot(cdf_vals, nbdtri_vals, label=rf&quot;$k={k},\ n={n}$&quot;, 
    ...             ls=style) 
    &gt;&gt;&gt; ax.legend() 
    &gt;&gt;&gt; ax.set_ylabel(&quot;$p$&quot;) 
    &gt;&gt;&gt; ax.set_xlabel(&quot;$CDF$&quot;) 
    &gt;&gt;&gt; title = &quot;nbdtri: inverse of negative binomial CDF with respect to $p$&quot; 
    &gt;&gt;&gt; ax.set_title(title) 
    &gt;&gt;&gt; plt.show() 
 
    `nbdtri` can evaluate different parameter sets by providing arrays with 
    shapes compatible for broadcasting for `k`, `n` and `p`. Here we compute 
    the function for three different `k` at four locations `p`, resulting in 
    a 3x4 array. 
 
    &gt;&gt;&gt; k = np.array([[5], [10], [15]]) 
    &gt;&gt;&gt; y = np.array([0.3, 0.5, 0.7, 0.9]) 
    &gt;&gt;&gt; k.shape, y.shape 
    ((3, 1), (4,)) 
 
    &gt;&gt;&gt; nbdtri(k, 5, y) 
    array([[0.37258157, 0.45169416, 0.53249956, 0.64578407], 
           [0.24588501, 0.30451981, 0.36778453, 0.46397088], 
           [0.18362101, 0.22966758, 0.28054743, 0.36066188]]) 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;nbdtrik&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    nbdtrik(y, n, p, out=None) 
 
    Negative binomial percentile function. 
 
    Returns the inverse with respect to the parameter `k` of 
    `y = nbdtr(k, n, p)`, the negative binomial cumulative distribution 
    function. 
 
    Parameters 
    ---------- 
    y : array_like 
        The probability of `k` or fewer failures before `n` successes (float). 
    n : array_like 
        The target number of successes (positive int). 
    p : array_like 
        Probability of success in a single event (float). 
    out : ndarray, optional 
        Optional output array for the function results 
 
    Returns 
    ------- 
    k : scalar or ndarray 
        The maximum number of allowed failures such that `nbdtr(k, n, p) = y`. 
 
    See Also 
    -------- 
    nbdtr : Cumulative distribution function of the negative binomial. 
    nbdtrc : Survival function of the negative binomial. 
    nbdtri : Inverse with respect to `p` of `nbdtr(k, n, p)`. 
    nbdtrin : Inverse with respect to `n` of `nbdtr(k, n, p)`. 
    scipy.stats.nbinom : Negative binomial distribution 
 
    Notes 
    ----- 
    Wrapper for the CDFLIB [1]_ Fortran routine `cdfnbn`. 
 
    Formula 26.5.26 of [2]_, 
 
    .. math:: 
        \sum_{j=k + 1}^\infty {{n + j - 1} 
        \choose{j}} p^n (1 - p)^j = I_{1 - p}(k + 1, n), 
 
    is used to reduce calculation of the cumulative distribution function to 
    that of a regularized incomplete beta :math:`I`. 
 
    Computation of `k` involves a search for a value that produces the desired 
    value of `y`.  The search relies on the monotonicity of `y` with `k`. 
 
    References 
    ---------- 
    .. [1] Barry Brown, James Lovato, and Kathy Russell, 
           CDFLIB: Library of Fortran Routines for Cumulative Distribution 
           Functions, Inverses, and Other Parameters. 
    .. [2] Milton Abramowitz and Irene A. Stegun, eds. 
           Handbook of Mathematical Functions with Formulas, 
           Graphs, and Mathematical Tables. New York: Dover, 1972. 
 
    Examples 
    -------- 
    Compute the negative binomial cumulative distribution function for an 
    exemplary parameter set. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.special import nbdtr, nbdtrik 
    &gt;&gt;&gt; k, n, p = 5, 2, 0.5 
    &gt;&gt;&gt; cdf_value = nbdtr(k, n, p) 
    &gt;&gt;&gt; cdf_value 
    0.9375 
 
    Verify that `nbdtrik` recovers the original value for `k`. 
 
    &gt;&gt;&gt; nbdtrik(cdf_value, n, p) 
    5.0 
 
    Plot the function for different parameter sets. 
 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; p_parameters = [0.2, 0.5, 0.7, 0.5] 
    &gt;&gt;&gt; n_parameters = [30, 30, 30, 80] 
    &gt;&gt;&gt; linestyles = ['solid', 'dashed', 'dotted', 'dashdot'] 
    &gt;&gt;&gt; parameters_list = list(zip(p_parameters, n_parameters, linestyles)) 
    &gt;&gt;&gt; cdf_vals = np.linspace(0, 1, 1000) 
    &gt;&gt;&gt; fig, ax = plt.subplots(figsize=(8, 8)) 
    &gt;&gt;&gt; for parameter_set in parameters_list: 
    ...     p, n, style = parameter_set 
    ...     nbdtrik_vals = nbdtrik(cdf_vals, n, p) 
    ...     ax.plot(cdf_vals, nbdtrik_vals, label=rf&quot;$n={n},\ p={p}$&quot;, 
    ...             ls=style) 
    &gt;&gt;&gt; ax.legend() 
    &gt;&gt;&gt; ax.set_ylabel(&quot;$k$&quot;) 
    &gt;&gt;&gt; ax.set_xlabel(&quot;$CDF$&quot;) 
    &gt;&gt;&gt; ax.set_title(&quot;Negative binomial percentile function&quot;) 
    &gt;&gt;&gt; plt.show() 
 
    The negative binomial distribution is also available as 
    `scipy.stats.nbinom`. The percentile function  method ``ppf`` 
    returns the result of `nbdtrik` rounded up to integers: 
 
    &gt;&gt;&gt; from scipy.stats import nbinom 
    &gt;&gt;&gt; q, n, p = 0.6, 5, 0.5 
    &gt;&gt;&gt; nbinom.ppf(q, n, p), nbdtrik(q, n, p) 
    (5.0, 4.800428460273882) 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;nbdtrin&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    nbdtrin(k, y, p, out=None) 
 
    Inverse of `nbdtr` vs `n`. 
 
    Returns the inverse with respect to the parameter `n` of 
    `y = nbdtr(k, n, p)`, the negative binomial cumulative distribution 
    function. 
 
    Parameters 
    ---------- 
    k : array_like 
        The maximum number of allowed failures (nonnegative int). 
    y : array_like 
        The probability of `k` or fewer failures before `n` successes (float). 
    p : array_like 
        Probability of success in a single event (float). 
    out : ndarray, optional 
        Optional output array for the function results 
 
    Returns 
    ------- 
    n : scalar or ndarray 
        The number of successes `n` such that `nbdtr(k, n, p) = y`. 
 
    See Also 
    -------- 
    nbdtr : Cumulative distribution function of the negative binomial. 
    nbdtri : Inverse with respect to `p` of `nbdtr(k, n, p)`. 
    nbdtrik : Inverse with respect to `k` of `nbdtr(k, n, p)`. 
 
    Notes 
    ----- 
    Wrapper for the CDFLIB [1]_ Fortran routine `cdfnbn`. 
 
    Formula 26.5.26 of [2]_, 
 
    .. math:: 
        \sum_{j=k + 1}^\infty {{n + j - 1} 
        \choose{j}} p^n (1 - p)^j = I_{1 - p}(k + 1, n), 
 
    is used to reduce calculation of the cumulative distribution function to 
    that of a regularized incomplete beta :math:`I`. 
 
    Computation of `n` involves a search for a value that produces the desired 
    value of `y`.  The search relies on the monotonicity of `y` with `n`. 
 
    References 
    ---------- 
    .. [1] Barry Brown, James Lovato, and Kathy Russell, 
           CDFLIB: Library of Fortran Routines for Cumulative Distribution 
           Functions, Inverses, and Other Parameters. 
    .. [2] Milton Abramowitz and Irene A. Stegun, eds. 
           Handbook of Mathematical Functions with Formulas, 
           Graphs, and Mathematical Tables. New York: Dover, 1972. 
 
    Examples 
    -------- 
    Compute the negative binomial cumulative distribution function for an 
    exemplary parameter set. 
 
    &gt;&gt;&gt; from scipy.special import nbdtr, nbdtrin 
    &gt;&gt;&gt; k, n, p = 5, 2, 0.5 
    &gt;&gt;&gt; cdf_value = nbdtr(k, n, p) 
    &gt;&gt;&gt; cdf_value 
    0.9375 
 
    Verify that `nbdtrin` recovers the original value for `n` up to floating 
    point accuracy. 
 
    &gt;&gt;&gt; nbdtrin(k, cdf_value, p) 
    1.999999999998137 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;ncfdtr&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    ncfdtr(dfn, dfd, nc, f, out=None) 
 
    Cumulative distribution function of the non-central F distribution. 
 
    The non-central F describes the distribution of, 
 
    .. math:: 
        Z = \frac{X/d_n}{Y/d_d} 
 
    where :math:`X` and :math:`Y` are independently distributed, with 
    :math:`X` distributed non-central :math:`\chi^2` with noncentrality 
    parameter `nc` and :math:`d_n` degrees of freedom, and :math:`Y` 
    distributed :math:`\chi^2` with :math:`d_d` degrees of freedom. 
 
    Parameters 
    ---------- 
    dfn : array_like 
        Degrees of freedom of the numerator sum of squares.  Range (0, inf). 
    dfd : array_like 
        Degrees of freedom of the denominator sum of squares.  Range (0, inf). 
    nc : array_like 
        Noncentrality parameter.  Should be in range (0, 1e4). 
    f : array_like 
        Quantiles, i.e. the upper limit of integration. 
    out : ndarray, optional 
        Optional output array for the function results 
 
    Returns 
    ------- 
    cdf : scalar or ndarray 
        The calculated CDF.  If all inputs are scalar, the return will be a 
        float.  Otherwise it will be an array. 
 
    See Also 
    -------- 
    ncfdtri : Quantile function; inverse of `ncfdtr` with respect to `f`. 
    ncfdtridfd : Inverse of `ncfdtr` with respect to `dfd`. 
    ncfdtridfn : Inverse of `ncfdtr` with respect to `dfn`. 
    ncfdtrinc : Inverse of `ncfdtr` with respect to `nc`. 
 
    Notes 
    ----- 
    Wrapper for the CDFLIB [1]_ Fortran routine `cdffnc`. 
 
    The cumulative distribution function is computed using Formula 26.6.20 of 
    [2]_: 
 
    .. math:: 
        F(d_n, d_d, n_c, f) = \sum_{j=0}^\infty e^{-n_c/2} 
        \frac{(n_c/2)^j}{j!} I_{x}(\frac{d_n}{2} + j, \frac{d_d}{2}), 
 
    where :math:`I` is the regularized incomplete beta function, and 
    :math:`x = f d_n/(f d_n + d_d)`. 
 
    The computation time required for this routine is proportional to the 
    noncentrality parameter `nc`.  Very large values of this parameter can 
    consume immense computer resources.  This is why the search range is 
    bounded by 10,000. 
 
    References 
    ---------- 
    .. [1] Barry Brown, James Lovato, and Kathy Russell, 
           CDFLIB: Library of Fortran Routines for Cumulative Distribution 
           Functions, Inverses, and Other Parameters. 
    .. [2] Milton Abramowitz and Irene A. Stegun, eds. 
           Handbook of Mathematical Functions with Formulas, 
           Graphs, and Mathematical Tables. New York: Dover, 1972. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import special 
    &gt;&gt;&gt; from scipy import stats 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
 
    Plot the CDF of the non-central F distribution, for nc=0.  Compare with the 
    F-distribution from scipy.stats: 
 
    &gt;&gt;&gt; x = np.linspace(-1, 8, num=500) 
    &gt;&gt;&gt; dfn = 3 
    &gt;&gt;&gt; dfd = 2 
    &gt;&gt;&gt; ncf_stats = stats.f.cdf(x, dfn, dfd) 
    &gt;&gt;&gt; ncf_special = special.ncfdtr(dfn, dfd, 0, x) 
 
    &gt;&gt;&gt; fig = plt.figure() 
    &gt;&gt;&gt; ax = fig.add_subplot(111) 
    &gt;&gt;&gt; ax.plot(x, ncf_stats, 'b-', lw=3) 
    &gt;&gt;&gt; ax.plot(x, ncf_special, 'r-') 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;ncfdtri&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    ncfdtri(dfn, dfd, nc, p, out=None) 
 
    Inverse with respect to `f` of the CDF of the non-central F distribution. 
 
    See `ncfdtr` for more details. 
 
    Parameters 
    ---------- 
    dfn : array_like 
        Degrees of freedom of the numerator sum of squares.  Range (0, inf). 
    dfd : array_like 
        Degrees of freedom of the denominator sum of squares.  Range (0, inf). 
    nc : array_like 
        Noncentrality parameter.  Should be in range (0, 1e4). 
    p : array_like 
        Value of the cumulative distribution function.  Must be in the 
        range [0, 1]. 
    out : ndarray, optional 
        Optional output array for the function results 
 
    Returns 
    ------- 
    f : scalar or ndarray 
        Quantiles, i.e., the upper limit of integration. 
 
    See Also 
    -------- 
    ncfdtr : CDF of the non-central F distribution. 
    ncfdtridfd : Inverse of `ncfdtr` with respect to `dfd`. 
    ncfdtridfn : Inverse of `ncfdtr` with respect to `dfn`. 
    ncfdtrinc : Inverse of `ncfdtr` with respect to `nc`. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.special import ncfdtr, ncfdtri 
 
    Compute the CDF for several values of `f`: 
 
    &gt;&gt;&gt; f = [0.5, 1, 1.5] 
    &gt;&gt;&gt; p = ncfdtr(2, 3, 1.5, f) 
    &gt;&gt;&gt; p 
    array([ 0.20782291,  0.36107392,  0.47345752]) 
 
    Compute the inverse.  We recover the values of `f`, as expected: 
 
    &gt;&gt;&gt; ncfdtri(2, 3, 1.5, p) 
    array([ 0.5,  1. ,  1.5]) 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;ncfdtridfd&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    ncfdtridfd(dfn, p, nc, f, out=None) 
 
    Calculate degrees of freedom (denominator) for the noncentral F-distribution. 
 
    This is the inverse with respect to `dfd` of `ncfdtr`. 
    See `ncfdtr` for more details. 
 
    Parameters 
    ---------- 
    dfn : array_like 
        Degrees of freedom of the numerator sum of squares.  Range (0, inf). 
    p : array_like 
        Value of the cumulative distribution function.  Must be in the 
        range [0, 1]. 
    nc : array_like 
        Noncentrality parameter.  Should be in range (0, 1e4). 
    f : array_like 
        Quantiles, i.e., the upper limit of integration. 
    out : ndarray, optional 
        Optional output array for the function results 
 
    Returns 
    ------- 
    dfd : scalar or ndarray 
        Degrees of freedom of the denominator sum of squares. 
 
    See Also 
    -------- 
    ncfdtr : CDF of the non-central F distribution. 
    ncfdtri : Quantile function; inverse of `ncfdtr` with respect to `f`. 
    ncfdtridfn : Inverse of `ncfdtr` with respect to `dfn`. 
    ncfdtrinc : Inverse of `ncfdtr` with respect to `nc`. 
 
    Notes 
    ----- 
    The value of the cumulative noncentral F distribution is not necessarily 
    monotone in either degrees of freedom. There thus may be two values that 
    provide a given CDF value. This routine assumes monotonicity and will 
    find an arbitrary one of the two values. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.special import ncfdtr, ncfdtridfd 
 
    Compute the CDF for several values of `dfd`: 
 
    &gt;&gt;&gt; dfd = [1, 2, 3] 
    &gt;&gt;&gt; p = ncfdtr(2, dfd, 0.25, 15) 
    &gt;&gt;&gt; p 
    array([ 0.8097138 ,  0.93020416,  0.96787852]) 
 
    Compute the inverse.  We recover the values of `dfd`, as expected: 
 
    &gt;&gt;&gt; ncfdtridfd(2, p, 0.25, 15) 
    array([ 1.,  2.,  3.]) 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;ncfdtridfn&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    ncfdtridfn(p, dfd, nc, f, out=None) 
 
    Calculate degrees of freedom (numerator) for the noncentral F-distribution. 
 
    This is the inverse with respect to `dfn` of `ncfdtr`. 
    See `ncfdtr` for more details. 
 
    Parameters 
    ---------- 
    p : array_like 
        Value of the cumulative distribution function. Must be in the 
        range [0, 1]. 
    dfd : array_like 
        Degrees of freedom of the denominator sum of squares. Range (0, inf). 
    nc : array_like 
        Noncentrality parameter.  Should be in range (0, 1e4). 
    f : float 
        Quantiles, i.e., the upper limit of integration. 
    out : ndarray, optional 
        Optional output array for the function results 
 
    Returns 
    ------- 
    dfn : scalar or ndarray 
        Degrees of freedom of the numerator sum of squares. 
 
    See Also 
    -------- 
    ncfdtr : CDF of the non-central F distribution. 
    ncfdtri : Quantile function; inverse of `ncfdtr` with respect to `f`. 
    ncfdtridfd : Inverse of `ncfdtr` with respect to `dfd`. 
    ncfdtrinc : Inverse of `ncfdtr` with respect to `nc`. 
 
    Notes 
    ----- 
    The value of the cumulative noncentral F distribution is not necessarily 
    monotone in either degrees of freedom. There thus may be two values that 
    provide a given CDF value. This routine assumes monotonicity and will 
    find an arbitrary one of the two values. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.special import ncfdtr, ncfdtridfn 
 
    Compute the CDF for several values of `dfn`: 
 
    &gt;&gt;&gt; dfn = [1, 2, 3] 
    &gt;&gt;&gt; p = ncfdtr(dfn, 2, 0.25, 15) 
    &gt;&gt;&gt; p 
    array([ 0.92562363,  0.93020416,  0.93188394]) 
 
    Compute the inverse. We recover the values of `dfn`, as expected: 
 
    &gt;&gt;&gt; ncfdtridfn(p, 2, 0.25, 15) 
    array([ 1.,  2.,  3.]) 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;ncfdtrinc&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    ncfdtrinc(dfn, dfd, p, f, out=None) 
 
    Calculate non-centrality parameter for non-central F distribution. 
 
    This is the inverse with respect to `nc` of `ncfdtr`. 
    See `ncfdtr` for more details. 
 
    Parameters 
    ---------- 
    dfn : array_like 
        Degrees of freedom of the numerator sum of squares. Range (0, inf). 
    dfd : array_like 
        Degrees of freedom of the denominator sum of squares. Range (0, inf). 
    p : array_like 
        Value of the cumulative distribution function. Must be in the 
        range [0, 1]. 
    f : array_like 
        Quantiles, i.e., the upper limit of integration. 
    out : ndarray, optional 
        Optional output array for the function results 
 
    Returns 
    ------- 
    nc : scalar or ndarray 
        Noncentrality parameter. 
 
    See Also 
    -------- 
    ncfdtr : CDF of the non-central F distribution. 
    ncfdtri : Quantile function; inverse of `ncfdtr` with respect to `f`. 
    ncfdtridfd : Inverse of `ncfdtr` with respect to `dfd`. 
    ncfdtridfn : Inverse of `ncfdtr` with respect to `dfn`. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.special import ncfdtr, ncfdtrinc 
 
    Compute the CDF for several values of `nc`: 
 
    &gt;&gt;&gt; nc = [0.5, 1.5, 2.0] 
    &gt;&gt;&gt; p = ncfdtr(2, 3, nc, 15) 
    &gt;&gt;&gt; p 
    array([ 0.96309246,  0.94327955,  0.93304098]) 
 
    Compute the inverse. We recover the values of `nc`, as expected: 
 
    &gt;&gt;&gt; ncfdtrinc(2, 3, p, 15) 
    array([ 0.5,  1.5,  2. ]) 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;nctdtr&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    nctdtr(df, nc, t, out=None) 
 
    Cumulative distribution function of the non-central `t` distribution. 
 
    Parameters 
    ---------- 
    df : array_like 
        Degrees of freedom of the distribution. Should be in range (0, inf). 
    nc : array_like 
        Noncentrality parameter. Should be in range (-1e6, 1e6). 
    t : array_like 
        Quantiles, i.e., the upper limit of integration. 
    out : ndarray, optional 
        Optional output array for the function results 
 
    Returns 
    ------- 
    cdf : scalar or ndarray 
        The calculated CDF. If all inputs are scalar, the return will be a 
        float. Otherwise, it will be an array. 
 
    See Also 
    -------- 
    nctdtrit : Inverse CDF (iCDF) of the non-central t distribution. 
    nctdtridf : Calculate degrees of freedom, given CDF and iCDF values. 
    nctdtrinc : Calculate non-centrality parameter, given CDF iCDF values. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import special 
    &gt;&gt;&gt; from scipy import stats 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
 
    Plot the CDF of the non-central t distribution, for nc=0. Compare with the 
    t-distribution from scipy.stats: 
 
    &gt;&gt;&gt; x = np.linspace(-5, 5, num=500) 
    &gt;&gt;&gt; df = 3 
    &gt;&gt;&gt; nct_stats = stats.t.cdf(x, df) 
    &gt;&gt;&gt; nct_special = special.nctdtr(df, 0, x) 
 
    &gt;&gt;&gt; fig = plt.figure() 
    &gt;&gt;&gt; ax = fig.add_subplot(111) 
    &gt;&gt;&gt; ax.plot(x, nct_stats, 'b-', lw=3) 
    &gt;&gt;&gt; ax.plot(x, nct_special, 'r-') 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;nctdtridf&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    nctdtridf(p, nc, t, out=None) 
 
    Calculate degrees of freedom for non-central t distribution. 
 
    See `nctdtr` for more details. 
 
    Parameters 
    ---------- 
    p : array_like 
        CDF values, in range (0, 1]. 
    nc : array_like 
        Noncentrality parameter. Should be in range (-1e6, 1e6). 
    t : array_like 
        Quantiles, i.e., the upper limit of integration. 
    out : ndarray, optional 
        Optional output array for the function results 
 
    Returns 
    ------- 
    df : scalar or ndarray 
        The degrees of freedom. If all inputs are scalar, the return will be a 
        float. Otherwise, it will be an array. 
 
    See Also 
    -------- 
    nctdtr :  CDF of the non-central `t` distribution. 
    nctdtrit : Inverse CDF (iCDF) of the non-central t distribution. 
    nctdtrinc : Calculate non-centrality parameter, given CDF iCDF values. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.special import nctdtr, nctdtridf 
 
    Compute the CDF for several values of `df`: 
 
    &gt;&gt;&gt; df = [1, 2, 3] 
    &gt;&gt;&gt; p = nctdtr(df, 0.25, 1) 
    &gt;&gt;&gt; p 
    array([0.67491974, 0.716464  , 0.73349456]) 
 
    Compute the inverse. We recover the values of `df`, as expected: 
 
    &gt;&gt;&gt; nctdtridf(p, 0.25, 1) 
    array([1., 2., 3.]) 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;nctdtrinc&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    nctdtrinc(df, p, t, out=None) 
 
    Calculate non-centrality parameter for non-central t distribution. 
 
    See `nctdtr` for more details. 
 
    Parameters 
    ---------- 
    df : array_like 
        Degrees of freedom of the distribution. Should be in range (0, inf). 
    p : array_like 
        CDF values, in range (0, 1]. 
    t : array_like 
        Quantiles, i.e., the upper limit of integration. 
    out : ndarray, optional 
        Optional output array for the function results 
 
    Returns 
    ------- 
    nc : scalar or ndarray 
        Noncentrality parameter 
 
    See Also 
    -------- 
    nctdtr :  CDF of the non-central `t` distribution. 
    nctdtrit : Inverse CDF (iCDF) of the non-central t distribution. 
    nctdtridf : Calculate degrees of freedom, given CDF and iCDF values. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.special import nctdtr, nctdtrinc 
 
    Compute the CDF for several values of `nc`: 
 
    &gt;&gt;&gt; nc = [0.5, 1.5, 2.5] 
    &gt;&gt;&gt; p = nctdtr(3, nc, 1.5) 
    &gt;&gt;&gt; p 
    array([0.77569497, 0.45524533, 0.1668691 ]) 
 
    Compute the inverse. We recover the values of `nc`, as expected: 
 
    &gt;&gt;&gt; nctdtrinc(3, p, 1.5) 
    array([0.5, 1.5, 2.5]) 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;nctdtrit&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    nctdtrit(df, nc, p, out=None) 
 
    Inverse cumulative distribution function of the non-central t distribution. 
 
    See `nctdtr` for more details. 
 
    Parameters 
    ---------- 
    df : array_like 
        Degrees of freedom of the distribution. Should be in range (0, inf). 
    nc : array_like 
        Noncentrality parameter. Should be in range (-1e6, 1e6). 
    p : array_like 
        CDF values, in range (0, 1]. 
    out : ndarray, optional 
        Optional output array for the function results 
 
    Returns 
    ------- 
    t : scalar or ndarray 
        Quantiles 
 
    See Also 
    -------- 
    nctdtr :  CDF of the non-central `t` distribution. 
    nctdtridf : Calculate degrees of freedom, given CDF and iCDF values. 
    nctdtrinc : Calculate non-centrality parameter, given CDF iCDF values. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.special import nctdtr, nctdtrit 
 
    Compute the CDF for several values of `t`: 
 
    &gt;&gt;&gt; t = [0.5, 1, 1.5] 
    &gt;&gt;&gt; p = nctdtr(3, 1, t) 
    &gt;&gt;&gt; p 
    array([0.29811049, 0.46922687, 0.6257559 ]) 
 
    Compute the inverse. We recover the values of `t`, as expected: 
 
    &gt;&gt;&gt; nctdtrit(3, 1, p) 
    array([0.5, 1. , 1.5]) 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;ndtr&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    ndtr(x, out=None) 
 
    Cumulative distribution of the standard normal distribution. 
 
    Returns the area under the standard Gaussian probability 
    density function, integrated from minus infinity to `x` 
 
    .. math:: 
 
       \frac{1}{\sqrt{2\pi}} \int_{-\infty}^x \exp(-t^2/2) dt 
 
    Parameters 
    ---------- 
    x : array_like, real or complex 
        Argument 
    out : ndarray, optional 
        Optional output array for the function results 
 
    Returns 
    ------- 
    scalar or ndarray 
        The value of the normal CDF evaluated at `x` 
 
    See Also 
    -------- 
    log_ndtr : Logarithm of ndtr 
    ndtri : Inverse of ndtr, standard normal percentile function 
    erf : Error function 
    erfc : 1 - erf 
    scipy.stats.norm : Normal distribution 
 
    Examples 
    -------- 
    Evaluate `ndtr` at one point. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.special import ndtr 
    &gt;&gt;&gt; ndtr(0.5) 
    0.6914624612740131 
 
    Evaluate the function at several points by providing a NumPy array 
    or list for `x`. 
 
    &gt;&gt;&gt; ndtr([0, 0.5, 2]) 
    array([0.5       , 0.69146246, 0.97724987]) 
 
    Plot the function. 
 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; x = np.linspace(-5, 5, 100) 
    &gt;&gt;&gt; fig, ax = plt.subplots() 
    &gt;&gt;&gt; ax.plot(x, ndtr(x)) 
    &gt;&gt;&gt; ax.set_title(r&quot;Standard normal cumulative distribution function $\Phi$&quot;) 
    &gt;&gt;&gt; plt.show() 
    &quot;&quot;&quot;</span><span class="s2">)</span>


<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;nrdtrimn&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    nrdtrimn(p, std, x, out=None) 
 
    Calculate mean of normal distribution given other params. 
 
    Parameters 
    ---------- 
    p : array_like 
        CDF values, in range (0, 1]. 
    std : array_like 
        Standard deviation. 
    x : array_like 
        Quantiles, i.e. the upper limit of integration. 
    out : ndarray, optional 
        Optional output array for the function results 
 
    Returns 
    ------- 
    mn : scalar or ndarray 
        The mean of the normal distribution. 
 
    See Also 
    -------- 
    scipy.stats.norm : Normal distribution 
    ndtr : Standard normal cumulative probability distribution 
    ndtri : Inverse of standard normal CDF with respect to quantile 
    nrdtrisd : Inverse of normal distribution CDF with respect to 
               standard deviation 
 
    Examples 
    -------- 
    `nrdtrimn` can be used to recover the mean of a normal distribution 
    if we know the CDF value `p` for a given quantile `x` and the 
    standard deviation `std`. First, we calculate 
    the normal distribution CDF for an exemplary parameter set. 
 
    &gt;&gt;&gt; from scipy.stats import norm 
    &gt;&gt;&gt; mean = 3. 
    &gt;&gt;&gt; std = 2. 
    &gt;&gt;&gt; x = 6. 
    &gt;&gt;&gt; p = norm.cdf(x, loc=mean, scale=std) 
    &gt;&gt;&gt; p 
    0.9331927987311419 
 
    Verify that `nrdtrimn` returns the original value for `mean`. 
 
    &gt;&gt;&gt; from scipy.special import nrdtrimn 
    &gt;&gt;&gt; nrdtrimn(p, std, x) 
    3.0000000000000004 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;nrdtrisd&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    nrdtrisd(mn, p, x, out=None) 
 
    Calculate standard deviation of normal distribution given other params. 
 
    Parameters 
    ---------- 
    mn : scalar or ndarray 
        The mean of the normal distribution. 
    p : array_like 
        CDF values, in range (0, 1]. 
    x : array_like 
        Quantiles, i.e. the upper limit of integration. 
 
    out : ndarray, optional 
        Optional output array for the function results 
 
    Returns 
    ------- 
    std : scalar or ndarray 
        Standard deviation. 
 
    See Also 
    -------- 
    scipy.stats.norm : Normal distribution 
    ndtr : Standard normal cumulative probability distribution 
    ndtri : Inverse of standard normal CDF with respect to quantile 
    nrdtrimn : Inverse of normal distribution CDF with respect to 
               mean 
 
    Examples 
    -------- 
    `nrdtrisd` can be used to recover the standard deviation of a normal 
    distribution if we know the CDF value `p` for a given quantile `x` and 
    the mean `mn`. First, we calculate the normal distribution CDF for an 
    exemplary parameter set. 
 
    &gt;&gt;&gt; from scipy.stats import norm 
    &gt;&gt;&gt; mean = 3. 
    &gt;&gt;&gt; std = 2. 
    &gt;&gt;&gt; x = 6. 
    &gt;&gt;&gt; p = norm.cdf(x, loc=mean, scale=std) 
    &gt;&gt;&gt; p 
    0.9331927987311419 
 
    Verify that `nrdtrisd` returns the original value for `std`. 
 
    &gt;&gt;&gt; from scipy.special import nrdtrisd 
    &gt;&gt;&gt; nrdtrisd(mean, p, x) 
    2.0000000000000004 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;log_ndtr&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    log_ndtr(x, out=None) 
 
    Logarithm of Gaussian cumulative distribution function. 
 
    Returns the log of the area under the standard Gaussian probability 
    density function, integrated from minus infinity to `x`:: 
 
        log(1/sqrt(2*pi) * integral(exp(-t**2 / 2), t=-inf..x)) 
 
    Parameters 
    ---------- 
    x : array_like, real or complex 
        Argument 
    out : ndarray, optional 
        Optional output array for the function results 
 
    Returns 
    ------- 
    scalar or ndarray 
        The value of the log of the normal CDF evaluated at `x` 
 
    See Also 
    -------- 
    erf 
    erfc 
    scipy.stats.norm 
    ndtr 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.special import log_ndtr, ndtr 
 
    The benefit of ``log_ndtr(x)`` over the naive implementation 
    ``np.log(ndtr(x))`` is most evident with moderate to large positive 
    values of ``x``: 
 
    &gt;&gt;&gt; x = np.array([6, 7, 9, 12, 15, 25]) 
    &gt;&gt;&gt; log_ndtr(x) 
    array([-9.86587646e-010, -1.27981254e-012, -1.12858841e-019, 
           -1.77648211e-033, -3.67096620e-051, -3.05669671e-138]) 
 
    The results of the naive calculation for the moderate ``x`` values 
    have only 5 or 6 correct significant digits. For values of ``x`` 
    greater than approximately 8.3, the naive expression returns 0: 
 
    &gt;&gt;&gt; np.log(ndtr(x)) 
    array([-9.86587701e-10, -1.27986510e-12,  0.00000000e+00, 
            0.00000000e+00,  0.00000000e+00,  0.00000000e+00]) 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;ndtri&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    ndtri(y, out=None) 
 
    Inverse of `ndtr` vs x 
 
    Returns the argument x for which the area under the standard normal 
    probability density function (integrated from minus infinity to `x`) 
    is equal to y. 
 
    Parameters 
    ---------- 
    p : array_like 
        Probability 
    out : ndarray, optional 
        Optional output array for the function results 
 
    Returns 
    ------- 
    x : scalar or ndarray 
        Value of x such that ``ndtr(x) == p``. 
 
    See Also 
    -------- 
    ndtr : Standard normal cumulative probability distribution 
    ndtri_exp : Inverse of log_ndtr 
 
    Examples 
    -------- 
    `ndtri` is the percentile function of the standard normal distribution. 
    This means it returns the inverse of the cumulative density `ndtr`. First, 
    let us compute a cumulative density value. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.special import ndtri, ndtr 
    &gt;&gt;&gt; cdf_val = ndtr(2) 
    &gt;&gt;&gt; cdf_val 
    0.9772498680518208 
 
    Verify that `ndtri` yields the original value for `x` up to floating point 
    errors. 
 
    &gt;&gt;&gt; ndtri(cdf_val) 
    2.0000000000000004 
 
    Plot the function. For that purpose, we provide a NumPy array as argument. 
 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; x = np.linspace(0.01, 1, 200) 
    &gt;&gt;&gt; fig, ax = plt.subplots() 
    &gt;&gt;&gt; ax.plot(x, ndtri(x)) 
    &gt;&gt;&gt; ax.set_title(&quot;Standard normal percentile function&quot;) 
    &gt;&gt;&gt; plt.show() 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;pdtr&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    pdtr(k, m, out=None) 
 
    Poisson cumulative distribution function. 
 
    Defined as the probability that a Poisson-distributed random 
    variable with event rate :math:`m` is less than or equal to 
    :math:`k`. More concretely, this works out to be [1]_ 
 
    .. math:: 
 
       \exp(-m) \sum_{j = 0}^{\lfloor{k}\rfloor} \frac{m^j}{j!}. 
 
    Parameters 
    ---------- 
    k : array_like 
        Number of occurrences (nonnegative, real) 
    m : array_like 
        Shape parameter (nonnegative, real) 
    out : ndarray, optional 
        Optional output array for the function results 
 
    Returns 
    ------- 
    scalar or ndarray 
        Values of the Poisson cumulative distribution function 
 
    See Also 
    -------- 
    pdtrc : Poisson survival function 
    pdtrik : inverse of `pdtr` with respect to `k` 
    pdtri : inverse of `pdtr` with respect to `m` 
 
    References 
    ---------- 
    .. [1] https://en.wikipedia.org/wiki/Poisson_distribution 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; import scipy.special as sc 
 
    It is a cumulative distribution function, so it converges to 1 
    monotonically as `k` goes to infinity. 
 
    &gt;&gt;&gt; sc.pdtr([1, 10, 100, np.inf], 1) 
    array([0.73575888, 0.99999999, 1.        , 1.        ]) 
 
    It is discontinuous at integers and constant between integers. 
 
    &gt;&gt;&gt; sc.pdtr([1, 1.5, 1.9, 2], 1) 
    array([0.73575888, 0.73575888, 0.73575888, 0.9196986 ]) 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;pdtrc&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    pdtrc(k, m, out=None) 
 
    Poisson survival function 
 
    Returns the sum of the terms from k+1 to infinity of the Poisson 
    distribution: sum(exp(-m) * m**j / j!, j=k+1..inf) = gammainc( 
    k+1, m). Arguments must both be non-negative doubles. 
 
    Parameters 
    ---------- 
    k : array_like 
        Number of occurrences (nonnegative, real) 
    m : array_like 
        Shape parameter (nonnegative, real) 
    out : ndarray, optional 
        Optional output array for the function results 
 
    Returns 
    ------- 
    scalar or ndarray 
        Values of the Poisson survival function 
 
    See Also 
    -------- 
    pdtr : Poisson cumulative distribution function 
    pdtrik : inverse of `pdtr` with respect to `k` 
    pdtri : inverse of `pdtr` with respect to `m` 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; import scipy.special as sc 
 
    It is a survival function, so it decreases to 0 
    monotonically as `k` goes to infinity. 
 
    &gt;&gt;&gt; k = np.array([1, 10, 100, np.inf]) 
    &gt;&gt;&gt; sc.pdtrc(k, 1) 
    array([2.64241118e-001, 1.00477664e-008, 3.94147589e-161, 0.00000000e+000]) 
 
    It can be expressed in terms of the lower incomplete gamma 
    function `gammainc`. 
 
    &gt;&gt;&gt; sc.gammainc(k + 1, 1) 
    array([2.64241118e-001, 1.00477664e-008, 3.94147589e-161, 0.00000000e+000]) 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;pdtri&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    pdtri(k, y, out=None) 
 
    Inverse to `pdtr` vs m 
 
    Returns the Poisson variable `m` such that the sum from 0 to `k` of 
    the Poisson density is equal to the given probability `y`: 
    calculated by ``gammaincinv(k + 1, y)``. `k` must be a nonnegative 
    integer and `y` between 0 and 1. 
 
    Parameters 
    ---------- 
    k : array_like 
        Number of occurrences (nonnegative, real) 
    y : array_like 
        Probability 
    out : ndarray, optional 
        Optional output array for the function results 
 
    Returns 
    ------- 
    scalar or ndarray 
        Values of the shape parameter `m` such that ``pdtr(k, m) = p`` 
 
    See Also 
    -------- 
    pdtr : Poisson cumulative distribution function 
    pdtrc : Poisson survival function 
    pdtrik : inverse of `pdtr` with respect to `k` 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import scipy.special as sc 
 
    Compute the CDF for several values of `m`: 
 
    &gt;&gt;&gt; m = [0.5, 1, 1.5] 
    &gt;&gt;&gt; p = sc.pdtr(1, m) 
    &gt;&gt;&gt; p 
    array([0.90979599, 0.73575888, 0.5578254 ]) 
 
    Compute the inverse. We recover the values of `m`, as expected: 
 
    &gt;&gt;&gt; sc.pdtri(1, p) 
    array([0.5, 1. , 1.5]) 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;pdtrik&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    pdtrik(p, m, out=None) 
 
    Inverse to `pdtr` vs `k`. 
 
    Parameters 
    ---------- 
    p : array_like 
        Probability 
    m : array_like 
        Shape parameter (nonnegative, real) 
    out : ndarray, optional 
        Optional output array for the function results 
 
    Returns 
    ------- 
    scalar or ndarray 
        The number of occurrences `k` such that ``pdtr(k, m) = p`` 
 
    See Also 
    -------- 
    pdtr : Poisson cumulative distribution function 
    pdtrc : Poisson survival function 
    pdtri : inverse of `pdtr` with respect to `m` 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import scipy.special as sc 
 
    Compute the CDF for several values of `k`: 
 
    &gt;&gt;&gt; k = [1, 2, 3] 
    &gt;&gt;&gt; p = sc.pdtr(k, 2) 
    &gt;&gt;&gt; p 
    array([0.40600585, 0.67667642, 0.85712346]) 
 
    Compute the inverse. We recover the values of `k`, as expected: 
 
    &gt;&gt;&gt; sc.pdtrik(p, 2) 
    array([1., 2., 3.]) 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;poch&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    poch(z, m, out=None) 
 
    Pochhammer symbol. 
 
    The Pochhammer symbol (rising factorial) is defined as 
 
    .. math:: 
 
        (z)_m = \frac{\Gamma(z + m)}{\Gamma(z)} 
 
    For positive integer `m` it reads 
 
    .. math:: 
 
        (z)_m = z (z + 1) ... (z + m - 1) 
 
    See [dlmf]_ for more details. 
 
    Parameters 
    ---------- 
    z, m : array_like 
        Real-valued arguments. 
    out : ndarray, optional 
        Optional output array for the function results 
 
    Returns 
    ------- 
    scalar or ndarray 
        The value of the function. 
 
    References 
    ---------- 
    .. [dlmf] Nist, Digital Library of Mathematical Functions 
        https://dlmf.nist.gov/5.2#iii 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import scipy.special as sc 
 
    It is 1 when m is 0. 
 
    &gt;&gt;&gt; sc.poch([1, 2, 3, 4], 0) 
    array([1., 1., 1., 1.]) 
 
    For z equal to 1 it reduces to the factorial function. 
 
    &gt;&gt;&gt; sc.poch(1, 5) 
    120.0 
    &gt;&gt;&gt; 1 * 2 * 3 * 4 * 5 
    120 
 
    It can be expressed in terms of the gamma function. 
 
    &gt;&gt;&gt; z, m = 3.7, 2.1 
    &gt;&gt;&gt; sc.poch(z, m) 
    20.529581933776953 
    &gt;&gt;&gt; sc.gamma(z + m) / sc.gamma(z) 
    20.52958193377696 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;powm1&quot;</span><span class="s2">, </span><span class="s4">&quot;&quot;&quot; 
    powm1(x, y, out=None) 
 
    Computes ``x**y - 1``. 
 
    This function is useful when `y` is near 0, or when `x` is near 1. 
 
    The function is implemented for real types only (unlike ``numpy.power``, 
    which accepts complex inputs). 
 
    Parameters 
    ---------- 
    x : array_like 
        The base. Must be a real type (i.e. integer or float, not complex). 
    y : array_like 
        The exponent. Must be a real type (i.e. integer or float, not complex). 
 
    Returns 
    ------- 
    array_like 
        Result of the calculation 
 
    Notes 
    ----- 
    .. versionadded:: 1.10.0 
 
    The underlying code is implemented for single precision and double 
    precision floats only.  Unlike `numpy.power`, integer inputs to 
    `powm1` are converted to floating point, and complex inputs are 
    not accepted. 
 
    Note the following edge cases: 
 
    * ``powm1(x, 0)`` returns 0 for any ``x``, including 0, ``inf`` 
      and ``nan``. 
    * ``powm1(1, y)`` returns 0 for any ``y``, including ``nan`` 
      and ``inf``. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.special import powm1 
 
    &gt;&gt;&gt; x = np.array([1.2, 10.0, 0.9999999975]) 
    &gt;&gt;&gt; y = np.array([1e-9, 1e-11, 0.1875]) 
    &gt;&gt;&gt; powm1(x, y) 
    array([ 1.82321557e-10,  2.30258509e-11, -4.68749998e-10]) 
 
    It can be verified that the relative errors in those results 
    are less than 2.5e-16. 
 
    Compare that to the result of ``x**y - 1``, where the 
    relative errors are all larger than 8e-8: 
 
    &gt;&gt;&gt; x**y - 1 
    array([ 1.82321491e-10,  2.30258035e-11, -4.68750039e-10]) 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>


<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;pseudo_huber&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    pseudo_huber(delta, r, out=None) 
 
    Pseudo-Huber loss function. 
 
    .. math:: \mathrm{pseudo\_huber}(\delta, r) = 
              \delta^2 \left( \sqrt{ 1 + \left( \frac{r}{\delta} \right)^2 } - 1 \right) 
 
    Parameters 
    ---------- 
    delta : array_like 
        Input array, indicating the soft quadratic vs. linear loss changepoint. 
    r : array_like 
        Input array, possibly representing residuals. 
    out : ndarray, optional 
        Optional output array for the function results 
 
    Returns 
    ------- 
    res : scalar or ndarray 
        The computed Pseudo-Huber loss function values. 
 
    See Also 
    -------- 
    huber: Similar function which this function approximates 
 
    Notes 
    ----- 
    Like `huber`, `pseudo_huber` often serves as a robust loss function 
    in statistics or machine learning to reduce the influence of outliers. 
    Unlike `huber`, `pseudo_huber` is smooth. 
 
    Typically, `r` represents residuals, the difference 
    between a model prediction and data. Then, for :math:`|r|\leq\delta`, 
    `pseudo_huber` resembles the squared error and for :math:`|r|&gt;\delta` the 
    absolute error. This way, the Pseudo-Huber loss often achieves 
    a fast convergence in model fitting for small residuals like the squared 
    error loss function and still reduces the influence of outliers 
    (:math:`|r|&gt;\delta`) like the absolute error loss. As :math:`\delta` is 
    the cutoff between squared and absolute error regimes, it has 
    to be tuned carefully for each problem. `pseudo_huber` is also 
    convex, making it suitable for gradient based optimization. [1]_ [2]_ 
 
    .. versionadded:: 0.15.0 
 
    References 
    ---------- 
    .. [1] Hartley, Zisserman, &quot;Multiple View Geometry in Computer Vision&quot;. 
           2003. Cambridge University Press. p. 619 
    .. [2] Charbonnier et al. &quot;Deterministic edge-preserving regularization 
           in computed imaging&quot;. 1997. IEEE Trans. Image Processing. 
           6 (2): 298 - 311. 
 
    Examples 
    -------- 
    Import all necessary modules. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.special import pseudo_huber, huber 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
 
    Calculate the function for ``delta=1`` at ``r=2``. 
 
    &gt;&gt;&gt; pseudo_huber(1., 2.) 
    1.2360679774997898 
 
    Calculate the function at ``r=2`` for different `delta` by providing 
    a list or NumPy array for `delta`. 
 
    &gt;&gt;&gt; pseudo_huber([1., 2., 4.], 3.) 
    array([2.16227766, 3.21110255, 4.        ]) 
 
    Calculate the function for ``delta=1`` at several points by providing 
    a list or NumPy array for `r`. 
 
    &gt;&gt;&gt; pseudo_huber(2., np.array([1., 1.5, 3., 4.])) 
    array([0.47213595, 1.        , 3.21110255, 4.94427191]) 
 
    The function can be calculated for different `delta` and `r` by 
    providing arrays for both with compatible shapes for broadcasting. 
 
    &gt;&gt;&gt; r = np.array([1., 2.5, 8., 10.]) 
    &gt;&gt;&gt; deltas = np.array([[1.], [5.], [9.]]) 
    &gt;&gt;&gt; print(r.shape, deltas.shape) 
    (4,) (3, 1) 
 
    &gt;&gt;&gt; pseudo_huber(deltas, r) 
    array([[ 0.41421356,  1.6925824 ,  7.06225775,  9.04987562], 
           [ 0.49509757,  2.95084972, 22.16990566, 30.90169944], 
           [ 0.49846624,  3.06693762, 27.37435121, 40.08261642]]) 
 
    Plot the function for different `delta`. 
 
    &gt;&gt;&gt; x = np.linspace(-4, 4, 500) 
    &gt;&gt;&gt; deltas = [1, 2, 3] 
    &gt;&gt;&gt; linestyles = [&quot;dashed&quot;, &quot;dotted&quot;, &quot;dashdot&quot;] 
    &gt;&gt;&gt; fig, ax = plt.subplots() 
    &gt;&gt;&gt; combined_plot_parameters = list(zip(deltas, linestyles)) 
    &gt;&gt;&gt; for delta, style in combined_plot_parameters: 
    ...     ax.plot(x, pseudo_huber(delta, x), label=rf&quot;$\delta={delta}$&quot;, 
    ...             ls=style) 
    &gt;&gt;&gt; ax.legend(loc=&quot;upper center&quot;) 
    &gt;&gt;&gt; ax.set_xlabel(&quot;$x$&quot;) 
    &gt;&gt;&gt; ax.set_title(r&quot;Pseudo-Huber loss function $h_{\delta}(x)$&quot;) 
    &gt;&gt;&gt; ax.set_xlim(-4, 4) 
    &gt;&gt;&gt; ax.set_ylim(0, 8) 
    &gt;&gt;&gt; plt.show() 
 
    Finally, illustrate the difference between `huber` and `pseudo_huber` by 
    plotting them and their gradients with respect to `r`. The plot shows 
    that `pseudo_huber` is continuously differentiable while `huber` is not 
    at the points :math:`\pm\delta`. 
 
    &gt;&gt;&gt; def huber_grad(delta, x): 
    ...     grad = np.copy(x) 
    ...     linear_area = np.argwhere(np.abs(x) &gt; delta) 
    ...     grad[linear_area]=delta*np.sign(x[linear_area]) 
    ...     return grad 
    &gt;&gt;&gt; def pseudo_huber_grad(delta, x): 
    ...     return x* (1+(x/delta)**2)**(-0.5) 
    &gt;&gt;&gt; x=np.linspace(-3, 3, 500) 
    &gt;&gt;&gt; delta = 1. 
    &gt;&gt;&gt; fig, ax = plt.subplots(figsize=(7, 7)) 
    &gt;&gt;&gt; ax.plot(x, huber(delta, x), label=&quot;Huber&quot;, ls=&quot;dashed&quot;) 
    &gt;&gt;&gt; ax.plot(x, huber_grad(delta, x), label=&quot;Huber Gradient&quot;, ls=&quot;dashdot&quot;) 
    &gt;&gt;&gt; ax.plot(x, pseudo_huber(delta, x), label=&quot;Pseudo-Huber&quot;, ls=&quot;dotted&quot;) 
    &gt;&gt;&gt; ax.plot(x, pseudo_huber_grad(delta, x), label=&quot;Pseudo-Huber Gradient&quot;, 
    ...         ls=&quot;solid&quot;) 
    &gt;&gt;&gt; ax.legend(loc=&quot;upper center&quot;) 
    &gt;&gt;&gt; plt.show() 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;radian&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    radian(d, m, s, out=None) 
 
    Convert from degrees to radians. 
 
    Returns the angle given in (d)egrees, (m)inutes, and (s)econds in 
    radians. 
 
    Parameters 
    ---------- 
    d : array_like 
        Degrees, can be real-valued. 
    m : array_like 
        Minutes, can be real-valued. 
    s : array_like 
        Seconds, can be real-valued. 
    out : ndarray, optional 
        Optional output array for the function results. 
 
    Returns 
    ------- 
    scalar or ndarray 
        Values of the inputs in radians. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import scipy.special as sc 
 
    There are many ways to specify an angle. 
 
    &gt;&gt;&gt; sc.radian(90, 0, 0) 
    1.5707963267948966 
    &gt;&gt;&gt; sc.radian(0, 60 * 90, 0) 
    1.5707963267948966 
    &gt;&gt;&gt; sc.radian(0, 0, 60**2 * 90) 
    1.5707963267948966 
 
    The inputs can be real-valued. 
 
    &gt;&gt;&gt; sc.radian(1.5, 0, 0) 
    0.02617993877991494 
    &gt;&gt;&gt; sc.radian(1, 30, 0) 
    0.02617993877991494 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;rel_entr&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    rel_entr(x, y, out=None) 
 
    Elementwise function for computing relative entropy. 
 
    .. math:: 
 
        \mathrm{rel\_entr}(x, y) = 
            \begin{cases} 
                x \log(x / y) &amp; x &gt; 0, y &gt; 0 \\ 
                0 &amp; x = 0, y \ge 0 \\ 
                \infty &amp; \text{otherwise} 
            \end{cases} 
 
    Parameters 
    ---------- 
    x, y : array_like 
        Input arrays 
    out : ndarray, optional 
        Optional output array for the function results 
 
    Returns 
    ------- 
    scalar or ndarray 
        Relative entropy of the inputs 
 
    See Also 
    -------- 
    entr, kl_div, scipy.stats.entropy 
 
    Notes 
    ----- 
    .. versionadded:: 0.15.0 
 
    This function is jointly convex in x and y. 
 
    The origin of this function is in convex programming; see 
    [1]_. Given two discrete probability distributions :math:`p_1, 
    \ldots, p_n` and :math:`q_1, \ldots, q_n`, the definition of relative 
    entropy in the context of *information theory* is 
 
    .. math:: 
 
        \sum_{i = 1}^n \mathrm{rel\_entr}(p_i, q_i). 
 
    To compute the latter quantity, use `scipy.stats.entropy`. 
 
    See [2]_ for details. 
 
    References 
    ---------- 
    .. [1] Boyd, Stephen and Lieven Vandenberghe. *Convex optimization*. 
           Cambridge University Press, 2004. 
           :doi:`https://doi.org/10.1017/CBO9780511804441` 
    .. [2] Kullback-Leibler divergence, 
           https://en.wikipedia.org/wiki/Kullback%E2%80%93Leibler_divergence 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;round&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    round(x, out=None) 
 
    Round to the nearest integer. 
 
    Returns the nearest integer to `x`.  If `x` ends in 0.5 exactly, 
    the nearest even integer is chosen. 
 
    Parameters 
    ---------- 
    x : array_like 
        Real valued input. 
    out : ndarray, optional 
        Optional output array for the function results. 
 
    Returns 
    ------- 
    scalar or ndarray 
        The nearest integers to the elements of `x`. The result is of 
        floating type, not integer type. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import scipy.special as sc 
 
    It rounds to even. 
 
    &gt;&gt;&gt; sc.round([0.5, 1.5]) 
    array([0., 2.]) 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;shichi&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    shichi(x, out=None) 
 
    Hyperbolic sine and cosine integrals. 
 
    The hyperbolic sine integral is 
 
    .. math:: 
 
      \int_0^x \frac{\sinh{t}}{t}dt 
 
    and the hyperbolic cosine integral is 
 
    .. math:: 
 
      \gamma + \log(x) + \int_0^x \frac{\cosh{t} - 1}{t} dt 
 
    where :math:`\gamma` is Euler's constant and :math:`\log` is the 
    principal branch of the logarithm [1]_. 
 
    Parameters 
    ---------- 
    x : array_like 
        Real or complex points at which to compute the hyperbolic sine 
        and cosine integrals. 
    out : tuple of ndarray, optional 
        Optional output arrays for the function results 
 
    Returns 
    ------- 
    si : scalar or ndarray 
        Hyperbolic sine integral at ``x`` 
    ci : scalar or ndarray 
        Hyperbolic cosine integral at ``x`` 
 
    See Also 
    -------- 
    sici : Sine and cosine integrals. 
    exp1 : Exponential integral E1. 
    expi : Exponential integral Ei. 
 
    Notes 
    ----- 
    For real arguments with ``x &lt; 0``, ``chi`` is the real part of the 
    hyperbolic cosine integral. For such points ``chi(x)`` and ``chi(x 
    + 0j)`` differ by a factor of ``1j*pi``. 
 
    For real arguments the function is computed by calling Cephes' 
    [2]_ *shichi* routine. For complex arguments the algorithm is based 
    on Mpmath's [3]_ *shi* and *chi* routines. 
 
    References 
    ---------- 
    .. [1] Milton Abramowitz and Irene A. Stegun, eds. 
           Handbook of Mathematical Functions with Formulas, 
           Graphs, and Mathematical Tables. New York: Dover, 1972. 
           (See Section 5.2.) 
    .. [2] Cephes Mathematical Functions Library, 
           http://www.netlib.org/cephes/ 
    .. [3] Fredrik Johansson and others. 
           &quot;mpmath: a Python library for arbitrary-precision floating-point 
           arithmetic&quot; (Version 0.19) http://mpmath.org/ 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; from scipy.special import shichi, sici 
 
    `shichi` accepts real or complex input: 
 
    &gt;&gt;&gt; shichi(0.5) 
    (0.5069967498196671, -0.05277684495649357) 
    &gt;&gt;&gt; shichi(0.5 + 2.5j) 
    ((0.11772029666668238+1.831091777729851j), 
     (0.29912435887648825+1.7395351121166562j)) 
 
    The hyperbolic sine and cosine integrals Shi(z) and Chi(z) are 
    related to the sine and cosine integrals Si(z) and Ci(z) by 
 
    * Shi(z) = -i*Si(i*z) 
    * Chi(z) = Ci(-i*z) + i*pi/2 
 
    &gt;&gt;&gt; z = 0.25 + 5j 
    &gt;&gt;&gt; shi, chi = shichi(z) 
    &gt;&gt;&gt; shi, -1j*sici(1j*z)[0]            # Should be the same. 
    ((-0.04834719325101729+1.5469354086921228j), 
     (-0.04834719325101729+1.5469354086921228j)) 
    &gt;&gt;&gt; chi, sici(-1j*z)[1] + 1j*np.pi/2  # Should be the same. 
    ((-0.19568708973868087+1.556276312103824j), 
     (-0.19568708973868087+1.556276312103824j)) 
 
    Plot the functions evaluated on the real axis: 
 
    &gt;&gt;&gt; xp = np.geomspace(1e-8, 4.0, 250) 
    &gt;&gt;&gt; x = np.concatenate((-xp[::-1], xp)) 
    &gt;&gt;&gt; shi, chi = shichi(x) 
 
    &gt;&gt;&gt; fig, ax = plt.subplots() 
    &gt;&gt;&gt; ax.plot(x, shi, label='Shi(x)') 
    &gt;&gt;&gt; ax.plot(x, chi, '--', label='Chi(x)') 
    &gt;&gt;&gt; ax.set_xlabel('x') 
    &gt;&gt;&gt; ax.set_title('Hyperbolic Sine and Cosine Integrals') 
    &gt;&gt;&gt; ax.legend(shadow=True, framealpha=1, loc='lower right') 
    &gt;&gt;&gt; ax.grid(True) 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;sici&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    sici(x, out=None) 
 
    Sine and cosine integrals. 
 
    The sine integral is 
 
    .. math:: 
 
      \int_0^x \frac{\sin{t}}{t}dt 
 
    and the cosine integral is 
 
    .. math:: 
 
      \gamma + \log(x) + \int_0^x \frac{\cos{t} - 1}{t}dt 
 
    where :math:`\gamma` is Euler's constant and :math:`\log` is the 
    principal branch of the logarithm [1]_. 
 
    Parameters 
    ---------- 
    x : array_like 
        Real or complex points at which to compute the sine and cosine 
        integrals. 
    out : tuple of ndarray, optional 
        Optional output arrays for the function results 
 
    Returns 
    ------- 
    si : scalar or ndarray 
        Sine integral at ``x`` 
    ci : scalar or ndarray 
        Cosine integral at ``x`` 
 
    See Also 
    -------- 
    shichi : Hyperbolic sine and cosine integrals. 
    exp1 : Exponential integral E1. 
    expi : Exponential integral Ei. 
 
    Notes 
    ----- 
    For real arguments with ``x &lt; 0``, ``ci`` is the real part of the 
    cosine integral. For such points ``ci(x)`` and ``ci(x + 0j)`` 
    differ by a factor of ``1j*pi``. 
 
    For real arguments the function is computed by calling Cephes' 
    [2]_ *sici* routine. For complex arguments the algorithm is based 
    on Mpmath's [3]_ *si* and *ci* routines. 
 
    References 
    ---------- 
    .. [1] Milton Abramowitz and Irene A. Stegun, eds. 
           Handbook of Mathematical Functions with Formulas, 
           Graphs, and Mathematical Tables. New York: Dover, 1972. 
           (See Section 5.2.) 
    .. [2] Cephes Mathematical Functions Library, 
           http://www.netlib.org/cephes/ 
    .. [3] Fredrik Johansson and others. 
           &quot;mpmath: a Python library for arbitrary-precision floating-point 
           arithmetic&quot; (Version 0.19) http://mpmath.org/ 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; from scipy.special import sici, exp1 
 
    `sici` accepts real or complex input: 
 
    &gt;&gt;&gt; sici(2.5) 
    (1.7785201734438267, 0.2858711963653835) 
    &gt;&gt;&gt; sici(2.5 + 3j) 
    ((4.505735874563953+0.06863305018999577j), 
    (0.0793644206906966-2.935510262937543j)) 
 
    For z in the right half plane, the sine and cosine integrals are 
    related to the exponential integral E1 (implemented in SciPy as 
    `scipy.special.exp1`) by 
 
    * Si(z) = (E1(i*z) - E1(-i*z))/2i + pi/2 
    * Ci(z) = -(E1(i*z) + E1(-i*z))/2 
 
    See [1]_ (equations 5.2.21 and 5.2.23). 
 
    We can verify these relations: 
 
    &gt;&gt;&gt; z = 2 - 3j 
    &gt;&gt;&gt; sici(z) 
    ((4.54751388956229-1.3991965806460565j), 
    (1.408292501520851+2.9836177420296055j)) 
 
    &gt;&gt;&gt; (exp1(1j*z) - exp1(-1j*z))/2j + np.pi/2  # Same as sine integral 
    (4.54751388956229-1.3991965806460565j) 
 
    &gt;&gt;&gt; -(exp1(1j*z) + exp1(-1j*z))/2            # Same as cosine integral 
    (1.408292501520851+2.9836177420296055j) 
 
    Plot the functions evaluated on the real axis; the dotted horizontal 
    lines are at pi/2 and -pi/2: 
 
    &gt;&gt;&gt; x = np.linspace(-16, 16, 150) 
    &gt;&gt;&gt; si, ci = sici(x) 
 
    &gt;&gt;&gt; fig, ax = plt.subplots() 
    &gt;&gt;&gt; ax.plot(x, si, label='Si(x)') 
    &gt;&gt;&gt; ax.plot(x, ci, '--', label='Ci(x)') 
    &gt;&gt;&gt; ax.legend(shadow=True, framealpha=1, loc='upper left') 
    &gt;&gt;&gt; ax.set_xlabel('x') 
    &gt;&gt;&gt; ax.set_title('Sine and Cosine Integrals') 
    &gt;&gt;&gt; ax.axhline(np.pi/2, linestyle=':', alpha=0.5, color='k') 
    &gt;&gt;&gt; ax.axhline(-np.pi/2, linestyle=':', alpha=0.5, color='k') 
    &gt;&gt;&gt; ax.grid(True) 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;sindg&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    sindg(x, out=None) 
 
    Sine of the angle `x` given in degrees. 
 
    Parameters 
    ---------- 
    x : array_like 
        Angle, given in degrees. 
    out : ndarray, optional 
        Optional output array for the function results. 
 
    Returns 
    ------- 
    scalar or ndarray 
        Sine at the input. 
 
    See Also 
    -------- 
    cosdg, tandg, cotdg 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; import scipy.special as sc 
 
    It is more accurate than using sine directly. 
 
    &gt;&gt;&gt; x = 180 * np.arange(3) 
    &gt;&gt;&gt; sc.sindg(x) 
    array([ 0., -0.,  0.]) 
    &gt;&gt;&gt; np.sin(x * np.pi / 180) 
    array([ 0.0000000e+00,  1.2246468e-16, -2.4492936e-16]) 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;smirnov&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    smirnov(n, d, out=None) 
 
    Kolmogorov-Smirnov complementary cumulative distribution function 
 
    Returns the exact Kolmogorov-Smirnov complementary cumulative 
    distribution function,(aka the Survival Function) of Dn+ (or Dn-) 
    for a one-sided test of equality between an empirical and a 
    theoretical distribution. It is equal to the probability that the 
    maximum difference between a theoretical distribution and an empirical 
    one based on `n` samples is greater than d. 
 
    Parameters 
    ---------- 
    n : int 
      Number of samples 
    d : float array_like 
      Deviation between the Empirical CDF (ECDF) and the target CDF. 
    out : ndarray, optional 
        Optional output array for the function results 
 
    Returns 
    ------- 
    scalar or ndarray 
        The value(s) of smirnov(n, d), Prob(Dn+ &gt;= d) (Also Prob(Dn- &gt;= d)) 
 
    See Also 
    -------- 
    smirnovi : The Inverse Survival Function for the distribution 
    scipy.stats.ksone : Provides the functionality as a continuous distribution 
    kolmogorov, kolmogi : Functions for the two-sided distribution 
 
    Notes 
    ----- 
    `smirnov` is used by `stats.kstest` in the application of the 
    Kolmogorov-Smirnov Goodness of Fit test. For historical reasons this 
    function is exposed in `scpy.special`, but the recommended way to achieve 
    the most accurate CDF/SF/PDF/PPF/ISF computations is to use the 
    `stats.ksone` distribution. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.special import smirnov 
    &gt;&gt;&gt; from scipy.stats import norm 
 
    Show the probability of a gap at least as big as 0, 0.5 and 1.0 for a 
    sample of size 5. 
 
    &gt;&gt;&gt; smirnov(5, [0, 0.5, 1.0]) 
    array([ 1.   ,  0.056,  0.   ]) 
 
    Compare a sample of size 5 against N(0, 1), the standard normal 
    distribution with mean 0 and standard deviation 1. 
 
    `x` is the sample. 
 
    &gt;&gt;&gt; x = np.array([-1.392, -0.135, 0.114, 0.190, 1.82]) 
 
    &gt;&gt;&gt; target = norm(0, 1) 
    &gt;&gt;&gt; cdfs = target.cdf(x) 
    &gt;&gt;&gt; cdfs 
    array([0.0819612 , 0.44630594, 0.5453811 , 0.57534543, 0.9656205 ]) 
 
    Construct the empirical CDF and the K-S statistics (Dn+, Dn-, Dn). 
 
    &gt;&gt;&gt; n = len(x) 
    &gt;&gt;&gt; ecdfs = np.arange(n+1, dtype=float)/n 
    &gt;&gt;&gt; cols = np.column_stack([x, ecdfs[1:], cdfs, cdfs - ecdfs[:n], 
    ...                        ecdfs[1:] - cdfs]) 
    &gt;&gt;&gt; with np.printoptions(precision=3): 
    ...    print(cols) 
    [[-1.392  0.2    0.082  0.082  0.118] 
     [-0.135  0.4    0.446  0.246 -0.046] 
     [ 0.114  0.6    0.545  0.145  0.055] 
     [ 0.19   0.8    0.575 -0.025  0.225] 
     [ 1.82   1.     0.966  0.166  0.034]] 
    &gt;&gt;&gt; gaps = cols[:, -2:] 
    &gt;&gt;&gt; Dnpm = np.max(gaps, axis=0) 
    &gt;&gt;&gt; print(f'Dn-={Dnpm[0]:f}, Dn+={Dnpm[1]:f}') 
    Dn-=0.246306, Dn+=0.224655 
    &gt;&gt;&gt; probs = smirnov(n, Dnpm) 
    &gt;&gt;&gt; print(f'For a sample of size {n} drawn from N(0, 1):', 
    ...       f' Smirnov n={n}: Prob(Dn- &gt;= {Dnpm[0]:f}) = {probs[0]:.4f}', 
    ...       f' Smirnov n={n}: Prob(Dn+ &gt;= {Dnpm[1]:f}) = {probs[1]:.4f}', 
    ...       sep='\n') 
    For a sample of size 5 drawn from N(0, 1): 
     Smirnov n=5: Prob(Dn- &gt;= 0.246306) = 0.4711 
     Smirnov n=5: Prob(Dn+ &gt;= 0.224655) = 0.5245 
 
    Plot the empirical CDF and the standard normal CDF. 
 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; plt.step(np.concatenate(([-2.5], x, [2.5])), 
    ...          np.concatenate((ecdfs, [1])), 
    ...          where='post', label='Empirical CDF') 
    &gt;&gt;&gt; xx = np.linspace(-2.5, 2.5, 100) 
    &gt;&gt;&gt; plt.plot(xx, target.cdf(xx), '--', label='CDF for N(0, 1)') 
 
    Add vertical lines marking Dn+ and Dn-. 
 
    &gt;&gt;&gt; iminus, iplus = np.argmax(gaps, axis=0) 
    &gt;&gt;&gt; plt.vlines([x[iminus]], ecdfs[iminus], cdfs[iminus], color='r', 
    ...            alpha=0.5, lw=4) 
    &gt;&gt;&gt; plt.vlines([x[iplus]], cdfs[iplus], ecdfs[iplus+1], color='m', 
    ...            alpha=0.5, lw=4) 
 
    &gt;&gt;&gt; plt.grid(True) 
    &gt;&gt;&gt; plt.legend(framealpha=1, shadow=True) 
    &gt;&gt;&gt; plt.show() 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;smirnovi&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    smirnovi(n, p, out=None) 
 
    Inverse to `smirnov` 
 
    Returns `d` such that ``smirnov(n, d) == p``, the critical value 
    corresponding to `p`. 
 
    Parameters 
    ---------- 
    n : int 
      Number of samples 
    p : float array_like 
        Probability 
    out : ndarray, optional 
        Optional output array for the function results 
 
    Returns 
    ------- 
    scalar or ndarray 
        The value(s) of smirnovi(n, p), the critical values. 
 
    See Also 
    -------- 
    smirnov : The Survival Function (SF) for the distribution 
    scipy.stats.ksone : Provides the functionality as a continuous distribution 
    kolmogorov, kolmogi : Functions for the two-sided distribution 
    scipy.stats.kstwobign : Two-sided Kolmogorov-Smirnov distribution, large n 
 
    Notes 
    ----- 
    `smirnov` is used by `stats.kstest` in the application of the 
    Kolmogorov-Smirnov Goodness of Fit test. For historical reasons this 
    function is exposed in `scpy.special`, but the recommended way to achieve 
    the most accurate CDF/SF/PDF/PPF/ISF computations is to use the 
    `stats.ksone` distribution. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.special import smirnovi, smirnov 
 
    &gt;&gt;&gt; n = 24 
    &gt;&gt;&gt; deviations = [0.1, 0.2, 0.3] 
 
    Use `smirnov` to compute the complementary CDF of the Smirnov 
    distribution for the given number of samples and deviations. 
 
    &gt;&gt;&gt; p = smirnov(n, deviations) 
    &gt;&gt;&gt; p 
    array([0.58105083, 0.12826832, 0.01032231]) 
 
    The inverse function ``smirnovi(n, p)`` returns ``deviations``. 
 
    &gt;&gt;&gt; smirnovi(n, p) 
    array([0.1, 0.2, 0.3]) 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;_smirnovc&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    _smirnovc(n, d) 
     Internal function, do not use. 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;_smirnovci&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
     Internal function, do not use. 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;_smirnovp&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    _smirnovp(n, p) 
     Internal function, do not use. 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;spence&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    spence(z, out=None) 
 
    Spence's function, also known as the dilogarithm. 
 
    It is defined to be 
 
    .. math:: 
      \int_1^z \frac{\log(t)}{1 - t}dt 
 
    for complex :math:`z`, where the contour of integration is taken 
    to avoid the branch cut of the logarithm. Spence's function is 
    analytic everywhere except the negative real axis where it has a 
    branch cut. 
 
    Parameters 
    ---------- 
    z : array_like 
        Points at which to evaluate Spence's function 
    out : ndarray, optional 
        Optional output array for the function results 
 
    Returns 
    ------- 
    s : scalar or ndarray 
        Computed values of Spence's function 
 
    Notes 
    ----- 
    There is a different convention which defines Spence's function by 
    the integral 
 
    .. math:: 
      -\int_0^z \frac{\log(1 - t)}{t}dt; 
 
    this is our ``spence(1 - z)``. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.special import spence 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
 
    The function is defined for complex inputs: 
 
    &gt;&gt;&gt; spence([1-1j, 1.5+2j, 3j, -10-5j]) 
    array([-0.20561676+0.91596559j, -0.86766909-1.39560134j, 
           -0.59422064-2.49129918j, -1.14044398+6.80075924j]) 
 
    For complex inputs on the branch cut, which is the negative real axis, 
    the function returns the limit for ``z`` with positive imaginary part. 
    For example, in the following, note the sign change of the imaginary 
    part of the output for ``z = -2`` and ``z = -2 - 1e-8j``: 
 
    &gt;&gt;&gt; spence([-2 + 1e-8j, -2, -2 - 1e-8j]) 
    array([2.32018041-3.45139229j, 2.32018042-3.4513923j , 
           2.32018041+3.45139229j]) 
 
    The function returns ``nan`` for real inputs on the branch cut: 
 
    &gt;&gt;&gt; spence(-1.5) 
    nan 
 
    Verify some particular values: ``spence(0) = pi**2/6``, 
    ``spence(1) = 0`` and ``spence(2) = -pi**2/12``. 
 
    &gt;&gt;&gt; spence([0, 1, 2]) 
    array([ 1.64493407,  0.        , -0.82246703]) 
    &gt;&gt;&gt; np.pi**2/6, -np.pi**2/12 
    (1.6449340668482264, -0.8224670334241132) 
 
    Verify the identity:: 
 
        spence(z) + spence(1 - z) = pi**2/6 - log(z)*log(1 - z) 
 
    &gt;&gt;&gt; z = 3 + 4j 
    &gt;&gt;&gt; spence(z) + spence(1 - z) 
    (-2.6523186143876067+1.8853470951513935j) 
    &gt;&gt;&gt; np.pi**2/6 - np.log(z)*np.log(1 - z) 
    (-2.652318614387606+1.885347095151394j) 
 
    Plot the function for positive real input. 
 
    &gt;&gt;&gt; fig, ax = plt.subplots() 
    &gt;&gt;&gt; x = np.linspace(0, 6, 400) 
    &gt;&gt;&gt; ax.plot(x, spence(x)) 
    &gt;&gt;&gt; ax.grid() 
    &gt;&gt;&gt; ax.set_xlabel('x') 
    &gt;&gt;&gt; ax.set_title('spence(x)') 
    &gt;&gt;&gt; plt.show() 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span>
    <span class="s4">&quot;stdtr&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    stdtr(df, t, out=None) 
 
    Student t distribution cumulative distribution function 
 
    Returns the integral: 
 
    .. math:: 
        \frac{\Gamma((df+1)/2)}{\sqrt{\pi df} \Gamma(df/2)} 
        \int_{-\infty}^t (1+x^2/df)^{-(df+1)/2}\, dx 
 
    Parameters 
    ---------- 
    df : array_like 
        Degrees of freedom 
    t : array_like 
        Upper bound of the integral 
    out : ndarray, optional 
        Optional output array for the function results 
 
    Returns 
    ------- 
    scalar or ndarray 
        Value of the Student t CDF at t 
 
    See Also 
    -------- 
    stdtridf : inverse of stdtr with respect to `df` 
    stdtrit : inverse of stdtr with respect to `t` 
    scipy.stats.t : student t distribution 
 
    Notes 
    ----- 
    The student t distribution is also available as `scipy.stats.t`. 
    Calling `stdtr` directly can improve performance compared to the 
    ``cdf`` method of `scipy.stats.t` (see last example below). 
 
    Examples 
    -------- 
    Calculate the function for ``df=3`` at ``t=1``. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.special import stdtr 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; stdtr(3, 1) 
    0.8044988905221148 
 
    Plot the function for three different degrees of freedom. 
 
    &gt;&gt;&gt; x = np.linspace(-10, 10, 1000) 
    &gt;&gt;&gt; fig, ax = plt.subplots() 
    &gt;&gt;&gt; parameters = [(1, &quot;solid&quot;), (3, &quot;dashed&quot;), (10, &quot;dotted&quot;)] 
    &gt;&gt;&gt; for (df, linestyle) in parameters: 
    ...     ax.plot(x, stdtr(df, x), ls=linestyle, label=f&quot;$df={df}$&quot;) 
    &gt;&gt;&gt; ax.legend() 
    &gt;&gt;&gt; ax.set_title(&quot;Student t distribution cumulative distribution function&quot;) 
    &gt;&gt;&gt; plt.show() 
 
    The function can be computed for several degrees of freedom at the same 
    time by providing a NumPy array or list for `df`: 
 
    &gt;&gt;&gt; stdtr([1, 2, 3], 1) 
    array([0.75      , 0.78867513, 0.80449889]) 
 
    It is possible to calculate the function at several points for several 
    different degrees of freedom simultaneously by providing arrays for `df` 
    and `t` with shapes compatible for broadcasting. Compute `stdtr` at 
    4 points for 3 degrees of freedom resulting in an array of shape 3x4. 
 
    &gt;&gt;&gt; dfs = np.array([[1], [2], [3]]) 
    &gt;&gt;&gt; t = np.array([2, 4, 6, 8]) 
    &gt;&gt;&gt; dfs.shape, t.shape 
    ((3, 1), (4,)) 
 
    &gt;&gt;&gt; stdtr(dfs, t) 
    array([[0.85241638, 0.92202087, 0.94743154, 0.96041658], 
           [0.90824829, 0.97140452, 0.98666426, 0.99236596], 
           [0.93033702, 0.98599577, 0.99536364, 0.99796171]]) 
 
    The t distribution is also available as `scipy.stats.t`. Calling `stdtr` 
    directly can be much faster than calling the ``cdf`` method of 
    `scipy.stats.t`. To get the same results, one must use the following 
    parametrization: ``scipy.stats.t(df).cdf(x) = stdtr(df, x)``. 
 
    &gt;&gt;&gt; from scipy.stats import t 
    &gt;&gt;&gt; df, x = 3, 1 
    &gt;&gt;&gt; stdtr_result = stdtr(df, x)  # this can be faster than below 
    &gt;&gt;&gt; stats_result = t(df).cdf(x) 
    &gt;&gt;&gt; stats_result == stdtr_result  # test that results are equal 
    True 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;stdtridf&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    stdtridf(p, t, out=None) 
 
    Inverse of `stdtr` vs df 
 
    Returns the argument df such that stdtr(df, t) is equal to `p`. 
 
    Parameters 
    ---------- 
    p : array_like 
        Probability 
    t : array_like 
        Upper bound of the integral 
    out : ndarray, optional 
        Optional output array for the function results 
 
    Returns 
    ------- 
    df : scalar or ndarray 
        Value of `df` such that ``stdtr(df, t) == p`` 
 
    See Also 
    -------- 
    stdtr : Student t CDF 
    stdtrit : inverse of stdtr with respect to `t` 
    scipy.stats.t : Student t distribution 
 
    Examples 
    -------- 
    Compute the student t cumulative distribution function for one 
    parameter set. 
 
    &gt;&gt;&gt; from scipy.special import stdtr, stdtridf 
    &gt;&gt;&gt; df, x = 5, 2 
    &gt;&gt;&gt; cdf_value = stdtr(df, x) 
    &gt;&gt;&gt; cdf_value 
    0.9490302605850709 
 
    Verify that `stdtridf` recovers the original value for `df` given 
    the CDF value and `x`. 
 
    &gt;&gt;&gt; stdtridf(cdf_value, x) 
    5.0 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;stdtrit&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    stdtrit(df, p, out=None) 
 
    The `p`-th quantile of the student t distribution. 
 
    This function is the inverse of the student t distribution cumulative 
    distribution function (CDF), returning `t` such that `stdtr(df, t) = p`. 
 
    Returns the argument `t` such that stdtr(df, t) is equal to `p`. 
 
    Parameters 
    ---------- 
    df : array_like 
        Degrees of freedom 
    p : array_like 
        Probability 
    out : ndarray, optional 
        Optional output array for the function results 
 
    Returns 
    ------- 
    t : scalar or ndarray 
        Value of `t` such that ``stdtr(df, t) == p`` 
 
    See Also 
    -------- 
    stdtr : Student t CDF 
    stdtridf : inverse of stdtr with respect to `df` 
    scipy.stats.t : Student t distribution 
 
    Notes 
    ----- 
    The student t distribution is also available as `scipy.stats.t`. Calling 
    `stdtrit` directly can improve performance compared to the ``ppf`` 
    method of `scipy.stats.t` (see last example below). 
 
    Examples 
    -------- 
    `stdtrit` represents the inverse of the student t distribution CDF which 
    is available as `stdtr`. Here, we calculate the CDF for ``df`` at 
    ``x=1``. `stdtrit` then returns ``1`` up to floating point errors 
    given the same value for `df` and the computed CDF value. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.special import stdtr, stdtrit 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; df = 3 
    &gt;&gt;&gt; x = 1 
    &gt;&gt;&gt; cdf_value = stdtr(df, x) 
    &gt;&gt;&gt; stdtrit(df, cdf_value) 
    0.9999999994418539 
 
    Plot the function for three different degrees of freedom. 
 
    &gt;&gt;&gt; x = np.linspace(0, 1, 1000) 
    &gt;&gt;&gt; parameters = [(1, &quot;solid&quot;), (2, &quot;dashed&quot;), (5, &quot;dotted&quot;)] 
    &gt;&gt;&gt; fig, ax = plt.subplots() 
    &gt;&gt;&gt; for (df, linestyle) in parameters: 
    ...     ax.plot(x, stdtrit(df, x), ls=linestyle, label=f&quot;$df={df}$&quot;) 
    &gt;&gt;&gt; ax.legend() 
    &gt;&gt;&gt; ax.set_ylim(-10, 10) 
    &gt;&gt;&gt; ax.set_title(&quot;Student t distribution quantile function&quot;) 
    &gt;&gt;&gt; plt.show() 
 
    The function can be computed for several degrees of freedom at the same 
    time by providing a NumPy array or list for `df`: 
 
    &gt;&gt;&gt; stdtrit([1, 2, 3], 0.7) 
    array([0.72654253, 0.6172134 , 0.58438973]) 
 
    It is possible to calculate the function at several points for several 
    different degrees of freedom simultaneously by providing arrays for `df` 
    and `p` with shapes compatible for broadcasting. Compute `stdtrit` at 
    4 points for 3 degrees of freedom resulting in an array of shape 3x4. 
 
    &gt;&gt;&gt; dfs = np.array([[1], [2], [3]]) 
    &gt;&gt;&gt; p = np.array([0.2, 0.4, 0.7, 0.8]) 
    &gt;&gt;&gt; dfs.shape, p.shape 
    ((3, 1), (4,)) 
 
    &gt;&gt;&gt; stdtrit(dfs, p) 
    array([[-1.37638192, -0.3249197 ,  0.72654253,  1.37638192], 
           [-1.06066017, -0.28867513,  0.6172134 ,  1.06066017], 
           [-0.97847231, -0.27667066,  0.58438973,  0.97847231]]) 
 
    The t distribution is also available as `scipy.stats.t`. Calling `stdtrit` 
    directly can be much faster than calling the ``ppf`` method of 
    `scipy.stats.t`. To get the same results, one must use the following 
    parametrization: ``scipy.stats.t(df).ppf(x) = stdtrit(df, x)``. 
 
    &gt;&gt;&gt; from scipy.stats import t 
    &gt;&gt;&gt; df, x = 3, 0.5 
    &gt;&gt;&gt; stdtrit_result = stdtrit(df, x)  # this can be faster than below 
    &gt;&gt;&gt; stats_result = t(df).ppf(x) 
    &gt;&gt;&gt; stats_result == stdtrit_result  # test that results are equal 
    True 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;struve&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    struve(v, x, out=None) 
 
    Struve function. 
 
    Return the value of the Struve function of order `v` at `x`.  The Struve 
    function is defined as, 
 
    .. math:: 
        H_v(x) = (z/2)^{v + 1} \sum_{n=0}^\infty 
        \frac{(-1)^n (z/2)^{2n}}{\Gamma(n + \frac{3}{2}) \Gamma(n + v + \frac{3}{2})}, 
 
    where :math:`\Gamma` is the gamma function. 
 
    Parameters 
    ---------- 
    v : array_like 
        Order of the Struve function (float). 
    x : array_like 
        Argument of the Struve function (float; must be positive unless `v` is 
        an integer). 
    out : ndarray, optional 
        Optional output array for the function results 
 
    Returns 
    ------- 
    H : scalar or ndarray 
        Value of the Struve function of order `v` at `x`. 
 
    See Also 
    -------- 
    modstruve: Modified Struve function 
 
    Notes 
    ----- 
    Three methods discussed in [1]_ are used to evaluate the Struve function: 
 
    - power series 
    - expansion in Bessel functions (if :math:`|z| &lt; |v| + 20`) 
    - asymptotic large-z expansion (if :math:`z \geq 0.7v + 12`) 
 
    Rounding errors are estimated based on the largest terms in the sums, and 
    the result associated with the smallest error is returned. 
 
    References 
    ---------- 
    .. [1] NIST Digital Library of Mathematical Functions 
           https://dlmf.nist.gov/11 
 
    Examples 
    -------- 
    Calculate the Struve function of order 1 at 2. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.special import struve 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; struve(1, 2.) 
    0.6467637282835622 
 
    Calculate the Struve function at 2 for orders 1, 2 and 3 by providing 
    a list for the order parameter `v`. 
 
    &gt;&gt;&gt; struve([1, 2, 3], 2.) 
    array([0.64676373, 0.28031806, 0.08363767]) 
 
    Calculate the Struve function of order 1 for several points by providing 
    an array for `x`. 
 
    &gt;&gt;&gt; points = np.array([2., 5., 8.]) 
    &gt;&gt;&gt; struve(1, points) 
    array([0.64676373, 0.80781195, 0.48811605]) 
 
    Compute the Struve function for several orders at several points by 
    providing arrays for `v` and `z`. The arrays have to be broadcastable 
    to the correct shapes. 
 
    &gt;&gt;&gt; orders = np.array([[1], [2], [3]]) 
    &gt;&gt;&gt; points.shape, orders.shape 
    ((3,), (3, 1)) 
 
    &gt;&gt;&gt; struve(orders, points) 
    array([[0.64676373, 0.80781195, 0.48811605], 
           [0.28031806, 1.56937455, 1.51769363], 
           [0.08363767, 1.50872065, 2.98697513]]) 
 
    Plot the Struve functions of order 0 to 3 from -10 to 10. 
 
    &gt;&gt;&gt; fig, ax = plt.subplots() 
    &gt;&gt;&gt; x = np.linspace(-10., 10., 1000) 
    &gt;&gt;&gt; for i in range(4): 
    ...     ax.plot(x, struve(i, x), label=f'$H_{i!r}$') 
    &gt;&gt;&gt; ax.legend(ncol=2) 
    &gt;&gt;&gt; ax.set_xlim(-10, 10) 
    &gt;&gt;&gt; ax.set_title(r&quot;Struve functions $H_{\nu}$&quot;) 
    &gt;&gt;&gt; plt.show() 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;tandg&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    tandg(x, out=None) 
 
    Tangent of angle `x` given in degrees. 
 
    Parameters 
    ---------- 
    x : array_like 
        Angle, given in degrees. 
    out : ndarray, optional 
        Optional output array for the function results. 
 
    Returns 
    ------- 
    scalar or ndarray 
        Tangent at the input. 
 
    See Also 
    -------- 
    sindg, cosdg, cotdg 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; import scipy.special as sc 
 
    It is more accurate than using tangent directly. 
 
    &gt;&gt;&gt; x = 180 * np.arange(3) 
    &gt;&gt;&gt; sc.tandg(x) 
    array([0., 0., 0.]) 
    &gt;&gt;&gt; np.tan(x * np.pi / 180) 
    array([ 0.0000000e+00, -1.2246468e-16, -2.4492936e-16]) 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span>
    <span class="s4">&quot;tklmbda&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    tklmbda(x, lmbda, out=None) 
 
    Cumulative distribution function of the Tukey lambda distribution. 
 
    Parameters 
    ---------- 
    x, lmbda : array_like 
        Parameters 
    out : ndarray, optional 
        Optional output array for the function results 
 
    Returns 
    ------- 
    cdf : scalar or ndarray 
        Value of the Tukey lambda CDF 
 
    See Also 
    -------- 
    scipy.stats.tukeylambda : Tukey lambda distribution 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; from scipy.special import tklmbda, expit 
 
    Compute the cumulative distribution function (CDF) of the Tukey lambda 
    distribution at several ``x`` values for `lmbda` = -1.5. 
 
    &gt;&gt;&gt; x = np.linspace(-2, 2, 9) 
    &gt;&gt;&gt; x 
    array([-2. , -1.5, -1. , -0.5,  0. ,  0.5,  1. ,  1.5,  2. ]) 
    &gt;&gt;&gt; tklmbda(x, -1.5) 
    array([0.34688734, 0.3786554 , 0.41528805, 0.45629737, 0.5       , 
           0.54370263, 0.58471195, 0.6213446 , 0.65311266]) 
 
    When `lmbda` is 0, the function is the logistic sigmoid function, 
    which is implemented in `scipy.special` as `expit`. 
 
    &gt;&gt;&gt; tklmbda(x, 0) 
    array([0.11920292, 0.18242552, 0.26894142, 0.37754067, 0.5       , 
           0.62245933, 0.73105858, 0.81757448, 0.88079708]) 
    &gt;&gt;&gt; expit(x) 
    array([0.11920292, 0.18242552, 0.26894142, 0.37754067, 0.5       , 
           0.62245933, 0.73105858, 0.81757448, 0.88079708]) 
 
    When `lmbda` is 1, the Tukey lambda distribution is uniform on the 
    interval [-1, 1], so the CDF increases linearly. 
 
    &gt;&gt;&gt; t = np.linspace(-1, 1, 9) 
    &gt;&gt;&gt; tklmbda(t, 1) 
    array([0.   , 0.125, 0.25 , 0.375, 0.5  , 0.625, 0.75 , 0.875, 1.   ]) 
 
    In the following, we generate plots for several values of `lmbda`. 
 
    The first figure shows graphs for `lmbda` &lt;= 0. 
 
    &gt;&gt;&gt; styles = ['-', '-.', '--', ':'] 
    &gt;&gt;&gt; fig, ax = plt.subplots() 
    &gt;&gt;&gt; x = np.linspace(-12, 12, 500) 
    &gt;&gt;&gt; for k, lmbda in enumerate([-1.0, -0.5, 0.0]): 
    ...     y = tklmbda(x, lmbda) 
    ...     ax.plot(x, y, styles[k], label=rf'$\lambda$ = {lmbda:-4.1f}') 
 
    &gt;&gt;&gt; ax.set_title(r'tklmbda(x, $\lambda$)') 
    &gt;&gt;&gt; ax.set_label('x') 
    &gt;&gt;&gt; ax.legend(framealpha=1, shadow=True) 
    &gt;&gt;&gt; ax.grid(True) 
 
    The second figure shows graphs for `lmbda` &gt; 0.  The dots in the 
    graphs show the bounds of the support of the distribution. 
 
    &gt;&gt;&gt; fig, ax = plt.subplots() 
    &gt;&gt;&gt; x = np.linspace(-4.2, 4.2, 500) 
    &gt;&gt;&gt; lmbdas = [0.25, 0.5, 1.0, 1.5] 
    &gt;&gt;&gt; for k, lmbda in enumerate(lmbdas): 
    ...     y = tklmbda(x, lmbda) 
    ...     ax.plot(x, y, styles[k], label=fr'$\lambda$ = {lmbda}') 
 
    &gt;&gt;&gt; ax.set_prop_cycle(None) 
    &gt;&gt;&gt; for lmbda in lmbdas: 
    ...     ax.plot([-1/lmbda, 1/lmbda], [0, 1], '.', ms=8) 
 
    &gt;&gt;&gt; ax.set_title(r'tklmbda(x, $\lambda$)') 
    &gt;&gt;&gt; ax.set_xlabel('x') 
    &gt;&gt;&gt; ax.legend(framealpha=1, shadow=True) 
    &gt;&gt;&gt; ax.grid(True) 
 
    &gt;&gt;&gt; plt.tight_layout() 
    &gt;&gt;&gt; plt.show() 
 
    The CDF of the Tukey lambda distribution is also implemented as the 
    ``cdf`` method of `scipy.stats.tukeylambda`.  In the following, 
    ``tukeylambda.cdf(x, -0.5)`` and ``tklmbda(x, -0.5)`` compute the 
    same values: 
 
    &gt;&gt;&gt; from scipy.stats import tukeylambda 
    &gt;&gt;&gt; x = np.linspace(-2, 2, 9) 
 
    &gt;&gt;&gt; tukeylambda.cdf(x, -0.5) 
    array([0.21995157, 0.27093858, 0.33541677, 0.41328161, 0.5       , 
           0.58671839, 0.66458323, 0.72906142, 0.78004843]) 
 
    &gt;&gt;&gt; tklmbda(x, -0.5) 
    array([0.21995157, 0.27093858, 0.33541677, 0.41328161, 0.5       , 
           0.58671839, 0.66458323, 0.72906142, 0.78004843]) 
 
    The implementation in ``tukeylambda`` also provides location and scale 
    parameters, and other methods such as ``pdf()`` (the probability 
    density function) and ``ppf()`` (the inverse of the CDF), so for 
    working with the Tukey lambda distribution, ``tukeylambda`` is more 
    generally useful.  The primary advantage of ``tklmbda`` is that it is 
    significantly faster than ``tukeylambda.cdf``. 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;wofz&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    wofz(z, out=None) 
 
    Faddeeva function 
 
    Returns the value of the Faddeeva function for complex argument:: 
 
        exp(-z**2) * erfc(-i*z) 
 
    Parameters 
    ---------- 
    z : array_like 
        complex argument 
    out : ndarray, optional 
        Optional output array for the function results 
 
    Returns 
    ------- 
    scalar or ndarray 
        Value of the Faddeeva function 
 
    See Also 
    -------- 
    dawsn, erf, erfc, erfcx, erfi 
 
    References 
    ---------- 
    .. [1] Steven G. Johnson, Faddeeva W function implementation. 
       http://ab-initio.mit.edu/Faddeeva 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import special 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
 
    &gt;&gt;&gt; x = np.linspace(-3, 3) 
    &gt;&gt;&gt; z = special.wofz(x) 
 
    &gt;&gt;&gt; plt.plot(x, z.real, label='wofz(x).real') 
    &gt;&gt;&gt; plt.plot(x, z.imag, label='wofz(x).imag') 
    &gt;&gt;&gt; plt.xlabel('$x$') 
    &gt;&gt;&gt; plt.legend(framealpha=1, shadow=True) 
    &gt;&gt;&gt; plt.grid(alpha=0.25) 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;xlogy&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    xlogy(x, y, out=None) 
 
    Compute ``x*log(y)`` so that the result is 0 if ``x = 0``. 
 
    Parameters 
    ---------- 
    x : array_like 
        Multiplier 
    y : array_like 
        Argument 
    out : ndarray, optional 
        Optional output array for the function results 
 
    Returns 
    ------- 
    z : scalar or ndarray 
        Computed x*log(y) 
 
    Notes 
    ----- 
    The log function used in the computation is the natural log. 
 
    .. versionadded:: 0.13.0 
 
    Examples 
    -------- 
    We can use this function to calculate the binary logistic loss also 
    known as the binary cross entropy. This loss function is used for 
    binary classification problems and is defined as: 
 
    .. math:: 
        L = 1/n * </span><span class="s3">\\</span><span class="s4">sum_{i=0}^n -(y_i*log(y</span><span class="s3">\\</span><span class="s4">_pred_i) + (1-y_i)*log(1-y</span><span class="s3">\\</span><span class="s4">_pred_i)) 
 
    We can define the parameters `x` and `y` as y and y_pred respectively. 
    y is the array of the actual labels which over here can be either 0 or 1. 
    y_pred is the array of the predicted probabilities with respect to 
    the positive class (1). 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.special import xlogy 
    &gt;&gt;&gt; y = np.array([0, 1, 0, 1, 1, 0]) 
    &gt;&gt;&gt; y_pred = np.array([0.3, 0.8, 0.4, 0.7, 0.9, 0.2]) 
    &gt;&gt;&gt; n = len(y) 
    &gt;&gt;&gt; loss = -(xlogy(y, y_pred) + xlogy(1 - y, 1 - y_pred)).sum() 
    &gt;&gt;&gt; loss /= n 
    &gt;&gt;&gt; loss 
    0.29597052165495025 
 
    A lower loss is usually better as it indicates that the predictions are 
    similar to the actual labels. In this example since our predicted 
    probabilities are close to the actual labels, we get an overall loss 
    that is reasonably low and appropriate. 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;xlog1py&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    xlog1py(x, y, out=None) 
 
    Compute ``x*log1p(y)`` so that the result is 0 if ``x = 0``. 
 
    Parameters 
    ---------- 
    x : array_like 
        Multiplier 
    y : array_like 
        Argument 
    out : ndarray, optional 
        Optional output array for the function results 
 
    Returns 
    ------- 
    z : scalar or ndarray 
        Computed x*log1p(y) 
 
    Notes 
    ----- 
 
    .. versionadded:: 0.13.0 
 
    Examples 
    -------- 
    This example shows how the function can be used to calculate the log of 
    the probability mass function for a geometric discrete random variable. 
    The probability mass function of the geometric distribution is defined 
    as follows: 
 
    .. math:: f(k) = (1-p)^{k-1} p 
 
    where :math:`p` is the probability of a single success 
    and :math:`1-p` is the probability of a single failure 
    and :math:`k` is the number of trials to get the first success. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.special import xlog1py 
    &gt;&gt;&gt; p = 0.5 
    &gt;&gt;&gt; k = 100 
    &gt;&gt;&gt; _pmf = np.power(1 - p, k - 1) * p 
    &gt;&gt;&gt; _pmf 
    7.888609052210118e-31 
 
    If we take k as a relatively large number the value of the probability 
    mass function can become very low. In such cases taking the log of the 
    pmf would be more suitable as the log function can change the values 
    to a scale that is more appropriate to work with. 
 
    &gt;&gt;&gt; _log_pmf = xlog1py(k - 1, -p) + np.log(p) 
    &gt;&gt;&gt; _log_pmf 
    -69.31471805599453 
 
    We can confirm that we get a value close to the original pmf value by 
    taking the exponential of the log pmf. 
 
    &gt;&gt;&gt; _orig_pmf = np.exp(_log_pmf) 
    &gt;&gt;&gt; np.isclose(_pmf, _orig_pmf) 
    True 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;y0&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    y0(x, out=None) 
 
    Bessel function of the second kind of order 0. 
 
    Parameters 
    ---------- 
    x : array_like 
        Argument (float). 
    out : ndarray, optional 
        Optional output array for the function results 
 
    Returns 
    ------- 
    Y : scalar or ndarray 
        Value of the Bessel function of the second kind of order 0 at `x`. 
 
    See Also 
    -------- 
    j0: Bessel function of the first kind of order 0 
    yv: Bessel function of the first kind 
 
    Notes 
    ----- 
    The domain is divided into the intervals [0, 5] and (5, infinity). In the 
    first interval a rational approximation :math:`R(x)` is employed to 
    compute, 
 
    .. math:: 
 
        Y_0(x) = R(x) + \frac{2 \log(x) J_0(x)}{\pi}, 
 
    where :math:`J_0` is the Bessel function of the first kind of order 0. 
 
    In the second interval, the Hankel asymptotic expansion is employed with 
    two rational functions of degree 6/6 and 7/7. 
 
    This function is a wrapper for the Cephes [1]_ routine `y0`. 
 
    References 
    ---------- 
    .. [1] Cephes Mathematical Functions Library, 
           http://www.netlib.org/cephes/ 
 
    Examples 
    -------- 
    Calculate the function at one point: 
 
    &gt;&gt;&gt; from scipy.special import y0 
    &gt;&gt;&gt; y0(1.) 
    0.08825696421567697 
 
    Calculate at several points: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; y0(np.array([0.5, 2., 3.])) 
    array([-0.44451873,  0.51037567,  0.37685001]) 
 
    Plot the function from 0 to 10. 
 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; fig, ax = plt.subplots() 
    &gt;&gt;&gt; x = np.linspace(0., 10., 1000) 
    &gt;&gt;&gt; y = y0(x) 
    &gt;&gt;&gt; ax.plot(x, y) 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;y1&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    y1(x, out=None) 
 
    Bessel function of the second kind of order 1. 
 
    Parameters 
    ---------- 
    x : array_like 
        Argument (float). 
    out : ndarray, optional 
        Optional output array for the function results 
 
    Returns 
    ------- 
    Y : scalar or ndarray 
        Value of the Bessel function of the second kind of order 1 at `x`. 
 
    See Also 
    -------- 
    j1: Bessel function of the first kind of order 1 
    yn: Bessel function of the second kind 
    yv: Bessel function of the second kind 
 
    Notes 
    ----- 
    The domain is divided into the intervals [0, 8] and (8, infinity). In the 
    first interval a 25 term Chebyshev expansion is used, and computing 
    :math:`J_1` (the Bessel function of the first kind) is required. In the 
    second, the asymptotic trigonometric representation is employed using two 
    rational functions of degree 5/5. 
 
    This function is a wrapper for the Cephes [1]_ routine `y1`. 
 
    References 
    ---------- 
    .. [1] Cephes Mathematical Functions Library, 
           http://www.netlib.org/cephes/ 
 
    Examples 
    -------- 
    Calculate the function at one point: 
 
    &gt;&gt;&gt; from scipy.special import y1 
    &gt;&gt;&gt; y1(1.) 
    -0.7812128213002888 
 
    Calculate at several points: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; y1(np.array([0.5, 2., 3.])) 
    array([-1.47147239, -0.10703243,  0.32467442]) 
 
    Plot the function from 0 to 10. 
 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; fig, ax = plt.subplots() 
    &gt;&gt;&gt; x = np.linspace(0., 10., 1000) 
    &gt;&gt;&gt; y = y1(x) 
    &gt;&gt;&gt; ax.plot(x, y) 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;yn&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    yn(n, x, out=None) 
 
    Bessel function of the second kind of integer order and real argument. 
 
    Parameters 
    ---------- 
    n : array_like 
        Order (integer). 
    x : array_like 
        Argument (float). 
    out : ndarray, optional 
        Optional output array for the function results 
 
    Returns 
    ------- 
    Y : scalar or ndarray 
        Value of the Bessel function, :math:`Y_n(x)`. 
 
    See Also 
    -------- 
    yv : For real order and real or complex argument. 
    y0: faster implementation of this function for order 0 
    y1: faster implementation of this function for order 1 
 
    Notes 
    ----- 
    Wrapper for the Cephes [1]_ routine `yn`. 
 
    The function is evaluated by forward recurrence on `n`, starting with 
    values computed by the Cephes routines `y0` and `y1`. If `n = 0` or 1, 
    the routine for `y0` or `y1` is called directly. 
 
    References 
    ---------- 
    .. [1] Cephes Mathematical Functions Library, 
           http://www.netlib.org/cephes/ 
 
    Examples 
    -------- 
    Evaluate the function of order 0 at one point. 
 
    &gt;&gt;&gt; from scipy.special import yn 
    &gt;&gt;&gt; yn(0, 1.) 
    0.08825696421567697 
 
    Evaluate the function at one point for different orders. 
 
    &gt;&gt;&gt; yn(0, 1.), yn(1, 1.), yn(2, 1.) 
    (0.08825696421567697, -0.7812128213002888, -1.6506826068162546) 
 
    The evaluation for different orders can be carried out in one call by 
    providing a list or NumPy array as argument for the `v` parameter: 
 
    &gt;&gt;&gt; yn([0, 1, 2], 1.) 
    array([ 0.08825696, -0.78121282, -1.65068261]) 
 
    Evaluate the function at several points for order 0 by providing an 
    array for `z`. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; points = np.array([0.5, 3., 8.]) 
    &gt;&gt;&gt; yn(0, points) 
    array([-0.44451873,  0.37685001,  0.22352149]) 
 
    If `z` is an array, the order parameter `v` must be broadcastable to 
    the correct shape if different orders shall be computed in one call. 
    To calculate the orders 0 and 1 for an 1D array: 
 
    &gt;&gt;&gt; orders = np.array([[0], [1]]) 
    &gt;&gt;&gt; orders.shape 
    (2, 1) 
 
    &gt;&gt;&gt; yn(orders, points) 
    array([[-0.44451873,  0.37685001,  0.22352149], 
           [-1.47147239,  0.32467442, -0.15806046]]) 
 
    Plot the functions of order 0 to 3 from 0 to 10. 
 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; fig, ax = plt.subplots() 
    &gt;&gt;&gt; x = np.linspace(0., 10., 1000) 
    &gt;&gt;&gt; for i in range(4): 
    ...     ax.plot(x, yn(i, x), label=f'$Y_{i!r}$') 
    &gt;&gt;&gt; ax.set_ylim(-3, 1) 
    &gt;&gt;&gt; ax.legend() 
    &gt;&gt;&gt; plt.show() 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;yv&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    yv(v, z, out=None) 
 
    Bessel function of the second kind of real order and complex argument. 
 
    Parameters 
    ---------- 
    v : array_like 
        Order (float). 
    z : array_like 
        Argument (float or complex). 
    out : ndarray, optional 
        Optional output array for the function results 
 
    Returns 
    ------- 
    Y : scalar or ndarray 
        Value of the Bessel function of the second kind, :math:`Y_v(x)`. 
 
    See Also 
    -------- 
    yve : :math:`Y_v` with leading exponential behavior stripped off. 
    y0: faster implementation of this function for order 0 
    y1: faster implementation of this function for order 1 
 
    Notes 
    ----- 
    For positive `v` values, the computation is carried out using the 
    AMOS [1]_ `zbesy` routine, which exploits the connection to the Hankel 
    Bessel functions :math:`H_v^{(1)}` and :math:`H_v^{(2)}`, 
 
    .. math:: Y_v(z) = \frac{1}{2\imath} (H_v^{(1)} - H_v^{(2)}). 
 
    For negative `v` values the formula, 
 
    .. math:: Y_{-v}(z) = Y_v(z) \cos(\pi v) + J_v(z) \sin(\pi v) 
 
    is used, where :math:`J_v(z)` is the Bessel function of the first kind, 
    computed using the AMOS routine `zbesj`.  Note that the second term is 
    exactly zero for integer `v`; to improve accuracy the second term is 
    explicitly omitted for `v` values such that `v = floor(v)`. 
 
    References 
    ---------- 
    .. [1] Donald E. Amos, &quot;AMOS, A Portable Package for Bessel Functions 
           of a Complex Argument and Nonnegative Order&quot;, 
           http://netlib.org/amos/ 
 
    Examples 
    -------- 
    Evaluate the function of order 0 at one point. 
 
    &gt;&gt;&gt; from scipy.special import yv 
    &gt;&gt;&gt; yv(0, 1.) 
    0.088256964215677 
 
    Evaluate the function at one point for different orders. 
 
    &gt;&gt;&gt; yv(0, 1.), yv(1, 1.), yv(1.5, 1.) 
    (0.088256964215677, -0.7812128213002889, -1.102495575160179) 
 
    The evaluation for different orders can be carried out in one call by 
    providing a list or NumPy array as argument for the `v` parameter: 
 
    &gt;&gt;&gt; yv([0, 1, 1.5], 1.) 
    array([ 0.08825696, -0.78121282, -1.10249558]) 
 
    Evaluate the function at several points for order 0 by providing an 
    array for `z`. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; points = np.array([0.5, 3., 8.]) 
    &gt;&gt;&gt; yv(0, points) 
    array([-0.44451873,  0.37685001,  0.22352149]) 
 
    If `z` is an array, the order parameter `v` must be broadcastable to 
    the correct shape if different orders shall be computed in one call. 
    To calculate the orders 0 and 1 for an 1D array: 
 
    &gt;&gt;&gt; orders = np.array([[0], [1]]) 
    &gt;&gt;&gt; orders.shape 
    (2, 1) 
 
    &gt;&gt;&gt; yv(orders, points) 
    array([[-0.44451873,  0.37685001,  0.22352149], 
           [-1.47147239,  0.32467442, -0.15806046]]) 
 
    Plot the functions of order 0 to 3 from 0 to 10. 
 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; fig, ax = plt.subplots() 
    &gt;&gt;&gt; x = np.linspace(0., 10., 1000) 
    &gt;&gt;&gt; for i in range(4): 
    ...     ax.plot(x, yv(i, x), label=f'$Y_{i!r}$') 
    &gt;&gt;&gt; ax.set_ylim(-3, 1) 
    &gt;&gt;&gt; ax.legend() 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;yve&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    yve(v, z, out=None) 
 
    Exponentially scaled Bessel function of the second kind of real order. 
 
    Returns the exponentially scaled Bessel function of the second 
    kind of real order `v` at complex `z`:: 
 
        yve(v, z) = yv(v, z) * exp(-abs(z.imag)) 
 
    Parameters 
    ---------- 
    v : array_like 
        Order (float). 
    z : array_like 
        Argument (float or complex). 
    out : ndarray, optional 
        Optional output array for the function results 
 
    Returns 
    ------- 
    Y : scalar or ndarray 
        Value of the exponentially scaled Bessel function. 
 
    See Also 
    -------- 
    yv: Unscaled Bessel function of the second kind of real order. 
 
    Notes 
    ----- 
    For positive `v` values, the computation is carried out using the 
    AMOS [1]_ `zbesy` routine, which exploits the connection to the Hankel 
    Bessel functions :math:`H_v^{(1)}` and :math:`H_v^{(2)}`, 
 
    .. math:: Y_v(z) = \frac{1}{2\imath} (H_v^{(1)} - H_v^{(2)}). 
 
    For negative `v` values the formula, 
 
    .. math:: Y_{-v}(z) = Y_v(z) \cos(\pi v) + J_v(z) \sin(\pi v) 
 
    is used, where :math:`J_v(z)` is the Bessel function of the first kind, 
    computed using the AMOS routine `zbesj`.  Note that the second term is 
    exactly zero for integer `v`; to improve accuracy the second term is 
    explicitly omitted for `v` values such that `v = floor(v)`. 
 
    Exponentially scaled Bessel functions are useful for large `z`: 
    for these, the unscaled Bessel functions can easily under-or overflow. 
 
    References 
    ---------- 
    .. [1] Donald E. Amos, &quot;AMOS, A Portable Package for Bessel Functions 
           of a Complex Argument and Nonnegative Order&quot;, 
           http://netlib.org/amos/ 
 
    Examples 
    -------- 
    Compare the output of `yv` and `yve` for large complex arguments for `z` 
    by computing their values for order ``v=1`` at ``z=1000j``. We see that 
    `yv` returns nan but `yve` returns a finite number: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.special import yv, yve 
    &gt;&gt;&gt; v = 1 
    &gt;&gt;&gt; z = 1000j 
    &gt;&gt;&gt; yv(v, z), yve(v, z) 
    ((nan+nanj), (-0.012610930256928629+7.721967686709076e-19j)) 
 
    For real arguments for `z`, `yve` returns the same as `yv` up to 
    floating point errors. 
 
    &gt;&gt;&gt; v, z = 1, 1000 
    &gt;&gt;&gt; yv(v, z), yve(v, z) 
    (-0.02478433129235178, -0.02478433129235179) 
 
    The function can be evaluated for several orders at the same time by 
    providing a list or NumPy array for `v`: 
 
    &gt;&gt;&gt; yve([1, 2, 3], 1j) 
    array([-0.20791042+0.14096627j,  0.38053618-0.04993878j, 
           0.00815531-1.66311097j]) 
 
    In the same way, the function can be evaluated at several points in one 
    call by providing a list or NumPy array for `z`: 
 
    &gt;&gt;&gt; yve(1, np.array([1j, 2j, 3j])) 
    array([-0.20791042+0.14096627j, -0.21526929+0.01205044j, 
           -0.19682671+0.00127278j]) 
 
    It is also possible to evaluate several orders at several points 
    at the same time by providing arrays for `v` and `z` with 
    broadcasting compatible shapes. Compute `yve` for two different orders 
    `v` and three points `z` resulting in a 2x3 array. 
 
    &gt;&gt;&gt; v = np.array([[1], [2]]) 
    &gt;&gt;&gt; z = np.array([3j, 4j, 5j]) 
    &gt;&gt;&gt; v.shape, z.shape 
    ((2, 1), (3,)) 
 
    &gt;&gt;&gt; yve(v, z) 
    array([[-1.96826713e-01+1.27277544e-03j, -1.78750840e-01+1.45558819e-04j, 
            -1.63972267e-01+1.73494110e-05j], 
           [1.94960056e-03-1.11782545e-01j,  2.02902325e-04-1.17626501e-01j, 
            2.27727687e-05-1.17951906e-01j]]) 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;zetac&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    zetac(x, out=None) 
 
    Riemann zeta function minus 1. 
 
    This function is defined as 
 
    .. math:: </span><span class="s3">\\</span><span class="s4">zeta(x) = </span><span class="s3">\\</span><span class="s4">sum_{k=2}^{</span><span class="s3">\\</span><span class="s4">infty} 1 / k^x, 
 
    where ``x &gt; 1``.  For ``x &lt; 1`` the analytic continuation is 
    computed. For more information on the Riemann zeta function, see 
    [dlmf]_. 
 
    Parameters 
    ---------- 
    x : array_like of float 
        Values at which to compute zeta(x) - 1 (must be real). 
    out : ndarray, optional 
        Optional output array for the function results 
 
    Returns 
    ------- 
    scalar or ndarray 
        Values of zeta(x) - 1. 
 
    See Also 
    -------- 
    zeta 
 
    References 
    ---------- 
    .. [dlmf] NIST Digital Library of Mathematical Functions 
              https://dlmf.nist.gov/25 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.special import zetac, zeta 
 
    Some special values: 
 
    &gt;&gt;&gt; zetac(2), np.pi**2/6 - 1 
    (0.64493406684822641, 0.6449340668482264) 
 
    &gt;&gt;&gt; zetac(-1), -1.0/12 - 1 
    (-1.0833333333333333, -1.0833333333333333) 
 
    Compare ``zetac(x)`` to ``zeta(x) - 1`` for large `x`: 
 
    &gt;&gt;&gt; zetac(60), zeta(60) - 1 
    (8.673617380119933e-19, 0.0) 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;_riemann_zeta&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    Internal function, use `zeta` instead. 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;_struve_asymp_large_z&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    _struve_asymp_large_z(v, z, is_h) 
 
    Internal function for testing `struve` &amp; `modstruve` 
 
    Evaluates using asymptotic expansion 
 
    Returns 
    ------- 
    v, err 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;_struve_power_series&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    _struve_power_series(v, z, is_h) 
 
    Internal function for testing `struve` &amp; `modstruve` 
 
    Evaluates using power series 
 
    Returns 
    ------- 
    v, err 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;_struve_bessel_series&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    _struve_bessel_series(v, z, is_h) 
 
    Internal function for testing `struve` &amp; `modstruve` 
 
    Evaluates using Bessel function series 
 
    Returns 
    ------- 
    v, err 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;_spherical_jn&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    Internal function, use `spherical_jn` instead. 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;_spherical_jn_d&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    Internal function, use `spherical_jn` instead. 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;_spherical_yn&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    Internal function, use `spherical_yn` instead. 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;_spherical_yn_d&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    Internal function, use `spherical_yn` instead. 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;_spherical_in&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    Internal function, use `spherical_in` instead. 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;_spherical_in_d&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    Internal function, use `spherical_in` instead. 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;_spherical_kn&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    Internal function, use `spherical_kn` instead. 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;_spherical_kn_d&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    Internal function, use `spherical_kn` instead. 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;owens_t&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    owens_t(h, a, out=None) 
 
    Owen's T Function. 
 
    The function T(h, a) gives the probability of the event 
    (X &gt; h and 0 &lt; Y &lt; a * X) where X and Y are independent 
    standard normal random variables. 
 
    Parameters 
    ---------- 
    h: array_like 
        Input value. 
    a: array_like 
        Input value. 
    out : ndarray, optional 
        Optional output array for the function results 
 
    Returns 
    ------- 
    t: scalar or ndarray 
        Probability of the event (X &gt; h and 0 &lt; Y &lt; a * X), 
        where X and Y are independent standard normal random variables. 
 
    References 
    ---------- 
    .. [1] M. Patefield and D. Tandy, &quot;Fast and accurate calculation of 
           Owen's T Function&quot;, Statistical Software vol. 5, pp. 1-25, 2000. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy import special 
    &gt;&gt;&gt; a = 3.5 
    &gt;&gt;&gt; h = 0.78 
    &gt;&gt;&gt; special.owens_t(h, a) 
    0.10877216734852274 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;_factorial&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    Internal function, do not use. 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;ndtri_exp&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    ndtri_exp(y, out=None) 
 
    Inverse of `log_ndtr` vs x. Allows for greater precision than 
    `ndtri` composed with `numpy.exp` for very small values of y and for 
    y close to 0. 
 
    Parameters 
    ---------- 
    y : array_like of float 
        Function argument 
    out : ndarray, optional 
        Optional output array for the function results 
 
    Returns 
    ------- 
    scalar or ndarray 
        Inverse of the log CDF of the standard normal distribution, evaluated 
        at y. 
 
    See Also 
    -------- 
    log_ndtr : log of the standard normal cumulative distribution function 
    ndtr : standard normal cumulative distribution function 
    ndtri : standard normal percentile function 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; import scipy.special as sc 
 
    `ndtri_exp` agrees with the naive implementation when the latter does 
    not suffer from underflow. 
 
    &gt;&gt;&gt; sc.ndtri_exp(-1) 
    -0.33747496376420244 
    &gt;&gt;&gt; sc.ndtri(np.exp(-1)) 
    -0.33747496376420244 
 
    For extreme values of y, the naive approach fails 
 
    &gt;&gt;&gt; sc.ndtri(np.exp(-800)) 
    -inf 
    &gt;&gt;&gt; sc.ndtri(np.exp(-1e-20)) 
    inf 
 
    whereas `ndtri_exp` is still able to compute the result to high precision. 
 
    &gt;&gt;&gt; sc.ndtri_exp(-800) 
    -39.88469483825668 
    &gt;&gt;&gt; sc.ndtri_exp(-1e-20) 
    9.262340089798409 
    &quot;&quot;&quot;</span><span class="s2">)</span>


<span class="s1">add_newdoc</span><span class="s2">(</span><span class="s4">&quot;_stirling2_inexact&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    Internal function, do not use. 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span>
    <span class="s4">&quot;_beta_pdf&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    _beta_pdf(x, a, b) 
 
    Probability density function of beta distribution. 
 
    Parameters 
    ---------- 
    x : array_like 
        Real-valued such that :math:`0 \leq x \leq 1`, 
        the upper limit of integration 
    a, b : array_like 
           Positive, real-valued parameters 
 
    Returns 
    ------- 
    scalar or ndarray 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span>
    <span class="s4">&quot;_beta_ppf&quot;</span><span class="s2">,</span>
    <span class="s4">r&quot;&quot;&quot; 
    _beta_ppf(x, a, b) 
 
    Percent point function of beta distribution. 
 
    Parameters 
    ---------- 
    x : array_like 
        Real-valued such that :math:`0 \leq x \leq 1`, 
        the upper limit of integration 
    a, b : array_like 
           Positive, real-valued parameters 
 
    Returns 
    ------- 
    scalar or ndarray 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span>
    <span class="s4">&quot;_invgauss_ppf&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    _invgauss_ppf(x, mu) 
 
    Percent point function of inverse gaussian distribution. 
 
    Parameters 
    ---------- 
    x : array_like 
        Positive real-valued 
    mu : array_like 
        Positive, real-valued parameters 
 
    Returns 
    ------- 
    scalar or ndarray 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span>
    <span class="s4">&quot;_invgauss_isf&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    _invgauss_isf(x, mu, s) 
 
    Inverse survival function of inverse gaussian distribution. 
 
    Parameters 
    ---------- 
    x : array_like 
        Positive real-valued 
    mu : array_like 
        Positive, real-valued parameters 
    s : array_like 
        Positive, real-valued parameters 
 
    Returns 
    ------- 
    scalar or ndarray 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span>
    <span class="s4">&quot;_ncx2_pdf&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    _ncx2_pdf(x, k, l) 
 
    Probability density function of Non-central chi-squared distribution. 
 
    Parameters 
    ---------- 
    x : array_like 
        Positive real-valued 
    k, l : array_like 
        Positive, real-valued parameters 
 
    Returns 
    ------- 
    scalar or ndarray 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span>
    <span class="s4">&quot;_ncx2_cdf&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    _ncx2_cdf(x, k, l) 
 
    Cumulative density function of Non-central chi-squared distribution. 
 
    Parameters 
    ---------- 
    x : array_like 
        Positive real-valued 
    k, l : array_like 
        Positive, real-valued parameters 
 
    Returns 
    ------- 
    scalar or ndarray 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span>
    <span class="s4">&quot;_ncx2_ppf&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    _ncx2_ppf(x, k, l) 
 
    Percent point function of Non-central chi-squared distribution. 
 
    Parameters 
    ---------- 
    x : array_like 
        Positive real-valued 
    k, l : array_like 
        Positive, real-valued parameters 
 
    Returns 
    ------- 
    scalar or ndarray 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span>
    <span class="s4">&quot;_ncx2_sf&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    _ncx2_sf(x, k, l) 
 
    Survival function of Non-central chi-squared distribution. 
 
    Parameters 
    ---------- 
    x : array_like 
        Positive real-valued 
    k, l : array_like 
        Positive, real-valued parameters 
 
    Returns 
    ------- 
    scalar or ndarray 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span>
    <span class="s4">&quot;_ncx2_isf&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    _ncx2_isf(x, k, l) 
 
    Inverse survival function of Non-central chi-squared distribution. 
 
    Parameters 
    ---------- 
    x : array_like 
        Positive real-valued 
    k, l : array_like 
        Positive, real-valued parameters 
 
    Returns 
    ------- 
    scalar or ndarray 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span>
    <span class="s4">&quot;_ncf_pdf&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    _ncf_pdf(x, v1, v2, l) 
 
    Probability density function of noncentral F-distribution. 
 
    Parameters 
    ---------- 
    x : array_like 
        Positive real-valued 
    v1, v2, l : array_like 
        Positive, real-valued parameters 
 
    Returns 
    ------- 
    scalar or ndarray 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span>
    <span class="s4">&quot;_ncf_cdf&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    _ncf_cdf(x, v1, v2, l) 
 
    Cumulative density function of noncentral F-distribution. 
 
    Parameters 
    ---------- 
    x : array_like 
        Positive real-valued 
    v1, v2, l : array_like 
        Positive, real-valued parameters 
 
    Returns 
    ------- 
    scalar or ndarray 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span>
    <span class="s4">&quot;_ncf_ppf&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    _ncf_ppf(x, v1, v2, l) 
 
    Percent point function of noncentral F-distribution. 
 
    Parameters 
    ---------- 
    x : array_like 
        Positive real-valued 
    v1, v2, l : array_like 
        Positive, real-valued parameters 
 
    Returns 
    ------- 
    scalar or ndarray 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span>
    <span class="s4">&quot;_ncf_sf&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    _ncf_sf(x, v1, v2, l) 
 
    Survival function of noncentral F-distribution. 
 
    Parameters 
    ---------- 
    x : array_like 
        Positive real-valued 
    v1, v2, l : array_like 
        Positive, real-valued parameters 
 
    Returns 
    ------- 
    scalar or ndarray 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span>
    <span class="s4">&quot;_ncf_isf&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    _ncf_isf(x, v1, v2, l) 
 
    Inverse surivial function of noncentral F-distribution. 
 
    Parameters 
    ---------- 
    x : array_like 
        Positive real-valued 
    v1, v2, l : array_like 
        Positive, real-valued parameters 
 
    Returns 
    ------- 
    scalar or ndarray 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span>
    <span class="s4">&quot;_ncf_mean&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    _ncf_mean(v1, v2, l) 
 
    Mean of noncentral F-distribution. 
 
    Parameters 
    ---------- 
    v1, v2, l : array_like 
        Positive, real-valued parameters 
 
    Returns 
    ------- 
    scalar or ndarray 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span>
    <span class="s4">&quot;_ncf_variance&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    _ncf_variance(v1, v2, l) 
 
    Variance of noncentral F-distribution. 
 
    Parameters 
    ---------- 
    v1, v2, l : array_like 
        Positive, real-valued parameters 
 
    Returns 
    ------- 
    scalar or ndarray 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span>
    <span class="s4">&quot;_ncf_skewness&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    _ncf_skewness(v1, v2, l) 
 
    Skewness of noncentral F-distribution. 
 
    Parameters 
    ---------- 
    v1, v2, l : array_like 
        Positive, real-valued parameters 
 
    Returns 
    ------- 
    scalar or ndarray 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span>
    <span class="s4">&quot;_ncf_kurtosis_excess&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    _ncf_kurtosis_excess(v1, v2, l) 
 
    Kurtosis excess of noncentral F-distribution. 
 
    Parameters 
    ---------- 
    v1, v2, l : array_like 
        Positive, real-valued parameters 
 
    Returns 
    ------- 
    scalar or ndarray 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span>
    <span class="s4">&quot;_nct_cdf&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    _nct_cdf(x, v, l) 
 
    Cumulative density function of noncentral t-distribution. 
 
    Parameters 
    ---------- 
    x : array_like 
        Real-valued 
    v : array_like 
        Positive, real-valued parameters 
    l : array_like 
        Real-valued parameters 
 
    Returns 
    ------- 
    scalar or ndarray 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span>
    <span class="s4">&quot;_nct_ppf&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    _nct_ppf(x, v, l) 
 
    Percent point function of noncentral t-distribution. 
 
    Parameters 
    ---------- 
    x : array_like 
        Real-valued 
    v : array_like 
        Positive, real-valued parameters 
    l : array_like 
        Real-valued parameters 
 
    Returns 
    ------- 
    scalar or ndarray 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span>
    <span class="s4">&quot;_nct_sf&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    _nct_sf(x, v, l) 
 
    Survival function of noncentral t-distribution. 
 
    Parameters 
    ---------- 
    x : array_like 
        Real-valued 
    v : array_like 
        Positive, real-valued parameters 
    l : array_like 
        Real-valued parameters 
 
    Returns 
    ------- 
    scalar or ndarray 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span>
    <span class="s4">&quot;_nct_isf&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    _nct_isf(x, v, l) 
 
    Inverse surivial function of noncentral t-distribution. 
 
    Parameters 
    ---------- 
    x : array_like 
        Real-valued 
    v : array_like 
        Positive, real-valued parameters 
    l : array_like 
        Real-valued parameters 
 
    Returns 
    ------- 
    scalar or ndarray 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span>
    <span class="s4">&quot;_nct_mean&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    _nct_mean(v, l) 
 
    Mean of noncentral t-distribution. 
 
    Parameters 
    ---------- 
    v : array_like 
        Positive, real-valued parameters 
    l : array_like 
        Real-valued parameters 
 
    Returns 
    ------- 
    scalar or ndarray 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span>
    <span class="s4">&quot;_nct_variance&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    _nct_variance(v, l) 
 
    Variance of noncentral t-distribution. 
 
    Parameters 
    ---------- 
    v : array_like 
        Positive, real-valued parameters 
    l : array_like 
        Real-valued parameters 
 
    Returns 
    ------- 
    scalar or ndarray 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span>
    <span class="s4">&quot;_nct_skewness&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    _nct_skewness(v, l) 
 
    Skewness of noncentral t-distribution. 
 
    Parameters 
    ---------- 
    v : array_like 
        Positive, real-valued parameters 
    l : array_like 
        Real-valued parameters 
 
    Returns 
    ------- 
    scalar or ndarray 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span>
    <span class="s4">&quot;_nct_kurtosis_excess&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    _nct_kurtosis_excess(v, l) 
 
    Kurtosis excess of noncentral t-distribution. 
 
    Parameters 
    ---------- 
    v : array_like 
        Positive, real-valued parameters 
    l : array_like 
        Real-valued parameters 
 
    Returns 
    ------- 
    scalar or ndarray 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span>
    <span class="s4">&quot;_skewnorm_cdf&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    _skewnorm_cdf(x, l, sc, sh) 
 
    Cumulative density function of skewnorm distribution. 
 
    Parameters 
    ---------- 
    x : array_like 
        Real-valued 
    l : array_like 
        Real-valued parameters 
    sc : array_like 
        Positive, Real-valued parameters 
    sh : array_like 
        Real-valued parameters 
 
    Returns 
    ------- 
    scalar or ndarray 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span>
    <span class="s4">&quot;_skewnorm_ppf&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    _skewnorm_ppf(x, l, sc, sh) 
 
    Percent point function of skewnorm distribution. 
 
    Parameters 
    ---------- 
    x : array_like 
        Real-valued 
    l : array_like 
        Real-valued parameters 
    sc : array_like 
        Positive, Real-valued parameters 
    sh : array_like 
        Real-valued parameters 
 
    Returns 
    ------- 
    scalar or ndarray 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span>
    <span class="s4">&quot;_skewnorm_isf&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    _skewnorm_isf(x, l, sc, sh) 
 
    Inverse surivial function of skewnorm distribution. 
 
    Parameters 
    ---------- 
    x : array_like 
        Real-valued 
    l : array_like 
        Real-valued parameters 
    sc : array_like 
        Positive, Real-valued parameters 
    sh : array_like 
        Real-valued parameters 
 
    Returns 
    ------- 
    scalar or ndarray 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span>
    <span class="s4">&quot;_binom_pmf&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    _binom_pmf(x, n, p) 
 
    Probability mass function of binomial distribution. 
 
    Parameters 
    ---------- 
    x : array_like 
        Real-valued 
    n : array_like 
        Positive, integer-valued parameter 
    p : array_like 
        Positive, real-valued parameter 
 
    Returns 
    ------- 
    scalar or ndarray 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span>
    <span class="s4">&quot;_binom_cdf&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    _binom_cdf(x, n, p) 
 
    Cumulative density function of binomial distribution. 
 
    Parameters 
    ---------- 
    x : array_like 
        Real-valued 
    n : array_like 
        Positive, integer-valued parameter 
    p : array_like 
        Positive, real-valued parameter 
 
    Returns 
    ------- 
    scalar or ndarray 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span>
    <span class="s4">&quot;_binom_ppf&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    _binom_ppf(x, n, p) 
 
    Percent point function of binomial distribution. 
 
    Parameters 
    ---------- 
    x : array_like 
        Real-valued 
    n : array_like 
        Positive, integer-valued parameter 
    p : array_like 
        Positive, real-valued parameter 
 
    Returns 
    ------- 
    scalar or ndarray 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span>
    <span class="s4">&quot;_binom_sf&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    _binom_sf(x, n, p) 
 
    Survival function of binomial distribution. 
 
    Parameters 
    ---------- 
    x : array_like 
        Real-valued 
    n : array_like 
        Positive, integer-valued parameter 
    p : array_like 
        Positive, real-valued parameter 
 
    Returns 
    ------- 
    scalar or ndarray 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span>
    <span class="s4">&quot;_binom_isf&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    _binom_isf(x, n, p) 
 
    Inverse survival function of binomial distribution. 
 
    Parameters 
    ---------- 
    x : array_like 
        Real-valued 
    n : array_like 
        Positive, integer-valued parameter 
    p : array_like 
        Positive, real-valued parameter 
 
    Returns 
    ------- 
    scalar or ndarray 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span>
    <span class="s4">&quot;_nbinom_pmf&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    _nbinom_pmf(x, r, p) 
 
    Probability mass function of negative binomial distribution. 
 
    Parameters 
    ---------- 
    x : array_like 
        Real-valued 
    r : array_like 
        Positive, integer-valued parameter 
    p : array_like 
        Positive, real-valued parameter 
 
    Returns 
    ------- 
    scalar or ndarray 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span>
    <span class="s4">&quot;_nbinom_cdf&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    _nbinom_cdf(x, r, p) 
 
    Cumulative density function of negative binomial distribution. 
 
    Parameters 
    ---------- 
    x : array_like 
        Real-valued 
    r : array_like 
        Positive, integer-valued parameter 
    p : array_like 
        Positive, real-valued parameter 
 
    Returns 
    ------- 
    scalar or ndarray 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span>
    <span class="s4">&quot;_nbinom_ppf&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    _nbinom_ppf(x, r, p) 
 
    Percent point function of negative binomial distribution. 
 
    Parameters 
    ---------- 
    x : array_like 
        Real-valued 
    r : array_like 
        Positive, integer-valued parameter 
    p : array_like 
        Positive, real-valued parameter 
 
    Returns 
    ------- 
    scalar or ndarray 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span>
    <span class="s4">&quot;_nbinom_sf&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    _nbinom_sf(x, r, p) 
 
    Survival function of negative binomial distribution. 
 
    Parameters 
    ---------- 
    x : array_like 
        Real-valued 
    r : array_like 
        Positive, integer-valued parameter 
    p : array_like 
        Positive, real-valued parameter 
 
    Returns 
    ------- 
    scalar or ndarray 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span>
    <span class="s4">&quot;_nbinom_isf&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    _nbinom_isf(x, r, p) 
 
    Inverse survival function of negative binomial distribution. 
 
    Parameters 
    ---------- 
    x : array_like 
        Real-valued 
    r : array_like 
        Positive, integer-valued parameter 
    p : array_like 
        Positive, real-valued parameter 
 
    Returns 
    ------- 
    scalar or ndarray 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span>
    <span class="s4">&quot;_nbinom_mean&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    _nbinom_mean(r, p) 
 
    Mean of negative binomial distribution. 
 
    Parameters 
    ---------- 
    r : array_like 
        Positive, integer-valued parameter 
    p : array_like 
        Positive, real-valued parameter 
 
    Returns 
    ------- 
    scalar or ndarray 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span>
    <span class="s4">&quot;_nbinom_variance&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    _nbinom_variance(r, p) 
 
    Variance of negative binomial distribution. 
 
    Parameters 
    ---------- 
    r : array_like 
        Positive, integer-valued parameter 
    p : array_like 
        Positive, real-valued parameter 
 
    Returns 
    ------- 
    scalar or ndarray 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span>
    <span class="s4">&quot;_nbinom_skewness&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    _nbinom_skewness(r, p) 
 
    Skewness of negative binomial distribution. 
 
    Parameters 
    ---------- 
    r : array_like 
        Positive, integer-valued parameter 
    p : array_like 
        Positive, real-valued parameter 
 
    Returns 
    ------- 
    scalar or ndarray 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span>
    <span class="s4">&quot;_nbinom_kurtosis_excess&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    _nbinom_kurtosis_excess(r, p) 
 
    Kurtosis excess of negative binomial distribution. 
 
    Parameters 
    ---------- 
    r : array_like 
        Positive, integer-valued parameter 
    p : array_like 
        Positive, real-valued parameter 
 
    Returns 
    ------- 
    scalar or ndarray 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span>
    <span class="s4">&quot;_hypergeom_pmf&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    _hypergeom_pmf(x, r, N, M) 
 
    Probability mass function of hypergeometric distribution. 
 
    Parameters 
    ---------- 
    x : array_like 
        Real-valued 
    r, N, M : array_like 
        Positive, integer-valued parameter 
 
    Returns 
    ------- 
    scalar or ndarray 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span>
    <span class="s4">&quot;_hypergeom_cdf&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    _hypergeom_cdf(x, r, N, M) 
 
    Cumulative density function of hypergeometric distribution. 
 
    Parameters 
    ---------- 
    x : array_like 
        Real-valued 
    r, N, M : array_like 
        Positive, integer-valued parameter 
 
    Returns 
    ------- 
    scalar or ndarray 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span>
    <span class="s4">&quot;_hypergeom_sf&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    _hypergeom_sf(x, r, N, M) 
 
    Survival function of hypergeometric distribution. 
 
    Parameters 
    ---------- 
    x : array_like 
        Real-valued 
    r, N, M : array_like 
        Positive, integer-valued parameter 
 
    Returns 
    ------- 
    scalar or ndarray 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span>
    <span class="s4">&quot;_hypergeom_mean&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    _hypergeom_mean(r, N, M) 
 
    Mean of hypergeometric distribution. 
 
    Parameters 
    ---------- 
    r, N, M : array_like 
        Positive, integer-valued parameter 
 
    Returns 
    ------- 
    scalar or ndarray 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span>
    <span class="s4">&quot;_hypergeom_variance&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    _hypergeom_variance(r, N, M) 
 
    Mean of hypergeometric distribution. 
 
    Parameters 
    ---------- 
    r, N, M : array_like 
        Positive, integer-valued parameter 
 
    Returns 
    ------- 
    scalar or ndarray 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>

<span class="s1">add_newdoc</span><span class="s2">(</span>
    <span class="s4">&quot;_hypergeom_skewness&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;&quot;&quot; 
    _hypergeom_skewness(r, N, M) 
 
    Skewness of hypergeometric distribution. 
 
    Parameters 
    ---------- 
    r, N, M : array_like 
        Positive, integer-valued parameter 
 
    Returns 
    ------- 
    scalar or ndarray 
 
    &quot;&quot;&quot;</span><span class="s2">)</span>
</pre>
</body>
</html>