<html>
<head>
<title>_windows.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #6aab73;}
.s5 { color: #2aacb8;}
.s6 { color: #7a7e85;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_windows.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;The suite of window functions.&quot;&quot;&quot;</span>

<span class="s2">import </span><span class="s1">operator</span>
<span class="s2">import </span><span class="s1">warnings</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">from </span><span class="s1">scipy </span><span class="s2">import </span><span class="s1">linalg</span><span class="s3">, </span><span class="s1">special</span><span class="s3">, </span><span class="s1">fft </span><span class="s2">as </span><span class="s1">sp_fft</span>

<span class="s1">__all__ </span><span class="s3">= [</span><span class="s4">'boxcar'</span><span class="s3">, </span><span class="s4">'triang'</span><span class="s3">, </span><span class="s4">'parzen'</span><span class="s3">, </span><span class="s4">'bohman'</span><span class="s3">, </span><span class="s4">'blackman'</span><span class="s3">, </span><span class="s4">'nuttall'</span><span class="s3">,</span>
           <span class="s4">'blackmanharris'</span><span class="s3">, </span><span class="s4">'flattop'</span><span class="s3">, </span><span class="s4">'bartlett'</span><span class="s3">, </span><span class="s4">'barthann'</span><span class="s3">,</span>
           <span class="s4">'hamming'</span><span class="s3">, </span><span class="s4">'kaiser'</span><span class="s3">, </span><span class="s4">'kaiser_bessel_derived'</span><span class="s3">, </span><span class="s4">'gaussian'</span><span class="s3">,</span>
           <span class="s4">'general_cosine'</span><span class="s3">, </span><span class="s4">'general_gaussian'</span><span class="s3">, </span><span class="s4">'general_hamming'</span><span class="s3">,</span>
           <span class="s4">'chebwin'</span><span class="s3">, </span><span class="s4">'cosine'</span><span class="s3">, </span><span class="s4">'hann'</span><span class="s3">, </span><span class="s4">'exponential'</span><span class="s3">, </span><span class="s4">'tukey'</span><span class="s3">, </span><span class="s4">'taylor'</span><span class="s3">,</span>
           <span class="s4">'dpss'</span><span class="s3">, </span><span class="s4">'get_window'</span><span class="s3">, </span><span class="s4">'lanczos'</span><span class="s3">]</span>


<span class="s2">def </span><span class="s1">_len_guards</span><span class="s3">(</span><span class="s1">M</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Handle small or incorrect window lengths&quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">int</span><span class="s3">(</span><span class="s1">M</span><span class="s3">) != </span><span class="s1">M </span><span class="s2">or </span><span class="s1">M </span><span class="s3">&lt; </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'Window length M must be a non-negative integer'</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">M </span><span class="s3">&lt;= </span><span class="s5">1</span>


<span class="s2">def </span><span class="s1">_extend</span><span class="s3">(</span><span class="s1">M</span><span class="s3">, </span><span class="s1">sym</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Extend window by 1 sample if needed for DFT-even symmetry&quot;&quot;&quot;</span>
    <span class="s2">if not </span><span class="s1">sym</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">M </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">, </span><span class="s2">True</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">M</span><span class="s3">, </span><span class="s2">False</span>


<span class="s2">def </span><span class="s1">_truncate</span><span class="s3">(</span><span class="s1">w</span><span class="s3">, </span><span class="s1">needed</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Truncate window by 1 sample if needed for DFT-even symmetry&quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">needed</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">w</span><span class="s3">[:-</span><span class="s5">1</span><span class="s3">]</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">w</span>


<span class="s2">def </span><span class="s1">general_cosine</span><span class="s3">(</span><span class="s1">M</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">sym</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
    <span class="s0">r&quot;&quot;&quot; 
    Generic weighted sum of cosine terms window 
 
    Parameters 
    ---------- 
    M : int 
        Number of points in the output window 
    a : array_like 
        Sequence of weighting coefficients. This uses the convention of being 
        centered on the origin, so these will typically all be positive 
        numbers, not alternating sign. 
    sym : bool, optional 
        When True (default), generates a symmetric window, for use in filter 
        design. 
        When False, generates a periodic window, for use in spectral analysis. 
 
    Returns 
    ------- 
    w : ndarray 
        The array of window values. 
 
    References 
    ---------- 
    .. [1] A. Nuttall, &quot;Some windows with very good sidelobe behavior,&quot; IEEE 
           Transactions on Acoustics, Speech, and Signal Processing, vol. 29, 
           no. 1, pp. 84-91, Feb 1981. :doi:`10.1109/TASSP.1981.1163506`. 
    .. [2] Heinzel G. et al., &quot;Spectrum and spectral density estimation by the 
           Discrete Fourier transform (DFT), including a comprehensive list of 
           window functions and some new flat-top windows&quot;, February 15, 2002 
           https://holometer.fnal.gov/GH_FFT.pdf 
 
    Examples 
    -------- 
    Heinzel describes a flat-top window named &quot;HFT90D&quot; with formula: [2]_ 
 
    .. math::  w_j = 1 - 1.942604 \cos(z) + 1.340318 \cos(2z) 
               - 0.440811 \cos(3z) + 0.043097 \cos(4z) 
 
    where 
 
    .. math::  z = \frac{2 \pi j}{N}, j = 0...N - 1 
 
    Since this uses the convention of starting at the origin, to reproduce the 
    window, we need to convert every other coefficient to a positive number: 
 
    &gt;&gt;&gt; HFT90D = [1, 1.942604, 1.340318, 0.440811, 0.043097] 
 
    The paper states that the highest sidelobe is at -90.2 dB.  Reproduce 
    Figure 42 by plotting the window and its frequency response, and confirm 
    the sidelobe level in red: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.signal.windows import general_cosine 
    &gt;&gt;&gt; from scipy.fft import fft, fftshift 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
 
    &gt;&gt;&gt; window = general_cosine(1000, HFT90D, sym=False) 
    &gt;&gt;&gt; plt.plot(window) 
    &gt;&gt;&gt; plt.title(&quot;HFT90D window&quot;) 
    &gt;&gt;&gt; plt.ylabel(&quot;Amplitude&quot;) 
    &gt;&gt;&gt; plt.xlabel(&quot;Sample&quot;) 
 
    &gt;&gt;&gt; plt.figure() 
    &gt;&gt;&gt; A = fft(window, 10000) / (len(window)/2.0) 
    &gt;&gt;&gt; freq = np.linspace(-0.5, 0.5, len(A)) 
    &gt;&gt;&gt; response = np.abs(fftshift(A / abs(A).max())) 
    &gt;&gt;&gt; response = 20 * np.log10(np.maximum(response, 1e-10)) 
    &gt;&gt;&gt; plt.plot(freq, response) 
    &gt;&gt;&gt; plt.axis([-50/1000, 50/1000, -140, 0]) 
    &gt;&gt;&gt; plt.title(&quot;Frequency response of the HFT90D window&quot;) 
    &gt;&gt;&gt; plt.ylabel(&quot;Normalized magnitude [dB]&quot;) 
    &gt;&gt;&gt; plt.xlabel(&quot;Normalized frequency [cycles per sample]&quot;) 
    &gt;&gt;&gt; plt.axhline(-90.2, color='red') 
    &gt;&gt;&gt; plt.show() 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">_len_guards</span><span class="s3">(</span><span class="s1">M</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">M</span><span class="s3">)</span>
    <span class="s1">M</span><span class="s3">, </span><span class="s1">needs_trunc </span><span class="s3">= </span><span class="s1">_extend</span><span class="s3">(</span><span class="s1">M</span><span class="s3">, </span><span class="s1">sym</span><span class="s3">)</span>

    <span class="s1">fac </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">linspace</span><span class="s3">(-</span><span class="s1">np</span><span class="s3">.</span><span class="s1">pi</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">pi</span><span class="s3">, </span><span class="s1">M</span><span class="s3">)</span>
    <span class="s1">w </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">M</span><span class="s3">)</span>
    <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)):</span>
        <span class="s1">w </span><span class="s3">+= </span><span class="s1">a</span><span class="s3">[</span><span class="s1">k</span><span class="s3">] * </span><span class="s1">np</span><span class="s3">.</span><span class="s1">cos</span><span class="s3">(</span><span class="s1">k </span><span class="s3">* </span><span class="s1">fac</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">_truncate</span><span class="s3">(</span><span class="s1">w</span><span class="s3">, </span><span class="s1">needs_trunc</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">boxcar</span><span class="s3">(</span><span class="s1">M</span><span class="s3">, </span><span class="s1">sym</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Return a boxcar or rectangular window. 
 
    Also known as a rectangular window or Dirichlet window, this is equivalent 
    to no window at all. 
 
    Parameters 
    ---------- 
    M : int 
        Number of points in the output window. If zero, an empty array 
        is returned. An exception is thrown when it is negative. 
    sym : bool, optional 
        Whether the window is symmetric. (Has no effect for boxcar.) 
 
    Returns 
    ------- 
    w : ndarray 
        The window, with the maximum value normalized to 1. 
 
    Examples 
    -------- 
    Plot the window and its frequency response: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import signal 
    &gt;&gt;&gt; from scipy.fft import fft, fftshift 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
 
    &gt;&gt;&gt; window = signal.windows.boxcar(51) 
    &gt;&gt;&gt; plt.plot(window) 
    &gt;&gt;&gt; plt.title(&quot;Boxcar window&quot;) 
    &gt;&gt;&gt; plt.ylabel(&quot;Amplitude&quot;) 
    &gt;&gt;&gt; plt.xlabel(&quot;Sample&quot;) 
 
    &gt;&gt;&gt; plt.figure() 
    &gt;&gt;&gt; A = fft(window, 2048) / (len(window)/2.0) 
    &gt;&gt;&gt; freq = np.linspace(-0.5, 0.5, len(A)) 
    &gt;&gt;&gt; response = 20 * np.log10(np.abs(fftshift(A / abs(A).max()))) 
    &gt;&gt;&gt; plt.plot(freq, response) 
    &gt;&gt;&gt; plt.axis([-0.5, 0.5, -120, 0]) 
    &gt;&gt;&gt; plt.title(&quot;Frequency response of the boxcar window&quot;) 
    &gt;&gt;&gt; plt.ylabel(&quot;Normalized magnitude [dB]&quot;) 
    &gt;&gt;&gt; plt.xlabel(&quot;Normalized frequency [cycles per sample]&quot;) 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">_len_guards</span><span class="s3">(</span><span class="s1">M</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">M</span><span class="s3">)</span>
    <span class="s1">M</span><span class="s3">, </span><span class="s1">needs_trunc </span><span class="s3">= </span><span class="s1">_extend</span><span class="s3">(</span><span class="s1">M</span><span class="s3">, </span><span class="s1">sym</span><span class="s3">)</span>

    <span class="s1">w </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">M</span><span class="s3">, </span><span class="s1">float</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">_truncate</span><span class="s3">(</span><span class="s1">w</span><span class="s3">, </span><span class="s1">needs_trunc</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">triang</span><span class="s3">(</span><span class="s1">M</span><span class="s3">, </span><span class="s1">sym</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Return a triangular window. 
 
    Parameters 
    ---------- 
    M : int 
        Number of points in the output window. If zero, an empty array 
        is returned. An exception is thrown when it is negative. 
    sym : bool, optional 
        When True (default), generates a symmetric window, for use in filter 
        design. 
        When False, generates a periodic window, for use in spectral analysis. 
 
    Returns 
    ------- 
    w : ndarray 
        The window, with the maximum value normalized to 1 (though the value 1 
        does not appear if `M` is even and `sym` is True). 
 
    See Also 
    -------- 
    bartlett : A triangular window that touches zero 
 
    Examples 
    -------- 
    Plot the window and its frequency response: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import signal 
    &gt;&gt;&gt; from scipy.fft import fft, fftshift 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
 
    &gt;&gt;&gt; window = signal.windows.triang(51) 
    &gt;&gt;&gt; plt.plot(window) 
    &gt;&gt;&gt; plt.title(&quot;Triangular window&quot;) 
    &gt;&gt;&gt; plt.ylabel(&quot;Amplitude&quot;) 
    &gt;&gt;&gt; plt.xlabel(&quot;Sample&quot;) 
 
    &gt;&gt;&gt; plt.figure() 
    &gt;&gt;&gt; A = fft(window, 2048) / (len(window)/2.0) 
    &gt;&gt;&gt; freq = np.linspace(-0.5, 0.5, len(A)) 
    &gt;&gt;&gt; response = np.abs(fftshift(A / abs(A).max())) 
    &gt;&gt;&gt; response = 20 * np.log10(np.maximum(response, 1e-10)) 
    &gt;&gt;&gt; plt.plot(freq, response) 
    &gt;&gt;&gt; plt.axis([-0.5, 0.5, -120, 0]) 
    &gt;&gt;&gt; plt.title(&quot;Frequency response of the triangular window&quot;) 
    &gt;&gt;&gt; plt.ylabel(&quot;Normalized magnitude [dB]&quot;) 
    &gt;&gt;&gt; plt.xlabel(&quot;Normalized frequency [cycles per sample]&quot;) 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">_len_guards</span><span class="s3">(</span><span class="s1">M</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">M</span><span class="s3">)</span>
    <span class="s1">M</span><span class="s3">, </span><span class="s1">needs_trunc </span><span class="s3">= </span><span class="s1">_extend</span><span class="s3">(</span><span class="s1">M</span><span class="s3">, </span><span class="s1">sym</span><span class="s3">)</span>

    <span class="s1">n </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s5">1</span><span class="s3">, (</span><span class="s1">M </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">) // </span><span class="s5">2 </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">M </span><span class="s3">% </span><span class="s5">2 </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s1">w </span><span class="s3">= (</span><span class="s5">2 </span><span class="s3">* </span><span class="s1">n </span><span class="s3">- </span><span class="s5">1.0</span><span class="s3">) / </span><span class="s1">M</span>
        <span class="s1">w </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">r_</span><span class="s3">[</span><span class="s1">w</span><span class="s3">, </span><span class="s1">w</span><span class="s3">[::-</span><span class="s5">1</span><span class="s3">]]</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">w </span><span class="s3">= </span><span class="s5">2 </span><span class="s3">* </span><span class="s1">n </span><span class="s3">/ (</span><span class="s1">M </span><span class="s3">+ </span><span class="s5">1.0</span><span class="s3">)</span>
        <span class="s1">w </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">r_</span><span class="s3">[</span><span class="s1">w</span><span class="s3">, </span><span class="s1">w</span><span class="s3">[-</span><span class="s5">2</span><span class="s3">::-</span><span class="s5">1</span><span class="s3">]]</span>

    <span class="s2">return </span><span class="s1">_truncate</span><span class="s3">(</span><span class="s1">w</span><span class="s3">, </span><span class="s1">needs_trunc</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">parzen</span><span class="s3">(</span><span class="s1">M</span><span class="s3">, </span><span class="s1">sym</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Return a Parzen window. 
 
    Parameters 
    ---------- 
    M : int 
        Number of points in the output window. If zero, an empty array 
        is returned. An exception is thrown when it is negative. 
    sym : bool, optional 
        When True (default), generates a symmetric window, for use in filter 
        design. 
        When False, generates a periodic window, for use in spectral analysis. 
 
    Returns 
    ------- 
    w : ndarray 
        The window, with the maximum value normalized to 1 (though the value 1 
        does not appear if `M` is even and `sym` is True). 
 
    References 
    ---------- 
    .. [1] E. Parzen, &quot;Mathematical Considerations in the Estimation of 
           Spectra&quot;, Technometrics,  Vol. 3, No. 2 (May, 1961), pp. 167-190 
 
    Examples 
    -------- 
    Plot the window and its frequency response: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import signal 
    &gt;&gt;&gt; from scipy.fft import fft, fftshift 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
 
    &gt;&gt;&gt; window = signal.windows.parzen(51) 
    &gt;&gt;&gt; plt.plot(window) 
    &gt;&gt;&gt; plt.title(&quot;Parzen window&quot;) 
    &gt;&gt;&gt; plt.ylabel(&quot;Amplitude&quot;) 
    &gt;&gt;&gt; plt.xlabel(&quot;Sample&quot;) 
 
    &gt;&gt;&gt; plt.figure() 
    &gt;&gt;&gt; A = fft(window, 2048) / (len(window)/2.0) 
    &gt;&gt;&gt; freq = np.linspace(-0.5, 0.5, len(A)) 
    &gt;&gt;&gt; response = 20 * np.log10(np.abs(fftshift(A / abs(A).max()))) 
    &gt;&gt;&gt; plt.plot(freq, response) 
    &gt;&gt;&gt; plt.axis([-0.5, 0.5, -120, 0]) 
    &gt;&gt;&gt; plt.title(&quot;Frequency response of the Parzen window&quot;) 
    &gt;&gt;&gt; plt.ylabel(&quot;Normalized magnitude [dB]&quot;) 
    &gt;&gt;&gt; plt.xlabel(&quot;Normalized frequency [cycles per sample]&quot;) 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">_len_guards</span><span class="s3">(</span><span class="s1">M</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">M</span><span class="s3">)</span>
    <span class="s1">M</span><span class="s3">, </span><span class="s1">needs_trunc </span><span class="s3">= </span><span class="s1">_extend</span><span class="s3">(</span><span class="s1">M</span><span class="s3">, </span><span class="s1">sym</span><span class="s3">)</span>

    <span class="s1">n </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(-(</span><span class="s1">M </span><span class="s3">- </span><span class="s5">1</span><span class="s3">) / </span><span class="s5">2.0</span><span class="s3">, (</span><span class="s1">M </span><span class="s3">- </span><span class="s5">1</span><span class="s3">) / </span><span class="s5">2.0 </span><span class="s3">+ </span><span class="s5">0.5</span><span class="s3">, </span><span class="s5">1.0</span><span class="s3">)</span>
    <span class="s1">na </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">extract</span><span class="s3">(</span><span class="s1">n </span><span class="s3">&lt; -(</span><span class="s1">M </span><span class="s3">- </span><span class="s5">1</span><span class="s3">) / </span><span class="s5">4.0</span><span class="s3">, </span><span class="s1">n</span><span class="s3">)</span>
    <span class="s1">nb </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">extract</span><span class="s3">(</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">n</span><span class="s3">) &lt;= (</span><span class="s1">M </span><span class="s3">- </span><span class="s5">1</span><span class="s3">) / </span><span class="s5">4.0</span><span class="s3">, </span><span class="s1">n</span><span class="s3">)</span>
    <span class="s1">wa </span><span class="s3">= </span><span class="s5">2 </span><span class="s3">* (</span><span class="s5">1 </span><span class="s3">- </span><span class="s1">np</span><span class="s3">.</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">na</span><span class="s3">) / (</span><span class="s1">M </span><span class="s3">/ </span><span class="s5">2.0</span><span class="s3">)) ** </span><span class="s5">3.0</span>
    <span class="s1">wb </span><span class="s3">= (</span><span class="s5">1 </span><span class="s3">- </span><span class="s5">6 </span><span class="s3">* (</span><span class="s1">np</span><span class="s3">.</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">nb</span><span class="s3">) / (</span><span class="s1">M </span><span class="s3">/ </span><span class="s5">2.0</span><span class="s3">)) ** </span><span class="s5">2.0 </span><span class="s3">+</span>
          <span class="s5">6 </span><span class="s3">* (</span><span class="s1">np</span><span class="s3">.</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">nb</span><span class="s3">) / (</span><span class="s1">M </span><span class="s3">/ </span><span class="s5">2.0</span><span class="s3">)) ** </span><span class="s5">3.0</span><span class="s3">)</span>
    <span class="s1">w </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">r_</span><span class="s3">[</span><span class="s1">wa</span><span class="s3">, </span><span class="s1">wb</span><span class="s3">, </span><span class="s1">wa</span><span class="s3">[::-</span><span class="s5">1</span><span class="s3">]]</span>

    <span class="s2">return </span><span class="s1">_truncate</span><span class="s3">(</span><span class="s1">w</span><span class="s3">, </span><span class="s1">needs_trunc</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">bohman</span><span class="s3">(</span><span class="s1">M</span><span class="s3">, </span><span class="s1">sym</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Return a Bohman window. 
 
    Parameters 
    ---------- 
    M : int 
        Number of points in the output window. If zero, an empty array 
        is returned. An exception is thrown when it is negative. 
    sym : bool, optional 
        When True (default), generates a symmetric window, for use in filter 
        design. 
        When False, generates a periodic window, for use in spectral analysis. 
 
    Returns 
    ------- 
    w : ndarray 
        The window, with the maximum value normalized to 1 (though the value 1 
        does not appear if `M` is even and `sym` is True). 
 
    Examples 
    -------- 
    Plot the window and its frequency response: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import signal 
    &gt;&gt;&gt; from scipy.fft import fft, fftshift 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
 
    &gt;&gt;&gt; window = signal.windows.bohman(51) 
    &gt;&gt;&gt; plt.plot(window) 
    &gt;&gt;&gt; plt.title(&quot;Bohman window&quot;) 
    &gt;&gt;&gt; plt.ylabel(&quot;Amplitude&quot;) 
    &gt;&gt;&gt; plt.xlabel(&quot;Sample&quot;) 
 
    &gt;&gt;&gt; plt.figure() 
    &gt;&gt;&gt; A = fft(window, 2047) / (len(window)/2.0) 
    &gt;&gt;&gt; freq = np.linspace(-0.5, 0.5, len(A)) 
    &gt;&gt;&gt; response = 20 * np.log10(np.abs(fftshift(A / abs(A).max()))) 
    &gt;&gt;&gt; plt.plot(freq, response) 
    &gt;&gt;&gt; plt.axis([-0.5, 0.5, -120, 0]) 
    &gt;&gt;&gt; plt.title(&quot;Frequency response of the Bohman window&quot;) 
    &gt;&gt;&gt; plt.ylabel(&quot;Normalized magnitude [dB]&quot;) 
    &gt;&gt;&gt; plt.xlabel(&quot;Normalized frequency [cycles per sample]&quot;) 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">_len_guards</span><span class="s3">(</span><span class="s1">M</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">M</span><span class="s3">)</span>
    <span class="s1">M</span><span class="s3">, </span><span class="s1">needs_trunc </span><span class="s3">= </span><span class="s1">_extend</span><span class="s3">(</span><span class="s1">M</span><span class="s3">, </span><span class="s1">sym</span><span class="s3">)</span>

    <span class="s1">fac </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">linspace</span><span class="s3">(-</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s1">M</span><span class="s3">)[</span><span class="s5">1</span><span class="s3">:-</span><span class="s5">1</span><span class="s3">])</span>
    <span class="s1">w </span><span class="s3">= (</span><span class="s5">1 </span><span class="s3">- </span><span class="s1">fac</span><span class="s3">) * </span><span class="s1">np</span><span class="s3">.</span><span class="s1">cos</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">pi </span><span class="s3">* </span><span class="s1">fac</span><span class="s3">) + </span><span class="s5">1.0 </span><span class="s3">/ </span><span class="s1">np</span><span class="s3">.</span><span class="s1">pi </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sin</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">pi </span><span class="s3">* </span><span class="s1">fac</span><span class="s3">)</span>
    <span class="s1">w </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">r_</span><span class="s3">[</span><span class="s5">0</span><span class="s3">, </span><span class="s1">w</span><span class="s3">, </span><span class="s5">0</span><span class="s3">]</span>

    <span class="s2">return </span><span class="s1">_truncate</span><span class="s3">(</span><span class="s1">w</span><span class="s3">, </span><span class="s1">needs_trunc</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">blackman</span><span class="s3">(</span><span class="s1">M</span><span class="s3">, </span><span class="s1">sym</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
    <span class="s0">r&quot;&quot;&quot; 
    Return a Blackman window. 
 
    The Blackman window is a taper formed by using the first three terms of 
    a summation of cosines. It was designed to have close to the minimal 
    leakage possible.  It is close to optimal, only slightly worse than a 
    Kaiser window. 
 
    Parameters 
    ---------- 
    M : int 
        Number of points in the output window. If zero, an empty array 
        is returned. An exception is thrown when it is negative. 
    sym : bool, optional 
        When True (default), generates a symmetric window, for use in filter 
        design. 
        When False, generates a periodic window, for use in spectral analysis. 
 
    Returns 
    ------- 
    w : ndarray 
        The window, with the maximum value normalized to 1 (though the value 1 
        does not appear if `M` is even and `sym` is True). 
 
    Notes 
    ----- 
    The Blackman window is defined as 
 
    .. math::  w(n) = 0.42 - 0.5 \cos(2\pi n/M) + 0.08 \cos(4\pi n/M) 
 
    The &quot;exact Blackman&quot; window was designed to null out the third and fourth 
    sidelobes, but has discontinuities at the boundaries, resulting in a 
    6 dB/oct fall-off.  This window is an approximation of the &quot;exact&quot; window, 
    which does not null the sidelobes as well, but is smooth at the edges, 
    improving the fall-off rate to 18 dB/oct. [3]_ 
 
    Most references to the Blackman window come from the signal processing 
    literature, where it is used as one of many windowing functions for 
    smoothing values.  It is also known as an apodization (which means 
    &quot;removing the foot&quot;, i.e. smoothing discontinuities at the beginning 
    and end of the sampled signal) or tapering function. It is known as a 
    &quot;near optimal&quot; tapering function, almost as good (by some measures) 
    as the Kaiser window. 
 
    References 
    ---------- 
    .. [1] Blackman, R.B. and Tukey, J.W., (1958) The measurement of power 
           spectra, Dover Publications, New York. 
    .. [2] Oppenheim, A.V., and R.W. Schafer. Discrete-Time Signal Processing. 
           Upper Saddle River, NJ: Prentice-Hall, 1999, pp. 468-471. 
    .. [3] Harris, Fredric J. (Jan 1978). &quot;On the use of Windows for Harmonic 
           Analysis with the Discrete Fourier Transform&quot;. Proceedings of the 
           IEEE 66 (1): 51-83. :doi:`10.1109/PROC.1978.10837`. 
 
    Examples 
    -------- 
    Plot the window and its frequency response: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import signal 
    &gt;&gt;&gt; from scipy.fft import fft, fftshift 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
 
    &gt;&gt;&gt; window = signal.windows.blackman(51) 
    &gt;&gt;&gt; plt.plot(window) 
    &gt;&gt;&gt; plt.title(&quot;Blackman window&quot;) 
    &gt;&gt;&gt; plt.ylabel(&quot;Amplitude&quot;) 
    &gt;&gt;&gt; plt.xlabel(&quot;Sample&quot;) 
 
    &gt;&gt;&gt; plt.figure() 
    &gt;&gt;&gt; A = fft(window, 2048) / (len(window)/2.0) 
    &gt;&gt;&gt; freq = np.linspace(-0.5, 0.5, len(A)) 
    &gt;&gt;&gt; response = np.abs(fftshift(A / abs(A).max())) 
    &gt;&gt;&gt; response = 20 * np.log10(np.maximum(response, 1e-10)) 
    &gt;&gt;&gt; plt.plot(freq, response) 
    &gt;&gt;&gt; plt.axis([-0.5, 0.5, -120, 0]) 
    &gt;&gt;&gt; plt.title(&quot;Frequency response of the Blackman window&quot;) 
    &gt;&gt;&gt; plt.ylabel(&quot;Normalized magnitude [dB]&quot;) 
    &gt;&gt;&gt; plt.xlabel(&quot;Normalized frequency [cycles per sample]&quot;) 
 
    &quot;&quot;&quot;</span>
    <span class="s6"># Docstring adapted from NumPy's blackman function</span>
    <span class="s2">return </span><span class="s1">general_cosine</span><span class="s3">(</span><span class="s1">M</span><span class="s3">, [</span><span class="s5">0.42</span><span class="s3">, </span><span class="s5">0.50</span><span class="s3">, </span><span class="s5">0.08</span><span class="s3">], </span><span class="s1">sym</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">nuttall</span><span class="s3">(</span><span class="s1">M</span><span class="s3">, </span><span class="s1">sym</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Return a minimum 4-term Blackman-Harris window according to Nuttall. 
 
    This variation is called &quot;Nuttall4c&quot; by Heinzel. [2]_ 
 
    Parameters 
    ---------- 
    M : int 
        Number of points in the output window. If zero, an empty array 
        is returned. An exception is thrown when it is negative. 
    sym : bool, optional 
        When True (default), generates a symmetric window, for use in filter 
        design. 
        When False, generates a periodic window, for use in spectral analysis. 
 
    Returns 
    ------- 
    w : ndarray 
        The window, with the maximum value normalized to 1 (though the value 1 
        does not appear if `M` is even and `sym` is True). 
 
    References 
    ---------- 
    .. [1] A. Nuttall, &quot;Some windows with very good sidelobe behavior,&quot; IEEE 
           Transactions on Acoustics, Speech, and Signal Processing, vol. 29, 
           no. 1, pp. 84-91, Feb 1981. :doi:`10.1109/TASSP.1981.1163506`. 
    .. [2] Heinzel G. et al., &quot;Spectrum and spectral density estimation by the 
           Discrete Fourier transform (DFT), including a comprehensive list of 
           window functions and some new flat-top windows&quot;, February 15, 2002 
           https://holometer.fnal.gov/GH_FFT.pdf 
 
    Examples 
    -------- 
    Plot the window and its frequency response: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import signal 
    &gt;&gt;&gt; from scipy.fft import fft, fftshift 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
 
    &gt;&gt;&gt; window = signal.windows.nuttall(51) 
    &gt;&gt;&gt; plt.plot(window) 
    &gt;&gt;&gt; plt.title(&quot;Nuttall window&quot;) 
    &gt;&gt;&gt; plt.ylabel(&quot;Amplitude&quot;) 
    &gt;&gt;&gt; plt.xlabel(&quot;Sample&quot;) 
 
    &gt;&gt;&gt; plt.figure() 
    &gt;&gt;&gt; A = fft(window, 2048) / (len(window)/2.0) 
    &gt;&gt;&gt; freq = np.linspace(-0.5, 0.5, len(A)) 
    &gt;&gt;&gt; response = 20 * np.log10(np.abs(fftshift(A / abs(A).max()))) 
    &gt;&gt;&gt; plt.plot(freq, response) 
    &gt;&gt;&gt; plt.axis([-0.5, 0.5, -120, 0]) 
    &gt;&gt;&gt; plt.title(&quot;Frequency response of the Nuttall window&quot;) 
    &gt;&gt;&gt; plt.ylabel(&quot;Normalized magnitude [dB]&quot;) 
    &gt;&gt;&gt; plt.xlabel(&quot;Normalized frequency [cycles per sample]&quot;) 
 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">general_cosine</span><span class="s3">(</span><span class="s1">M</span><span class="s3">, [</span><span class="s5">0.3635819</span><span class="s3">, </span><span class="s5">0.4891775</span><span class="s3">, </span><span class="s5">0.1365995</span><span class="s3">, </span><span class="s5">0.0106411</span><span class="s3">], </span><span class="s1">sym</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">blackmanharris</span><span class="s3">(</span><span class="s1">M</span><span class="s3">, </span><span class="s1">sym</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Return a minimum 4-term Blackman-Harris window. 
 
    Parameters 
    ---------- 
    M : int 
        Number of points in the output window. If zero, an empty array 
        is returned. An exception is thrown when it is negative. 
    sym : bool, optional 
        When True (default), generates a symmetric window, for use in filter 
        design. 
        When False, generates a periodic window, for use in spectral analysis. 
 
    Returns 
    ------- 
    w : ndarray 
        The window, with the maximum value normalized to 1 (though the value 1 
        does not appear if `M` is even and `sym` is True). 
 
    Examples 
    -------- 
    Plot the window and its frequency response: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import signal 
    &gt;&gt;&gt; from scipy.fft import fft, fftshift 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
 
    &gt;&gt;&gt; window = signal.windows.blackmanharris(51) 
    &gt;&gt;&gt; plt.plot(window) 
    &gt;&gt;&gt; plt.title(&quot;Blackman-Harris window&quot;) 
    &gt;&gt;&gt; plt.ylabel(&quot;Amplitude&quot;) 
    &gt;&gt;&gt; plt.xlabel(&quot;Sample&quot;) 
 
    &gt;&gt;&gt; plt.figure() 
    &gt;&gt;&gt; A = fft(window, 2048) / (len(window)/2.0) 
    &gt;&gt;&gt; freq = np.linspace(-0.5, 0.5, len(A)) 
    &gt;&gt;&gt; response = 20 * np.log10(np.abs(fftshift(A / abs(A).max()))) 
    &gt;&gt;&gt; plt.plot(freq, response) 
    &gt;&gt;&gt; plt.axis([-0.5, 0.5, -120, 0]) 
    &gt;&gt;&gt; plt.title(&quot;Frequency response of the Blackman-Harris window&quot;) 
    &gt;&gt;&gt; plt.ylabel(&quot;Normalized magnitude [dB]&quot;) 
    &gt;&gt;&gt; plt.xlabel(&quot;Normalized frequency [cycles per sample]&quot;) 
 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">general_cosine</span><span class="s3">(</span><span class="s1">M</span><span class="s3">, [</span><span class="s5">0.35875</span><span class="s3">, </span><span class="s5">0.48829</span><span class="s3">, </span><span class="s5">0.14128</span><span class="s3">, </span><span class="s5">0.01168</span><span class="s3">], </span><span class="s1">sym</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">flattop</span><span class="s3">(</span><span class="s1">M</span><span class="s3">, </span><span class="s1">sym</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Return a flat top window. 
 
    Parameters 
    ---------- 
    M : int 
        Number of points in the output window. If zero, an empty array 
        is returned. An exception is thrown when it is negative. 
    sym : bool, optional 
        When True (default), generates a symmetric window, for use in filter 
        design. 
        When False, generates a periodic window, for use in spectral analysis. 
 
    Returns 
    ------- 
    w : ndarray 
        The window, with the maximum value normalized to 1 (though the value 1 
        does not appear if `M` is even and `sym` is True). 
 
    Notes 
    ----- 
    Flat top windows are used for taking accurate measurements of signal 
    amplitude in the frequency domain, with minimal scalloping error from the 
    center of a frequency bin to its edges, compared to others.  This is a 
    5th-order cosine window, with the 5 terms optimized to make the main lobe 
    maximally flat. [1]_ 
 
    References 
    ---------- 
    .. [1] D'Antona, Gabriele, and A. Ferrero, &quot;Digital Signal Processing for 
           Measurement Systems&quot;, Springer Media, 2006, p. 70 
           :doi:`10.1007/0-387-28666-7`. 
 
    Examples 
    -------- 
    Plot the window and its frequency response: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import signal 
    &gt;&gt;&gt; from scipy.fft import fft, fftshift 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
 
    &gt;&gt;&gt; window = signal.windows.flattop(51) 
    &gt;&gt;&gt; plt.plot(window) 
    &gt;&gt;&gt; plt.title(&quot;Flat top window&quot;) 
    &gt;&gt;&gt; plt.ylabel(&quot;Amplitude&quot;) 
    &gt;&gt;&gt; plt.xlabel(&quot;Sample&quot;) 
 
    &gt;&gt;&gt; plt.figure() 
    &gt;&gt;&gt; A = fft(window, 2048) / (len(window)/2.0) 
    &gt;&gt;&gt; freq = np.linspace(-0.5, 0.5, len(A)) 
    &gt;&gt;&gt; response = 20 * np.log10(np.abs(fftshift(A / abs(A).max()))) 
    &gt;&gt;&gt; plt.plot(freq, response) 
    &gt;&gt;&gt; plt.axis([-0.5, 0.5, -120, 0]) 
    &gt;&gt;&gt; plt.title(&quot;Frequency response of the flat top window&quot;) 
    &gt;&gt;&gt; plt.ylabel(&quot;Normalized magnitude [dB]&quot;) 
    &gt;&gt;&gt; plt.xlabel(&quot;Normalized frequency [cycles per sample]&quot;) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">a </span><span class="s3">= [</span><span class="s5">0.21557895</span><span class="s3">, </span><span class="s5">0.41663158</span><span class="s3">, </span><span class="s5">0.277263158</span><span class="s3">, </span><span class="s5">0.083578947</span><span class="s3">, </span><span class="s5">0.006947368</span><span class="s3">]</span>
    <span class="s2">return </span><span class="s1">general_cosine</span><span class="s3">(</span><span class="s1">M</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">sym</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">bartlett</span><span class="s3">(</span><span class="s1">M</span><span class="s3">, </span><span class="s1">sym</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
    <span class="s0">r&quot;&quot;&quot; 
    Return a Bartlett window. 
 
    The Bartlett window is very similar to a triangular window, except 
    that the end points are at zero.  It is often used in signal 
    processing for tapering a signal, without generating too much 
    ripple in the frequency domain. 
 
    Parameters 
    ---------- 
    M : int 
        Number of points in the output window. If zero, an empty array 
        is returned. An exception is thrown when it is negative. 
    sym : bool, optional 
        When True (default), generates a symmetric window, for use in filter 
        design. 
        When False, generates a periodic window, for use in spectral analysis. 
 
    Returns 
    ------- 
    w : ndarray 
        The triangular window, with the first and last samples equal to zero 
        and the maximum value normalized to 1 (though the value 1 does not 
        appear if `M` is even and `sym` is True). 
 
    See Also 
    -------- 
    triang : A triangular window that does not touch zero at the ends 
 
    Notes 
    ----- 
    The Bartlett window is defined as 
 
    .. math:: w(n) = \frac{2}{M-1} \left( 
              \frac{M-1}{2} - \left|n - \frac{M-1}{2}\right| 
              \right) 
 
    Most references to the Bartlett window come from the signal 
    processing literature, where it is used as one of many windowing 
    functions for smoothing values.  Note that convolution with this 
    window produces linear interpolation.  It is also known as an 
    apodization (which means&quot;removing the foot&quot;, i.e. smoothing 
    discontinuities at the beginning and end of the sampled signal) or 
    tapering function. The Fourier transform of the Bartlett is the product 
    of two sinc functions. 
    Note the excellent discussion in Kanasewich. [2]_ 
 
    References 
    ---------- 
    .. [1] M.S. Bartlett, &quot;Periodogram Analysis and Continuous Spectra&quot;, 
           Biometrika 37, 1-16, 1950. 
    .. [2] E.R. Kanasewich, &quot;Time Sequence Analysis in Geophysics&quot;, 
           The University of Alberta Press, 1975, pp. 109-110. 
    .. [3] A.V. Oppenheim and R.W. Schafer, &quot;Discrete-Time Signal 
           Processing&quot;, Prentice-Hall, 1999, pp. 468-471. 
    .. [4] Wikipedia, &quot;Window function&quot;, 
           https://en.wikipedia.org/wiki/Window_function 
    .. [5] W.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling, 
           &quot;Numerical Recipes&quot;, Cambridge University Press, 1986, page 429. 
 
    Examples 
    -------- 
    Plot the window and its frequency response: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import signal 
    &gt;&gt;&gt; from scipy.fft import fft, fftshift 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
 
    &gt;&gt;&gt; window = signal.windows.bartlett(51) 
    &gt;&gt;&gt; plt.plot(window) 
    &gt;&gt;&gt; plt.title(&quot;Bartlett window&quot;) 
    &gt;&gt;&gt; plt.ylabel(&quot;Amplitude&quot;) 
    &gt;&gt;&gt; plt.xlabel(&quot;Sample&quot;) 
 
    &gt;&gt;&gt; plt.figure() 
    &gt;&gt;&gt; A = fft(window, 2048) / (len(window)/2.0) 
    &gt;&gt;&gt; freq = np.linspace(-0.5, 0.5, len(A)) 
    &gt;&gt;&gt; response = 20 * np.log10(np.abs(fftshift(A / abs(A).max()))) 
    &gt;&gt;&gt; plt.plot(freq, response) 
    &gt;&gt;&gt; plt.axis([-0.5, 0.5, -120, 0]) 
    &gt;&gt;&gt; plt.title(&quot;Frequency response of the Bartlett window&quot;) 
    &gt;&gt;&gt; plt.ylabel(&quot;Normalized magnitude [dB]&quot;) 
    &gt;&gt;&gt; plt.xlabel(&quot;Normalized frequency [cycles per sample]&quot;) 
 
    &quot;&quot;&quot;</span>
    <span class="s6"># Docstring adapted from NumPy's bartlett function</span>
    <span class="s2">if </span><span class="s1">_len_guards</span><span class="s3">(</span><span class="s1">M</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">M</span><span class="s3">)</span>
    <span class="s1">M</span><span class="s3">, </span><span class="s1">needs_trunc </span><span class="s3">= </span><span class="s1">_extend</span><span class="s3">(</span><span class="s1">M</span><span class="s3">, </span><span class="s1">sym</span><span class="s3">)</span>

    <span class="s1">n </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">M</span><span class="s3">)</span>
    <span class="s1">w </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">where</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">less_equal</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, (</span><span class="s1">M </span><span class="s3">- </span><span class="s5">1</span><span class="s3">) / </span><span class="s5">2.0</span><span class="s3">),</span>
                 <span class="s5">2.0 </span><span class="s3">* </span><span class="s1">n </span><span class="s3">/ (</span><span class="s1">M </span><span class="s3">- </span><span class="s5">1</span><span class="s3">), </span><span class="s5">2.0 </span><span class="s3">- </span><span class="s5">2.0 </span><span class="s3">* </span><span class="s1">n </span><span class="s3">/ (</span><span class="s1">M </span><span class="s3">- </span><span class="s5">1</span><span class="s3">))</span>

    <span class="s2">return </span><span class="s1">_truncate</span><span class="s3">(</span><span class="s1">w</span><span class="s3">, </span><span class="s1">needs_trunc</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">hann</span><span class="s3">(</span><span class="s1">M</span><span class="s3">, </span><span class="s1">sym</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
    <span class="s0">r&quot;&quot;&quot; 
    Return a Hann window. 
 
    The Hann window is a taper formed by using a raised cosine or sine-squared 
    with ends that touch zero. 
 
    Parameters 
    ---------- 
    M : int 
        Number of points in the output window. If zero, an empty array 
        is returned. An exception is thrown when it is negative. 
    sym : bool, optional 
        When True (default), generates a symmetric window, for use in filter 
        design. 
        When False, generates a periodic window, for use in spectral analysis. 
 
    Returns 
    ------- 
    w : ndarray 
        The window, with the maximum value normalized to 1 (though the value 1 
        does not appear if `M` is even and `sym` is True). 
 
    Notes 
    ----- 
    The Hann window is defined as 
 
    .. math::  w(n) = 0.5 - 0.5 \cos\left(\frac{2\pi{n}}{M-1}\right) 
               \qquad 0 \leq n \leq M-1 
 
    The window was named for Julius von Hann, an Austrian meteorologist. It is 
    also known as the Cosine Bell. It is sometimes erroneously referred to as 
    the &quot;Hanning&quot; window, from the use of &quot;hann&quot; as a verb in the original 
    paper and confusion with the very similar Hamming window. 
 
    Most references to the Hann window come from the signal processing 
    literature, where it is used as one of many windowing functions for 
    smoothing values.  It is also known as an apodization (which means 
    &quot;removing the foot&quot;, i.e. smoothing discontinuities at the beginning 
    and end of the sampled signal) or tapering function. 
 
    References 
    ---------- 
    .. [1] Blackman, R.B. and Tukey, J.W., (1958) The measurement of power 
           spectra, Dover Publications, New York. 
    .. [2] E.R. Kanasewich, &quot;Time Sequence Analysis in Geophysics&quot;, 
           The University of Alberta Press, 1975, pp. 106-108. 
    .. [3] Wikipedia, &quot;Window function&quot;, 
           https://en.wikipedia.org/wiki/Window_function 
    .. [4] W.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling, 
           &quot;Numerical Recipes&quot;, Cambridge University Press, 1986, page 425. 
 
    Examples 
    -------- 
    Plot the window and its frequency response: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import signal 
    &gt;&gt;&gt; from scipy.fft import fft, fftshift 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
 
    &gt;&gt;&gt; window = signal.windows.hann(51) 
    &gt;&gt;&gt; plt.plot(window) 
    &gt;&gt;&gt; plt.title(&quot;Hann window&quot;) 
    &gt;&gt;&gt; plt.ylabel(&quot;Amplitude&quot;) 
    &gt;&gt;&gt; plt.xlabel(&quot;Sample&quot;) 
 
    &gt;&gt;&gt; plt.figure() 
    &gt;&gt;&gt; A = fft(window, 2048) / (len(window)/2.0) 
    &gt;&gt;&gt; freq = np.linspace(-0.5, 0.5, len(A)) 
    &gt;&gt;&gt; response = np.abs(fftshift(A / abs(A).max())) 
    &gt;&gt;&gt; response = 20 * np.log10(np.maximum(response, 1e-10)) 
    &gt;&gt;&gt; plt.plot(freq, response) 
    &gt;&gt;&gt; plt.axis([-0.5, 0.5, -120, 0]) 
    &gt;&gt;&gt; plt.title(&quot;Frequency response of the Hann window&quot;) 
    &gt;&gt;&gt; plt.ylabel(&quot;Normalized magnitude [dB]&quot;) 
    &gt;&gt;&gt; plt.xlabel(&quot;Normalized frequency [cycles per sample]&quot;) 
 
    &quot;&quot;&quot;</span>
    <span class="s6"># Docstring adapted from NumPy's hanning function</span>
    <span class="s2">return </span><span class="s1">general_hamming</span><span class="s3">(</span><span class="s1">M</span><span class="s3">, </span><span class="s5">0.5</span><span class="s3">, </span><span class="s1">sym</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">tukey</span><span class="s3">(</span><span class="s1">M</span><span class="s3">, </span><span class="s1">alpha</span><span class="s3">=</span><span class="s5">0.5</span><span class="s3">, </span><span class="s1">sym</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
    <span class="s0">r&quot;&quot;&quot;Return a Tukey window, also known as a tapered cosine window. 
 
    Parameters 
    ---------- 
    M : int 
        Number of points in the output window. If zero, an empty array 
        is returned. An exception is thrown when it is negative. 
    alpha : float, optional 
        Shape parameter of the Tukey window, representing the fraction of the 
        window inside the cosine tapered region. 
        If zero, the Tukey window is equivalent to a rectangular window. 
        If one, the Tukey window is equivalent to a Hann window. 
    sym : bool, optional 
        When True (default), generates a symmetric window, for use in filter 
        design. 
        When False, generates a periodic window, for use in spectral analysis. 
 
    Returns 
    ------- 
    w : ndarray 
        The window, with the maximum value normalized to 1 (though the value 1 
        does not appear if `M` is even and `sym` is True). 
 
    References 
    ---------- 
    .. [1] Harris, Fredric J. (Jan 1978). &quot;On the use of Windows for Harmonic 
           Analysis with the Discrete Fourier Transform&quot;. Proceedings of the 
           IEEE 66 (1): 51-83. :doi:`10.1109/PROC.1978.10837` 
    .. [2] Wikipedia, &quot;Window function&quot;, 
           https://en.wikipedia.org/wiki/Window_function#Tukey_window 
 
    Examples 
    -------- 
    Plot the window and its frequency response: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import signal 
    &gt;&gt;&gt; from scipy.fft import fft, fftshift 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
 
    &gt;&gt;&gt; window = signal.windows.tukey(51) 
    &gt;&gt;&gt; plt.plot(window) 
    &gt;&gt;&gt; plt.title(&quot;Tukey window&quot;) 
    &gt;&gt;&gt; plt.ylabel(&quot;Amplitude&quot;) 
    &gt;&gt;&gt; plt.xlabel(&quot;Sample&quot;) 
    &gt;&gt;&gt; plt.ylim([0, 1.1]) 
 
    &gt;&gt;&gt; plt.figure() 
    &gt;&gt;&gt; A = fft(window, 2048) / (len(window)/2.0) 
    &gt;&gt;&gt; freq = np.linspace(-0.5, 0.5, len(A)) 
    &gt;&gt;&gt; response = 20 * np.log10(np.abs(fftshift(A / abs(A).max()))) 
    &gt;&gt;&gt; plt.plot(freq, response) 
    &gt;&gt;&gt; plt.axis([-0.5, 0.5, -120, 0]) 
    &gt;&gt;&gt; plt.title(&quot;Frequency response of the Tukey window&quot;) 
    &gt;&gt;&gt; plt.ylabel(&quot;Normalized magnitude [dB]&quot;) 
    &gt;&gt;&gt; plt.xlabel(&quot;Normalized frequency [cycles per sample]&quot;) 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">_len_guards</span><span class="s3">(</span><span class="s1">M</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">M</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">alpha </span><span class="s3">&lt;= </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">M</span><span class="s3">, </span><span class="s4">'d'</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">alpha </span><span class="s3">&gt;= </span><span class="s5">1.0</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">hann</span><span class="s3">(</span><span class="s1">M</span><span class="s3">, </span><span class="s1">sym</span><span class="s3">=</span><span class="s1">sym</span><span class="s3">)</span>

    <span class="s1">M</span><span class="s3">, </span><span class="s1">needs_trunc </span><span class="s3">= </span><span class="s1">_extend</span><span class="s3">(</span><span class="s1">M</span><span class="s3">, </span><span class="s1">sym</span><span class="s3">)</span>

    <span class="s1">n </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">M</span><span class="s3">)</span>
    <span class="s1">width </span><span class="s3">= </span><span class="s1">int</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">floor</span><span class="s3">(</span><span class="s1">alpha</span><span class="s3">*(</span><span class="s1">M</span><span class="s3">-</span><span class="s5">1</span><span class="s3">)/</span><span class="s5">2.0</span><span class="s3">))</span>
    <span class="s1">n1 </span><span class="s3">= </span><span class="s1">n</span><span class="s3">[</span><span class="s5">0</span><span class="s3">:</span><span class="s1">width</span><span class="s3">+</span><span class="s5">1</span><span class="s3">]</span>
    <span class="s1">n2 </span><span class="s3">= </span><span class="s1">n</span><span class="s3">[</span><span class="s1">width</span><span class="s3">+</span><span class="s5">1</span><span class="s3">:</span><span class="s1">M</span><span class="s3">-</span><span class="s1">width</span><span class="s3">-</span><span class="s5">1</span><span class="s3">]</span>
    <span class="s1">n3 </span><span class="s3">= </span><span class="s1">n</span><span class="s3">[</span><span class="s1">M</span><span class="s3">-</span><span class="s1">width</span><span class="s3">-</span><span class="s5">1</span><span class="s3">:]</span>

    <span class="s1">w1 </span><span class="s3">= </span><span class="s5">0.5 </span><span class="s3">* (</span><span class="s5">1 </span><span class="s3">+ </span><span class="s1">np</span><span class="s3">.</span><span class="s1">cos</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">pi </span><span class="s3">* (-</span><span class="s5">1 </span><span class="s3">+ </span><span class="s5">2.0</span><span class="s3">*</span><span class="s1">n1</span><span class="s3">/</span><span class="s1">alpha</span><span class="s3">/(</span><span class="s1">M</span><span class="s3">-</span><span class="s5">1</span><span class="s3">))))</span>
    <span class="s1">w2 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">n2</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">)</span>
    <span class="s1">w3 </span><span class="s3">= </span><span class="s5">0.5 </span><span class="s3">* (</span><span class="s5">1 </span><span class="s3">+ </span><span class="s1">np</span><span class="s3">.</span><span class="s1">cos</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">pi </span><span class="s3">* (-</span><span class="s5">2.0</span><span class="s3">/</span><span class="s1">alpha </span><span class="s3">+ </span><span class="s5">1 </span><span class="s3">+ </span><span class="s5">2.0</span><span class="s3">*</span><span class="s1">n3</span><span class="s3">/</span><span class="s1">alpha</span><span class="s3">/(</span><span class="s1">M</span><span class="s3">-</span><span class="s5">1</span><span class="s3">))))</span>

    <span class="s1">w </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">concatenate</span><span class="s3">((</span><span class="s1">w1</span><span class="s3">, </span><span class="s1">w2</span><span class="s3">, </span><span class="s1">w3</span><span class="s3">))</span>

    <span class="s2">return </span><span class="s1">_truncate</span><span class="s3">(</span><span class="s1">w</span><span class="s3">, </span><span class="s1">needs_trunc</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">barthann</span><span class="s3">(</span><span class="s1">M</span><span class="s3">, </span><span class="s1">sym</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Return a modified Bartlett-Hann window. 
 
    Parameters 
    ---------- 
    M : int 
        Number of points in the output window. If zero, an empty array 
        is returned. An exception is thrown when it is negative. 
    sym : bool, optional 
        When True (default), generates a symmetric window, for use in filter 
        design. 
        When False, generates a periodic window, for use in spectral analysis. 
 
    Returns 
    ------- 
    w : ndarray 
        The window, with the maximum value normalized to 1 (though the value 1 
        does not appear if `M` is even and `sym` is True). 
 
    Examples 
    -------- 
    Plot the window and its frequency response: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import signal 
    &gt;&gt;&gt; from scipy.fft import fft, fftshift 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
 
    &gt;&gt;&gt; window = signal.windows.barthann(51) 
    &gt;&gt;&gt; plt.plot(window) 
    &gt;&gt;&gt; plt.title(&quot;Bartlett-Hann window&quot;) 
    &gt;&gt;&gt; plt.ylabel(&quot;Amplitude&quot;) 
    &gt;&gt;&gt; plt.xlabel(&quot;Sample&quot;) 
 
    &gt;&gt;&gt; plt.figure() 
    &gt;&gt;&gt; A = fft(window, 2048) / (len(window)/2.0) 
    &gt;&gt;&gt; freq = np.linspace(-0.5, 0.5, len(A)) 
    &gt;&gt;&gt; response = 20 * np.log10(np.abs(fftshift(A / abs(A).max()))) 
    &gt;&gt;&gt; plt.plot(freq, response) 
    &gt;&gt;&gt; plt.axis([-0.5, 0.5, -120, 0]) 
    &gt;&gt;&gt; plt.title(&quot;Frequency response of the Bartlett-Hann window&quot;) 
    &gt;&gt;&gt; plt.ylabel(&quot;Normalized magnitude [dB]&quot;) 
    &gt;&gt;&gt; plt.xlabel(&quot;Normalized frequency [cycles per sample]&quot;) 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">_len_guards</span><span class="s3">(</span><span class="s1">M</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">M</span><span class="s3">)</span>
    <span class="s1">M</span><span class="s3">, </span><span class="s1">needs_trunc </span><span class="s3">= </span><span class="s1">_extend</span><span class="s3">(</span><span class="s1">M</span><span class="s3">, </span><span class="s1">sym</span><span class="s3">)</span>

    <span class="s1">n </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">M</span><span class="s3">)</span>
    <span class="s1">fac </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">n </span><span class="s3">/ (</span><span class="s1">M </span><span class="s3">- </span><span class="s5">1.0</span><span class="s3">) - </span><span class="s5">0.5</span><span class="s3">)</span>
    <span class="s1">w </span><span class="s3">= </span><span class="s5">0.62 </span><span class="s3">- </span><span class="s5">0.48 </span><span class="s3">* </span><span class="s1">fac </span><span class="s3">+ </span><span class="s5">0.38 </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">cos</span><span class="s3">(</span><span class="s5">2 </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">pi </span><span class="s3">* </span><span class="s1">fac</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">_truncate</span><span class="s3">(</span><span class="s1">w</span><span class="s3">, </span><span class="s1">needs_trunc</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">general_hamming</span><span class="s3">(</span><span class="s1">M</span><span class="s3">, </span><span class="s1">alpha</span><span class="s3">, </span><span class="s1">sym</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
    <span class="s0">r&quot;&quot;&quot;Return a generalized Hamming window. 
 
    The generalized Hamming window is constructed by multiplying a rectangular 
    window by one period of a cosine function [1]_. 
 
    Parameters 
    ---------- 
    M : int 
        Number of points in the output window. If zero, an empty array 
        is returned. An exception is thrown when it is negative. 
    alpha : float 
        The window coefficient, :math:`\alpha` 
    sym : bool, optional 
        When True (default), generates a symmetric window, for use in filter 
        design. 
        When False, generates a periodic window, for use in spectral analysis. 
 
    Returns 
    ------- 
    w : ndarray 
        The window, with the maximum value normalized to 1 (though the value 1 
        does not appear if `M` is even and `sym` is True). 
 
    See Also 
    -------- 
    hamming, hann 
 
    Notes 
    ----- 
    The generalized Hamming window is defined as 
 
    .. math:: w(n) = \alpha - \left(1 - \alpha\right) 
              \cos\left(\frac{2\pi{n}}{M-1}\right) \qquad 0 \leq n \leq M-1 
 
    Both the common Hamming window and Hann window are special cases of the 
    generalized Hamming window with :math:`\alpha` = 0.54 and :math:`\alpha` = 
    0.5, respectively [2]_. 
 
    References 
    ---------- 
    .. [1] DSPRelated, &quot;Generalized Hamming Window Family&quot;, 
           https://www.dsprelated.com/freebooks/sasp/Generalized_Hamming_Window_Family.html 
    .. [2] Wikipedia, &quot;Window function&quot;, 
           https://en.wikipedia.org/wiki/Window_function 
    .. [3] Riccardo Piantanida ESA, &quot;Sentinel-1 Level 1 Detailed Algorithm 
           Definition&quot;, 
           https://sentinel.esa.int/documents/247904/1877131/Sentinel-1-Level-1-Detailed-Algorithm-Definition 
    .. [4] Matthieu Bourbigot ESA, &quot;Sentinel-1 Product Definition&quot;, 
           https://sentinel.esa.int/documents/247904/1877131/Sentinel-1-Product-Definition 
 
    Examples 
    -------- 
    The Sentinel-1A/B Instrument Processing Facility uses generalized Hamming 
    windows in the processing of spaceborne Synthetic Aperture Radar (SAR) 
    data [3]_. The facility uses various values for the :math:`\alpha` 
    parameter based on operating mode of the SAR instrument. Some common 
    :math:`\alpha` values include 0.75, 0.7 and 0.52 [4]_. As an example, we 
    plot these different windows. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.signal.windows import general_hamming 
    &gt;&gt;&gt; from scipy.fft import fft, fftshift 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
 
    &gt;&gt;&gt; fig1, spatial_plot = plt.subplots() 
    &gt;&gt;&gt; spatial_plot.set_title(&quot;Generalized Hamming Windows&quot;) 
    &gt;&gt;&gt; spatial_plot.set_ylabel(&quot;Amplitude&quot;) 
    &gt;&gt;&gt; spatial_plot.set_xlabel(&quot;Sample&quot;) 
 
    &gt;&gt;&gt; fig2, freq_plot = plt.subplots() 
    &gt;&gt;&gt; freq_plot.set_title(&quot;Frequency Responses&quot;) 
    &gt;&gt;&gt; freq_plot.set_ylabel(&quot;Normalized magnitude [dB]&quot;) 
    &gt;&gt;&gt; freq_plot.set_xlabel(&quot;Normalized frequency [cycles per sample]&quot;) 
 
    &gt;&gt;&gt; for alpha in [0.75, 0.7, 0.52]: 
    ...     window = general_hamming(41, alpha) 
    ...     spatial_plot.plot(window, label=&quot;{:.2f}&quot;.format(alpha)) 
    ...     A = fft(window, 2048) / (len(window)/2.0) 
    ...     freq = np.linspace(-0.5, 0.5, len(A)) 
    ...     response = 20 * np.log10(np.abs(fftshift(A / abs(A).max()))) 
    ...     freq_plot.plot(freq, response, label=&quot;{:.2f}&quot;.format(alpha)) 
    &gt;&gt;&gt; freq_plot.legend(loc=&quot;upper right&quot;) 
    &gt;&gt;&gt; spatial_plot.legend(loc=&quot;upper right&quot;) 
 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">general_cosine</span><span class="s3">(</span><span class="s1">M</span><span class="s3">, [</span><span class="s1">alpha</span><span class="s3">, </span><span class="s5">1. </span><span class="s3">- </span><span class="s1">alpha</span><span class="s3">], </span><span class="s1">sym</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">hamming</span><span class="s3">(</span><span class="s1">M</span><span class="s3">, </span><span class="s1">sym</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
    <span class="s0">r&quot;&quot;&quot;Return a Hamming window. 
 
    The Hamming window is a taper formed by using a raised cosine with 
    non-zero endpoints, optimized to minimize the nearest side lobe. 
 
    Parameters 
    ---------- 
    M : int 
        Number of points in the output window. If zero, an empty array 
        is returned. An exception is thrown when it is negative. 
    sym : bool, optional 
        When True (default), generates a symmetric window, for use in filter 
        design. 
        When False, generates a periodic window, for use in spectral analysis. 
 
    Returns 
    ------- 
    w : ndarray 
        The window, with the maximum value normalized to 1 (though the value 1 
        does not appear if `M` is even and `sym` is True). 
 
    Notes 
    ----- 
    The Hamming window is defined as 
 
    .. math::  w(n) = 0.54 - 0.46 \cos\left(\frac{2\pi{n}}{M-1}\right) 
               \qquad 0 \leq n \leq M-1 
 
    The Hamming was named for R. W. Hamming, an associate of J. W. Tukey and 
    is described in Blackman and Tukey. It was recommended for smoothing the 
    truncated autocovariance function in the time domain. 
    Most references to the Hamming window come from the signal processing 
    literature, where it is used as one of many windowing functions for 
    smoothing values.  It is also known as an apodization (which means 
    &quot;removing the foot&quot;, i.e. smoothing discontinuities at the beginning 
    and end of the sampled signal) or tapering function. 
 
    References 
    ---------- 
    .. [1] Blackman, R.B. and Tukey, J.W., (1958) The measurement of power 
           spectra, Dover Publications, New York. 
    .. [2] E.R. Kanasewich, &quot;Time Sequence Analysis in Geophysics&quot;, The 
           University of Alberta Press, 1975, pp. 109-110. 
    .. [3] Wikipedia, &quot;Window function&quot;, 
           https://en.wikipedia.org/wiki/Window_function 
    .. [4] W.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling, 
           &quot;Numerical Recipes&quot;, Cambridge University Press, 1986, page 425. 
 
    Examples 
    -------- 
    Plot the window and its frequency response: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import signal 
    &gt;&gt;&gt; from scipy.fft import fft, fftshift 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
 
    &gt;&gt;&gt; window = signal.windows.hamming(51) 
    &gt;&gt;&gt; plt.plot(window) 
    &gt;&gt;&gt; plt.title(&quot;Hamming window&quot;) 
    &gt;&gt;&gt; plt.ylabel(&quot;Amplitude&quot;) 
    &gt;&gt;&gt; plt.xlabel(&quot;Sample&quot;) 
 
    &gt;&gt;&gt; plt.figure() 
    &gt;&gt;&gt; A = fft(window, 2048) / (len(window)/2.0) 
    &gt;&gt;&gt; freq = np.linspace(-0.5, 0.5, len(A)) 
    &gt;&gt;&gt; response = 20 * np.log10(np.abs(fftshift(A / abs(A).max()))) 
    &gt;&gt;&gt; plt.plot(freq, response) 
    &gt;&gt;&gt; plt.axis([-0.5, 0.5, -120, 0]) 
    &gt;&gt;&gt; plt.title(&quot;Frequency response of the Hamming window&quot;) 
    &gt;&gt;&gt; plt.ylabel(&quot;Normalized magnitude [dB]&quot;) 
    &gt;&gt;&gt; plt.xlabel(&quot;Normalized frequency [cycles per sample]&quot;) 
 
    &quot;&quot;&quot;</span>
    <span class="s6"># Docstring adapted from NumPy's hamming function</span>
    <span class="s2">return </span><span class="s1">general_hamming</span><span class="s3">(</span><span class="s1">M</span><span class="s3">, </span><span class="s5">0.54</span><span class="s3">, </span><span class="s1">sym</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">kaiser</span><span class="s3">(</span><span class="s1">M</span><span class="s3">, </span><span class="s1">beta</span><span class="s3">, </span><span class="s1">sym</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
    <span class="s0">r&quot;&quot;&quot;Return a Kaiser window. 
 
    The Kaiser window is a taper formed by using a Bessel function. 
 
    Parameters 
    ---------- 
    M : int 
        Number of points in the output window. If zero, an empty array 
        is returned. An exception is thrown when it is negative. 
    beta : float 
        Shape parameter, determines trade-off between main-lobe width and 
        side lobe level. As beta gets large, the window narrows. 
    sym : bool, optional 
        When True (default), generates a symmetric window, for use in filter 
        design. 
        When False, generates a periodic window, for use in spectral analysis. 
 
    Returns 
    ------- 
    w : ndarray 
        The window, with the maximum value normalized to 1 (though the value 1 
        does not appear if `M` is even and `sym` is True). 
 
    Notes 
    ----- 
    The Kaiser window is defined as 
 
    .. math::  w(n) = I_0\left( \beta \sqrt{1-\frac{4n^2}{(M-1)^2}} 
               \right)/I_0(\beta) 
 
    with 
 
    .. math:: \quad -\frac{M-1}{2} \leq n \leq \frac{M-1}{2}, 
 
    where :math:`I_0` is the modified zeroth-order Bessel function. 
 
    The Kaiser was named for Jim Kaiser, who discovered a simple approximation 
    to the DPSS window based on Bessel functions. 
    The Kaiser window is a very good approximation to the Digital Prolate 
    Spheroidal Sequence, or Slepian window, which is the transform which 
    maximizes the energy in the main lobe of the window relative to total 
    energy. 
 
    The Kaiser can approximate other windows by varying the beta parameter. 
    (Some literature uses alpha = beta/pi.) [4]_ 
 
    ====  ======================= 
    beta  Window shape 
    ====  ======================= 
    0     Rectangular 
    5     Similar to a Hamming 
    6     Similar to a Hann 
    8.6   Similar to a Blackman 
    ====  ======================= 
 
    A beta value of 14 is probably a good starting point. Note that as beta 
    gets large, the window narrows, and so the number of samples needs to be 
    large enough to sample the increasingly narrow spike, otherwise NaNs will 
    be returned. 
 
    Most references to the Kaiser window come from the signal processing 
    literature, where it is used as one of many windowing functions for 
    smoothing values.  It is also known as an apodization (which means 
    &quot;removing the foot&quot;, i.e. smoothing discontinuities at the beginning 
    and end of the sampled signal) or tapering function. 
 
    References 
    ---------- 
    .. [1] J. F. Kaiser, &quot;Digital Filters&quot; - Ch 7 in &quot;Systems analysis by 
           digital computer&quot;, Editors: F.F. Kuo and J.F. Kaiser, p 218-285. 
           John Wiley and Sons, New York, (1966). 
    .. [2] E.R. Kanasewich, &quot;Time Sequence Analysis in Geophysics&quot;, The 
           University of Alberta Press, 1975, pp. 177-178. 
    .. [3] Wikipedia, &quot;Window function&quot;, 
           https://en.wikipedia.org/wiki/Window_function 
    .. [4] F. J. Harris, &quot;On the use of windows for harmonic analysis with the 
           discrete Fourier transform,&quot; Proceedings of the IEEE, vol. 66, 
           no. 1, pp. 51-83, Jan. 1978. :doi:`10.1109/PROC.1978.10837`. 
 
    Examples 
    -------- 
    Plot the window and its frequency response: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import signal 
    &gt;&gt;&gt; from scipy.fft import fft, fftshift 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
 
    &gt;&gt;&gt; window = signal.windows.kaiser(51, beta=14) 
    &gt;&gt;&gt; plt.plot(window) 
    &gt;&gt;&gt; plt.title(r&quot;Kaiser window ($\beta$=14)&quot;) 
    &gt;&gt;&gt; plt.ylabel(&quot;Amplitude&quot;) 
    &gt;&gt;&gt; plt.xlabel(&quot;Sample&quot;) 
 
    &gt;&gt;&gt; plt.figure() 
    &gt;&gt;&gt; A = fft(window, 2048) / (len(window)/2.0) 
    &gt;&gt;&gt; freq = np.linspace(-0.5, 0.5, len(A)) 
    &gt;&gt;&gt; response = 20 * np.log10(np.abs(fftshift(A / abs(A).max()))) 
    &gt;&gt;&gt; plt.plot(freq, response) 
    &gt;&gt;&gt; plt.axis([-0.5, 0.5, -120, 0]) 
    &gt;&gt;&gt; plt.title(r&quot;Frequency response of the Kaiser window ($\beta$=14)&quot;) 
    &gt;&gt;&gt; plt.ylabel(&quot;Normalized magnitude [dB]&quot;) 
    &gt;&gt;&gt; plt.xlabel(&quot;Normalized frequency [cycles per sample]&quot;) 
 
    &quot;&quot;&quot;</span>
    <span class="s6"># Docstring adapted from NumPy's kaiser function</span>
    <span class="s2">if </span><span class="s1">_len_guards</span><span class="s3">(</span><span class="s1">M</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">M</span><span class="s3">)</span>
    <span class="s1">M</span><span class="s3">, </span><span class="s1">needs_trunc </span><span class="s3">= </span><span class="s1">_extend</span><span class="s3">(</span><span class="s1">M</span><span class="s3">, </span><span class="s1">sym</span><span class="s3">)</span>

    <span class="s1">n </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">M</span><span class="s3">)</span>
    <span class="s1">alpha </span><span class="s3">= (</span><span class="s1">M </span><span class="s3">- </span><span class="s5">1</span><span class="s3">) / </span><span class="s5">2.0</span>
    <span class="s1">w </span><span class="s3">= (</span><span class="s1">special</span><span class="s3">.</span><span class="s1">i0</span><span class="s3">(</span><span class="s1">beta </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s5">1 </span><span class="s3">- ((</span><span class="s1">n </span><span class="s3">- </span><span class="s1">alpha</span><span class="s3">) / </span><span class="s1">alpha</span><span class="s3">) ** </span><span class="s5">2.0</span><span class="s3">)) /</span>
         <span class="s1">special</span><span class="s3">.</span><span class="s1">i0</span><span class="s3">(</span><span class="s1">beta</span><span class="s3">))</span>

    <span class="s2">return </span><span class="s1">_truncate</span><span class="s3">(</span><span class="s1">w</span><span class="s3">, </span><span class="s1">needs_trunc</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">kaiser_bessel_derived</span><span class="s3">(</span><span class="s1">M</span><span class="s3">, </span><span class="s1">beta</span><span class="s3">, *, </span><span class="s1">sym</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Return a Kaiser-Bessel derived window. 
 
    Parameters 
    ---------- 
    M : int 
        Number of points in the output window. If zero, an empty array 
        is returned. An exception is thrown when it is negative. 
        Note that this window is only defined for an even 
        number of points. 
    beta : float 
        Kaiser window shape parameter. 
    sym : bool, optional 
        This parameter only exists to comply with the interface offered by 
        the other window functions and to be callable by `get_window`. 
        When True (default), generates a symmetric window, for use in filter 
        design. 
 
    Returns 
    ------- 
    w : ndarray 
        The window, normalized to fulfil the Princen-Bradley condition. 
 
    See Also 
    -------- 
    kaiser 
 
    Notes 
    ----- 
    It is designed to be suitable for use with the modified discrete cosine 
    transform (MDCT) and is mainly used in audio signal processing and 
    audio coding. 
 
    .. versionadded:: 1.9.0 
 
    References 
    ---------- 
    .. [1] Bosi, Marina, and Richard E. Goldberg. Introduction to Digital 
           Audio Coding and Standards. Dordrecht: Kluwer, 2003. 
    .. [2] Wikipedia, &quot;Kaiser window&quot;, 
           https://en.wikipedia.org/wiki/Kaiser_window 
 
    Examples 
    -------- 
    Plot the Kaiser-Bessel derived window based on the wikipedia 
    reference [2]_: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import signal 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; fig, ax = plt.subplots() 
    &gt;&gt;&gt; N = 50 
    &gt;&gt;&gt; for alpha in [0.64, 2.55, 7.64, 31.83]: 
    ...     ax.plot(signal.windows.kaiser_bessel_derived(2*N, np.pi*alpha), 
    ...             label=f&quot;{alpha=}&quot;) 
    &gt;&gt;&gt; ax.grid(True) 
    &gt;&gt;&gt; ax.set_title(&quot;Kaiser-Bessel derived window&quot;) 
    &gt;&gt;&gt; ax.set_ylabel(&quot;Amplitude&quot;) 
    &gt;&gt;&gt; ax.set_xlabel(&quot;Sample&quot;) 
    &gt;&gt;&gt; ax.set_xticks([0, N, 2*N-1]) 
    &gt;&gt;&gt; ax.set_xticklabels([&quot;0&quot;, &quot;N&quot;, &quot;2N+1&quot;])  # doctest: +SKIP 
    &gt;&gt;&gt; ax.set_yticks([0.0, 0.2, 0.4, 0.6, 0.707, 0.8, 1.0]) 
    &gt;&gt;&gt; fig.legend(loc=&quot;center&quot;) 
    &gt;&gt;&gt; fig.tight_layout() 
    &gt;&gt;&gt; fig.show() 
    &quot;&quot;&quot;</span>
    <span class="s2">if not </span><span class="s1">sym</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span>
            <span class="s4">&quot;Kaiser-Bessel Derived windows are only defined for symmetric &quot;</span>
            <span class="s4">&quot;shapes&quot;</span>
        <span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">M </span><span class="s3">&lt; </span><span class="s5">1</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([])</span>
    <span class="s2">elif </span><span class="s1">M </span><span class="s3">% </span><span class="s5">2</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span>
            <span class="s4">&quot;Kaiser-Bessel Derived windows are only defined for even number &quot;</span>
            <span class="s4">&quot;of points&quot;</span>
        <span class="s3">)</span>

    <span class="s1">kaiser_window </span><span class="s3">= </span><span class="s1">kaiser</span><span class="s3">(</span><span class="s1">M </span><span class="s3">// </span><span class="s5">2 </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">, </span><span class="s1">beta</span><span class="s3">)</span>
    <span class="s1">csum </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">cumsum</span><span class="s3">(</span><span class="s1">kaiser_window</span><span class="s3">)</span>
    <span class="s1">half_window </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s1">csum</span><span class="s3">[:-</span><span class="s5">1</span><span class="s3">] / </span><span class="s1">csum</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">])</span>
    <span class="s1">w </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">concatenate</span><span class="s3">((</span><span class="s1">half_window</span><span class="s3">, </span><span class="s1">half_window</span><span class="s3">[::-</span><span class="s5">1</span><span class="s3">]), </span><span class="s1">axis</span><span class="s3">=</span><span class="s5">0</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">w</span>


<span class="s2">def </span><span class="s1">gaussian</span><span class="s3">(</span><span class="s1">M</span><span class="s3">, </span><span class="s1">std</span><span class="s3">, </span><span class="s1">sym</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
    <span class="s0">r&quot;&quot;&quot;Return a Gaussian window. 
 
    Parameters 
    ---------- 
    M : int 
        Number of points in the output window. If zero, an empty array 
        is returned. An exception is thrown when it is negative. 
    std : float 
        The standard deviation, sigma. 
    sym : bool, optional 
        When True (default), generates a symmetric window, for use in filter 
        design. 
        When False, generates a periodic window, for use in spectral analysis. 
 
    Returns 
    ------- 
    w : ndarray 
        The window, with the maximum value normalized to 1 (though the value 1 
        does not appear if `M` is even and `sym` is True). 
 
    Notes 
    ----- 
    The Gaussian window is defined as 
 
    .. math::  w(n) = e^{ -\frac{1}{2}\left(\frac{n}{\sigma}\right)^2 } 
 
    Examples 
    -------- 
    Plot the window and its frequency response: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import signal 
    &gt;&gt;&gt; from scipy.fft import fft, fftshift 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
 
    &gt;&gt;&gt; window = signal.windows.gaussian(51, std=7) 
    &gt;&gt;&gt; plt.plot(window) 
    &gt;&gt;&gt; plt.title(r&quot;Gaussian window ($\sigma$=7)&quot;) 
    &gt;&gt;&gt; plt.ylabel(&quot;Amplitude&quot;) 
    &gt;&gt;&gt; plt.xlabel(&quot;Sample&quot;) 
 
    &gt;&gt;&gt; plt.figure() 
    &gt;&gt;&gt; A = fft(window, 2048) / (len(window)/2.0) 
    &gt;&gt;&gt; freq = np.linspace(-0.5, 0.5, len(A)) 
    &gt;&gt;&gt; response = 20 * np.log10(np.abs(fftshift(A / abs(A).max()))) 
    &gt;&gt;&gt; plt.plot(freq, response) 
    &gt;&gt;&gt; plt.axis([-0.5, 0.5, -120, 0]) 
    &gt;&gt;&gt; plt.title(r&quot;Frequency response of the Gaussian window ($\sigma$=7)&quot;) 
    &gt;&gt;&gt; plt.ylabel(&quot;Normalized magnitude [dB]&quot;) 
    &gt;&gt;&gt; plt.xlabel(&quot;Normalized frequency [cycles per sample]&quot;) 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">_len_guards</span><span class="s3">(</span><span class="s1">M</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">M</span><span class="s3">)</span>
    <span class="s1">M</span><span class="s3">, </span><span class="s1">needs_trunc </span><span class="s3">= </span><span class="s1">_extend</span><span class="s3">(</span><span class="s1">M</span><span class="s3">, </span><span class="s1">sym</span><span class="s3">)</span>

    <span class="s1">n </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">M</span><span class="s3">) - (</span><span class="s1">M </span><span class="s3">- </span><span class="s5">1.0</span><span class="s3">) / </span><span class="s5">2.0</span>
    <span class="s1">sig2 </span><span class="s3">= </span><span class="s5">2 </span><span class="s3">* </span><span class="s1">std </span><span class="s3">* </span><span class="s1">std</span>
    <span class="s1">w </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">exp</span><span class="s3">(-</span><span class="s1">n </span><span class="s3">** </span><span class="s5">2 </span><span class="s3">/ </span><span class="s1">sig2</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">_truncate</span><span class="s3">(</span><span class="s1">w</span><span class="s3">, </span><span class="s1">needs_trunc</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">general_gaussian</span><span class="s3">(</span><span class="s1">M</span><span class="s3">, </span><span class="s1">p</span><span class="s3">, </span><span class="s1">sig</span><span class="s3">, </span><span class="s1">sym</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
    <span class="s0">r&quot;&quot;&quot;Return a window with a generalized Gaussian shape. 
 
    Parameters 
    ---------- 
    M : int 
        Number of points in the output window. If zero, an empty array 
        is returned. An exception is thrown when it is negative. 
    p : float 
        Shape parameter.  p = 1 is identical to `gaussian`, p = 0.5 is 
        the same shape as the Laplace distribution. 
    sig : float 
        The standard deviation, sigma. 
    sym : bool, optional 
        When True (default), generates a symmetric window, for use in filter 
        design. 
        When False, generates a periodic window, for use in spectral analysis. 
 
    Returns 
    ------- 
    w : ndarray 
        The window, with the maximum value normalized to 1 (though the value 1 
        does not appear if `M` is even and `sym` is True). 
 
    Notes 
    ----- 
    The generalized Gaussian window is defined as 
 
    .. math::  w(n) = e^{ -\frac{1}{2}\left|\frac{n}{\sigma}\right|^{2p} } 
 
    the half-power point is at 
 
    .. math::  (2 \log(2))^{1/(2 p)} \sigma 
 
    Examples 
    -------- 
    Plot the window and its frequency response: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import signal 
    &gt;&gt;&gt; from scipy.fft import fft, fftshift 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
 
    &gt;&gt;&gt; window = signal.windows.general_gaussian(51, p=1.5, sig=7) 
    &gt;&gt;&gt; plt.plot(window) 
    &gt;&gt;&gt; plt.title(r&quot;Generalized Gaussian window (p=1.5, $\sigma$=7)&quot;) 
    &gt;&gt;&gt; plt.ylabel(&quot;Amplitude&quot;) 
    &gt;&gt;&gt; plt.xlabel(&quot;Sample&quot;) 
 
    &gt;&gt;&gt; plt.figure() 
    &gt;&gt;&gt; A = fft(window, 2048) / (len(window)/2.0) 
    &gt;&gt;&gt; freq = np.linspace(-0.5, 0.5, len(A)) 
    &gt;&gt;&gt; response = 20 * np.log10(np.abs(fftshift(A / abs(A).max()))) 
    &gt;&gt;&gt; plt.plot(freq, response) 
    &gt;&gt;&gt; plt.axis([-0.5, 0.5, -120, 0]) 
    &gt;&gt;&gt; plt.title(r&quot;Freq. resp. of the gen. Gaussian &quot; 
    ...           r&quot;window (p=1.5, $\sigma$=7)&quot;) 
    &gt;&gt;&gt; plt.ylabel(&quot;Normalized magnitude [dB]&quot;) 
    &gt;&gt;&gt; plt.xlabel(&quot;Normalized frequency [cycles per sample]&quot;) 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">_len_guards</span><span class="s3">(</span><span class="s1">M</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">M</span><span class="s3">)</span>
    <span class="s1">M</span><span class="s3">, </span><span class="s1">needs_trunc </span><span class="s3">= </span><span class="s1">_extend</span><span class="s3">(</span><span class="s1">M</span><span class="s3">, </span><span class="s1">sym</span><span class="s3">)</span>

    <span class="s1">n </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">M</span><span class="s3">) - (</span><span class="s1">M </span><span class="s3">- </span><span class="s5">1.0</span><span class="s3">) / </span><span class="s5">2.0</span>
    <span class="s1">w </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">exp</span><span class="s3">(-</span><span class="s5">0.5 </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">n </span><span class="s3">/ </span><span class="s1">sig</span><span class="s3">) ** (</span><span class="s5">2 </span><span class="s3">* </span><span class="s1">p</span><span class="s3">))</span>

    <span class="s2">return </span><span class="s1">_truncate</span><span class="s3">(</span><span class="s1">w</span><span class="s3">, </span><span class="s1">needs_trunc</span><span class="s3">)</span>


<span class="s6"># `chebwin` contributed by Kumar Appaiah.</span>
<span class="s2">def </span><span class="s1">chebwin</span><span class="s3">(</span><span class="s1">M</span><span class="s3">, </span><span class="s1">at</span><span class="s3">, </span><span class="s1">sym</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
    <span class="s0">r&quot;&quot;&quot;Return a Dolph-Chebyshev window. 
 
    Parameters 
    ---------- 
    M : int 
        Number of points in the output window. If zero, an empty array 
        is returned. An exception is thrown when it is negative. 
    at : float 
        Attenuation (in dB). 
    sym : bool, optional 
        When True (default), generates a symmetric window, for use in filter 
        design. 
        When False, generates a periodic window, for use in spectral analysis. 
 
    Returns 
    ------- 
    w : ndarray 
        The window, with the maximum value always normalized to 1 
 
    Notes 
    ----- 
    This window optimizes for the narrowest main lobe width for a given order 
    `M` and sidelobe equiripple attenuation `at`, using Chebyshev 
    polynomials.  It was originally developed by Dolph to optimize the 
    directionality of radio antenna arrays. 
 
    Unlike most windows, the Dolph-Chebyshev is defined in terms of its 
    frequency response: 
 
    .. math:: W(k) = \frac 
              {\cos\{M \cos^{-1}[\beta \cos(\frac{\pi k}{M})]\}} 
              {\cosh[M \cosh^{-1}(\beta)]} 
 
    where 
 
    .. math:: \beta = \cosh \left [\frac{1}{M} 
              \cosh^{-1}(10^\frac{A}{20}) \right ] 
 
    and 0 &lt;= abs(k) &lt;= M-1. A is the attenuation in decibels (`at`). 
 
    The time domain window is then generated using the IFFT, so 
    power-of-two `M` are the fastest to generate, and prime number `M` are 
    the slowest. 
 
    The equiripple condition in the frequency domain creates impulses in the 
    time domain, which appear at the ends of the window. 
 
    References 
    ---------- 
    .. [1] C. Dolph, &quot;A current distribution for broadside arrays which 
           optimizes the relationship between beam width and side-lobe level&quot;, 
           Proceedings of the IEEE, Vol. 34, Issue 6 
    .. [2] Peter Lynch, &quot;The Dolph-Chebyshev Window: A Simple Optimal Filter&quot;, 
           American Meteorological Society (April 1997) 
           http://mathsci.ucd.ie/~plynch/Publications/Dolph.pdf 
    .. [3] F. J. Harris, &quot;On the use of windows for harmonic analysis with the 
           discrete Fourier transforms&quot;, Proceedings of the IEEE, Vol. 66, 
           No. 1, January 1978 
 
    Examples 
    -------- 
    Plot the window and its frequency response: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import signal 
    &gt;&gt;&gt; from scipy.fft import fft, fftshift 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
 
    &gt;&gt;&gt; window = signal.windows.chebwin(51, at=100) 
    &gt;&gt;&gt; plt.plot(window) 
    &gt;&gt;&gt; plt.title(&quot;Dolph-Chebyshev window (100 dB)&quot;) 
    &gt;&gt;&gt; plt.ylabel(&quot;Amplitude&quot;) 
    &gt;&gt;&gt; plt.xlabel(&quot;Sample&quot;) 
 
    &gt;&gt;&gt; plt.figure() 
    &gt;&gt;&gt; A = fft(window, 2048) / (len(window)/2.0) 
    &gt;&gt;&gt; freq = np.linspace(-0.5, 0.5, len(A)) 
    &gt;&gt;&gt; response = 20 * np.log10(np.abs(fftshift(A / abs(A).max()))) 
    &gt;&gt;&gt; plt.plot(freq, response) 
    &gt;&gt;&gt; plt.axis([-0.5, 0.5, -120, 0]) 
    &gt;&gt;&gt; plt.title(&quot;Frequency response of the Dolph-Chebyshev window (100 dB)&quot;) 
    &gt;&gt;&gt; plt.ylabel(&quot;Normalized magnitude [dB]&quot;) 
    &gt;&gt;&gt; plt.xlabel(&quot;Normalized frequency [cycles per sample]&quot;) 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">at</span><span class="s3">) &lt; </span><span class="s5">45</span><span class="s3">:</span>
        <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span><span class="s4">&quot;This window is not suitable for spectral analysis &quot;</span>
                      <span class="s4">&quot;for attenuation values lower than about 45dB because &quot;</span>
                      <span class="s4">&quot;the equivalent noise bandwidth of a Chebyshev window &quot;</span>
                      <span class="s4">&quot;does not grow monotonically with increasing sidelobe &quot;</span>
                      <span class="s4">&quot;attenuation when the attenuation is smaller than &quot;</span>
                      <span class="s4">&quot;about 45 dB.&quot;</span><span class="s3">,</span>
                      <span class="s1">stacklevel</span><span class="s3">=</span><span class="s5">2</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">_len_guards</span><span class="s3">(</span><span class="s1">M</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">M</span><span class="s3">)</span>
    <span class="s1">M</span><span class="s3">, </span><span class="s1">needs_trunc </span><span class="s3">= </span><span class="s1">_extend</span><span class="s3">(</span><span class="s1">M</span><span class="s3">, </span><span class="s1">sym</span><span class="s3">)</span>

    <span class="s6"># compute the parameter beta</span>
    <span class="s1">order </span><span class="s3">= </span><span class="s1">M </span><span class="s3">- </span><span class="s5">1.0</span>
    <span class="s1">beta </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">cosh</span><span class="s3">(</span><span class="s5">1.0 </span><span class="s3">/ </span><span class="s1">order </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arccosh</span><span class="s3">(</span><span class="s5">10 </span><span class="s3">** (</span><span class="s1">np</span><span class="s3">.</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">at</span><span class="s3">) / </span><span class="s5">20.</span><span class="s3">)))</span>
    <span class="s1">k </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">r_</span><span class="s3">[</span><span class="s5">0</span><span class="s3">:</span><span class="s1">M</span><span class="s3">] * </span><span class="s5">1.0</span>
    <span class="s1">x </span><span class="s3">= </span><span class="s1">beta </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">cos</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">pi </span><span class="s3">* </span><span class="s1">k </span><span class="s3">/ </span><span class="s1">M</span><span class="s3">)</span>
    <span class="s6"># Find the window's DFT coefficients</span>
    <span class="s6"># Use analytic definition of Chebyshev polynomial instead of expansion</span>
    <span class="s6"># from scipy.special. Using the expansion in scipy.special leads to errors.</span>
    <span class="s1">p </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">)</span>
    <span class="s1">p</span><span class="s3">[</span><span class="s1">x </span><span class="s3">&gt; </span><span class="s5">1</span><span class="s3">] = </span><span class="s1">np</span><span class="s3">.</span><span class="s1">cosh</span><span class="s3">(</span><span class="s1">order </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arccosh</span><span class="s3">(</span><span class="s1">x</span><span class="s3">[</span><span class="s1">x </span><span class="s3">&gt; </span><span class="s5">1</span><span class="s3">]))</span>
    <span class="s1">p</span><span class="s3">[</span><span class="s1">x </span><span class="s3">&lt; -</span><span class="s5">1</span><span class="s3">] = (</span><span class="s5">2 </span><span class="s3">* (</span><span class="s1">M </span><span class="s3">% </span><span class="s5">2</span><span class="s3">) - </span><span class="s5">1</span><span class="s3">) * </span><span class="s1">np</span><span class="s3">.</span><span class="s1">cosh</span><span class="s3">(</span><span class="s1">order </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arccosh</span><span class="s3">(-</span><span class="s1">x</span><span class="s3">[</span><span class="s1">x </span><span class="s3">&lt; -</span><span class="s5">1</span><span class="s3">]))</span>
    <span class="s1">p</span><span class="s3">[</span><span class="s1">np</span><span class="s3">.</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) &lt;= </span><span class="s5">1</span><span class="s3">] = </span><span class="s1">np</span><span class="s3">.</span><span class="s1">cos</span><span class="s3">(</span><span class="s1">order </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arccos</span><span class="s3">(</span><span class="s1">x</span><span class="s3">[</span><span class="s1">np</span><span class="s3">.</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) &lt;= </span><span class="s5">1</span><span class="s3">]))</span>

    <span class="s6"># Appropriate IDFT and filling up</span>
    <span class="s6"># depending on even/odd M</span>
    <span class="s2">if </span><span class="s1">M </span><span class="s3">% </span><span class="s5">2</span><span class="s3">:</span>
        <span class="s1">w </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">real</span><span class="s3">(</span><span class="s1">sp_fft</span><span class="s3">.</span><span class="s1">fft</span><span class="s3">(</span><span class="s1">p</span><span class="s3">))</span>
        <span class="s1">n </span><span class="s3">= (</span><span class="s1">M </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">) // </span><span class="s5">2</span>
        <span class="s1">w </span><span class="s3">= </span><span class="s1">w</span><span class="s3">[:</span><span class="s1">n</span><span class="s3">]</span>
        <span class="s1">w </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">concatenate</span><span class="s3">((</span><span class="s1">w</span><span class="s3">[</span><span class="s1">n </span><span class="s3">- </span><span class="s5">1</span><span class="s3">:</span><span class="s5">0</span><span class="s3">:-</span><span class="s5">1</span><span class="s3">], </span><span class="s1">w</span><span class="s3">))</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">p </span><span class="s3">= </span><span class="s1">p </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">exp</span><span class="s3">(</span><span class="s5">1.j </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">pi </span><span class="s3">/ </span><span class="s1">M </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">r_</span><span class="s3">[</span><span class="s5">0</span><span class="s3">:</span><span class="s1">M</span><span class="s3">])</span>
        <span class="s1">w </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">real</span><span class="s3">(</span><span class="s1">sp_fft</span><span class="s3">.</span><span class="s1">fft</span><span class="s3">(</span><span class="s1">p</span><span class="s3">))</span>
        <span class="s1">n </span><span class="s3">= </span><span class="s1">M </span><span class="s3">// </span><span class="s5">2 </span><span class="s3">+ </span><span class="s5">1</span>
        <span class="s1">w </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">concatenate</span><span class="s3">((</span><span class="s1">w</span><span class="s3">[</span><span class="s1">n </span><span class="s3">- </span><span class="s5">1</span><span class="s3">:</span><span class="s5">0</span><span class="s3">:-</span><span class="s5">1</span><span class="s3">], </span><span class="s1">w</span><span class="s3">[</span><span class="s5">1</span><span class="s3">:</span><span class="s1">n</span><span class="s3">]))</span>
    <span class="s1">w </span><span class="s3">= </span><span class="s1">w </span><span class="s3">/ </span><span class="s1">max</span><span class="s3">(</span><span class="s1">w</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">_truncate</span><span class="s3">(</span><span class="s1">w</span><span class="s3">, </span><span class="s1">needs_trunc</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">cosine</span><span class="s3">(</span><span class="s1">M</span><span class="s3">, </span><span class="s1">sym</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Return a window with a simple cosine shape. 
 
    Parameters 
    ---------- 
    M : int 
        Number of points in the output window. If zero, an empty array 
        is returned. An exception is thrown when it is negative. 
    sym : bool, optional 
        When True (default), generates a symmetric window, for use in filter 
        design. 
        When False, generates a periodic window, for use in spectral analysis. 
 
    Returns 
    ------- 
    w : ndarray 
        The window, with the maximum value normalized to 1 (though the value 1 
        does not appear if `M` is even and `sym` is True). 
 
    Notes 
    ----- 
 
    .. versionadded:: 0.13.0 
 
    Examples 
    -------- 
    Plot the window and its frequency response: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import signal 
    &gt;&gt;&gt; from scipy.fft import fft, fftshift 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
 
    &gt;&gt;&gt; window = signal.windows.cosine(51) 
    &gt;&gt;&gt; plt.plot(window) 
    &gt;&gt;&gt; plt.title(&quot;Cosine window&quot;) 
    &gt;&gt;&gt; plt.ylabel(&quot;Amplitude&quot;) 
    &gt;&gt;&gt; plt.xlabel(&quot;Sample&quot;) 
 
    &gt;&gt;&gt; plt.figure() 
    &gt;&gt;&gt; A = fft(window, 2047) / (len(window)/2.0) 
    &gt;&gt;&gt; freq = np.linspace(-0.5, 0.5, len(A)) 
    &gt;&gt;&gt; response = 20 * np.log10(np.abs(fftshift(A / abs(A).max()))) 
    &gt;&gt;&gt; plt.plot(freq, response) 
    &gt;&gt;&gt; plt.axis([-0.5, 0.5, -120, 0]) 
    &gt;&gt;&gt; plt.title(&quot;Frequency response of the cosine window&quot;) 
    &gt;&gt;&gt; plt.ylabel(&quot;Normalized magnitude [dB]&quot;) 
    &gt;&gt;&gt; plt.xlabel(&quot;Normalized frequency [cycles per sample]&quot;) 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">_len_guards</span><span class="s3">(</span><span class="s1">M</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">M</span><span class="s3">)</span>
    <span class="s1">M</span><span class="s3">, </span><span class="s1">needs_trunc </span><span class="s3">= </span><span class="s1">_extend</span><span class="s3">(</span><span class="s1">M</span><span class="s3">, </span><span class="s1">sym</span><span class="s3">)</span>

    <span class="s1">w </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sin</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">pi </span><span class="s3">/ </span><span class="s1">M </span><span class="s3">* (</span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">M</span><span class="s3">) + </span><span class="s5">.5</span><span class="s3">))</span>

    <span class="s2">return </span><span class="s1">_truncate</span><span class="s3">(</span><span class="s1">w</span><span class="s3">, </span><span class="s1">needs_trunc</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">exponential</span><span class="s3">(</span><span class="s1">M</span><span class="s3">, </span><span class="s1">center</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">tau</span><span class="s3">=</span><span class="s5">1.</span><span class="s3">, </span><span class="s1">sym</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
    <span class="s0">r&quot;&quot;&quot;Return an exponential (or Poisson) window. 
 
    Parameters 
    ---------- 
    M : int 
        Number of points in the output window. If zero, an empty array 
        is returned. An exception is thrown when it is negative. 
    center : float, optional 
        Parameter defining the center location of the window function. 
        The default value if not given is ``center = (M-1) / 2``.  This 
        parameter must take its default value for symmetric windows. 
    tau : float, optional 
        Parameter defining the decay.  For ``center = 0`` use 
        ``tau = -(M-1) / ln(x)`` if ``x`` is the fraction of the window 
        remaining at the end. 
    sym : bool, optional 
        When True (default), generates a symmetric window, for use in filter 
        design. 
        When False, generates a periodic window, for use in spectral analysis. 
 
    Returns 
    ------- 
    w : ndarray 
        The window, with the maximum value normalized to 1 (though the value 1 
        does not appear if `M` is even and `sym` is True). 
 
    Notes 
    ----- 
    The Exponential window is defined as 
 
    .. math::  w(n) = e^{-|n-center| / \tau} 
 
    References 
    ---------- 
    .. [1] S. Gade and H. Herlufsen, &quot;Windows to FFT analysis (Part I)&quot;, 
           Technical Review 3, Bruel &amp; Kjaer, 1987. 
 
    Examples 
    -------- 
    Plot the symmetric window and its frequency response: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import signal 
    &gt;&gt;&gt; from scipy.fft import fft, fftshift 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
 
    &gt;&gt;&gt; M = 51 
    &gt;&gt;&gt; tau = 3.0 
    &gt;&gt;&gt; window = signal.windows.exponential(M, tau=tau) 
    &gt;&gt;&gt; plt.plot(window) 
    &gt;&gt;&gt; plt.title(&quot;Exponential Window (tau=3.0)&quot;) 
    &gt;&gt;&gt; plt.ylabel(&quot;Amplitude&quot;) 
    &gt;&gt;&gt; plt.xlabel(&quot;Sample&quot;) 
 
    &gt;&gt;&gt; plt.figure() 
    &gt;&gt;&gt; A = fft(window, 2048) / (len(window)/2.0) 
    &gt;&gt;&gt; freq = np.linspace(-0.5, 0.5, len(A)) 
    &gt;&gt;&gt; response = 20 * np.log10(np.abs(fftshift(A / abs(A).max()))) 
    &gt;&gt;&gt; plt.plot(freq, response) 
    &gt;&gt;&gt; plt.axis([-0.5, 0.5, -35, 0]) 
    &gt;&gt;&gt; plt.title(&quot;Frequency response of the Exponential window (tau=3.0)&quot;) 
    &gt;&gt;&gt; plt.ylabel(&quot;Normalized magnitude [dB]&quot;) 
    &gt;&gt;&gt; plt.xlabel(&quot;Normalized frequency [cycles per sample]&quot;) 
 
    This function can also generate non-symmetric windows: 
 
    &gt;&gt;&gt; tau2 = -(M-1) / np.log(0.01) 
    &gt;&gt;&gt; window2 = signal.windows.exponential(M, 0, tau2, False) 
    &gt;&gt;&gt; plt.figure() 
    &gt;&gt;&gt; plt.plot(window2) 
    &gt;&gt;&gt; plt.ylabel(&quot;Amplitude&quot;) 
    &gt;&gt;&gt; plt.xlabel(&quot;Sample&quot;) 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">sym </span><span class="s2">and </span><span class="s1">center </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;If sym==True, center must be None.&quot;</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">_len_guards</span><span class="s3">(</span><span class="s1">M</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">M</span><span class="s3">)</span>
    <span class="s1">M</span><span class="s3">, </span><span class="s1">needs_trunc </span><span class="s3">= </span><span class="s1">_extend</span><span class="s3">(</span><span class="s1">M</span><span class="s3">, </span><span class="s1">sym</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">center </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">center </span><span class="s3">= (</span><span class="s1">M</span><span class="s3">-</span><span class="s5">1</span><span class="s3">) / </span><span class="s5">2</span>

    <span class="s1">n </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">M</span><span class="s3">)</span>
    <span class="s1">w </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">exp</span><span class="s3">(-</span><span class="s1">np</span><span class="s3">.</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">n</span><span class="s3">-</span><span class="s1">center</span><span class="s3">) / </span><span class="s1">tau</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">_truncate</span><span class="s3">(</span><span class="s1">w</span><span class="s3">, </span><span class="s1">needs_trunc</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">taylor</span><span class="s3">(</span><span class="s1">M</span><span class="s3">, </span><span class="s1">nbar</span><span class="s3">=</span><span class="s5">4</span><span class="s3">, </span><span class="s1">sll</span><span class="s3">=</span><span class="s5">30</span><span class="s3">, </span><span class="s1">norm</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">sym</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
    <span class="s4">&quot;&quot;&quot; 
    Return a Taylor window. 
 
    The Taylor window taper function approximates the Dolph-Chebyshev window's 
    constant sidelobe level for a parameterized number of near-in sidelobes, 
    but then allows a taper beyond [2]_. 
 
    The SAR (synthetic aperture radar) community commonly uses Taylor 
    weighting for image formation processing because it provides strong, 
    selectable sidelobe suppression with minimum broadening of the 
    mainlobe [1]_. 
 
    Parameters 
    ---------- 
    M : int 
        Number of points in the output window. If zero, an empty array 
        is returned. An exception is thrown when it is negative. 
    nbar : int, optional 
        Number of nearly constant level sidelobes adjacent to the mainlobe. 
    sll : float, optional 
        Desired suppression of sidelobe level in decibels (dB) relative to the 
        DC gain of the mainlobe. This should be a positive number. 
    norm : bool, optional 
        When True (default), divides the window by the largest (middle) value 
        for odd-length windows or the value that would occur between the two 
        repeated middle values for even-length windows such that all values 
        are less than or equal to 1. When False the DC gain will remain at 1 
        (0 dB) and the sidelobes will be `sll` dB down. 
    sym : bool, optional 
        When True (default), generates a symmetric window, for use in filter 
        design. 
        When False, generates a periodic window, for use in spectral analysis. 
 
    Returns 
    ------- 
    out : array 
        The window. When `norm` is True (default), the maximum value is 
        normalized to 1 (though the value 1 does not appear if `M` is 
        even and `sym` is True). 
 
    See Also 
    -------- 
    chebwin, kaiser, bartlett, blackman, hamming, hann 
 
    References 
    ---------- 
    .. [1] W. Carrara, R. Goodman, and R. Majewski, &quot;Spotlight Synthetic 
           Aperture Radar: Signal Processing Algorithms&quot; Pages 512-513, 
           July 1995. 
    .. [2] Armin Doerry, &quot;Catalog of Window Taper Functions for 
           Sidelobe Control&quot;, 2017. 
           https://www.researchgate.net/profile/Armin_Doerry/publication/316281181_Catalog_of_Window_Taper_Functions_for_Sidelobe_Control/links/58f92cb2a6fdccb121c9d54d/Catalog-of-Window-Taper-Functions-for-Sidelobe-Control.pdf 
 
    Examples 
    -------- 
    Plot the window and its frequency response: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import signal 
    &gt;&gt;&gt; from scipy.fft import fft, fftshift 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
 
    &gt;&gt;&gt; window = signal.windows.taylor(51, nbar=20, sll=100, norm=False) 
    &gt;&gt;&gt; plt.plot(window) 
    &gt;&gt;&gt; plt.title(&quot;Taylor window (100 dB)&quot;) 
    &gt;&gt;&gt; plt.ylabel(&quot;Amplitude&quot;) 
    &gt;&gt;&gt; plt.xlabel(&quot;Sample&quot;) 
 
    &gt;&gt;&gt; plt.figure() 
    &gt;&gt;&gt; A = fft(window, 2048) / (len(window)/2.0) 
    &gt;&gt;&gt; freq = np.linspace(-0.5, 0.5, len(A)) 
    &gt;&gt;&gt; response = 20 * np.log10(np.abs(fftshift(A / abs(A).max()))) 
    &gt;&gt;&gt; plt.plot(freq, response) 
    &gt;&gt;&gt; plt.axis([-0.5, 0.5, -120, 0]) 
    &gt;&gt;&gt; plt.title(&quot;Frequency response of the Taylor window (100 dB)&quot;) 
    &gt;&gt;&gt; plt.ylabel(&quot;Normalized magnitude [dB]&quot;) 
    &gt;&gt;&gt; plt.xlabel(&quot;Normalized frequency [cycles per sample]&quot;) 
 
    &quot;&quot;&quot;  </span><span class="s6"># noqa: E501</span>
    <span class="s2">if </span><span class="s1">_len_guards</span><span class="s3">(</span><span class="s1">M</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">M</span><span class="s3">)</span>
    <span class="s1">M</span><span class="s3">, </span><span class="s1">needs_trunc </span><span class="s3">= </span><span class="s1">_extend</span><span class="s3">(</span><span class="s1">M</span><span class="s3">, </span><span class="s1">sym</span><span class="s3">)</span>

    <span class="s6"># Original text uses a negative sidelobe level parameter and then negates</span>
    <span class="s6"># it in the calculation of B. To keep consistent with other methods we</span>
    <span class="s6"># assume the sidelobe level parameter to be positive.</span>
    <span class="s1">B </span><span class="s3">= </span><span class="s5">10</span><span class="s3">**(</span><span class="s1">sll </span><span class="s3">/ </span><span class="s5">20</span><span class="s3">)</span>
    <span class="s1">A </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arccosh</span><span class="s3">(</span><span class="s1">B</span><span class="s3">) / </span><span class="s1">np</span><span class="s3">.</span><span class="s1">pi</span>
    <span class="s1">s2 </span><span class="s3">= </span><span class="s1">nbar</span><span class="s3">**</span><span class="s5">2 </span><span class="s3">/ (</span><span class="s1">A</span><span class="s3">**</span><span class="s5">2 </span><span class="s3">+ (</span><span class="s1">nbar </span><span class="s3">- </span><span class="s5">0.5</span><span class="s3">)**</span><span class="s5">2</span><span class="s3">)</span>
    <span class="s1">ma </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s5">1</span><span class="s3">, </span><span class="s1">nbar</span><span class="s3">)</span>

    <span class="s1">Fm </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">nbar</span><span class="s3">-</span><span class="s5">1</span><span class="s3">)</span>
    <span class="s1">signs </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty_like</span><span class="s3">(</span><span class="s1">ma</span><span class="s3">)</span>
    <span class="s1">signs</span><span class="s3">[::</span><span class="s5">2</span><span class="s3">] = </span><span class="s5">1</span>
    <span class="s1">signs</span><span class="s3">[</span><span class="s5">1</span><span class="s3">::</span><span class="s5">2</span><span class="s3">] = -</span><span class="s5">1</span>
    <span class="s1">m2 </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">*</span><span class="s1">ma</span>
    <span class="s2">for </span><span class="s1">mi</span><span class="s3">, </span><span class="s1">m </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">ma</span><span class="s3">):</span>
        <span class="s1">numer </span><span class="s3">= </span><span class="s1">signs</span><span class="s3">[</span><span class="s1">mi</span><span class="s3">] * </span><span class="s1">np</span><span class="s3">.</span><span class="s1">prod</span><span class="s3">(</span><span class="s5">1 </span><span class="s3">- </span><span class="s1">m2</span><span class="s3">[</span><span class="s1">mi</span><span class="s3">]/</span><span class="s1">s2</span><span class="s3">/(</span><span class="s1">A</span><span class="s3">**</span><span class="s5">2 </span><span class="s3">+ (</span><span class="s1">ma </span><span class="s3">- </span><span class="s5">0.5</span><span class="s3">)**</span><span class="s5">2</span><span class="s3">))</span>
        <span class="s1">denom </span><span class="s3">= </span><span class="s5">2 </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">prod</span><span class="s3">(</span><span class="s5">1 </span><span class="s3">- </span><span class="s1">m2</span><span class="s3">[</span><span class="s1">mi</span><span class="s3">]/</span><span class="s1">m2</span><span class="s3">[:</span><span class="s1">mi</span><span class="s3">]) * </span><span class="s1">np</span><span class="s3">.</span><span class="s1">prod</span><span class="s3">(</span><span class="s5">1 </span><span class="s3">- </span><span class="s1">m2</span><span class="s3">[</span><span class="s1">mi</span><span class="s3">]/</span><span class="s1">m2</span><span class="s3">[</span><span class="s1">mi</span><span class="s3">+</span><span class="s5">1</span><span class="s3">:])</span>
        <span class="s1">Fm</span><span class="s3">[</span><span class="s1">mi</span><span class="s3">] = </span><span class="s1">numer </span><span class="s3">/ </span><span class="s1">denom</span>

    <span class="s2">def </span><span class="s1">W</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s5">1 </span><span class="s3">+ </span><span class="s5">2</span><span class="s3">*</span><span class="s1">np</span><span class="s3">.</span><span class="s1">dot</span><span class="s3">(</span><span class="s1">Fm</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">cos</span><span class="s3">(</span>
            <span class="s5">2</span><span class="s3">*</span><span class="s1">np</span><span class="s3">.</span><span class="s1">pi</span><span class="s3">*</span><span class="s1">ma</span><span class="s3">[:, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">newaxis</span><span class="s3">]*(</span><span class="s1">n</span><span class="s3">-</span><span class="s1">M</span><span class="s3">/</span><span class="s5">2.</span><span class="s3">+</span><span class="s5">0.5</span><span class="s3">)/</span><span class="s1">M</span><span class="s3">))</span>

    <span class="s1">w </span><span class="s3">= </span><span class="s1">W</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s1">M</span><span class="s3">))</span>

    <span class="s6"># normalize (Note that this is not described in the original text [1])</span>
    <span class="s2">if </span><span class="s1">norm</span><span class="s3">:</span>
        <span class="s1">scale </span><span class="s3">= </span><span class="s5">1.0 </span><span class="s3">/ </span><span class="s1">W</span><span class="s3">((</span><span class="s1">M </span><span class="s3">- </span><span class="s5">1</span><span class="s3">) / </span><span class="s5">2</span><span class="s3">)</span>
        <span class="s1">w </span><span class="s3">*= </span><span class="s1">scale</span>

    <span class="s2">return </span><span class="s1">_truncate</span><span class="s3">(</span><span class="s1">w</span><span class="s3">, </span><span class="s1">needs_trunc</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">dpss</span><span class="s3">(</span><span class="s1">M</span><span class="s3">, </span><span class="s1">NW</span><span class="s3">, </span><span class="s1">Kmax</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">sym</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">norm</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">return_ratios</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Compute the Discrete Prolate Spheroidal Sequences (DPSS). 
 
    DPSS (or Slepian sequences) are often used in multitaper power spectral 
    density estimation (see [1]_). The first window in the sequence can be 
    used to maximize the energy concentration in the main lobe, and is also 
    called the Slepian window. 
 
    Parameters 
    ---------- 
    M : int 
        Window length. 
    NW : float 
        Standardized half bandwidth corresponding to ``2*NW = BW/f0 = BW*M*dt`` 
        where ``dt`` is taken as 1. 
    Kmax : int | None, optional 
        Number of DPSS windows to return (orders ``0`` through ``Kmax-1``). 
        If None (default), return only a single window of shape ``(M,)`` 
        instead of an array of windows of shape ``(Kmax, M)``. 
    sym : bool, optional 
        When True (default), generates a symmetric window, for use in filter 
        design. 
        When False, generates a periodic window, for use in spectral analysis. 
    norm : {2, 'approximate', 'subsample'} | None, optional 
        If 'approximate' or 'subsample', then the windows are normalized by the 
        maximum, and a correction scale-factor for even-length windows 
        is applied either using ``M**2/(M**2+NW)`` (&quot;approximate&quot;) or 
        a FFT-based subsample shift (&quot;subsample&quot;), see Notes for details. 
        If None, then &quot;approximate&quot; is used when ``Kmax=None`` and 2 otherwise 
        (which uses the l2 norm). 
    return_ratios : bool, optional 
        If True, also return the concentration ratios in addition to the 
        windows. 
 
    Returns 
    ------- 
    v : ndarray, shape (Kmax, M) or (M,) 
        The DPSS windows. Will be 1D if `Kmax` is None. 
    r : ndarray, shape (Kmax,) or float, optional 
        The concentration ratios for the windows. Only returned if 
        `return_ratios` evaluates to True. Will be 0D if `Kmax` is None. 
 
    Notes 
    ----- 
    This computation uses the tridiagonal eigenvector formulation given 
    in [2]_. 
 
    The default normalization for ``Kmax=None``, i.e. window-generation mode, 
    simply using the l-infinity norm would create a window with two unity 
    values, which creates slight normalization differences between even and odd 
    orders. The approximate correction of ``M**2/float(M**2+NW)`` for even 
    sample numbers is used to counteract this effect (see Examples below). 
 
    For very long signals (e.g., 1e6 elements), it can be useful to compute 
    windows orders of magnitude shorter and use interpolation (e.g., 
    `scipy.interpolate.interp1d`) to obtain tapers of length `M`, 
    but this in general will not preserve orthogonality between the tapers. 
 
    .. versionadded:: 1.1 
 
    References 
    ---------- 
    .. [1] Percival DB, Walden WT. Spectral Analysis for Physical Applications: 
       Multitaper and Conventional Univariate Techniques. 
       Cambridge University Press; 1993. 
    .. [2] Slepian, D. Prolate spheroidal wave functions, Fourier analysis, and 
       uncertainty V: The discrete case. Bell System Technical Journal, 
       Volume 57 (1978), 1371430. 
    .. [3] Kaiser, JF, Schafer RW. On the Use of the I0-Sinh Window for 
       Spectrum Analysis. IEEE Transactions on Acoustics, Speech and 
       Signal Processing. ASSP-28 (1): 105-107; 1980. 
 
    Examples 
    -------- 
    We can compare the window to `kaiser`, which was invented as an alternative 
    that was easier to calculate [3]_ (example adapted from 
    `here &lt;https://ccrma.stanford.edu/~jos/sasp/Kaiser_DPSS_Windows_Compared.html&gt;`_): 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; from scipy.signal import windows, freqz 
    &gt;&gt;&gt; M = 51 
    &gt;&gt;&gt; fig, axes = plt.subplots(3, 2, figsize=(5, 7)) 
    &gt;&gt;&gt; for ai, alpha in enumerate((1, 3, 5)): 
    ...     win_dpss = windows.dpss(M, alpha) 
    ...     beta = alpha*np.pi 
    ...     win_kaiser = windows.kaiser(M, beta) 
    ...     for win, c in ((win_dpss, 'k'), (win_kaiser, 'r')): 
    ...         win /= win.sum() 
    ...         axes[ai, 0].plot(win, color=c, lw=1.) 
    ...         axes[ai, 0].set(xlim=[0, M-1], title=r'$\\alpha$ = %s' % alpha, 
    ...                         ylabel='Amplitude') 
    ...         w, h = freqz(win) 
    ...         axes[ai, 1].plot(w, 20 * np.log10(np.abs(h)), color=c, lw=1.) 
    ...         axes[ai, 1].set(xlim=[0, np.pi], 
    ...                         title=r'$\\beta$ = %0.2f' % beta, 
    ...                         ylabel='Magnitude (dB)') 
    &gt;&gt;&gt; for ax in axes.ravel(): 
    ...     ax.grid(True) 
    &gt;&gt;&gt; axes[2, 1].legend(['DPSS', 'Kaiser']) 
    &gt;&gt;&gt; fig.tight_layout() 
    &gt;&gt;&gt; plt.show() 
 
    And here are examples of the first four windows, along with their 
    concentration ratios: 
 
    &gt;&gt;&gt; M = 512 
    &gt;&gt;&gt; NW = 2.5 
    &gt;&gt;&gt; win, eigvals = windows.dpss(M, NW, 4, return_ratios=True) 
    &gt;&gt;&gt; fig, ax = plt.subplots(1) 
    &gt;&gt;&gt; ax.plot(win.T, linewidth=1.) 
    &gt;&gt;&gt; ax.set(xlim=[0, M-1], ylim=[-0.1, 0.1], xlabel='Samples', 
    ...        title='DPSS, M=%d, NW=%0.1f' % (M, NW)) 
    &gt;&gt;&gt; ax.legend(['win[%d] (%0.4f)' % (ii, ratio) 
    ...            for ii, ratio in enumerate(eigvals)]) 
    &gt;&gt;&gt; fig.tight_layout() 
    &gt;&gt;&gt; plt.show() 
 
    Using a standard :math:`l_{\\infty}` norm would produce two unity values 
    for even `M`, but only one unity value for odd `M`. This produces uneven 
    window power that can be counteracted by the approximate correction 
    ``M**2/float(M**2+NW)``, which can be selected by using 
    ``norm='approximate'`` (which is the same as ``norm=None`` when 
    ``Kmax=None``, as is the case here). Alternatively, the slower 
    ``norm='subsample'`` can be used, which uses subsample shifting in the 
    frequency domain (FFT) to compute the correction: 
 
    &gt;&gt;&gt; Ms = np.arange(1, 41) 
    &gt;&gt;&gt; factors = (50, 20, 10, 5, 2.0001) 
    &gt;&gt;&gt; energy = np.empty((3, len(Ms), len(factors))) 
    &gt;&gt;&gt; for mi, M in enumerate(Ms): 
    ...     for fi, factor in enumerate(factors): 
    ...         NW = M / float(factor) 
    ...         # Corrected using empirical approximation (default) 
    ...         win = windows.dpss(M, NW) 
    ...         energy[0, mi, fi] = np.sum(win ** 2) / np.sqrt(M) 
    ...         # Corrected using subsample shifting 
    ...         win = windows.dpss(M, NW, norm='subsample') 
    ...         energy[1, mi, fi] = np.sum(win ** 2) / np.sqrt(M) 
    ...         # Uncorrected (using l-infinity norm) 
    ...         win /= win.max() 
    ...         energy[2, mi, fi] = np.sum(win ** 2) / np.sqrt(M) 
    &gt;&gt;&gt; fig, ax = plt.subplots(1) 
    &gt;&gt;&gt; hs = ax.plot(Ms, energy[2], '-o', markersize=4, 
    ...              markeredgecolor='none') 
    &gt;&gt;&gt; leg = [hs[-1]] 
    &gt;&gt;&gt; for hi, hh in enumerate(hs): 
    ...     h1 = ax.plot(Ms, energy[0, :, hi], '-o', markersize=4, 
    ...                  color=hh.get_color(), markeredgecolor='none', 
    ...                  alpha=0.66) 
    ...     h2 = ax.plot(Ms, energy[1, :, hi], '-o', markersize=4, 
    ...                  color=hh.get_color(), markeredgecolor='none', 
    ...                  alpha=0.33) 
    ...     if hi == len(hs) - 1: 
    ...         leg.insert(0, h1[0]) 
    ...         leg.insert(0, h2[0]) 
    &gt;&gt;&gt; ax.set(xlabel='M (samples)', ylabel=r'Power / $\\sqrt{M}$') 
    &gt;&gt;&gt; ax.legend(leg, ['Uncorrected', r'Corrected: $\\frac{M^2}{M^2+NW}$', 
    ...                 'Corrected (subsample)']) 
    &gt;&gt;&gt; fig.tight_layout() 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">_len_guards</span><span class="s3">(</span><span class="s1">M</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">M</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">norm </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">norm </span><span class="s3">= </span><span class="s4">'approximate' </span><span class="s2">if </span><span class="s1">Kmax </span><span class="s2">is None else </span><span class="s5">2</span>
    <span class="s1">known_norms </span><span class="s3">= (</span><span class="s5">2</span><span class="s3">, </span><span class="s4">'approximate'</span><span class="s3">, </span><span class="s4">'subsample'</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">norm </span><span class="s2">not in </span><span class="s1">known_norms</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">f'norm must be one of </span><span class="s2">{</span><span class="s1">known_norms</span><span class="s2">}</span><span class="s4">, got </span><span class="s2">{</span><span class="s1">norm</span><span class="s2">}</span><span class="s4">'</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">Kmax </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">singleton </span><span class="s3">= </span><span class="s2">True</span>
        <span class="s1">Kmax </span><span class="s3">= </span><span class="s5">1</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">singleton </span><span class="s3">= </span><span class="s2">False</span>
    <span class="s1">Kmax </span><span class="s3">= </span><span class="s1">operator</span><span class="s3">.</span><span class="s1">index</span><span class="s3">(</span><span class="s1">Kmax</span><span class="s3">)</span>
    <span class="s2">if not </span><span class="s5">0 </span><span class="s3">&lt; </span><span class="s1">Kmax </span><span class="s3">&lt;= </span><span class="s1">M</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'Kmax must be greater than 0 and less than M'</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">NW </span><span class="s3">&gt;= </span><span class="s1">M</span><span class="s3">/</span><span class="s5">2.</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'NW must be less than M/2.'</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">NW </span><span class="s3">&lt;= </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'NW must be positive'</span><span class="s3">)</span>
    <span class="s1">M</span><span class="s3">, </span><span class="s1">needs_trunc </span><span class="s3">= </span><span class="s1">_extend</span><span class="s3">(</span><span class="s1">M</span><span class="s3">, </span><span class="s1">sym</span><span class="s3">)</span>
    <span class="s1">W </span><span class="s3">= </span><span class="s1">float</span><span class="s3">(</span><span class="s1">NW</span><span class="s3">) / </span><span class="s1">M</span>
    <span class="s1">nidx </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s1">M</span><span class="s3">)</span>

    <span class="s6"># Here we want to set up an optimization problem to find a sequence</span>
    <span class="s6"># whose energy is maximally concentrated within band [-W,W].</span>
    <span class="s6"># Thus, the measure lambda(T,W) is the ratio between the energy within</span>
    <span class="s6"># that band, and the total energy. This leads to the eigen-system</span>
    <span class="s6"># (A - (l1)I)v = 0, where the eigenvector corresponding to the largest</span>
    <span class="s6"># eigenvalue is the sequence with maximally concentrated energy. The</span>
    <span class="s6"># collection of eigenvectors of this system are called Slepian</span>
    <span class="s6"># sequences, or discrete prolate spheroidal sequences (DPSS). Only the</span>
    <span class="s6"># first K, K = 2NW/dt orders of DPSS will exhibit good spectral</span>
    <span class="s6"># concentration</span>
    <span class="s6"># [see https://en.wikipedia.org/wiki/Spectral_concentration_problem]</span>

    <span class="s6"># Here we set up an alternative symmetric tri-diagonal eigenvalue</span>
    <span class="s6"># problem such that</span>
    <span class="s6"># (B - (l2)I)v = 0, and v are our DPSS (but eigenvalues l2 != l1)</span>
    <span class="s6"># the main diagonal = ([M-1-2*t]/2)**2 cos(2PIW), t=[0,1,2,...,M-1]</span>
    <span class="s6"># and the first off-diagonal = t(M-t)/2, t=[1,2,...,M-1]</span>
    <span class="s6"># [see Percival and Walden, 1993]</span>
    <span class="s1">d </span><span class="s3">= ((</span><span class="s1">M </span><span class="s3">- </span><span class="s5">1 </span><span class="s3">- </span><span class="s5">2 </span><span class="s3">* </span><span class="s1">nidx</span><span class="s3">) / </span><span class="s5">2.</span><span class="s3">) ** </span><span class="s5">2 </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">cos</span><span class="s3">(</span><span class="s5">2 </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">pi </span><span class="s3">* </span><span class="s1">W</span><span class="s3">)</span>
    <span class="s1">e </span><span class="s3">= </span><span class="s1">nidx</span><span class="s3">[</span><span class="s5">1</span><span class="s3">:] * (</span><span class="s1">M </span><span class="s3">- </span><span class="s1">nidx</span><span class="s3">[</span><span class="s5">1</span><span class="s3">:]) / </span><span class="s5">2.</span>

    <span class="s6"># only calculate the highest Kmax eigenvalues</span>
    <span class="s1">w</span><span class="s3">, </span><span class="s1">windows </span><span class="s3">= </span><span class="s1">linalg</span><span class="s3">.</span><span class="s1">eigh_tridiagonal</span><span class="s3">(</span>
        <span class="s1">d</span><span class="s3">, </span><span class="s1">e</span><span class="s3">, </span><span class="s1">select</span><span class="s3">=</span><span class="s4">'i'</span><span class="s3">, </span><span class="s1">select_range</span><span class="s3">=(</span><span class="s1">M </span><span class="s3">- </span><span class="s1">Kmax</span><span class="s3">, </span><span class="s1">M </span><span class="s3">- </span><span class="s5">1</span><span class="s3">))</span>
    <span class="s1">w </span><span class="s3">= </span><span class="s1">w</span><span class="s3">[::-</span><span class="s5">1</span><span class="s3">]</span>
    <span class="s1">windows </span><span class="s3">= </span><span class="s1">windows</span><span class="s3">[:, ::-</span><span class="s5">1</span><span class="s3">].</span><span class="s1">T</span>

    <span class="s6"># By convention (Percival and Walden, 1993 pg 379)</span>
    <span class="s6"># * symmetric tapers (k=0,2,4,...) should have a positive average.</span>
    <span class="s1">fix_even </span><span class="s3">= (</span><span class="s1">windows</span><span class="s3">[::</span><span class="s5">2</span><span class="s3">].</span><span class="s1">sum</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">=</span><span class="s5">1</span><span class="s3">) &lt; </span><span class="s5">0</span><span class="s3">)</span>
    <span class="s2">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">f </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">fix_even</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">f</span><span class="s3">:</span>
            <span class="s1">windows</span><span class="s3">[</span><span class="s5">2 </span><span class="s3">* </span><span class="s1">i</span><span class="s3">] *= -</span><span class="s5">1</span>
    <span class="s6"># * antisymmetric tapers should begin with a positive lobe</span>
    <span class="s6">#   (this depends on the definition of &quot;lobe&quot;, here we'll take the first</span>
    <span class="s6">#   point above the numerical noise, which should be good enough for</span>
    <span class="s6">#   sufficiently smooth functions, and more robust than relying on an</span>
    <span class="s6">#   algorithm that uses max(abs(w)), which is susceptible to numerical</span>
    <span class="s6">#   noise problems)</span>
    <span class="s1">thresh </span><span class="s3">= </span><span class="s1">max</span><span class="s3">(</span><span class="s5">1e-7</span><span class="s3">, </span><span class="s5">1. </span><span class="s3">/ </span><span class="s1">M</span><span class="s3">)</span>
    <span class="s2">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">w </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">windows</span><span class="s3">[</span><span class="s5">1</span><span class="s3">::</span><span class="s5">2</span><span class="s3">]):</span>
        <span class="s2">if </span><span class="s1">w</span><span class="s3">[</span><span class="s1">w </span><span class="s3">* </span><span class="s1">w </span><span class="s3">&gt; </span><span class="s1">thresh</span><span class="s3">][</span><span class="s5">0</span><span class="s3">] &lt; </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s1">windows</span><span class="s3">[</span><span class="s5">2 </span><span class="s3">* </span><span class="s1">i </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">] *= -</span><span class="s5">1</span>

    <span class="s6"># Now find the eigenvalues of the original spectral concentration problem</span>
    <span class="s6"># Use the autocorr sequence technique from Percival and Walden, 1993 pg 390</span>
    <span class="s2">if </span><span class="s1">return_ratios</span><span class="s3">:</span>
        <span class="s1">dpss_rxx </span><span class="s3">= </span><span class="s1">_fftautocorr</span><span class="s3">(</span><span class="s1">windows</span><span class="s3">)</span>
        <span class="s1">r </span><span class="s3">= </span><span class="s5">4 </span><span class="s3">* </span><span class="s1">W </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sinc</span><span class="s3">(</span><span class="s5">2 </span><span class="s3">* </span><span class="s1">W </span><span class="s3">* </span><span class="s1">nidx</span><span class="s3">)</span>
        <span class="s1">r</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] = </span><span class="s5">2 </span><span class="s3">* </span><span class="s1">W</span>
        <span class="s1">ratios </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">dot</span><span class="s3">(</span><span class="s1">dpss_rxx</span><span class="s3">, </span><span class="s1">r</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">singleton</span><span class="s3">:</span>
            <span class="s1">ratios </span><span class="s3">= </span><span class="s1">ratios</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
    <span class="s6"># Deal with sym and Kmax=None</span>
    <span class="s2">if </span><span class="s1">norm </span><span class="s3">!= </span><span class="s5">2</span><span class="s3">:</span>
        <span class="s1">windows </span><span class="s3">/= </span><span class="s1">windows</span><span class="s3">.</span><span class="s1">max</span><span class="s3">()</span>
        <span class="s2">if </span><span class="s1">M </span><span class="s3">% </span><span class="s5">2 </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">norm </span><span class="s3">== </span><span class="s4">'approximate'</span><span class="s3">:</span>
                <span class="s1">correction </span><span class="s3">= </span><span class="s1">M</span><span class="s3">**</span><span class="s5">2 </span><span class="s3">/ </span><span class="s1">float</span><span class="s3">(</span><span class="s1">M</span><span class="s3">**</span><span class="s5">2 </span><span class="s3">+ </span><span class="s1">NW</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">s </span><span class="s3">= </span><span class="s1">sp_fft</span><span class="s3">.</span><span class="s1">rfft</span><span class="s3">(</span><span class="s1">windows</span><span class="s3">[</span><span class="s5">0</span><span class="s3">])</span>
                <span class="s1">shift </span><span class="s3">= -(</span><span class="s5">1 </span><span class="s3">- </span><span class="s5">1.</span><span class="s3">/</span><span class="s1">M</span><span class="s3">) * </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s5">1</span><span class="s3">, </span><span class="s1">M</span><span class="s3">//</span><span class="s5">2 </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">)</span>
                <span class="s1">s</span><span class="s3">[</span><span class="s5">1</span><span class="s3">:] *= </span><span class="s5">2 </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">exp</span><span class="s3">(-</span><span class="s5">1j </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">pi </span><span class="s3">* </span><span class="s1">shift</span><span class="s3">)</span>
                <span class="s1">correction </span><span class="s3">= </span><span class="s1">M </span><span class="s3">/ </span><span class="s1">s</span><span class="s3">.</span><span class="s1">real</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">()</span>
            <span class="s1">windows </span><span class="s3">*= </span><span class="s1">correction</span>
    <span class="s6"># else we're already l2 normed, so do nothing</span>
    <span class="s2">if </span><span class="s1">needs_trunc</span><span class="s3">:</span>
        <span class="s1">windows </span><span class="s3">= </span><span class="s1">windows</span><span class="s3">[:, :-</span><span class="s5">1</span><span class="s3">]</span>
    <span class="s2">if </span><span class="s1">singleton</span><span class="s3">:</span>
        <span class="s1">windows </span><span class="s3">= </span><span class="s1">windows</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
    <span class="s2">return </span><span class="s3">(</span><span class="s1">windows</span><span class="s3">, </span><span class="s1">ratios</span><span class="s3">) </span><span class="s2">if </span><span class="s1">return_ratios </span><span class="s2">else </span><span class="s1">windows</span>


<span class="s2">def </span><span class="s1">lanczos</span><span class="s3">(</span><span class="s1">M</span><span class="s3">, *, </span><span class="s1">sym</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
    <span class="s0">r&quot;&quot;&quot;Return a Lanczos window also known as a sinc window. 
 
    Parameters 
    ---------- 
    M : int 
        Number of points in the output window. If zero, an empty array 
        is returned. An exception is thrown when it is negative. 
    sym : bool, optional 
        When True (default), generates a symmetric window, for use in filter 
        design. 
        When False, generates a periodic window, for use in spectral analysis. 
 
    Returns 
    ------- 
    w : ndarray 
        The window, with the maximum value normalized to 1 (though the value 1 
        does not appear if `M` is even and `sym` is True). 
 
    Notes 
    ----- 
    The Lanczos window is defined as 
 
    .. math::  w(n) = sinc \left( \frac{2n}{M - 1} - 1 \right) 
 
    where 
 
    .. math::  sinc(x) = \frac{\sin(\pi x)}{\pi x} 
 
    The Lanczos window has reduced Gibbs oscillations and is widely used for 
    filtering climate timeseries with good properties in the physical and 
    spectral domains. 
 
    .. versionadded:: 1.10 
 
    References 
    ---------- 
    .. [1] Lanczos, C., and Teichmann, T. (1957). Applied analysis. 
           Physics Today, 10, 44. 
    .. [2] Duchon C. E. (1979) Lanczos Filtering in One and Two Dimensions. 
           Journal of Applied Meteorology, Vol 18, pp 1016-1022. 
    .. [3] Thomson, R. E. and Emery, W. J. (2014) Data Analysis Methods in 
           Physical Oceanography (Third Edition), Elsevier, pp 593-637. 
    .. [4] Wikipedia, &quot;Window function&quot;, 
           http://en.wikipedia.org/wiki/Window_function 
 
    Examples 
    -------- 
    Plot the window 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.signal.windows import lanczos 
    &gt;&gt;&gt; from scipy.fft import fft, fftshift 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; fig, ax = plt.subplots(1) 
    &gt;&gt;&gt; window = lanczos(51) 
    &gt;&gt;&gt; ax.plot(window) 
    &gt;&gt;&gt; ax.set_title(&quot;Lanczos window&quot;) 
    &gt;&gt;&gt; ax.set_ylabel(&quot;Amplitude&quot;) 
    &gt;&gt;&gt; ax.set_xlabel(&quot;Sample&quot;) 
    &gt;&gt;&gt; fig.tight_layout() 
    &gt;&gt;&gt; plt.show() 
 
    and its frequency response: 
 
    &gt;&gt;&gt; fig, ax = plt.subplots(1) 
    &gt;&gt;&gt; A = fft(window, 2048) / (len(window)/2.0) 
    &gt;&gt;&gt; freq = np.linspace(-0.5, 0.5, len(A)) 
    &gt;&gt;&gt; response = 20 * np.log10(np.abs(fftshift(A / abs(A).max()))) 
    &gt;&gt;&gt; ax.plot(freq, response) 
    &gt;&gt;&gt; ax.set_xlim(-0.5, 0.5) 
    &gt;&gt;&gt; ax.set_ylim(-120, 0) 
    &gt;&gt;&gt; ax.set_title(&quot;Frequency response of the lanczos window&quot;) 
    &gt;&gt;&gt; ax.set_ylabel(&quot;Normalized magnitude [dB]&quot;) 
    &gt;&gt;&gt; ax.set_xlabel(&quot;Normalized frequency [cycles per sample]&quot;) 
    &gt;&gt;&gt; fig.tight_layout() 
    &gt;&gt;&gt; plt.show() 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">_len_guards</span><span class="s3">(</span><span class="s1">M</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">M</span><span class="s3">)</span>
    <span class="s1">M</span><span class="s3">, </span><span class="s1">needs_trunc </span><span class="s3">= </span><span class="s1">_extend</span><span class="s3">(</span><span class="s1">M</span><span class="s3">, </span><span class="s1">sym</span><span class="s3">)</span>

    <span class="s6"># To make sure that the window is symmetric, we concatenate the right hand</span>
    <span class="s6"># half of the window and the flipped one which is the left hand half of</span>
    <span class="s6"># the window.</span>
    <span class="s2">def </span><span class="s1">_calc_right_side_lanczos</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">m</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sinc</span><span class="s3">(</span><span class="s5">2. </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">m</span><span class="s3">) / (</span><span class="s1">m </span><span class="s3">- </span><span class="s5">1</span><span class="s3">) - </span><span class="s5">1.0</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">M </span><span class="s3">% </span><span class="s5">2 </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s1">wh </span><span class="s3">= </span><span class="s1">_calc_right_side_lanczos</span><span class="s3">(</span><span class="s1">M</span><span class="s3">/</span><span class="s5">2</span><span class="s3">, </span><span class="s1">M</span><span class="s3">)</span>
        <span class="s1">w </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">r_</span><span class="s3">[</span><span class="s1">np</span><span class="s3">.</span><span class="s1">flip</span><span class="s3">(</span><span class="s1">wh</span><span class="s3">), </span><span class="s1">wh</span><span class="s3">]</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">wh </span><span class="s3">= </span><span class="s1">_calc_right_side_lanczos</span><span class="s3">((</span><span class="s1">M</span><span class="s3">+</span><span class="s5">1</span><span class="s3">)/</span><span class="s5">2</span><span class="s3">, </span><span class="s1">M</span><span class="s3">)</span>
        <span class="s1">w </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">r_</span><span class="s3">[</span><span class="s1">np</span><span class="s3">.</span><span class="s1">flip</span><span class="s3">(</span><span class="s1">wh</span><span class="s3">), </span><span class="s5">1.0</span><span class="s3">, </span><span class="s1">wh</span><span class="s3">]</span>

    <span class="s2">return </span><span class="s1">_truncate</span><span class="s3">(</span><span class="s1">w</span><span class="s3">, </span><span class="s1">needs_trunc</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">_fftautocorr</span><span class="s3">(</span><span class="s1">x</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Compute the autocorrelation of a real array and crop the result.&quot;&quot;&quot;</span>
    <span class="s1">N </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">]</span>
    <span class="s1">use_N </span><span class="s3">= </span><span class="s1">sp_fft</span><span class="s3">.</span><span class="s1">next_fast_len</span><span class="s3">(</span><span class="s5">2</span><span class="s3">*</span><span class="s1">N</span><span class="s3">-</span><span class="s5">1</span><span class="s3">)</span>
    <span class="s1">x_fft </span><span class="s3">= </span><span class="s1">sp_fft</span><span class="s3">.</span><span class="s1">rfft</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">use_N</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=-</span><span class="s5">1</span><span class="s3">)</span>
    <span class="s1">cxy </span><span class="s3">= </span><span class="s1">sp_fft</span><span class="s3">.</span><span class="s1">irfft</span><span class="s3">(</span><span class="s1">x_fft </span><span class="s3">* </span><span class="s1">x_fft</span><span class="s3">.</span><span class="s1">conj</span><span class="s3">(), </span><span class="s1">n</span><span class="s3">=</span><span class="s1">use_N</span><span class="s3">)[:, :</span><span class="s1">N</span><span class="s3">]</span>
    <span class="s6"># Or equivalently (but in most cases slower):</span>
    <span class="s6"># cxy = np.array([np.convolve(xx, yy[::-1], mode='full')</span>
    <span class="s6">#                 for xx, yy in zip(x, x)])[:, N-1:2*N-1]</span>
    <span class="s2">return </span><span class="s1">cxy</span>


<span class="s1">_win_equiv_raw </span><span class="s3">= {</span>
    <span class="s3">(</span><span class="s4">'barthann'</span><span class="s3">, </span><span class="s4">'brthan'</span><span class="s3">, </span><span class="s4">'bth'</span><span class="s3">): (</span><span class="s1">barthann</span><span class="s3">, </span><span class="s2">False</span><span class="s3">),</span>
    <span class="s3">(</span><span class="s4">'bartlett'</span><span class="s3">, </span><span class="s4">'bart'</span><span class="s3">, </span><span class="s4">'brt'</span><span class="s3">): (</span><span class="s1">bartlett</span><span class="s3">, </span><span class="s2">False</span><span class="s3">),</span>
    <span class="s3">(</span><span class="s4">'blackman'</span><span class="s3">, </span><span class="s4">'black'</span><span class="s3">, </span><span class="s4">'blk'</span><span class="s3">): (</span><span class="s1">blackman</span><span class="s3">, </span><span class="s2">False</span><span class="s3">),</span>
    <span class="s3">(</span><span class="s4">'blackmanharris'</span><span class="s3">, </span><span class="s4">'blackharr'</span><span class="s3">, </span><span class="s4">'bkh'</span><span class="s3">): (</span><span class="s1">blackmanharris</span><span class="s3">, </span><span class="s2">False</span><span class="s3">),</span>
    <span class="s3">(</span><span class="s4">'bohman'</span><span class="s3">, </span><span class="s4">'bman'</span><span class="s3">, </span><span class="s4">'bmn'</span><span class="s3">): (</span><span class="s1">bohman</span><span class="s3">, </span><span class="s2">False</span><span class="s3">),</span>
    <span class="s3">(</span><span class="s4">'boxcar'</span><span class="s3">, </span><span class="s4">'box'</span><span class="s3">, </span><span class="s4">'ones'</span><span class="s3">,</span>
        <span class="s4">'rect'</span><span class="s3">, </span><span class="s4">'rectangular'</span><span class="s3">): (</span><span class="s1">boxcar</span><span class="s3">, </span><span class="s2">False</span><span class="s3">),</span>
    <span class="s3">(</span><span class="s4">'chebwin'</span><span class="s3">, </span><span class="s4">'cheb'</span><span class="s3">): (</span><span class="s1">chebwin</span><span class="s3">, </span><span class="s2">True</span><span class="s3">),</span>
    <span class="s3">(</span><span class="s4">'cosine'</span><span class="s3">, </span><span class="s4">'halfcosine'</span><span class="s3">): (</span><span class="s1">cosine</span><span class="s3">, </span><span class="s2">False</span><span class="s3">),</span>
    <span class="s3">(</span><span class="s4">'dpss'</span><span class="s3">,): (</span><span class="s1">dpss</span><span class="s3">, </span><span class="s2">True</span><span class="s3">),</span>
    <span class="s3">(</span><span class="s4">'exponential'</span><span class="s3">, </span><span class="s4">'poisson'</span><span class="s3">): (</span><span class="s1">exponential</span><span class="s3">, </span><span class="s2">False</span><span class="s3">),</span>
    <span class="s3">(</span><span class="s4">'flattop'</span><span class="s3">, </span><span class="s4">'flat'</span><span class="s3">, </span><span class="s4">'flt'</span><span class="s3">): (</span><span class="s1">flattop</span><span class="s3">, </span><span class="s2">False</span><span class="s3">),</span>
    <span class="s3">(</span><span class="s4">'gaussian'</span><span class="s3">, </span><span class="s4">'gauss'</span><span class="s3">, </span><span class="s4">'gss'</span><span class="s3">): (</span><span class="s1">gaussian</span><span class="s3">, </span><span class="s2">True</span><span class="s3">),</span>
    <span class="s3">(</span><span class="s4">'general cosine'</span><span class="s3">, </span><span class="s4">'general_cosine'</span><span class="s3">): (</span><span class="s1">general_cosine</span><span class="s3">, </span><span class="s2">True</span><span class="s3">),</span>
    <span class="s3">(</span><span class="s4">'general gaussian'</span><span class="s3">, </span><span class="s4">'general_gaussian'</span><span class="s3">,</span>
        <span class="s4">'general gauss'</span><span class="s3">, </span><span class="s4">'general_gauss'</span><span class="s3">, </span><span class="s4">'ggs'</span><span class="s3">): (</span><span class="s1">general_gaussian</span><span class="s3">, </span><span class="s2">True</span><span class="s3">),</span>
    <span class="s3">(</span><span class="s4">'general hamming'</span><span class="s3">, </span><span class="s4">'general_hamming'</span><span class="s3">): (</span><span class="s1">general_hamming</span><span class="s3">, </span><span class="s2">True</span><span class="s3">),</span>
    <span class="s3">(</span><span class="s4">'hamming'</span><span class="s3">, </span><span class="s4">'hamm'</span><span class="s3">, </span><span class="s4">'ham'</span><span class="s3">): (</span><span class="s1">hamming</span><span class="s3">, </span><span class="s2">False</span><span class="s3">),</span>
    <span class="s3">(</span><span class="s4">'hann'</span><span class="s3">, </span><span class="s4">'han'</span><span class="s3">): (</span><span class="s1">hann</span><span class="s3">, </span><span class="s2">False</span><span class="s3">),</span>
    <span class="s3">(</span><span class="s4">'kaiser'</span><span class="s3">, </span><span class="s4">'ksr'</span><span class="s3">): (</span><span class="s1">kaiser</span><span class="s3">, </span><span class="s2">True</span><span class="s3">),</span>
    <span class="s3">(</span><span class="s4">'kaiser bessel derived'</span><span class="s3">, </span><span class="s4">'kbd'</span><span class="s3">): (</span><span class="s1">kaiser_bessel_derived</span><span class="s3">, </span><span class="s2">True</span><span class="s3">),</span>
    <span class="s3">(</span><span class="s4">'lanczos'</span><span class="s3">, </span><span class="s4">'sinc'</span><span class="s3">): (</span><span class="s1">lanczos</span><span class="s3">, </span><span class="s2">False</span><span class="s3">),</span>
    <span class="s3">(</span><span class="s4">'nuttall'</span><span class="s3">, </span><span class="s4">'nutl'</span><span class="s3">, </span><span class="s4">'nut'</span><span class="s3">): (</span><span class="s1">nuttall</span><span class="s3">, </span><span class="s2">False</span><span class="s3">),</span>
    <span class="s3">(</span><span class="s4">'parzen'</span><span class="s3">, </span><span class="s4">'parz'</span><span class="s3">, </span><span class="s4">'par'</span><span class="s3">): (</span><span class="s1">parzen</span><span class="s3">, </span><span class="s2">False</span><span class="s3">),</span>
    <span class="s3">(</span><span class="s4">'taylor'</span><span class="s3">, </span><span class="s4">'taylorwin'</span><span class="s3">): (</span><span class="s1">taylor</span><span class="s3">, </span><span class="s2">False</span><span class="s3">),</span>
    <span class="s3">(</span><span class="s4">'triangle'</span><span class="s3">, </span><span class="s4">'triang'</span><span class="s3">, </span><span class="s4">'tri'</span><span class="s3">): (</span><span class="s1">triang</span><span class="s3">, </span><span class="s2">False</span><span class="s3">),</span>
    <span class="s3">(</span><span class="s4">'tukey'</span><span class="s3">, </span><span class="s4">'tuk'</span><span class="s3">): (</span><span class="s1">tukey</span><span class="s3">, </span><span class="s2">False</span><span class="s3">),</span>
<span class="s3">}</span>

<span class="s6"># Fill dict with all valid window name strings</span>
<span class="s1">_win_equiv </span><span class="s3">= {}</span>
<span class="s2">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">_win_equiv_raw</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
    <span class="s2">for </span><span class="s1">key </span><span class="s2">in </span><span class="s1">k</span><span class="s3">:</span>
        <span class="s1">_win_equiv</span><span class="s3">[</span><span class="s1">key</span><span class="s3">] = </span><span class="s1">v</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>

<span class="s6"># Keep track of which windows need additional parameters</span>
<span class="s1">_needs_param </span><span class="s3">= </span><span class="s1">set</span><span class="s3">()</span>
<span class="s2">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">_win_equiv_raw</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
    <span class="s2">if </span><span class="s1">v</span><span class="s3">[</span><span class="s5">1</span><span class="s3">]:</span>
        <span class="s1">_needs_param</span><span class="s3">.</span><span class="s1">update</span><span class="s3">(</span><span class="s1">k</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">get_window</span><span class="s3">(</span><span class="s1">window</span><span class="s3">, </span><span class="s1">Nx</span><span class="s3">, </span><span class="s1">fftbins</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return a window of a given length and type. 
 
    Parameters 
    ---------- 
    window : string, float, or tuple 
        The type of window to create. See below for more details. 
    Nx : int 
        The number of samples in the window. 
    fftbins : bool, optional 
        If True (default), create a &quot;periodic&quot; window, ready to use with 
        `ifftshift` and be multiplied by the result of an FFT (see also 
        :func:`~scipy.fft.fftfreq`). 
        If False, create a &quot;symmetric&quot; window, for use in filter design. 
 
    Returns 
    ------- 
    get_window : ndarray 
        Returns a window of length `Nx` and type `window` 
 
    Notes 
    ----- 
    Window types: 
 
    - `~scipy.signal.windows.boxcar` 
    - `~scipy.signal.windows.triang` 
    - `~scipy.signal.windows.blackman` 
    - `~scipy.signal.windows.hamming` 
    - `~scipy.signal.windows.hann` 
    - `~scipy.signal.windows.bartlett` 
    - `~scipy.signal.windows.flattop` 
    - `~scipy.signal.windows.parzen` 
    - `~scipy.signal.windows.bohman` 
    - `~scipy.signal.windows.blackmanharris` 
    - `~scipy.signal.windows.nuttall` 
    - `~scipy.signal.windows.barthann` 
    - `~scipy.signal.windows.cosine` 
    - `~scipy.signal.windows.exponential` 
    - `~scipy.signal.windows.tukey` 
    - `~scipy.signal.windows.taylor` 
    - `~scipy.signal.windows.lanczos` 
    - `~scipy.signal.windows.kaiser` (needs beta) 
    - `~scipy.signal.windows.kaiser_bessel_derived` (needs beta) 
    - `~scipy.signal.windows.gaussian` (needs standard deviation) 
    - `~scipy.signal.windows.general_cosine` (needs weighting coefficients) 
    - `~scipy.signal.windows.general_gaussian` (needs power, width) 
    - `~scipy.signal.windows.general_hamming` (needs window coefficient) 
    - `~scipy.signal.windows.dpss` (needs normalized half-bandwidth) 
    - `~scipy.signal.windows.chebwin` (needs attenuation) 
 
 
    If the window requires no parameters, then `window` can be a string. 
 
    If the window requires parameters, then `window` must be a tuple 
    with the first argument the string name of the window, and the next 
    arguments the needed parameters. 
 
    If `window` is a floating point number, it is interpreted as the beta 
    parameter of the `~scipy.signal.windows.kaiser` window. 
 
    Each of the window types listed above is also the name of 
    a function that can be called directly to create a window of 
    that type. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy import signal 
    &gt;&gt;&gt; signal.get_window('triang', 7) 
    array([ 0.125,  0.375,  0.625,  0.875,  0.875,  0.625,  0.375]) 
    &gt;&gt;&gt; signal.get_window(('kaiser', 4.0), 9) 
    array([ 0.08848053,  0.29425961,  0.56437221,  0.82160913,  0.97885093, 
            0.97885093,  0.82160913,  0.56437221,  0.29425961]) 
    &gt;&gt;&gt; signal.get_window(('exponential', None, 1.), 9) 
    array([ 0.011109  ,  0.03019738,  0.082085  ,  0.22313016,  0.60653066, 
            0.60653066,  0.22313016,  0.082085  ,  0.03019738]) 
    &gt;&gt;&gt; signal.get_window(4.0, 9) 
    array([ 0.08848053,  0.29425961,  0.56437221,  0.82160913,  0.97885093, 
            0.97885093,  0.82160913,  0.56437221,  0.29425961]) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">sym </span><span class="s3">= </span><span class="s2">not </span><span class="s1">fftbins</span>
    <span class="s2">try</span><span class="s3">:</span>
        <span class="s1">beta </span><span class="s3">= </span><span class="s1">float</span><span class="s3">(</span><span class="s1">window</span><span class="s3">)</span>
    <span class="s2">except </span><span class="s3">(</span><span class="s1">TypeError</span><span class="s3">, </span><span class="s1">ValueError</span><span class="s3">) </span><span class="s2">as </span><span class="s1">e</span><span class="s3">:</span>
        <span class="s1">args </span><span class="s3">= ()</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">window</span><span class="s3">, </span><span class="s1">tuple</span><span class="s3">):</span>
            <span class="s1">winstr </span><span class="s3">= </span><span class="s1">window</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
            <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">window</span><span class="s3">) &gt; </span><span class="s5">1</span><span class="s3">:</span>
                <span class="s1">args </span><span class="s3">= </span><span class="s1">window</span><span class="s3">[</span><span class="s5">1</span><span class="s3">:]</span>
        <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">window</span><span class="s3">, </span><span class="s1">str</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">window </span><span class="s2">in </span><span class="s1">_needs_param</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;The '&quot; </span><span class="s3">+ </span><span class="s1">window </span><span class="s3">+ </span><span class="s4">&quot;' window needs one or &quot;</span>
                                 <span class="s4">&quot;more parameters -- pass a tuple.&quot;</span><span class="s3">) </span><span class="s2">from </span><span class="s1">e</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">winstr </span><span class="s3">= </span><span class="s1">window</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;%s as window type is not supported.&quot; </span><span class="s3">%</span>
                             <span class="s1">str</span><span class="s3">(</span><span class="s1">type</span><span class="s3">(</span><span class="s1">window</span><span class="s3">))) </span><span class="s2">from </span><span class="s1">e</span>

        <span class="s2">try</span><span class="s3">:</span>
            <span class="s1">winfunc </span><span class="s3">= </span><span class="s1">_win_equiv</span><span class="s3">[</span><span class="s1">winstr</span><span class="s3">]</span>
        <span class="s2">except </span><span class="s1">KeyError </span><span class="s2">as </span><span class="s1">e</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Unknown window type.&quot;</span><span class="s3">) </span><span class="s2">from </span><span class="s1">e</span>

        <span class="s2">if </span><span class="s1">winfunc </span><span class="s2">is </span><span class="s1">dpss</span><span class="s3">:</span>
            <span class="s1">params </span><span class="s3">= (</span><span class="s1">Nx</span><span class="s3">,) + </span><span class="s1">args </span><span class="s3">+ (</span><span class="s2">None</span><span class="s3">,)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">params </span><span class="s3">= (</span><span class="s1">Nx</span><span class="s3">,) + </span><span class="s1">args</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">winfunc </span><span class="s3">= </span><span class="s1">kaiser</span>
        <span class="s1">params </span><span class="s3">= (</span><span class="s1">Nx</span><span class="s3">, </span><span class="s1">beta</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">winfunc</span><span class="s3">(*</span><span class="s1">params</span><span class="s3">, </span><span class="s1">sym</span><span class="s3">=</span><span class="s1">sym</span><span class="s3">)</span>
</pre>
</body>
</html>