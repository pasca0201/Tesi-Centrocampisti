<html>
<head>
<title>events.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #6aab73;}
.s5 { color: #5f826b; font-style: italic;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
events.py</font>
</center></td></tr></table>
<pre><span class="s0"># engine/events.py</span>
<span class="s0"># Copyright (C) 2005-2024 the SQLAlchemy authors and contributors</span>
<span class="s0"># &lt;see AUTHORS file&gt;</span>
<span class="s0">#</span>
<span class="s0"># This module is part of SQLAlchemy and is released under</span>
<span class="s0"># the MIT License: https://www.opensource.org/licenses/mit-license.php</span>


<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">annotations</span>

<span class="s2">import </span><span class="s1">typing</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Any</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Dict</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Optional</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Tuple</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Type</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Union</span>

<span class="s2">from </span><span class="s3">.</span><span class="s1">base </span><span class="s2">import </span><span class="s1">Connection</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">base </span><span class="s2">import </span><span class="s1">Engine</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">interfaces </span><span class="s2">import </span><span class="s1">ConnectionEventsTarget</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">interfaces </span><span class="s2">import </span><span class="s1">DBAPIConnection</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">interfaces </span><span class="s2">import </span><span class="s1">DBAPICursor</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">interfaces </span><span class="s2">import </span><span class="s1">Dialect</span>
<span class="s2">from </span><span class="s3">.. </span><span class="s2">import </span><span class="s1">event</span>
<span class="s2">from </span><span class="s3">.. </span><span class="s2">import </span><span class="s1">exc</span>
<span class="s2">from </span><span class="s3">..</span><span class="s1">util</span><span class="s3">.</span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Literal</span>

<span class="s2">if </span><span class="s1">typing</span><span class="s3">.</span><span class="s1">TYPE_CHECKING</span><span class="s3">:</span>
    <span class="s2">from </span><span class="s3">.</span><span class="s1">interfaces </span><span class="s2">import </span><span class="s1">_CoreMultiExecuteParams</span>
    <span class="s2">from </span><span class="s3">.</span><span class="s1">interfaces </span><span class="s2">import </span><span class="s1">_CoreSingleExecuteParams</span>
    <span class="s2">from </span><span class="s3">.</span><span class="s1">interfaces </span><span class="s2">import </span><span class="s1">_DBAPIAnyExecuteParams</span>
    <span class="s2">from </span><span class="s3">.</span><span class="s1">interfaces </span><span class="s2">import </span><span class="s1">_DBAPIMultiExecuteParams</span>
    <span class="s2">from </span><span class="s3">.</span><span class="s1">interfaces </span><span class="s2">import </span><span class="s1">_DBAPISingleExecuteParams</span>
    <span class="s2">from </span><span class="s3">.</span><span class="s1">interfaces </span><span class="s2">import </span><span class="s1">_ExecuteOptions</span>
    <span class="s2">from </span><span class="s3">.</span><span class="s1">interfaces </span><span class="s2">import </span><span class="s1">ExceptionContext</span>
    <span class="s2">from </span><span class="s3">.</span><span class="s1">interfaces </span><span class="s2">import </span><span class="s1">ExecutionContext</span>
    <span class="s2">from </span><span class="s3">.</span><span class="s1">result </span><span class="s2">import </span><span class="s1">Result</span>
    <span class="s2">from </span><span class="s3">..</span><span class="s1">pool </span><span class="s2">import </span><span class="s1">ConnectionPoolEntry</span>
    <span class="s2">from </span><span class="s3">..</span><span class="s1">sql </span><span class="s2">import </span><span class="s1">Executable</span>
    <span class="s2">from </span><span class="s3">..</span><span class="s1">sql</span><span class="s3">.</span><span class="s1">elements </span><span class="s2">import </span><span class="s1">BindParameter</span>


<span class="s2">class </span><span class="s1">ConnectionEvents</span><span class="s3">(</span><span class="s1">event</span><span class="s3">.</span><span class="s1">Events</span><span class="s3">[</span><span class="s1">ConnectionEventsTarget</span><span class="s3">]):</span>
    <span class="s4">&quot;&quot;&quot;Available events for 
    :class:`_engine.Connection` and :class:`_engine.Engine`. 
 
    The methods here define the name of an event as well as the names of 
    members that are passed to listener functions. 
 
    An event listener can be associated with any 
    :class:`_engine.Connection` or :class:`_engine.Engine` 
    class or instance, such as an :class:`_engine.Engine`, e.g.:: 
 
        from sqlalchemy import event, create_engine 
 
        def before_cursor_execute(conn, cursor, statement, parameters, context, 
                                                        executemany): 
            log.info(&quot;Received statement: %s&quot;, statement) 
 
        engine = create_engine('postgresql+psycopg2://scott:tiger@localhost/test') 
        event.listen(engine, &quot;before_cursor_execute&quot;, before_cursor_execute) 
 
    or with a specific :class:`_engine.Connection`:: 
 
        with engine.begin() as conn: 
            @event.listens_for(conn, 'before_cursor_execute') 
            def before_cursor_execute(conn, cursor, statement, parameters, 
                                            context, executemany): 
                log.info(&quot;Received statement: %s&quot;, statement) 
 
    When the methods are called with a `statement` parameter, such as in 
    :meth:`.after_cursor_execute` or :meth:`.before_cursor_execute`, 
    the statement is the exact SQL string that was prepared for transmission 
    to the DBAPI ``cursor`` in the connection's :class:`.Dialect`. 
 
    The :meth:`.before_execute` and :meth:`.before_cursor_execute` 
    events can also be established with the ``retval=True`` flag, which 
    allows modification of the statement and parameters to be sent 
    to the database.  The :meth:`.before_cursor_execute` event is 
    particularly useful here to add ad-hoc string transformations, such 
    as comments, to all executions:: 
 
        from sqlalchemy.engine import Engine 
        from sqlalchemy import event 
 
        @event.listens_for(Engine, &quot;before_cursor_execute&quot;, retval=True) 
        def comment_sql_calls(conn, cursor, statement, parameters, 
                                            context, executemany): 
            statement = statement + &quot; -- some comment&quot; 
            return statement, parameters 
 
    .. note:: :class:`_events.ConnectionEvents` can be established on any 
       combination of :class:`_engine.Engine`, :class:`_engine.Connection`, 
       as well 
       as instances of each of those classes.  Events across all 
       four scopes will fire off for a given instance of 
       :class:`_engine.Connection`.  However, for performance reasons, the 
       :class:`_engine.Connection` object determines at instantiation time 
       whether or not its parent :class:`_engine.Engine` has event listeners 
       established.   Event listeners added to the :class:`_engine.Engine` 
       class or to an instance of :class:`_engine.Engine` 
       *after* the instantiation 
       of a dependent :class:`_engine.Connection` instance will usually 
       *not* be available on that :class:`_engine.Connection` instance. 
       The newly 
       added listeners will instead take effect for 
       :class:`_engine.Connection` 
       instances created subsequent to those event listeners being 
       established on the parent :class:`_engine.Engine` class or instance. 
 
    :param retval=False: Applies to the :meth:`.before_execute` and 
      :meth:`.before_cursor_execute` events only.  When True, the 
      user-defined event function must have a return value, which 
      is a tuple of parameters that replace the given statement 
      and parameters.  See those methods for a description of 
      specific return arguments. 
 
    &quot;&quot;&quot;  </span><span class="s0"># noqa</span>

    <span class="s1">_target_class_doc </span><span class="s3">= </span><span class="s4">&quot;SomeEngine&quot;</span>
    <span class="s1">_dispatch_target </span><span class="s3">= </span><span class="s1">ConnectionEventsTarget</span>

    <span class="s3">@</span><span class="s1">classmethod</span>
    <span class="s2">def </span><span class="s1">_accept_with</span><span class="s3">(</span>
        <span class="s1">cls</span><span class="s3">,</span>
        <span class="s1">target</span><span class="s3">: </span><span class="s1">Union</span><span class="s3">[</span><span class="s1">ConnectionEventsTarget</span><span class="s3">, </span><span class="s1">Type</span><span class="s3">[</span><span class="s1">ConnectionEventsTarget</span><span class="s3">]],</span>
        <span class="s1">identifier</span><span class="s3">: </span><span class="s1">str</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">-&gt; Optional</span><span class="s3">[</span><span class="s1">Union</span><span class="s3">[</span><span class="s1">ConnectionEventsTarget</span><span class="s3">, </span><span class="s1">Type</span><span class="s3">[</span><span class="s1">ConnectionEventsTarget</span><span class="s3">]]]:</span>
        <span class="s1">default_dispatch </span><span class="s3">= </span><span class="s1">super</span><span class="s3">().</span><span class="s1">_accept_with</span><span class="s3">(</span><span class="s1">target</span><span class="s3">, </span><span class="s1">identifier</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">default_dispatch </span><span class="s2">is None and </span><span class="s1">hasattr</span><span class="s3">(</span>
            <span class="s1">target</span><span class="s3">, </span><span class="s4">&quot;_no_async_engine_events&quot;</span>
        <span class="s3">):</span>
            <span class="s1">target</span><span class="s3">.</span><span class="s1">_no_async_engine_events</span><span class="s3">()</span>

        <span class="s2">return </span><span class="s1">default_dispatch</span>

    <span class="s3">@</span><span class="s1">classmethod</span>
    <span class="s2">def </span><span class="s1">_listen</span><span class="s3">(</span>
        <span class="s1">cls</span><span class="s3">,</span>
        <span class="s1">event_key</span><span class="s3">: </span><span class="s1">event</span><span class="s3">.</span><span class="s1">_EventKey</span><span class="s3">[</span><span class="s1">ConnectionEventsTarget</span><span class="s3">],</span>
        <span class="s3">*,</span>
        <span class="s1">retval</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span><span class="s3">,</span>
        <span class="s3">**</span><span class="s1">kw</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s1">target</span><span class="s3">, </span><span class="s1">identifier</span><span class="s3">, </span><span class="s1">fn </span><span class="s3">= (</span>
            <span class="s1">event_key</span><span class="s3">.</span><span class="s1">dispatch_target</span><span class="s3">,</span>
            <span class="s1">event_key</span><span class="s3">.</span><span class="s1">identifier</span><span class="s3">,</span>
            <span class="s1">event_key</span><span class="s3">.</span><span class="s1">_listen_fn</span><span class="s3">,</span>
        <span class="s3">)</span>
        <span class="s1">target</span><span class="s3">.</span><span class="s1">_has_events </span><span class="s3">= </span><span class="s2">True</span>

        <span class="s2">if not </span><span class="s1">retval</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">identifier </span><span class="s3">== </span><span class="s4">&quot;before_execute&quot;</span><span class="s3">:</span>
                <span class="s1">orig_fn </span><span class="s3">= </span><span class="s1">fn</span>

                <span class="s2">def </span><span class="s1">wrap_before_execute</span><span class="s3">(  </span><span class="s0"># type: ignore</span>
                    <span class="s1">conn</span><span class="s3">, </span><span class="s1">clauseelement</span><span class="s3">, </span><span class="s1">multiparams</span><span class="s3">, </span><span class="s1">params</span><span class="s3">, </span><span class="s1">execution_options</span>
                <span class="s3">):</span>
                    <span class="s1">orig_fn</span><span class="s3">(</span>
                        <span class="s1">conn</span><span class="s3">,</span>
                        <span class="s1">clauseelement</span><span class="s3">,</span>
                        <span class="s1">multiparams</span><span class="s3">,</span>
                        <span class="s1">params</span><span class="s3">,</span>
                        <span class="s1">execution_options</span><span class="s3">,</span>
                    <span class="s3">)</span>
                    <span class="s2">return </span><span class="s1">clauseelement</span><span class="s3">, </span><span class="s1">multiparams</span><span class="s3">, </span><span class="s1">params</span>

                <span class="s1">fn </span><span class="s3">= </span><span class="s1">wrap_before_execute</span>
            <span class="s2">elif </span><span class="s1">identifier </span><span class="s3">== </span><span class="s4">&quot;before_cursor_execute&quot;</span><span class="s3">:</span>
                <span class="s1">orig_fn </span><span class="s3">= </span><span class="s1">fn</span>

                <span class="s2">def </span><span class="s1">wrap_before_cursor_execute</span><span class="s3">(  </span><span class="s0"># type: ignore</span>
                    <span class="s1">conn</span><span class="s3">, </span><span class="s1">cursor</span><span class="s3">, </span><span class="s1">statement</span><span class="s3">, </span><span class="s1">parameters</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">executemany</span>
                <span class="s3">):</span>
                    <span class="s1">orig_fn</span><span class="s3">(</span>
                        <span class="s1">conn</span><span class="s3">,</span>
                        <span class="s1">cursor</span><span class="s3">,</span>
                        <span class="s1">statement</span><span class="s3">,</span>
                        <span class="s1">parameters</span><span class="s3">,</span>
                        <span class="s1">context</span><span class="s3">,</span>
                        <span class="s1">executemany</span><span class="s3">,</span>
                    <span class="s3">)</span>
                    <span class="s2">return </span><span class="s1">statement</span><span class="s3">, </span><span class="s1">parameters</span>

                <span class="s1">fn </span><span class="s3">= </span><span class="s1">wrap_before_cursor_execute</span>
        <span class="s2">elif </span><span class="s1">retval </span><span class="s2">and </span><span class="s1">identifier </span><span class="s2">not in </span><span class="s3">(</span>
            <span class="s4">&quot;before_execute&quot;</span><span class="s3">,</span>
            <span class="s4">&quot;before_cursor_execute&quot;</span><span class="s3">,</span>
        <span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">exc</span><span class="s3">.</span><span class="s1">ArgumentError</span><span class="s3">(</span>
                <span class="s4">&quot;Only the 'before_execute', &quot;</span>
                <span class="s4">&quot;'before_cursor_execute' and 'handle_error' engine &quot;</span>
                <span class="s4">&quot;event listeners accept the 'retval=True' &quot;</span>
                <span class="s4">&quot;argument.&quot;</span>
            <span class="s3">)</span>
        <span class="s1">event_key</span><span class="s3">.</span><span class="s1">with_wrapper</span><span class="s3">(</span><span class="s1">fn</span><span class="s3">).</span><span class="s1">base_listen</span><span class="s3">()</span>

    <span class="s3">@</span><span class="s1">event</span><span class="s3">.</span><span class="s1">_legacy_signature</span><span class="s3">(</span>
        <span class="s4">&quot;1.4&quot;</span><span class="s3">,</span>
        <span class="s3">[</span><span class="s4">&quot;conn&quot;</span><span class="s3">, </span><span class="s4">&quot;clauseelement&quot;</span><span class="s3">, </span><span class="s4">&quot;multiparams&quot;</span><span class="s3">, </span><span class="s4">&quot;params&quot;</span><span class="s3">],</span>
        <span class="s2">lambda </span><span class="s1">conn</span><span class="s3">, </span><span class="s1">clauseelement</span><span class="s3">, </span><span class="s1">multiparams</span><span class="s3">, </span><span class="s1">params</span><span class="s3">, </span><span class="s1">execution_options</span><span class="s3">: (</span>
            <span class="s1">conn</span><span class="s3">,</span>
            <span class="s1">clauseelement</span><span class="s3">,</span>
            <span class="s1">multiparams</span><span class="s3">,</span>
            <span class="s1">params</span><span class="s3">,</span>
        <span class="s3">),</span>
    <span class="s3">)</span>
    <span class="s2">def </span><span class="s1">before_execute</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">conn</span><span class="s3">: </span><span class="s1">Connection</span><span class="s3">,</span>
        <span class="s1">clauseelement</span><span class="s3">: </span><span class="s1">Executable</span><span class="s3">,</span>
        <span class="s1">multiparams</span><span class="s3">: </span><span class="s1">_CoreMultiExecuteParams</span><span class="s3">,</span>
        <span class="s1">params</span><span class="s3">: </span><span class="s1">_CoreSingleExecuteParams</span><span class="s3">,</span>
        <span class="s1">execution_options</span><span class="s3">: </span><span class="s1">_ExecuteOptions</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">-&gt; Optional</span><span class="s3">[</span>
        <span class="s1">Tuple</span><span class="s3">[</span><span class="s1">Executable</span><span class="s3">, </span><span class="s1">_CoreMultiExecuteParams</span><span class="s3">, </span><span class="s1">_CoreSingleExecuteParams</span><span class="s3">]</span>
    <span class="s3">]:</span>
        <span class="s5">&quot;&quot;&quot;Intercept high level execute() events, receiving uncompiled 
        SQL constructs and other objects prior to rendering into SQL. 
 
        This event is good for debugging SQL compilation issues as well 
        as early manipulation of the parameters being sent to the database, 
        as the parameter lists will be in a consistent format here. 
 
        This event can be optionally established with the ``retval=True`` 
        flag.  The ``clauseelement``, ``multiparams``, and ``params`` 
        arguments should be returned as a three-tuple in this case:: 
 
            @event.listens_for(Engine, &quot;before_execute&quot;, retval=True) 
            def before_execute(conn, clauseelement, multiparams, params): 
                # do something with clauseelement, multiparams, params 
                return clauseelement, multiparams, params 
 
        :param conn: :class:`_engine.Connection` object 
        :param clauseelement: SQL expression construct, :class:`.Compiled` 
         instance, or string statement passed to 
         :meth:`_engine.Connection.execute`. 
        :param multiparams: Multiple parameter sets, a list of dictionaries. 
        :param params: Single parameter set, a single dictionary. 
        :param execution_options: dictionary of execution 
         options passed along with the statement, if any.  This is a merge 
         of all options that will be used, including those of the statement, 
         the connection, and those passed in to the method itself for 
         the 2.0 style of execution. 
 
         .. versionadded: 1.4 
 
        .. seealso:: 
 
            :meth:`.before_cursor_execute` 
 
        &quot;&quot;&quot;</span>

    <span class="s3">@</span><span class="s1">event</span><span class="s3">.</span><span class="s1">_legacy_signature</span><span class="s3">(</span>
        <span class="s4">&quot;1.4&quot;</span><span class="s3">,</span>
        <span class="s3">[</span><span class="s4">&quot;conn&quot;</span><span class="s3">, </span><span class="s4">&quot;clauseelement&quot;</span><span class="s3">, </span><span class="s4">&quot;multiparams&quot;</span><span class="s3">, </span><span class="s4">&quot;params&quot;</span><span class="s3">, </span><span class="s4">&quot;result&quot;</span><span class="s3">],</span>
        <span class="s2">lambda </span><span class="s1">conn</span><span class="s3">, </span><span class="s1">clauseelement</span><span class="s3">, </span><span class="s1">multiparams</span><span class="s3">, </span><span class="s1">params</span><span class="s3">, </span><span class="s1">execution_options</span><span class="s3">, </span><span class="s1">result</span><span class="s3">: (  </span><span class="s0"># noqa</span>
            <span class="s1">conn</span><span class="s3">,</span>
            <span class="s1">clauseelement</span><span class="s3">,</span>
            <span class="s1">multiparams</span><span class="s3">,</span>
            <span class="s1">params</span><span class="s3">,</span>
            <span class="s1">result</span><span class="s3">,</span>
        <span class="s3">),</span>
    <span class="s3">)</span>
    <span class="s2">def </span><span class="s1">after_execute</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">conn</span><span class="s3">: </span><span class="s1">Connection</span><span class="s3">,</span>
        <span class="s1">clauseelement</span><span class="s3">: </span><span class="s1">Executable</span><span class="s3">,</span>
        <span class="s1">multiparams</span><span class="s3">: </span><span class="s1">_CoreMultiExecuteParams</span><span class="s3">,</span>
        <span class="s1">params</span><span class="s3">: </span><span class="s1">_CoreSingleExecuteParams</span><span class="s3">,</span>
        <span class="s1">execution_options</span><span class="s3">: </span><span class="s1">_ExecuteOptions</span><span class="s3">,</span>
        <span class="s1">result</span><span class="s3">: </span><span class="s1">Result</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">],</span>
    <span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot;Intercept high level execute() events after execute. 
 
 
        :param conn: :class:`_engine.Connection` object 
        :param clauseelement: SQL expression construct, :class:`.Compiled` 
         instance, or string statement passed to 
         :meth:`_engine.Connection.execute`. 
        :param multiparams: Multiple parameter sets, a list of dictionaries. 
        :param params: Single parameter set, a single dictionary. 
        :param execution_options: dictionary of execution 
         options passed along with the statement, if any.  This is a merge 
         of all options that will be used, including those of the statement, 
         the connection, and those passed in to the method itself for 
         the 2.0 style of execution. 
 
         .. versionadded: 1.4 
 
        :param result: :class:`_engine.CursorResult` generated by the 
         execution. 
 
        &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">before_cursor_execute</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">conn</span><span class="s3">: </span><span class="s1">Connection</span><span class="s3">,</span>
        <span class="s1">cursor</span><span class="s3">: </span><span class="s1">DBAPICursor</span><span class="s3">,</span>
        <span class="s1">statement</span><span class="s3">: </span><span class="s1">str</span><span class="s3">,</span>
        <span class="s1">parameters</span><span class="s3">: </span><span class="s1">_DBAPIAnyExecuteParams</span><span class="s3">,</span>
        <span class="s1">context</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">ExecutionContext</span><span class="s3">],</span>
        <span class="s1">executemany</span><span class="s3">: </span><span class="s1">bool</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">-&gt; Optional</span><span class="s3">[</span><span class="s1">Tuple</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">_DBAPIAnyExecuteParams</span><span class="s3">]]:</span>
        <span class="s5">&quot;&quot;&quot;Intercept low-level cursor execute() events before execution, 
        receiving the string SQL statement and DBAPI-specific parameter list to 
        be invoked against a cursor. 
 
        This event is a good choice for logging as well as late modifications 
        to the SQL string.  It's less ideal for parameter modifications except 
        for those which are specific to a target backend. 
 
        This event can be optionally established with the ``retval=True`` 
        flag.  The ``statement`` and ``parameters`` arguments should be 
        returned as a two-tuple in this case:: 
 
            @event.listens_for(Engine, &quot;before_cursor_execute&quot;, retval=True) 
            def before_cursor_execute(conn, cursor, statement, 
                            parameters, context, executemany): 
                # do something with statement, parameters 
                return statement, parameters 
 
        See the example at :class:`_events.ConnectionEvents`. 
 
        :param conn: :class:`_engine.Connection` object 
        :param cursor: DBAPI cursor object 
        :param statement: string SQL statement, as to be passed to the DBAPI 
        :param parameters: Dictionary, tuple, or list of parameters being 
         passed to the ``execute()`` or ``executemany()`` method of the 
         DBAPI ``cursor``.  In some cases may be ``None``. 
        :param context: :class:`.ExecutionContext` object in use.  May 
         be ``None``. 
        :param executemany: boolean, if ``True``, this is an ``executemany()`` 
         call, if ``False``, this is an ``execute()`` call. 
 
        .. seealso:: 
 
            :meth:`.before_execute` 
 
            :meth:`.after_cursor_execute` 
 
        &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">after_cursor_execute</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">conn</span><span class="s3">: </span><span class="s1">Connection</span><span class="s3">,</span>
        <span class="s1">cursor</span><span class="s3">: </span><span class="s1">DBAPICursor</span><span class="s3">,</span>
        <span class="s1">statement</span><span class="s3">: </span><span class="s1">str</span><span class="s3">,</span>
        <span class="s1">parameters</span><span class="s3">: </span><span class="s1">_DBAPIAnyExecuteParams</span><span class="s3">,</span>
        <span class="s1">context</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">ExecutionContext</span><span class="s3">],</span>
        <span class="s1">executemany</span><span class="s3">: </span><span class="s1">bool</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot;Intercept low-level cursor execute() events after execution. 
 
        :param conn: :class:`_engine.Connection` object 
        :param cursor: DBAPI cursor object.  Will have results pending 
         if the statement was a SELECT, but these should not be consumed 
         as they will be needed by the :class:`_engine.CursorResult`. 
        :param statement: string SQL statement, as passed to the DBAPI 
        :param parameters: Dictionary, tuple, or list of parameters being 
         passed to the ``execute()`` or ``executemany()`` method of the 
         DBAPI ``cursor``.  In some cases may be ``None``. 
        :param context: :class:`.ExecutionContext` object in use.  May 
         be ``None``. 
        :param executemany: boolean, if ``True``, this is an ``executemany()`` 
         call, if ``False``, this is an ``execute()`` call. 
 
        &quot;&quot;&quot;</span>

    <span class="s3">@</span><span class="s1">event</span><span class="s3">.</span><span class="s1">_legacy_signature</span><span class="s3">(</span>
        <span class="s4">&quot;2.0&quot;</span><span class="s3">, [</span><span class="s4">&quot;conn&quot;</span><span class="s3">, </span><span class="s4">&quot;branch&quot;</span><span class="s3">], </span><span class="s1">converter</span><span class="s3">=</span><span class="s2">lambda </span><span class="s1">conn</span><span class="s3">: (</span><span class="s1">conn</span><span class="s3">, </span><span class="s2">False</span><span class="s3">)</span>
    <span class="s3">)</span>
    <span class="s2">def </span><span class="s1">engine_connect</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">conn</span><span class="s3">: </span><span class="s1">Connection</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot;Intercept the creation of a new :class:`_engine.Connection`. 
 
        This event is called typically as the direct result of calling 
        the :meth:`_engine.Engine.connect` method. 
 
        It differs from the :meth:`_events.PoolEvents.connect` method, which 
        refers to the actual connection to a database at the DBAPI level; 
        a DBAPI connection may be pooled and reused for many operations. 
        In contrast, this event refers only to the production of a higher level 
        :class:`_engine.Connection` wrapper around such a DBAPI connection. 
 
        It also differs from the :meth:`_events.PoolEvents.checkout` event 
        in that it is specific to the :class:`_engine.Connection` object, 
        not the 
        DBAPI connection that :meth:`_events.PoolEvents.checkout` deals with, 
        although 
        this DBAPI connection is available here via the 
        :attr:`_engine.Connection.connection` attribute. 
        But note there can in fact 
        be multiple :meth:`_events.PoolEvents.checkout` 
        events within the lifespan 
        of a single :class:`_engine.Connection` object, if that 
        :class:`_engine.Connection` 
        is invalidated and re-established. 
 
        :param conn: :class:`_engine.Connection` object. 
 
        .. seealso:: 
 
            :meth:`_events.PoolEvents.checkout` 
            the lower-level pool checkout event 
            for an individual DBAPI connection 
 
        &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">set_connection_execution_options</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">conn</span><span class="s3">: </span><span class="s1">Connection</span><span class="s3">, </span><span class="s1">opts</span><span class="s3">: </span><span class="s1">Dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">]</span>
    <span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot;Intercept when the :meth:`_engine.Connection.execution_options` 
        method is called. 
 
        This method is called after the new :class:`_engine.Connection` 
        has been 
        produced, with the newly updated execution options collection, but 
        before the :class:`.Dialect` has acted upon any of those new options. 
 
        Note that this method is not called when a new 
        :class:`_engine.Connection` 
        is produced which is inheriting execution options from its parent 
        :class:`_engine.Engine`; to intercept this condition, use the 
        :meth:`_events.ConnectionEvents.engine_connect` event. 
 
        :param conn: The newly copied :class:`_engine.Connection` object 
 
        :param opts: dictionary of options that were passed to the 
         :meth:`_engine.Connection.execution_options` method. 
         This dictionary may be modified in place to affect the ultimate 
         options which take effect. 
 
         .. versionadded:: 2.0 the ``opts`` dictionary may be modified 
            in place. 
 
 
        .. seealso:: 
 
            :meth:`_events.ConnectionEvents.set_engine_execution_options` 
            - event 
            which is called when :meth:`_engine.Engine.execution_options` 
            is called. 
 
 
        &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">set_engine_execution_options</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">engine</span><span class="s3">: </span><span class="s1">Engine</span><span class="s3">, </span><span class="s1">opts</span><span class="s3">: </span><span class="s1">Dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">]</span>
    <span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot;Intercept when the :meth:`_engine.Engine.execution_options` 
        method is called. 
 
        The :meth:`_engine.Engine.execution_options` method produces a shallow 
        copy of the :class:`_engine.Engine` which stores the new options. 
        That new 
        :class:`_engine.Engine` is passed here. 
        A particular application of this 
        method is to add a :meth:`_events.ConnectionEvents.engine_connect` 
        event 
        handler to the given :class:`_engine.Engine` 
        which will perform some per- 
        :class:`_engine.Connection` task specific to these execution options. 
 
        :param conn: The newly copied :class:`_engine.Engine` object 
 
        :param opts: dictionary of options that were passed to the 
         :meth:`_engine.Connection.execution_options` method. 
         This dictionary may be modified in place to affect the ultimate 
         options which take effect. 
 
         .. versionadded:: 2.0 the ``opts`` dictionary may be modified 
            in place. 
 
        .. seealso:: 
 
            :meth:`_events.ConnectionEvents.set_connection_execution_options` 
            - event 
            which is called when :meth:`_engine.Connection.execution_options` 
            is 
            called. 
 
        &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">engine_disposed</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">engine</span><span class="s3">: </span><span class="s1">Engine</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot;Intercept when the :meth:`_engine.Engine.dispose` method is called. 
 
        The :meth:`_engine.Engine.dispose` method instructs the engine to 
        &quot;dispose&quot; of it's connection pool (e.g. :class:`_pool.Pool`), and 
        replaces it with a new one.  Disposing of the old pool has the 
        effect that existing checked-in connections are closed.  The new 
        pool does not establish any new connections until it is first used. 
 
        This event can be used to indicate that resources related to the 
        :class:`_engine.Engine` should also be cleaned up, 
        keeping in mind that the 
        :class:`_engine.Engine` 
        can still be used for new requests in which case 
        it re-acquires connection resources. 
 
        &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">begin</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">conn</span><span class="s3">: </span><span class="s1">Connection</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot;Intercept begin() events. 
 
        :param conn: :class:`_engine.Connection` object 
 
        &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">rollback</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">conn</span><span class="s3">: </span><span class="s1">Connection</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot;Intercept rollback() events, as initiated by a 
        :class:`.Transaction`. 
 
        Note that the :class:`_pool.Pool` also &quot;auto-rolls back&quot; 
        a DBAPI connection upon checkin, if the ``reset_on_return`` 
        flag is set to its default value of ``'rollback'``. 
        To intercept this 
        rollback, use the :meth:`_events.PoolEvents.reset` hook. 
 
        :param conn: :class:`_engine.Connection` object 
 
        .. seealso:: 
 
            :meth:`_events.PoolEvents.reset` 
 
        &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">commit</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">conn</span><span class="s3">: </span><span class="s1">Connection</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot;Intercept commit() events, as initiated by a 
        :class:`.Transaction`. 
 
        Note that the :class:`_pool.Pool` may also &quot;auto-commit&quot; 
        a DBAPI connection upon checkin, if the ``reset_on_return`` 
        flag is set to the value ``'commit'``.  To intercept this 
        commit, use the :meth:`_events.PoolEvents.reset` hook. 
 
        :param conn: :class:`_engine.Connection` object 
        &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">savepoint</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">conn</span><span class="s3">: </span><span class="s1">Connection</span><span class="s3">, </span><span class="s1">name</span><span class="s3">: </span><span class="s1">str</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot;Intercept savepoint() events. 
 
        :param conn: :class:`_engine.Connection` object 
        :param name: specified name used for the savepoint. 
 
        &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">rollback_savepoint</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">conn</span><span class="s3">: </span><span class="s1">Connection</span><span class="s3">, </span><span class="s1">name</span><span class="s3">: </span><span class="s1">str</span><span class="s3">, </span><span class="s1">context</span><span class="s3">: </span><span class="s2">None</span>
    <span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot;Intercept rollback_savepoint() events. 
 
        :param conn: :class:`_engine.Connection` object 
        :param name: specified name used for the savepoint. 
        :param context: not used 
 
        &quot;&quot;&quot;</span>
        <span class="s0"># TODO: deprecate &quot;context&quot;</span>

    <span class="s2">def </span><span class="s1">release_savepoint</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">conn</span><span class="s3">: </span><span class="s1">Connection</span><span class="s3">, </span><span class="s1">name</span><span class="s3">: </span><span class="s1">str</span><span class="s3">, </span><span class="s1">context</span><span class="s3">: </span><span class="s2">None</span>
    <span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot;Intercept release_savepoint() events. 
 
        :param conn: :class:`_engine.Connection` object 
        :param name: specified name used for the savepoint. 
        :param context: not used 
 
        &quot;&quot;&quot;</span>
        <span class="s0"># TODO: deprecate &quot;context&quot;</span>

    <span class="s2">def </span><span class="s1">begin_twophase</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">conn</span><span class="s3">: </span><span class="s1">Connection</span><span class="s3">, </span><span class="s1">xid</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot;Intercept begin_twophase() events. 
 
        :param conn: :class:`_engine.Connection` object 
        :param xid: two-phase XID identifier 
 
        &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">prepare_twophase</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">conn</span><span class="s3">: </span><span class="s1">Connection</span><span class="s3">, </span><span class="s1">xid</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot;Intercept prepare_twophase() events. 
 
        :param conn: :class:`_engine.Connection` object 
        :param xid: two-phase XID identifier 
        &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">rollback_twophase</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">conn</span><span class="s3">: </span><span class="s1">Connection</span><span class="s3">, </span><span class="s1">xid</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">, </span><span class="s1">is_prepared</span><span class="s3">: </span><span class="s1">bool</span>
    <span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot;Intercept rollback_twophase() events. 
 
        :param conn: :class:`_engine.Connection` object 
        :param xid: two-phase XID identifier 
        :param is_prepared: boolean, indicates if 
         :meth:`.TwoPhaseTransaction.prepare` was called. 
 
        &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">commit_twophase</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">conn</span><span class="s3">: </span><span class="s1">Connection</span><span class="s3">, </span><span class="s1">xid</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">, </span><span class="s1">is_prepared</span><span class="s3">: </span><span class="s1">bool</span>
    <span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot;Intercept commit_twophase() events. 
 
        :param conn: :class:`_engine.Connection` object 
        :param xid: two-phase XID identifier 
        :param is_prepared: boolean, indicates if 
         :meth:`.TwoPhaseTransaction.prepare` was called. 
 
        &quot;&quot;&quot;</span>


<span class="s2">class </span><span class="s1">DialectEvents</span><span class="s3">(</span><span class="s1">event</span><span class="s3">.</span><span class="s1">Events</span><span class="s3">[</span><span class="s1">Dialect</span><span class="s3">]):</span>
    <span class="s5">&quot;&quot;&quot;event interface for execution-replacement functions. 
 
    These events allow direct instrumentation and replacement 
    of key dialect functions which interact with the DBAPI. 
 
    .. note:: 
 
        :class:`.DialectEvents` hooks should be considered **semi-public** 
        and experimental. 
        These hooks are not for general use and are only for those situations 
        where intricate re-statement of DBAPI mechanics must be injected onto 
        an existing dialect.  For general-use statement-interception events, 
        please use the :class:`_events.ConnectionEvents` interface. 
 
    .. seealso:: 
 
        :meth:`_events.ConnectionEvents.before_cursor_execute` 
 
        :meth:`_events.ConnectionEvents.before_execute` 
 
        :meth:`_events.ConnectionEvents.after_cursor_execute` 
 
        :meth:`_events.ConnectionEvents.after_execute` 
 
    &quot;&quot;&quot;</span>

    <span class="s1">_target_class_doc </span><span class="s3">= </span><span class="s4">&quot;SomeEngine&quot;</span>
    <span class="s1">_dispatch_target </span><span class="s3">= </span><span class="s1">Dialect</span>

    <span class="s3">@</span><span class="s1">classmethod</span>
    <span class="s2">def </span><span class="s1">_listen</span><span class="s3">(</span>
        <span class="s1">cls</span><span class="s3">,</span>
        <span class="s1">event_key</span><span class="s3">: </span><span class="s1">event</span><span class="s3">.</span><span class="s1">_EventKey</span><span class="s3">[</span><span class="s1">Dialect</span><span class="s3">],</span>
        <span class="s3">*,</span>
        <span class="s1">retval</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span><span class="s3">,</span>
        <span class="s3">**</span><span class="s1">kw</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s1">target </span><span class="s3">= </span><span class="s1">event_key</span><span class="s3">.</span><span class="s1">dispatch_target</span>

        <span class="s1">target</span><span class="s3">.</span><span class="s1">_has_events </span><span class="s3">= </span><span class="s2">True</span>
        <span class="s1">event_key</span><span class="s3">.</span><span class="s1">base_listen</span><span class="s3">()</span>

    <span class="s3">@</span><span class="s1">classmethod</span>
    <span class="s2">def </span><span class="s1">_accept_with</span><span class="s3">(</span>
        <span class="s1">cls</span><span class="s3">,</span>
        <span class="s1">target</span><span class="s3">: </span><span class="s1">Union</span><span class="s3">[</span><span class="s1">Engine</span><span class="s3">, </span><span class="s1">Type</span><span class="s3">[</span><span class="s1">Engine</span><span class="s3">], </span><span class="s1">Dialect</span><span class="s3">, </span><span class="s1">Type</span><span class="s3">[</span><span class="s1">Dialect</span><span class="s3">]],</span>
        <span class="s1">identifier</span><span class="s3">: </span><span class="s1">str</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">-&gt; Optional</span><span class="s3">[</span><span class="s1">Union</span><span class="s3">[</span><span class="s1">Dialect</span><span class="s3">, </span><span class="s1">Type</span><span class="s3">[</span><span class="s1">Dialect</span><span class="s3">]]]:</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">target</span><span class="s3">, </span><span class="s1">type</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">issubclass</span><span class="s3">(</span><span class="s1">target</span><span class="s3">, </span><span class="s1">Engine</span><span class="s3">):</span>
                <span class="s2">return </span><span class="s1">Dialect</span>
            <span class="s2">elif </span><span class="s1">issubclass</span><span class="s3">(</span><span class="s1">target</span><span class="s3">, </span><span class="s1">Dialect</span><span class="s3">):</span>
                <span class="s2">return </span><span class="s1">target</span>
        <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">target</span><span class="s3">, </span><span class="s1">Engine</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">target</span><span class="s3">.</span><span class="s1">dialect</span>
        <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">target</span><span class="s3">, </span><span class="s1">Dialect</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">target</span>
        <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">target</span><span class="s3">, </span><span class="s1">Connection</span><span class="s3">) </span><span class="s2">and </span><span class="s1">identifier </span><span class="s3">== </span><span class="s4">&quot;handle_error&quot;</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">exc</span><span class="s3">.</span><span class="s1">InvalidRequestError</span><span class="s3">(</span>
                <span class="s4">&quot;The handle_error() event hook as of SQLAlchemy 2.0 is &quot;</span>
                <span class="s4">&quot;established on the Dialect, and may only be applied to the &quot;</span>
                <span class="s4">&quot;Engine as a whole or to a specific Dialect as a whole, &quot;</span>
                <span class="s4">&quot;not on a per-Connection basis.&quot;</span>
            <span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">target</span><span class="s3">, </span><span class="s4">&quot;_no_async_engine_events&quot;</span><span class="s3">):</span>
            <span class="s1">target</span><span class="s3">.</span><span class="s1">_no_async_engine_events</span><span class="s3">()</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">return None</span>

    <span class="s2">def </span><span class="s1">handle_error</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">exception_context</span><span class="s3">: </span><span class="s1">ExceptionContext</span>
    <span class="s3">) </span><span class="s1">-&gt; Optional</span><span class="s3">[</span><span class="s1">BaseException</span><span class="s3">]:</span>
        <span class="s5">r&quot;&quot;&quot;Intercept all exceptions processed by the 
        :class:`_engine.Dialect`, typically but not limited to those 
        emitted within the scope of a :class:`_engine.Connection`. 
 
        .. versionchanged:: 2.0 the :meth:`.DialectEvents.handle_error` event 
           is moved to the :class:`.DialectEvents` class, moved from the 
           :class:`.ConnectionEvents` class, so that it may also participate in 
           the &quot;pre ping&quot; operation configured with the 
           :paramref:`_sa.create_engine.pool_pre_ping` parameter. The event 
           remains registered by using the :class:`_engine.Engine` as the event 
           target, however note that using the :class:`_engine.Connection` as 
           an event target for :meth:`.DialectEvents.handle_error` is no longer 
           supported. 
 
        This includes all exceptions emitted by the DBAPI as well as 
        within SQLAlchemy's statement invocation process, including 
        encoding errors and other statement validation errors.  Other areas 
        in which the event is invoked include transaction begin and end, 
        result row fetching, cursor creation. 
 
        Note that :meth:`.handle_error` may support new kinds of exceptions 
        and new calling scenarios at *any time*.  Code which uses this 
        event must expect new calling patterns to be present in minor 
        releases. 
 
        To support the wide variety of members that correspond to an exception, 
        as well as to allow extensibility of the event without backwards 
        incompatibility, the sole argument received is an instance of 
        :class:`.ExceptionContext`.   This object contains data members 
        representing detail about the exception. 
 
        Use cases supported by this hook include: 
 
        * read-only, low-level exception handling for logging and 
          debugging purposes 
        * Establishing whether a DBAPI connection error message indicates 
          that the database connection needs to be reconnected, including 
          for the &quot;pre_ping&quot; handler used by **some** dialects 
        * Establishing or disabling whether a connection or the owning 
          connection pool is invalidated or expired in response to a 
          specific exception 
        * exception re-writing 
 
        The hook is called while the cursor from the failed operation 
        (if any) is still open and accessible.   Special cleanup operations 
        can be called on this cursor; SQLAlchemy will attempt to close 
        this cursor subsequent to this hook being invoked. 
 
        As of SQLAlchemy 2.0, the &quot;pre_ping&quot; handler enabled using the 
        :paramref:`_sa.create_engine.pool_pre_ping` parameter will also 
        participate in the :meth:`.handle_error` process, **for those dialects 
        that rely upon disconnect codes to detect database liveness**. Note 
        that some dialects such as psycopg, psycopg2, and most MySQL dialects 
        make use of a native ``ping()`` method supplied by the DBAPI which does 
        not make use of disconnect codes. 
 
        .. versionchanged:: 2.0.0 The :meth:`.DialectEvents.handle_error` 
           event hook participates in connection pool &quot;pre-ping&quot; operations. 
           Within this usage, the :attr:`.ExceptionContext.engine` attribute 
           will be ``None``, however the :class:`.Dialect` in use is always 
           available via the :attr:`.ExceptionContext.dialect` attribute. 
 
        .. versionchanged:: 2.0.5 Added :attr:`.ExceptionContext.is_pre_ping` 
           attribute which will be set to ``True`` when the 
           :meth:`.DialectEvents.handle_error` event hook is triggered within 
           a connection pool pre-ping operation. 
 
        .. versionchanged:: 2.0.5 An issue was repaired that allows for the 
           PostgreSQL ``psycopg`` and ``psycopg2`` drivers, as well as all 
           MySQL drivers, to properly participate in the 
           :meth:`.DialectEvents.handle_error` event hook during 
           connection pool &quot;pre-ping&quot; operations; previously, the 
           implementation was non-working for these drivers. 
 
 
        A handler function has two options for replacing 
        the SQLAlchemy-constructed exception into one that is user 
        defined.   It can either raise this new exception directly, in 
        which case all further event listeners are bypassed and the 
        exception will be raised, after appropriate cleanup as taken 
        place:: 
 
            @event.listens_for(Engine, &quot;handle_error&quot;) 
            def handle_exception(context): 
                if isinstance(context.original_exception, 
                    psycopg2.OperationalError) and \ 
                    &quot;failed&quot; in str(context.original_exception): 
                    raise MySpecialException(&quot;failed operation&quot;) 
 
        .. warning::  Because the 
           :meth:`_events.DialectEvents.handle_error` 
           event specifically provides for exceptions to be re-thrown as 
           the ultimate exception raised by the failed statement, 
           **stack traces will be misleading** if the user-defined event 
           handler itself fails and throws an unexpected exception; 
           the stack trace may not illustrate the actual code line that 
           failed!  It is advised to code carefully here and use 
           logging and/or inline debugging if unexpected exceptions are 
           occurring. 
 
        Alternatively, a &quot;chained&quot; style of event handling can be 
        used, by configuring the handler with the ``retval=True`` 
        modifier and returning the new exception instance from the 
        function.  In this case, event handling will continue onto the 
        next handler.   The &quot;chained&quot; exception is available using 
        :attr:`.ExceptionContext.chained_exception`:: 
 
            @event.listens_for(Engine, &quot;handle_error&quot;, retval=True) 
            def handle_exception(context): 
                if context.chained_exception is not None and \ 
                    &quot;special&quot; in context.chained_exception.message: 
                    return MySpecialException(&quot;failed&quot;, 
                        cause=context.chained_exception) 
 
        Handlers that return ``None`` may be used within the chain; when 
        a handler returns ``None``, the previous exception instance, 
        if any, is maintained as the current exception that is passed onto the 
        next handler. 
 
        When a custom exception is raised or returned, SQLAlchemy raises 
        this new exception as-is, it is not wrapped by any SQLAlchemy 
        object.  If the exception is not a subclass of 
        :class:`sqlalchemy.exc.StatementError`, 
        certain features may not be available; currently this includes 
        the ORM's feature of adding a detail hint about &quot;autoflush&quot; to 
        exceptions raised within the autoflush process. 
 
        :param context: an :class:`.ExceptionContext` object.  See this 
         class for details on all available members. 
 
 
        .. seealso:: 
 
            :ref:`pool_new_disconnect_codes` 
 
        &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">do_connect</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">dialect</span><span class="s3">: </span><span class="s1">Dialect</span><span class="s3">,</span>
        <span class="s1">conn_rec</span><span class="s3">: </span><span class="s1">ConnectionPoolEntry</span><span class="s3">,</span>
        <span class="s1">cargs</span><span class="s3">: </span><span class="s1">Tuple</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">, ...],</span>
        <span class="s1">cparams</span><span class="s3">: </span><span class="s1">Dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">],</span>
    <span class="s3">) </span><span class="s1">-&gt; Optional</span><span class="s3">[</span><span class="s1">DBAPIConnection</span><span class="s3">]:</span>
        <span class="s5">&quot;&quot;&quot;Receive connection arguments before a connection is made. 
 
        This event is useful in that it allows the handler to manipulate the 
        cargs and/or cparams collections that control how the DBAPI 
        ``connect()`` function will be called. ``cargs`` will always be a 
        Python list that can be mutated in-place, and ``cparams`` a Python 
        dictionary that may also be mutated:: 
 
            e = create_engine(&quot;postgresql+psycopg2://user@host/dbname&quot;) 
 
            @event.listens_for(e, 'do_connect') 
            def receive_do_connect(dialect, conn_rec, cargs, cparams): 
                cparams[&quot;password&quot;] = &quot;some_password&quot; 
 
        The event hook may also be used to override the call to ``connect()`` 
        entirely, by returning a non-``None`` DBAPI connection object:: 
 
            e = create_engine(&quot;postgresql+psycopg2://user@host/dbname&quot;) 
 
            @event.listens_for(e, 'do_connect') 
            def receive_do_connect(dialect, conn_rec, cargs, cparams): 
                return psycopg2.connect(*cargs, **cparams) 
 
        .. seealso:: 
 
            :ref:`custom_dbapi_args` 
 
        &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">do_executemany</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">cursor</span><span class="s3">: </span><span class="s1">DBAPICursor</span><span class="s3">,</span>
        <span class="s1">statement</span><span class="s3">: </span><span class="s1">str</span><span class="s3">,</span>
        <span class="s1">parameters</span><span class="s3">: </span><span class="s1">_DBAPIMultiExecuteParams</span><span class="s3">,</span>
        <span class="s1">context</span><span class="s3">: </span><span class="s1">ExecutionContext</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">-&gt; Optional</span><span class="s3">[</span><span class="s1">Literal</span><span class="s3">[</span><span class="s2">True</span><span class="s3">]]:</span>
        <span class="s5">&quot;&quot;&quot;Receive a cursor to have executemany() called. 
 
        Return the value True to halt further events from invoking, 
        and to indicate that the cursor execution has already taken 
        place within the event handler. 
 
        &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">do_execute_no_params</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">cursor</span><span class="s3">: </span><span class="s1">DBAPICursor</span><span class="s3">, </span><span class="s1">statement</span><span class="s3">: </span><span class="s1">str</span><span class="s3">, </span><span class="s1">context</span><span class="s3">: </span><span class="s1">ExecutionContext</span>
    <span class="s3">) </span><span class="s1">-&gt; Optional</span><span class="s3">[</span><span class="s1">Literal</span><span class="s3">[</span><span class="s2">True</span><span class="s3">]]:</span>
        <span class="s5">&quot;&quot;&quot;Receive a cursor to have execute() with no parameters called. 
 
        Return the value True to halt further events from invoking, 
        and to indicate that the cursor execution has already taken 
        place within the event handler. 
 
        &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">do_execute</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">cursor</span><span class="s3">: </span><span class="s1">DBAPICursor</span><span class="s3">,</span>
        <span class="s1">statement</span><span class="s3">: </span><span class="s1">str</span><span class="s3">,</span>
        <span class="s1">parameters</span><span class="s3">: </span><span class="s1">_DBAPISingleExecuteParams</span><span class="s3">,</span>
        <span class="s1">context</span><span class="s3">: </span><span class="s1">ExecutionContext</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">-&gt; Optional</span><span class="s3">[</span><span class="s1">Literal</span><span class="s3">[</span><span class="s2">True</span><span class="s3">]]:</span>
        <span class="s5">&quot;&quot;&quot;Receive a cursor to have execute() called. 
 
        Return the value True to halt further events from invoking, 
        and to indicate that the cursor execution has already taken 
        place within the event handler. 
 
        &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">do_setinputsizes</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">inputsizes</span><span class="s3">: </span><span class="s1">Dict</span><span class="s3">[</span><span class="s1">BindParameter</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">], </span><span class="s1">Any</span><span class="s3">],</span>
        <span class="s1">cursor</span><span class="s3">: </span><span class="s1">DBAPICursor</span><span class="s3">,</span>
        <span class="s1">statement</span><span class="s3">: </span><span class="s1">str</span><span class="s3">,</span>
        <span class="s1">parameters</span><span class="s3">: </span><span class="s1">_DBAPIAnyExecuteParams</span><span class="s3">,</span>
        <span class="s1">context</span><span class="s3">: </span><span class="s1">ExecutionContext</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot;Receive the setinputsizes dictionary for possible modification. 
 
        This event is emitted in the case where the dialect makes use of the 
        DBAPI ``cursor.setinputsizes()`` method which passes information about 
        parameter binding for a particular statement.   The given 
        ``inputsizes`` dictionary will contain :class:`.BindParameter` objects 
        as keys, linked to DBAPI-specific type objects as values; for 
        parameters that are not bound, they are added to the dictionary with 
        ``None`` as the value, which means the parameter will not be included 
        in the ultimate setinputsizes call.   The event may be used to inspect 
        and/or log the datatypes that are being bound, as well as to modify the 
        dictionary in place.  Parameters can be added, modified, or removed 
        from this dictionary.   Callers will typically want to inspect the 
        :attr:`.BindParameter.type` attribute of the given bind objects in 
        order to make decisions about the DBAPI object. 
 
        After the event, the ``inputsizes`` dictionary is converted into 
        an appropriate datastructure to be passed to ``cursor.setinputsizes``; 
        either a list for a positional bound parameter execution style, 
        or a dictionary of string parameter keys to DBAPI type objects for 
        a named bound parameter execution style. 
 
        The setinputsizes hook overall is only used for dialects which include 
        the flag ``use_setinputsizes=True``.  Dialects which use this 
        include cx_Oracle, pg8000, asyncpg, and pyodbc dialects. 
 
        .. note:: 
 
            For use with pyodbc, the ``use_setinputsizes`` flag 
            must be passed to the dialect, e.g.:: 
 
                create_engine(&quot;mssql+pyodbc://...&quot;, use_setinputsizes=True) 
 
            .. seealso:: 
 
                  :ref:`mssql_pyodbc_setinputsizes` 
 
        .. versionadded:: 1.2.9 
 
        .. seealso:: 
 
            :ref:`cx_oracle_setinputsizes` 
 
        &quot;&quot;&quot;</span>
        <span class="s2">pass</span>
</pre>
</body>
</html>