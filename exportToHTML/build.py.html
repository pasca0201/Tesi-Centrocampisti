<html>
<head>
<title>build.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #6aab73;}
.s4 { color: #cf8e6d;}
.s5 { color: #2aacb8;}
.s6 { color: #5f826b; font-style: italic;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
build.py</font>
</center></td></tr></table>
<pre><span class="s0"># This file is part of Patsy</span>
<span class="s0"># Copyright (C) 2011-2015 Nathaniel Smith &lt;njs@pobox.com&gt;</span>
<span class="s0"># See file LICENSE.txt for license information.</span>

<span class="s0"># This file defines the core design matrix building functions.</span>

<span class="s0"># These are made available in the patsy.* namespace</span>
<span class="s1">__all__ </span><span class="s2">= [</span><span class="s3">&quot;design_matrix_builders&quot;</span><span class="s2">, </span><span class="s3">&quot;build_design_matrices&quot;</span><span class="s2">]</span>

<span class="s4">import </span><span class="s1">itertools</span>
<span class="s4">import </span><span class="s1">six</span>

<span class="s4">import </span><span class="s1">numpy </span><span class="s4">as </span><span class="s1">np</span>
<span class="s4">from </span><span class="s1">patsy </span><span class="s4">import </span><span class="s1">PatsyError</span>
<span class="s4">from </span><span class="s1">patsy</span><span class="s2">.</span><span class="s1">categorical </span><span class="s4">import </span><span class="s2">(</span><span class="s1">guess_categorical</span><span class="s2">,</span>
                               <span class="s1">CategoricalSniffer</span><span class="s2">,</span>
                               <span class="s1">categorical_to_int</span><span class="s2">)</span>
<span class="s4">from </span><span class="s1">patsy</span><span class="s2">.</span><span class="s1">util </span><span class="s4">import </span><span class="s2">(</span><span class="s1">atleast_2d_column_default</span><span class="s2">,</span>
                        <span class="s1">have_pandas</span><span class="s2">, </span><span class="s1">asarray_or_pandas</span><span class="s2">,</span>
                        <span class="s1">safe_issubdtype</span><span class="s2">)</span>
<span class="s4">from </span><span class="s1">patsy</span><span class="s2">.</span><span class="s1">design_info </span><span class="s4">import </span><span class="s2">(</span><span class="s1">DesignMatrix</span><span class="s2">, </span><span class="s1">DesignInfo</span><span class="s2">,</span>
                               <span class="s1">FactorInfo</span><span class="s2">, </span><span class="s1">SubtermInfo</span><span class="s2">)</span>
<span class="s4">from </span><span class="s1">patsy</span><span class="s2">.</span><span class="s1">redundancy </span><span class="s4">import </span><span class="s1">pick_contrasts_for_term</span>
<span class="s4">from </span><span class="s1">patsy</span><span class="s2">.</span><span class="s1">eval </span><span class="s4">import </span><span class="s1">EvalEnvironment</span>
<span class="s4">from </span><span class="s1">patsy</span><span class="s2">.</span><span class="s1">contrasts </span><span class="s4">import </span><span class="s1">code_contrast_matrix</span><span class="s2">, </span><span class="s1">Treatment</span>
<span class="s4">from </span><span class="s1">patsy</span><span class="s2">.</span><span class="s1">compat </span><span class="s4">import </span><span class="s1">OrderedDict</span>
<span class="s4">from </span><span class="s1">patsy</span><span class="s2">.</span><span class="s1">missing </span><span class="s4">import </span><span class="s1">NAAction</span>

<span class="s4">if </span><span class="s1">have_pandas</span><span class="s2">:</span>
    <span class="s4">import </span><span class="s1">pandas</span>

<span class="s4">class </span><span class="s1">_MockFactor</span><span class="s2">(</span><span class="s1">object</span><span class="s2">):</span>
    <span class="s4">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">=</span><span class="s3">&quot;MOCKMOCK&quot;</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_name </span><span class="s2">= </span><span class="s1">name</span>

    <span class="s4">def </span><span class="s1">eval</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">state</span><span class="s2">, </span><span class="s1">env</span><span class="s2">):</span>
        <span class="s4">return </span><span class="s1">env</span><span class="s2">[</span><span class="s3">&quot;mock&quot;</span><span class="s2">]</span>

    <span class="s4">def </span><span class="s1">name</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_name</span>

<span class="s4">def </span><span class="s1">_max_allowed_dim</span><span class="s2">(</span><span class="s1">dim</span><span class="s2">, </span><span class="s1">arr</span><span class="s2">, </span><span class="s1">factor</span><span class="s2">):</span>
    <span class="s4">if </span><span class="s1">arr</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">&gt; </span><span class="s1">dim</span><span class="s2">:</span>
        <span class="s1">msg </span><span class="s2">= (</span><span class="s3">&quot;factor '%s' evaluates to an %s-dimensional array; I only &quot;</span>
               <span class="s3">&quot;handle arrays with dimension &lt;= %s&quot;</span>
               <span class="s2">% (</span><span class="s1">factor</span><span class="s2">.</span><span class="s1">name</span><span class="s2">(), </span><span class="s1">arr</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">, </span><span class="s1">dim</span><span class="s2">))</span>
        <span class="s4">raise </span><span class="s1">PatsyError</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">, </span><span class="s1">factor</span><span class="s2">)</span>

<span class="s4">def </span><span class="s1">test__max_allowed_dim</span><span class="s2">():</span>
    <span class="s4">import </span><span class="s1">pytest</span>
    <span class="s1">f </span><span class="s2">= </span><span class="s1">_MockFactor</span><span class="s2">()</span>
    <span class="s1">_max_allowed_dim</span><span class="s2">(</span><span class="s5">1</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">(</span><span class="s5">1</span><span class="s2">), </span><span class="s1">f</span><span class="s2">)</span>
    <span class="s1">_max_allowed_dim</span><span class="s2">(</span><span class="s5">1</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s5">1</span><span class="s2">]), </span><span class="s1">f</span><span class="s2">)</span>
    <span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">PatsyError</span><span class="s2">, </span><span class="s1">_max_allowed_dim</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([[</span><span class="s5">1</span><span class="s2">]]), </span><span class="s1">f</span><span class="s2">)</span>
    <span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">PatsyError</span><span class="s2">, </span><span class="s1">_max_allowed_dim</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([[[</span><span class="s5">1</span><span class="s2">]]]), </span><span class="s1">f</span><span class="s2">)</span>
    <span class="s1">_max_allowed_dim</span><span class="s2">(</span><span class="s5">2</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">(</span><span class="s5">1</span><span class="s2">), </span><span class="s1">f</span><span class="s2">)</span>
    <span class="s1">_max_allowed_dim</span><span class="s2">(</span><span class="s5">2</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s5">1</span><span class="s2">]), </span><span class="s1">f</span><span class="s2">)</span>
    <span class="s1">_max_allowed_dim</span><span class="s2">(</span><span class="s5">2</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([[</span><span class="s5">1</span><span class="s2">]]), </span><span class="s1">f</span><span class="s2">)</span>
    <span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">PatsyError</span><span class="s2">, </span><span class="s1">_max_allowed_dim</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([[[</span><span class="s5">1</span><span class="s2">]]]), </span><span class="s1">f</span><span class="s2">)</span>

<span class="s4">def </span><span class="s1">_eval_factor</span><span class="s2">(</span><span class="s1">factor_info</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">NA_action</span><span class="s2">):</span>
    <span class="s1">factor </span><span class="s2">= </span><span class="s1">factor_info</span><span class="s2">.</span><span class="s1">factor</span>
    <span class="s1">result </span><span class="s2">= </span><span class="s1">factor</span><span class="s2">.</span><span class="s1">eval</span><span class="s2">(</span><span class="s1">factor_info</span><span class="s2">.</span><span class="s1">state</span><span class="s2">, </span><span class="s1">data</span><span class="s2">)</span>
    <span class="s0"># Returns either a 2d ndarray, or a DataFrame, plus is_NA mask</span>
    <span class="s4">if </span><span class="s1">factor_info</span><span class="s2">.</span><span class="s1">type </span><span class="s2">== </span><span class="s3">&quot;numerical&quot;</span><span class="s2">:</span>
        <span class="s1">result </span><span class="s2">= </span><span class="s1">atleast_2d_column_default</span><span class="s2">(</span><span class="s1">result</span><span class="s2">, </span><span class="s1">preserve_pandas</span><span class="s2">=</span><span class="s4">True</span><span class="s2">)</span>
        <span class="s1">_max_allowed_dim</span><span class="s2">(</span><span class="s5">2</span><span class="s2">, </span><span class="s1">result</span><span class="s2">, </span><span class="s1">factor</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">result</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">1</span><span class="s2">] != </span><span class="s1">factor_info</span><span class="s2">.</span><span class="s1">num_columns</span><span class="s2">:</span>
            <span class="s4">raise </span><span class="s1">PatsyError</span><span class="s2">(</span><span class="s3">&quot;when evaluating factor %s, I got %s columns &quot;</span>
                                <span class="s3">&quot;instead of the %s I was expecting&quot;</span>
                                <span class="s2">% (</span><span class="s1">factor</span><span class="s2">.</span><span class="s1">name</span><span class="s2">(),</span>
                                   <span class="s1">factor_info</span><span class="s2">.</span><span class="s1">num_columns</span><span class="s2">,</span>
                                   <span class="s1">result</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">1</span><span class="s2">]),</span>
                                <span class="s1">factor</span><span class="s2">)</span>
        <span class="s4">if not </span><span class="s1">safe_issubdtype</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">result</span><span class="s2">).</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">number</span><span class="s2">):</span>
            <span class="s4">raise </span><span class="s1">PatsyError</span><span class="s2">(</span><span class="s3">&quot;when evaluating numeric factor %s, &quot;</span>
                             <span class="s3">&quot;I got non-numeric data of type '%s'&quot;</span>
                             <span class="s2">% (</span><span class="s1">factor</span><span class="s2">.</span><span class="s1">name</span><span class="s2">(), </span><span class="s1">result</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">),</span>
                             <span class="s1">factor</span><span class="s2">)</span>
        <span class="s4">return </span><span class="s1">result</span><span class="s2">, </span><span class="s1">NA_action</span><span class="s2">.</span><span class="s1">is_numerical_NA</span><span class="s2">(</span><span class="s1">result</span><span class="s2">)</span>
    <span class="s0"># returns either a 1d ndarray or a pandas.Series, plus is_NA mask</span>
    <span class="s4">else</span><span class="s2">:</span>
        <span class="s4">assert </span><span class="s1">factor_info</span><span class="s2">.</span><span class="s1">type </span><span class="s2">== </span><span class="s3">&quot;categorical&quot;</span>
        <span class="s1">result </span><span class="s2">= </span><span class="s1">categorical_to_int</span><span class="s2">(</span><span class="s1">result</span><span class="s2">, </span><span class="s1">factor_info</span><span class="s2">.</span><span class="s1">categories</span><span class="s2">, </span><span class="s1">NA_action</span><span class="s2">,</span>
                                    <span class="s1">origin</span><span class="s2">=</span><span class="s1">factor_info</span><span class="s2">.</span><span class="s1">factor</span><span class="s2">)</span>
        <span class="s4">assert </span><span class="s1">result</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s5">1</span>
        <span class="s4">return </span><span class="s1">result</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">result </span><span class="s2">== -</span><span class="s5">1</span><span class="s2">)</span>

<span class="s4">def </span><span class="s1">test__eval_factor_numerical</span><span class="s2">():</span>
    <span class="s4">import </span><span class="s1">pytest</span>
    <span class="s1">naa </span><span class="s2">= </span><span class="s1">NAAction</span><span class="s2">()</span>
    <span class="s1">f </span><span class="s2">= </span><span class="s1">_MockFactor</span><span class="s2">()</span>

    <span class="s1">fi1 </span><span class="s2">= </span><span class="s1">FactorInfo</span><span class="s2">(</span><span class="s1">f</span><span class="s2">, </span><span class="s3">&quot;numerical&quot;</span><span class="s2">, {}, </span><span class="s1">num_columns</span><span class="s2">=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">categories</span><span class="s2">=</span><span class="s4">None</span><span class="s2">)</span>

    <span class="s4">assert </span><span class="s1">fi1</span><span class="s2">.</span><span class="s1">factor </span><span class="s4">is </span><span class="s1">f</span>
    <span class="s1">eval123</span><span class="s2">, </span><span class="s1">is_NA </span><span class="s2">= </span><span class="s1">_eval_factor</span><span class="s2">(</span><span class="s1">fi1</span><span class="s2">, {</span><span class="s3">&quot;mock&quot;</span><span class="s2">: [</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s2">]}, </span><span class="s1">naa</span><span class="s2">)</span>
    <span class="s4">assert </span><span class="s1">eval123</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">== (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">1</span><span class="s2">)</span>
    <span class="s4">assert </span><span class="s1">np</span><span class="s2">.</span><span class="s1">all</span><span class="s2">(</span><span class="s1">eval123 </span><span class="s2">== [[</span><span class="s5">1</span><span class="s2">], [</span><span class="s5">2</span><span class="s2">], [</span><span class="s5">3</span><span class="s2">]])</span>
    <span class="s4">assert </span><span class="s1">is_NA</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">== (</span><span class="s5">3</span><span class="s2">,)</span>
    <span class="s4">assert </span><span class="s1">np</span><span class="s2">.</span><span class="s1">all</span><span class="s2">(~</span><span class="s1">is_NA</span><span class="s2">)</span>
    <span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">PatsyError</span><span class="s2">, </span><span class="s1">_eval_factor</span><span class="s2">, </span><span class="s1">fi1</span><span class="s2">, {</span><span class="s3">&quot;mock&quot;</span><span class="s2">: [[[</span><span class="s5">1</span><span class="s2">]]]}, </span><span class="s1">naa</span><span class="s2">)</span>
    <span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">PatsyError</span><span class="s2">, </span><span class="s1">_eval_factor</span><span class="s2">, </span><span class="s1">fi1</span><span class="s2">, {</span><span class="s3">&quot;mock&quot;</span><span class="s2">: [[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">]]}, </span><span class="s1">naa</span><span class="s2">)</span>
    <span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">PatsyError</span><span class="s2">, </span><span class="s1">_eval_factor</span><span class="s2">, </span><span class="s1">fi1</span><span class="s2">, {</span><span class="s3">&quot;mock&quot;</span><span class="s2">: [</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s2">]}, </span><span class="s1">naa</span><span class="s2">)</span>
    <span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">PatsyError</span><span class="s2">, </span><span class="s1">_eval_factor</span><span class="s2">, </span><span class="s1">fi1</span><span class="s2">, {</span><span class="s3">&quot;mock&quot;</span><span class="s2">: [</span><span class="s4">True</span><span class="s2">, </span><span class="s4">False</span><span class="s2">]}, </span><span class="s1">naa</span><span class="s2">)</span>
    <span class="s1">fi2 </span><span class="s2">= </span><span class="s1">FactorInfo</span><span class="s2">(</span><span class="s1">_MockFactor</span><span class="s2">(), </span><span class="s3">&quot;numerical&quot;</span><span class="s2">,</span>
                     <span class="s2">{}, </span><span class="s1">num_columns</span><span class="s2">=</span><span class="s5">2</span><span class="s2">, </span><span class="s1">categories</span><span class="s2">=</span><span class="s4">None</span><span class="s2">)</span>
    <span class="s1">eval123321</span><span class="s2">, </span><span class="s1">is_NA </span><span class="s2">= </span><span class="s1">_eval_factor</span><span class="s2">(</span><span class="s1">fi2</span><span class="s2">,</span>
                                     <span class="s2">{</span><span class="s3">&quot;mock&quot;</span><span class="s2">: [[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">3</span><span class="s2">], [</span><span class="s5">2</span><span class="s2">, </span><span class="s5">2</span><span class="s2">], [</span><span class="s5">3</span><span class="s2">, </span><span class="s5">1</span><span class="s2">]]},</span>
                                     <span class="s1">naa</span><span class="s2">)</span>
    <span class="s4">assert </span><span class="s1">eval123321</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">== (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">2</span><span class="s2">)</span>
    <span class="s4">assert </span><span class="s1">np</span><span class="s2">.</span><span class="s1">all</span><span class="s2">(</span><span class="s1">eval123321 </span><span class="s2">== [[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">3</span><span class="s2">], [</span><span class="s5">2</span><span class="s2">, </span><span class="s5">2</span><span class="s2">], [</span><span class="s5">3</span><span class="s2">, </span><span class="s5">1</span><span class="s2">]])</span>
    <span class="s4">assert </span><span class="s1">is_NA</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">== (</span><span class="s5">3</span><span class="s2">,)</span>
    <span class="s4">assert </span><span class="s1">np</span><span class="s2">.</span><span class="s1">all</span><span class="s2">(~</span><span class="s1">is_NA</span><span class="s2">)</span>
    <span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">PatsyError</span><span class="s2">, </span><span class="s1">_eval_factor</span><span class="s2">, </span><span class="s1">fi2</span><span class="s2">, {</span><span class="s3">&quot;mock&quot;</span><span class="s2">: [</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s2">]}, </span><span class="s1">naa</span><span class="s2">)</span>
    <span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">PatsyError</span><span class="s2">, </span><span class="s1">_eval_factor</span><span class="s2">, </span><span class="s1">fi2</span><span class="s2">, {</span><span class="s3">&quot;mock&quot;</span><span class="s2">: [[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s2">]]}, </span><span class="s1">naa</span><span class="s2">)</span>

    <span class="s1">ev_nan</span><span class="s2">, </span><span class="s1">is_NA </span><span class="s2">= </span><span class="s1">_eval_factor</span><span class="s2">(</span><span class="s1">fi1</span><span class="s2">, {</span><span class="s3">&quot;mock&quot;</span><span class="s2">: [</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">nan</span><span class="s2">]},</span>
                                 <span class="s1">NAAction</span><span class="s2">(</span><span class="s1">NA_types</span><span class="s2">=[</span><span class="s3">&quot;NaN&quot;</span><span class="s2">]))</span>
    <span class="s4">assert </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array_equal</span><span class="s2">(</span><span class="s1">is_NA</span><span class="s2">, [</span><span class="s4">False</span><span class="s2">, </span><span class="s4">False</span><span class="s2">, </span><span class="s4">True</span><span class="s2">])</span>
    <span class="s1">ev_nan</span><span class="s2">, </span><span class="s1">is_NA </span><span class="s2">= </span><span class="s1">_eval_factor</span><span class="s2">(</span><span class="s1">fi1</span><span class="s2">, {</span><span class="s3">&quot;mock&quot;</span><span class="s2">: [</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">nan</span><span class="s2">]},</span>
                                 <span class="s1">NAAction</span><span class="s2">(</span><span class="s1">NA_types</span><span class="s2">=[]))</span>
    <span class="s4">assert </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array_equal</span><span class="s2">(</span><span class="s1">is_NA</span><span class="s2">, [</span><span class="s4">False</span><span class="s2">, </span><span class="s4">False</span><span class="s2">, </span><span class="s4">False</span><span class="s2">])</span>

    <span class="s4">if </span><span class="s1">have_pandas</span><span class="s2">:</span>
        <span class="s1">eval_ser</span><span class="s2">, </span><span class="s1">_ </span><span class="s2">= </span><span class="s1">_eval_factor</span><span class="s2">(</span><span class="s1">fi1</span><span class="s2">,</span>
                                   <span class="s2">{</span><span class="s3">&quot;mock&quot;</span><span class="s2">:</span>
                                    <span class="s1">pandas</span><span class="s2">.</span><span class="s1">Series</span><span class="s2">([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s2">],</span>
                                                  <span class="s1">index</span><span class="s2">=[</span><span class="s5">10</span><span class="s2">, </span><span class="s5">20</span><span class="s2">, </span><span class="s5">30</span><span class="s2">])},</span>
                                   <span class="s1">naa</span><span class="s2">)</span>
        <span class="s4">assert </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">eval_ser</span><span class="s2">, </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">DataFrame</span><span class="s2">)</span>
        <span class="s4">assert </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array_equal</span><span class="s2">(</span><span class="s1">eval_ser</span><span class="s2">, [[</span><span class="s5">1</span><span class="s2">], [</span><span class="s5">2</span><span class="s2">], [</span><span class="s5">3</span><span class="s2">]])</span>
        <span class="s4">assert </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array_equal</span><span class="s2">(</span><span class="s1">eval_ser</span><span class="s2">.</span><span class="s1">index</span><span class="s2">, [</span><span class="s5">10</span><span class="s2">, </span><span class="s5">20</span><span class="s2">, </span><span class="s5">30</span><span class="s2">])</span>
        <span class="s1">eval_df1</span><span class="s2">, </span><span class="s1">_ </span><span class="s2">= </span><span class="s1">_eval_factor</span><span class="s2">(</span><span class="s1">fi1</span><span class="s2">,</span>
                                   <span class="s2">{</span><span class="s3">&quot;mock&quot;</span><span class="s2">:</span>
                                    <span class="s1">pandas</span><span class="s2">.</span><span class="s1">DataFrame</span><span class="s2">([[</span><span class="s5">2</span><span class="s2">], [</span><span class="s5">1</span><span class="s2">], [</span><span class="s5">3</span><span class="s2">]],</span>
                                                     <span class="s1">index</span><span class="s2">=[</span><span class="s5">20</span><span class="s2">, </span><span class="s5">10</span><span class="s2">, </span><span class="s5">30</span><span class="s2">])},</span>
                                   <span class="s1">naa</span><span class="s2">)</span>
        <span class="s4">assert </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">eval_df1</span><span class="s2">, </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">DataFrame</span><span class="s2">)</span>
        <span class="s4">assert </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array_equal</span><span class="s2">(</span><span class="s1">eval_df1</span><span class="s2">, [[</span><span class="s5">2</span><span class="s2">], [</span><span class="s5">1</span><span class="s2">], [</span><span class="s5">3</span><span class="s2">]])</span>
        <span class="s4">assert </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array_equal</span><span class="s2">(</span><span class="s1">eval_df1</span><span class="s2">.</span><span class="s1">index</span><span class="s2">, [</span><span class="s5">20</span><span class="s2">, </span><span class="s5">10</span><span class="s2">, </span><span class="s5">30</span><span class="s2">])</span>
        <span class="s1">eval_df2</span><span class="s2">, </span><span class="s1">_ </span><span class="s2">= </span><span class="s1">_eval_factor</span><span class="s2">(</span><span class="s1">fi2</span><span class="s2">,</span>
                                   <span class="s2">{</span><span class="s3">&quot;mock&quot;</span><span class="s2">:</span>
                                    <span class="s1">pandas</span><span class="s2">.</span><span class="s1">DataFrame</span><span class="s2">([[</span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s2">], [</span><span class="s5">1</span><span class="s2">, </span><span class="s5">4</span><span class="s2">], [</span><span class="s5">3</span><span class="s2">, -</span><span class="s5">1</span><span class="s2">]],</span>
                                                     <span class="s1">index</span><span class="s2">=[</span><span class="s5">20</span><span class="s2">, </span><span class="s5">30</span><span class="s2">, </span><span class="s5">10</span><span class="s2">])},</span>
                                   <span class="s1">naa</span><span class="s2">)</span>
        <span class="s4">assert </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">eval_df2</span><span class="s2">, </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">DataFrame</span><span class="s2">)</span>
        <span class="s4">assert </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array_equal</span><span class="s2">(</span><span class="s1">eval_df2</span><span class="s2">, [[</span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s2">], [</span><span class="s5">1</span><span class="s2">, </span><span class="s5">4</span><span class="s2">], [</span><span class="s5">3</span><span class="s2">, -</span><span class="s5">1</span><span class="s2">]])</span>
        <span class="s4">assert </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array_equal</span><span class="s2">(</span><span class="s1">eval_df2</span><span class="s2">.</span><span class="s1">index</span><span class="s2">, [</span><span class="s5">20</span><span class="s2">, </span><span class="s5">30</span><span class="s2">, </span><span class="s5">10</span><span class="s2">])</span>

        <span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">PatsyError</span><span class="s2">,</span>
                      <span class="s1">_eval_factor</span><span class="s2">, </span><span class="s1">fi2</span><span class="s2">,</span>
                      <span class="s2">{</span><span class="s3">&quot;mock&quot;</span><span class="s2">: </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">Series</span><span class="s2">([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s2">], </span><span class="s1">index</span><span class="s2">=[</span><span class="s5">10</span><span class="s2">, </span><span class="s5">20</span><span class="s2">, </span><span class="s5">30</span><span class="s2">])},</span>
                      <span class="s1">naa</span><span class="s2">)</span>
        <span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">PatsyError</span><span class="s2">,</span>
                      <span class="s1">_eval_factor</span><span class="s2">, </span><span class="s1">fi1</span><span class="s2">,</span>
                      <span class="s2">{</span><span class="s3">&quot;mock&quot;</span><span class="s2">:</span>
                       <span class="s1">pandas</span><span class="s2">.</span><span class="s1">DataFrame</span><span class="s2">([[</span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s2">], [</span><span class="s5">1</span><span class="s2">, </span><span class="s5">4</span><span class="s2">], [</span><span class="s5">3</span><span class="s2">, -</span><span class="s5">1</span><span class="s2">]],</span>
                                        <span class="s1">index</span><span class="s2">=[</span><span class="s5">20</span><span class="s2">, </span><span class="s5">30</span><span class="s2">, </span><span class="s5">10</span><span class="s2">])},</span>
                      <span class="s1">naa</span><span class="s2">)</span>

<span class="s4">def </span><span class="s1">test__eval_factor_categorical</span><span class="s2">():</span>
    <span class="s4">import </span><span class="s1">pytest</span>
    <span class="s4">from </span><span class="s1">patsy</span><span class="s2">.</span><span class="s1">categorical </span><span class="s4">import </span><span class="s1">C</span>
    <span class="s1">naa </span><span class="s2">= </span><span class="s1">NAAction</span><span class="s2">()</span>
    <span class="s1">f </span><span class="s2">= </span><span class="s1">_MockFactor</span><span class="s2">()</span>
    <span class="s1">fi1 </span><span class="s2">= </span><span class="s1">FactorInfo</span><span class="s2">(</span><span class="s1">f</span><span class="s2">, </span><span class="s3">&quot;categorical&quot;</span><span class="s2">,</span>
                     <span class="s2">{}, </span><span class="s1">num_columns</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">categories</span><span class="s2">=(</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s2">))</span>
    <span class="s4">assert </span><span class="s1">fi1</span><span class="s2">.</span><span class="s1">factor </span><span class="s4">is </span><span class="s1">f</span>
    <span class="s1">cat1</span><span class="s2">, </span><span class="s1">_ </span><span class="s2">= </span><span class="s1">_eval_factor</span><span class="s2">(</span><span class="s1">fi1</span><span class="s2">, {</span><span class="s3">&quot;mock&quot;</span><span class="s2">: [</span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s2">]}, </span><span class="s1">naa</span><span class="s2">)</span>
    <span class="s4">assert </span><span class="s1">cat1</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">== (</span><span class="s5">3</span><span class="s2">,)</span>
    <span class="s4">assert </span><span class="s1">np</span><span class="s2">.</span><span class="s1">all</span><span class="s2">(</span><span class="s1">cat1 </span><span class="s2">== [</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">])</span>
    <span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">PatsyError</span><span class="s2">, </span><span class="s1">_eval_factor</span><span class="s2">, </span><span class="s1">fi1</span><span class="s2">, {</span><span class="s3">&quot;mock&quot;</span><span class="s2">: [</span><span class="s3">&quot;c&quot;</span><span class="s2">]}, </span><span class="s1">naa</span><span class="s2">)</span>
    <span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">PatsyError</span><span class="s2">, </span><span class="s1">_eval_factor</span><span class="s2">, </span><span class="s1">fi1</span><span class="s2">, {</span><span class="s3">&quot;mock&quot;</span><span class="s2">: </span><span class="s1">C</span><span class="s2">([</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s2">])}, </span><span class="s1">naa</span><span class="s2">)</span>
    <span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">PatsyError</span><span class="s2">, </span><span class="s1">_eval_factor</span><span class="s2">, </span><span class="s1">fi1</span><span class="s2">,</span>
                  <span class="s2">{</span><span class="s3">&quot;mock&quot;</span><span class="s2">: </span><span class="s1">C</span><span class="s2">([</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s2">], </span><span class="s1">levels</span><span class="s2">=[</span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;a&quot;</span><span class="s2">])}, </span><span class="s1">naa</span><span class="s2">)</span>
    <span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">PatsyError</span><span class="s2">, </span><span class="s1">_eval_factor</span><span class="s2">, </span><span class="s1">fi1</span><span class="s2">, {</span><span class="s3">&quot;mock&quot;</span><span class="s2">: [</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">]}, </span><span class="s1">naa</span><span class="s2">)</span>
    <span class="s1">bad_cat </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">([</span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s2">])</span>
    <span class="s1">bad_cat</span><span class="s2">.</span><span class="s1">resize</span><span class="s2">((</span><span class="s5">2</span><span class="s2">, </span><span class="s5">2</span><span class="s2">))</span>
    <span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">PatsyError</span><span class="s2">, </span><span class="s1">_eval_factor</span><span class="s2">, </span><span class="s1">fi1</span><span class="s2">, {</span><span class="s3">&quot;mock&quot;</span><span class="s2">: </span><span class="s1">bad_cat</span><span class="s2">}, </span><span class="s1">naa</span><span class="s2">)</span>

    <span class="s1">cat1_NA</span><span class="s2">, </span><span class="s1">is_NA </span><span class="s2">= </span><span class="s1">_eval_factor</span><span class="s2">(</span><span class="s1">fi1</span><span class="s2">, {</span><span class="s3">&quot;mock&quot;</span><span class="s2">: [</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s4">None</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s2">]},</span>
                                  <span class="s1">NAAction</span><span class="s2">(</span><span class="s1">NA_types</span><span class="s2">=[</span><span class="s3">&quot;None&quot;</span><span class="s2">]))</span>
    <span class="s4">assert </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array_equal</span><span class="s2">(</span><span class="s1">is_NA</span><span class="s2">, [</span><span class="s4">False</span><span class="s2">, </span><span class="s4">True</span><span class="s2">, </span><span class="s4">False</span><span class="s2">])</span>
    <span class="s4">assert </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array_equal</span><span class="s2">(</span><span class="s1">cat1_NA</span><span class="s2">, [</span><span class="s5">0</span><span class="s2">, -</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">])</span>
    <span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">PatsyError</span><span class="s2">, </span><span class="s1">_eval_factor</span><span class="s2">, </span><span class="s1">fi1</span><span class="s2">,</span>
                  <span class="s2">{</span><span class="s3">&quot;mock&quot;</span><span class="s2">: [</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s4">None</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s2">]}, </span><span class="s1">NAAction</span><span class="s2">(</span><span class="s1">NA_types</span><span class="s2">=[]))</span>

    <span class="s1">fi2 </span><span class="s2">= </span><span class="s1">FactorInfo</span><span class="s2">(</span><span class="s1">_MockFactor</span><span class="s2">(), </span><span class="s3">&quot;categorical&quot;</span><span class="s2">, {},</span>
                     <span class="s1">num_columns</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">categories</span><span class="s2">=[</span><span class="s4">False</span><span class="s2">, </span><span class="s4">True</span><span class="s2">])</span>
    <span class="s1">cat2</span><span class="s2">, </span><span class="s1">_ </span><span class="s2">= </span><span class="s1">_eval_factor</span><span class="s2">(</span><span class="s1">fi2</span><span class="s2">, {</span><span class="s3">&quot;mock&quot;</span><span class="s2">: [</span><span class="s4">True</span><span class="s2">, </span><span class="s4">False</span><span class="s2">, </span><span class="s4">False</span><span class="s2">, </span><span class="s4">True</span><span class="s2">]}, </span><span class="s1">naa</span><span class="s2">)</span>
    <span class="s4">assert </span><span class="s1">cat2</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">== (</span><span class="s5">4</span><span class="s2">,)</span>
    <span class="s4">assert </span><span class="s1">np</span><span class="s2">.</span><span class="s1">all</span><span class="s2">(</span><span class="s1">cat2 </span><span class="s2">== [</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">])</span>

    <span class="s4">if </span><span class="s1">have_pandas</span><span class="s2">:</span>
        <span class="s1">s </span><span class="s2">= </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">Series</span><span class="s2">([</span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;a&quot;</span><span class="s2">], </span><span class="s1">index</span><span class="s2">=[</span><span class="s5">10</span><span class="s2">, </span><span class="s5">20</span><span class="s2">])</span>
        <span class="s1">cat_s</span><span class="s2">, </span><span class="s1">_ </span><span class="s2">= </span><span class="s1">_eval_factor</span><span class="s2">(</span><span class="s1">fi1</span><span class="s2">, {</span><span class="s3">&quot;mock&quot;</span><span class="s2">: </span><span class="s1">s</span><span class="s2">}, </span><span class="s1">naa</span><span class="s2">)</span>
        <span class="s4">assert </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">cat_s</span><span class="s2">, </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">Series</span><span class="s2">)</span>
        <span class="s4">assert </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array_equal</span><span class="s2">(</span><span class="s1">cat_s</span><span class="s2">, [</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">])</span>
        <span class="s4">assert </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array_equal</span><span class="s2">(</span><span class="s1">cat_s</span><span class="s2">.</span><span class="s1">index</span><span class="s2">, [</span><span class="s5">10</span><span class="s2">, </span><span class="s5">20</span><span class="s2">])</span>
        <span class="s1">sbool </span><span class="s2">= </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">Series</span><span class="s2">([</span><span class="s4">True</span><span class="s2">, </span><span class="s4">False</span><span class="s2">], </span><span class="s1">index</span><span class="s2">=[</span><span class="s5">11</span><span class="s2">, </span><span class="s5">21</span><span class="s2">])</span>
        <span class="s1">cat_sbool</span><span class="s2">, </span><span class="s1">_ </span><span class="s2">= </span><span class="s1">_eval_factor</span><span class="s2">(</span><span class="s1">fi2</span><span class="s2">, {</span><span class="s3">&quot;mock&quot;</span><span class="s2">: </span><span class="s1">sbool</span><span class="s2">}, </span><span class="s1">naa</span><span class="s2">)</span>
        <span class="s4">assert </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">cat_sbool</span><span class="s2">, </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">Series</span><span class="s2">)</span>
        <span class="s4">assert </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array_equal</span><span class="s2">(</span><span class="s1">cat_sbool</span><span class="s2">, [</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">])</span>
        <span class="s4">assert </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array_equal</span><span class="s2">(</span><span class="s1">cat_sbool</span><span class="s2">.</span><span class="s1">index</span><span class="s2">, [</span><span class="s5">11</span><span class="s2">, </span><span class="s5">21</span><span class="s2">])</span>

<span class="s4">def </span><span class="s1">_column_combinations</span><span class="s2">(</span><span class="s1">columns_per_factor</span><span class="s2">):</span>
    <span class="s0"># For consistency with R, the left-most item iterates fastest:</span>
    <span class="s1">iterators </span><span class="s2">= [</span><span class="s1">range</span><span class="s2">(</span><span class="s1">n</span><span class="s2">) </span><span class="s4">for </span><span class="s1">n </span><span class="s4">in </span><span class="s1">reversed</span><span class="s2">(</span><span class="s1">columns_per_factor</span><span class="s2">)]</span>
    <span class="s4">for </span><span class="s1">reversed_combo </span><span class="s4">in </span><span class="s1">itertools</span><span class="s2">.</span><span class="s1">product</span><span class="s2">(*</span><span class="s1">iterators</span><span class="s2">):</span>
        <span class="s4">yield </span><span class="s1">reversed_combo</span><span class="s2">[::-</span><span class="s5">1</span><span class="s2">]</span>

<span class="s4">def </span><span class="s1">test__column_combinations</span><span class="s2">():</span>
    <span class="s4">assert </span><span class="s1">list</span><span class="s2">(</span><span class="s1">_column_combinations</span><span class="s2">([</span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s2">])) == [(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">),</span>
                                                  <span class="s2">(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">),</span>
                                                  <span class="s2">(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">),</span>
                                                  <span class="s2">(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">),</span>
                                                  <span class="s2">(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">2</span><span class="s2">),</span>
                                                  <span class="s2">(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">)]</span>
    <span class="s4">assert </span><span class="s1">list</span><span class="s2">(</span><span class="s1">_column_combinations</span><span class="s2">([</span><span class="s5">3</span><span class="s2">])) == [(</span><span class="s5">0</span><span class="s2">,), (</span><span class="s5">1</span><span class="s2">,), (</span><span class="s5">2</span><span class="s2">,)]</span>
    <span class="s4">assert </span><span class="s1">list</span><span class="s2">(</span><span class="s1">_column_combinations</span><span class="s2">([])) == [()]</span>

<span class="s4">def </span><span class="s1">_subterm_column_combinations</span><span class="s2">(</span><span class="s1">factor_infos</span><span class="s2">, </span><span class="s1">subterm</span><span class="s2">):</span>
    <span class="s1">columns_per_factor </span><span class="s2">= []</span>
    <span class="s4">for </span><span class="s1">factor </span><span class="s4">in </span><span class="s1">subterm</span><span class="s2">.</span><span class="s1">factors</span><span class="s2">:</span>
        <span class="s4">if </span><span class="s1">factor </span><span class="s4">in </span><span class="s1">subterm</span><span class="s2">.</span><span class="s1">contrast_matrices</span><span class="s2">:</span>
            <span class="s1">columns </span><span class="s2">= </span><span class="s1">subterm</span><span class="s2">.</span><span class="s1">contrast_matrices</span><span class="s2">[</span><span class="s1">factor</span><span class="s2">].</span><span class="s1">matrix</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">1</span><span class="s2">]</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">columns </span><span class="s2">= </span><span class="s1">factor_infos</span><span class="s2">[</span><span class="s1">factor</span><span class="s2">].</span><span class="s1">num_columns</span>
        <span class="s1">columns_per_factor</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">columns</span><span class="s2">)</span>
    <span class="s4">return </span><span class="s1">_column_combinations</span><span class="s2">(</span><span class="s1">columns_per_factor</span><span class="s2">)</span>

<span class="s4">def </span><span class="s1">_subterm_column_names_iter</span><span class="s2">(</span><span class="s1">factor_infos</span><span class="s2">, </span><span class="s1">subterm</span><span class="s2">):</span>
    <span class="s1">total </span><span class="s2">= </span><span class="s5">0</span>
    <span class="s4">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">column_idxs </span><span class="s4">in </span><span class="s1">enumerate</span><span class="s2">(</span>
            <span class="s1">_subterm_column_combinations</span><span class="s2">(</span><span class="s1">factor_infos</span><span class="s2">, </span><span class="s1">subterm</span><span class="s2">)):</span>
        <span class="s1">name_pieces </span><span class="s2">= []</span>
        <span class="s4">for </span><span class="s1">factor</span><span class="s2">, </span><span class="s1">column_idx </span><span class="s4">in </span><span class="s1">zip</span><span class="s2">(</span><span class="s1">subterm</span><span class="s2">.</span><span class="s1">factors</span><span class="s2">, </span><span class="s1">column_idxs</span><span class="s2">):</span>
            <span class="s1">fi </span><span class="s2">= </span><span class="s1">factor_infos</span><span class="s2">[</span><span class="s1">factor</span><span class="s2">]</span>
            <span class="s4">if </span><span class="s1">fi</span><span class="s2">.</span><span class="s1">type </span><span class="s2">== </span><span class="s3">&quot;numerical&quot;</span><span class="s2">:</span>
                <span class="s4">if </span><span class="s1">fi</span><span class="s2">.</span><span class="s1">num_columns </span><span class="s2">&gt; </span><span class="s5">1</span><span class="s2">:</span>
                    <span class="s1">name_pieces</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s3">&quot;%s[%s]&quot;</span>
                                       <span class="s2">% (</span><span class="s1">factor</span><span class="s2">.</span><span class="s1">name</span><span class="s2">(), </span><span class="s1">column_idx</span><span class="s2">))</span>
                <span class="s4">else</span><span class="s2">:</span>
                    <span class="s4">assert </span><span class="s1">column_idx </span><span class="s2">== </span><span class="s5">0</span>
                    <span class="s1">name_pieces</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">factor</span><span class="s2">.</span><span class="s1">name</span><span class="s2">())</span>
            <span class="s4">else</span><span class="s2">:</span>
                <span class="s4">assert </span><span class="s1">fi</span><span class="s2">.</span><span class="s1">type </span><span class="s2">== </span><span class="s3">&quot;categorical&quot;</span>
                <span class="s1">contrast </span><span class="s2">= </span><span class="s1">subterm</span><span class="s2">.</span><span class="s1">contrast_matrices</span><span class="s2">[</span><span class="s1">factor</span><span class="s2">]</span>
                <span class="s1">suffix </span><span class="s2">= </span><span class="s1">contrast</span><span class="s2">.</span><span class="s1">column_suffixes</span><span class="s2">[</span><span class="s1">column_idx</span><span class="s2">]</span>
                <span class="s1">name_pieces</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s3">&quot;%s%s&quot; </span><span class="s2">% (</span><span class="s1">factor</span><span class="s2">.</span><span class="s1">name</span><span class="s2">(), </span><span class="s1">suffix</span><span class="s2">))</span>
        <span class="s4">if not </span><span class="s1">name_pieces</span><span class="s2">:</span>
            <span class="s4">yield </span><span class="s3">&quot;Intercept&quot;</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s4">yield </span><span class="s3">&quot;:&quot;</span><span class="s2">.</span><span class="s1">join</span><span class="s2">(</span><span class="s1">name_pieces</span><span class="s2">)</span>
        <span class="s1">total </span><span class="s2">+= </span><span class="s5">1</span>
    <span class="s4">assert </span><span class="s1">total </span><span class="s2">== </span><span class="s1">subterm</span><span class="s2">.</span><span class="s1">num_columns</span>

<span class="s4">def </span><span class="s1">_build_subterm</span><span class="s2">(</span><span class="s1">subterm</span><span class="s2">, </span><span class="s1">factor_infos</span><span class="s2">, </span><span class="s1">factor_values</span><span class="s2">, </span><span class="s1">out</span><span class="s2">):</span>
    <span class="s4">assert </span><span class="s1">subterm</span><span class="s2">.</span><span class="s1">num_columns </span><span class="s2">== </span><span class="s1">out</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">1</span><span class="s2">]</span>
    <span class="s1">out</span><span class="s2">[...] = </span><span class="s5">1</span>
    <span class="s4">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">column_idxs </span><span class="s4">in </span><span class="s1">enumerate</span><span class="s2">(</span>
            <span class="s1">_subterm_column_combinations</span><span class="s2">(</span><span class="s1">factor_infos</span><span class="s2">, </span><span class="s1">subterm</span><span class="s2">)):</span>
        <span class="s4">for </span><span class="s1">factor</span><span class="s2">, </span><span class="s1">column_idx </span><span class="s4">in </span><span class="s1">zip</span><span class="s2">(</span><span class="s1">subterm</span><span class="s2">.</span><span class="s1">factors</span><span class="s2">, </span><span class="s1">column_idxs</span><span class="s2">):</span>
            <span class="s4">if </span><span class="s1">factor_infos</span><span class="s2">[</span><span class="s1">factor</span><span class="s2">].</span><span class="s1">type </span><span class="s2">== </span><span class="s3">&quot;categorical&quot;</span><span class="s2">:</span>
                <span class="s1">contrast </span><span class="s2">= </span><span class="s1">subterm</span><span class="s2">.</span><span class="s1">contrast_matrices</span><span class="s2">[</span><span class="s1">factor</span><span class="s2">]</span>
                <span class="s4">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">any</span><span class="s2">(</span><span class="s1">factor_values</span><span class="s2">[</span><span class="s1">factor</span><span class="s2">] &lt; </span><span class="s5">0</span><span class="s2">):</span>
                    <span class="s4">raise </span><span class="s1">PatsyError</span><span class="s2">(</span><span class="s3">&quot;can't build a design matrix &quot;</span>
                                     <span class="s3">&quot;containing missing values&quot;</span><span class="s2">, </span><span class="s1">factor</span><span class="s2">)</span>
                <span class="s1">out</span><span class="s2">[:, </span><span class="s1">i</span><span class="s2">] *= </span><span class="s1">contrast</span><span class="s2">.</span><span class="s1">matrix</span><span class="s2">[</span><span class="s1">factor_values</span><span class="s2">[</span><span class="s1">factor</span><span class="s2">],</span>
                                             <span class="s1">column_idx</span><span class="s2">]</span>
            <span class="s4">else</span><span class="s2">:</span>
                <span class="s4">assert </span><span class="s1">factor_infos</span><span class="s2">[</span><span class="s1">factor</span><span class="s2">].</span><span class="s1">type </span><span class="s2">== </span><span class="s3">&quot;numerical&quot;</span>
                <span class="s4">assert </span><span class="s2">(</span><span class="s1">factor_values</span><span class="s2">[</span><span class="s1">factor</span><span class="s2">].</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">1</span><span class="s2">]</span>
                        <span class="s2">== </span><span class="s1">factor_infos</span><span class="s2">[</span><span class="s1">factor</span><span class="s2">].</span><span class="s1">num_columns</span><span class="s2">)</span>
                <span class="s1">out</span><span class="s2">[:, </span><span class="s1">i</span><span class="s2">] *= </span><span class="s1">factor_values</span><span class="s2">[</span><span class="s1">factor</span><span class="s2">][:, </span><span class="s1">column_idx</span><span class="s2">]</span>

<span class="s4">def </span><span class="s1">test__subterm_column_names_iter_and__build_subterm</span><span class="s2">():</span>
    <span class="s4">import </span><span class="s1">pytest</span>
    <span class="s4">from </span><span class="s1">patsy</span><span class="s2">.</span><span class="s1">contrasts </span><span class="s4">import </span><span class="s1">ContrastMatrix</span>
    <span class="s4">from </span><span class="s1">patsy</span><span class="s2">.</span><span class="s1">categorical </span><span class="s4">import </span><span class="s1">C</span>
    <span class="s1">f1 </span><span class="s2">= </span><span class="s1">_MockFactor</span><span class="s2">(</span><span class="s3">&quot;f1&quot;</span><span class="s2">)</span>
    <span class="s1">f2 </span><span class="s2">= </span><span class="s1">_MockFactor</span><span class="s2">(</span><span class="s3">&quot;f2&quot;</span><span class="s2">)</span>
    <span class="s1">f3 </span><span class="s2">= </span><span class="s1">_MockFactor</span><span class="s2">(</span><span class="s3">&quot;f3&quot;</span><span class="s2">)</span>
    <span class="s1">contrast </span><span class="s2">= </span><span class="s1">ContrastMatrix</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0.5</span><span class="s2">],</span>
                                        <span class="s2">[</span><span class="s5">3</span><span class="s2">, </span><span class="s5">0</span><span class="s2">]]),</span>
                              <span class="s2">[</span><span class="s3">&quot;[c1]&quot;</span><span class="s2">, </span><span class="s3">&quot;[c2]&quot;</span><span class="s2">])</span>

    <span class="s1">factor_infos1 </span><span class="s2">= {</span><span class="s1">f1</span><span class="s2">: </span><span class="s1">FactorInfo</span><span class="s2">(</span><span class="s1">f1</span><span class="s2">, </span><span class="s3">&quot;numerical&quot;</span><span class="s2">, {},</span>
                                    <span class="s1">num_columns</span><span class="s2">=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">categories</span><span class="s2">=</span><span class="s4">None</span><span class="s2">),</span>
                     <span class="s1">f2</span><span class="s2">: </span><span class="s1">FactorInfo</span><span class="s2">(</span><span class="s1">f2</span><span class="s2">, </span><span class="s3">&quot;categorical&quot;</span><span class="s2">, {},</span>
                                    <span class="s1">num_columns</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">categories</span><span class="s2">=[</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s2">]),</span>
                     <span class="s1">f3</span><span class="s2">: </span><span class="s1">FactorInfo</span><span class="s2">(</span><span class="s1">f3</span><span class="s2">, </span><span class="s3">&quot;numerical&quot;</span><span class="s2">, {},</span>
                                    <span class="s1">num_columns</span><span class="s2">=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">categories</span><span class="s2">=</span><span class="s4">None</span><span class="s2">),</span>
                     <span class="s2">}</span>
    <span class="s1">contrast_matrices </span><span class="s2">= {</span><span class="s1">f2</span><span class="s2">: </span><span class="s1">contrast</span><span class="s2">}</span>
    <span class="s1">subterm1 </span><span class="s2">= </span><span class="s1">SubtermInfo</span><span class="s2">([</span><span class="s1">f1</span><span class="s2">, </span><span class="s1">f2</span><span class="s2">, </span><span class="s1">f3</span><span class="s2">], </span><span class="s1">contrast_matrices</span><span class="s2">, </span><span class="s5">2</span><span class="s2">)</span>
    <span class="s4">assert </span><span class="s2">(</span><span class="s1">list</span><span class="s2">(</span><span class="s1">_subterm_column_names_iter</span><span class="s2">(</span><span class="s1">factor_infos1</span><span class="s2">, </span><span class="s1">subterm1</span><span class="s2">))</span>
            <span class="s2">== [</span><span class="s3">&quot;f1:f2[c1]:f3&quot;</span><span class="s2">, </span><span class="s3">&quot;f1:f2[c2]:f3&quot;</span><span class="s2">])</span>

    <span class="s1">mat </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">((</span><span class="s5">3</span><span class="s2">, </span><span class="s5">2</span><span class="s2">))</span>
    <span class="s1">_build_subterm</span><span class="s2">(</span><span class="s1">subterm1</span><span class="s2">, </span><span class="s1">factor_infos1</span><span class="s2">,</span>
                   <span class="s2">{</span><span class="s1">f1</span><span class="s2">: </span><span class="s1">atleast_2d_column_default</span><span class="s2">([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s2">]),</span>
                    <span class="s1">f2</span><span class="s2">: </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">([</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">]),</span>
                    <span class="s1">f3</span><span class="s2">: </span><span class="s1">atleast_2d_column_default</span><span class="s2">([</span><span class="s5">7.5</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, -</span><span class="s5">12</span><span class="s2">])},</span>
                   <span class="s1">mat</span><span class="s2">)</span>
    <span class="s4">assert </span><span class="s1">np</span><span class="s2">.</span><span class="s1">allclose</span><span class="s2">(</span><span class="s1">mat</span><span class="s2">, [[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0.5 </span><span class="s2">* </span><span class="s5">1 </span><span class="s2">* </span><span class="s5">7.5</span><span class="s2">],</span>
                             <span class="s2">[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0.5 </span><span class="s2">* </span><span class="s5">2 </span><span class="s2">* </span><span class="s5">2</span><span class="s2">],</span>
                             <span class="s2">[</span><span class="s5">3 </span><span class="s2">* </span><span class="s5">3 </span><span class="s2">* -</span><span class="s5">12</span><span class="s2">, </span><span class="s5">0</span><span class="s2">]])</span>
    <span class="s0"># Check that missing categorical values blow up</span>
    <span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">PatsyError</span><span class="s2">, </span><span class="s1">_build_subterm</span><span class="s2">, </span><span class="s1">subterm1</span><span class="s2">, </span><span class="s1">factor_infos1</span><span class="s2">,</span>
                  <span class="s2">{</span><span class="s1">f1</span><span class="s2">: </span><span class="s1">atleast_2d_column_default</span><span class="s2">([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s2">]),</span>
                   <span class="s1">f2</span><span class="s2">: </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">([</span><span class="s5">0</span><span class="s2">, -</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">]),</span>
                   <span class="s1">f3</span><span class="s2">: </span><span class="s1">atleast_2d_column_default</span><span class="s2">([</span><span class="s5">7.5</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, -</span><span class="s5">12</span><span class="s2">])},</span>
                  <span class="s1">mat</span><span class="s2">)</span>

    <span class="s1">factor_infos2 </span><span class="s2">= </span><span class="s1">dict</span><span class="s2">(</span><span class="s1">factor_infos1</span><span class="s2">)</span>
    <span class="s1">factor_infos2</span><span class="s2">[</span><span class="s1">f1</span><span class="s2">] = </span><span class="s1">FactorInfo</span><span class="s2">(</span><span class="s1">f1</span><span class="s2">, </span><span class="s3">&quot;numerical&quot;</span><span class="s2">, {},</span>
                                   <span class="s1">num_columns</span><span class="s2">=</span><span class="s5">2</span><span class="s2">, </span><span class="s1">categories</span><span class="s2">=</span><span class="s4">None</span><span class="s2">)</span>
    <span class="s1">subterm2 </span><span class="s2">= </span><span class="s1">SubtermInfo</span><span class="s2">([</span><span class="s1">f1</span><span class="s2">, </span><span class="s1">f2</span><span class="s2">, </span><span class="s1">f3</span><span class="s2">], </span><span class="s1">contrast_matrices</span><span class="s2">, </span><span class="s5">4</span><span class="s2">)</span>
    <span class="s4">assert </span><span class="s2">(</span><span class="s1">list</span><span class="s2">(</span><span class="s1">_subterm_column_names_iter</span><span class="s2">(</span><span class="s1">factor_infos2</span><span class="s2">, </span><span class="s1">subterm2</span><span class="s2">))</span>
            <span class="s2">== [</span><span class="s3">&quot;f1[0]:f2[c1]:f3&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;f1[1]:f2[c1]:f3&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;f1[0]:f2[c2]:f3&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;f1[1]:f2[c2]:f3&quot;</span><span class="s2">])</span>

    <span class="s1">mat2 </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">((</span><span class="s5">3</span><span class="s2">, </span><span class="s5">4</span><span class="s2">))</span>
    <span class="s1">_build_subterm</span><span class="s2">(</span><span class="s1">subterm2</span><span class="s2">, </span><span class="s1">factor_infos2</span><span class="s2">,</span>
                   <span class="s2">{</span><span class="s1">f1</span><span class="s2">: </span><span class="s1">atleast_2d_column_default</span><span class="s2">([[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">], [</span><span class="s5">3</span><span class="s2">, </span><span class="s5">4</span><span class="s2">], [</span><span class="s5">5</span><span class="s2">, </span><span class="s5">6</span><span class="s2">]]),</span>
                    <span class="s1">f2</span><span class="s2">: </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">([</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">]),</span>
                    <span class="s1">f3</span><span class="s2">: </span><span class="s1">atleast_2d_column_default</span><span class="s2">([</span><span class="s5">7.5</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, -</span><span class="s5">12</span><span class="s2">])},</span>
                   <span class="s1">mat2</span><span class="s2">)</span>
    <span class="s4">assert </span><span class="s1">np</span><span class="s2">.</span><span class="s1">allclose</span><span class="s2">(</span><span class="s1">mat2</span><span class="s2">, [[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0.5 </span><span class="s2">* </span><span class="s5">1 </span><span class="s2">* </span><span class="s5">7.5</span><span class="s2">, </span><span class="s5">0.5 </span><span class="s2">* </span><span class="s5">2 </span><span class="s2">* </span><span class="s5">7.5</span><span class="s2">],</span>
                              <span class="s2">[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0.5 </span><span class="s2">* </span><span class="s5">3 </span><span class="s2">* </span><span class="s5">2</span><span class="s2">, </span><span class="s5">0.5 </span><span class="s2">* </span><span class="s5">4 </span><span class="s2">* </span><span class="s5">2</span><span class="s2">],</span>
                              <span class="s2">[</span><span class="s5">3 </span><span class="s2">* </span><span class="s5">5 </span><span class="s2">* -</span><span class="s5">12</span><span class="s2">, </span><span class="s5">3 </span><span class="s2">* </span><span class="s5">6 </span><span class="s2">* -</span><span class="s5">12</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">]])</span>


    <span class="s1">subterm_int </span><span class="s2">= </span><span class="s1">SubtermInfo</span><span class="s2">([], {}, </span><span class="s5">1</span><span class="s2">)</span>
    <span class="s4">assert </span><span class="s1">list</span><span class="s2">(</span><span class="s1">_subterm_column_names_iter</span><span class="s2">({}, </span><span class="s1">subterm_int</span><span class="s2">)) == [</span><span class="s3">&quot;Intercept&quot;</span><span class="s2">]</span>

    <span class="s1">mat3 </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">((</span><span class="s5">3</span><span class="s2">, </span><span class="s5">1</span><span class="s2">))</span>
    <span class="s1">_build_subterm</span><span class="s2">(</span><span class="s1">subterm_int</span><span class="s2">, {},</span>
                   <span class="s2">{</span><span class="s1">f1</span><span class="s2">: [</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s2">], </span><span class="s1">f2</span><span class="s2">: [</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s2">], </span><span class="s1">f3</span><span class="s2">: [</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s2">]},</span>
                   <span class="s1">mat3</span><span class="s2">)</span>
    <span class="s4">assert </span><span class="s1">np</span><span class="s2">.</span><span class="s1">allclose</span><span class="s2">(</span><span class="s1">mat3</span><span class="s2">, </span><span class="s5">1</span><span class="s2">)</span>

<span class="s4">def </span><span class="s1">_factors_memorize</span><span class="s2">(</span><span class="s1">factors</span><span class="s2">, </span><span class="s1">data_iter_maker</span><span class="s2">, </span><span class="s1">eval_env</span><span class="s2">):</span>
    <span class="s0"># First, start off the memorization process by setting up each factor's</span>
    <span class="s0"># state and finding out how many passes it will need:</span>
    <span class="s1">factor_states </span><span class="s2">= {}</span>
    <span class="s1">passes_needed </span><span class="s2">= {}</span>
    <span class="s4">for </span><span class="s1">factor </span><span class="s4">in </span><span class="s1">factors</span><span class="s2">:</span>
        <span class="s1">state </span><span class="s2">= {}</span>
        <span class="s1">which_pass </span><span class="s2">= </span><span class="s1">factor</span><span class="s2">.</span><span class="s1">memorize_passes_needed</span><span class="s2">(</span><span class="s1">state</span><span class="s2">, </span><span class="s1">eval_env</span><span class="s2">)</span>
        <span class="s1">factor_states</span><span class="s2">[</span><span class="s1">factor</span><span class="s2">] = </span><span class="s1">state</span>
        <span class="s1">passes_needed</span><span class="s2">[</span><span class="s1">factor</span><span class="s2">] = </span><span class="s1">which_pass</span>
    <span class="s0"># Now, cycle through the data until all the factors have finished</span>
    <span class="s0"># memorizing everything:</span>
    <span class="s1">memorize_needed </span><span class="s2">= </span><span class="s1">set</span><span class="s2">()</span>
    <span class="s4">for </span><span class="s1">factor</span><span class="s2">, </span><span class="s1">passes </span><span class="s4">in </span><span class="s1">six</span><span class="s2">.</span><span class="s1">iteritems</span><span class="s2">(</span><span class="s1">passes_needed</span><span class="s2">):</span>
        <span class="s4">if </span><span class="s1">passes </span><span class="s2">&gt; </span><span class="s5">0</span><span class="s2">:</span>
            <span class="s1">memorize_needed</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">factor</span><span class="s2">)</span>
    <span class="s1">which_pass </span><span class="s2">= </span><span class="s5">0</span>
    <span class="s4">while </span><span class="s1">memorize_needed</span><span class="s2">:</span>
        <span class="s4">for </span><span class="s1">data </span><span class="s4">in </span><span class="s1">data_iter_maker</span><span class="s2">():</span>
            <span class="s4">for </span><span class="s1">factor </span><span class="s4">in </span><span class="s1">memorize_needed</span><span class="s2">:</span>
                <span class="s1">state </span><span class="s2">= </span><span class="s1">factor_states</span><span class="s2">[</span><span class="s1">factor</span><span class="s2">]</span>
                <span class="s1">factor</span><span class="s2">.</span><span class="s1">memorize_chunk</span><span class="s2">(</span><span class="s1">state</span><span class="s2">, </span><span class="s1">which_pass</span><span class="s2">, </span><span class="s1">data</span><span class="s2">)</span>
        <span class="s4">for </span><span class="s1">factor </span><span class="s4">in </span><span class="s1">list</span><span class="s2">(</span><span class="s1">memorize_needed</span><span class="s2">):</span>
            <span class="s1">factor</span><span class="s2">.</span><span class="s1">memorize_finish</span><span class="s2">(</span><span class="s1">factor_states</span><span class="s2">[</span><span class="s1">factor</span><span class="s2">], </span><span class="s1">which_pass</span><span class="s2">)</span>
            <span class="s4">if </span><span class="s1">which_pass </span><span class="s2">== </span><span class="s1">passes_needed</span><span class="s2">[</span><span class="s1">factor</span><span class="s2">] - </span><span class="s5">1</span><span class="s2">:</span>
                <span class="s1">memorize_needed</span><span class="s2">.</span><span class="s1">remove</span><span class="s2">(</span><span class="s1">factor</span><span class="s2">)</span>
        <span class="s1">which_pass </span><span class="s2">+= </span><span class="s5">1</span>
    <span class="s4">return </span><span class="s1">factor_states</span>

<span class="s4">def </span><span class="s1">test__factors_memorize</span><span class="s2">():</span>
    <span class="s4">class </span><span class="s1">MockFactor</span><span class="s2">(</span><span class="s1">object</span><span class="s2">):</span>
        <span class="s4">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">requested_passes</span><span class="s2">, </span><span class="s1">token</span><span class="s2">):</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_requested_passes </span><span class="s2">= </span><span class="s1">requested_passes</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_token </span><span class="s2">= </span><span class="s1">token</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_chunk_in_pass </span><span class="s2">= </span><span class="s5">0</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_seen_passes </span><span class="s2">= </span><span class="s5">0</span>

        <span class="s4">def </span><span class="s1">memorize_passes_needed</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">state</span><span class="s2">, </span><span class="s1">eval_env</span><span class="s2">):</span>
            <span class="s1">state</span><span class="s2">[</span><span class="s3">&quot;calls&quot;</span><span class="s2">] = []</span>
            <span class="s1">state</span><span class="s2">[</span><span class="s3">&quot;token&quot;</span><span class="s2">] = </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_token</span>
            <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_requested_passes</span>

        <span class="s4">def </span><span class="s1">memorize_chunk</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">state</span><span class="s2">, </span><span class="s1">which_pass</span><span class="s2">, </span><span class="s1">data</span><span class="s2">):</span>
            <span class="s1">state</span><span class="s2">[</span><span class="s3">&quot;calls&quot;</span><span class="s2">].</span><span class="s1">append</span><span class="s2">((</span><span class="s3">&quot;memorize_chunk&quot;</span><span class="s2">, </span><span class="s1">which_pass</span><span class="s2">))</span>
            <span class="s4">assert </span><span class="s1">data</span><span class="s2">[</span><span class="s3">&quot;chunk&quot;</span><span class="s2">] == </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_chunk_in_pass</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_chunk_in_pass </span><span class="s2">+= </span><span class="s5">1</span>

        <span class="s4">def </span><span class="s1">memorize_finish</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">state</span><span class="s2">, </span><span class="s1">which_pass</span><span class="s2">):</span>
            <span class="s1">state</span><span class="s2">[</span><span class="s3">&quot;calls&quot;</span><span class="s2">].</span><span class="s1">append</span><span class="s2">((</span><span class="s3">&quot;memorize_finish&quot;</span><span class="s2">, </span><span class="s1">which_pass</span><span class="s2">))</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_chunk_in_pass </span><span class="s2">= </span><span class="s5">0</span>

    <span class="s4">class </span><span class="s1">Data</span><span class="s2">(</span><span class="s1">object</span><span class="s2">):</span>
        <span class="s1">CHUNKS </span><span class="s2">= </span><span class="s5">3</span>
        <span class="s4">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">calls </span><span class="s2">= </span><span class="s5">0</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">data </span><span class="s2">= [{</span><span class="s3">&quot;chunk&quot;</span><span class="s2">: </span><span class="s1">i</span><span class="s2">} </span><span class="s4">for </span><span class="s1">i </span><span class="s4">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">CHUNKS</span><span class="s2">)]</span>
        <span class="s4">def </span><span class="s1">__call__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">calls </span><span class="s2">+= </span><span class="s5">1</span>
            <span class="s4">return </span><span class="s1">iter</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">)</span>
    <span class="s1">data </span><span class="s2">= </span><span class="s1">Data</span><span class="s2">()</span>
    <span class="s1">f0 </span><span class="s2">= </span><span class="s1">MockFactor</span><span class="s2">(</span><span class="s5">0</span><span class="s2">, </span><span class="s3">&quot;f0&quot;</span><span class="s2">)</span>
    <span class="s1">f1 </span><span class="s2">= </span><span class="s1">MockFactor</span><span class="s2">(</span><span class="s5">1</span><span class="s2">, </span><span class="s3">&quot;f1&quot;</span><span class="s2">)</span>
    <span class="s1">f2a </span><span class="s2">= </span><span class="s1">MockFactor</span><span class="s2">(</span><span class="s5">2</span><span class="s2">, </span><span class="s3">&quot;f2a&quot;</span><span class="s2">)</span>
    <span class="s1">f2b </span><span class="s2">= </span><span class="s1">MockFactor</span><span class="s2">(</span><span class="s5">2</span><span class="s2">, </span><span class="s3">&quot;f2b&quot;</span><span class="s2">)</span>
    <span class="s1">factor_states </span><span class="s2">= </span><span class="s1">_factors_memorize</span><span class="s2">(</span><span class="s1">set</span><span class="s2">([</span><span class="s1">f0</span><span class="s2">, </span><span class="s1">f1</span><span class="s2">, </span><span class="s1">f2a</span><span class="s2">, </span><span class="s1">f2b</span><span class="s2">]), </span><span class="s1">data</span><span class="s2">, {})</span>
    <span class="s4">assert </span><span class="s1">data</span><span class="s2">.</span><span class="s1">calls </span><span class="s2">== </span><span class="s5">2</span>
    <span class="s1">mem_chunks0 </span><span class="s2">= [(</span><span class="s3">&quot;memorize_chunk&quot;</span><span class="s2">, </span><span class="s5">0</span><span class="s2">)] * </span><span class="s1">data</span><span class="s2">.</span><span class="s1">CHUNKS</span>
    <span class="s1">mem_chunks1 </span><span class="s2">= [(</span><span class="s3">&quot;memorize_chunk&quot;</span><span class="s2">, </span><span class="s5">1</span><span class="s2">)] * </span><span class="s1">data</span><span class="s2">.</span><span class="s1">CHUNKS</span>
    <span class="s1">expected </span><span class="s2">= {</span>
        <span class="s1">f0</span><span class="s2">: {</span>
            <span class="s3">&quot;calls&quot;</span><span class="s2">: [],</span>
            <span class="s3">&quot;token&quot;</span><span class="s2">: </span><span class="s3">&quot;f0&quot;</span><span class="s2">,</span>
            <span class="s2">},</span>
        <span class="s1">f1</span><span class="s2">: {</span>
            <span class="s3">&quot;calls&quot;</span><span class="s2">: </span><span class="s1">mem_chunks0 </span><span class="s2">+ [(</span><span class="s3">&quot;memorize_finish&quot;</span><span class="s2">, </span><span class="s5">0</span><span class="s2">)],</span>
            <span class="s3">&quot;token&quot;</span><span class="s2">: </span><span class="s3">&quot;f1&quot;</span><span class="s2">,</span>
            <span class="s2">},</span>
        <span class="s1">f2a</span><span class="s2">: {</span>
            <span class="s3">&quot;calls&quot;</span><span class="s2">: </span><span class="s1">mem_chunks0 </span><span class="s2">+ [(</span><span class="s3">&quot;memorize_finish&quot;</span><span class="s2">, </span><span class="s5">0</span><span class="s2">)]</span>
                     <span class="s2">+ </span><span class="s1">mem_chunks1 </span><span class="s2">+ [(</span><span class="s3">&quot;memorize_finish&quot;</span><span class="s2">, </span><span class="s5">1</span><span class="s2">)],</span>
            <span class="s3">&quot;token&quot;</span><span class="s2">: </span><span class="s3">&quot;f2a&quot;</span><span class="s2">,</span>
            <span class="s2">},</span>
        <span class="s1">f2b</span><span class="s2">: {</span>
            <span class="s3">&quot;calls&quot;</span><span class="s2">: </span><span class="s1">mem_chunks0 </span><span class="s2">+ [(</span><span class="s3">&quot;memorize_finish&quot;</span><span class="s2">, </span><span class="s5">0</span><span class="s2">)]</span>
                     <span class="s2">+ </span><span class="s1">mem_chunks1 </span><span class="s2">+ [(</span><span class="s3">&quot;memorize_finish&quot;</span><span class="s2">, </span><span class="s5">1</span><span class="s2">)],</span>
            <span class="s3">&quot;token&quot;</span><span class="s2">: </span><span class="s3">&quot;f2b&quot;</span><span class="s2">,</span>
            <span class="s2">},</span>
        <span class="s2">}</span>
    <span class="s4">assert </span><span class="s1">factor_states </span><span class="s2">== </span><span class="s1">expected</span>

<span class="s4">def </span><span class="s1">_examine_factor_types</span><span class="s2">(</span><span class="s1">factors</span><span class="s2">, </span><span class="s1">factor_states</span><span class="s2">, </span><span class="s1">data_iter_maker</span><span class="s2">, </span><span class="s1">NA_action</span><span class="s2">):</span>
    <span class="s1">num_column_counts </span><span class="s2">= {}</span>
    <span class="s1">cat_sniffers </span><span class="s2">= {}</span>
    <span class="s1">examine_needed </span><span class="s2">= </span><span class="s1">set</span><span class="s2">(</span><span class="s1">factors</span><span class="s2">)</span>
    <span class="s4">for </span><span class="s1">data </span><span class="s4">in </span><span class="s1">data_iter_maker</span><span class="s2">():</span>
        <span class="s4">for </span><span class="s1">factor </span><span class="s4">in </span><span class="s1">list</span><span class="s2">(</span><span class="s1">examine_needed</span><span class="s2">):</span>
            <span class="s1">value </span><span class="s2">= </span><span class="s1">factor</span><span class="s2">.</span><span class="s1">eval</span><span class="s2">(</span><span class="s1">factor_states</span><span class="s2">[</span><span class="s1">factor</span><span class="s2">], </span><span class="s1">data</span><span class="s2">)</span>
            <span class="s4">if </span><span class="s1">factor </span><span class="s4">in </span><span class="s1">cat_sniffers </span><span class="s4">or </span><span class="s1">guess_categorical</span><span class="s2">(</span><span class="s1">value</span><span class="s2">):</span>
                <span class="s4">if </span><span class="s1">factor </span><span class="s4">not in </span><span class="s1">cat_sniffers</span><span class="s2">:</span>
                    <span class="s1">cat_sniffers</span><span class="s2">[</span><span class="s1">factor</span><span class="s2">] = </span><span class="s1">CategoricalSniffer</span><span class="s2">(</span><span class="s1">NA_action</span><span class="s2">,</span>
                                                              <span class="s1">factor</span><span class="s2">.</span><span class="s1">origin</span><span class="s2">)</span>
                <span class="s1">done </span><span class="s2">= </span><span class="s1">cat_sniffers</span><span class="s2">[</span><span class="s1">factor</span><span class="s2">].</span><span class="s1">sniff</span><span class="s2">(</span><span class="s1">value</span><span class="s2">)</span>
                <span class="s4">if </span><span class="s1">done</span><span class="s2">:</span>
                    <span class="s1">examine_needed</span><span class="s2">.</span><span class="s1">remove</span><span class="s2">(</span><span class="s1">factor</span><span class="s2">)</span>
            <span class="s4">else</span><span class="s2">:</span>
                <span class="s0"># Numeric</span>
                <span class="s1">value </span><span class="s2">= </span><span class="s1">atleast_2d_column_default</span><span class="s2">(</span><span class="s1">value</span><span class="s2">)</span>
                <span class="s1">_max_allowed_dim</span><span class="s2">(</span><span class="s5">2</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">factor</span><span class="s2">)</span>
                <span class="s1">column_count </span><span class="s2">= </span><span class="s1">value</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">1</span><span class="s2">]</span>
                <span class="s1">num_column_counts</span><span class="s2">[</span><span class="s1">factor</span><span class="s2">] = </span><span class="s1">column_count</span>
                <span class="s1">examine_needed</span><span class="s2">.</span><span class="s1">remove</span><span class="s2">(</span><span class="s1">factor</span><span class="s2">)</span>
        <span class="s4">if not </span><span class="s1">examine_needed</span><span class="s2">:</span>
            <span class="s4">break</span>
    <span class="s0"># Pull out the levels</span>
    <span class="s1">cat_levels_contrasts </span><span class="s2">= {}</span>
    <span class="s4">for </span><span class="s1">factor</span><span class="s2">, </span><span class="s1">sniffer </span><span class="s4">in </span><span class="s1">six</span><span class="s2">.</span><span class="s1">iteritems</span><span class="s2">(</span><span class="s1">cat_sniffers</span><span class="s2">):</span>
        <span class="s1">cat_levels_contrasts</span><span class="s2">[</span><span class="s1">factor</span><span class="s2">] = </span><span class="s1">sniffer</span><span class="s2">.</span><span class="s1">levels_contrast</span><span class="s2">()</span>
    <span class="s4">return </span><span class="s2">(</span><span class="s1">num_column_counts</span><span class="s2">, </span><span class="s1">cat_levels_contrasts</span><span class="s2">)</span>

<span class="s4">def </span><span class="s1">test__examine_factor_types</span><span class="s2">():</span>
    <span class="s4">from </span><span class="s1">patsy</span><span class="s2">.</span><span class="s1">categorical </span><span class="s4">import </span><span class="s1">C</span>
    <span class="s4">class </span><span class="s1">MockFactor</span><span class="s2">(</span><span class="s1">object</span><span class="s2">):</span>
        <span class="s4">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
            <span class="s0"># You should check this using 'is', not '=='</span>
            <span class="s4">from </span><span class="s1">patsy</span><span class="s2">.</span><span class="s1">origin </span><span class="s4">import </span><span class="s1">Origin</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">origin </span><span class="s2">= </span><span class="s1">Origin</span><span class="s2">(</span><span class="s3">&quot;MOCK&quot;</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">)</span>

        <span class="s4">def </span><span class="s1">eval</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">state</span><span class="s2">, </span><span class="s1">data</span><span class="s2">):</span>
            <span class="s4">return </span><span class="s1">state</span><span class="s2">[</span><span class="s1">data</span><span class="s2">]</span>

        <span class="s4">def </span><span class="s1">name</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
            <span class="s4">return </span><span class="s3">&quot;MOCK MOCK&quot;</span>

    <span class="s0"># This hacky class can only be iterated over once, but it keeps track of</span>
    <span class="s0"># how far it got.</span>
    <span class="s4">class </span><span class="s1">DataIterMaker</span><span class="s2">(</span><span class="s1">object</span><span class="s2">):</span>
        <span class="s4">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">i </span><span class="s2">= -</span><span class="s5">1</span>

        <span class="s4">def </span><span class="s1">__call__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
            <span class="s4">return </span><span class="s1">self</span>

        <span class="s4">def </span><span class="s1">__iter__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
            <span class="s4">return </span><span class="s1">self</span>

        <span class="s4">def </span><span class="s1">next</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">i </span><span class="s2">+= </span><span class="s5">1</span>
            <span class="s4">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">i </span><span class="s2">&gt; </span><span class="s5">1</span><span class="s2">:</span>
                <span class="s4">raise </span><span class="s1">StopIteration</span>
            <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">i</span>
        <span class="s1">__next__ </span><span class="s2">= </span><span class="s1">next</span>

    <span class="s1">num_1dim </span><span class="s2">= </span><span class="s1">MockFactor</span><span class="s2">()</span>
    <span class="s1">num_1col </span><span class="s2">= </span><span class="s1">MockFactor</span><span class="s2">()</span>
    <span class="s1">num_4col </span><span class="s2">= </span><span class="s1">MockFactor</span><span class="s2">()</span>
    <span class="s1">categ_1col </span><span class="s2">= </span><span class="s1">MockFactor</span><span class="s2">()</span>
    <span class="s1">bool_1col </span><span class="s2">= </span><span class="s1">MockFactor</span><span class="s2">()</span>
    <span class="s1">string_1col </span><span class="s2">= </span><span class="s1">MockFactor</span><span class="s2">()</span>
    <span class="s1">object_1col </span><span class="s2">= </span><span class="s1">MockFactor</span><span class="s2">()</span>
    <span class="s1">object_levels </span><span class="s2">= (</span><span class="s1">object</span><span class="s2">(), </span><span class="s1">object</span><span class="s2">(), </span><span class="s1">object</span><span class="s2">())</span>
    <span class="s1">factor_states </span><span class="s2">= {</span>
        <span class="s1">num_1dim</span><span class="s2">: ([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s2">], [</span><span class="s5">4</span><span class="s2">, </span><span class="s5">5</span><span class="s2">, </span><span class="s5">6</span><span class="s2">]),</span>
        <span class="s1">num_1col</span><span class="s2">: ([[</span><span class="s5">1</span><span class="s2">], [</span><span class="s5">2</span><span class="s2">], [</span><span class="s5">3</span><span class="s2">]], [[</span><span class="s5">4</span><span class="s2">], [</span><span class="s5">5</span><span class="s2">], [</span><span class="s5">6</span><span class="s2">]]),</span>
        <span class="s1">num_4col</span><span class="s2">: (</span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">((</span><span class="s5">3</span><span class="s2">, </span><span class="s5">4</span><span class="s2">)), </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">((</span><span class="s5">3</span><span class="s2">, </span><span class="s5">4</span><span class="s2">))),</span>
        <span class="s1">categ_1col</span><span class="s2">: (</span><span class="s1">C</span><span class="s2">([</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s2">], </span><span class="s1">levels</span><span class="s2">=(</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s2">),</span>
                       <span class="s1">contrast</span><span class="s2">=</span><span class="s3">&quot;MOCK CONTRAST&quot;</span><span class="s2">),</span>
                     <span class="s1">C</span><span class="s2">([</span><span class="s3">&quot;c&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;a&quot;</span><span class="s2">], </span><span class="s1">levels</span><span class="s2">=(</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s2">),</span>
                       <span class="s1">contrast</span><span class="s2">=</span><span class="s3">&quot;MOCK CONTRAST&quot;</span><span class="s2">)),</span>
        <span class="s1">bool_1col</span><span class="s2">: ([</span><span class="s4">True</span><span class="s2">, </span><span class="s4">True</span><span class="s2">, </span><span class="s4">False</span><span class="s2">], [</span><span class="s4">False</span><span class="s2">, </span><span class="s4">True</span><span class="s2">, </span><span class="s4">True</span><span class="s2">]),</span>
        <span class="s0"># It has to read through all the data to see all the possible levels:</span>
        <span class="s1">string_1col</span><span class="s2">: ([</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;a&quot;</span><span class="s2">], [</span><span class="s3">&quot;c&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;a&quot;</span><span class="s2">]),</span>
        <span class="s1">object_1col</span><span class="s2">: ([</span><span class="s1">object_levels</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]] * </span><span class="s5">3</span><span class="s2">, </span><span class="s1">object_levels</span><span class="s2">),</span>
        <span class="s2">}</span>

    <span class="s1">it </span><span class="s2">= </span><span class="s1">DataIterMaker</span><span class="s2">()</span>
    <span class="s2">(</span><span class="s1">num_column_counts</span><span class="s2">, </span><span class="s1">cat_levels_contrasts</span><span class="s2">,</span>
     <span class="s2">) = </span><span class="s1">_examine_factor_types</span><span class="s2">(</span><span class="s1">factor_states</span><span class="s2">.</span><span class="s1">keys</span><span class="s2">(), </span><span class="s1">factor_states</span><span class="s2">, </span><span class="s1">it</span><span class="s2">,</span>
                               <span class="s1">NAAction</span><span class="s2">())</span>
    <span class="s4">assert </span><span class="s1">it</span><span class="s2">.</span><span class="s1">i </span><span class="s2">== </span><span class="s5">2</span>
    <span class="s1">iterations </span><span class="s2">= </span><span class="s5">0</span>
    <span class="s4">assert </span><span class="s1">num_column_counts </span><span class="s2">== {</span><span class="s1">num_1dim</span><span class="s2">: </span><span class="s5">1</span><span class="s2">, </span><span class="s1">num_1col</span><span class="s2">: </span><span class="s5">1</span><span class="s2">, </span><span class="s1">num_4col</span><span class="s2">: </span><span class="s5">4</span><span class="s2">}</span>
    <span class="s4">assert </span><span class="s1">cat_levels_contrasts </span><span class="s2">== {</span>
        <span class="s1">categ_1col</span><span class="s2">: ((</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s2">), </span><span class="s3">&quot;MOCK CONTRAST&quot;</span><span class="s2">),</span>
        <span class="s1">bool_1col</span><span class="s2">: ((</span><span class="s4">False</span><span class="s2">, </span><span class="s4">True</span><span class="s2">), </span><span class="s4">None</span><span class="s2">),</span>
        <span class="s1">string_1col</span><span class="s2">: ((</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s2">), </span><span class="s4">None</span><span class="s2">),</span>
        <span class="s1">object_1col</span><span class="s2">: (</span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">sorted</span><span class="s2">(</span><span class="s1">object_levels</span><span class="s2">, </span><span class="s1">key</span><span class="s2">=</span><span class="s1">id</span><span class="s2">)), </span><span class="s4">None</span><span class="s2">),</span>
        <span class="s2">}</span>

    <span class="s0"># Check that it doesn't read through all the data if that's not necessary:</span>
    <span class="s1">it </span><span class="s2">= </span><span class="s1">DataIterMaker</span><span class="s2">()</span>
    <span class="s1">no_read_necessary </span><span class="s2">= [</span><span class="s1">num_1dim</span><span class="s2">, </span><span class="s1">num_1col</span><span class="s2">, </span><span class="s1">num_4col</span><span class="s2">, </span><span class="s1">categ_1col</span><span class="s2">, </span><span class="s1">bool_1col</span><span class="s2">]</span>
    <span class="s2">(</span><span class="s1">num_column_counts</span><span class="s2">, </span><span class="s1">cat_levels_contrasts</span><span class="s2">,</span>
     <span class="s2">) = </span><span class="s1">_examine_factor_types</span><span class="s2">(</span><span class="s1">no_read_necessary</span><span class="s2">, </span><span class="s1">factor_states</span><span class="s2">, </span><span class="s1">it</span><span class="s2">,</span>
                               <span class="s1">NAAction</span><span class="s2">())</span>
    <span class="s4">assert </span><span class="s1">it</span><span class="s2">.</span><span class="s1">i </span><span class="s2">== </span><span class="s5">0</span>
    <span class="s4">assert </span><span class="s1">num_column_counts </span><span class="s2">== {</span><span class="s1">num_1dim</span><span class="s2">: </span><span class="s5">1</span><span class="s2">, </span><span class="s1">num_1col</span><span class="s2">: </span><span class="s5">1</span><span class="s2">, </span><span class="s1">num_4col</span><span class="s2">: </span><span class="s5">4</span><span class="s2">}</span>
    <span class="s4">assert </span><span class="s1">cat_levels_contrasts </span><span class="s2">== {</span>
        <span class="s1">categ_1col</span><span class="s2">: ((</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s2">), </span><span class="s3">&quot;MOCK CONTRAST&quot;</span><span class="s2">),</span>
        <span class="s1">bool_1col</span><span class="s2">: ((</span><span class="s4">False</span><span class="s2">, </span><span class="s4">True</span><span class="s2">), </span><span class="s4">None</span><span class="s2">),</span>
        <span class="s2">}</span>

    <span class="s0"># Illegal inputs:</span>
    <span class="s1">bool_3col </span><span class="s2">= </span><span class="s1">MockFactor</span><span class="s2">()</span>
    <span class="s1">num_3dim </span><span class="s2">= </span><span class="s1">MockFactor</span><span class="s2">()</span>
    <span class="s0"># no such thing as a multi-dimensional Categorical</span>
    <span class="s0"># categ_3dim = MockFactor()</span>
    <span class="s1">string_3col </span><span class="s2">= </span><span class="s1">MockFactor</span><span class="s2">()</span>
    <span class="s1">object_3col </span><span class="s2">= </span><span class="s1">MockFactor</span><span class="s2">()</span>
    <span class="s1">illegal_factor_states </span><span class="s2">= {</span>
        <span class="s1">num_3dim</span><span class="s2">: (</span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">((</span><span class="s5">3</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s5">3</span><span class="s2">)), </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">((</span><span class="s5">3</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s5">3</span><span class="s2">))),</span>
        <span class="s1">string_3col</span><span class="s2">: ([[</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s2">]], [[</span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s2">, </span><span class="s3">&quot;a&quot;</span><span class="s2">]]),</span>
        <span class="s1">object_3col</span><span class="s2">: ([[[</span><span class="s1">object</span><span class="s2">()]]], [[[</span><span class="s1">object</span><span class="s2">()]]]),</span>
        <span class="s2">}</span>
    <span class="s4">import </span><span class="s1">pytest</span>
    <span class="s4">for </span><span class="s1">illegal_factor </span><span class="s4">in </span><span class="s1">illegal_factor_states</span><span class="s2">:</span>
        <span class="s1">it </span><span class="s2">= </span><span class="s1">DataIterMaker</span><span class="s2">()</span>
        <span class="s4">try</span><span class="s2">:</span>
            <span class="s1">_examine_factor_types</span><span class="s2">([</span><span class="s1">illegal_factor</span><span class="s2">], </span><span class="s1">illegal_factor_states</span><span class="s2">, </span><span class="s1">it</span><span class="s2">,</span>
                                  <span class="s1">NAAction</span><span class="s2">())</span>
        <span class="s4">except </span><span class="s1">PatsyError </span><span class="s4">as </span><span class="s1">e</span><span class="s2">:</span>
            <span class="s4">assert </span><span class="s1">e</span><span class="s2">.</span><span class="s1">origin </span><span class="s4">is </span><span class="s1">illegal_factor</span><span class="s2">.</span><span class="s1">origin</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s4">assert False</span>

<span class="s4">def </span><span class="s1">_make_subterm_infos</span><span class="s2">(</span><span class="s1">terms</span><span class="s2">,</span>
                        <span class="s1">num_column_counts</span><span class="s2">,</span>
                        <span class="s1">cat_levels_contrasts</span><span class="s2">):</span>
    <span class="s0"># Sort each term into a bucket based on the set of numeric factors it</span>
    <span class="s0"># contains:</span>
    <span class="s1">term_buckets </span><span class="s2">= </span><span class="s1">OrderedDict</span><span class="s2">()</span>
    <span class="s1">bucket_ordering </span><span class="s2">= []</span>
    <span class="s4">for </span><span class="s1">term </span><span class="s4">in </span><span class="s1">terms</span><span class="s2">:</span>
        <span class="s1">num_factors </span><span class="s2">= []</span>
        <span class="s4">for </span><span class="s1">factor </span><span class="s4">in </span><span class="s1">term</span><span class="s2">.</span><span class="s1">factors</span><span class="s2">:</span>
            <span class="s4">if </span><span class="s1">factor </span><span class="s4">in </span><span class="s1">num_column_counts</span><span class="s2">:</span>
                <span class="s1">num_factors</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">factor</span><span class="s2">)</span>
        <span class="s1">bucket </span><span class="s2">= </span><span class="s1">frozenset</span><span class="s2">(</span><span class="s1">num_factors</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">bucket </span><span class="s4">not in </span><span class="s1">term_buckets</span><span class="s2">:</span>
            <span class="s1">bucket_ordering</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">bucket</span><span class="s2">)</span>
        <span class="s1">term_buckets</span><span class="s2">.</span><span class="s1">setdefault</span><span class="s2">(</span><span class="s1">bucket</span><span class="s2">, []).</span><span class="s1">append</span><span class="s2">(</span><span class="s1">term</span><span class="s2">)</span>
    <span class="s0"># Special rule: if there is a no-numerics bucket, then it always comes</span>
    <span class="s0"># first:</span>
    <span class="s4">if </span><span class="s1">frozenset</span><span class="s2">() </span><span class="s4">in </span><span class="s1">term_buckets</span><span class="s2">:</span>
        <span class="s1">bucket_ordering</span><span class="s2">.</span><span class="s1">remove</span><span class="s2">(</span><span class="s1">frozenset</span><span class="s2">())</span>
        <span class="s1">bucket_ordering</span><span class="s2">.</span><span class="s1">insert</span><span class="s2">(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">frozenset</span><span class="s2">())</span>
    <span class="s1">term_to_subterm_infos </span><span class="s2">= </span><span class="s1">OrderedDict</span><span class="s2">()</span>
    <span class="s1">new_term_order </span><span class="s2">= []</span>
    <span class="s0"># Then within each bucket, work out which sort of contrasts we want to use</span>
    <span class="s0"># for each term to avoid redundancy</span>
    <span class="s4">for </span><span class="s1">bucket </span><span class="s4">in </span><span class="s1">bucket_ordering</span><span class="s2">:</span>
        <span class="s1">bucket_terms </span><span class="s2">= </span><span class="s1">term_buckets</span><span class="s2">[</span><span class="s1">bucket</span><span class="s2">]</span>
        <span class="s0"># Sort by degree of interaction</span>
        <span class="s1">bucket_terms</span><span class="s2">.</span><span class="s1">sort</span><span class="s2">(</span><span class="s1">key</span><span class="s2">=</span><span class="s4">lambda </span><span class="s1">t</span><span class="s2">: </span><span class="s1">len</span><span class="s2">(</span><span class="s1">t</span><span class="s2">.</span><span class="s1">factors</span><span class="s2">))</span>
        <span class="s1">new_term_order </span><span class="s2">+= </span><span class="s1">bucket_terms</span>
        <span class="s1">used_subterms </span><span class="s2">= </span><span class="s1">set</span><span class="s2">()</span>
        <span class="s4">for </span><span class="s1">term </span><span class="s4">in </span><span class="s1">bucket_terms</span><span class="s2">:</span>
            <span class="s1">subterm_infos </span><span class="s2">= []</span>
            <span class="s1">factor_codings </span><span class="s2">= </span><span class="s1">pick_contrasts_for_term</span><span class="s2">(</span><span class="s1">term</span><span class="s2">,</span>
                                                     <span class="s1">num_column_counts</span><span class="s2">,</span>
                                                     <span class="s1">used_subterms</span><span class="s2">)</span>
            <span class="s0"># Construct one SubtermInfo for each subterm</span>
            <span class="s4">for </span><span class="s1">factor_coding </span><span class="s4">in </span><span class="s1">factor_codings</span><span class="s2">:</span>
                <span class="s1">subterm_factors </span><span class="s2">= []</span>
                <span class="s1">contrast_matrices </span><span class="s2">= {}</span>
                <span class="s1">subterm_columns </span><span class="s2">= </span><span class="s5">1</span>
                <span class="s0"># In order to preserve factor ordering information, the</span>
                <span class="s0"># coding_for_term just returns dicts, and we refer to</span>
                <span class="s0"># the original factors to figure out which are included in</span>
                <span class="s0"># each subterm, and in what order</span>
                <span class="s4">for </span><span class="s1">factor </span><span class="s4">in </span><span class="s1">term</span><span class="s2">.</span><span class="s1">factors</span><span class="s2">:</span>
                    <span class="s0"># Numeric factors are included in every subterm</span>
                    <span class="s4">if </span><span class="s1">factor </span><span class="s4">in </span><span class="s1">num_column_counts</span><span class="s2">:</span>
                        <span class="s1">subterm_factors</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">factor</span><span class="s2">)</span>
                        <span class="s1">subterm_columns </span><span class="s2">*= </span><span class="s1">num_column_counts</span><span class="s2">[</span><span class="s1">factor</span><span class="s2">]</span>
                    <span class="s4">elif </span><span class="s1">factor </span><span class="s4">in </span><span class="s1">factor_coding</span><span class="s2">:</span>
                        <span class="s1">subterm_factors</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">factor</span><span class="s2">)</span>
                        <span class="s1">levels</span><span class="s2">, </span><span class="s1">contrast </span><span class="s2">= </span><span class="s1">cat_levels_contrasts</span><span class="s2">[</span><span class="s1">factor</span><span class="s2">]</span>
                        <span class="s0"># This is where the default coding is set to</span>
                        <span class="s0"># Treatment:</span>
                        <span class="s1">coded </span><span class="s2">= </span><span class="s1">code_contrast_matrix</span><span class="s2">(</span><span class="s1">factor_coding</span><span class="s2">[</span><span class="s1">factor</span><span class="s2">],</span>
                                                     <span class="s1">levels</span><span class="s2">, </span><span class="s1">contrast</span><span class="s2">,</span>
                                                     <span class="s1">default</span><span class="s2">=</span><span class="s1">Treatment</span><span class="s2">)</span>
                        <span class="s1">contrast_matrices</span><span class="s2">[</span><span class="s1">factor</span><span class="s2">] = </span><span class="s1">coded</span>
                        <span class="s1">subterm_columns </span><span class="s2">*= </span><span class="s1">coded</span><span class="s2">.</span><span class="s1">matrix</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">1</span><span class="s2">]</span>
                <span class="s1">subterm_infos</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">SubtermInfo</span><span class="s2">(</span><span class="s1">subterm_factors</span><span class="s2">,</span>
                                                       <span class="s1">contrast_matrices</span><span class="s2">,</span>
                                                       <span class="s1">subterm_columns</span><span class="s2">))</span>
            <span class="s1">term_to_subterm_infos</span><span class="s2">[</span><span class="s1">term</span><span class="s2">] = </span><span class="s1">subterm_infos</span>
    <span class="s4">assert </span><span class="s1">new_term_order </span><span class="s2">== </span><span class="s1">list</span><span class="s2">(</span><span class="s1">term_to_subterm_infos</span><span class="s2">)</span>
    <span class="s4">return </span><span class="s1">term_to_subterm_infos</span>

<span class="s4">def </span><span class="s1">design_matrix_builders</span><span class="s2">(</span><span class="s1">termlists</span><span class="s2">, </span><span class="s1">data_iter_maker</span><span class="s2">, </span><span class="s1">eval_env</span><span class="s2">,</span>
                           <span class="s1">NA_action</span><span class="s2">=</span><span class="s3">&quot;drop&quot;</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot;Construct several :class:`DesignInfo` objects from termlists. 
 
    This is one of Patsy's fundamental functions. This function and 
    :func:`build_design_matrices` together form the API to the core formula 
    interpretation machinery. 
 
    :arg termlists: A list of termlists, where each termlist is a list of 
      :class:`Term` objects which together specify a design matrix. 
    :arg data_iter_maker: A zero-argument callable which returns an iterator 
      over dict-like data objects. This must be a callable rather than a 
      simple iterator because sufficiently complex formulas may require 
      multiple passes over the data (e.g. if there are nested stateful 
      transforms). 
    :arg eval_env: Either a :class:`EvalEnvironment` which will be used to 
      look up any variables referenced in `termlists` that cannot be 
      found in `data_iter_maker`, or else a depth represented as an 
      integer which will be passed to :meth:`EvalEnvironment.capture`. 
      ``eval_env=0`` means to use the context of the function calling 
      :func:`design_matrix_builders` for lookups. If calling this function 
      from a library, you probably want ``eval_env=1``, which means that 
      variables should be resolved in *your* caller's namespace. 
    :arg NA_action: An :class:`NAAction` object or string, used to determine 
      what values count as 'missing' for purposes of determining the levels of 
      categorical factors. 
    :returns: A list of :class:`DesignInfo` objects, one for each 
      termlist passed in. 
 
    This function performs zero or more iterations over the data in order to 
    sniff out any necessary information about factor types, set up stateful 
    transforms, pick column names, etc. 
 
    See :ref:`formulas` for details. 
 
    .. versionadded:: 0.2.0 
       The ``NA_action`` argument. 
    .. versionadded:: 0.4.0 
       The ``eval_env`` argument. 
    &quot;&quot;&quot;</span>
    <span class="s0"># People upgrading from versions prior to 0.4.0 could potentially have</span>
    <span class="s0"># passed NA_action as the 3rd positional argument. Fortunately</span>
    <span class="s0"># EvalEnvironment.capture only accepts int and EvalEnvironment objects,</span>
    <span class="s0"># and we improved its error messages to make this clear.</span>
    <span class="s1">eval_env </span><span class="s2">= </span><span class="s1">EvalEnvironment</span><span class="s2">.</span><span class="s1">capture</span><span class="s2">(</span><span class="s1">eval_env</span><span class="s2">, </span><span class="s1">reference</span><span class="s2">=</span><span class="s5">1</span><span class="s2">)</span>
    <span class="s4">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">NA_action</span><span class="s2">, </span><span class="s1">str</span><span class="s2">):</span>
        <span class="s1">NA_action </span><span class="s2">= </span><span class="s1">NAAction</span><span class="s2">(</span><span class="s1">NA_action</span><span class="s2">)</span>
    <span class="s1">all_factors </span><span class="s2">= </span><span class="s1">set</span><span class="s2">()</span>
    <span class="s4">for </span><span class="s1">termlist </span><span class="s4">in </span><span class="s1">termlists</span><span class="s2">:</span>
        <span class="s4">for </span><span class="s1">term </span><span class="s4">in </span><span class="s1">termlist</span><span class="s2">:</span>
            <span class="s1">all_factors</span><span class="s2">.</span><span class="s1">update</span><span class="s2">(</span><span class="s1">term</span><span class="s2">.</span><span class="s1">factors</span><span class="s2">)</span>
    <span class="s1">factor_states </span><span class="s2">= </span><span class="s1">_factors_memorize</span><span class="s2">(</span><span class="s1">all_factors</span><span class="s2">, </span><span class="s1">data_iter_maker</span><span class="s2">, </span><span class="s1">eval_env</span><span class="s2">)</span>
    <span class="s0"># Now all the factors have working eval methods, so we can evaluate them</span>
    <span class="s0"># on some data to find out what type of data they return.</span>
    <span class="s2">(</span><span class="s1">num_column_counts</span><span class="s2">,</span>
     <span class="s1">cat_levels_contrasts</span><span class="s2">) = </span><span class="s1">_examine_factor_types</span><span class="s2">(</span><span class="s1">all_factors</span><span class="s2">,</span>
                                                   <span class="s1">factor_states</span><span class="s2">,</span>
                                                   <span class="s1">data_iter_maker</span><span class="s2">,</span>
                                                   <span class="s1">NA_action</span><span class="s2">)</span>
    <span class="s0"># Now we need the factor infos, which encapsulate the knowledge of</span>
    <span class="s0"># how to turn any given factor into a chunk of data:</span>
    <span class="s1">factor_infos </span><span class="s2">= {}</span>
    <span class="s4">for </span><span class="s1">factor </span><span class="s4">in </span><span class="s1">all_factors</span><span class="s2">:</span>
        <span class="s4">if </span><span class="s1">factor </span><span class="s4">in </span><span class="s1">num_column_counts</span><span class="s2">:</span>
            <span class="s1">fi </span><span class="s2">= </span><span class="s1">FactorInfo</span><span class="s2">(</span><span class="s1">factor</span><span class="s2">,</span>
                            <span class="s3">&quot;numerical&quot;</span><span class="s2">,</span>
                            <span class="s1">factor_states</span><span class="s2">[</span><span class="s1">factor</span><span class="s2">],</span>
                            <span class="s1">num_columns</span><span class="s2">=</span><span class="s1">num_column_counts</span><span class="s2">[</span><span class="s1">factor</span><span class="s2">],</span>
                            <span class="s1">categories</span><span class="s2">=</span><span class="s4">None</span><span class="s2">)</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s4">assert </span><span class="s1">factor </span><span class="s4">in </span><span class="s1">cat_levels_contrasts</span>
            <span class="s1">categories </span><span class="s2">= </span><span class="s1">cat_levels_contrasts</span><span class="s2">[</span><span class="s1">factor</span><span class="s2">][</span><span class="s5">0</span><span class="s2">]</span>
            <span class="s1">fi </span><span class="s2">= </span><span class="s1">FactorInfo</span><span class="s2">(</span><span class="s1">factor</span><span class="s2">,</span>
                            <span class="s3">&quot;categorical&quot;</span><span class="s2">,</span>
                            <span class="s1">factor_states</span><span class="s2">[</span><span class="s1">factor</span><span class="s2">],</span>
                            <span class="s1">num_columns</span><span class="s2">=</span><span class="s4">None</span><span class="s2">,</span>
                            <span class="s1">categories</span><span class="s2">=</span><span class="s1">categories</span><span class="s2">)</span>
        <span class="s1">factor_infos</span><span class="s2">[</span><span class="s1">factor</span><span class="s2">] = </span><span class="s1">fi</span>
    <span class="s0"># And now we can construct the DesignInfo for each termlist:</span>
    <span class="s1">design_infos </span><span class="s2">= []</span>
    <span class="s4">for </span><span class="s1">termlist </span><span class="s4">in </span><span class="s1">termlists</span><span class="s2">:</span>
        <span class="s1">term_to_subterm_infos </span><span class="s2">= </span><span class="s1">_make_subterm_infos</span><span class="s2">(</span><span class="s1">termlist</span><span class="s2">,</span>
                                                    <span class="s1">num_column_counts</span><span class="s2">,</span>
                                                    <span class="s1">cat_levels_contrasts</span><span class="s2">)</span>
        <span class="s4">assert </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">term_to_subterm_infos</span><span class="s2">, </span><span class="s1">OrderedDict</span><span class="s2">)</span>
        <span class="s4">assert </span><span class="s1">frozenset</span><span class="s2">(</span><span class="s1">term_to_subterm_infos</span><span class="s2">) == </span><span class="s1">frozenset</span><span class="s2">(</span><span class="s1">termlist</span><span class="s2">)</span>
        <span class="s1">this_design_factor_infos </span><span class="s2">= {}</span>
        <span class="s4">for </span><span class="s1">term </span><span class="s4">in </span><span class="s1">termlist</span><span class="s2">:</span>
            <span class="s4">for </span><span class="s1">factor </span><span class="s4">in </span><span class="s1">term</span><span class="s2">.</span><span class="s1">factors</span><span class="s2">:</span>
                <span class="s1">this_design_factor_infos</span><span class="s2">[</span><span class="s1">factor</span><span class="s2">] = </span><span class="s1">factor_infos</span><span class="s2">[</span><span class="s1">factor</span><span class="s2">]</span>
        <span class="s1">column_names </span><span class="s2">= []</span>
        <span class="s4">for </span><span class="s1">subterms </span><span class="s4">in </span><span class="s1">six</span><span class="s2">.</span><span class="s1">itervalues</span><span class="s2">(</span><span class="s1">term_to_subterm_infos</span><span class="s2">):</span>
            <span class="s4">for </span><span class="s1">subterm </span><span class="s4">in </span><span class="s1">subterms</span><span class="s2">:</span>
                <span class="s4">for </span><span class="s1">column_name </span><span class="s4">in </span><span class="s1">_subterm_column_names_iter</span><span class="s2">(</span>
                        <span class="s1">factor_infos</span><span class="s2">, </span><span class="s1">subterm</span><span class="s2">):</span>
                    <span class="s1">column_names</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">column_name</span><span class="s2">)</span>
        <span class="s1">design_infos</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">DesignInfo</span><span class="s2">(</span><span class="s1">column_names</span><span class="s2">,</span>
                                       <span class="s1">factor_infos</span><span class="s2">=</span><span class="s1">this_design_factor_infos</span><span class="s2">,</span>
                                       <span class="s1">term_codings</span><span class="s2">=</span><span class="s1">term_to_subterm_infos</span><span class="s2">))</span>
    <span class="s4">return </span><span class="s1">design_infos</span>

<span class="s4">def </span><span class="s1">_build_design_matrix</span><span class="s2">(</span><span class="s1">design_info</span><span class="s2">, </span><span class="s1">factor_info_to_values</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">):</span>
    <span class="s1">factor_to_values </span><span class="s2">= {}</span>
    <span class="s1">need_reshape </span><span class="s2">= </span><span class="s4">False</span>
    <span class="s1">num_rows </span><span class="s2">= </span><span class="s4">None</span>
    <span class="s4">for </span><span class="s1">factor_info</span><span class="s2">, </span><span class="s1">value </span><span class="s4">in </span><span class="s1">six</span><span class="s2">.</span><span class="s1">iteritems</span><span class="s2">(</span><span class="s1">factor_info_to_values</span><span class="s2">):</span>
        <span class="s0"># It's possible that the same factor appears in multiple different</span>
        <span class="s0"># FactorInfo objects (e.g. if someone is simultaneously building two</span>
        <span class="s0"># DesignInfo objects that started out as part of different</span>
        <span class="s0"># formulas). Skip any factor_info that is not our expected</span>
        <span class="s0"># factor_info.</span>
        <span class="s4">if </span><span class="s1">design_info</span><span class="s2">.</span><span class="s1">factor_infos</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">factor_info</span><span class="s2">.</span><span class="s1">factor</span><span class="s2">) </span><span class="s4">is not </span><span class="s1">factor_info</span><span class="s2">:</span>
            <span class="s4">continue</span>
        <span class="s1">factor_to_values</span><span class="s2">[</span><span class="s1">factor_info</span><span class="s2">.</span><span class="s1">factor</span><span class="s2">] = </span><span class="s1">value</span>
        <span class="s4">if </span><span class="s1">num_rows </span><span class="s4">is not None</span><span class="s2">:</span>
            <span class="s4">assert </span><span class="s1">num_rows </span><span class="s2">== </span><span class="s1">value</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">num_rows </span><span class="s2">= </span><span class="s1">value</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]</span>
    <span class="s4">if </span><span class="s1">num_rows </span><span class="s4">is None</span><span class="s2">:</span>
        <span class="s0"># We have no dependence on the data -- e.g. an empty termlist, or</span>
        <span class="s0"># only an intercept term.</span>
        <span class="s1">num_rows </span><span class="s2">= </span><span class="s5">1</span>
        <span class="s1">need_reshape </span><span class="s2">= </span><span class="s4">True</span>
    <span class="s1">shape </span><span class="s2">= (</span><span class="s1">num_rows</span><span class="s2">, </span><span class="s1">len</span><span class="s2">(</span><span class="s1">design_info</span><span class="s2">.</span><span class="s1">column_names</span><span class="s2">))</span>
    <span class="s1">m </span><span class="s2">= </span><span class="s1">DesignMatrix</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">(</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">), </span><span class="s1">design_info</span><span class="s2">)</span>
    <span class="s1">start_column </span><span class="s2">= </span><span class="s5">0</span>
    <span class="s4">for </span><span class="s1">term</span><span class="s2">, </span><span class="s1">subterms </span><span class="s4">in </span><span class="s1">six</span><span class="s2">.</span><span class="s1">iteritems</span><span class="s2">(</span><span class="s1">design_info</span><span class="s2">.</span><span class="s1">term_codings</span><span class="s2">):</span>
        <span class="s4">for </span><span class="s1">subterm </span><span class="s4">in </span><span class="s1">subterms</span><span class="s2">:</span>
            <span class="s1">end_column </span><span class="s2">= </span><span class="s1">start_column </span><span class="s2">+ </span><span class="s1">subterm</span><span class="s2">.</span><span class="s1">num_columns</span>
            <span class="s1">m_slice </span><span class="s2">= </span><span class="s1">m</span><span class="s2">[:, </span><span class="s1">start_column</span><span class="s2">:</span><span class="s1">end_column</span><span class="s2">]</span>
            <span class="s1">_build_subterm</span><span class="s2">(</span><span class="s1">subterm</span><span class="s2">, </span><span class="s1">design_info</span><span class="s2">.</span><span class="s1">factor_infos</span><span class="s2">,</span>
                           <span class="s1">factor_to_values</span><span class="s2">, </span><span class="s1">m_slice</span><span class="s2">)</span>
            <span class="s1">start_column </span><span class="s2">= </span><span class="s1">end_column</span>
    <span class="s4">assert </span><span class="s1">start_column </span><span class="s2">== </span><span class="s1">m</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">1</span><span class="s2">]</span>
    <span class="s4">return </span><span class="s1">need_reshape</span><span class="s2">, </span><span class="s1">m</span>

<span class="s4">class </span><span class="s1">_CheckMatch</span><span class="s2">(</span><span class="s1">object</span><span class="s2">):</span>
    <span class="s4">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">eq_fn</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_name </span><span class="s2">= </span><span class="s1">name</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_eq_fn </span><span class="s2">= </span><span class="s1">eq_fn</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">value </span><span class="s2">= </span><span class="s4">None</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_value_desc </span><span class="s2">= </span><span class="s4">None</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_value_origin </span><span class="s2">= </span><span class="s4">None</span>

    <span class="s4">def </span><span class="s1">check</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">seen_value</span><span class="s2">, </span><span class="s1">desc</span><span class="s2">, </span><span class="s1">origin</span><span class="s2">):</span>
        <span class="s4">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">value </span><span class="s4">is None</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">value </span><span class="s2">= </span><span class="s1">seen_value</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_value_desc </span><span class="s2">= </span><span class="s1">desc</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_value_origin </span><span class="s2">= </span><span class="s1">origin</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s4">if not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_eq_fn</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">value</span><span class="s2">, </span><span class="s1">seen_value</span><span class="s2">):</span>
                <span class="s1">msg </span><span class="s2">= (</span><span class="s3">&quot;%s mismatch between %s and %s&quot;</span>
                       <span class="s2">% (</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_name</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_value_desc</span><span class="s2">, </span><span class="s1">desc</span><span class="s2">))</span>
                <span class="s4">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">value</span><span class="s2">, </span><span class="s1">int</span><span class="s2">):</span>
                    <span class="s1">msg </span><span class="s2">+= </span><span class="s3">&quot; (%r versus %r)&quot; </span><span class="s2">% (</span><span class="s1">self</span><span class="s2">.</span><span class="s1">value</span><span class="s2">, </span><span class="s1">seen_value</span><span class="s2">)</span>
                <span class="s0"># XX FIXME: this is a case where having discontiguous Origins</span>
                <span class="s0"># would be useful...</span>
                <span class="s4">raise </span><span class="s1">PatsyError</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">, </span><span class="s1">origin</span><span class="s2">)</span>

<span class="s4">def </span><span class="s1">build_design_matrices</span><span class="s2">(</span><span class="s1">design_infos</span><span class="s2">, </span><span class="s1">data</span><span class="s2">,</span>
                          <span class="s1">NA_action</span><span class="s2">=</span><span class="s3">&quot;drop&quot;</span><span class="s2">,</span>
                          <span class="s1">return_type</span><span class="s2">=</span><span class="s3">&quot;matrix&quot;</span><span class="s2">,</span>
                          <span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">(</span><span class="s1">float</span><span class="s2">)):</span>
    <span class="s6">&quot;&quot;&quot;Construct several design matrices from :class:`DesignMatrixBuilder` 
    objects. 
 
    This is one of Patsy's fundamental functions. This function and 
    :func:`design_matrix_builders` together form the API to the core formula 
    interpretation machinery. 
 
    :arg design_infos: A list of :class:`DesignInfo` objects describing the 
      design matrices to be built. 
    :arg data: A dict-like object which will be used to look up data. 
    :arg NA_action: What to do with rows that contain missing values. You can 
      ``&quot;drop&quot;`` them, ``&quot;raise&quot;`` an error, or for customization, pass an 
      :class:`NAAction` object. See :class:`NAAction` for details on what 
      values count as 'missing' (and how to alter this). 
    :arg return_type: Either ``&quot;matrix&quot;`` or ``&quot;dataframe&quot;``. See below. 
    :arg dtype: The dtype of the returned matrix. Useful if you want to use 
      single-precision or extended-precision. 
 
    This function returns either a list of :class:`DesignMatrix` objects (for 
    ``return_type=&quot;matrix&quot;``) or a list of :class:`pandas.DataFrame` objects 
    (for ``return_type=&quot;dataframe&quot;``). In both cases, all returned design 
    matrices will have ``.design_info`` attributes containing the appropriate 
    :class:`DesignInfo` objects. 
 
    Note that unlike :func:`design_matrix_builders`, this function takes only 
    a simple data argument, not any kind of iterator. That's because this 
    function doesn't need a global view of the data -- everything that depends 
    on the whole data set is already encapsulated in the ``design_infos``. If 
    you are incrementally processing a large data set, simply call this 
    function for each chunk. 
 
    Index handling: This function always checks for indexes in the following 
    places: 
 
    * If ``data`` is a :class:`pandas.DataFrame`, its ``.index`` attribute. 
    * If any factors evaluate to a :class:`pandas.Series` or 
      :class:`pandas.DataFrame`, then their ``.index`` attributes. 
 
    If multiple indexes are found, they must be identical (same values in the 
    same order). If no indexes are found, then a default index is generated 
    using ``np.arange(num_rows)``. One way or another, we end up with a single 
    index for all the data. If ``return_type=&quot;dataframe&quot;``, then this index is 
    used as the index of the returned DataFrame objects. Examining this index 
    makes it possible to determine which rows were removed due to NAs. 
 
    Determining the number of rows in design matrices: This is not as obvious 
    as it might seem, because it's possible to have a formula like &quot;~ 1&quot; that 
    doesn't depend on the data (it has no factors). For this formula, it's 
    obvious what every row in the design matrix should look like (just the 
    value ``1``); but, how many rows like this should there be? To determine 
    the number of rows in a design matrix, this function always checks in the 
    following places: 
 
    * If ``data`` is a :class:`pandas.DataFrame`, then its number of rows. 
    * The number of entries in any factors present in any of the design 
    * matrices being built. 
 
    All these values much match. In particular, if this function is called to 
    generate multiple design matrices at once, then they must all have the 
    same number of rows. 
 
    .. versionadded:: 0.2.0 
       The ``NA_action`` argument. 
 
    &quot;&quot;&quot;</span>
    <span class="s4">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">NA_action</span><span class="s2">, </span><span class="s1">str</span><span class="s2">):</span>
        <span class="s1">NA_action </span><span class="s2">= </span><span class="s1">NAAction</span><span class="s2">(</span><span class="s1">NA_action</span><span class="s2">)</span>
    <span class="s4">if </span><span class="s1">return_type </span><span class="s2">== </span><span class="s3">&quot;dataframe&quot; </span><span class="s4">and not </span><span class="s1">have_pandas</span><span class="s2">:</span>
        <span class="s4">raise </span><span class="s1">PatsyError</span><span class="s2">(</span><span class="s3">&quot;pandas.DataFrame was requested, but pandas &quot;</span>
                            <span class="s3">&quot;is not installed&quot;</span><span class="s2">)</span>
    <span class="s4">if </span><span class="s1">return_type </span><span class="s4">not in </span><span class="s2">(</span><span class="s3">&quot;matrix&quot;</span><span class="s2">, </span><span class="s3">&quot;dataframe&quot;</span><span class="s2">):</span>
        <span class="s4">raise </span><span class="s1">PatsyError</span><span class="s2">(</span><span class="s3">&quot;unrecognized output type %r, should be &quot;</span>
                            <span class="s3">&quot;'matrix' or 'dataframe'&quot; </span><span class="s2">% (</span><span class="s1">return_type</span><span class="s2">,))</span>
    <span class="s0"># Evaluate factors</span>
    <span class="s1">factor_info_to_values </span><span class="s2">= {}</span>
    <span class="s1">factor_info_to_isNAs </span><span class="s2">= {}</span>
    <span class="s1">rows_checker </span><span class="s2">= </span><span class="s1">_CheckMatch</span><span class="s2">(</span><span class="s3">&quot;Number of rows&quot;</span><span class="s2">, </span><span class="s4">lambda </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">: </span><span class="s1">a </span><span class="s2">== </span><span class="s1">b</span><span class="s2">)</span>
    <span class="s1">index_checker </span><span class="s2">= </span><span class="s1">_CheckMatch</span><span class="s2">(</span><span class="s3">&quot;Index&quot;</span><span class="s2">, </span><span class="s4">lambda </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">: </span><span class="s1">a</span><span class="s2">.</span><span class="s1">equals</span><span class="s2">(</span><span class="s1">b</span><span class="s2">))</span>
    <span class="s4">if </span><span class="s1">have_pandas </span><span class="s4">and </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">data</span><span class="s2">, </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">DataFrame</span><span class="s2">):</span>
        <span class="s1">index_checker</span><span class="s2">.</span><span class="s1">check</span><span class="s2">(</span><span class="s1">data</span><span class="s2">.</span><span class="s1">index</span><span class="s2">, </span><span class="s3">&quot;data.index&quot;</span><span class="s2">, </span><span class="s4">None</span><span class="s2">)</span>
        <span class="s1">rows_checker</span><span class="s2">.</span><span class="s1">check</span><span class="s2">(</span><span class="s1">data</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">0</span><span class="s2">], </span><span class="s3">&quot;data argument&quot;</span><span class="s2">, </span><span class="s4">None</span><span class="s2">)</span>
    <span class="s4">for </span><span class="s1">design_info </span><span class="s4">in </span><span class="s1">design_infos</span><span class="s2">:</span>
        <span class="s0"># We look at evaluators rather than factors here, because it might</span>
        <span class="s0"># happen that we have the same factor twice, but with different</span>
        <span class="s0"># memorized state.</span>
        <span class="s4">for </span><span class="s1">factor_info </span><span class="s4">in </span><span class="s1">six</span><span class="s2">.</span><span class="s1">itervalues</span><span class="s2">(</span><span class="s1">design_info</span><span class="s2">.</span><span class="s1">factor_infos</span><span class="s2">):</span>
            <span class="s4">if </span><span class="s1">factor_info </span><span class="s4">not in </span><span class="s1">factor_info_to_values</span><span class="s2">:</span>
                <span class="s1">value</span><span class="s2">, </span><span class="s1">is_NA </span><span class="s2">= </span><span class="s1">_eval_factor</span><span class="s2">(</span><span class="s1">factor_info</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">NA_action</span><span class="s2">)</span>
                <span class="s1">factor_info_to_isNAs</span><span class="s2">[</span><span class="s1">factor_info</span><span class="s2">] = </span><span class="s1">is_NA</span>
                <span class="s0"># value may now be a Series, DataFrame, or ndarray</span>
                <span class="s1">name </span><span class="s2">= </span><span class="s1">factor_info</span><span class="s2">.</span><span class="s1">factor</span><span class="s2">.</span><span class="s1">name</span><span class="s2">()</span>
                <span class="s1">origin </span><span class="s2">= </span><span class="s1">factor_info</span><span class="s2">.</span><span class="s1">factor</span><span class="s2">.</span><span class="s1">origin</span>
                <span class="s1">rows_checker</span><span class="s2">.</span><span class="s1">check</span><span class="s2">(</span><span class="s1">value</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">0</span><span class="s2">], </span><span class="s1">name</span><span class="s2">, </span><span class="s1">origin</span><span class="s2">)</span>
                <span class="s4">if </span><span class="s2">(</span><span class="s1">have_pandas</span>
                    <span class="s4">and </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">value</span><span class="s2">, (</span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">Series</span><span class="s2">, </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">DataFrame</span><span class="s2">))):</span>
                    <span class="s1">index_checker</span><span class="s2">.</span><span class="s1">check</span><span class="s2">(</span><span class="s1">value</span><span class="s2">.</span><span class="s1">index</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">origin</span><span class="s2">)</span>
                <span class="s0"># Strategy: we work with raw ndarrays for doing the actual</span>
                <span class="s0"># combining; DesignMatrixBuilder objects never sees pandas</span>
                <span class="s0"># objects. Then at the end, if a DataFrame was requested, we</span>
                <span class="s0"># convert. So every entry in this dict is either a 2-d array</span>
                <span class="s0"># of floats, or a 1-d array of integers (representing</span>
                <span class="s0"># categories).</span>
                <span class="s1">value </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">value</span><span class="s2">)</span>
                <span class="s1">factor_info_to_values</span><span class="s2">[</span><span class="s1">factor_info</span><span class="s2">] = </span><span class="s1">value</span>
    <span class="s0"># Handle NAs</span>
    <span class="s1">values </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">factor_info_to_values</span><span class="s2">.</span><span class="s1">values</span><span class="s2">())</span>
    <span class="s1">is_NAs </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">factor_info_to_isNAs</span><span class="s2">.</span><span class="s1">values</span><span class="s2">())</span>
    <span class="s1">origins </span><span class="s2">= [</span><span class="s1">factor_info</span><span class="s2">.</span><span class="s1">factor</span><span class="s2">.</span><span class="s1">origin</span>
               <span class="s4">for </span><span class="s1">factor_info </span><span class="s4">in </span><span class="s1">factor_info_to_values</span><span class="s2">]</span>
    <span class="s1">pandas_index </span><span class="s2">= </span><span class="s1">index_checker</span><span class="s2">.</span><span class="s1">value</span>
    <span class="s1">num_rows </span><span class="s2">= </span><span class="s1">rows_checker</span><span class="s2">.</span><span class="s1">value</span>
    <span class="s0"># num_rows is None iff evaluator_to_values (and associated sets like</span>
    <span class="s0"># 'values') are empty, i.e., we have no actual evaluators involved</span>
    <span class="s0"># (formulas like &quot;~ 1&quot;).</span>
    <span class="s4">if </span><span class="s1">return_type </span><span class="s2">== </span><span class="s3">&quot;dataframe&quot; </span><span class="s4">and </span><span class="s1">num_rows </span><span class="s4">is not None</span><span class="s2">:</span>
        <span class="s4">if </span><span class="s1">pandas_index </span><span class="s4">is None</span><span class="s2">:</span>
            <span class="s1">pandas_index </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(</span><span class="s1">num_rows</span><span class="s2">)</span>
        <span class="s1">values</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">pandas_index</span><span class="s2">)</span>
        <span class="s1">is_NAs</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">pandas_index</span><span class="s2">), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">bool</span><span class="s2">))</span>
        <span class="s1">origins</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s4">None</span><span class="s2">)</span>
    <span class="s1">new_values </span><span class="s2">= </span><span class="s1">NA_action</span><span class="s2">.</span><span class="s1">handle_NA</span><span class="s2">(</span><span class="s1">values</span><span class="s2">, </span><span class="s1">is_NAs</span><span class="s2">, </span><span class="s1">origins</span><span class="s2">)</span>
    <span class="s0"># NA_action may have changed the number of rows.</span>
    <span class="s4">if </span><span class="s1">new_values</span><span class="s2">:</span>
        <span class="s1">num_rows </span><span class="s2">= </span><span class="s1">new_values</span><span class="s2">[</span><span class="s5">0</span><span class="s2">].</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]</span>
    <span class="s4">if </span><span class="s1">return_type </span><span class="s2">== </span><span class="s3">&quot;dataframe&quot; </span><span class="s4">and </span><span class="s1">num_rows </span><span class="s4">is not None</span><span class="s2">:</span>
        <span class="s1">pandas_index </span><span class="s2">= </span><span class="s1">new_values</span><span class="s2">.</span><span class="s1">pop</span><span class="s2">()</span>
    <span class="s1">factor_info_to_values </span><span class="s2">= </span><span class="s1">dict</span><span class="s2">(</span><span class="s1">zip</span><span class="s2">(</span><span class="s1">factor_info_to_values</span><span class="s2">, </span><span class="s1">new_values</span><span class="s2">))</span>
    <span class="s0"># Build factor values into matrices</span>
    <span class="s1">results </span><span class="s2">= []</span>
    <span class="s4">for </span><span class="s1">design_info </span><span class="s4">in </span><span class="s1">design_infos</span><span class="s2">:</span>
        <span class="s1">results</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">_build_design_matrix</span><span class="s2">(</span><span class="s1">design_info</span><span class="s2">,</span>
                                            <span class="s1">factor_info_to_values</span><span class="s2">,</span>
                                            <span class="s1">dtype</span><span class="s2">))</span>
    <span class="s1">matrices </span><span class="s2">= []</span>
    <span class="s4">for </span><span class="s1">need_reshape</span><span class="s2">, </span><span class="s1">matrix </span><span class="s4">in </span><span class="s1">results</span><span class="s2">:</span>
        <span class="s4">if </span><span class="s1">need_reshape</span><span class="s2">:</span>
            <span class="s0"># There is no data-dependence, at all -- a formula like &quot;1 ~ 1&quot;.</span>
            <span class="s0"># In this case the builder just returns a single-row matrix, and</span>
            <span class="s0"># we have to broadcast it vertically to the appropriate size. If</span>
            <span class="s0"># we can figure out what that is...</span>
            <span class="s4">assert </span><span class="s1">matrix</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">0</span><span class="s2">] == </span><span class="s5">1</span>
            <span class="s4">if </span><span class="s1">num_rows </span><span class="s4">is not None</span><span class="s2">:</span>
                <span class="s1">matrix </span><span class="s2">= </span><span class="s1">DesignMatrix</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">repeat</span><span class="s2">(</span><span class="s1">matrix</span><span class="s2">, </span><span class="s1">num_rows</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s5">0</span><span class="s2">),</span>
                                      <span class="s1">matrix</span><span class="s2">.</span><span class="s1">design_info</span><span class="s2">)</span>
            <span class="s4">else</span><span class="s2">:</span>
                <span class="s4">raise </span><span class="s1">PatsyError</span><span class="s2">(</span>
                    <span class="s3">&quot;No design matrix has any non-trivial factors, &quot;</span>
                    <span class="s3">&quot;the data object is not a DataFrame. &quot;</span>
                    <span class="s3">&quot;I can't tell how many rows the design matrix should &quot;</span>
                    <span class="s3">&quot;have!&quot;</span>
                    <span class="s2">)</span>
        <span class="s1">matrices</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">matrix</span><span class="s2">)</span>
    <span class="s4">if </span><span class="s1">return_type </span><span class="s2">== </span><span class="s3">&quot;dataframe&quot;</span><span class="s2">:</span>
        <span class="s4">assert </span><span class="s1">have_pandas</span>
        <span class="s4">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">matrix </span><span class="s4">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">matrices</span><span class="s2">):</span>
            <span class="s1">di </span><span class="s2">= </span><span class="s1">matrix</span><span class="s2">.</span><span class="s1">design_info</span>
            <span class="s1">matrices</span><span class="s2">[</span><span class="s1">i</span><span class="s2">] = </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">DataFrame</span><span class="s2">(</span><span class="s1">matrix</span><span class="s2">,</span>
                                           <span class="s1">columns</span><span class="s2">=</span><span class="s1">di</span><span class="s2">.</span><span class="s1">column_names</span><span class="s2">,</span>
                                           <span class="s1">index</span><span class="s2">=</span><span class="s1">pandas_index</span><span class="s2">)</span>
            <span class="s1">matrices</span><span class="s2">[</span><span class="s1">i</span><span class="s2">].</span><span class="s1">design_info </span><span class="s2">= </span><span class="s1">di</span>
    <span class="s4">return </span><span class="s1">matrices</span>

<span class="s0"># It should be possible to do just the factors -&gt; factor_infos stuff</span>
<span class="s0"># alone, since that, well, makes logical sense to do.</span>
</pre>
</body>
</html>