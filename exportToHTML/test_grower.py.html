<html>
<head>
<title>test_grower.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #2aacb8;}
.s4 { color: #7a7e85;}
.s5 { color: #5f826b; font-style: italic;}
.s6 { color: #6aab73;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_grower.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">import </span><span class="s1">pytest</span>
<span class="s0">from </span><span class="s1">numpy</span><span class="s2">.</span><span class="s1">testing </span><span class="s0">import </span><span class="s1">assert_allclose</span><span class="s2">, </span><span class="s1">assert_array_equal</span>
<span class="s0">from </span><span class="s1">pytest </span><span class="s0">import </span><span class="s1">approx</span>

<span class="s0">from </span><span class="s1">sklearn</span><span class="s2">.</span><span class="s1">ensemble</span><span class="s2">.</span><span class="s1">_hist_gradient_boosting</span><span class="s2">.</span><span class="s1">binning </span><span class="s0">import </span><span class="s1">_BinMapper</span>
<span class="s0">from </span><span class="s1">sklearn</span><span class="s2">.</span><span class="s1">ensemble</span><span class="s2">.</span><span class="s1">_hist_gradient_boosting</span><span class="s2">.</span><span class="s1">common </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">G_H_DTYPE</span><span class="s2">,</span>
    <span class="s1">X_BINNED_DTYPE</span><span class="s2">,</span>
    <span class="s1">X_BITSET_INNER_DTYPE</span><span class="s2">,</span>
    <span class="s1">X_DTYPE</span><span class="s2">,</span>
    <span class="s1">Y_DTYPE</span><span class="s2">,</span>
<span class="s2">)</span>
<span class="s0">from </span><span class="s1">sklearn</span><span class="s2">.</span><span class="s1">ensemble</span><span class="s2">.</span><span class="s1">_hist_gradient_boosting</span><span class="s2">.</span><span class="s1">grower </span><span class="s0">import </span><span class="s1">TreeGrower</span>
<span class="s0">from </span><span class="s1">sklearn</span><span class="s2">.</span><span class="s1">preprocessing </span><span class="s0">import </span><span class="s1">OneHotEncoder</span>
<span class="s0">from </span><span class="s1">sklearn</span><span class="s2">.</span><span class="s1">utils</span><span class="s2">.</span><span class="s1">_openmp_helpers </span><span class="s0">import </span><span class="s1">_openmp_effective_n_threads</span>

<span class="s1">n_threads </span><span class="s2">= </span><span class="s1">_openmp_effective_n_threads</span><span class="s2">()</span>


<span class="s0">def </span><span class="s1">_make_training_data</span><span class="s2">(</span><span class="s1">n_bins</span><span class="s2">=</span><span class="s3">256</span><span class="s2">, </span><span class="s1">constant_hessian</span><span class="s2">=</span><span class="s0">True</span><span class="s2">):</span>
    <span class="s1">rng </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">random</span><span class="s2">.</span><span class="s1">RandomState</span><span class="s2">(</span><span class="s3">42</span><span class="s2">)</span>
    <span class="s1">n_samples </span><span class="s2">= </span><span class="s3">10000</span>

    <span class="s4"># Generate some test data directly binned so as to test the grower code</span>
    <span class="s4"># independently of the binning logic.</span>
    <span class="s1">X_binned </span><span class="s2">= </span><span class="s1">rng</span><span class="s2">.</span><span class="s1">randint</span><span class="s2">(</span><span class="s3">0</span><span class="s2">, </span><span class="s1">n_bins </span><span class="s2">- </span><span class="s3">1</span><span class="s2">, </span><span class="s1">size</span><span class="s2">=(</span><span class="s1">n_samples</span><span class="s2">, </span><span class="s3">2</span><span class="s2">), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">X_BINNED_DTYPE</span><span class="s2">)</span>
    <span class="s1">X_binned </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asfortranarray</span><span class="s2">(</span><span class="s1">X_binned</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">true_decision_function</span><span class="s2">(</span><span class="s1">input_features</span><span class="s2">):</span>
        <span class="s5">&quot;&quot;&quot;Ground truth decision function 
 
        This is a very simple yet asymmetric decision tree. Therefore the 
        grower code should have no trouble recovering the decision function 
        from 10000 training samples. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">input_features</span><span class="s2">[</span><span class="s3">0</span><span class="s2">] &lt;= </span><span class="s1">n_bins </span><span class="s2">// </span><span class="s3">2</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s2">-</span><span class="s3">1</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s2">-</span><span class="s3">1 </span><span class="s0">if </span><span class="s1">input_features</span><span class="s2">[</span><span class="s3">1</span><span class="s2">] &lt;= </span><span class="s1">n_bins </span><span class="s2">// </span><span class="s3">3 </span><span class="s0">else </span><span class="s3">1</span>

    <span class="s1">target </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s1">true_decision_function</span><span class="s2">(</span><span class="s1">x</span><span class="s2">) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">X_binned</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">Y_DTYPE</span><span class="s2">)</span>

    <span class="s4"># Assume a square loss applied to an initial model that always predicts 0</span>
    <span class="s4"># (hardcoded for this test):</span>
    <span class="s1">all_gradients </span><span class="s2">= </span><span class="s1">target</span><span class="s2">.</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">G_H_DTYPE</span><span class="s2">)</span>
    <span class="s1">shape_hessians </span><span class="s2">= </span><span class="s3">1 </span><span class="s0">if </span><span class="s1">constant_hessian </span><span class="s0">else </span><span class="s1">all_gradients</span><span class="s2">.</span><span class="s1">shape</span>
    <span class="s1">all_hessians </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">(</span><span class="s1">shape</span><span class="s2">=</span><span class="s1">shape_hessians</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">G_H_DTYPE</span><span class="s2">)</span>

    <span class="s0">return </span><span class="s1">X_binned</span><span class="s2">, </span><span class="s1">all_gradients</span><span class="s2">, </span><span class="s1">all_hessians</span>


<span class="s0">def </span><span class="s1">_check_children_consistency</span><span class="s2">(</span><span class="s1">parent</span><span class="s2">, </span><span class="s1">left</span><span class="s2">, </span><span class="s1">right</span><span class="s2">):</span>
    <span class="s4"># Make sure the samples are correctly dispatched from a parent to its</span>
    <span class="s4"># children</span>
    <span class="s0">assert </span><span class="s1">parent</span><span class="s2">.</span><span class="s1">left_child </span><span class="s0">is </span><span class="s1">left</span>
    <span class="s0">assert </span><span class="s1">parent</span><span class="s2">.</span><span class="s1">right_child </span><span class="s0">is </span><span class="s1">right</span>

    <span class="s4"># each sample from the parent is propagated to one of the two children</span>
    <span class="s0">assert </span><span class="s1">len</span><span class="s2">(</span><span class="s1">left</span><span class="s2">.</span><span class="s1">sample_indices</span><span class="s2">) + </span><span class="s1">len</span><span class="s2">(</span><span class="s1">right</span><span class="s2">.</span><span class="s1">sample_indices</span><span class="s2">) == </span><span class="s1">len</span><span class="s2">(</span>
        <span class="s1">parent</span><span class="s2">.</span><span class="s1">sample_indices</span>
    <span class="s2">)</span>

    <span class="s0">assert </span><span class="s1">set</span><span class="s2">(</span><span class="s1">left</span><span class="s2">.</span><span class="s1">sample_indices</span><span class="s2">).</span><span class="s1">union</span><span class="s2">(</span><span class="s1">set</span><span class="s2">(</span><span class="s1">right</span><span class="s2">.</span><span class="s1">sample_indices</span><span class="s2">)) == </span><span class="s1">set</span><span class="s2">(</span>
        <span class="s1">parent</span><span class="s2">.</span><span class="s1">sample_indices</span>
    <span class="s2">)</span>

    <span class="s4"># samples are sent either to the left or the right node, never to both</span>
    <span class="s0">assert </span><span class="s1">set</span><span class="s2">(</span><span class="s1">left</span><span class="s2">.</span><span class="s1">sample_indices</span><span class="s2">).</span><span class="s1">intersection</span><span class="s2">(</span><span class="s1">set</span><span class="s2">(</span><span class="s1">right</span><span class="s2">.</span><span class="s1">sample_indices</span><span class="s2">)) == </span><span class="s1">set</span><span class="s2">()</span>


<span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">parametrize</span><span class="s2">(</span>
    <span class="s6">&quot;n_bins, constant_hessian, stopping_param, shrinkage&quot;</span><span class="s2">,</span>
    <span class="s2">[</span>
        <span class="s2">(</span><span class="s3">11</span><span class="s2">, </span><span class="s0">True</span><span class="s2">, </span><span class="s6">&quot;min_gain_to_split&quot;</span><span class="s2">, </span><span class="s3">0.5</span><span class="s2">),</span>
        <span class="s2">(</span><span class="s3">11</span><span class="s2">, </span><span class="s0">False</span><span class="s2">, </span><span class="s6">&quot;min_gain_to_split&quot;</span><span class="s2">, </span><span class="s3">1.0</span><span class="s2">),</span>
        <span class="s2">(</span><span class="s3">11</span><span class="s2">, </span><span class="s0">True</span><span class="s2">, </span><span class="s6">&quot;max_leaf_nodes&quot;</span><span class="s2">, </span><span class="s3">1.0</span><span class="s2">),</span>
        <span class="s2">(</span><span class="s3">11</span><span class="s2">, </span><span class="s0">False</span><span class="s2">, </span><span class="s6">&quot;max_leaf_nodes&quot;</span><span class="s2">, </span><span class="s3">0.1</span><span class="s2">),</span>
        <span class="s2">(</span><span class="s3">42</span><span class="s2">, </span><span class="s0">True</span><span class="s2">, </span><span class="s6">&quot;max_leaf_nodes&quot;</span><span class="s2">, </span><span class="s3">0.01</span><span class="s2">),</span>
        <span class="s2">(</span><span class="s3">42</span><span class="s2">, </span><span class="s0">False</span><span class="s2">, </span><span class="s6">&quot;max_leaf_nodes&quot;</span><span class="s2">, </span><span class="s3">1.0</span><span class="s2">),</span>
        <span class="s2">(</span><span class="s3">256</span><span class="s2">, </span><span class="s0">True</span><span class="s2">, </span><span class="s6">&quot;min_gain_to_split&quot;</span><span class="s2">, </span><span class="s3">1.0</span><span class="s2">),</span>
        <span class="s2">(</span><span class="s3">256</span><span class="s2">, </span><span class="s0">True</span><span class="s2">, </span><span class="s6">&quot;max_leaf_nodes&quot;</span><span class="s2">, </span><span class="s3">0.1</span><span class="s2">),</span>
    <span class="s2">],</span>
<span class="s2">)</span>
<span class="s0">def </span><span class="s1">test_grow_tree</span><span class="s2">(</span><span class="s1">n_bins</span><span class="s2">, </span><span class="s1">constant_hessian</span><span class="s2">, </span><span class="s1">stopping_param</span><span class="s2">, </span><span class="s1">shrinkage</span><span class="s2">):</span>
    <span class="s1">X_binned</span><span class="s2">, </span><span class="s1">all_gradients</span><span class="s2">, </span><span class="s1">all_hessians </span><span class="s2">= </span><span class="s1">_make_training_data</span><span class="s2">(</span>
        <span class="s1">n_bins</span><span class="s2">=</span><span class="s1">n_bins</span><span class="s2">, </span><span class="s1">constant_hessian</span><span class="s2">=</span><span class="s1">constant_hessian</span>
    <span class="s2">)</span>
    <span class="s1">n_samples </span><span class="s2">= </span><span class="s1">X_binned</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s3">0</span><span class="s2">]</span>

    <span class="s0">if </span><span class="s1">stopping_param </span><span class="s2">== </span><span class="s6">&quot;max_leaf_nodes&quot;</span><span class="s2">:</span>
        <span class="s1">stopping_param </span><span class="s2">= {</span><span class="s6">&quot;max_leaf_nodes&quot;</span><span class="s2">: </span><span class="s3">3</span><span class="s2">}</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">stopping_param </span><span class="s2">= {</span><span class="s6">&quot;min_gain_to_split&quot;</span><span class="s2">: </span><span class="s3">0.01</span><span class="s2">}</span>

    <span class="s1">grower </span><span class="s2">= </span><span class="s1">TreeGrower</span><span class="s2">(</span>
        <span class="s1">X_binned</span><span class="s2">,</span>
        <span class="s1">all_gradients</span><span class="s2">,</span>
        <span class="s1">all_hessians</span><span class="s2">,</span>
        <span class="s1">n_bins</span><span class="s2">=</span><span class="s1">n_bins</span><span class="s2">,</span>
        <span class="s1">shrinkage</span><span class="s2">=</span><span class="s1">shrinkage</span><span class="s2">,</span>
        <span class="s1">min_samples_leaf</span><span class="s2">=</span><span class="s3">1</span><span class="s2">,</span>
        <span class="s2">**</span><span class="s1">stopping_param</span><span class="s2">,</span>
    <span class="s2">)</span>

    <span class="s4"># The root node is not yet split, but the best possible split has</span>
    <span class="s4"># already been evaluated:</span>
    <span class="s0">assert </span><span class="s1">grower</span><span class="s2">.</span><span class="s1">root</span><span class="s2">.</span><span class="s1">left_child </span><span class="s0">is None</span>
    <span class="s0">assert </span><span class="s1">grower</span><span class="s2">.</span><span class="s1">root</span><span class="s2">.</span><span class="s1">right_child </span><span class="s0">is None</span>

    <span class="s1">root_split </span><span class="s2">= </span><span class="s1">grower</span><span class="s2">.</span><span class="s1">root</span><span class="s2">.</span><span class="s1">split_info</span>
    <span class="s0">assert </span><span class="s1">root_split</span><span class="s2">.</span><span class="s1">feature_idx </span><span class="s2">== </span><span class="s3">0</span>
    <span class="s0">assert </span><span class="s1">root_split</span><span class="s2">.</span><span class="s1">bin_idx </span><span class="s2">== </span><span class="s1">n_bins </span><span class="s2">// </span><span class="s3">2</span>
    <span class="s0">assert </span><span class="s1">len</span><span class="s2">(</span><span class="s1">grower</span><span class="s2">.</span><span class="s1">splittable_nodes</span><span class="s2">) == </span><span class="s3">1</span>

    <span class="s4"># Calling split next applies the next split and computes the best split</span>
    <span class="s4"># for each of the two newly introduced children nodes.</span>
    <span class="s1">left_node</span><span class="s2">, </span><span class="s1">right_node </span><span class="s2">= </span><span class="s1">grower</span><span class="s2">.</span><span class="s1">split_next</span><span class="s2">()</span>

    <span class="s4"># All training samples have ben split in the two nodes, approximately</span>
    <span class="s4"># 50%/50%</span>
    <span class="s1">_check_children_consistency</span><span class="s2">(</span><span class="s1">grower</span><span class="s2">.</span><span class="s1">root</span><span class="s2">, </span><span class="s1">left_node</span><span class="s2">, </span><span class="s1">right_node</span><span class="s2">)</span>
    <span class="s0">assert </span><span class="s1">len</span><span class="s2">(</span><span class="s1">left_node</span><span class="s2">.</span><span class="s1">sample_indices</span><span class="s2">) &gt; </span><span class="s3">0.4 </span><span class="s2">* </span><span class="s1">n_samples</span>
    <span class="s0">assert </span><span class="s1">len</span><span class="s2">(</span><span class="s1">left_node</span><span class="s2">.</span><span class="s1">sample_indices</span><span class="s2">) &lt; </span><span class="s3">0.6 </span><span class="s2">* </span><span class="s1">n_samples</span>

    <span class="s0">if </span><span class="s1">grower</span><span class="s2">.</span><span class="s1">min_gain_to_split </span><span class="s2">&gt; </span><span class="s3">0</span><span class="s2">:</span>
        <span class="s4"># The left node is too pure: there is no gain to split it further.</span>
        <span class="s0">assert </span><span class="s1">left_node</span><span class="s2">.</span><span class="s1">split_info</span><span class="s2">.</span><span class="s1">gain </span><span class="s2">&lt; </span><span class="s1">grower</span><span class="s2">.</span><span class="s1">min_gain_to_split</span>
        <span class="s0">assert </span><span class="s1">left_node </span><span class="s0">in </span><span class="s1">grower</span><span class="s2">.</span><span class="s1">finalized_leaves</span>

    <span class="s4"># The right node can still be split further, this time on feature #1</span>
    <span class="s1">split_info </span><span class="s2">= </span><span class="s1">right_node</span><span class="s2">.</span><span class="s1">split_info</span>
    <span class="s0">assert </span><span class="s1">split_info</span><span class="s2">.</span><span class="s1">gain </span><span class="s2">&gt; </span><span class="s3">1.0</span>
    <span class="s0">assert </span><span class="s1">split_info</span><span class="s2">.</span><span class="s1">feature_idx </span><span class="s2">== </span><span class="s3">1</span>
    <span class="s0">assert </span><span class="s1">split_info</span><span class="s2">.</span><span class="s1">bin_idx </span><span class="s2">== </span><span class="s1">n_bins </span><span class="s2">// </span><span class="s3">3</span>
    <span class="s0">assert </span><span class="s1">right_node</span><span class="s2">.</span><span class="s1">left_child </span><span class="s0">is None</span>
    <span class="s0">assert </span><span class="s1">right_node</span><span class="s2">.</span><span class="s1">right_child </span><span class="s0">is None</span>

    <span class="s4"># The right split has not been applied yet. Let's do it now:</span>
    <span class="s0">assert </span><span class="s1">len</span><span class="s2">(</span><span class="s1">grower</span><span class="s2">.</span><span class="s1">splittable_nodes</span><span class="s2">) == </span><span class="s3">1</span>
    <span class="s1">right_left_node</span><span class="s2">, </span><span class="s1">right_right_node </span><span class="s2">= </span><span class="s1">grower</span><span class="s2">.</span><span class="s1">split_next</span><span class="s2">()</span>
    <span class="s1">_check_children_consistency</span><span class="s2">(</span><span class="s1">right_node</span><span class="s2">, </span><span class="s1">right_left_node</span><span class="s2">, </span><span class="s1">right_right_node</span><span class="s2">)</span>
    <span class="s0">assert </span><span class="s1">len</span><span class="s2">(</span><span class="s1">right_left_node</span><span class="s2">.</span><span class="s1">sample_indices</span><span class="s2">) &gt; </span><span class="s3">0.1 </span><span class="s2">* </span><span class="s1">n_samples</span>
    <span class="s0">assert </span><span class="s1">len</span><span class="s2">(</span><span class="s1">right_left_node</span><span class="s2">.</span><span class="s1">sample_indices</span><span class="s2">) &lt; </span><span class="s3">0.2 </span><span class="s2">* </span><span class="s1">n_samples</span>

    <span class="s0">assert </span><span class="s1">len</span><span class="s2">(</span><span class="s1">right_right_node</span><span class="s2">.</span><span class="s1">sample_indices</span><span class="s2">) &gt; </span><span class="s3">0.2 </span><span class="s2">* </span><span class="s1">n_samples</span>
    <span class="s0">assert </span><span class="s1">len</span><span class="s2">(</span><span class="s1">right_right_node</span><span class="s2">.</span><span class="s1">sample_indices</span><span class="s2">) &lt; </span><span class="s3">0.4 </span><span class="s2">* </span><span class="s1">n_samples</span>

    <span class="s4"># All the leafs are pure, it is not possible to split any further:</span>
    <span class="s0">assert not </span><span class="s1">grower</span><span class="s2">.</span><span class="s1">splittable_nodes</span>

    <span class="s1">grower</span><span class="s2">.</span><span class="s1">_apply_shrinkage</span><span class="s2">()</span>

    <span class="s4"># Check the values of the leaves:</span>
    <span class="s0">assert </span><span class="s1">grower</span><span class="s2">.</span><span class="s1">root</span><span class="s2">.</span><span class="s1">left_child</span><span class="s2">.</span><span class="s1">value </span><span class="s2">== </span><span class="s1">approx</span><span class="s2">(</span><span class="s1">shrinkage</span><span class="s2">)</span>
    <span class="s0">assert </span><span class="s1">grower</span><span class="s2">.</span><span class="s1">root</span><span class="s2">.</span><span class="s1">right_child</span><span class="s2">.</span><span class="s1">left_child</span><span class="s2">.</span><span class="s1">value </span><span class="s2">== </span><span class="s1">approx</span><span class="s2">(</span><span class="s1">shrinkage</span><span class="s2">)</span>
    <span class="s0">assert </span><span class="s1">grower</span><span class="s2">.</span><span class="s1">root</span><span class="s2">.</span><span class="s1">right_child</span><span class="s2">.</span><span class="s1">right_child</span><span class="s2">.</span><span class="s1">value </span><span class="s2">== </span><span class="s1">approx</span><span class="s2">(-</span><span class="s1">shrinkage</span><span class="s2">, </span><span class="s1">rel</span><span class="s2">=</span><span class="s3">1e-3</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">test_predictor_from_grower</span><span class="s2">():</span>
    <span class="s4"># Build a tree on the toy 3-leaf dataset to extract the predictor.</span>
    <span class="s1">n_bins </span><span class="s2">= </span><span class="s3">256</span>
    <span class="s1">X_binned</span><span class="s2">, </span><span class="s1">all_gradients</span><span class="s2">, </span><span class="s1">all_hessians </span><span class="s2">= </span><span class="s1">_make_training_data</span><span class="s2">(</span><span class="s1">n_bins</span><span class="s2">=</span><span class="s1">n_bins</span><span class="s2">)</span>
    <span class="s1">grower </span><span class="s2">= </span><span class="s1">TreeGrower</span><span class="s2">(</span>
        <span class="s1">X_binned</span><span class="s2">,</span>
        <span class="s1">all_gradients</span><span class="s2">,</span>
        <span class="s1">all_hessians</span><span class="s2">,</span>
        <span class="s1">n_bins</span><span class="s2">=</span><span class="s1">n_bins</span><span class="s2">,</span>
        <span class="s1">shrinkage</span><span class="s2">=</span><span class="s3">1.0</span><span class="s2">,</span>
        <span class="s1">max_leaf_nodes</span><span class="s2">=</span><span class="s3">3</span><span class="s2">,</span>
        <span class="s1">min_samples_leaf</span><span class="s2">=</span><span class="s3">5</span><span class="s2">,</span>
    <span class="s2">)</span>
    <span class="s1">grower</span><span class="s2">.</span><span class="s1">grow</span><span class="s2">()</span>
    <span class="s0">assert </span><span class="s1">grower</span><span class="s2">.</span><span class="s1">n_nodes </span><span class="s2">== </span><span class="s3">5  </span><span class="s4"># (2 decision nodes + 3 leaves)</span>

    <span class="s4"># Check that the node structure can be converted into a predictor</span>
    <span class="s4"># object to perform predictions at scale</span>
    <span class="s4"># We pass undefined binning_thresholds because we won't use predict anyway</span>
    <span class="s1">predictor </span><span class="s2">= </span><span class="s1">grower</span><span class="s2">.</span><span class="s1">make_predictor</span><span class="s2">(</span>
        <span class="s1">binning_thresholds</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">((</span><span class="s1">X_binned</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s3">1</span><span class="s2">], </span><span class="s1">n_bins</span><span class="s2">))</span>
    <span class="s2">)</span>
    <span class="s0">assert </span><span class="s1">predictor</span><span class="s2">.</span><span class="s1">nodes</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s3">0</span><span class="s2">] == </span><span class="s3">5</span>
    <span class="s0">assert </span><span class="s1">predictor</span><span class="s2">.</span><span class="s1">nodes</span><span class="s2">[</span><span class="s6">&quot;is_leaf&quot;</span><span class="s2">].</span><span class="s1">sum</span><span class="s2">() == </span><span class="s3">3</span>

    <span class="s4"># Probe some predictions for each leaf of the tree</span>
    <span class="s4"># each group of 3 samples corresponds to a condition in _make_training_data</span>
    <span class="s1">input_data </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">(</span>
        <span class="s2">[</span>
            <span class="s2">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">],</span>
            <span class="s2">[</span><span class="s3">42</span><span class="s2">, </span><span class="s3">99</span><span class="s2">],</span>
            <span class="s2">[</span><span class="s3">128</span><span class="s2">, </span><span class="s3">254</span><span class="s2">],</span>
            <span class="s2">[</span><span class="s3">129</span><span class="s2">, </span><span class="s3">0</span><span class="s2">],</span>
            <span class="s2">[</span><span class="s3">129</span><span class="s2">, </span><span class="s3">85</span><span class="s2">],</span>
            <span class="s2">[</span><span class="s3">254</span><span class="s2">, </span><span class="s3">85</span><span class="s2">],</span>
            <span class="s2">[</span><span class="s3">129</span><span class="s2">, </span><span class="s3">86</span><span class="s2">],</span>
            <span class="s2">[</span><span class="s3">129</span><span class="s2">, </span><span class="s3">254</span><span class="s2">],</span>
            <span class="s2">[</span><span class="s3">242</span><span class="s2">, </span><span class="s3">100</span><span class="s2">],</span>
        <span class="s2">],</span>
        <span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">uint8</span><span class="s2">,</span>
    <span class="s2">)</span>
    <span class="s1">missing_values_bin_idx </span><span class="s2">= </span><span class="s1">n_bins </span><span class="s2">- </span><span class="s3">1</span>
    <span class="s1">predictions </span><span class="s2">= </span><span class="s1">predictor</span><span class="s2">.</span><span class="s1">predict_binned</span><span class="s2">(</span>
        <span class="s1">input_data</span><span class="s2">, </span><span class="s1">missing_values_bin_idx</span><span class="s2">, </span><span class="s1">n_threads</span>
    <span class="s2">)</span>
    <span class="s1">expected_targets </span><span class="s2">= [</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, -</span><span class="s3">1</span><span class="s2">, -</span><span class="s3">1</span><span class="s2">, -</span><span class="s3">1</span><span class="s2">]</span>
    <span class="s0">assert </span><span class="s1">np</span><span class="s2">.</span><span class="s1">allclose</span><span class="s2">(</span><span class="s1">predictions</span><span class="s2">, </span><span class="s1">expected_targets</span><span class="s2">)</span>

    <span class="s4"># Check that training set can be recovered exactly:</span>
    <span class="s1">predictions </span><span class="s2">= </span><span class="s1">predictor</span><span class="s2">.</span><span class="s1">predict_binned</span><span class="s2">(</span><span class="s1">X_binned</span><span class="s2">, </span><span class="s1">missing_values_bin_idx</span><span class="s2">, </span><span class="s1">n_threads</span><span class="s2">)</span>
    <span class="s0">assert </span><span class="s1">np</span><span class="s2">.</span><span class="s1">allclose</span><span class="s2">(</span><span class="s1">predictions</span><span class="s2">, -</span><span class="s1">all_gradients</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">parametrize</span><span class="s2">(</span>
    <span class="s6">&quot;n_samples, min_samples_leaf, n_bins, constant_hessian, noise&quot;</span><span class="s2">,</span>
    <span class="s2">[</span>
        <span class="s2">(</span><span class="s3">11</span><span class="s2">, </span><span class="s3">10</span><span class="s2">, </span><span class="s3">7</span><span class="s2">, </span><span class="s0">True</span><span class="s2">, </span><span class="s3">0</span><span class="s2">),</span>
        <span class="s2">(</span><span class="s3">13</span><span class="s2">, </span><span class="s3">10</span><span class="s2">, </span><span class="s3">42</span><span class="s2">, </span><span class="s0">False</span><span class="s2">, </span><span class="s3">0</span><span class="s2">),</span>
        <span class="s2">(</span><span class="s3">56</span><span class="s2">, </span><span class="s3">10</span><span class="s2">, </span><span class="s3">255</span><span class="s2">, </span><span class="s0">True</span><span class="s2">, </span><span class="s3">0.1</span><span class="s2">),</span>
        <span class="s2">(</span><span class="s3">101</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">7</span><span class="s2">, </span><span class="s0">True</span><span class="s2">, </span><span class="s3">0</span><span class="s2">),</span>
        <span class="s2">(</span><span class="s3">200</span><span class="s2">, </span><span class="s3">42</span><span class="s2">, </span><span class="s3">42</span><span class="s2">, </span><span class="s0">False</span><span class="s2">, </span><span class="s3">0</span><span class="s2">),</span>
        <span class="s2">(</span><span class="s3">300</span><span class="s2">, </span><span class="s3">55</span><span class="s2">, </span><span class="s3">255</span><span class="s2">, </span><span class="s0">True</span><span class="s2">, </span><span class="s3">0.1</span><span class="s2">),</span>
        <span class="s2">(</span><span class="s3">300</span><span class="s2">, </span><span class="s3">301</span><span class="s2">, </span><span class="s3">255</span><span class="s2">, </span><span class="s0">True</span><span class="s2">, </span><span class="s3">0.1</span><span class="s2">),</span>
    <span class="s2">],</span>
<span class="s2">)</span>
<span class="s0">def </span><span class="s1">test_min_samples_leaf</span><span class="s2">(</span><span class="s1">n_samples</span><span class="s2">, </span><span class="s1">min_samples_leaf</span><span class="s2">, </span><span class="s1">n_bins</span><span class="s2">, </span><span class="s1">constant_hessian</span><span class="s2">, </span><span class="s1">noise</span><span class="s2">):</span>
    <span class="s1">rng </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">random</span><span class="s2">.</span><span class="s1">RandomState</span><span class="s2">(</span><span class="s1">seed</span><span class="s2">=</span><span class="s3">0</span><span class="s2">)</span>
    <span class="s4"># data = linear target, 3 features, 1 irrelevant.</span>
    <span class="s1">X </span><span class="s2">= </span><span class="s1">rng</span><span class="s2">.</span><span class="s1">normal</span><span class="s2">(</span><span class="s1">size</span><span class="s2">=(</span><span class="s1">n_samples</span><span class="s2">, </span><span class="s3">3</span><span class="s2">))</span>
    <span class="s1">y </span><span class="s2">= </span><span class="s1">X</span><span class="s2">[:, </span><span class="s3">0</span><span class="s2">] - </span><span class="s1">X</span><span class="s2">[:, </span><span class="s3">1</span><span class="s2">]</span>
    <span class="s0">if </span><span class="s1">noise</span><span class="s2">:</span>
        <span class="s1">y_scale </span><span class="s2">= </span><span class="s1">y</span><span class="s2">.</span><span class="s1">std</span><span class="s2">()</span>
        <span class="s1">y </span><span class="s2">+= </span><span class="s1">rng</span><span class="s2">.</span><span class="s1">normal</span><span class="s2">(</span><span class="s1">scale</span><span class="s2">=</span><span class="s1">noise</span><span class="s2">, </span><span class="s1">size</span><span class="s2">=</span><span class="s1">n_samples</span><span class="s2">) * </span><span class="s1">y_scale</span>
    <span class="s1">mapper </span><span class="s2">= </span><span class="s1">_BinMapper</span><span class="s2">(</span><span class="s1">n_bins</span><span class="s2">=</span><span class="s1">n_bins</span><span class="s2">)</span>
    <span class="s1">X </span><span class="s2">= </span><span class="s1">mapper</span><span class="s2">.</span><span class="s1">fit_transform</span><span class="s2">(</span><span class="s1">X</span><span class="s2">)</span>

    <span class="s1">all_gradients </span><span class="s2">= </span><span class="s1">y</span><span class="s2">.</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">G_H_DTYPE</span><span class="s2">)</span>
    <span class="s1">shape_hessian </span><span class="s2">= </span><span class="s3">1 </span><span class="s0">if </span><span class="s1">constant_hessian </span><span class="s0">else </span><span class="s1">all_gradients</span><span class="s2">.</span><span class="s1">shape</span>
    <span class="s1">all_hessians </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">(</span><span class="s1">shape</span><span class="s2">=</span><span class="s1">shape_hessian</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">G_H_DTYPE</span><span class="s2">)</span>
    <span class="s1">grower </span><span class="s2">= </span><span class="s1">TreeGrower</span><span class="s2">(</span>
        <span class="s1">X</span><span class="s2">,</span>
        <span class="s1">all_gradients</span><span class="s2">,</span>
        <span class="s1">all_hessians</span><span class="s2">,</span>
        <span class="s1">n_bins</span><span class="s2">=</span><span class="s1">n_bins</span><span class="s2">,</span>
        <span class="s1">shrinkage</span><span class="s2">=</span><span class="s3">1.0</span><span class="s2">,</span>
        <span class="s1">min_samples_leaf</span><span class="s2">=</span><span class="s1">min_samples_leaf</span><span class="s2">,</span>
        <span class="s1">max_leaf_nodes</span><span class="s2">=</span><span class="s1">n_samples</span><span class="s2">,</span>
    <span class="s2">)</span>
    <span class="s1">grower</span><span class="s2">.</span><span class="s1">grow</span><span class="s2">()</span>
    <span class="s1">predictor </span><span class="s2">= </span><span class="s1">grower</span><span class="s2">.</span><span class="s1">make_predictor</span><span class="s2">(</span><span class="s1">binning_thresholds</span><span class="s2">=</span><span class="s1">mapper</span><span class="s2">.</span><span class="s1">bin_thresholds_</span><span class="s2">)</span>

    <span class="s0">if </span><span class="s1">n_samples </span><span class="s2">&gt;= </span><span class="s1">min_samples_leaf</span><span class="s2">:</span>
        <span class="s0">for </span><span class="s1">node </span><span class="s0">in </span><span class="s1">predictor</span><span class="s2">.</span><span class="s1">nodes</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">node</span><span class="s2">[</span><span class="s6">&quot;is_leaf&quot;</span><span class="s2">]:</span>
                <span class="s0">assert </span><span class="s1">node</span><span class="s2">[</span><span class="s6">&quot;count&quot;</span><span class="s2">] &gt;= </span><span class="s1">min_samples_leaf</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s0">assert </span><span class="s1">predictor</span><span class="s2">.</span><span class="s1">nodes</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s3">0</span><span class="s2">] == </span><span class="s3">1</span>
        <span class="s0">assert </span><span class="s1">predictor</span><span class="s2">.</span><span class="s1">nodes</span><span class="s2">[</span><span class="s3">0</span><span class="s2">][</span><span class="s6">&quot;is_leaf&quot;</span><span class="s2">]</span>
        <span class="s0">assert </span><span class="s1">predictor</span><span class="s2">.</span><span class="s1">nodes</span><span class="s2">[</span><span class="s3">0</span><span class="s2">][</span><span class="s6">&quot;count&quot;</span><span class="s2">] == </span><span class="s1">n_samples</span>


<span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">parametrize</span><span class="s2">(</span><span class="s6">&quot;n_samples, min_samples_leaf&quot;</span><span class="s2">, [(</span><span class="s3">99</span><span class="s2">, </span><span class="s3">50</span><span class="s2">), (</span><span class="s3">100</span><span class="s2">, </span><span class="s3">50</span><span class="s2">)])</span>
<span class="s0">def </span><span class="s1">test_min_samples_leaf_root</span><span class="s2">(</span><span class="s1">n_samples</span><span class="s2">, </span><span class="s1">min_samples_leaf</span><span class="s2">):</span>
    <span class="s4"># Make sure root node isn't split if n_samples is not at least twice</span>
    <span class="s4"># min_samples_leaf</span>
    <span class="s1">rng </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">random</span><span class="s2">.</span><span class="s1">RandomState</span><span class="s2">(</span><span class="s1">seed</span><span class="s2">=</span><span class="s3">0</span><span class="s2">)</span>

    <span class="s1">n_bins </span><span class="s2">= </span><span class="s3">256</span>

    <span class="s4"># data = linear target, 3 features, 1 irrelevant.</span>
    <span class="s1">X </span><span class="s2">= </span><span class="s1">rng</span><span class="s2">.</span><span class="s1">normal</span><span class="s2">(</span><span class="s1">size</span><span class="s2">=(</span><span class="s1">n_samples</span><span class="s2">, </span><span class="s3">3</span><span class="s2">))</span>
    <span class="s1">y </span><span class="s2">= </span><span class="s1">X</span><span class="s2">[:, </span><span class="s3">0</span><span class="s2">] - </span><span class="s1">X</span><span class="s2">[:, </span><span class="s3">1</span><span class="s2">]</span>
    <span class="s1">mapper </span><span class="s2">= </span><span class="s1">_BinMapper</span><span class="s2">(</span><span class="s1">n_bins</span><span class="s2">=</span><span class="s1">n_bins</span><span class="s2">)</span>
    <span class="s1">X </span><span class="s2">= </span><span class="s1">mapper</span><span class="s2">.</span><span class="s1">fit_transform</span><span class="s2">(</span><span class="s1">X</span><span class="s2">)</span>

    <span class="s1">all_gradients </span><span class="s2">= </span><span class="s1">y</span><span class="s2">.</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">G_H_DTYPE</span><span class="s2">)</span>
    <span class="s1">all_hessians </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">(</span><span class="s1">shape</span><span class="s2">=</span><span class="s3">1</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">G_H_DTYPE</span><span class="s2">)</span>
    <span class="s1">grower </span><span class="s2">= </span><span class="s1">TreeGrower</span><span class="s2">(</span>
        <span class="s1">X</span><span class="s2">,</span>
        <span class="s1">all_gradients</span><span class="s2">,</span>
        <span class="s1">all_hessians</span><span class="s2">,</span>
        <span class="s1">n_bins</span><span class="s2">=</span><span class="s1">n_bins</span><span class="s2">,</span>
        <span class="s1">shrinkage</span><span class="s2">=</span><span class="s3">1.0</span><span class="s2">,</span>
        <span class="s1">min_samples_leaf</span><span class="s2">=</span><span class="s1">min_samples_leaf</span><span class="s2">,</span>
        <span class="s1">max_leaf_nodes</span><span class="s2">=</span><span class="s1">n_samples</span><span class="s2">,</span>
    <span class="s2">)</span>
    <span class="s1">grower</span><span class="s2">.</span><span class="s1">grow</span><span class="s2">()</span>
    <span class="s0">if </span><span class="s1">n_samples </span><span class="s2">&gt;= </span><span class="s1">min_samples_leaf </span><span class="s2">* </span><span class="s3">2</span><span class="s2">:</span>
        <span class="s0">assert </span><span class="s1">len</span><span class="s2">(</span><span class="s1">grower</span><span class="s2">.</span><span class="s1">finalized_leaves</span><span class="s2">) &gt;= </span><span class="s3">2</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s0">assert </span><span class="s1">len</span><span class="s2">(</span><span class="s1">grower</span><span class="s2">.</span><span class="s1">finalized_leaves</span><span class="s2">) == </span><span class="s3">1</span>


<span class="s0">def </span><span class="s1">assert_is_stump</span><span class="s2">(</span><span class="s1">grower</span><span class="s2">):</span>
    <span class="s4"># To assert that stumps are created when max_depth=1</span>
    <span class="s0">for </span><span class="s1">leaf </span><span class="s0">in </span><span class="s2">(</span><span class="s1">grower</span><span class="s2">.</span><span class="s1">root</span><span class="s2">.</span><span class="s1">left_child</span><span class="s2">, </span><span class="s1">grower</span><span class="s2">.</span><span class="s1">root</span><span class="s2">.</span><span class="s1">right_child</span><span class="s2">):</span>
        <span class="s0">assert </span><span class="s1">leaf</span><span class="s2">.</span><span class="s1">left_child </span><span class="s0">is None</span>
        <span class="s0">assert </span><span class="s1">leaf</span><span class="s2">.</span><span class="s1">right_child </span><span class="s0">is None</span>


<span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">parametrize</span><span class="s2">(</span><span class="s6">&quot;max_depth&quot;</span><span class="s2">, [</span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s2">])</span>
<span class="s0">def </span><span class="s1">test_max_depth</span><span class="s2">(</span><span class="s1">max_depth</span><span class="s2">):</span>
    <span class="s4"># Make sure max_depth parameter works as expected</span>
    <span class="s1">rng </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">random</span><span class="s2">.</span><span class="s1">RandomState</span><span class="s2">(</span><span class="s1">seed</span><span class="s2">=</span><span class="s3">0</span><span class="s2">)</span>

    <span class="s1">n_bins </span><span class="s2">= </span><span class="s3">256</span>
    <span class="s1">n_samples </span><span class="s2">= </span><span class="s3">1000</span>

    <span class="s4"># data = linear target, 3 features, 1 irrelevant.</span>
    <span class="s1">X </span><span class="s2">= </span><span class="s1">rng</span><span class="s2">.</span><span class="s1">normal</span><span class="s2">(</span><span class="s1">size</span><span class="s2">=(</span><span class="s1">n_samples</span><span class="s2">, </span><span class="s3">3</span><span class="s2">))</span>
    <span class="s1">y </span><span class="s2">= </span><span class="s1">X</span><span class="s2">[:, </span><span class="s3">0</span><span class="s2">] - </span><span class="s1">X</span><span class="s2">[:, </span><span class="s3">1</span><span class="s2">]</span>
    <span class="s1">mapper </span><span class="s2">= </span><span class="s1">_BinMapper</span><span class="s2">(</span><span class="s1">n_bins</span><span class="s2">=</span><span class="s1">n_bins</span><span class="s2">)</span>
    <span class="s1">X </span><span class="s2">= </span><span class="s1">mapper</span><span class="s2">.</span><span class="s1">fit_transform</span><span class="s2">(</span><span class="s1">X</span><span class="s2">)</span>

    <span class="s1">all_gradients </span><span class="s2">= </span><span class="s1">y</span><span class="s2">.</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">G_H_DTYPE</span><span class="s2">)</span>
    <span class="s1">all_hessians </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">(</span><span class="s1">shape</span><span class="s2">=</span><span class="s3">1</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">G_H_DTYPE</span><span class="s2">)</span>
    <span class="s1">grower </span><span class="s2">= </span><span class="s1">TreeGrower</span><span class="s2">(</span><span class="s1">X</span><span class="s2">, </span><span class="s1">all_gradients</span><span class="s2">, </span><span class="s1">all_hessians</span><span class="s2">, </span><span class="s1">max_depth</span><span class="s2">=</span><span class="s1">max_depth</span><span class="s2">)</span>
    <span class="s1">grower</span><span class="s2">.</span><span class="s1">grow</span><span class="s2">()</span>

    <span class="s1">depth </span><span class="s2">= </span><span class="s1">max</span><span class="s2">(</span><span class="s1">leaf</span><span class="s2">.</span><span class="s1">depth </span><span class="s0">for </span><span class="s1">leaf </span><span class="s0">in </span><span class="s1">grower</span><span class="s2">.</span><span class="s1">finalized_leaves</span><span class="s2">)</span>
    <span class="s0">assert </span><span class="s1">depth </span><span class="s2">== </span><span class="s1">max_depth</span>

    <span class="s0">if </span><span class="s1">max_depth </span><span class="s2">== </span><span class="s3">1</span><span class="s2">:</span>
        <span class="s1">assert_is_stump</span><span class="s2">(</span><span class="s1">grower</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">test_input_validation</span><span class="s2">():</span>
    <span class="s1">X_binned</span><span class="s2">, </span><span class="s1">all_gradients</span><span class="s2">, </span><span class="s1">all_hessians </span><span class="s2">= </span><span class="s1">_make_training_data</span><span class="s2">()</span>

    <span class="s1">X_binned_float </span><span class="s2">= </span><span class="s1">X_binned</span><span class="s2">.</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float32</span><span class="s2">)</span>
    <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">NotImplementedError</span><span class="s2">, </span><span class="s1">match</span><span class="s2">=</span><span class="s6">&quot;X_binned must be of type uint8&quot;</span><span class="s2">):</span>
        <span class="s1">TreeGrower</span><span class="s2">(</span><span class="s1">X_binned_float</span><span class="s2">, </span><span class="s1">all_gradients</span><span class="s2">, </span><span class="s1">all_hessians</span><span class="s2">)</span>

    <span class="s1">X_binned_C_array </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ascontiguousarray</span><span class="s2">(</span><span class="s1">X_binned</span><span class="s2">)</span>
    <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span>
        <span class="s1">ValueError</span><span class="s2">, </span><span class="s1">match</span><span class="s2">=</span><span class="s6">&quot;X_binned should be passed as Fortran contiguous array&quot;</span>
    <span class="s2">):</span>
        <span class="s1">TreeGrower</span><span class="s2">(</span><span class="s1">X_binned_C_array</span><span class="s2">, </span><span class="s1">all_gradients</span><span class="s2">, </span><span class="s1">all_hessians</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">test_init_parameters_validation</span><span class="s2">():</span>
    <span class="s1">X_binned</span><span class="s2">, </span><span class="s1">all_gradients</span><span class="s2">, </span><span class="s1">all_hessians </span><span class="s2">= </span><span class="s1">_make_training_data</span><span class="s2">()</span>
    <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">ValueError</span><span class="s2">, </span><span class="s1">match</span><span class="s2">=</span><span class="s6">&quot;min_gain_to_split=-1 must be positive&quot;</span><span class="s2">):</span>
        <span class="s1">TreeGrower</span><span class="s2">(</span><span class="s1">X_binned</span><span class="s2">, </span><span class="s1">all_gradients</span><span class="s2">, </span><span class="s1">all_hessians</span><span class="s2">, </span><span class="s1">min_gain_to_split</span><span class="s2">=-</span><span class="s3">1</span><span class="s2">)</span>

    <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">ValueError</span><span class="s2">, </span><span class="s1">match</span><span class="s2">=</span><span class="s6">&quot;min_hessian_to_split=-1 must be positive&quot;</span><span class="s2">):</span>
        <span class="s1">TreeGrower</span><span class="s2">(</span><span class="s1">X_binned</span><span class="s2">, </span><span class="s1">all_gradients</span><span class="s2">, </span><span class="s1">all_hessians</span><span class="s2">, </span><span class="s1">min_hessian_to_split</span><span class="s2">=-</span><span class="s3">1</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">test_missing_value_predict_only</span><span class="s2">():</span>
    <span class="s4"># Make sure that missing values are supported at predict time even if they</span>
    <span class="s4"># were not encountered in the training data: the missing values are</span>
    <span class="s4"># assigned to whichever child has the most samples.</span>

    <span class="s1">rng </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">random</span><span class="s2">.</span><span class="s1">RandomState</span><span class="s2">(</span><span class="s3">0</span><span class="s2">)</span>
    <span class="s1">n_samples </span><span class="s2">= </span><span class="s3">100</span>
    <span class="s1">X_binned </span><span class="s2">= </span><span class="s1">rng</span><span class="s2">.</span><span class="s1">randint</span><span class="s2">(</span><span class="s3">0</span><span class="s2">, </span><span class="s3">256</span><span class="s2">, </span><span class="s1">size</span><span class="s2">=(</span><span class="s1">n_samples</span><span class="s2">, </span><span class="s3">1</span><span class="s2">), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">uint8</span><span class="s2">)</span>
    <span class="s1">X_binned </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asfortranarray</span><span class="s2">(</span><span class="s1">X_binned</span><span class="s2">)</span>

    <span class="s1">gradients </span><span class="s2">= </span><span class="s1">rng</span><span class="s2">.</span><span class="s1">normal</span><span class="s2">(</span><span class="s1">size</span><span class="s2">=</span><span class="s1">n_samples</span><span class="s2">).</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">G_H_DTYPE</span><span class="s2">)</span>
    <span class="s1">hessians </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">(</span><span class="s1">shape</span><span class="s2">=</span><span class="s3">1</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">G_H_DTYPE</span><span class="s2">)</span>

    <span class="s1">grower </span><span class="s2">= </span><span class="s1">TreeGrower</span><span class="s2">(</span>
        <span class="s1">X_binned</span><span class="s2">, </span><span class="s1">gradients</span><span class="s2">, </span><span class="s1">hessians</span><span class="s2">, </span><span class="s1">min_samples_leaf</span><span class="s2">=</span><span class="s3">5</span><span class="s2">, </span><span class="s1">has_missing_values</span><span class="s2">=</span><span class="s0">False</span>
    <span class="s2">)</span>
    <span class="s1">grower</span><span class="s2">.</span><span class="s1">grow</span><span class="s2">()</span>

    <span class="s4"># We pass undefined binning_thresholds because we won't use predict anyway</span>
    <span class="s1">predictor </span><span class="s2">= </span><span class="s1">grower</span><span class="s2">.</span><span class="s1">make_predictor</span><span class="s2">(</span>
        <span class="s1">binning_thresholds</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">((</span><span class="s1">X_binned</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s3">1</span><span class="s2">], </span><span class="s1">X_binned</span><span class="s2">.</span><span class="s1">max</span><span class="s2">() + </span><span class="s3">1</span><span class="s2">))</span>
    <span class="s2">)</span>

    <span class="s4"># go from root to a leaf, always following node with the most samples.</span>
    <span class="s4"># That's the path nans are supposed to take</span>
    <span class="s1">node </span><span class="s2">= </span><span class="s1">predictor</span><span class="s2">.</span><span class="s1">nodes</span><span class="s2">[</span><span class="s3">0</span><span class="s2">]</span>
    <span class="s0">while not </span><span class="s1">node</span><span class="s2">[</span><span class="s6">&quot;is_leaf&quot;</span><span class="s2">]:</span>
        <span class="s1">left </span><span class="s2">= </span><span class="s1">predictor</span><span class="s2">.</span><span class="s1">nodes</span><span class="s2">[</span><span class="s1">node</span><span class="s2">[</span><span class="s6">&quot;left&quot;</span><span class="s2">]]</span>
        <span class="s1">right </span><span class="s2">= </span><span class="s1">predictor</span><span class="s2">.</span><span class="s1">nodes</span><span class="s2">[</span><span class="s1">node</span><span class="s2">[</span><span class="s6">&quot;right&quot;</span><span class="s2">]]</span>
        <span class="s1">node </span><span class="s2">= </span><span class="s1">left </span><span class="s0">if </span><span class="s1">left</span><span class="s2">[</span><span class="s6">&quot;count&quot;</span><span class="s2">] &gt; </span><span class="s1">right</span><span class="s2">[</span><span class="s6">&quot;count&quot;</span><span class="s2">] </span><span class="s0">else </span><span class="s1">right</span>

    <span class="s1">prediction_main_path </span><span class="s2">= </span><span class="s1">node</span><span class="s2">[</span><span class="s6">&quot;value&quot;</span><span class="s2">]</span>

    <span class="s4"># now build X_test with only nans, and make sure all predictions are equal</span>
    <span class="s4"># to prediction_main_path</span>
    <span class="s1">all_nans </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">full</span><span class="s2">(</span><span class="s1">shape</span><span class="s2">=(</span><span class="s1">n_samples</span><span class="s2">, </span><span class="s3">1</span><span class="s2">), </span><span class="s1">fill_value</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">nan</span><span class="s2">)</span>
    <span class="s1">known_cat_bitsets </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">((</span><span class="s3">0</span><span class="s2">, </span><span class="s3">8</span><span class="s2">), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">X_BITSET_INNER_DTYPE</span><span class="s2">)</span>
    <span class="s1">f_idx_map </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">(</span><span class="s3">0</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">uint32</span><span class="s2">)</span>

    <span class="s1">y_pred </span><span class="s2">= </span><span class="s1">predictor</span><span class="s2">.</span><span class="s1">predict</span><span class="s2">(</span><span class="s1">all_nans</span><span class="s2">, </span><span class="s1">known_cat_bitsets</span><span class="s2">, </span><span class="s1">f_idx_map</span><span class="s2">, </span><span class="s1">n_threads</span><span class="s2">)</span>
    <span class="s0">assert </span><span class="s1">np</span><span class="s2">.</span><span class="s1">all</span><span class="s2">(</span><span class="s1">y_pred </span><span class="s2">== </span><span class="s1">prediction_main_path</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">test_split_on_nan_with_infinite_values</span><span class="s2">():</span>
    <span class="s4"># Make sure the split on nan situations are respected even when there are</span>
    <span class="s4"># samples with +inf values (we set the threshold to +inf when we have a</span>
    <span class="s4"># split on nan so this test makes sure this does not introduce edge-case</span>
    <span class="s4"># bugs). We need to use the private API so that we can also test</span>
    <span class="s4"># predict_binned().</span>

    <span class="s1">X </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">nan</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">nan</span><span class="s2">]).</span><span class="s1">reshape</span><span class="s2">(-</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">)</span>
    <span class="s4"># the gradient values will force a split on nan situation</span>
    <span class="s1">gradients </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">100</span><span class="s2">, </span><span class="s3">100</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">G_H_DTYPE</span><span class="s2">)</span>
    <span class="s1">hessians </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">(</span><span class="s1">shape</span><span class="s2">=</span><span class="s3">1</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">G_H_DTYPE</span><span class="s2">)</span>

    <span class="s1">bin_mapper </span><span class="s2">= </span><span class="s1">_BinMapper</span><span class="s2">()</span>
    <span class="s1">X_binned </span><span class="s2">= </span><span class="s1">bin_mapper</span><span class="s2">.</span><span class="s1">fit_transform</span><span class="s2">(</span><span class="s1">X</span><span class="s2">)</span>

    <span class="s1">n_bins_non_missing </span><span class="s2">= </span><span class="s3">3</span>
    <span class="s1">has_missing_values </span><span class="s2">= </span><span class="s0">True</span>
    <span class="s1">grower </span><span class="s2">= </span><span class="s1">TreeGrower</span><span class="s2">(</span>
        <span class="s1">X_binned</span><span class="s2">,</span>
        <span class="s1">gradients</span><span class="s2">,</span>
        <span class="s1">hessians</span><span class="s2">,</span>
        <span class="s1">n_bins_non_missing</span><span class="s2">=</span><span class="s1">n_bins_non_missing</span><span class="s2">,</span>
        <span class="s1">has_missing_values</span><span class="s2">=</span><span class="s1">has_missing_values</span><span class="s2">,</span>
        <span class="s1">min_samples_leaf</span><span class="s2">=</span><span class="s3">1</span><span class="s2">,</span>
        <span class="s1">n_threads</span><span class="s2">=</span><span class="s1">n_threads</span><span class="s2">,</span>
    <span class="s2">)</span>

    <span class="s1">grower</span><span class="s2">.</span><span class="s1">grow</span><span class="s2">()</span>

    <span class="s1">predictor </span><span class="s2">= </span><span class="s1">grower</span><span class="s2">.</span><span class="s1">make_predictor</span><span class="s2">(</span><span class="s1">binning_thresholds</span><span class="s2">=</span><span class="s1">bin_mapper</span><span class="s2">.</span><span class="s1">bin_thresholds_</span><span class="s2">)</span>

    <span class="s4"># sanity check: this was a split on nan</span>
    <span class="s0">assert </span><span class="s1">predictor</span><span class="s2">.</span><span class="s1">nodes</span><span class="s2">[</span><span class="s3">0</span><span class="s2">][</span><span class="s6">&quot;num_threshold&quot;</span><span class="s2">] == </span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span>
    <span class="s0">assert </span><span class="s1">predictor</span><span class="s2">.</span><span class="s1">nodes</span><span class="s2">[</span><span class="s3">0</span><span class="s2">][</span><span class="s6">&quot;bin_threshold&quot;</span><span class="s2">] == </span><span class="s1">n_bins_non_missing </span><span class="s2">- </span><span class="s3">1</span>

    <span class="s1">known_cat_bitsets</span><span class="s2">, </span><span class="s1">f_idx_map </span><span class="s2">= </span><span class="s1">bin_mapper</span><span class="s2">.</span><span class="s1">make_known_categories_bitsets</span><span class="s2">()</span>

    <span class="s4"># Make sure in particular that the +inf sample is mapped to the left child</span>
    <span class="s4"># Note that lightgbm &quot;fails&quot; here and will assign the inf sample to the</span>
    <span class="s4"># right child, even though it's a &quot;split on nan&quot; situation.</span>
    <span class="s1">predictions </span><span class="s2">= </span><span class="s1">predictor</span><span class="s2">.</span><span class="s1">predict</span><span class="s2">(</span><span class="s1">X</span><span class="s2">, </span><span class="s1">known_cat_bitsets</span><span class="s2">, </span><span class="s1">f_idx_map</span><span class="s2">, </span><span class="s1">n_threads</span><span class="s2">)</span>
    <span class="s1">predictions_binned </span><span class="s2">= </span><span class="s1">predictor</span><span class="s2">.</span><span class="s1">predict_binned</span><span class="s2">(</span>
        <span class="s1">X_binned</span><span class="s2">,</span>
        <span class="s1">missing_values_bin_idx</span><span class="s2">=</span><span class="s1">bin_mapper</span><span class="s2">.</span><span class="s1">missing_values_bin_idx_</span><span class="s2">,</span>
        <span class="s1">n_threads</span><span class="s2">=</span><span class="s1">n_threads</span><span class="s2">,</span>
    <span class="s2">)</span>
    <span class="s1">np</span><span class="s2">.</span><span class="s1">testing</span><span class="s2">.</span><span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">predictions</span><span class="s2">, -</span><span class="s1">gradients</span><span class="s2">)</span>
    <span class="s1">np</span><span class="s2">.</span><span class="s1">testing</span><span class="s2">.</span><span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">predictions_binned</span><span class="s2">, -</span><span class="s1">gradients</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">test_grow_tree_categories</span><span class="s2">():</span>
    <span class="s4"># Check that the grower produces the right predictor tree when a split is</span>
    <span class="s4"># categorical</span>
    <span class="s1">X_binned </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">] * </span><span class="s3">11 </span><span class="s2">+ [</span><span class="s3">1</span><span class="s2">]], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">X_BINNED_DTYPE</span><span class="s2">).</span><span class="s1">T</span>
    <span class="s1">X_binned </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asfortranarray</span><span class="s2">(</span><span class="s1">X_binned</span><span class="s2">)</span>

    <span class="s1">all_gradients </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s3">10</span><span class="s2">, </span><span class="s3">1</span><span class="s2">] * </span><span class="s3">11 </span><span class="s2">+ [</span><span class="s3">1</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">G_H_DTYPE</span><span class="s2">)</span>
    <span class="s1">all_hessians </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">(</span><span class="s3">1</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">G_H_DTYPE</span><span class="s2">)</span>
    <span class="s1">is_categorical </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">(</span><span class="s3">1</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">uint8</span><span class="s2">)</span>

    <span class="s1">grower </span><span class="s2">= </span><span class="s1">TreeGrower</span><span class="s2">(</span>
        <span class="s1">X_binned</span><span class="s2">,</span>
        <span class="s1">all_gradients</span><span class="s2">,</span>
        <span class="s1">all_hessians</span><span class="s2">,</span>
        <span class="s1">n_bins</span><span class="s2">=</span><span class="s3">4</span><span class="s2">,</span>
        <span class="s1">shrinkage</span><span class="s2">=</span><span class="s3">1.0</span><span class="s2">,</span>
        <span class="s1">min_samples_leaf</span><span class="s2">=</span><span class="s3">1</span><span class="s2">,</span>
        <span class="s1">is_categorical</span><span class="s2">=</span><span class="s1">is_categorical</span><span class="s2">,</span>
        <span class="s1">n_threads</span><span class="s2">=</span><span class="s1">n_threads</span><span class="s2">,</span>
    <span class="s2">)</span>
    <span class="s1">grower</span><span class="s2">.</span><span class="s1">grow</span><span class="s2">()</span>
    <span class="s0">assert </span><span class="s1">grower</span><span class="s2">.</span><span class="s1">n_nodes </span><span class="s2">== </span><span class="s3">3</span>

    <span class="s1">categories </span><span class="s2">= [</span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s3">4</span><span class="s2">, </span><span class="s3">9</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">X_DTYPE</span><span class="s2">)]</span>
    <span class="s1">predictor </span><span class="s2">= </span><span class="s1">grower</span><span class="s2">.</span><span class="s1">make_predictor</span><span class="s2">(</span><span class="s1">binning_thresholds</span><span class="s2">=</span><span class="s1">categories</span><span class="s2">)</span>
    <span class="s1">root </span><span class="s2">= </span><span class="s1">predictor</span><span class="s2">.</span><span class="s1">nodes</span><span class="s2">[</span><span class="s3">0</span><span class="s2">]</span>
    <span class="s0">assert </span><span class="s1">root</span><span class="s2">[</span><span class="s6">&quot;count&quot;</span><span class="s2">] == </span><span class="s3">23</span>
    <span class="s0">assert </span><span class="s1">root</span><span class="s2">[</span><span class="s6">&quot;depth&quot;</span><span class="s2">] == </span><span class="s3">0</span>
    <span class="s0">assert </span><span class="s1">root</span><span class="s2">[</span><span class="s6">&quot;is_categorical&quot;</span><span class="s2">]</span>

    <span class="s1">left</span><span class="s2">, </span><span class="s1">right </span><span class="s2">= </span><span class="s1">predictor</span><span class="s2">.</span><span class="s1">nodes</span><span class="s2">[</span><span class="s1">root</span><span class="s2">[</span><span class="s6">&quot;left&quot;</span><span class="s2">]], </span><span class="s1">predictor</span><span class="s2">.</span><span class="s1">nodes</span><span class="s2">[</span><span class="s1">root</span><span class="s2">[</span><span class="s6">&quot;right&quot;</span><span class="s2">]]</span>

    <span class="s4"># arbitrary validation, but this means ones go to the left.</span>
    <span class="s0">assert </span><span class="s1">left</span><span class="s2">[</span><span class="s6">&quot;count&quot;</span><span class="s2">] &gt;= </span><span class="s1">right</span><span class="s2">[</span><span class="s6">&quot;count&quot;</span><span class="s2">]</span>

    <span class="s4"># check binned category value (1)</span>
    <span class="s1">expected_binned_cat_bitset </span><span class="s2">= [</span><span class="s3">2</span><span class="s2">**</span><span class="s3">1</span><span class="s2">] + [</span><span class="s3">0</span><span class="s2">] * </span><span class="s3">7</span>
    <span class="s1">binned_cat_bitset </span><span class="s2">= </span><span class="s1">predictor</span><span class="s2">.</span><span class="s1">binned_left_cat_bitsets</span>
    <span class="s1">assert_array_equal</span><span class="s2">(</span><span class="s1">binned_cat_bitset</span><span class="s2">[</span><span class="s3">0</span><span class="s2">], </span><span class="s1">expected_binned_cat_bitset</span><span class="s2">)</span>

    <span class="s4"># check raw category value (9)</span>
    <span class="s1">expected_raw_cat_bitsets </span><span class="s2">= [</span><span class="s3">2</span><span class="s2">**</span><span class="s3">9</span><span class="s2">] + [</span><span class="s3">0</span><span class="s2">] * </span><span class="s3">7</span>
    <span class="s1">raw_cat_bitsets </span><span class="s2">= </span><span class="s1">predictor</span><span class="s2">.</span><span class="s1">raw_left_cat_bitsets</span>
    <span class="s1">assert_array_equal</span><span class="s2">(</span><span class="s1">raw_cat_bitsets</span><span class="s2">[</span><span class="s3">0</span><span class="s2">], </span><span class="s1">expected_raw_cat_bitsets</span><span class="s2">)</span>

    <span class="s4"># Note that since there was no missing values during training, the missing</span>
    <span class="s4"># values aren't part of the bitsets. However, we expect the missing values</span>
    <span class="s4"># to go to the biggest child (i.e. the left one).</span>
    <span class="s4"># The left child has a value of -1 = negative gradient.</span>
    <span class="s0">assert </span><span class="s1">root</span><span class="s2">[</span><span class="s6">&quot;missing_go_to_left&quot;</span><span class="s2">]</span>

    <span class="s4"># make sure binned missing values are mapped to the left child during</span>
    <span class="s4"># prediction</span>
    <span class="s1">prediction_binned </span><span class="s2">= </span><span class="s1">predictor</span><span class="s2">.</span><span class="s1">predict_binned</span><span class="s2">(</span>
        <span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">([[</span><span class="s3">6</span><span class="s2">]]).</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">X_BINNED_DTYPE</span><span class="s2">),</span>
        <span class="s1">missing_values_bin_idx</span><span class="s2">=</span><span class="s3">6</span><span class="s2">,</span>
        <span class="s1">n_threads</span><span class="s2">=</span><span class="s1">n_threads</span><span class="s2">,</span>
    <span class="s2">)</span>
    <span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">prediction_binned</span><span class="s2">, [-</span><span class="s3">1</span><span class="s2">])  </span><span class="s4"># negative gradient</span>

    <span class="s4"># make sure raw missing values are mapped to the left child during</span>
    <span class="s4"># prediction</span>
    <span class="s1">known_cat_bitsets </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">((</span><span class="s3">1</span><span class="s2">, </span><span class="s3">8</span><span class="s2">), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">uint32</span><span class="s2">)  </span><span class="s4"># ignored anyway</span>
    <span class="s1">f_idx_map </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s3">0</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">uint32</span><span class="s2">)</span>
    <span class="s1">prediction </span><span class="s2">= </span><span class="s1">predictor</span><span class="s2">.</span><span class="s1">predict</span><span class="s2">(</span>
        <span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([[</span><span class="s1">np</span><span class="s2">.</span><span class="s1">nan</span><span class="s2">]]), </span><span class="s1">known_cat_bitsets</span><span class="s2">, </span><span class="s1">f_idx_map</span><span class="s2">, </span><span class="s1">n_threads</span>
    <span class="s2">)</span>
    <span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">prediction</span><span class="s2">, [-</span><span class="s3">1</span><span class="s2">])</span>


<span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">parametrize</span><span class="s2">(</span><span class="s6">&quot;min_samples_leaf&quot;</span><span class="s2">, (</span><span class="s3">1</span><span class="s2">, </span><span class="s3">20</span><span class="s2">))</span>
<span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">parametrize</span><span class="s2">(</span><span class="s6">&quot;n_unique_categories&quot;</span><span class="s2">, (</span><span class="s3">2</span><span class="s2">, </span><span class="s3">10</span><span class="s2">, </span><span class="s3">100</span><span class="s2">))</span>
<span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">parametrize</span><span class="s2">(</span><span class="s6">&quot;target&quot;</span><span class="s2">, (</span><span class="s6">&quot;binary&quot;</span><span class="s2">, </span><span class="s6">&quot;random&quot;</span><span class="s2">, </span><span class="s6">&quot;equal&quot;</span><span class="s2">))</span>
<span class="s0">def </span><span class="s1">test_ohe_equivalence</span><span class="s2">(</span><span class="s1">min_samples_leaf</span><span class="s2">, </span><span class="s1">n_unique_categories</span><span class="s2">, </span><span class="s1">target</span><span class="s2">):</span>
    <span class="s4"># Make sure that native categorical splits are equivalent to using a OHE,</span>
    <span class="s4"># when given enough depth</span>

    <span class="s1">rng </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">random</span><span class="s2">.</span><span class="s1">RandomState</span><span class="s2">(</span><span class="s3">0</span><span class="s2">)</span>
    <span class="s1">n_samples </span><span class="s2">= </span><span class="s3">10_000</span>
    <span class="s1">X_binned </span><span class="s2">= </span><span class="s1">rng</span><span class="s2">.</span><span class="s1">randint</span><span class="s2">(</span><span class="s3">0</span><span class="s2">, </span><span class="s1">n_unique_categories</span><span class="s2">, </span><span class="s1">size</span><span class="s2">=(</span><span class="s1">n_samples</span><span class="s2">, </span><span class="s3">1</span><span class="s2">), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">uint8</span><span class="s2">)</span>

    <span class="s1">X_ohe </span><span class="s2">= </span><span class="s1">OneHotEncoder</span><span class="s2">(</span><span class="s1">sparse_output</span><span class="s2">=</span><span class="s0">False</span><span class="s2">).</span><span class="s1">fit_transform</span><span class="s2">(</span><span class="s1">X_binned</span><span class="s2">)</span>
    <span class="s1">X_ohe </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asfortranarray</span><span class="s2">(</span><span class="s1">X_ohe</span><span class="s2">).</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">uint8</span><span class="s2">)</span>

    <span class="s0">if </span><span class="s1">target </span><span class="s2">== </span><span class="s6">&quot;equal&quot;</span><span class="s2">:</span>
        <span class="s1">gradients </span><span class="s2">= </span><span class="s1">X_binned</span><span class="s2">.</span><span class="s1">reshape</span><span class="s2">(-</span><span class="s3">1</span><span class="s2">)</span>
    <span class="s0">elif </span><span class="s1">target </span><span class="s2">== </span><span class="s6">&quot;binary&quot;</span><span class="s2">:</span>
        <span class="s1">gradients </span><span class="s2">= (</span><span class="s1">X_binned </span><span class="s2">% </span><span class="s3">2</span><span class="s2">).</span><span class="s1">reshape</span><span class="s2">(-</span><span class="s3">1</span><span class="s2">)</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">gradients </span><span class="s2">= </span><span class="s1">rng</span><span class="s2">.</span><span class="s1">randn</span><span class="s2">(</span><span class="s1">n_samples</span><span class="s2">)</span>
    <span class="s1">gradients </span><span class="s2">= </span><span class="s1">gradients</span><span class="s2">.</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">G_H_DTYPE</span><span class="s2">)</span>

    <span class="s1">hessians </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">(</span><span class="s1">shape</span><span class="s2">=</span><span class="s3">1</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">G_H_DTYPE</span><span class="s2">)</span>

    <span class="s1">grower_params </span><span class="s2">= {</span>
        <span class="s6">&quot;min_samples_leaf&quot;</span><span class="s2">: </span><span class="s1">min_samples_leaf</span><span class="s2">,</span>
        <span class="s6">&quot;max_depth&quot;</span><span class="s2">: </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s6">&quot;max_leaf_nodes&quot;</span><span class="s2">: </span><span class="s0">None</span><span class="s2">,</span>
    <span class="s2">}</span>

    <span class="s1">grower </span><span class="s2">= </span><span class="s1">TreeGrower</span><span class="s2">(</span>
        <span class="s1">X_binned</span><span class="s2">, </span><span class="s1">gradients</span><span class="s2">, </span><span class="s1">hessians</span><span class="s2">, </span><span class="s1">is_categorical</span><span class="s2">=[</span><span class="s0">True</span><span class="s2">], **</span><span class="s1">grower_params</span>
    <span class="s2">)</span>
    <span class="s1">grower</span><span class="s2">.</span><span class="s1">grow</span><span class="s2">()</span>
    <span class="s4"># we pass undefined bin_thresholds because we won't use predict()</span>
    <span class="s1">predictor </span><span class="s2">= </span><span class="s1">grower</span><span class="s2">.</span><span class="s1">make_predictor</span><span class="s2">(</span>
        <span class="s1">binning_thresholds</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">((</span><span class="s3">1</span><span class="s2">, </span><span class="s1">n_unique_categories</span><span class="s2">))</span>
    <span class="s2">)</span>
    <span class="s1">preds </span><span class="s2">= </span><span class="s1">predictor</span><span class="s2">.</span><span class="s1">predict_binned</span><span class="s2">(</span>
        <span class="s1">X_binned</span><span class="s2">, </span><span class="s1">missing_values_bin_idx</span><span class="s2">=</span><span class="s3">255</span><span class="s2">, </span><span class="s1">n_threads</span><span class="s2">=</span><span class="s1">n_threads</span>
    <span class="s2">)</span>

    <span class="s1">grower_ohe </span><span class="s2">= </span><span class="s1">TreeGrower</span><span class="s2">(</span><span class="s1">X_ohe</span><span class="s2">, </span><span class="s1">gradients</span><span class="s2">, </span><span class="s1">hessians</span><span class="s2">, **</span><span class="s1">grower_params</span><span class="s2">)</span>
    <span class="s1">grower_ohe</span><span class="s2">.</span><span class="s1">grow</span><span class="s2">()</span>
    <span class="s1">predictor_ohe </span><span class="s2">= </span><span class="s1">grower_ohe</span><span class="s2">.</span><span class="s1">make_predictor</span><span class="s2">(</span>
        <span class="s1">binning_thresholds</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">((</span><span class="s1">X_ohe</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s3">1</span><span class="s2">], </span><span class="s1">n_unique_categories</span><span class="s2">))</span>
    <span class="s2">)</span>
    <span class="s1">preds_ohe </span><span class="s2">= </span><span class="s1">predictor_ohe</span><span class="s2">.</span><span class="s1">predict_binned</span><span class="s2">(</span>
        <span class="s1">X_ohe</span><span class="s2">, </span><span class="s1">missing_values_bin_idx</span><span class="s2">=</span><span class="s3">255</span><span class="s2">, </span><span class="s1">n_threads</span><span class="s2">=</span><span class="s1">n_threads</span>
    <span class="s2">)</span>

    <span class="s0">assert </span><span class="s1">predictor</span><span class="s2">.</span><span class="s1">get_max_depth</span><span class="s2">() &lt;= </span><span class="s1">predictor_ohe</span><span class="s2">.</span><span class="s1">get_max_depth</span><span class="s2">()</span>
    <span class="s0">if </span><span class="s1">target </span><span class="s2">== </span><span class="s6">&quot;binary&quot; </span><span class="s0">and </span><span class="s1">n_unique_categories </span><span class="s2">&gt; </span><span class="s3">2</span><span class="s2">:</span>
        <span class="s4"># OHE needs more splits to achieve the same predictions</span>
        <span class="s0">assert </span><span class="s1">predictor</span><span class="s2">.</span><span class="s1">get_max_depth</span><span class="s2">() &lt; </span><span class="s1">predictor_ohe</span><span class="s2">.</span><span class="s1">get_max_depth</span><span class="s2">()</span>

    <span class="s1">np</span><span class="s2">.</span><span class="s1">testing</span><span class="s2">.</span><span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">preds</span><span class="s2">, </span><span class="s1">preds_ohe</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">test_grower_interaction_constraints</span><span class="s2">():</span>
    <span class="s5">&quot;&quot;&quot;Check that grower respects interaction constraints.&quot;&quot;&quot;</span>
    <span class="s1">n_features </span><span class="s2">= </span><span class="s3">6</span>
    <span class="s1">interaction_cst </span><span class="s2">= [{</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">}, {</span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">}, {</span><span class="s3">3</span><span class="s2">, </span><span class="s3">4</span><span class="s2">, </span><span class="s3">5</span><span class="s2">}]</span>
    <span class="s1">n_samples </span><span class="s2">= </span><span class="s3">10</span>
    <span class="s1">n_bins </span><span class="s2">= </span><span class="s3">6</span>
    <span class="s1">root_feature_splits </span><span class="s2">= []</span>

    <span class="s0">def </span><span class="s1">get_all_children</span><span class="s2">(</span><span class="s1">node</span><span class="s2">):</span>
        <span class="s1">res </span><span class="s2">= []</span>
        <span class="s0">if </span><span class="s1">node</span><span class="s2">.</span><span class="s1">is_leaf</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">res</span>
        <span class="s0">for </span><span class="s1">n </span><span class="s0">in </span><span class="s2">[</span><span class="s1">node</span><span class="s2">.</span><span class="s1">left_child</span><span class="s2">, </span><span class="s1">node</span><span class="s2">.</span><span class="s1">right_child</span><span class="s2">]:</span>
            <span class="s1">res</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">n</span><span class="s2">)</span>
            <span class="s1">res</span><span class="s2">.</span><span class="s1">extend</span><span class="s2">(</span><span class="s1">get_all_children</span><span class="s2">(</span><span class="s1">n</span><span class="s2">))</span>
        <span class="s0">return </span><span class="s1">res</span>

    <span class="s0">for </span><span class="s1">seed </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s3">20</span><span class="s2">):</span>
        <span class="s1">rng </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">random</span><span class="s2">.</span><span class="s1">RandomState</span><span class="s2">(</span><span class="s1">seed</span><span class="s2">)</span>

        <span class="s1">X_binned </span><span class="s2">= </span><span class="s1">rng</span><span class="s2">.</span><span class="s1">randint</span><span class="s2">(</span>
            <span class="s3">0</span><span class="s2">, </span><span class="s1">n_bins </span><span class="s2">- </span><span class="s3">1</span><span class="s2">, </span><span class="s1">size</span><span class="s2">=(</span><span class="s1">n_samples</span><span class="s2">, </span><span class="s1">n_features</span><span class="s2">), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">X_BINNED_DTYPE</span>
        <span class="s2">)</span>
        <span class="s1">X_binned </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asfortranarray</span><span class="s2">(</span><span class="s1">X_binned</span><span class="s2">)</span>
        <span class="s1">gradients </span><span class="s2">= </span><span class="s1">rng</span><span class="s2">.</span><span class="s1">normal</span><span class="s2">(</span><span class="s1">size</span><span class="s2">=</span><span class="s1">n_samples</span><span class="s2">).</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">G_H_DTYPE</span><span class="s2">)</span>
        <span class="s1">hessians </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">(</span><span class="s1">shape</span><span class="s2">=</span><span class="s3">1</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">G_H_DTYPE</span><span class="s2">)</span>

        <span class="s1">grower </span><span class="s2">= </span><span class="s1">TreeGrower</span><span class="s2">(</span>
            <span class="s1">X_binned</span><span class="s2">,</span>
            <span class="s1">gradients</span><span class="s2">,</span>
            <span class="s1">hessians</span><span class="s2">,</span>
            <span class="s1">n_bins</span><span class="s2">=</span><span class="s1">n_bins</span><span class="s2">,</span>
            <span class="s1">min_samples_leaf</span><span class="s2">=</span><span class="s3">1</span><span class="s2">,</span>
            <span class="s1">interaction_cst</span><span class="s2">=</span><span class="s1">interaction_cst</span><span class="s2">,</span>
            <span class="s1">n_threads</span><span class="s2">=</span><span class="s1">n_threads</span><span class="s2">,</span>
        <span class="s2">)</span>
        <span class="s1">grower</span><span class="s2">.</span><span class="s1">grow</span><span class="s2">()</span>

        <span class="s1">root_feature_idx </span><span class="s2">= </span><span class="s1">grower</span><span class="s2">.</span><span class="s1">root</span><span class="s2">.</span><span class="s1">split_info</span><span class="s2">.</span><span class="s1">feature_idx</span>
        <span class="s1">root_feature_splits</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">root_feature_idx</span><span class="s2">)</span>

        <span class="s1">feature_idx_to_constraint_set </span><span class="s2">= {</span>
            <span class="s3">0</span><span class="s2">: {</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">},</span>
            <span class="s3">1</span><span class="s2">: {</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">},</span>
            <span class="s3">2</span><span class="s2">: {</span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">},</span>
            <span class="s3">3</span><span class="s2">: {</span><span class="s3">3</span><span class="s2">, </span><span class="s3">4</span><span class="s2">, </span><span class="s3">5</span><span class="s2">},</span>
            <span class="s3">4</span><span class="s2">: {</span><span class="s3">3</span><span class="s2">, </span><span class="s3">4</span><span class="s2">, </span><span class="s3">5</span><span class="s2">},</span>
            <span class="s3">5</span><span class="s2">: {</span><span class="s3">3</span><span class="s2">, </span><span class="s3">4</span><span class="s2">, </span><span class="s3">5</span><span class="s2">},</span>
        <span class="s2">}</span>

        <span class="s1">root_constraint_set </span><span class="s2">= </span><span class="s1">feature_idx_to_constraint_set</span><span class="s2">[</span><span class="s1">root_feature_idx</span><span class="s2">]</span>
        <span class="s0">for </span><span class="s1">node </span><span class="s0">in </span><span class="s2">(</span><span class="s1">grower</span><span class="s2">.</span><span class="s1">root</span><span class="s2">.</span><span class="s1">left_child</span><span class="s2">, </span><span class="s1">grower</span><span class="s2">.</span><span class="s1">root</span><span class="s2">.</span><span class="s1">right_child</span><span class="s2">):</span>
            <span class="s4"># Root's children's allowed_features must be the root's constraints set.</span>
            <span class="s1">assert_array_equal</span><span class="s2">(</span><span class="s1">node</span><span class="s2">.</span><span class="s1">allowed_features</span><span class="s2">, </span><span class="s1">list</span><span class="s2">(</span><span class="s1">root_constraint_set</span><span class="s2">))</span>
        <span class="s0">for </span><span class="s1">node </span><span class="s0">in </span><span class="s1">get_all_children</span><span class="s2">(</span><span class="s1">grower</span><span class="s2">.</span><span class="s1">root</span><span class="s2">):</span>
            <span class="s0">if </span><span class="s1">node</span><span class="s2">.</span><span class="s1">is_leaf</span><span class="s2">:</span>
                <span class="s0">continue</span>
            <span class="s4"># Ensure that each node uses a subset of features of its parent node.</span>
            <span class="s1">parent_interaction_cst_indices </span><span class="s2">= </span><span class="s1">set</span><span class="s2">(</span><span class="s1">node</span><span class="s2">.</span><span class="s1">interaction_cst_indices</span><span class="s2">)</span>
            <span class="s1">right_interactions_cst_indices </span><span class="s2">= </span><span class="s1">set</span><span class="s2">(</span>
                <span class="s1">node</span><span class="s2">.</span><span class="s1">right_child</span><span class="s2">.</span><span class="s1">interaction_cst_indices</span>
            <span class="s2">)</span>
            <span class="s1">left_interactions_cst_indices </span><span class="s2">= </span><span class="s1">set</span><span class="s2">(</span><span class="s1">node</span><span class="s2">.</span><span class="s1">left_child</span><span class="s2">.</span><span class="s1">interaction_cst_indices</span><span class="s2">)</span>

            <span class="s0">assert </span><span class="s1">right_interactions_cst_indices</span><span class="s2">.</span><span class="s1">issubset</span><span class="s2">(</span>
                <span class="s1">parent_interaction_cst_indices</span>
            <span class="s2">)</span>
            <span class="s0">assert </span><span class="s1">left_interactions_cst_indices</span><span class="s2">.</span><span class="s1">issubset</span><span class="s2">(</span>
                <span class="s1">parent_interaction_cst_indices</span>
            <span class="s2">)</span>
            <span class="s4"># The features used for split must have been present in the root's</span>
            <span class="s4"># constraint set.</span>
            <span class="s0">assert </span><span class="s1">node</span><span class="s2">.</span><span class="s1">split_info</span><span class="s2">.</span><span class="s1">feature_idx </span><span class="s0">in </span><span class="s1">root_constraint_set</span>

    <span class="s4"># Make sure that every feature is used at least once as split for the root node.</span>
    <span class="s0">assert </span><span class="s2">(</span>
        <span class="s1">len</span><span class="s2">(</span><span class="s1">set</span><span class="s2">(</span><span class="s1">root_feature_splits</span><span class="s2">))</span>
        <span class="s2">== </span><span class="s1">len</span><span class="s2">(</span><span class="s1">set</span><span class="s2">().</span><span class="s1">union</span><span class="s2">(*</span><span class="s1">interaction_cst</span><span class="s2">))</span>
        <span class="s2">== </span><span class="s1">n_features</span>
    <span class="s2">)</span>
</pre>
</body>
</html>