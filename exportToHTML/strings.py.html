<html>
<head>
<title>strings.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #7a7e85;}
.s5 { color: #6aab73;}
.s6 { color: #2aacb8;}
.s7 { color: #a5c261;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
strings.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
This module contains a set of functions for vectorized string 
operations. 
&quot;&quot;&quot;</span>

<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">from </span><span class="s1">numpy </span><span class="s2">import </span><span class="s3">(</span>
    <span class="s1">equal</span><span class="s3">, </span><span class="s1">not_equal</span><span class="s3">, </span><span class="s1">less</span><span class="s3">, </span><span class="s1">less_equal</span><span class="s3">, </span><span class="s1">greater</span><span class="s3">, </span><span class="s1">greater_equal</span><span class="s3">,</span>
    <span class="s1">add</span><span class="s3">, </span><span class="s1">multiply </span><span class="s2">as </span><span class="s1">_multiply_ufunc</span><span class="s3">,</span>
<span class="s3">)</span>
<span class="s2">from </span><span class="s1">numpy</span><span class="s3">.</span><span class="s1">_core</span><span class="s3">.</span><span class="s1">multiarray </span><span class="s2">import </span><span class="s1">_vec_string</span>
<span class="s2">from </span><span class="s1">numpy</span><span class="s3">.</span><span class="s1">_core</span><span class="s3">.</span><span class="s1">umath </span><span class="s2">import </span><span class="s3">(</span>
    <span class="s1">isalpha</span><span class="s3">,</span>
    <span class="s1">isdigit</span><span class="s3">,</span>
    <span class="s1">isspace</span><span class="s3">,</span>
    <span class="s1">isalnum</span><span class="s3">,</span>
    <span class="s1">islower</span><span class="s3">,</span>
    <span class="s1">isupper</span><span class="s3">,</span>
    <span class="s1">istitle</span><span class="s3">,</span>
    <span class="s1">isdecimal</span><span class="s3">,</span>
    <span class="s1">isnumeric</span><span class="s3">,</span>
    <span class="s1">str_len</span><span class="s3">,</span>
    <span class="s1">find </span><span class="s2">as </span><span class="s1">_find_ufunc</span><span class="s3">,</span>
    <span class="s1">rfind </span><span class="s2">as </span><span class="s1">_rfind_ufunc</span><span class="s3">,</span>
    <span class="s1">index </span><span class="s2">as </span><span class="s1">_index_ufunc</span><span class="s3">,</span>
    <span class="s1">rindex </span><span class="s2">as </span><span class="s1">_rindex_ufunc</span><span class="s3">,</span>
    <span class="s1">count </span><span class="s2">as </span><span class="s1">_count_ufunc</span><span class="s3">,</span>
    <span class="s1">startswith </span><span class="s2">as </span><span class="s1">_startswith_ufunc</span><span class="s3">,</span>
    <span class="s1">endswith </span><span class="s2">as </span><span class="s1">_endswith_ufunc</span><span class="s3">,</span>
    <span class="s1">_lstrip_whitespace</span><span class="s3">,</span>
    <span class="s1">_lstrip_chars</span><span class="s3">,</span>
    <span class="s1">_rstrip_whitespace</span><span class="s3">,</span>
    <span class="s1">_rstrip_chars</span><span class="s3">,</span>
    <span class="s1">_strip_whitespace</span><span class="s3">,</span>
    <span class="s1">_strip_chars</span><span class="s3">,</span>
    <span class="s1">_replace</span><span class="s3">,</span>
    <span class="s1">_expandtabs_length</span><span class="s3">,</span>
    <span class="s1">_expandtabs</span><span class="s3">,</span>
    <span class="s1">_center</span><span class="s3">,</span>
    <span class="s1">_ljust</span><span class="s3">,</span>
    <span class="s1">_rjust</span><span class="s3">,</span>
    <span class="s1">_zfill</span><span class="s3">,</span>
    <span class="s1">_partition</span><span class="s3">,</span>
    <span class="s1">_partition_index</span><span class="s3">,</span>
    <span class="s1">_rpartition</span><span class="s3">,</span>
    <span class="s1">_rpartition_index</span><span class="s3">,</span>
<span class="s3">)</span>


<span class="s1">__all__ </span><span class="s3">= [</span>
    <span class="s4"># UFuncs</span>
    <span class="s5">&quot;equal&quot;</span><span class="s3">, </span><span class="s5">&quot;not_equal&quot;</span><span class="s3">, </span><span class="s5">&quot;less&quot;</span><span class="s3">, </span><span class="s5">&quot;less_equal&quot;</span><span class="s3">, </span><span class="s5">&quot;greater&quot;</span><span class="s3">, </span><span class="s5">&quot;greater_equal&quot;</span><span class="s3">,</span>
    <span class="s5">&quot;add&quot;</span><span class="s3">, </span><span class="s5">&quot;multiply&quot;</span><span class="s3">, </span><span class="s5">&quot;isalpha&quot;</span><span class="s3">, </span><span class="s5">&quot;isdigit&quot;</span><span class="s3">, </span><span class="s5">&quot;isspace&quot;</span><span class="s3">, </span><span class="s5">&quot;isalnum&quot;</span><span class="s3">, </span><span class="s5">&quot;islower&quot;</span><span class="s3">,</span>
    <span class="s5">&quot;isupper&quot;</span><span class="s3">, </span><span class="s5">&quot;istitle&quot;</span><span class="s3">, </span><span class="s5">&quot;isdecimal&quot;</span><span class="s3">, </span><span class="s5">&quot;isnumeric&quot;</span><span class="s3">, </span><span class="s5">&quot;str_len&quot;</span><span class="s3">, </span><span class="s5">&quot;find&quot;</span><span class="s3">,</span>
    <span class="s5">&quot;rfind&quot;</span><span class="s3">, </span><span class="s5">&quot;index&quot;</span><span class="s3">, </span><span class="s5">&quot;rindex&quot;</span><span class="s3">, </span><span class="s5">&quot;count&quot;</span><span class="s3">, </span><span class="s5">&quot;startswith&quot;</span><span class="s3">, </span><span class="s5">&quot;endswith&quot;</span><span class="s3">, </span><span class="s5">&quot;lstrip&quot;</span><span class="s3">,</span>
    <span class="s5">&quot;rstrip&quot;</span><span class="s3">, </span><span class="s5">&quot;strip&quot;</span><span class="s3">, </span><span class="s5">&quot;replace&quot;</span><span class="s3">, </span><span class="s5">&quot;expandtabs&quot;</span><span class="s3">, </span><span class="s5">&quot;center&quot;</span><span class="s3">, </span><span class="s5">&quot;ljust&quot;</span><span class="s3">, </span><span class="s5">&quot;rjust&quot;</span><span class="s3">,</span>
    <span class="s5">&quot;zfill&quot;</span><span class="s3">, </span><span class="s5">&quot;partition&quot;</span><span class="s3">, </span><span class="s5">&quot;rpartition&quot;</span><span class="s3">,</span>

    <span class="s4"># _vec_string - Will gradually become ufuncs as well</span>
    <span class="s5">&quot;upper&quot;</span><span class="s3">, </span><span class="s5">&quot;lower&quot;</span><span class="s3">, </span><span class="s5">&quot;swapcase&quot;</span><span class="s3">, </span><span class="s5">&quot;capitalize&quot;</span><span class="s3">, </span><span class="s5">&quot;title&quot;</span><span class="s3">,</span>

    <span class="s4"># _vec_string - Will probably not become ufuncs</span>
    <span class="s5">&quot;mod&quot;</span><span class="s3">, </span><span class="s5">&quot;decode&quot;</span><span class="s3">, </span><span class="s5">&quot;encode&quot;</span><span class="s3">, </span><span class="s5">&quot;translate&quot;</span><span class="s3">,</span>

    <span class="s4"># Removed from namespace until behavior has been crystallized</span>
    <span class="s4"># &quot;join&quot;, &quot;split&quot;, &quot;rsplit&quot;, &quot;splitlines&quot;,</span>
<span class="s3">]</span>


<span class="s1">MAX </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">iinfo</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">int64</span><span class="s3">).</span><span class="s1">max</span>


<span class="s2">def </span><span class="s1">_get_num_chars</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Helper function that returns the number of characters per field in 
    a string or unicode array.  This is to abstract out the fact that 
    for a unicode array this is itemsize / 4. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">issubclass</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">type</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">str_</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">a</span><span class="s3">.</span><span class="s1">itemsize </span><span class="s3">// </span><span class="s6">4</span>
    <span class="s2">return </span><span class="s1">a</span><span class="s3">.</span><span class="s1">itemsize</span>


<span class="s2">def </span><span class="s1">_to_bytes_or_str_array</span><span class="s3">(</span><span class="s1">result</span><span class="s3">, </span><span class="s1">output_dtype_like</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Helper function to cast a result back into an array 
    with the appropriate dtype if an object array must be used 
    as an intermediary. 
    &quot;&quot;&quot;</span>
    <span class="s1">output_dtype_like </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">output_dtype_like</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">result</span><span class="s3">.</span><span class="s1">size </span><span class="s3">== </span><span class="s6">0</span><span class="s3">:</span>
        <span class="s4"># Calling asarray &amp; tolist in an empty array would result</span>
        <span class="s4"># in losing shape information</span>
        <span class="s2">return </span><span class="s1">result</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">output_dtype_like</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>
    <span class="s1">ret </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">result</span><span class="s3">.</span><span class="s1">tolist</span><span class="s3">())</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">output_dtype_like</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">dtypes</span><span class="s3">.</span><span class="s1">StringDType</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">ret</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">type</span><span class="s3">(</span><span class="s1">output_dtype_like</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">))</span>
    <span class="s2">return </span><span class="s1">ret</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">type</span><span class="s3">(</span><span class="s1">output_dtype_like</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)(</span><span class="s1">_get_num_chars</span><span class="s3">(</span><span class="s1">ret</span><span class="s3">)))</span>


<span class="s2">def </span><span class="s1">_clean_args</span><span class="s3">(*</span><span class="s1">args</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Helper function for delegating arguments to Python string 
    functions. 
 
    Many of the Python string operations that have optional arguments 
    do not use 'None' to indicate a default value.  In these cases, 
    we need to remove all None arguments, and those following them. 
    &quot;&quot;&quot;</span>
    <span class="s1">newargs </span><span class="s3">= []</span>
    <span class="s2">for </span><span class="s1">chk </span><span class="s2">in </span><span class="s1">args</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">chk </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s2">break</span>
        <span class="s1">newargs</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">chk</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">newargs</span>


<span class="s2">def </span><span class="s1">multiply</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">i</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return (a * i), that is string multiple concatenation, 
    element-wise. 
 
    Values in ``i`` of less than 0 are treated as 0 (which yields an 
    empty string). 
 
    Parameters 
    ---------- 
    a : array_like, with ``StringDType``, ``bytes_`` or ``str_`` dtype 
 
    i : array_like, with any integer dtype 
 
    Returns 
    ------- 
    out : ndarray 
        Output array of ``StringDType``, ``bytes_`` or ``str_`` dtype, 
        depending on input types 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; a = np.array([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]) 
    &gt;&gt;&gt; np.strings.multiply(a, 3) 
    array(['aaa', 'bbb', 'ccc'], dtype='&lt;U3') 
    &gt;&gt;&gt; i = np.array([1, 2, 3]) 
    &gt;&gt;&gt; np.strings.multiply(a, i) 
    array(['a', 'bb', 'ccc'], dtype='&lt;U3') 
    &gt;&gt;&gt; np.strings.multiply(np.array(['a']), i) 
    array(['a', 'aa', 'aaa'], dtype='&lt;U3') 
    &gt;&gt;&gt; a = np.array(['a', 'b', 'c', 'd', 'e', 'f']).reshape((2, 3)) 
    &gt;&gt;&gt; np.strings.multiply(a, 3) 
    array([['aaa', 'bbb', 'ccc'], 
           ['ddd', 'eee', 'fff']], dtype='&lt;U3') 
    &gt;&gt;&gt; np.strings.multiply(a, i) 
    array([['a', 'bb', 'ccc'], 
           ['d', 'ee', 'fff']], dtype='&lt;U3') 
 
    &quot;&quot;&quot;</span>
    <span class="s1">a </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asanyarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>

    <span class="s1">i </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asanyarray</span><span class="s3">(</span><span class="s1">i</span><span class="s3">)</span>
    <span class="s2">if not </span><span class="s1">np</span><span class="s3">.</span><span class="s1">issubdtype</span><span class="s3">(</span><span class="s1">i</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">integer</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s5">f&quot;unsupported type </span><span class="s2">{</span><span class="s1">i</span><span class="s3">.</span><span class="s1">dtype</span><span class="s2">} </span><span class="s5">for operand 'i'&quot;</span><span class="s3">)</span>
    <span class="s1">i </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">maximum</span><span class="s3">(</span><span class="s1">i</span><span class="s3">, </span><span class="s6">0</span><span class="s3">)</span>

    <span class="s4"># delegate to stringdtype loops that also do overflow checking</span>
    <span class="s2">if </span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">char </span><span class="s3">== </span><span class="s5">&quot;T&quot;</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">a </span><span class="s3">* </span><span class="s1">i</span>

    <span class="s1">a_len </span><span class="s3">= </span><span class="s1">str_len</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>

    <span class="s4"># Ensure we can do a_len * i without overflow.</span>
    <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">any</span><span class="s3">(</span><span class="s1">a_len </span><span class="s3">&gt; </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">maxsize </span><span class="s3">/ </span><span class="s1">np</span><span class="s3">.</span><span class="s1">maximum</span><span class="s3">(</span><span class="s1">i</span><span class="s3">, </span><span class="s6">1</span><span class="s3">)):</span>
        <span class="s2">raise </span><span class="s1">MemoryError</span><span class="s3">(</span><span class="s5">&quot;repeated string is too long&quot;</span><span class="s3">)</span>

    <span class="s1">buffersizes </span><span class="s3">= </span><span class="s1">a_len </span><span class="s3">* </span><span class="s1">i</span>
    <span class="s1">out_dtype </span><span class="s3">= </span><span class="s5">f&quot;</span><span class="s2">{</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">char</span><span class="s2">}{</span><span class="s1">buffersizes</span><span class="s3">.</span><span class="s1">max</span><span class="s3">()</span><span class="s2">}</span><span class="s5">&quot;</span>
    <span class="s1">out </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty_like</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">=</span><span class="s1">buffersizes</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">out_dtype</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">_multiply_ufunc</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">i</span><span class="s3">, </span><span class="s1">out</span><span class="s3">=</span><span class="s1">out</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">mod</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">values</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return (a % i), that is pre-Python 2.6 string formatting 
    (interpolation), element-wise for a pair of array_likes of str 
    or unicode. 
 
    Parameters 
    ---------- 
    a : array_like, with `np.bytes_` or `np.str_` dtype 
 
    values : array_like of values 
       These values will be element-wise interpolated into the string. 
 
    Returns 
    ------- 
    out : ndarray 
        Output array of ``StringDType``, ``bytes_`` or ``str_`` dtype, 
        depending on input types 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; a = np.array([&quot;NumPy is a %s library&quot;]) 
    &gt;&gt;&gt; np.strings.mod(a, values=[&quot;Python&quot;]) 
    array(['NumPy is a Python library'], dtype='&lt;U25') 
 
    &gt;&gt;&gt; a = np.array([b'%d bytes', b'%d bits']) 
    &gt;&gt;&gt; values = np.array([8, 64]) 
    &gt;&gt;&gt; np.strings.mod(a, values) 
    array([b'8 bytes', b'64 bits'], dtype='|S7') 
 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_to_bytes_or_str_array</span><span class="s3">(</span>
        <span class="s1">_vec_string</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">object_</span><span class="s3">, </span><span class="s5">'__mod__'</span><span class="s3">, (</span><span class="s1">values</span><span class="s3">,)), </span><span class="s1">a</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">find</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">sub</span><span class="s3">, </span><span class="s1">start</span><span class="s3">=</span><span class="s6">0</span><span class="s3">, </span><span class="s1">end</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    For each element, return the lowest index in the string where 
    substring ``sub`` is found, such that ``sub`` is contained in the 
    range [``start``, ``end``). 
 
    Parameters 
    ---------- 
    a : array_like, with ``StringDType``, ``bytes_`` or ``str_`` dtype 
 
    sub : array_like, with `np.bytes_` or `np.str_` dtype 
        The substring to search for. 
 
    start, end : array_like, with any integer dtype 
        The range to look in, interpreted as in slice notation. 
 
    Returns 
    ------- 
    y : ndarray 
        Output array of ints 
 
    See Also 
    -------- 
    str.find 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; a = np.array([&quot;NumPy is a Python library&quot;]) 
    &gt;&gt;&gt; np.strings.find(a, &quot;Python&quot;) 
    array([11]) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">end </span><span class="s3">= </span><span class="s1">end </span><span class="s2">if </span><span class="s1">end </span><span class="s2">is not None else </span><span class="s1">MAX</span>
    <span class="s2">return </span><span class="s1">_find_ufunc</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">sub</span><span class="s3">, </span><span class="s1">start</span><span class="s3">, </span><span class="s1">end</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">rfind</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">sub</span><span class="s3">, </span><span class="s1">start</span><span class="s3">=</span><span class="s6">0</span><span class="s3">, </span><span class="s1">end</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    For each element, return the highest index in the string where 
    substring ``sub`` is found, such that ``sub`` is contained in the 
    range [``start``, ``end``). 
 
    Parameters 
    ---------- 
    a : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype 
 
    sub : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype 
        The substring to search for. 
 
    start, end : array_like, with any integer dtype 
        The range to look in, interpreted as in slice notation. 
 
    Returns 
    ------- 
    y : ndarray 
        Output array of ints 
 
    See Also 
    -------- 
    str.rfind 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; a = np.array([&quot;Computer Science&quot;]) 
    &gt;&gt;&gt; np.strings.rfind(a, &quot;Science&quot;, start=0, end=None) 
    array([9]) 
    &gt;&gt;&gt; np.strings.rfind(a, &quot;Science&quot;, start=0, end=8) 
    array([-1]) 
    &gt;&gt;&gt; b = np.array([&quot;Computer Science&quot;, &quot;Science&quot;]) 
    &gt;&gt;&gt; np.strings.rfind(b, &quot;Science&quot;, start=0, end=None) 
    array([9, 0]) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">end </span><span class="s3">= </span><span class="s1">end </span><span class="s2">if </span><span class="s1">end </span><span class="s2">is not None else </span><span class="s1">MAX</span>
    <span class="s2">return </span><span class="s1">_rfind_ufunc</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">sub</span><span class="s3">, </span><span class="s1">start</span><span class="s3">, </span><span class="s1">end</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">index</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">sub</span><span class="s3">, </span><span class="s1">start</span><span class="s3">=</span><span class="s6">0</span><span class="s3">, </span><span class="s1">end</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Like `find`, but raises :exc:`ValueError` when the substring is not found. 
 
    Parameters 
    ---------- 
    a : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype 
 
    sub : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype 
 
    start, end : array_like, with any integer dtype, optional 
 
    Returns 
    ------- 
    out : ndarray 
        Output array of ints. 
 
    See Also 
    -------- 
    find, str.index 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; a = np.array([&quot;Computer Science&quot;]) 
    &gt;&gt;&gt; np.strings.index(a, &quot;Science&quot;, start=0, end=None) 
    array([9]) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">end </span><span class="s3">= </span><span class="s1">end </span><span class="s2">if </span><span class="s1">end </span><span class="s2">is not None else </span><span class="s1">MAX</span>
    <span class="s2">return </span><span class="s1">_index_ufunc</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">sub</span><span class="s3">, </span><span class="s1">start</span><span class="s3">, </span><span class="s1">end</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">rindex</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">sub</span><span class="s3">, </span><span class="s1">start</span><span class="s3">=</span><span class="s6">0</span><span class="s3">, </span><span class="s1">end</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Like `rfind`, but raises :exc:`ValueError` when the substring `sub` is 
    not found. 
 
    Parameters 
    ---------- 
    a : array-like, with `np.bytes_` or `np.str_` dtype 
 
    sub : array-like, with `np.bytes_` or `np.str_` dtype 
 
    start, end : array-like, with any integer dtype, optional 
 
    Returns 
    ------- 
    out : ndarray 
        Output array of ints. 
 
    See Also 
    -------- 
    rfind, str.rindex 
 
    Examples 
    -------- 
    &gt;&gt;&gt; a = np.array([&quot;Computer Science&quot;]) 
    &gt;&gt;&gt; np.strings.rindex(a, &quot;Science&quot;, start=0, end=None) 
    array([9]) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">end </span><span class="s3">= </span><span class="s1">end </span><span class="s2">if </span><span class="s1">end </span><span class="s2">is not None else </span><span class="s1">MAX</span>
    <span class="s2">return </span><span class="s1">_rindex_ufunc</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">sub</span><span class="s3">, </span><span class="s1">start</span><span class="s3">, </span><span class="s1">end</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">count</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">sub</span><span class="s3">, </span><span class="s1">start</span><span class="s3">=</span><span class="s6">0</span><span class="s3">, </span><span class="s1">end</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns an array with the number of non-overlapping occurrences of 
    substring ``sub`` in the range [``start``, ``end``). 
 
    Parameters 
    ---------- 
    a : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype 
 
    sub : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype 
       The substring to search for. 
 
    start, end : array_like, with any integer dtype 
        The range to look in, interpreted as in slice notation. 
 
    Returns 
    ------- 
    y : ndarray 
        Output array of ints 
 
    See Also 
    -------- 
    str.count 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; c = np.array(['aAaAaA', '  aA  ', 'abBABba']) 
    &gt;&gt;&gt; c 
    array(['aAaAaA', '  aA  ', 'abBABba'], dtype='&lt;U7') 
    &gt;&gt;&gt; np.strings.count(c, 'A') 
    array([3, 1, 1]) 
    &gt;&gt;&gt; np.strings.count(c, 'aA') 
    array([3, 1, 0]) 
    &gt;&gt;&gt; np.strings.count(c, 'A', start=1, end=4) 
    array([2, 1, 1]) 
    &gt;&gt;&gt; np.strings.count(c, 'A', start=1, end=3) 
    array([1, 0, 0]) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">end </span><span class="s3">= </span><span class="s1">end </span><span class="s2">if </span><span class="s1">end </span><span class="s2">is not None else </span><span class="s1">MAX</span>
    <span class="s2">return </span><span class="s1">_count_ufunc</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">sub</span><span class="s3">, </span><span class="s1">start</span><span class="s3">, </span><span class="s1">end</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">startswith</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">prefix</span><span class="s3">, </span><span class="s1">start</span><span class="s3">=</span><span class="s6">0</span><span class="s3">, </span><span class="s1">end</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns a boolean array which is `True` where the string element 
    in ``a`` starts with ``prefix``, otherwise `False`. 
 
    Parameters 
    ---------- 
    a : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype 
 
    prefix : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype 
 
    start, end : array_like, with any integer dtype 
        With ``start``, test beginning at that position. With ``end``, 
        stop comparing at that position. 
 
    Returns 
    ------- 
    out : ndarray 
        Output array of bools 
 
    See Also 
    -------- 
    str.startswith 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; s = np.array(['foo', 'bar']) 
    &gt;&gt;&gt; s 
    array(['foo', 'bar'], dtype='&lt;U3') 
    &gt;&gt;&gt; np.strings.startswith(s, 'fo') 
    array([True,  False]) 
    &gt;&gt;&gt; np.strings.startswith(s, 'o', start=1, end=2) 
    array([True,  False]) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">end </span><span class="s3">= </span><span class="s1">end </span><span class="s2">if </span><span class="s1">end </span><span class="s2">is not None else </span><span class="s1">MAX</span>
    <span class="s2">return </span><span class="s1">_startswith_ufunc</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">prefix</span><span class="s3">, </span><span class="s1">start</span><span class="s3">, </span><span class="s1">end</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">endswith</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">suffix</span><span class="s3">, </span><span class="s1">start</span><span class="s3">=</span><span class="s6">0</span><span class="s3">, </span><span class="s1">end</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns a boolean array which is `True` where the string element 
    in ``a`` ends with ``suffix``, otherwise `False`. 
 
    Parameters 
    ---------- 
    a : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype 
 
    suffix : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype 
 
    start, end : array_like, with any integer dtype 
        With ``start``, test beginning at that position. With ``end``, 
        stop comparing at that position. 
 
    Returns 
    ------- 
    out : ndarray 
        Output array of bools 
 
    See Also 
    -------- 
    str.endswith 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; s = np.array(['foo', 'bar']) 
    &gt;&gt;&gt; s 
    array(['foo', 'bar'], dtype='&lt;U3') 
    &gt;&gt;&gt; np.strings.endswith(s, 'ar') 
    array([False,  True]) 
    &gt;&gt;&gt; np.strings.endswith(s, 'a', start=1, end=2) 
    array([False,  True]) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">end </span><span class="s3">= </span><span class="s1">end </span><span class="s2">if </span><span class="s1">end </span><span class="s2">is not None else </span><span class="s1">MAX</span>
    <span class="s2">return </span><span class="s1">_endswith_ufunc</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">suffix</span><span class="s3">, </span><span class="s1">start</span><span class="s3">, </span><span class="s1">end</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">decode</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">encoding</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">errors</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s0">r&quot;&quot;&quot; 
    Calls :meth:`bytes.decode` element-wise. 
 
    The set of available codecs comes from the Python standard library, 
    and may be extended at runtime.  For more information, see the 
    :mod:`codecs` module. 
 
    Parameters 
    ---------- 
    a : array_like, with ``bytes_`` dtype 
 
    encoding : str, optional 
       The name of an encoding 
 
    errors : str, optional 
       Specifies how to handle encoding errors 
 
    Returns 
    ------- 
    out : ndarray 
 
    See Also 
    -------- 
    :py:meth:`bytes.decode` 
 
    Notes 
    ----- 
    The type of the result will depend on the encoding specified. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; c = np.array([b'\x81\xc1\x81\xc1\x81\xc1', b'@@\x81\xc1@@', 
    ...               b'\x81\x82\xc2\xc1\xc2\x82\x81']) 
    &gt;&gt;&gt; c 
    array([b'\x81\xc1\x81\xc1\x81\xc1', b'@@\x81\xc1@@', 
           b'\x81\x82\xc2\xc1\xc2\x82\x81'], dtype='|S7') 
    &gt;&gt;&gt; np.strings.decode(c, encoding='cp037') 
    array(['aAaAaA', '  aA  ', 'abBABba'], dtype='&lt;U7') 
 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_to_bytes_or_str_array</span><span class="s3">(</span>
        <span class="s1">_vec_string</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">object_</span><span class="s3">, </span><span class="s5">'decode'</span><span class="s3">, </span><span class="s1">_clean_args</span><span class="s3">(</span><span class="s1">encoding</span><span class="s3">, </span><span class="s1">errors</span><span class="s3">)),</span>
        <span class="s1">np</span><span class="s3">.</span><span class="s1">str_</span><span class="s3">(</span><span class="s5">''</span><span class="s3">))</span>


<span class="s2">def </span><span class="s1">encode</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">encoding</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">errors</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Calls :meth:`str.encode` element-wise. 
 
    The set of available codecs comes from the Python standard library, 
    and may be extended at runtime. For more information, see the 
    :mod:`codecs` module. 
 
    Parameters 
    ---------- 
    a : array_like, with ``StringDType`` or ``str_`` dtype 
 
    encoding : str, optional 
       The name of an encoding 
 
    errors : str, optional 
       Specifies how to handle encoding errors 
 
    Returns 
    ------- 
    out : ndarray 
 
    See Also 
    -------- 
    str.encode 
 
    Notes 
    ----- 
    The type of the result will depend on the encoding specified. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; a = np.array(['aAaAaA', '  aA  ', 'abBABba']) 
    &gt;&gt;&gt; np.strings.encode(a, encoding='cp037') 
    array([b'\x81\xc1\x81\xc1\x81\xc1', b'@@\x81\xc1@@', 
       b'\x81\x82\xc2\xc1\xc2\x82\x81'], dtype='|S7') 
 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_to_bytes_or_str_array</span><span class="s3">(</span>
        <span class="s1">_vec_string</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">object_</span><span class="s3">, </span><span class="s5">'encode'</span><span class="s3">, </span><span class="s1">_clean_args</span><span class="s3">(</span><span class="s1">encoding</span><span class="s3">, </span><span class="s1">errors</span><span class="s3">)),</span>
        <span class="s1">np</span><span class="s3">.</span><span class="s1">bytes_</span><span class="s3">(</span><span class="s7">b''</span><span class="s3">))</span>


<span class="s2">def </span><span class="s1">expandtabs</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">tabsize</span><span class="s3">=</span><span class="s6">8</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return a copy of each string element where all tab characters are 
    replaced by one or more spaces. 
 
    Calls :meth:`str.expandtabs` element-wise. 
 
    Return a copy of each string element where all tab characters are 
    replaced by one or more spaces, depending on the current column 
    and the given `tabsize`. The column number is reset to zero after 
    each newline occurring in the string. This doesn't understand other 
    non-printing characters or escape sequences. 
 
    Parameters 
    ---------- 
    a : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype 
        Input array 
    tabsize : int, optional 
        Replace tabs with `tabsize` number of spaces.  If not given defaults 
        to 8 spaces. 
 
    Returns 
    ------- 
    out : ndarray 
        Output array of ``StringDType``, ``bytes_`` or ``str_`` dtype, 
        depending on input type 
 
    See Also 
    -------- 
    str.expandtabs 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; a = np.array(['\t\tHello\tworld']) 
    &gt;&gt;&gt; np.strings.expandtabs(a, tabsize=4)  # doctest: +SKIP 
    array(['        Hello   world'], dtype='&lt;U21')  # doctest: +SKIP 
 
    &quot;&quot;&quot;</span>
    <span class="s1">a </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asanyarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
    <span class="s1">tabsize </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asanyarray</span><span class="s3">(</span><span class="s1">tabsize</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">char </span><span class="s3">== </span><span class="s5">&quot;T&quot;</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">_expandtabs</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">tabsize</span><span class="s3">)</span>

    <span class="s1">buffersizes </span><span class="s3">= </span><span class="s1">_expandtabs_length</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">tabsize</span><span class="s3">)</span>
    <span class="s1">out_dtype </span><span class="s3">= </span><span class="s5">f&quot;</span><span class="s2">{</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">char</span><span class="s2">}{</span><span class="s1">buffersizes</span><span class="s3">.</span><span class="s1">max</span><span class="s3">()</span><span class="s2">}</span><span class="s5">&quot;</span>
    <span class="s1">out </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty_like</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">=</span><span class="s1">buffersizes</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">out_dtype</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">_expandtabs</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">tabsize</span><span class="s3">, </span><span class="s1">out</span><span class="s3">=</span><span class="s1">out</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">center</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">width</span><span class="s3">, </span><span class="s1">fillchar</span><span class="s3">=</span><span class="s5">' '</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return a copy of `a` with its elements centered in a string of 
    length `width`. 
 
    Parameters 
    ---------- 
    a : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype 
 
    width : array_like, with any integer dtype 
        The length of the resulting strings, unless ``width &lt; str_len(a)``. 
    fillchar : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype 
        Optional padding character to use (default is space). 
 
    Returns 
    ------- 
    out : ndarray 
        Output array of ``StringDType``, ``bytes_`` or ``str_`` dtype, 
        depending on input types 
 
    See Also 
    -------- 
    str.center 
 
    Notes 
    ----- 
    While it is possible for ``a`` and ``fillchar`` to have different dtypes, 
    passing a non-ASCII character in ``fillchar`` when ``a`` is of dtype &quot;S&quot; 
    is not allowed, and a ``ValueError`` is raised. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; c = np.array(['a1b2','1b2a','b2a1','2a1b']); c 
    array(['a1b2', '1b2a', 'b2a1', '2a1b'], dtype='&lt;U4') 
    &gt;&gt;&gt; np.strings.center(c, width=9) 
    array(['   a1b2  ', '   1b2a  ', '   b2a1  ', '   2a1b  '], dtype='&lt;U9') 
    &gt;&gt;&gt; np.strings.center(c, width=9, fillchar='*') 
    array(['***a1b2**', '***1b2a**', '***b2a1**', '***2a1b**'], dtype='&lt;U9') 
    &gt;&gt;&gt; np.strings.center(c, width=1) 
    array(['a1b2', '1b2a', 'b2a1', '2a1b'], dtype='&lt;U4') 
 
    &quot;&quot;&quot;</span>
    <span class="s1">a </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asanyarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
    <span class="s1">fillchar </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asanyarray</span><span class="s3">(</span><span class="s1">fillchar</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">any</span><span class="s3">(</span><span class="s1">str_len</span><span class="s3">(</span><span class="s1">fillchar</span><span class="s3">) != </span><span class="s6">1</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span>
            <span class="s5">&quot;The fill character must be exactly one character long&quot;</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">char </span><span class="s3">== </span><span class="s5">&quot;T&quot;</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">_center</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">width</span><span class="s3">, </span><span class="s1">fillchar</span><span class="s3">)</span>

    <span class="s1">width </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">maximum</span><span class="s3">(</span><span class="s1">str_len</span><span class="s3">(</span><span class="s1">a</span><span class="s3">), </span><span class="s1">width</span><span class="s3">)</span>
    <span class="s1">out_dtype </span><span class="s3">= </span><span class="s5">f&quot;</span><span class="s2">{</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">char</span><span class="s2">}{</span><span class="s1">width</span><span class="s3">.</span><span class="s1">max</span><span class="s3">()</span><span class="s2">}</span><span class="s5">&quot;</span>
    <span class="s1">shape </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">broadcast_shapes</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">width</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">fillchar</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">)</span>
    <span class="s1">out </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty_like</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">=</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">out_dtype</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">_center</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">width</span><span class="s3">, </span><span class="s1">fillchar</span><span class="s3">, </span><span class="s1">out</span><span class="s3">=</span><span class="s1">out</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">ljust</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">width</span><span class="s3">, </span><span class="s1">fillchar</span><span class="s3">=</span><span class="s5">' '</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return an array with the elements of `a` left-justified in a 
    string of length `width`. 
 
    Parameters 
    ---------- 
    a : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype 
 
    width : array_like, with any integer dtype 
        The length of the resulting strings, unless ``width &lt; str_len(a)``. 
    fillchar : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype 
        Optional character to use for padding (default is space). 
 
    Returns 
    ------- 
    out : ndarray 
        Output array of ``StringDType``, ``bytes_`` or ``str_`` dtype, 
        depending on input types 
 
    See Also 
    -------- 
    str.ljust 
 
    Notes 
    ----- 
    While it is possible for ``a`` and ``fillchar`` to have different dtypes, 
    passing a non-ASCII character in ``fillchar`` when ``a`` is of dtype &quot;S&quot; 
    is not allowed, and a ``ValueError`` is raised. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; c = np.array(['aAaAaA', '  aA  ', 'abBABba']) 
    &gt;&gt;&gt; np.strings.ljust(c, width=3) 
    array(['aAaAaA', '  aA  ', 'abBABba'], dtype='&lt;U7') 
    &gt;&gt;&gt; np.strings.ljust(c, width=9) 
    array(['aAaAaA   ', '  aA     ', 'abBABba  '], dtype='&lt;U9') 
 
    &quot;&quot;&quot;</span>
    <span class="s1">a </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asanyarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
    <span class="s1">fillchar </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asanyarray</span><span class="s3">(</span><span class="s1">fillchar</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">any</span><span class="s3">(</span><span class="s1">str_len</span><span class="s3">(</span><span class="s1">fillchar</span><span class="s3">) != </span><span class="s6">1</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span>
            <span class="s5">&quot;The fill character must be exactly one character long&quot;</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">char </span><span class="s3">== </span><span class="s5">&quot;T&quot;</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">_ljust</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">width</span><span class="s3">, </span><span class="s1">fillchar</span><span class="s3">)</span>

    <span class="s1">width </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">maximum</span><span class="s3">(</span><span class="s1">str_len</span><span class="s3">(</span><span class="s1">a</span><span class="s3">), </span><span class="s1">width</span><span class="s3">)</span>
    <span class="s1">shape </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">broadcast_shapes</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">width</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">fillchar</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">)</span>
    <span class="s1">out_dtype </span><span class="s3">= </span><span class="s5">f&quot;</span><span class="s2">{</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">char</span><span class="s2">}{</span><span class="s1">width</span><span class="s3">.</span><span class="s1">max</span><span class="s3">()</span><span class="s2">}</span><span class="s5">&quot;</span>
    <span class="s1">out </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty_like</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">=</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">out_dtype</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">_ljust</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">width</span><span class="s3">, </span><span class="s1">fillchar</span><span class="s3">, </span><span class="s1">out</span><span class="s3">=</span><span class="s1">out</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">rjust</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">width</span><span class="s3">, </span><span class="s1">fillchar</span><span class="s3">=</span><span class="s5">' '</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return an array with the elements of `a` right-justified in a 
    string of length `width`. 
 
    Parameters 
    ---------- 
    a : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype 
 
    width : array_like, with any integer dtype 
        The length of the resulting strings, unless ``width &lt; str_len(a)``. 
    fillchar : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype 
        Optional padding character to use (default is space). 
 
    Returns 
    ------- 
    out : ndarray 
        Output array of ``StringDType``, ``bytes_`` or ``str_`` dtype, 
        depending on input types 
 
    See Also 
    -------- 
    str.rjust 
 
    Notes 
    ----- 
    While it is possible for ``a`` and ``fillchar`` to have different dtypes, 
    passing a non-ASCII character in ``fillchar`` when ``a`` is of dtype &quot;S&quot; 
    is not allowed, and a ``ValueError`` is raised. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; a = np.array(['aAaAaA', '  aA  ', 'abBABba']) 
    &gt;&gt;&gt; np.strings.rjust(a, width=3) 
    array(['aAaAaA', '  aA  ', 'abBABba'], dtype='&lt;U7') 
    &gt;&gt;&gt; np.strings.rjust(a, width=9) 
    array(['   aAaAaA', '     aA  ', '  abBABba'], dtype='&lt;U9') 
 
    &quot;&quot;&quot;</span>
    <span class="s1">a </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asanyarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
    <span class="s1">fillchar </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asanyarray</span><span class="s3">(</span><span class="s1">fillchar</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">any</span><span class="s3">(</span><span class="s1">str_len</span><span class="s3">(</span><span class="s1">fillchar</span><span class="s3">) != </span><span class="s6">1</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span>
            <span class="s5">&quot;The fill character must be exactly one character long&quot;</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">char </span><span class="s3">== </span><span class="s5">&quot;T&quot;</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">_rjust</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">width</span><span class="s3">, </span><span class="s1">fillchar</span><span class="s3">)</span>

    <span class="s1">width </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">maximum</span><span class="s3">(</span><span class="s1">str_len</span><span class="s3">(</span><span class="s1">a</span><span class="s3">), </span><span class="s1">width</span><span class="s3">)</span>
    <span class="s1">shape </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">broadcast_shapes</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">width</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">fillchar</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">)</span>
    <span class="s1">out_dtype </span><span class="s3">= </span><span class="s5">f&quot;</span><span class="s2">{</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">char</span><span class="s2">}{</span><span class="s1">width</span><span class="s3">.</span><span class="s1">max</span><span class="s3">()</span><span class="s2">}</span><span class="s5">&quot;</span>
    <span class="s1">out </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty_like</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">=</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">out_dtype</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">_rjust</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">width</span><span class="s3">, </span><span class="s1">fillchar</span><span class="s3">, </span><span class="s1">out</span><span class="s3">=</span><span class="s1">out</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">zfill</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">width</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return the numeric string left-filled with zeros. A leading 
    sign prefix (``+``/``-``) is handled by inserting the padding 
    after the sign character rather than before. 
 
    Parameters 
    ---------- 
    a : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype 
 
    width : array_like, with any integer dtype 
        Width of string to left-fill elements in `a`. 
 
    Returns 
    ------- 
    out : ndarray 
        Output array of ``StringDType``, ``bytes_`` or ``str_`` dtype, 
        depending on input type 
 
    See Also 
    -------- 
    str.zfill 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; np.strings.zfill(['1', '-1', '+1'], 3) 
    array(['001', '-01', '+01'], dtype='&lt;U3') 
 
    &quot;&quot;&quot;</span>
    <span class="s1">a </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asanyarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">char </span><span class="s3">== </span><span class="s5">&quot;T&quot;</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">_zfill</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">width</span><span class="s3">)</span>

    <span class="s1">width </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">maximum</span><span class="s3">(</span><span class="s1">str_len</span><span class="s3">(</span><span class="s1">a</span><span class="s3">), </span><span class="s1">width</span><span class="s3">)</span>
    <span class="s1">shape </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">broadcast_shapes</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">width</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">)</span>
    <span class="s1">out_dtype </span><span class="s3">= </span><span class="s5">f&quot;</span><span class="s2">{</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">char</span><span class="s2">}{</span><span class="s1">width</span><span class="s3">.</span><span class="s1">max</span><span class="s3">()</span><span class="s2">}</span><span class="s5">&quot;</span>
    <span class="s1">out </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty_like</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">=</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">out_dtype</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">_zfill</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">width</span><span class="s3">, </span><span class="s1">out</span><span class="s3">=</span><span class="s1">out</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">lstrip</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">chars</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    For each element in `a`, return a copy with the leading characters 
    removed. 
 
    Parameters 
    ---------- 
    a : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype 
    chars : scalar with the same dtype as ``a``, optional 
       The ``chars`` argument is a string specifying the set of 
       characters to be removed. If ``None``, the ``chars`` 
       argument defaults to removing whitespace. The ``chars`` argument 
       is not a prefix or suffix; rather, all combinations of its 
       values are stripped. 
 
    Returns 
    ------- 
    out : ndarray 
        Output array of ``StringDType``, ``bytes_`` or ``str_`` dtype, 
        depending on input types 
 
    See Also 
    -------- 
    str.lstrip 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; c = np.array(['aAaAaA', '  aA  ', 'abBABba']) 
    &gt;&gt;&gt; c 
    array(['aAaAaA', '  aA  ', 'abBABba'], dtype='&lt;U7') 
    # The 'a' variable is unstripped from c[1] because of leading whitespace. 
    &gt;&gt;&gt; np.strings.lstrip(c, 'a') 
    array(['AaAaA', '  aA  ', 'bBABba'], dtype='&lt;U7') 
    &gt;&gt;&gt; np.strings.lstrip(c, 'A') # leaves c unchanged 
    array(['aAaAaA', '  aA  ', 'abBABba'], dtype='&lt;U7') 
    &gt;&gt;&gt; (np.strings.lstrip(c, ' ') == np.strings.lstrip(c, '')).all() 
    np.False_ 
    &gt;&gt;&gt; (np.strings.lstrip(c, ' ') == np.strings.lstrip(c)).all() 
    np.True_ 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">chars </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">_lstrip_whitespace</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">_lstrip_chars</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">chars</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">rstrip</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">chars</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    For each element in `a`, return a copy with the trailing characters 
    removed. 
 
    Parameters 
    ---------- 
    a : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype 
    chars : scalar with the same dtype as ``a``, optional 
       The ``chars`` argument is a string specifying the set of 
       characters to be removed. If ``None``, the ``chars`` 
       argument defaults to removing whitespace. The ``chars`` argument 
       is not a prefix or suffix; rather, all combinations of its 
       values are stripped. 
 
    Returns 
    ------- 
    out : ndarray 
        Output array of ``StringDType``, ``bytes_`` or ``str_`` dtype, 
        depending on input types 
 
    See Also 
    -------- 
    str.rstrip 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; c = np.array(['aAaAaA', 'abBABba']) 
    &gt;&gt;&gt; c 
    array(['aAaAaA', 'abBABba'], dtype='&lt;U7') 
    &gt;&gt;&gt; np.strings.rstrip(c, 'a') 
    array(['aAaAaA', 'abBABb'], dtype='&lt;U7') 
    &gt;&gt;&gt; np.strings.rstrip(c, 'A') 
    array(['aAaAa', 'abBABba'], dtype='&lt;U7') 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">chars </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">_rstrip_whitespace</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">_rstrip_chars</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">chars</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">strip</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">chars</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    For each element in `a`, return a copy with the leading and 
    trailing characters removed. 
 
    Parameters 
    ---------- 
    a : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype 
    chars : scalar with the same dtype as ``a``, optional 
       The ``chars`` argument is a string specifying the set of 
       characters to be removed. If ``None``, the ``chars`` 
       argument defaults to removing whitespace. The ``chars`` argument 
       is not a prefix or suffix; rather, all combinations of its 
       values are stripped. 
 
    Returns 
    ------- 
    out : ndarray 
        Output array of ``StringDType``, ``bytes_`` or ``str_`` dtype, 
        depending on input types 
 
    See Also 
    -------- 
    str.strip 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; c = np.array(['aAaAaA', '  aA  ', 'abBABba']) 
    &gt;&gt;&gt; c 
    array(['aAaAaA', '  aA  ', 'abBABba'], dtype='&lt;U7') 
    &gt;&gt;&gt; np.strings.strip(c) 
    array(['aAaAaA', 'aA', 'abBABba'], dtype='&lt;U7') 
    # 'a' unstripped from c[1] because of leading whitespace. 
    &gt;&gt;&gt; np.strings.strip(c, 'a') 
    array(['AaAaA', '  aA  ', 'bBABb'], dtype='&lt;U7') 
    # 'A' unstripped from c[1] because of trailing whitespace. 
    &gt;&gt;&gt; np.strings.strip(c, 'A') 
    array(['aAaAa', '  aA  ', 'abBABba'], dtype='&lt;U7') 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">chars </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">_strip_whitespace</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">_strip_chars</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">chars</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">upper</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return an array with the elements converted to uppercase. 
 
    Calls :meth:`str.upper` element-wise. 
 
    For 8-bit strings, this method is locale-dependent. 
 
    Parameters 
    ---------- 
    a : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype 
        Input array. 
 
    Returns 
    ------- 
    out : ndarray 
        Output array of ``StringDType``, ``bytes_`` or ``str_`` dtype, 
        depending on input types 
 
    See Also 
    -------- 
    str.upper 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; c = np.array(['a1b c', '1bca', 'bca1']); c 
    array(['a1b c', '1bca', 'bca1'], dtype='&lt;U5') 
    &gt;&gt;&gt; np.strings.upper(c) 
    array(['A1B C', '1BCA', 'BCA1'], dtype='&lt;U5') 
 
    &quot;&quot;&quot;</span>
    <span class="s1">a_arr </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">_vec_string</span><span class="s3">(</span><span class="s1">a_arr</span><span class="s3">, </span><span class="s1">a_arr</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s5">'upper'</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">lower</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return an array with the elements converted to lowercase. 
 
    Call :meth:`str.lower` element-wise. 
 
    For 8-bit strings, this method is locale-dependent. 
 
    Parameters 
    ---------- 
    a : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype 
        Input array. 
 
    Returns 
    ------- 
    out : ndarray 
        Output array of ``StringDType``, ``bytes_`` or ``str_`` dtype, 
        depending on input types 
 
    See Also 
    -------- 
    str.lower 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; c = np.array(['A1B C', '1BCA', 'BCA1']); c 
    array(['A1B C', '1BCA', 'BCA1'], dtype='&lt;U5') 
    &gt;&gt;&gt; np.strings.lower(c) 
    array(['a1b c', '1bca', 'bca1'], dtype='&lt;U5') 
 
    &quot;&quot;&quot;</span>
    <span class="s1">a_arr </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">_vec_string</span><span class="s3">(</span><span class="s1">a_arr</span><span class="s3">, </span><span class="s1">a_arr</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s5">'lower'</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">swapcase</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return element-wise a copy of the string with 
    uppercase characters converted to lowercase and vice versa. 
 
    Calls :meth:`str.swapcase` element-wise. 
 
    For 8-bit strings, this method is locale-dependent. 
 
    Parameters 
    ---------- 
    a : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype 
        Input array. 
 
    Returns 
    ------- 
    out : ndarray 
        Output array of ``StringDType``, ``bytes_`` or ``str_`` dtype, 
        depending on input types 
 
    See Also 
    -------- 
    str.swapcase 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; c=np.array(['a1B c','1b Ca','b Ca1','cA1b'],'S5'); c 
    array(['a1B c', '1b Ca', 'b Ca1', 'cA1b'], 
        dtype='|S5') 
    &gt;&gt;&gt; np.strings.swapcase(c) 
    array(['A1b C', '1B cA', 'B cA1', 'Ca1B'], 
        dtype='|S5') 
 
    &quot;&quot;&quot;</span>
    <span class="s1">a_arr </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">_vec_string</span><span class="s3">(</span><span class="s1">a_arr</span><span class="s3">, </span><span class="s1">a_arr</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s5">'swapcase'</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">capitalize</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return a copy of ``a`` with only the first character of each element 
    capitalized. 
 
    Calls :meth:`str.capitalize` element-wise. 
 
    For byte strings, this method is locale-dependent. 
 
    Parameters 
    ---------- 
    a : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype 
        Input array of strings to capitalize. 
 
    Returns 
    ------- 
    out : ndarray 
        Output array of ``StringDType``, ``bytes_`` or ``str_`` dtype, 
        depending on input types 
 
    See Also 
    -------- 
    str.capitalize 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; c = np.array(['a1b2','1b2a','b2a1','2a1b'],'S4'); c 
    array(['a1b2', '1b2a', 'b2a1', '2a1b'], 
        dtype='|S4') 
    &gt;&gt;&gt; np.strings.capitalize(c) 
    array(['A1b2', '1b2a', 'B2a1', '2a1b'], 
        dtype='|S4') 
 
    &quot;&quot;&quot;</span>
    <span class="s1">a_arr </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">_vec_string</span><span class="s3">(</span><span class="s1">a_arr</span><span class="s3">, </span><span class="s1">a_arr</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s5">'capitalize'</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">title</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return element-wise title cased version of string or unicode. 
 
    Title case words start with uppercase characters, all remaining cased 
    characters are lowercase. 
 
    Calls :meth:`str.title` element-wise. 
 
    For 8-bit strings, this method is locale-dependent. 
 
    Parameters 
    ---------- 
    a : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype 
        Input array. 
 
    Returns 
    ------- 
    out : ndarray 
        Output array of ``StringDType``, ``bytes_`` or ``str_`` dtype, 
        depending on input types 
 
    See Also 
    -------- 
    str.title 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; c=np.array(['a1b c','1b ca','b ca1','ca1b'],'S5'); c 
    array(['a1b c', '1b ca', 'b ca1', 'ca1b'], 
        dtype='|S5') 
    &gt;&gt;&gt; np.strings.title(c) 
    array(['A1B C', '1B Ca', 'B Ca1', 'Ca1B'], 
        dtype='|S5') 
 
    &quot;&quot;&quot;</span>
    <span class="s1">a_arr </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">_vec_string</span><span class="s3">(</span><span class="s1">a_arr</span><span class="s3">, </span><span class="s1">a_arr</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s5">'title'</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">replace</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">old</span><span class="s3">, </span><span class="s1">new</span><span class="s3">, </span><span class="s1">count</span><span class="s3">=-</span><span class="s6">1</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    For each element in ``a``, return a copy of the string with 
    occurrences of substring ``old`` replaced by ``new``. 
 
    Parameters 
    ---------- 
    a : array_like, with ``bytes_`` or ``str_`` dtype 
 
    old, new : array_like, with ``bytes_`` or ``str_`` dtype 
 
    count : array_like, with ``int_`` dtype 
        If the optional argument ``count`` is given, only the first 
        ``count`` occurrences are replaced. 
 
    Returns 
    ------- 
    out : ndarray 
        Output array of ``StringDType``, ``bytes_`` or ``str_`` dtype, 
        depending on input types 
 
    See Also 
    -------- 
    str.replace 
     
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; a = np.array([&quot;That is a mango&quot;, &quot;Monkeys eat mangos&quot;]) 
    &gt;&gt;&gt; np.strings.replace(a, 'mango', 'banana') 
    array(['That is a banana', 'Monkeys eat bananas'], dtype='&lt;U19') 
 
    &gt;&gt;&gt; a = np.array([&quot;The dish is fresh&quot;, &quot;This is it&quot;]) 
    &gt;&gt;&gt; np.strings.replace(a, 'is', 'was') 
    array(['The dwash was fresh', 'Thwas was it'], dtype='&lt;U19') 
 
    &quot;&quot;&quot;</span>
    <span class="s1">arr </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asanyarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
    <span class="s1">a_dt </span><span class="s3">= </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">dtype</span>
    <span class="s1">old </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asanyarray</span><span class="s3">(</span><span class="s1">old</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">old</span><span class="s3">, </span><span class="s5">'dtype'</span><span class="s3">, </span><span class="s1">a_dt</span><span class="s3">))</span>
    <span class="s1">new </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asanyarray</span><span class="s3">(</span><span class="s1">new</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">new</span><span class="s3">, </span><span class="s5">'dtype'</span><span class="s3">, </span><span class="s1">a_dt</span><span class="s3">))</span>
    <span class="s1">count </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asanyarray</span><span class="s3">(</span><span class="s1">count</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">char </span><span class="s3">== </span><span class="s5">&quot;T&quot;</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">_replace</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">, </span><span class="s1">old</span><span class="s3">, </span><span class="s1">new</span><span class="s3">, </span><span class="s1">count</span><span class="s3">)</span>

    <span class="s1">max_int64 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">iinfo</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">int64</span><span class="s3">).</span><span class="s1">max</span>
    <span class="s1">counts </span><span class="s3">= </span><span class="s1">_count_ufunc</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">, </span><span class="s1">old</span><span class="s3">, </span><span class="s6">0</span><span class="s3">, </span><span class="s1">max_int64</span><span class="s3">)</span>
    <span class="s1">counts </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">where</span><span class="s3">(</span><span class="s1">count </span><span class="s3">&lt; </span><span class="s6">0</span><span class="s3">, </span><span class="s1">counts</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">minimum</span><span class="s3">(</span><span class="s1">counts</span><span class="s3">, </span><span class="s1">count</span><span class="s3">))</span>

    <span class="s1">buffersizes </span><span class="s3">= </span><span class="s1">str_len</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">) + </span><span class="s1">counts </span><span class="s3">* (</span><span class="s1">str_len</span><span class="s3">(</span><span class="s1">new</span><span class="s3">) - </span><span class="s1">str_len</span><span class="s3">(</span><span class="s1">old</span><span class="s3">))</span>
    <span class="s1">out_dtype </span><span class="s3">= </span><span class="s5">f&quot;</span><span class="s2">{</span><span class="s1">arr</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">char</span><span class="s2">}{</span><span class="s1">buffersizes</span><span class="s3">.</span><span class="s1">max</span><span class="s3">()</span><span class="s2">}</span><span class="s5">&quot;</span>
    <span class="s1">out </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty_like</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">=</span><span class="s1">buffersizes</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">out_dtype</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">_replace</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">, </span><span class="s1">old</span><span class="s3">, </span><span class="s1">new</span><span class="s3">, </span><span class="s1">counts</span><span class="s3">, </span><span class="s1">out</span><span class="s3">=</span><span class="s1">out</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">_join</span><span class="s3">(</span><span class="s1">sep</span><span class="s3">, </span><span class="s1">seq</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return a string which is the concatenation of the strings in the 
    sequence `seq`. 
 
    Calls :meth:`str.join` element-wise. 
 
    Parameters 
    ---------- 
    sep : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype 
    seq : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype 
 
    Returns 
    ------- 
    out : ndarray 
        Output array of ``StringDType``, ``bytes_`` or ``str_`` dtype, 
        depending on input types 
 
    See Also 
    -------- 
    str.join 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; np.strings.join('-', 'osd')  # doctest: +SKIP 
    array('o-s-d', dtype='&lt;U5')  # doctest: +SKIP 
 
    &gt;&gt;&gt; np.strings.join(['-', '.'], ['ghc', 'osd'])  # doctest: +SKIP 
    array(['g-h-c', 'o.s.d'], dtype='&lt;U5')  # doctest: +SKIP 
 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_to_bytes_or_str_array</span><span class="s3">(</span>
        <span class="s1">_vec_string</span><span class="s3">(</span><span class="s1">sep</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">object_</span><span class="s3">, </span><span class="s5">'join'</span><span class="s3">, (</span><span class="s1">seq</span><span class="s3">,)), </span><span class="s1">seq</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">_split</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">sep</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">maxsplit</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    For each element in `a`, return a list of the words in the 
    string, using `sep` as the delimiter string. 
 
    Calls :meth:`str.split` element-wise. 
 
    Parameters 
    ---------- 
    a : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype 
 
    sep : str or unicode, optional 
       If `sep` is not specified or None, any whitespace string is a 
       separator. 
 
    maxsplit : int, optional 
        If `maxsplit` is given, at most `maxsplit` splits are done. 
 
    Returns 
    ------- 
    out : ndarray 
        Array of list objects 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; x = np.array(&quot;Numpy is nice!&quot;) 
    &gt;&gt;&gt; np.strings.split(x, &quot; &quot;)  # doctest: +SKIP 
    array(list(['Numpy', 'is', 'nice!']), dtype=object)  # doctest: +SKIP 
 
    &gt;&gt;&gt; np.strings.split(x, &quot; &quot;, 1)  # doctest: +SKIP 
    array(list(['Numpy', 'is nice!']), dtype=object)  # doctest: +SKIP 
 
    See Also 
    -------- 
    str.split, rsplit 
 
    &quot;&quot;&quot;</span>
    <span class="s4"># This will return an array of lists of different sizes, so we</span>
    <span class="s4"># leave it as an object array</span>
    <span class="s2">return </span><span class="s1">_vec_string</span><span class="s3">(</span>
        <span class="s1">a</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">object_</span><span class="s3">, </span><span class="s5">'split'</span><span class="s3">, [</span><span class="s1">sep</span><span class="s3">] + </span><span class="s1">_clean_args</span><span class="s3">(</span><span class="s1">maxsplit</span><span class="s3">))</span>


<span class="s2">def </span><span class="s1">_rsplit</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">sep</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">maxsplit</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    For each element in `a`, return a list of the words in the 
    string, using `sep` as the delimiter string. 
 
    Calls :meth:`str.rsplit` element-wise. 
 
    Except for splitting from the right, `rsplit` 
    behaves like `split`. 
 
    Parameters 
    ---------- 
    a : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype 
 
    sep : str or unicode, optional 
        If `sep` is not specified or None, any whitespace string 
        is a separator. 
    maxsplit : int, optional 
        If `maxsplit` is given, at most `maxsplit` splits are done, 
        the rightmost ones. 
 
    Returns 
    ------- 
    out : ndarray 
        Array of list objects 
 
    See Also 
    -------- 
    str.rsplit, split 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; a = np.array(['aAaAaA', 'abBABba']) 
    &gt;&gt;&gt; np.strings.rsplit(a, 'A')  # doctest: +SKIP 
    array([list(['a', 'a', 'a', '']),  # doctest: +SKIP 
           list(['abB', 'Bba'])], dtype=object)  # doctest: +SKIP 
 
    &quot;&quot;&quot;</span>
    <span class="s4"># This will return an array of lists of different sizes, so we</span>
    <span class="s4"># leave it as an object array</span>
    <span class="s2">return </span><span class="s1">_vec_string</span><span class="s3">(</span>
        <span class="s1">a</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">object_</span><span class="s3">, </span><span class="s5">'rsplit'</span><span class="s3">, [</span><span class="s1">sep</span><span class="s3">] + </span><span class="s1">_clean_args</span><span class="s3">(</span><span class="s1">maxsplit</span><span class="s3">))</span>


<span class="s2">def </span><span class="s1">_splitlines</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">keepends</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    For each element in `a`, return a list of the lines in the 
    element, breaking at line boundaries. 
 
    Calls :meth:`str.splitlines` element-wise. 
 
    Parameters 
    ---------- 
    a : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype 
 
    keepends : bool, optional 
        Line breaks are not included in the resulting list unless 
        keepends is given and true. 
 
    Returns 
    ------- 
    out : ndarray 
        Array of list objects 
 
    See Also 
    -------- 
    str.splitlines 
 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_vec_string</span><span class="s3">(</span>
        <span class="s1">a</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">object_</span><span class="s3">, </span><span class="s5">'splitlines'</span><span class="s3">, </span><span class="s1">_clean_args</span><span class="s3">(</span><span class="s1">keepends</span><span class="s3">))</span>


<span class="s2">def </span><span class="s1">partition</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">sep</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Partition each element in ``a`` around ``sep``. 
 
    For each element in ``a``, split the element at the first 
    occurrence of ``sep``, and return a 3-tuple containing the part 
    before the separator, the separator itself, and the part after 
    the separator. If the separator is not found, the first item of 
    the tuple will contain the whole string, and the second and third 
    ones will be the empty string. 
 
    Parameters 
    ---------- 
    a : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype 
        Input array 
    sep : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype 
        Separator to split each string element in ``a``. 
 
    Returns 
    ------- 
    out : 3-tuple: 
        - array with ``StringDType``, ``bytes_`` or ``str_`` dtype with the 
          part before the separator 
        - array with ``StringDType``, ``bytes_`` or ``str_`` dtype with the 
          separator 
        - array with ``StringDType``, ``bytes_`` or ``str_`` dtype with the 
          part after the separator 
 
    See Also 
    -------- 
    str.partition 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; x = np.array([&quot;Numpy is nice!&quot;]) 
    &gt;&gt;&gt; np.strings.partition(x, &quot; &quot;) 
    (array(['Numpy'], dtype='&lt;U5'), 
     array([' '], dtype='&lt;U1'), 
     array(['is nice!'], dtype='&lt;U8')) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">a </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asanyarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
    <span class="s4"># TODO switch to copy=False when issues around views are fixed</span>
    <span class="s1">sep </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">sep</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">subok</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">char </span><span class="s3">== </span><span class="s5">&quot;T&quot;</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">_partition</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">sep</span><span class="s3">)</span>

    <span class="s1">pos </span><span class="s3">= </span><span class="s1">_find_ufunc</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">sep</span><span class="s3">, </span><span class="s6">0</span><span class="s3">, </span><span class="s1">MAX</span><span class="s3">)</span>
    <span class="s1">a_len </span><span class="s3">= </span><span class="s1">str_len</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
    <span class="s1">sep_len </span><span class="s3">= </span><span class="s1">str_len</span><span class="s3">(</span><span class="s1">sep</span><span class="s3">)</span>

    <span class="s1">not_found </span><span class="s3">= </span><span class="s1">pos </span><span class="s3">&lt; </span><span class="s6">0</span>
    <span class="s1">buffersizes1 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">where</span><span class="s3">(</span><span class="s1">not_found</span><span class="s3">, </span><span class="s1">a_len</span><span class="s3">, </span><span class="s1">pos</span><span class="s3">)</span>
    <span class="s1">buffersizes3 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">where</span><span class="s3">(</span><span class="s1">not_found</span><span class="s3">, </span><span class="s6">0</span><span class="s3">, </span><span class="s1">a_len </span><span class="s3">- </span><span class="s1">pos </span><span class="s3">- </span><span class="s1">sep_len</span><span class="s3">)</span>

    <span class="s1">out_dtype </span><span class="s3">= </span><span class="s5">&quot;,&quot;</span><span class="s3">.</span><span class="s1">join</span><span class="s3">([</span><span class="s5">f&quot;</span><span class="s2">{</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">char</span><span class="s2">}{</span><span class="s1">n</span><span class="s2">}</span><span class="s5">&quot; </span><span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s3">(</span>
        <span class="s1">buffersizes1</span><span class="s3">.</span><span class="s1">max</span><span class="s3">(),</span>
        <span class="s6">1 </span><span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">all</span><span class="s3">(</span><span class="s1">not_found</span><span class="s3">) </span><span class="s2">else </span><span class="s1">sep_len</span><span class="s3">.</span><span class="s1">max</span><span class="s3">(),</span>
        <span class="s1">buffersizes3</span><span class="s3">.</span><span class="s1">max</span><span class="s3">(),</span>
    <span class="s3">)])</span>
    <span class="s1">shape </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">broadcast_shapes</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">sep</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">)</span>
    <span class="s1">out </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty_like</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">=</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">out_dtype</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">_partition_index</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">sep</span><span class="s3">, </span><span class="s1">pos</span><span class="s3">, </span><span class="s1">out</span><span class="s3">=(</span><span class="s1">out</span><span class="s3">[</span><span class="s5">&quot;f0&quot;</span><span class="s3">], </span><span class="s1">out</span><span class="s3">[</span><span class="s5">&quot;f1&quot;</span><span class="s3">], </span><span class="s1">out</span><span class="s3">[</span><span class="s5">&quot;f2&quot;</span><span class="s3">]))</span>


<span class="s2">def </span><span class="s1">rpartition</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">sep</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Partition (split) each element around the right-most separator. 
 
    For each element in ``a``, split the element at the last 
    occurrence of ``sep``, and return a 3-tuple containing the part 
    before the separator, the separator itself, and the part after 
    the separator. If the separator is not found, the third item of 
    the tuple will contain the whole string, and the first and second 
    ones will be the empty string. 
 
    Parameters 
    ---------- 
    a : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype 
        Input array 
    sep : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype 
        Separator to split each string element in ``a``. 
 
    Returns 
    ------- 
    out : 3-tuple: 
        - array with ``StringDType``, ``bytes_`` or ``str_`` dtype with the 
          part before the separator 
        - array with ``StringDType``, ``bytes_`` or ``str_`` dtype with the 
          separator 
        - array with ``StringDType``, ``bytes_`` or ``str_`` dtype with the 
          part after the separator 
 
    See Also 
    -------- 
    str.rpartition 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; a = np.array(['aAaAaA', '  aA  ', 'abBABba']) 
    &gt;&gt;&gt; np.strings.rpartition(a, 'A') 
    (array(['aAaAa', '  a', 'abB'], dtype='&lt;U5'), 
     array(['A', 'A', 'A'], dtype='&lt;U1'), 
     array(['', '  ', 'Bba'], dtype='&lt;U3')) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">a </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asanyarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
    <span class="s4"># TODO switch to copy=False when issues around views are fixed</span>
    <span class="s1">sep </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">sep</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">subok</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">char </span><span class="s3">== </span><span class="s5">&quot;T&quot;</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">_rpartition</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">sep</span><span class="s3">)</span>

    <span class="s1">pos </span><span class="s3">= </span><span class="s1">_rfind_ufunc</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">sep</span><span class="s3">, </span><span class="s6">0</span><span class="s3">, </span><span class="s1">MAX</span><span class="s3">)</span>
    <span class="s1">a_len </span><span class="s3">= </span><span class="s1">str_len</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
    <span class="s1">sep_len </span><span class="s3">= </span><span class="s1">str_len</span><span class="s3">(</span><span class="s1">sep</span><span class="s3">)</span>

    <span class="s1">not_found </span><span class="s3">= </span><span class="s1">pos </span><span class="s3">&lt; </span><span class="s6">0</span>
    <span class="s1">buffersizes1 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">where</span><span class="s3">(</span><span class="s1">not_found</span><span class="s3">, </span><span class="s6">0</span><span class="s3">, </span><span class="s1">pos</span><span class="s3">)</span>
    <span class="s1">buffersizes3 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">where</span><span class="s3">(</span><span class="s1">not_found</span><span class="s3">, </span><span class="s1">a_len</span><span class="s3">, </span><span class="s1">a_len </span><span class="s3">- </span><span class="s1">pos </span><span class="s3">- </span><span class="s1">sep_len</span><span class="s3">)</span>

    <span class="s1">out_dtype </span><span class="s3">= </span><span class="s5">&quot;,&quot;</span><span class="s3">.</span><span class="s1">join</span><span class="s3">([</span><span class="s5">f&quot;</span><span class="s2">{</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">char</span><span class="s2">}{</span><span class="s1">n</span><span class="s2">}</span><span class="s5">&quot; </span><span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s3">(</span>
        <span class="s1">buffersizes1</span><span class="s3">.</span><span class="s1">max</span><span class="s3">(),</span>
        <span class="s6">1 </span><span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">all</span><span class="s3">(</span><span class="s1">not_found</span><span class="s3">) </span><span class="s2">else </span><span class="s1">sep_len</span><span class="s3">.</span><span class="s1">max</span><span class="s3">(),</span>
        <span class="s1">buffersizes3</span><span class="s3">.</span><span class="s1">max</span><span class="s3">(),</span>
    <span class="s3">)])</span>
    <span class="s1">shape </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">broadcast_shapes</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">sep</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">)</span>
    <span class="s1">out </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty_like</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">=</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">out_dtype</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">_rpartition_index</span><span class="s3">(</span>
        <span class="s1">a</span><span class="s3">, </span><span class="s1">sep</span><span class="s3">, </span><span class="s1">pos</span><span class="s3">, </span><span class="s1">out</span><span class="s3">=(</span><span class="s1">out</span><span class="s3">[</span><span class="s5">&quot;f0&quot;</span><span class="s3">], </span><span class="s1">out</span><span class="s3">[</span><span class="s5">&quot;f1&quot;</span><span class="s3">], </span><span class="s1">out</span><span class="s3">[</span><span class="s5">&quot;f2&quot;</span><span class="s3">]))</span>


<span class="s2">def </span><span class="s1">translate</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">table</span><span class="s3">, </span><span class="s1">deletechars</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    For each element in `a`, return a copy of the string where all 
    characters occurring in the optional argument `deletechars` are 
    removed, and the remaining characters have been mapped through the 
    given translation table. 
 
    Calls :meth:`str.translate` element-wise. 
 
    Parameters 
    ---------- 
    a : array-like, with `np.bytes_` or `np.str_` dtype 
 
    table : str of length 256 
 
    deletechars : str 
 
    Returns 
    ------- 
    out : ndarray 
        Output array of str or unicode, depending on input type 
 
    See Also 
    -------- 
    str.translate 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; a = np.array(['a1b c', '1bca', 'bca1']) 
    &gt;&gt;&gt; table = a[0].maketrans('abc', '123') 
    &gt;&gt;&gt; deletechars = ' ' 
    &gt;&gt;&gt; np.char.translate(a, table, deletechars) 
    array(['112 3', '1231', '2311'], dtype='&lt;U5') 
 
    &quot;&quot;&quot;</span>
    <span class="s1">a_arr </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">issubclass</span><span class="s3">(</span><span class="s1">a_arr</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">type</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">str_</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">_vec_string</span><span class="s3">(</span>
            <span class="s1">a_arr</span><span class="s3">, </span><span class="s1">a_arr</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s5">'translate'</span><span class="s3">, (</span><span class="s1">table</span><span class="s3">,))</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">_vec_string</span><span class="s3">(</span>
            <span class="s1">a_arr</span><span class="s3">,</span>
            <span class="s1">a_arr</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">,</span>
            <span class="s5">'translate'</span><span class="s3">,</span>
            <span class="s3">[</span><span class="s1">table</span><span class="s3">] + </span><span class="s1">_clean_args</span><span class="s3">(</span><span class="s1">deletechars</span><span class="s3">)</span>
        <span class="s3">)</span>
</pre>
</body>
</html>