<html>
<head>
<title>selectable.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #5f826b; font-style: italic;}
.s3 { color: #cf8e6d;}
.s4 { color: #bcbec4;}
.s5 { color: #6aab73;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
selectable.py</font>
</center></td></tr></table>
<pre><span class="s0"># sql/selectable.py</span>
<span class="s0"># Copyright (C) 2005-2024 the SQLAlchemy authors and contributors</span>
<span class="s0"># &lt;see AUTHORS file&gt;</span>
<span class="s0">#</span>
<span class="s0"># This module is part of SQLAlchemy and is released under</span>
<span class="s0"># the MIT License: https://www.opensource.org/licenses/mit-license.php</span>

<span class="s2">&quot;&quot;&quot;The :class:`_expression.FromClause` class of SQL expression elements, 
representing 
SQL tables and derived rowsets. 
 
&quot;&quot;&quot;</span>

<span class="s3">from </span><span class="s1">__future__ </span><span class="s3">import </span><span class="s1">annotations</span>

<span class="s3">import </span><span class="s1">collections</span>
<span class="s3">from </span><span class="s1">enum </span><span class="s3">import </span><span class="s1">Enum</span>
<span class="s3">import </span><span class="s1">itertools</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">AbstractSet</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Any </span><span class="s3">as </span><span class="s1">TODO_Any</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Any</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Callable</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">cast</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Dict</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Generic</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Iterable</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Iterator</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">List</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">NamedTuple</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">NoReturn</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Optional</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">overload</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Sequence</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Set</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Tuple</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Type</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">TYPE_CHECKING</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">TypeVar</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Union</span>

<span class="s3">from </span><span class="s4">. </span><span class="s3">import </span><span class="s1">cache_key</span>
<span class="s3">from </span><span class="s4">. </span><span class="s3">import </span><span class="s1">coercions</span>
<span class="s3">from </span><span class="s4">. </span><span class="s3">import </span><span class="s1">operators</span>
<span class="s3">from </span><span class="s4">. </span><span class="s3">import </span><span class="s1">roles</span>
<span class="s3">from </span><span class="s4">. </span><span class="s3">import </span><span class="s1">traversals</span>
<span class="s3">from </span><span class="s4">. </span><span class="s3">import </span><span class="s1">type_api</span>
<span class="s3">from </span><span class="s4">. </span><span class="s3">import </span><span class="s1">visitors</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">_typing </span><span class="s3">import </span><span class="s1">_ColumnsClauseArgument</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">_typing </span><span class="s3">import </span><span class="s1">_no_kw</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">_typing </span><span class="s3">import </span><span class="s1">_TP</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">_typing </span><span class="s3">import </span><span class="s1">is_column_element</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">_typing </span><span class="s3">import </span><span class="s1">is_select_statement</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">_typing </span><span class="s3">import </span><span class="s1">is_subquery</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">_typing </span><span class="s3">import </span><span class="s1">is_table</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">_typing </span><span class="s3">import </span><span class="s1">is_text_clause</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">annotation </span><span class="s3">import </span><span class="s1">Annotated</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">annotation </span><span class="s3">import </span><span class="s1">SupportsCloneAnnotations</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">base </span><span class="s3">import </span><span class="s1">_clone</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">base </span><span class="s3">import </span><span class="s1">_cloned_difference</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">base </span><span class="s3">import </span><span class="s1">_cloned_intersection</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">base </span><span class="s3">import </span><span class="s1">_entity_namespace_key</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">base </span><span class="s3">import </span><span class="s1">_EntityNamespace</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">base </span><span class="s3">import </span><span class="s1">_expand_cloned</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">base </span><span class="s3">import </span><span class="s1">_from_objects</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">base </span><span class="s3">import </span><span class="s1">_generative</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">base </span><span class="s3">import </span><span class="s1">_never_select_column</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">base </span><span class="s3">import </span><span class="s1">_NoArg</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">base </span><span class="s3">import </span><span class="s1">_select_iterables</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">base </span><span class="s3">import </span><span class="s1">CacheableOptions</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">base </span><span class="s3">import </span><span class="s1">ColumnCollection</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">base </span><span class="s3">import </span><span class="s1">ColumnSet</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">base </span><span class="s3">import </span><span class="s1">CompileState</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">base </span><span class="s3">import </span><span class="s1">DedupeColumnCollection</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">base </span><span class="s3">import </span><span class="s1">Executable</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">base </span><span class="s3">import </span><span class="s1">Generative</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">base </span><span class="s3">import </span><span class="s1">HasCompileState</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">base </span><span class="s3">import </span><span class="s1">HasMemoized</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">base </span><span class="s3">import </span><span class="s1">Immutable</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">coercions </span><span class="s3">import </span><span class="s1">_document_text_coercion</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">elements </span><span class="s3">import </span><span class="s1">_anonymous_label</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">elements </span><span class="s3">import </span><span class="s1">BindParameter</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">elements </span><span class="s3">import </span><span class="s1">BooleanClauseList</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">elements </span><span class="s3">import </span><span class="s1">ClauseElement</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">elements </span><span class="s3">import </span><span class="s1">ClauseList</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">elements </span><span class="s3">import </span><span class="s1">ColumnClause</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">elements </span><span class="s3">import </span><span class="s1">ColumnElement</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">elements </span><span class="s3">import </span><span class="s1">DQLDMLClauseElement</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">elements </span><span class="s3">import </span><span class="s1">GroupedElement</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">elements </span><span class="s3">import </span><span class="s1">literal_column</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">elements </span><span class="s3">import </span><span class="s1">TableValuedColumn</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">elements </span><span class="s3">import </span><span class="s1">UnaryExpression</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">operators </span><span class="s3">import </span><span class="s1">OperatorType</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">sqltypes </span><span class="s3">import </span><span class="s1">NULLTYPE</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">visitors </span><span class="s3">import </span><span class="s1">_TraverseInternalsType</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">visitors </span><span class="s3">import </span><span class="s1">InternalTraversal</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">visitors </span><span class="s3">import </span><span class="s1">prefix_anon_map</span>
<span class="s3">from </span><span class="s4">.. </span><span class="s3">import </span><span class="s1">exc</span>
<span class="s3">from </span><span class="s4">.. </span><span class="s3">import </span><span class="s1">util</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">util </span><span class="s3">import </span><span class="s1">HasMemoized_ro_memoized_attribute</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">util</span><span class="s4">.</span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Literal</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">util</span><span class="s4">.</span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Protocol</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">util</span><span class="s4">.</span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Self</span>

<span class="s1">and_ </span><span class="s4">= </span><span class="s1">BooleanClauseList</span><span class="s4">.</span><span class="s1">and_</span>

<span class="s1">_T </span><span class="s4">= </span><span class="s1">TypeVar</span><span class="s4">(</span><span class="s5">&quot;_T&quot;</span><span class="s4">, </span><span class="s1">bound</span><span class="s4">=</span><span class="s1">Any</span><span class="s4">)</span>

<span class="s3">if </span><span class="s1">TYPE_CHECKING</span><span class="s4">:</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">_typing </span><span class="s3">import </span><span class="s1">_ColumnExpressionArgument</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">_typing </span><span class="s3">import </span><span class="s1">_ColumnExpressionOrStrLabelArgument</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">_typing </span><span class="s3">import </span><span class="s1">_FromClauseArgument</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">_typing </span><span class="s3">import </span><span class="s1">_JoinTargetArgument</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">_typing </span><span class="s3">import </span><span class="s1">_LimitOffsetType</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">_typing </span><span class="s3">import </span><span class="s1">_MAYBE_ENTITY</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">_typing </span><span class="s3">import </span><span class="s1">_NOT_ENTITY</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">_typing </span><span class="s3">import </span><span class="s1">_OnClauseArgument</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">_typing </span><span class="s3">import </span><span class="s1">_SelectStatementForCompoundArgument</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">_typing </span><span class="s3">import </span><span class="s1">_T0</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">_typing </span><span class="s3">import </span><span class="s1">_T1</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">_typing </span><span class="s3">import </span><span class="s1">_T2</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">_typing </span><span class="s3">import </span><span class="s1">_T3</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">_typing </span><span class="s3">import </span><span class="s1">_T4</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">_typing </span><span class="s3">import </span><span class="s1">_T5</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">_typing </span><span class="s3">import </span><span class="s1">_T6</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">_typing </span><span class="s3">import </span><span class="s1">_T7</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">_typing </span><span class="s3">import </span><span class="s1">_TextCoercedExpressionArgument</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">_typing </span><span class="s3">import </span><span class="s1">_TypedColumnClauseArgument </span><span class="s3">as </span><span class="s1">_TCCA</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">_typing </span><span class="s3">import </span><span class="s1">_TypeEngineArgument</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">base </span><span class="s3">import </span><span class="s1">_AmbiguousTableNameMap</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">base </span><span class="s3">import </span><span class="s1">ExecutableOption</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">base </span><span class="s3">import </span><span class="s1">ReadOnlyColumnCollection</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">cache_key </span><span class="s3">import </span><span class="s1">_CacheKeyTraversalType</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">compiler </span><span class="s3">import </span><span class="s1">SQLCompiler</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">dml </span><span class="s3">import </span><span class="s1">Delete</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">dml </span><span class="s3">import </span><span class="s1">Update</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">elements </span><span class="s3">import </span><span class="s1">BinaryExpression</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">elements </span><span class="s3">import </span><span class="s1">KeyedColumnElement</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">elements </span><span class="s3">import </span><span class="s1">Label</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">elements </span><span class="s3">import </span><span class="s1">NamedColumn</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">elements </span><span class="s3">import </span><span class="s1">TextClause</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">functions </span><span class="s3">import </span><span class="s1">Function</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">schema </span><span class="s3">import </span><span class="s1">ForeignKey</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">schema </span><span class="s3">import </span><span class="s1">ForeignKeyConstraint</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">sqltypes </span><span class="s3">import </span><span class="s1">TableValueType</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">type_api </span><span class="s3">import </span><span class="s1">TypeEngine</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">visitors </span><span class="s3">import </span><span class="s1">_CloneCallableType</span>


<span class="s1">_ColumnsClauseElement </span><span class="s4">= </span><span class="s1">Union</span><span class="s4">[</span><span class="s5">&quot;FromClause&quot;</span><span class="s4">, </span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">], </span><span class="s5">&quot;TextClause&quot;</span><span class="s4">]</span>
<span class="s1">_LabelConventionCallable </span><span class="s4">= </span><span class="s1">Callable</span><span class="s4">[</span>
    <span class="s4">[</span><span class="s1">Union</span><span class="s4">[</span><span class="s5">&quot;ColumnElement[Any]&quot;</span><span class="s4">, </span><span class="s5">&quot;TextClause&quot;</span><span class="s4">]], </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]</span>
<span class="s4">]</span>


<span class="s3">class </span><span class="s1">_JoinTargetProtocol</span><span class="s4">(</span><span class="s1">Protocol</span><span class="s4">):</span>
    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">ro_non_memoized_property</span>
    <span class="s3">def </span><span class="s1">_from_objects</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; List</span><span class="s4">[</span><span class="s1">FromClause</span><span class="s4">]: ...</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">ro_non_memoized_property</span>
    <span class="s3">def </span><span class="s1">entity_namespace</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; _EntityNamespace</span><span class="s4">: ...</span>


<span class="s1">_JoinTargetElement </span><span class="s4">= </span><span class="s1">Union</span><span class="s4">[</span><span class="s5">&quot;FromClause&quot;</span><span class="s4">, </span><span class="s1">_JoinTargetProtocol</span><span class="s4">]</span>
<span class="s1">_OnClauseElement </span><span class="s4">= </span><span class="s1">Union</span><span class="s4">[</span><span class="s5">&quot;ColumnElement[bool]&quot;</span><span class="s4">, </span><span class="s1">_JoinTargetProtocol</span><span class="s4">]</span>

<span class="s1">_ForUpdateOfArgument </span><span class="s4">= </span><span class="s1">Union</span><span class="s4">[</span>
    <span class="s0"># single column, Table, ORM Entity</span>
    <span class="s1">Union</span><span class="s4">[</span>
        <span class="s5">&quot;_ColumnExpressionArgument[Any]&quot;</span><span class="s4">,</span>
        <span class="s5">&quot;_FromClauseArgument&quot;</span><span class="s4">,</span>
    <span class="s4">],</span>
    <span class="s0"># or sequence of single column elements</span>
    <span class="s1">Sequence</span><span class="s4">[</span><span class="s5">&quot;_ColumnExpressionArgument[Any]&quot;</span><span class="s4">],</span>
<span class="s4">]</span>


<span class="s1">_SetupJoinsElement </span><span class="s4">= </span><span class="s1">Tuple</span><span class="s4">[</span>
    <span class="s1">_JoinTargetElement</span><span class="s4">,</span>
    <span class="s1">Optional</span><span class="s4">[</span><span class="s1">_OnClauseElement</span><span class="s4">],</span>
    <span class="s1">Optional</span><span class="s4">[</span><span class="s5">&quot;FromClause&quot;</span><span class="s4">],</span>
    <span class="s1">Dict</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">Any</span><span class="s4">],</span>
<span class="s4">]</span>


<span class="s1">_SelectIterable </span><span class="s4">= </span><span class="s1">Iterable</span><span class="s4">[</span><span class="s1">Union</span><span class="s4">[</span><span class="s5">&quot;ColumnElement[Any]&quot;</span><span class="s4">, </span><span class="s5">&quot;TextClause&quot;</span><span class="s4">]]</span>


<span class="s3">class </span><span class="s1">_OffsetLimitParam</span><span class="s4">(</span><span class="s1">BindParameter</span><span class="s4">[</span><span class="s1">int</span><span class="s4">]):</span>
    <span class="s1">inherit_cache </span><span class="s4">= </span><span class="s3">True</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">_limit_offset_value</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Optional</span><span class="s4">[</span><span class="s1">int</span><span class="s4">]:</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">effective_value</span>


<span class="s3">class </span><span class="s1">ReturnsRows</span><span class="s4">(</span><span class="s1">roles</span><span class="s4">.</span><span class="s1">ReturnsRowsRole</span><span class="s4">, </span><span class="s1">DQLDMLClauseElement</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;The base-most class for Core constructs that have some concept of 
    columns that can represent rows. 
 
    While the SELECT statement and TABLE are the primary things we think 
    of in this category,  DML like INSERT, UPDATE and DELETE can also specify 
    RETURNING which means they can be used in CTEs and other forms, and 
    PostgreSQL has functions that return rows also. 
 
    .. versionadded:: 1.4 
 
    &quot;&quot;&quot;</span>

    <span class="s1">_is_returns_rows </span><span class="s4">= </span><span class="s3">True</span>

    <span class="s0"># sub-elements of returns_rows</span>
    <span class="s1">_is_from_clause </span><span class="s4">= </span><span class="s3">False</span>
    <span class="s1">_is_select_base </span><span class="s4">= </span><span class="s3">False</span>
    <span class="s1">_is_select_statement </span><span class="s4">= </span><span class="s3">False</span>
    <span class="s1">_is_lateral </span><span class="s4">= </span><span class="s3">False</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">selectable</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; ReturnsRows</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">ro_non_memoized_property</span>
    <span class="s3">def </span><span class="s1">_all_selected_columns</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; _SelectIterable</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;A sequence of column expression objects that represents the 
        &quot;selected&quot; columns of this :class:`_expression.ReturnsRows`. 
 
        This is typically equivalent to .exported_columns except it is 
        delivered in the form of a straight sequence and not  keyed 
        :class:`_expression.ColumnCollection`. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">is_derived_from</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">fromclause</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">FromClause</span><span class="s4">]) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Return ``True`` if this :class:`.ReturnsRows` is 
        'derived' from the given :class:`.FromClause`. 
 
        An example would be an Alias of a Table is derived from that Table. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">_generate_fromclause_column_proxies</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">fromclause</span><span class="s4">: </span><span class="s1">FromClause</span>
    <span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Populate columns into an :class:`.AliasedReturnsRows` object.&quot;&quot;&quot;</span>

        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">_refresh_for_new_column</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">column</span><span class="s4">: </span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;reset internal collections for an incoming column being added.&quot;&quot;&quot;</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">exported_columns</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; ReadOnlyColumnCollection</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">, </span><span class="s1">Any</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;A :class:`_expression.ColumnCollection` 
        that represents the &quot;exported&quot; 
        columns of this :class:`_expression.ReturnsRows`. 
 
        The &quot;exported&quot; columns represent the collection of 
        :class:`_expression.ColumnElement` 
        expressions that are rendered by this SQL 
        construct.   There are primary varieties which are the 
        &quot;FROM clause columns&quot; of a FROM clause, such as a table, join, 
        or subquery, the &quot;SELECTed columns&quot;, which are the columns in 
        the &quot;columns clause&quot; of a SELECT statement, and the RETURNING 
        columns in a DML statement.. 
 
        .. versionadded:: 1.4 
 
        .. seealso:: 
 
            :attr:`_expression.FromClause.exported_columns` 
 
            :attr:`_expression.SelectBase.exported_columns` 
        &quot;&quot;&quot;</span>

        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>


<span class="s3">class </span><span class="s1">ExecutableReturnsRows</span><span class="s4">(</span><span class="s1">Executable</span><span class="s4">, </span><span class="s1">ReturnsRows</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;base for executable statements that return rows.&quot;&quot;&quot;</span>


<span class="s3">class </span><span class="s1">TypedReturnsRows</span><span class="s4">(</span><span class="s1">ExecutableReturnsRows</span><span class="s4">, </span><span class="s1">Generic</span><span class="s4">[</span><span class="s1">_TP</span><span class="s4">]):</span>
    <span class="s2">&quot;&quot;&quot;base for executable statements that return rows.&quot;&quot;&quot;</span>


<span class="s3">class </span><span class="s1">Selectable</span><span class="s4">(</span><span class="s1">ReturnsRows</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Mark a class as being selectable.&quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;selectable&quot;</span>

    <span class="s1">is_selectable </span><span class="s4">= </span><span class="s3">True</span>

    <span class="s3">def </span><span class="s1">_refresh_for_new_column</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">column</span><span class="s4">: </span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">lateral</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">name</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">) </span><span class="s1">-&gt; LateralFromClause</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Return a LATERAL alias of this :class:`_expression.Selectable`. 
 
        The return value is the :class:`_expression.Lateral` construct also 
        provided by the top-level :func:`_expression.lateral` function. 
 
        .. seealso:: 
 
            :ref:`tutorial_lateral_correlation` -  overview of usage. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">Lateral</span><span class="s4">.</span><span class="s1">_construct</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">name</span><span class="s4">=</span><span class="s1">name</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">deprecated</span><span class="s4">(</span>
        <span class="s5">&quot;1.4&quot;</span><span class="s4">,</span>
        <span class="s1">message</span><span class="s4">=</span><span class="s5">&quot;The :meth:`.Selectable.replace_selectable` method is &quot;</span>
        <span class="s5">&quot;deprecated, and will be removed in a future release.  Similar &quot;</span>
        <span class="s5">&quot;functionality is available via the sqlalchemy.sql.visitors module.&quot;</span><span class="s4">,</span>
    <span class="s4">)</span>
    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">preload_module</span><span class="s4">(</span><span class="s5">&quot;sqlalchemy.sql.util&quot;</span><span class="s4">)</span>
    <span class="s3">def </span><span class="s1">replace_selectable</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">old</span><span class="s4">: </span><span class="s1">FromClause</span><span class="s4">, </span><span class="s1">alias</span><span class="s4">: </span><span class="s1">Alias</span><span class="s4">) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Replace all occurrences of :class:`_expression.FromClause` 
        'old' with the given :class:`_expression.Alias` 
        object, returning a copy of this :class:`_expression.FromClause`. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">util</span><span class="s4">.</span><span class="s1">preloaded</span><span class="s4">.</span><span class="s1">sql_util</span><span class="s4">.</span><span class="s1">ClauseAdapter</span><span class="s4">(</span><span class="s1">alias</span><span class="s4">).</span><span class="s1">traverse</span><span class="s4">(</span><span class="s1">self</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">corresponding_column</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">column</span><span class="s4">: </span><span class="s1">KeyedColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">], </span><span class="s1">require_embedded</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span>
    <span class="s4">) </span><span class="s1">-&gt; Optional</span><span class="s4">[</span><span class="s1">KeyedColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]:</span>
        <span class="s2">&quot;&quot;&quot;Given a :class:`_expression.ColumnElement`, return the exported 
        :class:`_expression.ColumnElement` object from the 
        :attr:`_expression.Selectable.exported_columns` 
        collection of this :class:`_expression.Selectable` 
        which corresponds to that 
        original :class:`_expression.ColumnElement` via a common ancestor 
        column. 
 
        :param column: the target :class:`_expression.ColumnElement` 
                      to be matched. 
 
        :param require_embedded: only return corresponding columns for 
         the given :class:`_expression.ColumnElement`, if the given 
         :class:`_expression.ColumnElement` 
         is actually present within a sub-element 
         of this :class:`_expression.Selectable`. 
         Normally the column will match if 
         it merely shares a common ancestor with one of the exported 
         columns of this :class:`_expression.Selectable`. 
 
        .. seealso:: 
 
            :attr:`_expression.Selectable.exported_columns` - the 
            :class:`_expression.ColumnCollection` 
            that is used for the operation. 
 
            :meth:`_expression.ColumnCollection.corresponding_column` 
            - implementation 
            method. 
 
        &quot;&quot;&quot;</span>

        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">exported_columns</span><span class="s4">.</span><span class="s1">corresponding_column</span><span class="s4">(</span>
            <span class="s1">column</span><span class="s4">, </span><span class="s1">require_embedded</span>
        <span class="s4">)</span>


<span class="s3">class </span><span class="s1">HasPrefixes</span><span class="s4">:</span>
    <span class="s1">_prefixes</span><span class="s4">: </span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">DQLDMLClauseElement</span><span class="s4">, </span><span class="s1">str</span><span class="s4">], ...] = ()</span>

    <span class="s1">_has_prefixes_traverse_internals</span><span class="s4">: </span><span class="s1">_TraverseInternalsType </span><span class="s4">= [</span>
        <span class="s4">(</span><span class="s5">&quot;_prefixes&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_prefix_sequence</span><span class="s4">)</span>
    <span class="s4">]</span>

    <span class="s4">@</span><span class="s1">_generative</span>
    <span class="s4">@</span><span class="s1">_document_text_coercion</span><span class="s4">(</span>
        <span class="s5">&quot;prefixes&quot;</span><span class="s4">,</span>
        <span class="s5">&quot;:meth:`_expression.HasPrefixes.prefix_with`&quot;</span><span class="s4">,</span>
        <span class="s5">&quot;:paramref:`.HasPrefixes.prefix_with.*prefixes`&quot;</span><span class="s4">,</span>
    <span class="s4">)</span>
    <span class="s3">def </span><span class="s1">prefix_with</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s4">*</span><span class="s1">prefixes</span><span class="s4">: </span><span class="s1">_TextCoercedExpressionArgument</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">],</span>
        <span class="s1">dialect</span><span class="s4">: </span><span class="s1">str </span><span class="s4">= </span><span class="s5">&quot;*&quot;</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s2">r&quot;&quot;&quot;Add one or more expressions following the statement keyword, i.e. 
        SELECT, INSERT, UPDATE, or DELETE. Generative. 
 
        This is used to support backend-specific prefix keywords such as those 
        provided by MySQL. 
 
        E.g.:: 
 
            stmt = table.insert().prefix_with(&quot;LOW_PRIORITY&quot;, dialect=&quot;mysql&quot;) 
 
            # MySQL 5.7 optimizer hints 
            stmt = select(table).prefix_with( 
                &quot;/*+ BKA(t1) */&quot;, dialect=&quot;mysql&quot;) 
 
        Multiple prefixes can be specified by multiple calls 
        to :meth:`_expression.HasPrefixes.prefix_with`. 
 
        :param \*prefixes: textual or :class:`_expression.ClauseElement` 
         construct which 
         will be rendered following the INSERT, UPDATE, or DELETE 
         keyword. 
        :param dialect: optional string dialect name which will 
         limit rendering of this prefix to only that dialect. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_prefixes </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_prefixes </span><span class="s4">+ </span><span class="s1">tuple</span><span class="s4">(</span>
            <span class="s4">[</span>
                <span class="s4">(</span><span class="s1">coercions</span><span class="s4">.</span><span class="s1">expect</span><span class="s4">(</span><span class="s1">roles</span><span class="s4">.</span><span class="s1">StatementOptionRole</span><span class="s4">, </span><span class="s1">p</span><span class="s4">), </span><span class="s1">dialect</span><span class="s4">)</span>
                <span class="s3">for </span><span class="s1">p </span><span class="s3">in </span><span class="s1">prefixes</span>
            <span class="s4">]</span>
        <span class="s4">)</span>
        <span class="s3">return </span><span class="s1">self</span>


<span class="s3">class </span><span class="s1">HasSuffixes</span><span class="s4">:</span>
    <span class="s1">_suffixes</span><span class="s4">: </span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">DQLDMLClauseElement</span><span class="s4">, </span><span class="s1">str</span><span class="s4">], ...] = ()</span>

    <span class="s1">_has_suffixes_traverse_internals</span><span class="s4">: </span><span class="s1">_TraverseInternalsType </span><span class="s4">= [</span>
        <span class="s4">(</span><span class="s5">&quot;_suffixes&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_prefix_sequence</span><span class="s4">)</span>
    <span class="s4">]</span>

    <span class="s4">@</span><span class="s1">_generative</span>
    <span class="s4">@</span><span class="s1">_document_text_coercion</span><span class="s4">(</span>
        <span class="s5">&quot;suffixes&quot;</span><span class="s4">,</span>
        <span class="s5">&quot;:meth:`_expression.HasSuffixes.suffix_with`&quot;</span><span class="s4">,</span>
        <span class="s5">&quot;:paramref:`.HasSuffixes.suffix_with.*suffixes`&quot;</span><span class="s4">,</span>
    <span class="s4">)</span>
    <span class="s3">def </span><span class="s1">suffix_with</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s4">*</span><span class="s1">suffixes</span><span class="s4">: </span><span class="s1">_TextCoercedExpressionArgument</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">],</span>
        <span class="s1">dialect</span><span class="s4">: </span><span class="s1">str </span><span class="s4">= </span><span class="s5">&quot;*&quot;</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s2">r&quot;&quot;&quot;Add one or more expressions following the statement as a whole. 
 
        This is used to support backend-specific suffix keywords on 
        certain constructs. 
 
        E.g.:: 
 
            stmt = select(col1, col2).cte().suffix_with( 
                &quot;cycle empno set y_cycle to 1 default 0&quot;, dialect=&quot;oracle&quot;) 
 
        Multiple suffixes can be specified by multiple calls 
        to :meth:`_expression.HasSuffixes.suffix_with`. 
 
        :param \*suffixes: textual or :class:`_expression.ClauseElement` 
         construct which 
         will be rendered following the target clause. 
        :param dialect: Optional string dialect name which will 
         limit rendering of this suffix to only that dialect. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_suffixes </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_suffixes </span><span class="s4">+ </span><span class="s1">tuple</span><span class="s4">(</span>
            <span class="s4">[</span>
                <span class="s4">(</span><span class="s1">coercions</span><span class="s4">.</span><span class="s1">expect</span><span class="s4">(</span><span class="s1">roles</span><span class="s4">.</span><span class="s1">StatementOptionRole</span><span class="s4">, </span><span class="s1">p</span><span class="s4">), </span><span class="s1">dialect</span><span class="s4">)</span>
                <span class="s3">for </span><span class="s1">p </span><span class="s3">in </span><span class="s1">suffixes</span>
            <span class="s4">]</span>
        <span class="s4">)</span>
        <span class="s3">return </span><span class="s1">self</span>


<span class="s3">class </span><span class="s1">HasHints</span><span class="s4">:</span>
    <span class="s1">_hints</span><span class="s4">: </span><span class="s1">util</span><span class="s4">.</span><span class="s1">immutabledict</span><span class="s4">[</span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">FromClause</span><span class="s4">, </span><span class="s1">str</span><span class="s4">], </span><span class="s1">str</span><span class="s4">] = (</span>
        <span class="s1">util</span><span class="s4">.</span><span class="s1">immutabledict</span><span class="s4">()</span>
    <span class="s4">)</span>
    <span class="s1">_statement_hints</span><span class="s4">: </span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">str</span><span class="s4">], ...] = ()</span>

    <span class="s1">_has_hints_traverse_internals</span><span class="s4">: </span><span class="s1">_TraverseInternalsType </span><span class="s4">= [</span>
        <span class="s4">(</span><span class="s5">&quot;_statement_hints&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_statement_hint_list</span><span class="s4">),</span>
        <span class="s4">(</span><span class="s5">&quot;_hints&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_table_hint_list</span><span class="s4">),</span>
    <span class="s4">]</span>

    <span class="s4">@</span><span class="s1">_generative</span>
    <span class="s3">def </span><span class="s1">with_statement_hint</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">text</span><span class="s4">: </span><span class="s1">str</span><span class="s4">, </span><span class="s1">dialect_name</span><span class="s4">: </span><span class="s1">str </span><span class="s4">= </span><span class="s5">&quot;*&quot;</span><span class="s4">) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Add a statement hint to this :class:`_expression.Select` or 
        other selectable object. 
 
        .. tip:: 
 
            :meth:`_expression.Select.with_statement_hint` generally adds hints 
            **at the trailing end** of a SELECT statement.  To place 
            dialect-specific hints such as optimizer hints at the **front** of 
            the SELECT statement after the SELECT keyword, use the 
            :meth:`_expression.Select.prefix_with` method for an open-ended 
            space, or for table-specific hints the 
            :meth:`_expression.Select.with_hint` may be used, which places 
            hints in a dialect-specific location. 
 
        This method is similar to :meth:`_expression.Select.with_hint` except 
        that it does not require an individual table, and instead applies to 
        the statement as a whole. 
 
        Hints here are specific to the backend database and may include 
        directives such as isolation levels, file directives, fetch directives, 
        etc. 
 
        .. seealso:: 
 
            :meth:`_expression.Select.with_hint` 
 
            :meth:`_expression.Select.prefix_with` - generic SELECT prefixing 
            which also can suit some database-specific HINT syntaxes such as 
            MySQL or Oracle optimizer hints 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_with_hint</span><span class="s4">(</span><span class="s3">None</span><span class="s4">, </span><span class="s1">text</span><span class="s4">, </span><span class="s1">dialect_name</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">_generative</span>
    <span class="s3">def </span><span class="s1">with_hint</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">selectable</span><span class="s4">: </span><span class="s1">_FromClauseArgument</span><span class="s4">,</span>
        <span class="s1">text</span><span class="s4">: </span><span class="s1">str</span><span class="s4">,</span>
        <span class="s1">dialect_name</span><span class="s4">: </span><span class="s1">str </span><span class="s4">= </span><span class="s5">&quot;*&quot;</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s2">r&quot;&quot;&quot;Add an indexing or other executional context hint for the given 
        selectable to this :class:`_expression.Select` or other selectable 
        object. 
 
        .. tip:: 
 
            The :meth:`_expression.Select.with_hint` method adds hints that are 
            **specific to a single table** to a statement, in a location that 
            is **dialect-specific**.  To add generic optimizer hints to the 
            **beginning** of a statement ahead of the SELECT keyword such as 
            for MySQL or Oracle, use the :meth:`_expression.Select.prefix_with` 
            method.  To add optimizer hints to the **end** of a statement such 
            as for PostgreSQL, use the 
            :meth:`_expression.Select.with_statement_hint` method. 
 
        The text of the hint is rendered in the appropriate 
        location for the database backend in use, relative 
        to the given :class:`_schema.Table` or :class:`_expression.Alias` 
        passed as the 
        ``selectable`` argument. The dialect implementation 
        typically uses Python string substitution syntax 
        with the token ``%(name)s`` to render the name of 
        the table or alias. E.g. when using Oracle, the 
        following:: 
 
            select(mytable).\ 
                with_hint(mytable, &quot;index(%(name)s ix_mytable)&quot;) 
 
        Would render SQL as:: 
 
            select /*+ index(mytable ix_mytable) */ ... from mytable 
 
        The ``dialect_name`` option will limit the rendering of a particular 
        hint to a particular backend. Such as, to add hints for both Oracle 
        and Sybase simultaneously:: 
 
            select(mytable).\ 
                with_hint(mytable, &quot;index(%(name)s ix_mytable)&quot;, 'oracle').\ 
                with_hint(mytable, &quot;WITH INDEX ix_mytable&quot;, 'mssql') 
 
        .. seealso:: 
 
            :meth:`_expression.Select.with_statement_hint` 
 
            :meth:`_expression.Select.prefix_with` - generic SELECT prefixing 
            which also can suit some database-specific HINT syntaxes such as 
            MySQL or Oracle optimizer hints 
 
        &quot;&quot;&quot;</span>

        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_with_hint</span><span class="s4">(</span><span class="s1">selectable</span><span class="s4">, </span><span class="s1">text</span><span class="s4">, </span><span class="s1">dialect_name</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_with_hint</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">selectable</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_FromClauseArgument</span><span class="s4">],</span>
        <span class="s1">text</span><span class="s4">: </span><span class="s1">str</span><span class="s4">,</span>
        <span class="s1">dialect_name</span><span class="s4">: </span><span class="s1">str</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">selectable </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_statement_hints </span><span class="s4">+= ((</span><span class="s1">dialect_name</span><span class="s4">, </span><span class="s1">text</span><span class="s4">),)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_hints </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_hints</span><span class="s4">.</span><span class="s1">union</span><span class="s4">(</span>
                <span class="s4">{</span>
                    <span class="s4">(</span>
                        <span class="s1">coercions</span><span class="s4">.</span><span class="s1">expect</span><span class="s4">(</span><span class="s1">roles</span><span class="s4">.</span><span class="s1">FromClauseRole</span><span class="s4">, </span><span class="s1">selectable</span><span class="s4">),</span>
                        <span class="s1">dialect_name</span><span class="s4">,</span>
                    <span class="s4">): </span><span class="s1">text</span>
                <span class="s4">}</span>
            <span class="s4">)</span>
        <span class="s3">return </span><span class="s1">self</span>


<span class="s3">class </span><span class="s1">FromClause</span><span class="s4">(</span><span class="s1">roles</span><span class="s4">.</span><span class="s1">AnonymizedFromClauseRole</span><span class="s4">, </span><span class="s1">Selectable</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Represent an element that can be used within the ``FROM`` 
    clause of a ``SELECT`` statement. 
 
    The most common forms of :class:`_expression.FromClause` are the 
    :class:`_schema.Table` and the :func:`_expression.select` constructs.  Key 
    features common to all :class:`_expression.FromClause` objects include: 
 
    * a :attr:`.c` collection, which provides per-name access to a collection 
      of :class:`_expression.ColumnElement` objects. 
    * a :attr:`.primary_key` attribute, which is a collection of all those 
      :class:`_expression.ColumnElement` 
      objects that indicate the ``primary_key`` flag. 
    * Methods to generate various derivations of a &quot;from&quot; clause, including 
      :meth:`_expression.FromClause.alias`, 
      :meth:`_expression.FromClause.join`, 
      :meth:`_expression.FromClause.select`. 
 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;fromclause&quot;</span>
    <span class="s1">named_with_column </span><span class="s4">= </span><span class="s3">False</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">ro_non_memoized_property</span>
    <span class="s3">def </span><span class="s1">_hide_froms</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Iterable</span><span class="s4">[</span><span class="s1">FromClause</span><span class="s4">]:</span>
        <span class="s3">return </span><span class="s4">()</span>

    <span class="s1">_is_clone_of</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">FromClause</span><span class="s4">]</span>

    <span class="s1">_columns</span><span class="s4">: </span><span class="s1">ColumnCollection</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">, </span><span class="s1">Any</span><span class="s4">]</span>

    <span class="s1">schema</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span>
    <span class="s5">&quot;&quot;&quot;Define the 'schema' attribute for this :class:`_expression.FromClause`. 
 
    This is typically ``None`` for most objects except that of 
    :class:`_schema.Table`, where it is taken as the value of the 
    :paramref:`_schema.Table.schema` argument. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">is_selectable </span><span class="s4">= </span><span class="s3">True</span>
    <span class="s1">_is_from_clause </span><span class="s4">= </span><span class="s3">True</span>
    <span class="s1">_is_join </span><span class="s4">= </span><span class="s3">False</span>

    <span class="s1">_use_schema_map </span><span class="s4">= </span><span class="s3">False</span>

    <span class="s3">def </span><span class="s1">select</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Select</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]:</span>
        <span class="s2">r&quot;&quot;&quot;Return a SELECT of this :class:`_expression.FromClause`. 
 
 
        e.g.:: 
 
            stmt = some_table.select().where(some_table.c.id == 5) 
 
        .. seealso:: 
 
            :func:`_expression.select` - general purpose 
            method which allows for arbitrary column lists. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">Select</span><span class="s4">(</span><span class="s1">self</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">join</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">right</span><span class="s4">: </span><span class="s1">_FromClauseArgument</span><span class="s4">,</span>
        <span class="s1">onclause</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_ColumnExpressionArgument</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">]] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">isouter</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
        <span class="s1">full</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; Join</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Return a :class:`_expression.Join` from this 
        :class:`_expression.FromClause` 
        to another :class:`FromClause`. 
 
        E.g.:: 
 
            from sqlalchemy import join 
 
            j = user_table.join(address_table, 
                            user_table.c.id == address_table.c.user_id) 
            stmt = select(user_table).select_from(j) 
 
        would emit SQL along the lines of:: 
 
            SELECT user.id, user.name FROM user 
            JOIN address ON user.id = address.user_id 
 
        :param right: the right side of the join; this is any 
         :class:`_expression.FromClause` object such as a 
         :class:`_schema.Table` object, and 
         may also be a selectable-compatible object such as an ORM-mapped 
         class. 
 
        :param onclause: a SQL expression representing the ON clause of the 
         join.  If left at ``None``, :meth:`_expression.FromClause.join` 
         will attempt to 
         join the two tables based on a foreign key relationship. 
 
        :param isouter: if True, render a LEFT OUTER JOIN, instead of JOIN. 
 
        :param full: if True, render a FULL OUTER JOIN, instead of LEFT OUTER 
         JOIN.  Implies :paramref:`.FromClause.join.isouter`. 
 
        .. seealso:: 
 
            :func:`_expression.join` - standalone function 
 
            :class:`_expression.Join` - the type of object produced 
 
        &quot;&quot;&quot;</span>

        <span class="s3">return </span><span class="s1">Join</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">right</span><span class="s4">, </span><span class="s1">onclause</span><span class="s4">, </span><span class="s1">isouter</span><span class="s4">, </span><span class="s1">full</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">outerjoin</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">right</span><span class="s4">: </span><span class="s1">_FromClauseArgument</span><span class="s4">,</span>
        <span class="s1">onclause</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_ColumnExpressionArgument</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">]] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">full</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; Join</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Return a :class:`_expression.Join` from this 
        :class:`_expression.FromClause` 
        to another :class:`FromClause`, with the &quot;isouter&quot; flag set to 
        True. 
 
        E.g.:: 
 
            from sqlalchemy import outerjoin 
 
            j = user_table.outerjoin(address_table, 
                            user_table.c.id == address_table.c.user_id) 
 
        The above is equivalent to:: 
 
            j = user_table.join( 
                address_table, 
                user_table.c.id == address_table.c.user_id, 
                isouter=True) 
 
        :param right: the right side of the join; this is any 
         :class:`_expression.FromClause` object such as a 
         :class:`_schema.Table` object, and 
         may also be a selectable-compatible object such as an ORM-mapped 
         class. 
 
        :param onclause: a SQL expression representing the ON clause of the 
         join.  If left at ``None``, :meth:`_expression.FromClause.join` 
         will attempt to 
         join the two tables based on a foreign key relationship. 
 
        :param full: if True, render a FULL OUTER JOIN, instead of 
         LEFT OUTER JOIN. 
 
        .. seealso:: 
 
            :meth:`_expression.FromClause.join` 
 
            :class:`_expression.Join` 
 
        &quot;&quot;&quot;</span>

        <span class="s3">return </span><span class="s1">Join</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">right</span><span class="s4">, </span><span class="s1">onclause</span><span class="s4">, </span><span class="s3">True</span><span class="s4">, </span><span class="s1">full</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">alias</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">name</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">, </span><span class="s1">flat</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span>
    <span class="s4">) </span><span class="s1">-&gt; NamedFromClause</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Return an alias of this :class:`_expression.FromClause`. 
 
        E.g.:: 
 
            a2 = some_table.alias('a2') 
 
        The above code creates an :class:`_expression.Alias` 
        object which can be used 
        as a FROM clause in any SELECT statement. 
 
        .. seealso:: 
 
            :ref:`tutorial_using_aliases` 
 
            :func:`_expression.alias` 
 
        &quot;&quot;&quot;</span>

        <span class="s3">return </span><span class="s1">Alias</span><span class="s4">.</span><span class="s1">_construct</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">name</span><span class="s4">=</span><span class="s1">name</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">tablesample</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">sampling</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span><span class="s1">float</span><span class="s4">, </span><span class="s1">Function</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]],</span>
        <span class="s1">name</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">seed</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">roles</span><span class="s4">.</span><span class="s1">ExpressionElementRole</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]] = </span><span class="s3">None</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; TableSample</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Return a TABLESAMPLE alias of this :class:`_expression.FromClause`. 
 
        The return value is the :class:`_expression.TableSample` 
        construct also 
        provided by the top-level :func:`_expression.tablesample` function. 
 
        .. seealso:: 
 
            :func:`_expression.tablesample` - usage guidelines and parameters 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">TableSample</span><span class="s4">.</span><span class="s1">_construct</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">, </span><span class="s1">sampling</span><span class="s4">=</span><span class="s1">sampling</span><span class="s4">, </span><span class="s1">name</span><span class="s4">=</span><span class="s1">name</span><span class="s4">, </span><span class="s1">seed</span><span class="s4">=</span><span class="s1">seed</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">is_derived_from</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">fromclause</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">FromClause</span><span class="s4">]) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Return ``True`` if this :class:`_expression.FromClause` is 
        'derived' from the given ``FromClause``. 
 
        An example would be an Alias of a Table is derived from that Table. 
 
        &quot;&quot;&quot;</span>
        <span class="s0"># this is essentially an &quot;identity&quot; check in the base class.</span>
        <span class="s0"># Other constructs override this to traverse through</span>
        <span class="s0"># contained elements.</span>
        <span class="s3">return </span><span class="s1">fromclause </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_cloned_set</span>

    <span class="s3">def </span><span class="s1">_is_lexical_equivalent</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">: </span><span class="s1">FromClause</span><span class="s4">) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Return ``True`` if this :class:`_expression.FromClause` and 
        the other represent the same lexical identity. 
 
        This tests if either one is a copy of the other, or 
        if they are the same via annotation identity. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">bool</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_cloned_set</span><span class="s4">.</span><span class="s1">intersection</span><span class="s4">(</span><span class="s1">other</span><span class="s4">.</span><span class="s1">_cloned_set</span><span class="s4">))</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">ro_non_memoized_property</span>
    <span class="s3">def </span><span class="s1">description</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; str</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;A brief description of this :class:`_expression.FromClause`. 
 
        Used primarily for error message formatting. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">getattr</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s5">&quot;name&quot;</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">__class__</span><span class="s4">.</span><span class="s1">__name__ </span><span class="s4">+ </span><span class="s5">&quot; object&quot;</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_generate_fromclause_column_proxies</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">fromclause</span><span class="s4">: </span><span class="s1">FromClause</span>
    <span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s1">fromclause</span><span class="s4">.</span><span class="s1">_columns</span><span class="s4">.</span><span class="s1">_populate_separate_keys</span><span class="s4">(</span>
            <span class="s1">col</span><span class="s4">.</span><span class="s1">_make_proxy</span><span class="s4">(</span><span class="s1">fromclause</span><span class="s4">) </span><span class="s3">for </span><span class="s1">col </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">c</span>
        <span class="s4">)</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">ro_non_memoized_property</span>
    <span class="s3">def </span><span class="s1">exported_columns</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; ReadOnlyColumnCollection</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">KeyedColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]:</span>
        <span class="s2">&quot;&quot;&quot;A :class:`_expression.ColumnCollection` 
        that represents the &quot;exported&quot; 
        columns of this :class:`_expression.Selectable`. 
 
        The &quot;exported&quot; columns for a :class:`_expression.FromClause` 
        object are synonymous 
        with the :attr:`_expression.FromClause.columns` collection. 
 
        .. versionadded:: 1.4 
 
        .. seealso:: 
 
            :attr:`_expression.Selectable.exported_columns` 
 
            :attr:`_expression.SelectBase.exported_columns` 
 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">c</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">ro_non_memoized_property</span>
    <span class="s3">def </span><span class="s1">columns</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; ReadOnlyColumnCollection</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">KeyedColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]:</span>
        <span class="s2">&quot;&quot;&quot;A named-based collection of :class:`_expression.ColumnElement` 
        objects maintained by this :class:`_expression.FromClause`. 
 
        The :attr:`.columns`, or :attr:`.c` collection, is the gateway 
        to the construction of SQL expressions using table-bound or 
        other selectable-bound columns:: 
 
            select(mytable).where(mytable.c.somecolumn == 5) 
 
        :return: a :class:`.ColumnCollection` object. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">c</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">ro_memoized_property</span>
    <span class="s3">def </span><span class="s1">c</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; ReadOnlyColumnCollection</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">KeyedColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]:</span>
        <span class="s2">&quot;&quot;&quot; 
        A synonym for :attr:`.FromClause.columns` 
 
        :return: a :class:`.ColumnCollection` 
 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s5">&quot;_columns&quot; </span><span class="s3">not in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">__dict__</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_init_collections</span><span class="s4">()</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_populate_column_collection</span><span class="s4">()</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_columns</span><span class="s4">.</span><span class="s1">as_readonly</span><span class="s4">()</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">ro_non_memoized_property</span>
    <span class="s3">def </span><span class="s1">entity_namespace</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; _EntityNamespace</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Return a namespace used for name-based access in SQL expressions. 
 
        This is the namespace that is used to resolve &quot;filter_by()&quot; type 
        expressions, such as:: 
 
            stmt.filter_by(address='some address') 
 
        It defaults to the ``.c`` collection, however internally it can 
        be overridden using the &quot;entity_namespace&quot; annotation to deliver 
        alternative results. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">c</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">ro_memoized_property</span>
    <span class="s3">def </span><span class="s1">primary_key</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Iterable</span><span class="s4">[</span><span class="s1">NamedColumn</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]:</span>
        <span class="s2">&quot;&quot;&quot;Return the iterable collection of :class:`_schema.Column` objects 
        which comprise the primary key of this :class:`_selectable.FromClause`. 
 
        For a :class:`_schema.Table` object, this collection is represented 
        by the :class:`_schema.PrimaryKeyConstraint` which itself is an 
        iterable collection of :class:`_schema.Column` objects. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_init_collections</span><span class="s4">()</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_populate_column_collection</span><span class="s4">()</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">primary_key</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">ro_memoized_property</span>
    <span class="s3">def </span><span class="s1">foreign_keys</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Iterable</span><span class="s4">[</span><span class="s1">ForeignKey</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;Return the collection of :class:`_schema.ForeignKey` marker objects 
        which this FromClause references. 
 
        Each :class:`_schema.ForeignKey` is a member of a 
        :class:`_schema.Table`-wide 
        :class:`_schema.ForeignKeyConstraint`. 
 
        .. seealso:: 
 
            :attr:`_schema.Table.foreign_key_constraints` 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_init_collections</span><span class="s4">()</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_populate_column_collection</span><span class="s4">()</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">foreign_keys</span>

    <span class="s3">def </span><span class="s1">_reset_column_collection</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Reset the attributes linked to the ``FromClause.c`` attribute. 
 
        This collection is separate from all the other memoized things 
        as it has shown to be sensitive to being cleared out in situations 
        where enclosing code, typically in a replacement traversal scenario, 
        has already established strong relationships 
        with the exported columns. 
 
        The collection is cleared for the case where a table is having a 
        column added to it as well as within a Join during copy internals. 
 
        &quot;&quot;&quot;</span>

        <span class="s3">for </span><span class="s1">key </span><span class="s3">in </span><span class="s4">[</span><span class="s5">&quot;_columns&quot;</span><span class="s4">, </span><span class="s5">&quot;columns&quot;</span><span class="s4">, </span><span class="s5">&quot;c&quot;</span><span class="s4">, </span><span class="s5">&quot;primary_key&quot;</span><span class="s4">, </span><span class="s5">&quot;foreign_keys&quot;</span><span class="s4">]:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">__dict__</span><span class="s4">.</span><span class="s1">pop</span><span class="s4">(</span><span class="s1">key</span><span class="s4">, </span><span class="s3">None</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">ro_non_memoized_property</span>
    <span class="s3">def </span><span class="s1">_select_iterable</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; _SelectIterable</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s4">(</span><span class="s1">c </span><span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">c </span><span class="s3">if not </span><span class="s1">_never_select_column</span><span class="s4">(</span><span class="s1">c</span><span class="s4">))</span>

    <span class="s3">def </span><span class="s1">_init_collections</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s3">assert </span><span class="s5">&quot;_columns&quot; </span><span class="s3">not in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">__dict__</span>
        <span class="s3">assert </span><span class="s5">&quot;primary_key&quot; </span><span class="s3">not in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">__dict__</span>
        <span class="s3">assert </span><span class="s5">&quot;foreign_keys&quot; </span><span class="s3">not in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">__dict__</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">_columns </span><span class="s4">= </span><span class="s1">ColumnCollection</span><span class="s4">()</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">primary_key </span><span class="s4">= </span><span class="s1">ColumnSet</span><span class="s4">()  </span><span class="s0"># type: ignore</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">foreign_keys </span><span class="s4">= </span><span class="s1">set</span><span class="s4">()  </span><span class="s0"># type: ignore</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">_cols_populated</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s5">&quot;_columns&quot; </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">__dict__</span>

    <span class="s3">def </span><span class="s1">_populate_column_collection</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Called on subclasses to establish the .c collection. 
 
        Each implementation has a different way of establishing 
        this collection. 
 
        &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">_refresh_for_new_column</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">column</span><span class="s4">: </span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Given a column added to the .c collection of an underlying 
        selectable, produce the local version of that column, assuming this 
        selectable ultimately should proxy this column. 
 
        this is used to &quot;ping&quot; a derived selectable to add a new column 
        to its .c. collection when a Column has been added to one of the 
        Table objects it ultimately derives from. 
 
        If the given selectable hasn't populated its .c. collection yet, 
        it should at least pass on the message to the contained selectables, 
        but it will return None. 
 
        This method is currently used by Declarative to allow Table 
        columns to be added to a partially constructed inheritance 
        mapping that may have already produced joins.  The method 
        isn't public right now, as the full span of implications 
        and/or caveats aren't yet clear. 
 
        It's also possible that this functionality could be invoked by 
        default via an event, which would require that 
        selectables maintain a weak referencing collection of all 
        derivations. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_reset_column_collection</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">_anonymous_fromclause</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, *, </span><span class="s1">name</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">, </span><span class="s1">flat</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span>
    <span class="s4">) </span><span class="s1">-&gt; FromClause</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">alias</span><span class="s4">(</span><span class="s1">name</span><span class="s4">=</span><span class="s1">name</span><span class="s4">)</span>

    <span class="s3">if </span><span class="s1">TYPE_CHECKING</span><span class="s4">:</span>

        <span class="s3">def </span><span class="s1">self_group</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">, </span><span class="s1">against</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">OperatorType</span><span class="s4">] = </span><span class="s3">None</span>
        <span class="s4">) </span><span class="s1">-&gt; Union</span><span class="s4">[</span><span class="s1">FromGrouping</span><span class="s4">, </span><span class="s1">Self</span><span class="s4">]: ...</span>


<span class="s3">class </span><span class="s1">NamedFromClause</span><span class="s4">(</span><span class="s1">FromClause</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;A :class:`.FromClause` that has a name. 
 
    Examples include tables, subqueries, CTEs, aliased tables. 
 
    .. versionadded:: 2.0 
 
    &quot;&quot;&quot;</span>

    <span class="s1">named_with_column </span><span class="s4">= </span><span class="s3">True</span>

    <span class="s1">name</span><span class="s4">: </span><span class="s1">str</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">preload_module</span><span class="s4">(</span><span class="s5">&quot;sqlalchemy.sql.sqltypes&quot;</span><span class="s4">)</span>
    <span class="s3">def </span><span class="s1">table_valued</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; TableValuedColumn</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;Return a :class:`_sql.TableValuedColumn` object for this 
        :class:`_expression.FromClause`. 
 
        A :class:`_sql.TableValuedColumn` is a :class:`_sql.ColumnElement` that 
        represents a complete row in a table. Support for this construct is 
        backend dependent, and is supported in various forms by backends 
        such as PostgreSQL, Oracle and SQL Server. 
 
        E.g.: 
 
        .. sourcecode:: pycon+sql 
 
            &gt;&gt;&gt; from sqlalchemy import select, column, func, table 
            &gt;&gt;&gt; a = table(&quot;a&quot;, column(&quot;id&quot;), column(&quot;x&quot;), column(&quot;y&quot;)) 
            &gt;&gt;&gt; stmt = select(func.row_to_json(a.table_valued())) 
            &gt;&gt;&gt; print(stmt) 
            {printsql}SELECT row_to_json(a) AS row_to_json_1 
            FROM a 
 
        .. versionadded:: 1.4.0b2 
 
        .. seealso:: 
 
            :ref:`tutorial_functions` - in the :ref:`unified_tutorial` 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">TableValuedColumn</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">type_api</span><span class="s4">.</span><span class="s1">TABLEVALUE</span><span class="s4">)</span>


<span class="s3">class </span><span class="s1">SelectLabelStyle</span><span class="s4">(</span><span class="s1">Enum</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Label style constants that may be passed to 
    :meth:`_sql.Select.set_label_style`.&quot;&quot;&quot;</span>

    <span class="s1">LABEL_STYLE_NONE </span><span class="s4">= </span><span class="s6">0</span>
    <span class="s5">&quot;&quot;&quot;Label style indicating no automatic labeling should be applied to the 
    columns clause of a SELECT statement. 
 
    Below, the columns named ``columna`` are both rendered as is, meaning that 
    the name ``columna`` can only refer to the first occurrence of this name 
    within a result set, as well as if the statement were used as a subquery: 
 
    .. sourcecode:: pycon+sql 
 
        &gt;&gt;&gt; from sqlalchemy import table, column, select, true, LABEL_STYLE_NONE 
        &gt;&gt;&gt; table1 = table(&quot;table1&quot;, column(&quot;columna&quot;), column(&quot;columnb&quot;)) 
        &gt;&gt;&gt; table2 = table(&quot;table2&quot;, column(&quot;columna&quot;), column(&quot;columnc&quot;)) 
        &gt;&gt;&gt; print(select(table1, table2).join(table2, true()).set_label_style(LABEL_STYLE_NONE)) 
        {printsql}SELECT table1.columna, table1.columnb, table2.columna, table2.columnc 
        FROM table1 JOIN table2 ON true 
 
    Used with the :meth:`_sql.Select.set_label_style` method. 
 
    .. versionadded:: 1.4 
 
    &quot;&quot;&quot;  </span><span class="s0"># noqa: E501</span>

    <span class="s1">LABEL_STYLE_TABLENAME_PLUS_COL </span><span class="s4">= </span><span class="s6">1</span>
    <span class="s5">&quot;&quot;&quot;Label style indicating all columns should be labeled as 
    ``&lt;tablename&gt;_&lt;columnname&gt;`` when generating the columns clause of a SELECT 
    statement, to disambiguate same-named columns referenced from different 
    tables, aliases, or subqueries. 
 
    Below, all column names are given a label so that the two same-named 
    columns ``columna`` are disambiguated as ``table1_columna`` and 
    ``table2_columna``: 
 
    .. sourcecode:: pycon+sql 
 
        &gt;&gt;&gt; from sqlalchemy import table, column, select, true, LABEL_STYLE_TABLENAME_PLUS_COL 
        &gt;&gt;&gt; table1 = table(&quot;table1&quot;, column(&quot;columna&quot;), column(&quot;columnb&quot;)) 
        &gt;&gt;&gt; table2 = table(&quot;table2&quot;, column(&quot;columna&quot;), column(&quot;columnc&quot;)) 
        &gt;&gt;&gt; print(select(table1, table2).join(table2, true()).set_label_style(LABEL_STYLE_TABLENAME_PLUS_COL)) 
        {printsql}SELECT table1.columna AS table1_columna, table1.columnb AS table1_columnb, table2.columna AS table2_columna, table2.columnc AS table2_columnc 
        FROM table1 JOIN table2 ON true 
 
    Used with the :meth:`_sql.GenerativeSelect.set_label_style` method. 
    Equivalent to the legacy method ``Select.apply_labels()``; 
    :data:`_sql.LABEL_STYLE_TABLENAME_PLUS_COL` is SQLAlchemy's legacy 
    auto-labeling style. :data:`_sql.LABEL_STYLE_DISAMBIGUATE_ONLY` provides a 
    less intrusive approach to disambiguation of same-named column expressions. 
 
 
    .. versionadded:: 1.4 
 
    &quot;&quot;&quot;  </span><span class="s0"># noqa: E501</span>

    <span class="s1">LABEL_STYLE_DISAMBIGUATE_ONLY </span><span class="s4">= </span><span class="s6">2</span>
    <span class="s5">&quot;&quot;&quot;Label style indicating that columns with a name that conflicts with 
    an existing name should be labeled with a semi-anonymizing label 
    when generating the columns clause of a SELECT statement. 
 
    Below, most column names are left unaffected, except for the second 
    occurrence of the name ``columna``, which is labeled using the 
    label ``columna_1`` to disambiguate it from that of ``tablea.columna``: 
 
    .. sourcecode:: pycon+sql 
 
        &gt;&gt;&gt; from sqlalchemy import table, column, select, true, LABEL_STYLE_DISAMBIGUATE_ONLY 
        &gt;&gt;&gt; table1 = table(&quot;table1&quot;, column(&quot;columna&quot;), column(&quot;columnb&quot;)) 
        &gt;&gt;&gt; table2 = table(&quot;table2&quot;, column(&quot;columna&quot;), column(&quot;columnc&quot;)) 
        &gt;&gt;&gt; print(select(table1, table2).join(table2, true()).set_label_style(LABEL_STYLE_DISAMBIGUATE_ONLY)) 
        {printsql}SELECT table1.columna, table1.columnb, table2.columna AS columna_1, table2.columnc 
        FROM table1 JOIN table2 ON true 
 
    Used with the :meth:`_sql.GenerativeSelect.set_label_style` method, 
    :data:`_sql.LABEL_STYLE_DISAMBIGUATE_ONLY` is the default labeling style 
    for all SELECT statements outside of :term:`1.x style` ORM queries. 
 
    .. versionadded:: 1.4 
 
    &quot;&quot;&quot;  </span><span class="s0"># noqa: E501</span>

    <span class="s1">LABEL_STYLE_DEFAULT </span><span class="s4">= </span><span class="s1">LABEL_STYLE_DISAMBIGUATE_ONLY</span>
    <span class="s5">&quot;&quot;&quot;The default label style, refers to 
    :data:`_sql.LABEL_STYLE_DISAMBIGUATE_ONLY`. 
 
    .. versionadded:: 1.4 
 
    &quot;&quot;&quot;</span>

    <span class="s1">LABEL_STYLE_LEGACY_ORM </span><span class="s4">= </span><span class="s6">3</span>


<span class="s4">(</span>
    <span class="s1">LABEL_STYLE_NONE</span><span class="s4">,</span>
    <span class="s1">LABEL_STYLE_TABLENAME_PLUS_COL</span><span class="s4">,</span>
    <span class="s1">LABEL_STYLE_DISAMBIGUATE_ONLY</span><span class="s4">,</span>
    <span class="s1">_</span><span class="s4">,</span>
<span class="s4">) = </span><span class="s1">list</span><span class="s4">(</span><span class="s1">SelectLabelStyle</span><span class="s4">)</span>

<span class="s1">LABEL_STYLE_DEFAULT </span><span class="s4">= </span><span class="s1">LABEL_STYLE_DISAMBIGUATE_ONLY</span>


<span class="s3">class </span><span class="s1">Join</span><span class="s4">(</span><span class="s1">roles</span><span class="s4">.</span><span class="s1">DMLTableRole</span><span class="s4">, </span><span class="s1">FromClause</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Represent a ``JOIN`` construct between two 
    :class:`_expression.FromClause` 
    elements. 
 
    The public constructor function for :class:`_expression.Join` 
    is the module-level 
    :func:`_expression.join()` function, as well as the 
    :meth:`_expression.FromClause.join` method 
    of any :class:`_expression.FromClause` (e.g. such as 
    :class:`_schema.Table`). 
 
    .. seealso:: 
 
        :func:`_expression.join` 
 
        :meth:`_expression.FromClause.join` 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;join&quot;</span>

    <span class="s1">_traverse_internals</span><span class="s4">: </span><span class="s1">_TraverseInternalsType </span><span class="s4">= [</span>
        <span class="s4">(</span><span class="s5">&quot;left&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_clauseelement</span><span class="s4">),</span>
        <span class="s4">(</span><span class="s5">&quot;right&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_clauseelement</span><span class="s4">),</span>
        <span class="s4">(</span><span class="s5">&quot;onclause&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_clauseelement</span><span class="s4">),</span>
        <span class="s4">(</span><span class="s5">&quot;isouter&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_boolean</span><span class="s4">),</span>
        <span class="s4">(</span><span class="s5">&quot;full&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_boolean</span><span class="s4">),</span>
    <span class="s4">]</span>

    <span class="s1">_is_join </span><span class="s4">= </span><span class="s3">True</span>

    <span class="s1">left</span><span class="s4">: </span><span class="s1">FromClause</span>
    <span class="s1">right</span><span class="s4">: </span><span class="s1">FromClause</span>
    <span class="s1">onclause</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">]]</span>
    <span class="s1">isouter</span><span class="s4">: </span><span class="s1">bool</span>
    <span class="s1">full</span><span class="s4">: </span><span class="s1">bool</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">left</span><span class="s4">: </span><span class="s1">_FromClauseArgument</span><span class="s4">,</span>
        <span class="s1">right</span><span class="s4">: </span><span class="s1">_FromClauseArgument</span><span class="s4">,</span>
        <span class="s1">onclause</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_OnClauseArgument</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">isouter</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
        <span class="s1">full</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
    <span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Construct a new :class:`_expression.Join`. 
 
        The usual entrypoint here is the :func:`_expression.join` 
        function or the :meth:`_expression.FromClause.join` method of any 
        :class:`_expression.FromClause` object. 
 
        &quot;&quot;&quot;</span>

        <span class="s0"># when deannotate was removed here, callcounts went up for ORM</span>
        <span class="s0"># compilation of eager joins, since there were more comparisons of</span>
        <span class="s0"># annotated objects.   test_orm.py -&gt; test_fetch_results</span>
        <span class="s0"># was therefore changed to show a more real-world use case, where the</span>
        <span class="s0"># compilation is cached; there's no change in post-cache callcounts.</span>
        <span class="s0"># callcounts for a single compilation in that particular test</span>
        <span class="s0"># that includes about eight joins about 1100 extra fn calls, from</span>
        <span class="s0"># 29200 -&gt; 30373</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">left </span><span class="s4">= </span><span class="s1">coercions</span><span class="s4">.</span><span class="s1">expect</span><span class="s4">(</span>
            <span class="s1">roles</span><span class="s4">.</span><span class="s1">FromClauseRole</span><span class="s4">,</span>
            <span class="s1">left</span><span class="s4">,</span>
        <span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">right </span><span class="s4">= </span><span class="s1">coercions</span><span class="s4">.</span><span class="s1">expect</span><span class="s4">(</span>
            <span class="s1">roles</span><span class="s4">.</span><span class="s1">FromClauseRole</span><span class="s4">,</span>
            <span class="s1">right</span><span class="s4">,</span>
        <span class="s4">).</span><span class="s1">self_group</span><span class="s4">()</span>

        <span class="s3">if </span><span class="s1">onclause </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">onclause </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_match_primaries</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">left</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">right</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s0"># note: taken from If91f61527236fd4d7ae3cad1f24c38be921c90ba</span>
            <span class="s0"># not merged yet</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">onclause </span><span class="s4">= </span><span class="s1">coercions</span><span class="s4">.</span><span class="s1">expect</span><span class="s4">(</span>
                <span class="s1">roles</span><span class="s4">.</span><span class="s1">OnClauseRole</span><span class="s4">, </span><span class="s1">onclause</span>
            <span class="s4">).</span><span class="s1">self_group</span><span class="s4">(</span><span class="s1">against</span><span class="s4">=</span><span class="s1">operators</span><span class="s4">.</span><span class="s1">_asbool</span><span class="s4">)</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">isouter </span><span class="s4">= </span><span class="s1">isouter</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">full </span><span class="s4">= </span><span class="s1">full</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">ro_non_memoized_property</span>
    <span class="s3">def </span><span class="s1">description</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; str</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s5">&quot;Join object on %s(%d) and %s(%d)&quot; </span><span class="s4">% (</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">left</span><span class="s4">.</span><span class="s1">description</span><span class="s4">,</span>
            <span class="s1">id</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">left</span><span class="s4">),</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">right</span><span class="s4">.</span><span class="s1">description</span><span class="s4">,</span>
            <span class="s1">id</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">right</span><span class="s4">),</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">is_derived_from</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">fromclause</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">FromClause</span><span class="s4">]) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s4">(</span>
            <span class="s0"># use hash() to ensure direct comparison to annotated works</span>
            <span class="s0"># as well</span>
            <span class="s1">hash</span><span class="s4">(</span><span class="s1">fromclause</span><span class="s4">) == </span><span class="s1">hash</span><span class="s4">(</span><span class="s1">self</span><span class="s4">)</span>
            <span class="s3">or </span><span class="s1">self</span><span class="s4">.</span><span class="s1">left</span><span class="s4">.</span><span class="s1">is_derived_from</span><span class="s4">(</span><span class="s1">fromclause</span><span class="s4">)</span>
            <span class="s3">or </span><span class="s1">self</span><span class="s4">.</span><span class="s1">right</span><span class="s4">.</span><span class="s1">is_derived_from</span><span class="s4">(</span><span class="s1">fromclause</span><span class="s4">)</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">self_group</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">against</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">OperatorType</span><span class="s4">] = </span><span class="s3">None</span>
    <span class="s4">) </span><span class="s1">-&gt; FromGrouping</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">FromGrouping</span><span class="s4">(</span><span class="s1">self</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">preload_module</span><span class="s4">(</span><span class="s5">&quot;sqlalchemy.sql.util&quot;</span><span class="s4">)</span>
    <span class="s3">def </span><span class="s1">_populate_column_collection</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s1">sqlutil </span><span class="s4">= </span><span class="s1">util</span><span class="s4">.</span><span class="s1">preloaded</span><span class="s4">.</span><span class="s1">sql_util</span>
        <span class="s1">columns</span><span class="s4">: </span><span class="s1">List</span><span class="s4">[</span><span class="s1">KeyedColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]] = [</span><span class="s1">c </span><span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">left</span><span class="s4">.</span><span class="s1">c</span><span class="s4">] + [</span>
            <span class="s1">c </span><span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">right</span><span class="s4">.</span><span class="s1">c</span>
        <span class="s4">]</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">primary_key</span><span class="s4">.</span><span class="s1">extend</span><span class="s4">(  </span><span class="s0"># type: ignore</span>
            <span class="s1">sqlutil</span><span class="s4">.</span><span class="s1">reduce_columns</span><span class="s4">(</span>
                <span class="s4">(</span><span class="s1">c </span><span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">columns </span><span class="s3">if </span><span class="s1">c</span><span class="s4">.</span><span class="s1">primary_key</span><span class="s4">), </span><span class="s1">self</span><span class="s4">.</span><span class="s1">onclause</span>
            <span class="s4">)</span>
        <span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_columns</span><span class="s4">.</span><span class="s1">_populate_separate_keys</span><span class="s4">(</span>
            <span class="s4">(</span><span class="s1">col</span><span class="s4">.</span><span class="s1">_tq_key_label</span><span class="s4">, </span><span class="s1">col</span><span class="s4">) </span><span class="s3">for </span><span class="s1">col </span><span class="s3">in </span><span class="s1">columns</span>
        <span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">foreign_keys</span><span class="s4">.</span><span class="s1">update</span><span class="s4">(  </span><span class="s0"># type: ignore</span>
            <span class="s1">itertools</span><span class="s4">.</span><span class="s1">chain</span><span class="s4">(*[</span><span class="s1">col</span><span class="s4">.</span><span class="s1">foreign_keys </span><span class="s3">for </span><span class="s1">col </span><span class="s3">in </span><span class="s1">columns</span><span class="s4">])</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_copy_internals</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">clone</span><span class="s4">: </span><span class="s1">_CloneCallableType </span><span class="s4">= </span><span class="s1">_clone</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span>
    <span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s0"># see Select._copy_internals() for similar concept</span>

        <span class="s0"># here we pre-clone &quot;left&quot; and &quot;right&quot; so that we can</span>
        <span class="s0"># determine the new FROM clauses</span>
        <span class="s1">all_the_froms </span><span class="s4">= </span><span class="s1">set</span><span class="s4">(</span>
            <span class="s1">itertools</span><span class="s4">.</span><span class="s1">chain</span><span class="s4">(</span>
                <span class="s1">_from_objects</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">left</span><span class="s4">),</span>
                <span class="s1">_from_objects</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">right</span><span class="s4">),</span>
            <span class="s4">)</span>
        <span class="s4">)</span>

        <span class="s0"># run the clone on those.  these will be placed in the</span>
        <span class="s0"># cache used by the clone function</span>
        <span class="s1">new_froms </span><span class="s4">= {</span><span class="s1">f</span><span class="s4">: </span><span class="s1">clone</span><span class="s4">(</span><span class="s1">f</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">) </span><span class="s3">for </span><span class="s1">f </span><span class="s3">in </span><span class="s1">all_the_froms</span><span class="s4">}</span>

        <span class="s0"># set up a special replace function that will replace for</span>
        <span class="s0"># ColumnClause with parent table referring to those</span>
        <span class="s0"># replaced FromClause objects</span>
        <span class="s3">def </span><span class="s1">replace</span><span class="s4">(</span>
            <span class="s1">obj</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span><span class="s1">BinaryExpression</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">], </span><span class="s1">ColumnClause</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]],</span>
            <span class="s4">**</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
        <span class="s4">) </span><span class="s1">-&gt; Optional</span><span class="s4">[</span><span class="s1">KeyedColumnElement</span><span class="s4">[</span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]]:</span>
            <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">obj</span><span class="s4">, </span><span class="s1">ColumnClause</span><span class="s4">) </span><span class="s3">and </span><span class="s1">obj</span><span class="s4">.</span><span class="s1">table </span><span class="s3">in </span><span class="s1">new_froms</span><span class="s4">:</span>
                <span class="s1">newelem </span><span class="s4">= </span><span class="s1">new_froms</span><span class="s4">[</span><span class="s1">obj</span><span class="s4">.</span><span class="s1">table</span><span class="s4">].</span><span class="s1">corresponding_column</span><span class="s4">(</span><span class="s1">obj</span><span class="s4">)</span>
                <span class="s3">return </span><span class="s1">newelem</span>
            <span class="s3">return None</span>

        <span class="s1">kw</span><span class="s4">[</span><span class="s5">&quot;replace&quot;</span><span class="s4">] = </span><span class="s1">replace</span>

        <span class="s0"># run normal _copy_internals.  the clones for</span>
        <span class="s0"># left and right will come from the clone function's</span>
        <span class="s0"># cache</span>
        <span class="s1">super</span><span class="s4">().</span><span class="s1">_copy_internals</span><span class="s4">(</span><span class="s1">clone</span><span class="s4">=</span><span class="s1">clone</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">)</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">_reset_memoizations</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">_refresh_for_new_column</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">column</span><span class="s4">: </span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s1">super</span><span class="s4">().</span><span class="s1">_refresh_for_new_column</span><span class="s4">(</span><span class="s1">column</span><span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">left</span><span class="s4">.</span><span class="s1">_refresh_for_new_column</span><span class="s4">(</span><span class="s1">column</span><span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">right</span><span class="s4">.</span><span class="s1">_refresh_for_new_column</span><span class="s4">(</span><span class="s1">column</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_match_primaries</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">left</span><span class="s4">: </span><span class="s1">FromClause</span><span class="s4">,</span>
        <span class="s1">right</span><span class="s4">: </span><span class="s1">FromClause</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; ColumnElement</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">]:</span>
        <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">left</span><span class="s4">, </span><span class="s1">Join</span><span class="s4">):</span>
            <span class="s1">left_right </span><span class="s4">= </span><span class="s1">left</span><span class="s4">.</span><span class="s1">right</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">left_right </span><span class="s4">= </span><span class="s3">None</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_join_condition</span><span class="s4">(</span><span class="s1">left</span><span class="s4">, </span><span class="s1">right</span><span class="s4">, </span><span class="s1">a_subset</span><span class="s4">=</span><span class="s1">left_right</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">classmethod</span>
    <span class="s3">def </span><span class="s1">_join_condition</span><span class="s4">(</span>
        <span class="s1">cls</span><span class="s4">,</span>
        <span class="s1">a</span><span class="s4">: </span><span class="s1">FromClause</span><span class="s4">,</span>
        <span class="s1">b</span><span class="s4">: </span><span class="s1">FromClause</span><span class="s4">,</span>
        <span class="s4">*,</span>
        <span class="s1">a_subset</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">FromClause</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">consider_as_foreign_keys</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span>
            <span class="s1">AbstractSet</span><span class="s4">[</span><span class="s1">ColumnClause</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]</span>
        <span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; ColumnElement</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;Create a join condition between two tables or selectables. 
 
        See sqlalchemy.sql.util.join_condition() for full docs. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">constraints </span><span class="s4">= </span><span class="s1">cls</span><span class="s4">.</span><span class="s1">_joincond_scan_left_right</span><span class="s4">(</span>
            <span class="s1">a</span><span class="s4">, </span><span class="s1">a_subset</span><span class="s4">, </span><span class="s1">b</span><span class="s4">, </span><span class="s1">consider_as_foreign_keys</span>
        <span class="s4">)</span>

        <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">constraints</span><span class="s4">) &gt; </span><span class="s6">1</span><span class="s4">:</span>
            <span class="s1">cls</span><span class="s4">.</span><span class="s1">_joincond_trim_constraints</span><span class="s4">(</span>
                <span class="s1">a</span><span class="s4">, </span><span class="s1">b</span><span class="s4">, </span><span class="s1">constraints</span><span class="s4">, </span><span class="s1">consider_as_foreign_keys</span>
            <span class="s4">)</span>

        <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">constraints</span><span class="s4">) == </span><span class="s6">0</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">b</span><span class="s4">, </span><span class="s1">FromGrouping</span><span class="s4">):</span>
                <span class="s1">hint </span><span class="s4">= (</span>
                    <span class="s5">&quot; Perhaps you meant to convert the right side to a &quot;</span>
                    <span class="s5">&quot;subquery using alias()?&quot;</span>
                <span class="s4">)</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">hint </span><span class="s4">= </span><span class="s5">&quot;&quot;</span>
            <span class="s3">raise </span><span class="s1">exc</span><span class="s4">.</span><span class="s1">NoForeignKeysError</span><span class="s4">(</span>
                <span class="s5">&quot;Can't find any foreign key relationships &quot;</span>
                <span class="s5">&quot;between '%s' and '%s'.%s&quot;</span>
                <span class="s4">% (</span><span class="s1">a</span><span class="s4">.</span><span class="s1">description</span><span class="s4">, </span><span class="s1">b</span><span class="s4">.</span><span class="s1">description</span><span class="s4">, </span><span class="s1">hint</span><span class="s4">)</span>
            <span class="s4">)</span>

        <span class="s1">crit </span><span class="s4">= [(</span><span class="s1">x </span><span class="s4">== </span><span class="s1">y</span><span class="s4">) </span><span class="s3">for </span><span class="s1">x</span><span class="s4">, </span><span class="s1">y </span><span class="s3">in </span><span class="s1">list</span><span class="s4">(</span><span class="s1">constraints</span><span class="s4">.</span><span class="s1">values</span><span class="s4">())[</span><span class="s6">0</span><span class="s4">]]</span>
        <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">crit</span><span class="s4">) == </span><span class="s6">1</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">crit</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">and_</span><span class="s4">(*</span><span class="s1">crit</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">classmethod</span>
    <span class="s3">def </span><span class="s1">_can_join</span><span class="s4">(</span>
        <span class="s1">cls</span><span class="s4">,</span>
        <span class="s1">left</span><span class="s4">: </span><span class="s1">FromClause</span><span class="s4">,</span>
        <span class="s1">right</span><span class="s4">: </span><span class="s1">FromClause</span><span class="s4">,</span>
        <span class="s4">*,</span>
        <span class="s1">consider_as_foreign_keys</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span>
            <span class="s1">AbstractSet</span><span class="s4">[</span><span class="s1">ColumnClause</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]</span>
        <span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">left</span><span class="s4">, </span><span class="s1">Join</span><span class="s4">):</span>
            <span class="s1">left_right </span><span class="s4">= </span><span class="s1">left</span><span class="s4">.</span><span class="s1">right</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">left_right </span><span class="s4">= </span><span class="s3">None</span>

        <span class="s1">constraints </span><span class="s4">= </span><span class="s1">cls</span><span class="s4">.</span><span class="s1">_joincond_scan_left_right</span><span class="s4">(</span>
            <span class="s1">a</span><span class="s4">=</span><span class="s1">left</span><span class="s4">,</span>
            <span class="s1">b</span><span class="s4">=</span><span class="s1">right</span><span class="s4">,</span>
            <span class="s1">a_subset</span><span class="s4">=</span><span class="s1">left_right</span><span class="s4">,</span>
            <span class="s1">consider_as_foreign_keys</span><span class="s4">=</span><span class="s1">consider_as_foreign_keys</span><span class="s4">,</span>
        <span class="s4">)</span>

        <span class="s3">return </span><span class="s1">bool</span><span class="s4">(</span><span class="s1">constraints</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">classmethod</span>
    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">preload_module</span><span class="s4">(</span><span class="s5">&quot;sqlalchemy.sql.util&quot;</span><span class="s4">)</span>
    <span class="s3">def </span><span class="s1">_joincond_scan_left_right</span><span class="s4">(</span>
        <span class="s1">cls</span><span class="s4">,</span>
        <span class="s1">a</span><span class="s4">: </span><span class="s1">FromClause</span><span class="s4">,</span>
        <span class="s1">a_subset</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">FromClause</span><span class="s4">],</span>
        <span class="s1">b</span><span class="s4">: </span><span class="s1">FromClause</span><span class="s4">,</span>
        <span class="s1">consider_as_foreign_keys</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">AbstractSet</span><span class="s4">[</span><span class="s1">ColumnClause</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]],</span>
    <span class="s4">) </span><span class="s1">-&gt; collections</span><span class="s4">.</span><span class="s1">defaultdict</span><span class="s4">[</span>
        <span class="s1">Optional</span><span class="s4">[</span><span class="s1">ForeignKeyConstraint</span><span class="s4">],</span>
        <span class="s1">List</span><span class="s4">[</span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">ColumnClause</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">], </span><span class="s1">ColumnClause</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]],</span>
    <span class="s4">]:</span>
        <span class="s1">sql_util </span><span class="s4">= </span><span class="s1">util</span><span class="s4">.</span><span class="s1">preloaded</span><span class="s4">.</span><span class="s1">sql_util</span>

        <span class="s1">a </span><span class="s4">= </span><span class="s1">coercions</span><span class="s4">.</span><span class="s1">expect</span><span class="s4">(</span><span class="s1">roles</span><span class="s4">.</span><span class="s1">FromClauseRole</span><span class="s4">, </span><span class="s1">a</span><span class="s4">)</span>
        <span class="s1">b </span><span class="s4">= </span><span class="s1">coercions</span><span class="s4">.</span><span class="s1">expect</span><span class="s4">(</span><span class="s1">roles</span><span class="s4">.</span><span class="s1">FromClauseRole</span><span class="s4">, </span><span class="s1">b</span><span class="s4">)</span>

        <span class="s1">constraints</span><span class="s4">: </span><span class="s1">collections</span><span class="s4">.</span><span class="s1">defaultdict</span><span class="s4">[</span>
            <span class="s1">Optional</span><span class="s4">[</span><span class="s1">ForeignKeyConstraint</span><span class="s4">],</span>
            <span class="s1">List</span><span class="s4">[</span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">ColumnClause</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">], </span><span class="s1">ColumnClause</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]],</span>
        <span class="s4">] = </span><span class="s1">collections</span><span class="s4">.</span><span class="s1">defaultdict</span><span class="s4">(</span><span class="s1">list</span><span class="s4">)</span>

        <span class="s3">for </span><span class="s1">left </span><span class="s3">in </span><span class="s4">(</span><span class="s1">a_subset</span><span class="s4">, </span><span class="s1">a</span><span class="s4">):</span>
            <span class="s3">if </span><span class="s1">left </span><span class="s3">is None</span><span class="s4">:</span>
                <span class="s3">continue</span>
            <span class="s3">for </span><span class="s1">fk </span><span class="s3">in </span><span class="s1">sorted</span><span class="s4">(</span>
                <span class="s1">b</span><span class="s4">.</span><span class="s1">foreign_keys</span><span class="s4">,</span>
                <span class="s1">key</span><span class="s4">=</span><span class="s3">lambda </span><span class="s1">fk</span><span class="s4">: </span><span class="s1">fk</span><span class="s4">.</span><span class="s1">parent</span><span class="s4">.</span><span class="s1">_creation_order</span><span class="s4">,</span>
            <span class="s4">):</span>
                <span class="s3">if </span><span class="s4">(</span>
                    <span class="s1">consider_as_foreign_keys </span><span class="s3">is not None</span>
                    <span class="s3">and </span><span class="s1">fk</span><span class="s4">.</span><span class="s1">parent </span><span class="s3">not in </span><span class="s1">consider_as_foreign_keys</span>
                <span class="s4">):</span>
                    <span class="s3">continue</span>
                <span class="s3">try</span><span class="s4">:</span>
                    <span class="s1">col </span><span class="s4">= </span><span class="s1">fk</span><span class="s4">.</span><span class="s1">get_referent</span><span class="s4">(</span><span class="s1">left</span><span class="s4">)</span>
                <span class="s3">except </span><span class="s1">exc</span><span class="s4">.</span><span class="s1">NoReferenceError </span><span class="s3">as </span><span class="s1">nrte</span><span class="s4">:</span>
                    <span class="s1">table_names </span><span class="s4">= {</span><span class="s1">t</span><span class="s4">.</span><span class="s1">name </span><span class="s3">for </span><span class="s1">t </span><span class="s3">in </span><span class="s1">sql_util</span><span class="s4">.</span><span class="s1">find_tables</span><span class="s4">(</span><span class="s1">left</span><span class="s4">)}</span>
                    <span class="s3">if </span><span class="s1">nrte</span><span class="s4">.</span><span class="s1">table_name </span><span class="s3">in </span><span class="s1">table_names</span><span class="s4">:</span>
                        <span class="s3">raise</span>
                    <span class="s3">else</span><span class="s4">:</span>
                        <span class="s3">continue</span>

                <span class="s3">if </span><span class="s1">col </span><span class="s3">is not None</span><span class="s4">:</span>
                    <span class="s1">constraints</span><span class="s4">[</span><span class="s1">fk</span><span class="s4">.</span><span class="s1">constraint</span><span class="s4">].</span><span class="s1">append</span><span class="s4">((</span><span class="s1">col</span><span class="s4">, </span><span class="s1">fk</span><span class="s4">.</span><span class="s1">parent</span><span class="s4">))</span>
            <span class="s3">if </span><span class="s1">left </span><span class="s3">is not </span><span class="s1">b</span><span class="s4">:</span>
                <span class="s3">for </span><span class="s1">fk </span><span class="s3">in </span><span class="s1">sorted</span><span class="s4">(</span>
                    <span class="s1">left</span><span class="s4">.</span><span class="s1">foreign_keys</span><span class="s4">,</span>
                    <span class="s1">key</span><span class="s4">=</span><span class="s3">lambda </span><span class="s1">fk</span><span class="s4">: </span><span class="s1">fk</span><span class="s4">.</span><span class="s1">parent</span><span class="s4">.</span><span class="s1">_creation_order</span><span class="s4">,</span>
                <span class="s4">):</span>
                    <span class="s3">if </span><span class="s4">(</span>
                        <span class="s1">consider_as_foreign_keys </span><span class="s3">is not None</span>
                        <span class="s3">and </span><span class="s1">fk</span><span class="s4">.</span><span class="s1">parent </span><span class="s3">not in </span><span class="s1">consider_as_foreign_keys</span>
                    <span class="s4">):</span>
                        <span class="s3">continue</span>
                    <span class="s3">try</span><span class="s4">:</span>
                        <span class="s1">col </span><span class="s4">= </span><span class="s1">fk</span><span class="s4">.</span><span class="s1">get_referent</span><span class="s4">(</span><span class="s1">b</span><span class="s4">)</span>
                    <span class="s3">except </span><span class="s1">exc</span><span class="s4">.</span><span class="s1">NoReferenceError </span><span class="s3">as </span><span class="s1">nrte</span><span class="s4">:</span>
                        <span class="s1">table_names </span><span class="s4">= {</span><span class="s1">t</span><span class="s4">.</span><span class="s1">name </span><span class="s3">for </span><span class="s1">t </span><span class="s3">in </span><span class="s1">sql_util</span><span class="s4">.</span><span class="s1">find_tables</span><span class="s4">(</span><span class="s1">b</span><span class="s4">)}</span>
                        <span class="s3">if </span><span class="s1">nrte</span><span class="s4">.</span><span class="s1">table_name </span><span class="s3">in </span><span class="s1">table_names</span><span class="s4">:</span>
                            <span class="s3">raise</span>
                        <span class="s3">else</span><span class="s4">:</span>
                            <span class="s3">continue</span>

                    <span class="s3">if </span><span class="s1">col </span><span class="s3">is not None</span><span class="s4">:</span>
                        <span class="s1">constraints</span><span class="s4">[</span><span class="s1">fk</span><span class="s4">.</span><span class="s1">constraint</span><span class="s4">].</span><span class="s1">append</span><span class="s4">((</span><span class="s1">col</span><span class="s4">, </span><span class="s1">fk</span><span class="s4">.</span><span class="s1">parent</span><span class="s4">))</span>
            <span class="s3">if </span><span class="s1">constraints</span><span class="s4">:</span>
                <span class="s3">break</span>
        <span class="s3">return </span><span class="s1">constraints</span>

    <span class="s4">@</span><span class="s1">classmethod</span>
    <span class="s3">def </span><span class="s1">_joincond_trim_constraints</span><span class="s4">(</span>
        <span class="s1">cls</span><span class="s4">,</span>
        <span class="s1">a</span><span class="s4">: </span><span class="s1">FromClause</span><span class="s4">,</span>
        <span class="s1">b</span><span class="s4">: </span><span class="s1">FromClause</span><span class="s4">,</span>
        <span class="s1">constraints</span><span class="s4">: </span><span class="s1">Dict</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">, </span><span class="s1">Any</span><span class="s4">],</span>
        <span class="s1">consider_as_foreign_keys</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">],</span>
    <span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s0"># more than one constraint matched.  narrow down the list</span>
        <span class="s0"># to include just those FKCs that match exactly to</span>
        <span class="s0"># &quot;consider_as_foreign_keys&quot;.</span>
        <span class="s3">if </span><span class="s1">consider_as_foreign_keys</span><span class="s4">:</span>
            <span class="s3">for </span><span class="s1">const </span><span class="s3">in </span><span class="s1">list</span><span class="s4">(</span><span class="s1">constraints</span><span class="s4">):</span>
                <span class="s3">if </span><span class="s4">{</span><span class="s1">f</span><span class="s4">.</span><span class="s1">parent </span><span class="s3">for </span><span class="s1">f </span><span class="s3">in </span><span class="s1">const</span><span class="s4">.</span><span class="s1">elements</span><span class="s4">} != </span><span class="s1">set</span><span class="s4">(</span>
                    <span class="s1">consider_as_foreign_keys</span>
                <span class="s4">):</span>
                    <span class="s3">del </span><span class="s1">constraints</span><span class="s4">[</span><span class="s1">const</span><span class="s4">]</span>

        <span class="s0"># if still multiple constraints, but</span>
        <span class="s0"># they all refer to the exact same end result, use it.</span>
        <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">constraints</span><span class="s4">) &gt; </span><span class="s6">1</span><span class="s4">:</span>
            <span class="s1">dedupe </span><span class="s4">= {</span><span class="s1">tuple</span><span class="s4">(</span><span class="s1">crit</span><span class="s4">) </span><span class="s3">for </span><span class="s1">crit </span><span class="s3">in </span><span class="s1">constraints</span><span class="s4">.</span><span class="s1">values</span><span class="s4">()}</span>
            <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">dedupe</span><span class="s4">) == </span><span class="s6">1</span><span class="s4">:</span>
                <span class="s1">key </span><span class="s4">= </span><span class="s1">list</span><span class="s4">(</span><span class="s1">constraints</span><span class="s4">)[</span><span class="s6">0</span><span class="s4">]</span>
                <span class="s1">constraints </span><span class="s4">= {</span><span class="s1">key</span><span class="s4">: </span><span class="s1">constraints</span><span class="s4">[</span><span class="s1">key</span><span class="s4">]}</span>

        <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">constraints</span><span class="s4">) != </span><span class="s6">1</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">exc</span><span class="s4">.</span><span class="s1">AmbiguousForeignKeysError</span><span class="s4">(</span>
                <span class="s5">&quot;Can't determine join between '%s' and '%s'; &quot;</span>
                <span class="s5">&quot;tables have more than one foreign key &quot;</span>
                <span class="s5">&quot;constraint relationship between them. &quot;</span>
                <span class="s5">&quot;Please specify the 'onclause' of this &quot;</span>
                <span class="s5">&quot;join explicitly.&quot; </span><span class="s4">% (</span><span class="s1">a</span><span class="s4">.</span><span class="s1">description</span><span class="s4">, </span><span class="s1">b</span><span class="s4">.</span><span class="s1">description</span><span class="s4">)</span>
            <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">select</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Select</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]:</span>
        <span class="s2">r&quot;&quot;&quot;Create a :class:`_expression.Select` from this 
        :class:`_expression.Join`. 
 
        E.g.:: 
 
            stmt = table_a.join(table_b, table_a.c.id == table_b.c.a_id) 
 
            stmt = stmt.select() 
 
        The above will produce a SQL string resembling:: 
 
            SELECT table_a.id, table_a.col, table_b.id, table_b.a_id 
            FROM table_a JOIN table_b ON table_a.id = table_b.a_id 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">Select</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">left</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">right</span><span class="s4">).</span><span class="s1">select_from</span><span class="s4">(</span><span class="s1">self</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">preload_module</span><span class="s4">(</span><span class="s5">&quot;sqlalchemy.sql.util&quot;</span><span class="s4">)</span>
    <span class="s3">def </span><span class="s1">_anonymous_fromclause</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">name</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">, </span><span class="s1">flat</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span>
    <span class="s4">) </span><span class="s1">-&gt; TODO_Any</span><span class="s4">:</span>
        <span class="s1">sqlutil </span><span class="s4">= </span><span class="s1">util</span><span class="s4">.</span><span class="s1">preloaded</span><span class="s4">.</span><span class="s1">sql_util</span>
        <span class="s3">if </span><span class="s1">flat</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">left</span><span class="s4">, (</span><span class="s1">FromGrouping</span><span class="s4">, </span><span class="s1">Join</span><span class="s4">)):</span>
                <span class="s1">left_name </span><span class="s4">= </span><span class="s1">name  </span><span class="s0"># will recurse</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s3">if </span><span class="s1">name </span><span class="s3">and </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">left</span><span class="s4">, </span><span class="s1">NamedFromClause</span><span class="s4">):</span>
                    <span class="s1">left_name </span><span class="s4">= </span><span class="s5">f&quot;</span><span class="s3">{</span><span class="s1">name</span><span class="s3">}</span><span class="s5">_</span><span class="s3">{</span><span class="s1">self</span><span class="s4">.</span><span class="s1">left</span><span class="s4">.</span><span class="s1">name</span><span class="s3">}</span><span class="s5">&quot;</span>
                <span class="s3">else</span><span class="s4">:</span>
                    <span class="s1">left_name </span><span class="s4">= </span><span class="s1">name</span>
            <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">right</span><span class="s4">, (</span><span class="s1">FromGrouping</span><span class="s4">, </span><span class="s1">Join</span><span class="s4">)):</span>
                <span class="s1">right_name </span><span class="s4">= </span><span class="s1">name  </span><span class="s0"># will recurse</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s3">if </span><span class="s1">name </span><span class="s3">and </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">right</span><span class="s4">, </span><span class="s1">NamedFromClause</span><span class="s4">):</span>
                    <span class="s1">right_name </span><span class="s4">= </span><span class="s5">f&quot;</span><span class="s3">{</span><span class="s1">name</span><span class="s3">}</span><span class="s5">_</span><span class="s3">{</span><span class="s1">self</span><span class="s4">.</span><span class="s1">right</span><span class="s4">.</span><span class="s1">name</span><span class="s3">}</span><span class="s5">&quot;</span>
                <span class="s3">else</span><span class="s4">:</span>
                    <span class="s1">right_name </span><span class="s4">= </span><span class="s1">name</span>
            <span class="s1">left_a</span><span class="s4">, </span><span class="s1">right_a </span><span class="s4">= (</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">left</span><span class="s4">.</span><span class="s1">_anonymous_fromclause</span><span class="s4">(</span><span class="s1">name</span><span class="s4">=</span><span class="s1">left_name</span><span class="s4">, </span><span class="s1">flat</span><span class="s4">=</span><span class="s1">flat</span><span class="s4">),</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">right</span><span class="s4">.</span><span class="s1">_anonymous_fromclause</span><span class="s4">(</span><span class="s1">name</span><span class="s4">=</span><span class="s1">right_name</span><span class="s4">, </span><span class="s1">flat</span><span class="s4">=</span><span class="s1">flat</span><span class="s4">),</span>
            <span class="s4">)</span>
            <span class="s1">adapter </span><span class="s4">= </span><span class="s1">sqlutil</span><span class="s4">.</span><span class="s1">ClauseAdapter</span><span class="s4">(</span><span class="s1">left_a</span><span class="s4">).</span><span class="s1">chain</span><span class="s4">(</span>
                <span class="s1">sqlutil</span><span class="s4">.</span><span class="s1">ClauseAdapter</span><span class="s4">(</span><span class="s1">right_a</span><span class="s4">)</span>
            <span class="s4">)</span>

            <span class="s3">return </span><span class="s1">left_a</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span>
                <span class="s1">right_a</span><span class="s4">,</span>
                <span class="s1">adapter</span><span class="s4">.</span><span class="s1">traverse</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">onclause</span><span class="s4">),</span>
                <span class="s1">isouter</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">isouter</span><span class="s4">,</span>
                <span class="s1">full</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">full</span><span class="s4">,</span>
            <span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s4">(</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">select</span><span class="s4">()</span>
                <span class="s4">.</span><span class="s1">set_label_style</span><span class="s4">(</span><span class="s1">LABEL_STYLE_TABLENAME_PLUS_COL</span><span class="s4">)</span>
                <span class="s4">.</span><span class="s1">correlate</span><span class="s4">(</span><span class="s3">None</span><span class="s4">)</span>
                <span class="s4">.</span><span class="s1">alias</span><span class="s4">(</span><span class="s1">name</span><span class="s4">)</span>
            <span class="s4">)</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">ro_non_memoized_property</span>
    <span class="s3">def </span><span class="s1">_hide_froms</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Iterable</span><span class="s4">[</span><span class="s1">FromClause</span><span class="s4">]:</span>
        <span class="s3">return </span><span class="s1">itertools</span><span class="s4">.</span><span class="s1">chain</span><span class="s4">(</span>
            <span class="s4">*[</span><span class="s1">_from_objects</span><span class="s4">(</span><span class="s1">x</span><span class="s4">.</span><span class="s1">left</span><span class="s4">, </span><span class="s1">x</span><span class="s4">.</span><span class="s1">right</span><span class="s4">) </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_cloned_set</span><span class="s4">]</span>
        <span class="s4">)</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">ro_non_memoized_property</span>
    <span class="s3">def </span><span class="s1">_from_objects</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; List</span><span class="s4">[</span><span class="s1">FromClause</span><span class="s4">]:</span>
        <span class="s1">self_list</span><span class="s4">: </span><span class="s1">List</span><span class="s4">[</span><span class="s1">FromClause</span><span class="s4">] = [</span><span class="s1">self</span><span class="s4">]</span>
        <span class="s3">return </span><span class="s1">self_list </span><span class="s4">+ </span><span class="s1">self</span><span class="s4">.</span><span class="s1">left</span><span class="s4">.</span><span class="s1">_from_objects </span><span class="s4">+ </span><span class="s1">self</span><span class="s4">.</span><span class="s1">right</span><span class="s4">.</span><span class="s1">_from_objects</span>


<span class="s3">class </span><span class="s1">NoInit</span><span class="s4">:</span>
    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, *</span><span class="s1">arg</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">):</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">(</span>
            <span class="s5">&quot;The %s class is not intended to be constructed &quot;</span>
            <span class="s5">&quot;directly.  Please use the %s() standalone &quot;</span>
            <span class="s5">&quot;function or the %s() method available from appropriate &quot;</span>
            <span class="s5">&quot;selectable objects.&quot;</span>
            <span class="s4">% (</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">__class__</span><span class="s4">.</span><span class="s1">__name__</span><span class="s4">,</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">__class__</span><span class="s4">.</span><span class="s1">__name__</span><span class="s4">.</span><span class="s1">lower</span><span class="s4">(),</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">__class__</span><span class="s4">.</span><span class="s1">__name__</span><span class="s4">.</span><span class="s1">lower</span><span class="s4">(),</span>
            <span class="s4">)</span>
        <span class="s4">)</span>


<span class="s3">class </span><span class="s1">LateralFromClause</span><span class="s4">(</span><span class="s1">NamedFromClause</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;mark a FROM clause as being able to render directly as LATERAL&quot;&quot;&quot;</span>


<span class="s0"># FromClause -&gt;</span>
<span class="s0">#   AliasedReturnsRows</span>
<span class="s0">#        -&gt; Alias   only for FromClause</span>
<span class="s0">#        -&gt; Subquery  only for SelectBase</span>
<span class="s0">#        -&gt; CTE only for HasCTE -&gt; SelectBase, DML</span>
<span class="s0">#        -&gt; Lateral -&gt; FromClause, but we accept SelectBase</span>
<span class="s0">#           w/ non-deprecated coercion</span>
<span class="s0">#        -&gt; TableSample -&gt; only for FromClause</span>


<span class="s3">class </span><span class="s1">AliasedReturnsRows</span><span class="s4">(</span><span class="s1">NoInit</span><span class="s4">, </span><span class="s1">NamedFromClause</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Base class of aliases against tables, subqueries, and other 
    selectables.&quot;&quot;&quot;</span>

    <span class="s1">_is_from_container </span><span class="s4">= </span><span class="s3">True</span>

    <span class="s1">_supports_derived_columns </span><span class="s4">= </span><span class="s3">False</span>

    <span class="s1">element</span><span class="s4">: </span><span class="s1">ReturnsRows</span>

    <span class="s1">_traverse_internals</span><span class="s4">: </span><span class="s1">_TraverseInternalsType </span><span class="s4">= [</span>
        <span class="s4">(</span><span class="s5">&quot;element&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_clauseelement</span><span class="s4">),</span>
        <span class="s4">(</span><span class="s5">&quot;name&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_anon_name</span><span class="s4">),</span>
    <span class="s4">]</span>

    <span class="s4">@</span><span class="s1">classmethod</span>
    <span class="s3">def </span><span class="s1">_construct</span><span class="s4">(</span>
        <span class="s1">cls</span><span class="s4">,</span>
        <span class="s1">selectable</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
        <span class="s4">*,</span>
        <span class="s1">name</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s4">**</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s1">obj </span><span class="s4">= </span><span class="s1">cls</span><span class="s4">.</span><span class="s1">__new__</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">)</span>
        <span class="s1">obj</span><span class="s4">.</span><span class="s1">_init</span><span class="s4">(</span><span class="s1">selectable</span><span class="s4">, </span><span class="s1">name</span><span class="s4">=</span><span class="s1">name</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">obj</span>

    <span class="s3">def </span><span class="s1">_init</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">selectable</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">, *, </span><span class="s1">name</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">element </span><span class="s4">= </span><span class="s1">coercions</span><span class="s4">.</span><span class="s1">expect</span><span class="s4">(</span>
            <span class="s1">roles</span><span class="s4">.</span><span class="s1">ReturnsRowsRole</span><span class="s4">, </span><span class="s1">selectable</span><span class="s4">, </span><span class="s1">apply_propagate_attrs</span><span class="s4">=</span><span class="s1">self</span>
        <span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">element </span><span class="s4">= </span><span class="s1">selectable</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_orig_name </span><span class="s4">= </span><span class="s1">name</span>
        <span class="s3">if </span><span class="s1">name </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s4">(</span>
                <span class="s1">isinstance</span><span class="s4">(</span><span class="s1">selectable</span><span class="s4">, </span><span class="s1">FromClause</span><span class="s4">)</span>
                <span class="s3">and </span><span class="s1">selectable</span><span class="s4">.</span><span class="s1">named_with_column</span>
            <span class="s4">):</span>
                <span class="s1">name </span><span class="s4">= </span><span class="s1">getattr</span><span class="s4">(</span><span class="s1">selectable</span><span class="s4">, </span><span class="s5">&quot;name&quot;</span><span class="s4">, </span><span class="s3">None</span><span class="s4">)</span>
                <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">name</span><span class="s4">, </span><span class="s1">_anonymous_label</span><span class="s4">):</span>
                    <span class="s1">name </span><span class="s4">= </span><span class="s3">None</span>
            <span class="s1">name </span><span class="s4">= </span><span class="s1">_anonymous_label</span><span class="s4">.</span><span class="s1">safe_construct</span><span class="s4">(</span><span class="s1">id</span><span class="s4">(</span><span class="s1">self</span><span class="s4">), </span><span class="s1">name </span><span class="s3">or </span><span class="s5">&quot;anon&quot;</span><span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">name </span><span class="s4">= </span><span class="s1">name</span>

    <span class="s3">def </span><span class="s1">_refresh_for_new_column</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">column</span><span class="s4">: </span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s1">super</span><span class="s4">().</span><span class="s1">_refresh_for_new_column</span><span class="s4">(</span><span class="s1">column</span><span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">element</span><span class="s4">.</span><span class="s1">_refresh_for_new_column</span><span class="s4">(</span><span class="s1">column</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_populate_column_collection</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">element</span><span class="s4">.</span><span class="s1">_generate_fromclause_column_proxies</span><span class="s4">(</span><span class="s1">self</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">ro_non_memoized_property</span>
    <span class="s3">def </span><span class="s1">description</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; str</span><span class="s4">:</span>
        <span class="s1">name </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">name</span>
        <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">name</span><span class="s4">, </span><span class="s1">_anonymous_label</span><span class="s4">):</span>
            <span class="s1">name </span><span class="s4">= </span><span class="s5">&quot;anon_1&quot;</span>

        <span class="s3">return </span><span class="s1">name</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">ro_non_memoized_property</span>
    <span class="s3">def </span><span class="s1">implicit_returning</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">element</span><span class="s4">.</span><span class="s1">implicit_returning  </span><span class="s0"># type: ignore</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">original</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; ReturnsRows</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Legacy for dialects that are referring to Alias.original.&quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">element</span>

    <span class="s3">def </span><span class="s1">is_derived_from</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">fromclause</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">FromClause</span><span class="s4">]) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">fromclause </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_cloned_set</span><span class="s4">:</span>
            <span class="s3">return True</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">element</span><span class="s4">.</span><span class="s1">is_derived_from</span><span class="s4">(</span><span class="s1">fromclause</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_copy_internals</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">clone</span><span class="s4">: </span><span class="s1">_CloneCallableType </span><span class="s4">= </span><span class="s1">_clone</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span>
    <span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s1">existing_element </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">element</span>

        <span class="s1">super</span><span class="s4">().</span><span class="s1">_copy_internals</span><span class="s4">(</span><span class="s1">clone</span><span class="s4">=</span><span class="s1">clone</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">)</span>

        <span class="s0"># the element clone is usually against a Table that returns the</span>
        <span class="s0"># same object.  don't reset exported .c. collections and other</span>
        <span class="s0"># memoized details if it was not changed.  this saves a lot on</span>
        <span class="s0"># performance.</span>
        <span class="s3">if </span><span class="s1">existing_element </span><span class="s3">is not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">element</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_reset_column_collection</span><span class="s4">()</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">_from_objects</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; List</span><span class="s4">[</span><span class="s1">FromClause</span><span class="s4">]:</span>
        <span class="s3">return </span><span class="s4">[</span><span class="s1">self</span><span class="s4">]</span>


<span class="s3">class </span><span class="s1">FromClauseAlias</span><span class="s4">(</span><span class="s1">AliasedReturnsRows</span><span class="s4">):</span>
    <span class="s1">element</span><span class="s4">: </span><span class="s1">FromClause</span>


<span class="s3">class </span><span class="s1">Alias</span><span class="s4">(</span><span class="s1">roles</span><span class="s4">.</span><span class="s1">DMLTableRole</span><span class="s4">, </span><span class="s1">FromClauseAlias</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Represents an table or selectable alias (AS). 
 
    Represents an alias, as typically applied to any table or 
    sub-select within a SQL statement using the ``AS`` keyword (or 
    without the keyword on certain databases such as Oracle). 
 
    This object is constructed from the :func:`_expression.alias` module 
    level function as well as the :meth:`_expression.FromClause.alias` 
    method available 
    on all :class:`_expression.FromClause` subclasses. 
 
    .. seealso:: 
 
        :meth:`_expression.FromClause.alias` 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;alias&quot;</span>

    <span class="s1">inherit_cache </span><span class="s4">= </span><span class="s3">True</span>

    <span class="s1">element</span><span class="s4">: </span><span class="s1">FromClause</span>

    <span class="s4">@</span><span class="s1">classmethod</span>
    <span class="s3">def </span><span class="s1">_factory</span><span class="s4">(</span>
        <span class="s1">cls</span><span class="s4">,</span>
        <span class="s1">selectable</span><span class="s4">: </span><span class="s1">FromClause</span><span class="s4">,</span>
        <span class="s1">name</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">flat</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; NamedFromClause</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">coercions</span><span class="s4">.</span><span class="s1">expect</span><span class="s4">(</span>
            <span class="s1">roles</span><span class="s4">.</span><span class="s1">FromClauseRole</span><span class="s4">, </span><span class="s1">selectable</span><span class="s4">, </span><span class="s1">allow_select</span><span class="s4">=</span><span class="s3">True</span>
        <span class="s4">).</span><span class="s1">alias</span><span class="s4">(</span><span class="s1">name</span><span class="s4">=</span><span class="s1">name</span><span class="s4">, </span><span class="s1">flat</span><span class="s4">=</span><span class="s1">flat</span><span class="s4">)</span>


<span class="s3">class </span><span class="s1">TableValuedAlias</span><span class="s4">(</span><span class="s1">LateralFromClause</span><span class="s4">, </span><span class="s1">Alias</span><span class="s4">):</span>
    <span class="s5">&quot;&quot;&quot;An alias against a &quot;table valued&quot; SQL function. 
 
    This construct provides for a SQL function that returns columns 
    to be used in the FROM clause of a SELECT statement.   The 
    object is generated using the :meth:`_functions.FunctionElement.table_valued` 
    method, e.g.: 
 
    .. sourcecode:: pycon+sql 
 
        &gt;&gt;&gt; from sqlalchemy import select, func 
        &gt;&gt;&gt; fn = func.json_array_elements_text('[&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]').table_valued(&quot;value&quot;) 
        &gt;&gt;&gt; print(select(fn.c.value)) 
        {printsql}SELECT anon_1.value 
        FROM json_array_elements_text(:json_array_elements_text_1) AS anon_1 
 
    .. versionadded:: 1.4.0b2 
 
    .. seealso:: 
 
        :ref:`tutorial_functions_table_valued` - in the :ref:`unified_tutorial` 
 
    &quot;&quot;&quot;  </span><span class="s0"># noqa: E501</span>

    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;table_valued_alias&quot;</span>

    <span class="s1">_supports_derived_columns </span><span class="s4">= </span><span class="s3">True</span>
    <span class="s1">_render_derived </span><span class="s4">= </span><span class="s3">False</span>
    <span class="s1">_render_derived_w_types </span><span class="s4">= </span><span class="s3">False</span>
    <span class="s1">joins_implicitly </span><span class="s4">= </span><span class="s3">False</span>

    <span class="s1">_traverse_internals</span><span class="s4">: </span><span class="s1">_TraverseInternalsType </span><span class="s4">= [</span>
        <span class="s4">(</span><span class="s5">&quot;element&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_clauseelement</span><span class="s4">),</span>
        <span class="s4">(</span><span class="s5">&quot;name&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_anon_name</span><span class="s4">),</span>
        <span class="s4">(</span><span class="s5">&quot;_tableval_type&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_type</span><span class="s4">),</span>
        <span class="s4">(</span><span class="s5">&quot;_render_derived&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_boolean</span><span class="s4">),</span>
        <span class="s4">(</span><span class="s5">&quot;_render_derived_w_types&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_boolean</span><span class="s4">),</span>
    <span class="s4">]</span>

    <span class="s3">def </span><span class="s1">_init</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">selectable</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
        <span class="s4">*,</span>
        <span class="s1">name</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">table_value_type</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">TableValueType</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">joins_implicitly</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s1">super</span><span class="s4">().</span><span class="s1">_init</span><span class="s4">(</span><span class="s1">selectable</span><span class="s4">, </span><span class="s1">name</span><span class="s4">=</span><span class="s1">name</span><span class="s4">)</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">joins_implicitly </span><span class="s4">= </span><span class="s1">joins_implicitly</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_tableval_type </span><span class="s4">= (</span>
            <span class="s1">type_api</span><span class="s4">.</span><span class="s1">TABLEVALUE</span>
            <span class="s3">if </span><span class="s1">table_value_type </span><span class="s3">is None</span>
            <span class="s3">else </span><span class="s1">table_value_type</span>
        <span class="s4">)</span>

    <span class="s4">@</span><span class="s1">HasMemoized</span><span class="s4">.</span><span class="s1">memoized_attribute</span>
    <span class="s3">def </span><span class="s1">column</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; TableValuedColumn</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;Return a column expression representing this 
        :class:`_sql.TableValuedAlias`. 
 
        This accessor is used to implement the 
        :meth:`_functions.FunctionElement.column_valued` method. See that 
        method for further details. 
 
        E.g.: 
 
        .. sourcecode:: pycon+sql 
 
            &gt;&gt;&gt; print(select(func.some_func().table_valued(&quot;value&quot;).column)) 
            {printsql}SELECT anon_1 FROM some_func() AS anon_1 
 
        .. seealso:: 
 
            :meth:`_functions.FunctionElement.column_valued` 
 
        &quot;&quot;&quot;</span>

        <span class="s3">return </span><span class="s1">TableValuedColumn</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_tableval_type</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">alias</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">name</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">, </span><span class="s1">flat</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span>
    <span class="s4">) </span><span class="s1">-&gt; TableValuedAlias</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Return a new alias of this :class:`_sql.TableValuedAlias`. 
 
        This creates a distinct FROM object that will be distinguished 
        from the original one when used in a SQL statement. 
 
        &quot;&quot;&quot;</span>

        <span class="s1">tva</span><span class="s4">: </span><span class="s1">TableValuedAlias </span><span class="s4">= </span><span class="s1">TableValuedAlias</span><span class="s4">.</span><span class="s1">_construct</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">,</span>
            <span class="s1">name</span><span class="s4">=</span><span class="s1">name</span><span class="s4">,</span>
            <span class="s1">table_value_type</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_tableval_type</span><span class="s4">,</span>
            <span class="s1">joins_implicitly</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">joins_implicitly</span><span class="s4">,</span>
        <span class="s4">)</span>

        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_render_derived</span><span class="s4">:</span>
            <span class="s1">tva</span><span class="s4">.</span><span class="s1">_render_derived </span><span class="s4">= </span><span class="s3">True</span>
            <span class="s1">tva</span><span class="s4">.</span><span class="s1">_render_derived_w_types </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_render_derived_w_types</span>

        <span class="s3">return </span><span class="s1">tva</span>

    <span class="s3">def </span><span class="s1">lateral</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">name</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">) </span><span class="s1">-&gt; LateralFromClause</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Return a new :class:`_sql.TableValuedAlias` with the lateral flag 
        set, so that it renders as LATERAL. 
 
        .. seealso:: 
 
            :func:`_expression.lateral` 
 
        &quot;&quot;&quot;</span>
        <span class="s1">tva </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">alias</span><span class="s4">(</span><span class="s1">name</span><span class="s4">=</span><span class="s1">name</span><span class="s4">)</span>
        <span class="s1">tva</span><span class="s4">.</span><span class="s1">_is_lateral </span><span class="s4">= </span><span class="s3">True</span>
        <span class="s3">return </span><span class="s1">tva</span>

    <span class="s3">def </span><span class="s1">render_derived</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">name</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">with_types</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; TableValuedAlias</span><span class="s4">:</span>
        <span class="s5">&quot;&quot;&quot;Apply &quot;render derived&quot; to this :class:`_sql.TableValuedAlias`. 
 
        This has the effect of the individual column names listed out 
        after the alias name in the &quot;AS&quot; sequence, e.g.: 
 
        .. sourcecode:: pycon+sql 
 
            &gt;&gt;&gt; print( 
            ...     select( 
            ...         func.unnest(array([&quot;one&quot;, &quot;two&quot;, &quot;three&quot;])). 
                        table_valued(&quot;x&quot;, with_ordinality=&quot;o&quot;).render_derived() 
            ...     ) 
            ... ) 
            {printsql}SELECT anon_1.x, anon_1.o 
            FROM unnest(ARRAY[%(param_1)s, %(param_2)s, %(param_3)s]) WITH ORDINALITY AS anon_1(x, o) 
 
        The ``with_types`` keyword will render column types inline within 
        the alias expression (this syntax currently applies to the 
        PostgreSQL database): 
 
        .. sourcecode:: pycon+sql 
 
            &gt;&gt;&gt; print( 
            ...     select( 
            ...         func.json_to_recordset( 
            ...             '[{&quot;a&quot;:1,&quot;b&quot;:&quot;foo&quot;},{&quot;a&quot;:&quot;2&quot;,&quot;c&quot;:&quot;bar&quot;}]' 
            ...         ) 
            ...         .table_valued(column(&quot;a&quot;, Integer), column(&quot;b&quot;, String)) 
            ...         .render_derived(with_types=True) 
            ...     ) 
            ... ) 
            {printsql}SELECT anon_1.a, anon_1.b FROM json_to_recordset(:json_to_recordset_1) 
            AS anon_1(a INTEGER, b VARCHAR) 
 
        :param name: optional string name that will be applied to the alias 
         generated.  If left as None, a unique anonymizing name will be used. 
 
        :param with_types: if True, the derived columns will include the 
         datatype specification with each column. This is a special syntax 
         currently known to be required by PostgreSQL for some SQL functions. 
 
        &quot;&quot;&quot;  </span><span class="s0"># noqa: E501</span>

        <span class="s0"># note: don't use the @_generative system here, keep a reference</span>
        <span class="s0"># to the original object.  otherwise you can have re-use of the</span>
        <span class="s0"># python id() of the original which can cause name conflicts if</span>
        <span class="s0"># a new anon-name grabs the same identifier as the local anon-name</span>
        <span class="s0"># (just saw it happen on CI)</span>

        <span class="s0"># construct against original to prevent memory growth</span>
        <span class="s0"># for repeated generations</span>
        <span class="s1">new_alias</span><span class="s4">: </span><span class="s1">TableValuedAlias </span><span class="s4">= </span><span class="s1">TableValuedAlias</span><span class="s4">.</span><span class="s1">_construct</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">element</span><span class="s4">,</span>
            <span class="s1">name</span><span class="s4">=</span><span class="s1">name</span><span class="s4">,</span>
            <span class="s1">table_value_type</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_tableval_type</span><span class="s4">,</span>
            <span class="s1">joins_implicitly</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">joins_implicitly</span><span class="s4">,</span>
        <span class="s4">)</span>
        <span class="s1">new_alias</span><span class="s4">.</span><span class="s1">_render_derived </span><span class="s4">= </span><span class="s3">True</span>
        <span class="s1">new_alias</span><span class="s4">.</span><span class="s1">_render_derived_w_types </span><span class="s4">= </span><span class="s1">with_types</span>
        <span class="s3">return </span><span class="s1">new_alias</span>


<span class="s3">class </span><span class="s1">Lateral</span><span class="s4">(</span><span class="s1">FromClauseAlias</span><span class="s4">, </span><span class="s1">LateralFromClause</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Represent a LATERAL subquery. 
 
    This object is constructed from the :func:`_expression.lateral` module 
    level function as well as the :meth:`_expression.FromClause.lateral` 
    method available 
    on all :class:`_expression.FromClause` subclasses. 
 
    While LATERAL is part of the SQL standard, currently only more recent 
    PostgreSQL versions provide support for this keyword. 
 
    .. seealso:: 
 
        :ref:`tutorial_lateral_correlation` -  overview of usage. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;lateral&quot;</span>
    <span class="s1">_is_lateral </span><span class="s4">= </span><span class="s3">True</span>

    <span class="s1">inherit_cache </span><span class="s4">= </span><span class="s3">True</span>

    <span class="s4">@</span><span class="s1">classmethod</span>
    <span class="s3">def </span><span class="s1">_factory</span><span class="s4">(</span>
        <span class="s1">cls</span><span class="s4">,</span>
        <span class="s1">selectable</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span><span class="s1">SelectBase</span><span class="s4">, </span><span class="s1">_FromClauseArgument</span><span class="s4">],</span>
        <span class="s1">name</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; LateralFromClause</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">coercions</span><span class="s4">.</span><span class="s1">expect</span><span class="s4">(</span>
            <span class="s1">roles</span><span class="s4">.</span><span class="s1">FromClauseRole</span><span class="s4">, </span><span class="s1">selectable</span><span class="s4">, </span><span class="s1">explicit_subquery</span><span class="s4">=</span><span class="s3">True</span>
        <span class="s4">).</span><span class="s1">lateral</span><span class="s4">(</span><span class="s1">name</span><span class="s4">=</span><span class="s1">name</span><span class="s4">)</span>


<span class="s3">class </span><span class="s1">TableSample</span><span class="s4">(</span><span class="s1">FromClauseAlias</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Represent a TABLESAMPLE clause. 
 
    This object is constructed from the :func:`_expression.tablesample` module 
    level function as well as the :meth:`_expression.FromClause.tablesample` 
    method 
    available on all :class:`_expression.FromClause` subclasses. 
 
    .. seealso:: 
 
        :func:`_expression.tablesample` 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;tablesample&quot;</span>

    <span class="s1">_traverse_internals</span><span class="s4">: </span><span class="s1">_TraverseInternalsType </span><span class="s4">= (</span>
        <span class="s1">AliasedReturnsRows</span><span class="s4">.</span><span class="s1">_traverse_internals</span>
        <span class="s4">+ [</span>
            <span class="s4">(</span><span class="s5">&quot;sampling&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_clauseelement</span><span class="s4">),</span>
            <span class="s4">(</span><span class="s5">&quot;seed&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_clauseelement</span><span class="s4">),</span>
        <span class="s4">]</span>
    <span class="s4">)</span>

    <span class="s4">@</span><span class="s1">classmethod</span>
    <span class="s3">def </span><span class="s1">_factory</span><span class="s4">(</span>
        <span class="s1">cls</span><span class="s4">,</span>
        <span class="s1">selectable</span><span class="s4">: </span><span class="s1">_FromClauseArgument</span><span class="s4">,</span>
        <span class="s1">sampling</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span><span class="s1">float</span><span class="s4">, </span><span class="s1">Function</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]],</span>
        <span class="s1">name</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">seed</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">roles</span><span class="s4">.</span><span class="s1">ExpressionElementRole</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]] = </span><span class="s3">None</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; TableSample</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">coercions</span><span class="s4">.</span><span class="s1">expect</span><span class="s4">(</span><span class="s1">roles</span><span class="s4">.</span><span class="s1">FromClauseRole</span><span class="s4">, </span><span class="s1">selectable</span><span class="s4">).</span><span class="s1">tablesample</span><span class="s4">(</span>
            <span class="s1">sampling</span><span class="s4">, </span><span class="s1">name</span><span class="s4">=</span><span class="s1">name</span><span class="s4">, </span><span class="s1">seed</span><span class="s4">=</span><span class="s1">seed</span>
        <span class="s4">)</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">preload_module</span><span class="s4">(</span><span class="s5">&quot;sqlalchemy.sql.functions&quot;</span><span class="s4">)</span>
    <span class="s3">def </span><span class="s1">_init</span><span class="s4">(  </span><span class="s0"># type: ignore[override]</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">selectable</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
        <span class="s4">*,</span>
        <span class="s1">name</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">sampling</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span><span class="s1">float</span><span class="s4">, </span><span class="s1">Function</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]],</span>
        <span class="s1">seed</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">roles</span><span class="s4">.</span><span class="s1">ExpressionElementRole</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]] = </span><span class="s3">None</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s3">assert </span><span class="s1">sampling </span><span class="s3">is not None</span>
        <span class="s1">functions </span><span class="s4">= </span><span class="s1">util</span><span class="s4">.</span><span class="s1">preloaded</span><span class="s4">.</span><span class="s1">sql_functions</span>
        <span class="s3">if not </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">sampling</span><span class="s4">, </span><span class="s1">functions</span><span class="s4">.</span><span class="s1">Function</span><span class="s4">):</span>
            <span class="s1">sampling </span><span class="s4">= </span><span class="s1">functions</span><span class="s4">.</span><span class="s1">func</span><span class="s4">.</span><span class="s1">system</span><span class="s4">(</span><span class="s1">sampling</span><span class="s4">)</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">sampling</span><span class="s4">: </span><span class="s1">Function</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">] = </span><span class="s1">sampling</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">seed </span><span class="s4">= </span><span class="s1">seed</span>
        <span class="s1">super</span><span class="s4">().</span><span class="s1">_init</span><span class="s4">(</span><span class="s1">selectable</span><span class="s4">, </span><span class="s1">name</span><span class="s4">=</span><span class="s1">name</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_get_method</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Function</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]:</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">sampling</span>


<span class="s3">class </span><span class="s1">CTE</span><span class="s4">(</span>
    <span class="s1">roles</span><span class="s4">.</span><span class="s1">DMLTableRole</span><span class="s4">,</span>
    <span class="s1">roles</span><span class="s4">.</span><span class="s1">IsCTERole</span><span class="s4">,</span>
    <span class="s1">Generative</span><span class="s4">,</span>
    <span class="s1">HasPrefixes</span><span class="s4">,</span>
    <span class="s1">HasSuffixes</span><span class="s4">,</span>
    <span class="s1">AliasedReturnsRows</span><span class="s4">,</span>
<span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Represent a Common Table Expression. 
 
    The :class:`_expression.CTE` object is obtained using the 
    :meth:`_sql.SelectBase.cte` method from any SELECT statement. A less often 
    available syntax also allows use of the :meth:`_sql.HasCTE.cte` method 
    present on :term:`DML` constructs such as :class:`_sql.Insert`, 
    :class:`_sql.Update` and 
    :class:`_sql.Delete`.   See the :meth:`_sql.HasCTE.cte` method for 
    usage details on CTEs. 
 
    .. seealso:: 
 
        :ref:`tutorial_subqueries_ctes` - in the 2.0 tutorial 
 
        :meth:`_sql.HasCTE.cte` - examples of calling styles 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;cte&quot;</span>

    <span class="s1">_traverse_internals</span><span class="s4">: </span><span class="s1">_TraverseInternalsType </span><span class="s4">= (</span>
        <span class="s1">AliasedReturnsRows</span><span class="s4">.</span><span class="s1">_traverse_internals</span>
        <span class="s4">+ [</span>
            <span class="s4">(</span><span class="s5">&quot;_cte_alias&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_clauseelement</span><span class="s4">),</span>
            <span class="s4">(</span><span class="s5">&quot;_restates&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_clauseelement</span><span class="s4">),</span>
            <span class="s4">(</span><span class="s5">&quot;recursive&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_boolean</span><span class="s4">),</span>
            <span class="s4">(</span><span class="s5">&quot;nesting&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_boolean</span><span class="s4">),</span>
        <span class="s4">]</span>
        <span class="s4">+ </span><span class="s1">HasPrefixes</span><span class="s4">.</span><span class="s1">_has_prefixes_traverse_internals</span>
        <span class="s4">+ </span><span class="s1">HasSuffixes</span><span class="s4">.</span><span class="s1">_has_suffixes_traverse_internals</span>
    <span class="s4">)</span>

    <span class="s1">element</span><span class="s4">: </span><span class="s1">HasCTE</span>

    <span class="s4">@</span><span class="s1">classmethod</span>
    <span class="s3">def </span><span class="s1">_factory</span><span class="s4">(</span>
        <span class="s1">cls</span><span class="s4">,</span>
        <span class="s1">selectable</span><span class="s4">: </span><span class="s1">HasCTE</span><span class="s4">,</span>
        <span class="s1">name</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">recursive</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; CTE</span><span class="s4">:</span>
        <span class="s2">r&quot;&quot;&quot;Return a new :class:`_expression.CTE`, 
        or Common Table Expression instance. 
 
        Please see :meth:`_expression.HasCTE.cte` for detail on CTE usage. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">coercions</span><span class="s4">.</span><span class="s1">expect</span><span class="s4">(</span><span class="s1">roles</span><span class="s4">.</span><span class="s1">HasCTERole</span><span class="s4">, </span><span class="s1">selectable</span><span class="s4">).</span><span class="s1">cte</span><span class="s4">(</span>
            <span class="s1">name</span><span class="s4">=</span><span class="s1">name</span><span class="s4">, </span><span class="s1">recursive</span><span class="s4">=</span><span class="s1">recursive</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_init</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">selectable</span><span class="s4">: </span><span class="s1">Select</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">],</span>
        <span class="s4">*,</span>
        <span class="s1">name</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">recursive</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
        <span class="s1">nesting</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
        <span class="s1">_cte_alias</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">CTE</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">_restates</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">CTE</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">_prefixes</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Tuple</span><span class="s4">[()]] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">_suffixes</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Tuple</span><span class="s4">[()]] = </span><span class="s3">None</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">recursive </span><span class="s4">= </span><span class="s1">recursive</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">nesting </span><span class="s4">= </span><span class="s1">nesting</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_cte_alias </span><span class="s4">= </span><span class="s1">_cte_alias</span>
        <span class="s0"># Keep recursivity reference with union/union_all</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_restates </span><span class="s4">= </span><span class="s1">_restates</span>
        <span class="s3">if </span><span class="s1">_prefixes</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_prefixes </span><span class="s4">= </span><span class="s1">_prefixes</span>
        <span class="s3">if </span><span class="s1">_suffixes</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_suffixes </span><span class="s4">= </span><span class="s1">_suffixes</span>
        <span class="s1">super</span><span class="s4">().</span><span class="s1">_init</span><span class="s4">(</span><span class="s1">selectable</span><span class="s4">, </span><span class="s1">name</span><span class="s4">=</span><span class="s1">name</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_populate_column_collection</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_cte_alias </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_cte_alias</span><span class="s4">.</span><span class="s1">_generate_fromclause_column_proxies</span><span class="s4">(</span><span class="s1">self</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">element</span><span class="s4">.</span><span class="s1">_generate_fromclause_column_proxies</span><span class="s4">(</span><span class="s1">self</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">alias</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">name</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">, </span><span class="s1">flat</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">) </span><span class="s1">-&gt; CTE</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Return an :class:`_expression.Alias` of this 
        :class:`_expression.CTE`. 
 
        This method is a CTE-specific specialization of the 
        :meth:`_expression.FromClause.alias` method. 
 
        .. seealso:: 
 
            :ref:`tutorial_using_aliases` 
 
            :func:`_expression.alias` 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">CTE</span><span class="s4">.</span><span class="s1">_construct</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">element</span><span class="s4">,</span>
            <span class="s1">name</span><span class="s4">=</span><span class="s1">name</span><span class="s4">,</span>
            <span class="s1">recursive</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">recursive</span><span class="s4">,</span>
            <span class="s1">nesting</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">nesting</span><span class="s4">,</span>
            <span class="s1">_cte_alias</span><span class="s4">=</span><span class="s1">self</span><span class="s4">,</span>
            <span class="s1">_prefixes</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_prefixes</span><span class="s4">,</span>
            <span class="s1">_suffixes</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_suffixes</span><span class="s4">,</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">union</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, *</span><span class="s1">other</span><span class="s4">: </span><span class="s1">_SelectStatementForCompoundArgument</span><span class="s4">) </span><span class="s1">-&gt; CTE</span><span class="s4">:</span>
        <span class="s2">r&quot;&quot;&quot;Return a new :class:`_expression.CTE` with a SQL ``UNION`` 
        of the original CTE against the given selectables provided 
        as positional arguments. 
 
        :param \*other: one or more elements with which to create a 
         UNION. 
 
         .. versionchanged:: 1.4.28 multiple elements are now accepted. 
 
        .. seealso:: 
 
            :meth:`_sql.HasCTE.cte` - examples of calling styles 
 
        &quot;&quot;&quot;</span>
        <span class="s3">assert </span><span class="s1">is_select_statement</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">element</span>
        <span class="s4">), </span><span class="s5">f&quot;CTE element f</span><span class="s3">{</span><span class="s1">self</span><span class="s4">.</span><span class="s1">element</span><span class="s3">} </span><span class="s5">does not support union()&quot;</span>

        <span class="s3">return </span><span class="s1">CTE</span><span class="s4">.</span><span class="s1">_construct</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">element</span><span class="s4">.</span><span class="s1">union</span><span class="s4">(*</span><span class="s1">other</span><span class="s4">),</span>
            <span class="s1">name</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">name</span><span class="s4">,</span>
            <span class="s1">recursive</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">recursive</span><span class="s4">,</span>
            <span class="s1">nesting</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">nesting</span><span class="s4">,</span>
            <span class="s1">_restates</span><span class="s4">=</span><span class="s1">self</span><span class="s4">,</span>
            <span class="s1">_prefixes</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_prefixes</span><span class="s4">,</span>
            <span class="s1">_suffixes</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_suffixes</span><span class="s4">,</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">union_all</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, *</span><span class="s1">other</span><span class="s4">: </span><span class="s1">_SelectStatementForCompoundArgument</span><span class="s4">) </span><span class="s1">-&gt; CTE</span><span class="s4">:</span>
        <span class="s2">r&quot;&quot;&quot;Return a new :class:`_expression.CTE` with a SQL ``UNION ALL`` 
        of the original CTE against the given selectables provided 
        as positional arguments. 
 
        :param \*other: one or more elements with which to create a 
         UNION. 
 
         .. versionchanged:: 1.4.28 multiple elements are now accepted. 
 
        .. seealso:: 
 
            :meth:`_sql.HasCTE.cte` - examples of calling styles 
 
        &quot;&quot;&quot;</span>

        <span class="s3">assert </span><span class="s1">is_select_statement</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">element</span>
        <span class="s4">), </span><span class="s5">f&quot;CTE element f</span><span class="s3">{</span><span class="s1">self</span><span class="s4">.</span><span class="s1">element</span><span class="s3">} </span><span class="s5">does not support union_all()&quot;</span>

        <span class="s3">return </span><span class="s1">CTE</span><span class="s4">.</span><span class="s1">_construct</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">element</span><span class="s4">.</span><span class="s1">union_all</span><span class="s4">(*</span><span class="s1">other</span><span class="s4">),</span>
            <span class="s1">name</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">name</span><span class="s4">,</span>
            <span class="s1">recursive</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">recursive</span><span class="s4">,</span>
            <span class="s1">nesting</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">nesting</span><span class="s4">,</span>
            <span class="s1">_restates</span><span class="s4">=</span><span class="s1">self</span><span class="s4">,</span>
            <span class="s1">_prefixes</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_prefixes</span><span class="s4">,</span>
            <span class="s1">_suffixes</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_suffixes</span><span class="s4">,</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_get_reference_cte</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; CTE</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot; 
        A recursive CTE is updated to attach the recursive part. 
        Updated CTEs should still refer to the original CTE. 
        This function returns this reference identifier. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_restates </span><span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_restates </span><span class="s3">is not None else </span><span class="s1">self</span>


<span class="s3">class </span><span class="s1">_CTEOpts</span><span class="s4">(</span><span class="s1">NamedTuple</span><span class="s4">):</span>
    <span class="s1">nesting</span><span class="s4">: </span><span class="s1">bool</span>


<span class="s3">class </span><span class="s1">_ColumnsPlusNames</span><span class="s4">(</span><span class="s1">NamedTuple</span><span class="s4">):</span>
    <span class="s1">required_label_name</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]</span>
    <span class="s5">&quot;&quot;&quot; 
    string label name, if non-None, must be rendered as a 
    label, i.e. &quot;AS &lt;name&gt;&quot; 
    &quot;&quot;&quot;</span>

    <span class="s1">proxy_key</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]</span>
    <span class="s5">&quot;&quot;&quot; 
    proxy_key that is to be part of the result map for this 
    col.  this is also the key in a fromclause.c or 
    select.selected_columns collection 
    &quot;&quot;&quot;</span>

    <span class="s1">fallback_label_name</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]</span>
    <span class="s5">&quot;&quot;&quot; 
    name that can be used to render an &quot;AS &lt;name&gt;&quot; when 
    we have to render a label even though 
    required_label_name was not given 
    &quot;&quot;&quot;</span>

    <span class="s1">column</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">], </span><span class="s1">TextClause</span><span class="s4">]</span>
    <span class="s5">&quot;&quot;&quot; 
    the ColumnElement itself 
    &quot;&quot;&quot;</span>

    <span class="s1">repeated</span><span class="s4">: </span><span class="s1">bool</span>
    <span class="s5">&quot;&quot;&quot; 
    True if this is a duplicate of a previous column 
    in the list of columns 
    &quot;&quot;&quot;</span>


<span class="s3">class </span><span class="s1">SelectsRows</span><span class="s4">(</span><span class="s1">ReturnsRows</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Sub-base of ReturnsRows for elements that deliver rows 
    directly, namely SELECT and INSERT/UPDATE/DELETE..RETURNING&quot;&quot;&quot;</span>

    <span class="s1">_label_style</span><span class="s4">: </span><span class="s1">SelectLabelStyle </span><span class="s4">= </span><span class="s1">LABEL_STYLE_NONE</span>

    <span class="s3">def </span><span class="s1">_generate_columns_plus_names</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">anon_for_dupe_key</span><span class="s4">: </span><span class="s1">bool</span><span class="s4">,</span>
        <span class="s1">cols</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_SelectIterable</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; List</span><span class="s4">[</span><span class="s1">_ColumnsPlusNames</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;Generate column names as rendered in a SELECT statement by 
        the compiler. 
 
        This is distinct from the _column_naming_convention generator that's 
        intended for population of .c collections and similar, which has 
        different rules.   the collection returned here calls upon the 
        _column_naming_convention as well. 
 
        &quot;&quot;&quot;</span>

        <span class="s3">if </span><span class="s1">cols </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s1">cols </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_all_selected_columns</span>

        <span class="s1">key_naming_convention </span><span class="s4">= </span><span class="s1">SelectState</span><span class="s4">.</span><span class="s1">_column_naming_convention</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_label_style</span>
        <span class="s4">)</span>

        <span class="s1">names </span><span class="s4">= {}</span>

        <span class="s1">result</span><span class="s4">: </span><span class="s1">List</span><span class="s4">[</span><span class="s1">_ColumnsPlusNames</span><span class="s4">] = []</span>
        <span class="s1">result_append </span><span class="s4">= </span><span class="s1">result</span><span class="s4">.</span><span class="s1">append</span>

        <span class="s1">table_qualified </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_label_style </span><span class="s3">is </span><span class="s1">LABEL_STYLE_TABLENAME_PLUS_COL</span>
        <span class="s1">label_style_none </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_label_style </span><span class="s3">is </span><span class="s1">LABEL_STYLE_NONE</span>

        <span class="s0"># a counter used for &quot;dedupe&quot; labels, which have double underscores</span>
        <span class="s0"># in them and are never referred by name; they only act</span>
        <span class="s0"># as positional placeholders.  they need only be unique within</span>
        <span class="s0"># the single columns clause they're rendered within (required by</span>
        <span class="s0"># some dbs such as mysql).  So their anon identity is tracked against</span>
        <span class="s0"># a fixed counter rather than hash() identity.</span>
        <span class="s1">dedupe_hash </span><span class="s4">= </span><span class="s6">1</span>

        <span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">cols</span><span class="s4">:</span>
            <span class="s1">repeated </span><span class="s4">= </span><span class="s3">False</span>

            <span class="s3">if not </span><span class="s1">c</span><span class="s4">.</span><span class="s1">_render_label_in_columns_clause</span><span class="s4">:</span>
                <span class="s1">effective_name </span><span class="s4">= </span><span class="s1">required_label_name </span><span class="s4">= </span><span class="s1">fallback_label_name </span><span class="s4">= (</span>
                    <span class="s3">None</span>
                <span class="s4">)</span>
            <span class="s3">elif </span><span class="s1">label_style_none</span><span class="s4">:</span>
                <span class="s3">if </span><span class="s1">TYPE_CHECKING</span><span class="s4">:</span>
                    <span class="s3">assert </span><span class="s1">is_column_element</span><span class="s4">(</span><span class="s1">c</span><span class="s4">)</span>

                <span class="s1">effective_name </span><span class="s4">= </span><span class="s1">required_label_name </span><span class="s4">= </span><span class="s3">None</span>
                <span class="s1">fallback_label_name </span><span class="s4">= </span><span class="s1">c</span><span class="s4">.</span><span class="s1">_non_anon_label </span><span class="s3">or </span><span class="s1">c</span><span class="s4">.</span><span class="s1">_anon_name_label</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s3">if </span><span class="s1">TYPE_CHECKING</span><span class="s4">:</span>
                    <span class="s3">assert </span><span class="s1">is_column_element</span><span class="s4">(</span><span class="s1">c</span><span class="s4">)</span>

                <span class="s3">if </span><span class="s1">table_qualified</span><span class="s4">:</span>
                    <span class="s1">required_label_name </span><span class="s4">= </span><span class="s1">effective_name </span><span class="s4">= (</span>
                        <span class="s1">fallback_label_name</span>
                    <span class="s4">) = </span><span class="s1">c</span><span class="s4">.</span><span class="s1">_tq_label</span>
                <span class="s3">else</span><span class="s4">:</span>
                    <span class="s1">effective_name </span><span class="s4">= </span><span class="s1">fallback_label_name </span><span class="s4">= </span><span class="s1">c</span><span class="s4">.</span><span class="s1">_non_anon_label</span>
                    <span class="s1">required_label_name </span><span class="s4">= </span><span class="s3">None</span>

                <span class="s3">if </span><span class="s1">effective_name </span><span class="s3">is None</span><span class="s4">:</span>
                    <span class="s0"># it seems like this could be _proxy_key and we would</span>
                    <span class="s0"># not need _expression_label but it isn't</span>
                    <span class="s0"># giving us a clue when to use anon_label instead</span>
                    <span class="s1">expr_label </span><span class="s4">= </span><span class="s1">c</span><span class="s4">.</span><span class="s1">_expression_label</span>
                    <span class="s3">if </span><span class="s1">expr_label </span><span class="s3">is None</span><span class="s4">:</span>
                        <span class="s1">repeated </span><span class="s4">= </span><span class="s1">c</span><span class="s4">.</span><span class="s1">_anon_name_label </span><span class="s3">in </span><span class="s1">names</span>
                        <span class="s1">names</span><span class="s4">[</span><span class="s1">c</span><span class="s4">.</span><span class="s1">_anon_name_label</span><span class="s4">] = </span><span class="s1">c</span>
                        <span class="s1">effective_name </span><span class="s4">= </span><span class="s1">required_label_name </span><span class="s4">= </span><span class="s3">None</span>

                        <span class="s3">if </span><span class="s1">repeated</span><span class="s4">:</span>
                            <span class="s0"># here, &quot;required_label_name&quot; is sent as</span>
                            <span class="s0"># &quot;None&quot; and &quot;fallback_label_name&quot; is sent.</span>
                            <span class="s3">if </span><span class="s1">table_qualified</span><span class="s4">:</span>
                                <span class="s1">fallback_label_name </span><span class="s4">= (</span>
                                    <span class="s1">c</span><span class="s4">.</span><span class="s1">_dedupe_anon_tq_label_idx</span><span class="s4">(</span><span class="s1">dedupe_hash</span><span class="s4">)</span>
                                <span class="s4">)</span>
                                <span class="s1">dedupe_hash </span><span class="s4">+= </span><span class="s6">1</span>
                            <span class="s3">else</span><span class="s4">:</span>
                                <span class="s1">fallback_label_name </span><span class="s4">= </span><span class="s1">c</span><span class="s4">.</span><span class="s1">_dedupe_anon_label_idx</span><span class="s4">(</span>
                                    <span class="s1">dedupe_hash</span>
                                <span class="s4">)</span>
                                <span class="s1">dedupe_hash </span><span class="s4">+= </span><span class="s6">1</span>
                        <span class="s3">else</span><span class="s4">:</span>
                            <span class="s1">fallback_label_name </span><span class="s4">= </span><span class="s1">c</span><span class="s4">.</span><span class="s1">_anon_name_label</span>
                    <span class="s3">else</span><span class="s4">:</span>
                        <span class="s1">required_label_name </span><span class="s4">= </span><span class="s1">effective_name </span><span class="s4">= (</span>
                            <span class="s1">fallback_label_name</span>
                        <span class="s4">) = </span><span class="s1">expr_label</span>

            <span class="s3">if </span><span class="s1">effective_name </span><span class="s3">is not None</span><span class="s4">:</span>
                <span class="s3">if </span><span class="s1">TYPE_CHECKING</span><span class="s4">:</span>
                    <span class="s3">assert </span><span class="s1">is_column_element</span><span class="s4">(</span><span class="s1">c</span><span class="s4">)</span>

                <span class="s3">if </span><span class="s1">effective_name </span><span class="s3">in </span><span class="s1">names</span><span class="s4">:</span>
                    <span class="s0"># when looking to see if names[name] is the same column as</span>
                    <span class="s0"># c, use hash(), so that an annotated version of the column</span>
                    <span class="s0"># is seen as the same as the non-annotated</span>
                    <span class="s3">if </span><span class="s1">hash</span><span class="s4">(</span><span class="s1">names</span><span class="s4">[</span><span class="s1">effective_name</span><span class="s4">]) != </span><span class="s1">hash</span><span class="s4">(</span><span class="s1">c</span><span class="s4">):</span>
                        <span class="s0"># different column under the same name.  apply</span>
                        <span class="s0"># disambiguating label</span>
                        <span class="s3">if </span><span class="s1">table_qualified</span><span class="s4">:</span>
                            <span class="s1">required_label_name </span><span class="s4">= </span><span class="s1">fallback_label_name </span><span class="s4">= (</span>
                                <span class="s1">c</span><span class="s4">.</span><span class="s1">_anon_tq_label</span>
                            <span class="s4">)</span>
                        <span class="s3">else</span><span class="s4">:</span>
                            <span class="s1">required_label_name </span><span class="s4">= </span><span class="s1">fallback_label_name </span><span class="s4">= (</span>
                                <span class="s1">c</span><span class="s4">.</span><span class="s1">_anon_name_label</span>
                            <span class="s4">)</span>

                        <span class="s3">if </span><span class="s1">anon_for_dupe_key </span><span class="s3">and </span><span class="s1">required_label_name </span><span class="s3">in </span><span class="s1">names</span><span class="s4">:</span>
                            <span class="s0"># here, c._anon_tq_label is definitely unique to</span>
                            <span class="s0"># that column identity (or annotated version), so</span>
                            <span class="s0"># this should always be true.</span>
                            <span class="s0"># this is also an infrequent codepath because</span>
                            <span class="s0"># you need two levels of duplication to be here</span>
                            <span class="s3">assert </span><span class="s1">hash</span><span class="s4">(</span><span class="s1">names</span><span class="s4">[</span><span class="s1">required_label_name</span><span class="s4">]) == </span><span class="s1">hash</span><span class="s4">(</span><span class="s1">c</span><span class="s4">)</span>

                            <span class="s0"># the column under the disambiguating label is</span>
                            <span class="s0"># already present.  apply the &quot;dedupe&quot; label to</span>
                            <span class="s0"># subsequent occurrences of the column so that the</span>
                            <span class="s0"># original stays non-ambiguous</span>
                            <span class="s3">if </span><span class="s1">table_qualified</span><span class="s4">:</span>
                                <span class="s1">required_label_name </span><span class="s4">= </span><span class="s1">fallback_label_name </span><span class="s4">= (</span>
                                    <span class="s1">c</span><span class="s4">.</span><span class="s1">_dedupe_anon_tq_label_idx</span><span class="s4">(</span><span class="s1">dedupe_hash</span><span class="s4">)</span>
                                <span class="s4">)</span>
                                <span class="s1">dedupe_hash </span><span class="s4">+= </span><span class="s6">1</span>
                            <span class="s3">else</span><span class="s4">:</span>
                                <span class="s1">required_label_name </span><span class="s4">= </span><span class="s1">fallback_label_name </span><span class="s4">= (</span>
                                    <span class="s1">c</span><span class="s4">.</span><span class="s1">_dedupe_anon_label_idx</span><span class="s4">(</span><span class="s1">dedupe_hash</span><span class="s4">)</span>
                                <span class="s4">)</span>
                                <span class="s1">dedupe_hash </span><span class="s4">+= </span><span class="s6">1</span>
                            <span class="s1">repeated </span><span class="s4">= </span><span class="s3">True</span>
                        <span class="s3">else</span><span class="s4">:</span>
                            <span class="s1">names</span><span class="s4">[</span><span class="s1">required_label_name</span><span class="s4">] = </span><span class="s1">c</span>
                    <span class="s3">elif </span><span class="s1">anon_for_dupe_key</span><span class="s4">:</span>
                        <span class="s0"># same column under the same name. apply the &quot;dedupe&quot;</span>
                        <span class="s0"># label so that the original stays non-ambiguous</span>
                        <span class="s3">if </span><span class="s1">table_qualified</span><span class="s4">:</span>
                            <span class="s1">required_label_name </span><span class="s4">= </span><span class="s1">fallback_label_name </span><span class="s4">= (</span>
                                <span class="s1">c</span><span class="s4">.</span><span class="s1">_dedupe_anon_tq_label_idx</span><span class="s4">(</span><span class="s1">dedupe_hash</span><span class="s4">)</span>
                            <span class="s4">)</span>
                            <span class="s1">dedupe_hash </span><span class="s4">+= </span><span class="s6">1</span>
                        <span class="s3">else</span><span class="s4">:</span>
                            <span class="s1">required_label_name </span><span class="s4">= </span><span class="s1">fallback_label_name </span><span class="s4">= (</span>
                                <span class="s1">c</span><span class="s4">.</span><span class="s1">_dedupe_anon_label_idx</span><span class="s4">(</span><span class="s1">dedupe_hash</span><span class="s4">)</span>
                            <span class="s4">)</span>
                            <span class="s1">dedupe_hash </span><span class="s4">+= </span><span class="s6">1</span>
                        <span class="s1">repeated </span><span class="s4">= </span><span class="s3">True</span>
                <span class="s3">else</span><span class="s4">:</span>
                    <span class="s1">names</span><span class="s4">[</span><span class="s1">effective_name</span><span class="s4">] = </span><span class="s1">c</span>

            <span class="s1">result_append</span><span class="s4">(</span>
                <span class="s1">_ColumnsPlusNames</span><span class="s4">(</span>
                    <span class="s1">required_label_name</span><span class="s4">,</span>
                    <span class="s1">key_naming_convention</span><span class="s4">(</span><span class="s1">c</span><span class="s4">),</span>
                    <span class="s1">fallback_label_name</span><span class="s4">,</span>
                    <span class="s1">c</span><span class="s4">,</span>
                    <span class="s1">repeated</span><span class="s4">,</span>
                <span class="s4">)</span>
            <span class="s4">)</span>

        <span class="s3">return </span><span class="s1">result</span>


<span class="s3">class </span><span class="s1">HasCTE</span><span class="s4">(</span><span class="s1">roles</span><span class="s4">.</span><span class="s1">HasCTERole</span><span class="s4">, </span><span class="s1">SelectsRows</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Mixin that declares a class to include CTE support.&quot;&quot;&quot;</span>

    <span class="s1">_has_ctes_traverse_internals</span><span class="s4">: </span><span class="s1">_TraverseInternalsType </span><span class="s4">= [</span>
        <span class="s4">(</span><span class="s5">&quot;_independent_ctes&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_clauseelement_list</span><span class="s4">),</span>
        <span class="s4">(</span><span class="s5">&quot;_independent_ctes_opts&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_plain_obj</span><span class="s4">),</span>
    <span class="s4">]</span>

    <span class="s1">_independent_ctes</span><span class="s4">: </span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">CTE</span><span class="s4">, ...] = ()</span>
    <span class="s1">_independent_ctes_opts</span><span class="s4">: </span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">_CTEOpts</span><span class="s4">, ...] = ()</span>

    <span class="s4">@</span><span class="s1">_generative</span>
    <span class="s3">def </span><span class="s1">add_cte</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, *</span><span class="s1">ctes</span><span class="s4">: </span><span class="s1">CTE</span><span class="s4">, </span><span class="s1">nest_here</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s2">r&quot;&quot;&quot;Add one or more :class:`_sql.CTE` constructs to this statement. 
 
        This method will associate the given :class:`_sql.CTE` constructs with 
        the parent statement such that they will each be unconditionally 
        rendered in the WITH clause of the final statement, even if not 
        referenced elsewhere within the statement or any sub-selects. 
 
        The optional :paramref:`.HasCTE.add_cte.nest_here` parameter when set 
        to True will have the effect that each given :class:`_sql.CTE` will 
        render in a WITH clause rendered directly along with this statement, 
        rather than being moved to the top of the ultimate rendered statement, 
        even if this statement is rendered as a subquery within a larger 
        statement. 
 
        This method has two general uses. One is to embed CTE statements that 
        serve some purpose without being referenced explicitly, such as the use 
        case of embedding a DML statement such as an INSERT or UPDATE as a CTE 
        inline with a primary statement that may draw from its results 
        indirectly.  The other is to provide control over the exact placement 
        of a particular series of CTE constructs that should remain rendered 
        directly in terms of a particular statement that may be nested in a 
        larger statement. 
 
        E.g.:: 
 
            from sqlalchemy import table, column, select 
            t = table('t', column('c1'), column('c2')) 
 
            ins = t.insert().values({&quot;c1&quot;: &quot;x&quot;, &quot;c2&quot;: &quot;y&quot;}).cte() 
 
            stmt = select(t).add_cte(ins) 
 
        Would render:: 
 
            WITH anon_1 AS 
            (INSERT INTO t (c1, c2) VALUES (:param_1, :param_2)) 
            SELECT t.c1, t.c2 
            FROM t 
 
        Above, the &quot;anon_1&quot; CTE is not referenced in the SELECT 
        statement, however still accomplishes the task of running an INSERT 
        statement. 
 
        Similarly in a DML-related context, using the PostgreSQL 
        :class:`_postgresql.Insert` construct to generate an &quot;upsert&quot;:: 
 
            from sqlalchemy import table, column 
            from sqlalchemy.dialects.postgresql import insert 
 
            t = table(&quot;t&quot;, column(&quot;c1&quot;), column(&quot;c2&quot;)) 
 
            delete_statement_cte = ( 
                t.delete().where(t.c.c1 &lt; 1).cte(&quot;deletions&quot;) 
            ) 
 
            insert_stmt = insert(t).values({&quot;c1&quot;: 1, &quot;c2&quot;: 2}) 
            update_statement = insert_stmt.on_conflict_do_update( 
                index_elements=[t.c.c1], 
                set_={ 
                    &quot;c1&quot;: insert_stmt.excluded.c1, 
                    &quot;c2&quot;: insert_stmt.excluded.c2, 
                }, 
            ).add_cte(delete_statement_cte) 
 
            print(update_statement) 
 
        The above statement renders as:: 
 
            WITH deletions AS 
            (DELETE FROM t WHERE t.c1 &lt; %(c1_1)s) 
            INSERT INTO t (c1, c2) VALUES (%(c1)s, %(c2)s) 
            ON CONFLICT (c1) DO UPDATE SET c1 = excluded.c1, c2 = excluded.c2 
 
        .. versionadded:: 1.4.21 
 
        :param \*ctes: zero or more :class:`.CTE` constructs. 
 
         .. versionchanged:: 2.0  Multiple CTE instances are accepted 
 
        :param nest_here: if True, the given CTE or CTEs will be rendered 
         as though they specified the :paramref:`.HasCTE.cte.nesting` flag 
         to ``True`` when they were added to this :class:`.HasCTE`. 
         Assuming the given CTEs are not referenced in an outer-enclosing 
         statement as well, the CTEs given should render at the level of 
         this statement when this flag is given. 
 
         .. versionadded:: 2.0 
 
         .. seealso:: 
 
            :paramref:`.HasCTE.cte.nesting` 
 
 
        &quot;&quot;&quot;</span>
        <span class="s1">opt </span><span class="s4">= </span><span class="s1">_CTEOpts</span><span class="s4">(</span>
            <span class="s1">nest_here</span><span class="s4">,</span>
        <span class="s4">)</span>
        <span class="s3">for </span><span class="s1">cte </span><span class="s3">in </span><span class="s1">ctes</span><span class="s4">:</span>
            <span class="s1">cte </span><span class="s4">= </span><span class="s1">coercions</span><span class="s4">.</span><span class="s1">expect</span><span class="s4">(</span><span class="s1">roles</span><span class="s4">.</span><span class="s1">IsCTERole</span><span class="s4">, </span><span class="s1">cte</span><span class="s4">)</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_independent_ctes </span><span class="s4">+= (</span><span class="s1">cte</span><span class="s4">,)</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_independent_ctes_opts </span><span class="s4">+= (</span><span class="s1">opt</span><span class="s4">,)</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">cte</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">name</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">recursive</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
        <span class="s1">nesting</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; CTE</span><span class="s4">:</span>
        <span class="s2">r&quot;&quot;&quot;Return a new :class:`_expression.CTE`, 
        or Common Table Expression instance. 
 
        Common table expressions are a SQL standard whereby SELECT 
        statements can draw upon secondary statements specified along 
        with the primary statement, using a clause called &quot;WITH&quot;. 
        Special semantics regarding UNION can also be employed to 
        allow &quot;recursive&quot; queries, where a SELECT statement can draw 
        upon the set of rows that have previously been selected. 
 
        CTEs can also be applied to DML constructs UPDATE, INSERT 
        and DELETE on some databases, both as a source of CTE rows 
        when combined with RETURNING, as well as a consumer of 
        CTE rows. 
 
        SQLAlchemy detects :class:`_expression.CTE` objects, which are treated 
        similarly to :class:`_expression.Alias` objects, as special elements 
        to be delivered to the FROM clause of the statement as well 
        as to a WITH clause at the top of the statement. 
 
        For special prefixes such as PostgreSQL &quot;MATERIALIZED&quot; and 
        &quot;NOT MATERIALIZED&quot;, the :meth:`_expression.CTE.prefix_with` 
        method may be 
        used to establish these. 
 
        .. versionchanged:: 1.3.13 Added support for prefixes. 
           In particular - MATERIALIZED and NOT MATERIALIZED. 
 
        :param name: name given to the common table expression.  Like 
         :meth:`_expression.FromClause.alias`, the name can be left as 
         ``None`` in which case an anonymous symbol will be used at query 
         compile time. 
        :param recursive: if ``True``, will render ``WITH RECURSIVE``. 
         A recursive common table expression is intended to be used in 
         conjunction with UNION ALL in order to derive rows 
         from those already selected. 
        :param nesting: if ``True``, will render the CTE locally to the 
         statement in which it is referenced.   For more complex scenarios, 
         the :meth:`.HasCTE.add_cte` method using the 
         :paramref:`.HasCTE.add_cte.nest_here` 
         parameter may also be used to more carefully 
         control the exact placement of a particular CTE. 
 
         .. versionadded:: 1.4.24 
 
         .. seealso:: 
 
            :meth:`.HasCTE.add_cte` 
 
        The following examples include two from PostgreSQL's documentation at 
        https://www.postgresql.org/docs/current/static/queries-with.html, 
        as well as additional examples. 
 
        Example 1, non recursive:: 
 
            from sqlalchemy import (Table, Column, String, Integer, 
                                    MetaData, select, func) 
 
            metadata = MetaData() 
 
            orders = Table('orders', metadata, 
                Column('region', String), 
                Column('amount', Integer), 
                Column('product', String), 
                Column('quantity', Integer) 
            ) 
 
            regional_sales = select( 
                                orders.c.region, 
                                func.sum(orders.c.amount).label('total_sales') 
                            ).group_by(orders.c.region).cte(&quot;regional_sales&quot;) 
 
 
            top_regions = select(regional_sales.c.region).\ 
                    where( 
                        regional_sales.c.total_sales &gt; 
                        select( 
                            func.sum(regional_sales.c.total_sales) / 10 
                        ) 
                    ).cte(&quot;top_regions&quot;) 
 
            statement = select( 
                        orders.c.region, 
                        orders.c.product, 
                        func.sum(orders.c.quantity).label(&quot;product_units&quot;), 
                        func.sum(orders.c.amount).label(&quot;product_sales&quot;) 
                ).where(orders.c.region.in_( 
                    select(top_regions.c.region) 
                )).group_by(orders.c.region, orders.c.product) 
 
            result = conn.execute(statement).fetchall() 
 
        Example 2, WITH RECURSIVE:: 
 
            from sqlalchemy import (Table, Column, String, Integer, 
                                    MetaData, select, func) 
 
            metadata = MetaData() 
 
            parts = Table('parts', metadata, 
                Column('part', String), 
                Column('sub_part', String), 
                Column('quantity', Integer), 
            ) 
 
            included_parts = select(\ 
                parts.c.sub_part, parts.c.part, parts.c.quantity\ 
                ).\ 
                where(parts.c.part=='our part').\ 
                cte(recursive=True) 
 
 
            incl_alias = included_parts.alias() 
            parts_alias = parts.alias() 
            included_parts = included_parts.union_all( 
                select( 
                    parts_alias.c.sub_part, 
                    parts_alias.c.part, 
                    parts_alias.c.quantity 
                ).\ 
                where(parts_alias.c.part==incl_alias.c.sub_part) 
            ) 
 
            statement = select( 
                        included_parts.c.sub_part, 
                        func.sum(included_parts.c.quantity). 
                          label('total_quantity') 
                    ).\ 
                    group_by(included_parts.c.sub_part) 
 
            result = conn.execute(statement).fetchall() 
 
        Example 3, an upsert using UPDATE and INSERT with CTEs:: 
 
            from datetime import date 
            from sqlalchemy import (MetaData, Table, Column, Integer, 
                                    Date, select, literal, and_, exists) 
 
            metadata = MetaData() 
 
            visitors = Table('visitors', metadata, 
                Column('product_id', Integer, primary_key=True), 
                Column('date', Date, primary_key=True), 
                Column('count', Integer), 
            ) 
 
            # add 5 visitors for the product_id == 1 
            product_id = 1 
            day = date.today() 
            count = 5 
 
            update_cte = ( 
                visitors.update() 
                .where(and_(visitors.c.product_id == product_id, 
                            visitors.c.date == day)) 
                .values(count=visitors.c.count + count) 
                .returning(literal(1)) 
                .cte('update_cte') 
            ) 
 
            upsert = visitors.insert().from_select( 
                [visitors.c.product_id, visitors.c.date, visitors.c.count], 
                select(literal(product_id), literal(day), literal(count)) 
                    .where(~exists(update_cte.select())) 
            ) 
 
            connection.execute(upsert) 
 
        Example 4, Nesting CTE (SQLAlchemy 1.4.24 and above):: 
 
            value_a = select( 
                literal(&quot;root&quot;).label(&quot;n&quot;) 
            ).cte(&quot;value_a&quot;) 
 
            # A nested CTE with the same name as the root one 
            value_a_nested = select( 
                literal(&quot;nesting&quot;).label(&quot;n&quot;) 
            ).cte(&quot;value_a&quot;, nesting=True) 
 
            # Nesting CTEs takes ascendency locally 
            # over the CTEs at a higher level 
            value_b = select(value_a_nested.c.n).cte(&quot;value_b&quot;) 
 
            value_ab = select(value_a.c.n.label(&quot;a&quot;), value_b.c.n.label(&quot;b&quot;)) 
 
        The above query will render the second CTE nested inside the first, 
        shown with inline parameters below as:: 
 
            WITH 
                value_a AS 
                    (SELECT 'root' AS n), 
                value_b AS 
                    (WITH value_a AS 
                        (SELECT 'nesting' AS n) 
                    SELECT value_a.n AS n FROM value_a) 
            SELECT value_a.n AS a, value_b.n AS b 
            FROM value_a, value_b 
 
        The same CTE can be set up using the :meth:`.HasCTE.add_cte` method 
        as follows (SQLAlchemy 2.0 and above):: 
 
            value_a = select( 
                literal(&quot;root&quot;).label(&quot;n&quot;) 
            ).cte(&quot;value_a&quot;) 
 
            # A nested CTE with the same name as the root one 
            value_a_nested = select( 
                literal(&quot;nesting&quot;).label(&quot;n&quot;) 
            ).cte(&quot;value_a&quot;) 
 
            # Nesting CTEs takes ascendency locally 
            # over the CTEs at a higher level 
            value_b = ( 
                select(value_a_nested.c.n). 
                add_cte(value_a_nested, nest_here=True). 
                cte(&quot;value_b&quot;) 
            ) 
 
            value_ab = select(value_a.c.n.label(&quot;a&quot;), value_b.c.n.label(&quot;b&quot;)) 
 
        Example 5, Non-Linear CTE (SQLAlchemy 1.4.28 and above):: 
 
            edge = Table( 
                &quot;edge&quot;, 
                metadata, 
                Column(&quot;id&quot;, Integer, primary_key=True), 
                Column(&quot;left&quot;, Integer), 
                Column(&quot;right&quot;, Integer), 
            ) 
 
            root_node = select(literal(1).label(&quot;node&quot;)).cte( 
                &quot;nodes&quot;, recursive=True 
            ) 
 
            left_edge = select(edge.c.left).join( 
                root_node, edge.c.right == root_node.c.node 
            ) 
            right_edge = select(edge.c.right).join( 
                root_node, edge.c.left == root_node.c.node 
            ) 
 
            subgraph_cte = root_node.union(left_edge, right_edge) 
 
            subgraph = select(subgraph_cte) 
 
        The above query will render 2 UNIONs inside the recursive CTE:: 
 
            WITH RECURSIVE nodes(node) AS ( 
                    SELECT 1 AS node 
                UNION 
                    SELECT edge.&quot;left&quot; AS &quot;left&quot; 
                    FROM edge JOIN nodes ON edge.&quot;right&quot; = nodes.node 
                UNION 
                    SELECT edge.&quot;right&quot; AS &quot;right&quot; 
                    FROM edge JOIN nodes ON edge.&quot;left&quot; = nodes.node 
            ) 
            SELECT nodes.node FROM nodes 
 
        .. seealso:: 
 
            :meth:`_orm.Query.cte` - ORM version of 
            :meth:`_expression.HasCTE.cte`. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">CTE</span><span class="s4">.</span><span class="s1">_construct</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">, </span><span class="s1">name</span><span class="s4">=</span><span class="s1">name</span><span class="s4">, </span><span class="s1">recursive</span><span class="s4">=</span><span class="s1">recursive</span><span class="s4">, </span><span class="s1">nesting</span><span class="s4">=</span><span class="s1">nesting</span>
        <span class="s4">)</span>


<span class="s3">class </span><span class="s1">Subquery</span><span class="s4">(</span><span class="s1">AliasedReturnsRows</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Represent a subquery of a SELECT. 
 
    A :class:`.Subquery` is created by invoking the 
    :meth:`_expression.SelectBase.subquery` method, or for convenience the 
    :meth:`_expression.SelectBase.alias` method, on any 
    :class:`_expression.SelectBase` subclass 
    which includes :class:`_expression.Select`, 
    :class:`_expression.CompoundSelect`, and 
    :class:`_expression.TextualSelect`.  As rendered in a FROM clause, 
    it represents the 
    body of the SELECT statement inside of parenthesis, followed by the usual 
    &quot;AS &lt;somename&gt;&quot; that defines all &quot;alias&quot; objects. 
 
    The :class:`.Subquery` object is very similar to the 
    :class:`_expression.Alias` 
    object and can be used in an equivalent way.    The difference between 
    :class:`_expression.Alias` and :class:`.Subquery` is that 
    :class:`_expression.Alias` always 
    contains a :class:`_expression.FromClause` object whereas 
    :class:`.Subquery` 
    always contains a :class:`_expression.SelectBase` object. 
 
    .. versionadded:: 1.4 The :class:`.Subquery` class was added which now 
       serves the purpose of providing an aliased version of a SELECT 
       statement. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;subquery&quot;</span>

    <span class="s1">_is_subquery </span><span class="s4">= </span><span class="s3">True</span>

    <span class="s1">inherit_cache </span><span class="s4">= </span><span class="s3">True</span>

    <span class="s1">element</span><span class="s4">: </span><span class="s1">SelectBase</span>

    <span class="s4">@</span><span class="s1">classmethod</span>
    <span class="s3">def </span><span class="s1">_factory</span><span class="s4">(</span>
        <span class="s1">cls</span><span class="s4">, </span><span class="s1">selectable</span><span class="s4">: </span><span class="s1">SelectBase</span><span class="s4">, </span><span class="s1">name</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span>
    <span class="s4">) </span><span class="s1">-&gt; Subquery</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Return a :class:`.Subquery` object.&quot;&quot;&quot;</span>

        <span class="s3">return </span><span class="s1">coercions</span><span class="s4">.</span><span class="s1">expect</span><span class="s4">(</span>
            <span class="s1">roles</span><span class="s4">.</span><span class="s1">SelectStatementRole</span><span class="s4">, </span><span class="s1">selectable</span>
        <span class="s4">).</span><span class="s1">subquery</span><span class="s4">(</span><span class="s1">name</span><span class="s4">=</span><span class="s1">name</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">deprecated</span><span class="s4">(</span>
        <span class="s5">&quot;1.4&quot;</span><span class="s4">,</span>
        <span class="s5">&quot;The :meth:`.Subquery.as_scalar` method, which was previously &quot;</span>
        <span class="s5">&quot;``Alias.as_scalar()`` prior to version 1.4, is deprecated and &quot;</span>
        <span class="s5">&quot;will be removed in a future release; Please use the &quot;</span>
        <span class="s5">&quot;:meth:`_expression.Select.scalar_subquery` method of the &quot;</span>
        <span class="s5">&quot;:func:`_expression.select` &quot;</span>
        <span class="s5">&quot;construct before constructing a subquery object, or with the ORM &quot;</span>
        <span class="s5">&quot;use the :meth:`_query.Query.scalar_subquery` method.&quot;</span><span class="s4">,</span>
    <span class="s4">)</span>
    <span class="s3">def </span><span class="s1">as_scalar</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; ScalarSelect</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]:</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">element</span><span class="s4">.</span><span class="s1">set_label_style</span><span class="s4">(</span><span class="s1">LABEL_STYLE_NONE</span><span class="s4">).</span><span class="s1">scalar_subquery</span><span class="s4">()</span>


<span class="s3">class </span><span class="s1">FromGrouping</span><span class="s4">(</span><span class="s1">GroupedElement</span><span class="s4">, </span><span class="s1">FromClause</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Represent a grouping of a FROM clause&quot;&quot;&quot;</span>

    <span class="s1">_traverse_internals</span><span class="s4">: </span><span class="s1">_TraverseInternalsType </span><span class="s4">= [</span>
        <span class="s4">(</span><span class="s5">&quot;element&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_clauseelement</span><span class="s4">)</span>
    <span class="s4">]</span>

    <span class="s1">element</span><span class="s4">: </span><span class="s1">FromClause</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">element</span><span class="s4">: </span><span class="s1">FromClause</span><span class="s4">):</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">element </span><span class="s4">= </span><span class="s1">coercions</span><span class="s4">.</span><span class="s1">expect</span><span class="s4">(</span><span class="s1">roles</span><span class="s4">.</span><span class="s1">FromClauseRole</span><span class="s4">, </span><span class="s1">element</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_init_collections</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s3">pass</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">ro_non_memoized_property</span>
    <span class="s3">def </span><span class="s1">columns</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; ReadOnlyColumnCollection</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">KeyedColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]:</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">element</span><span class="s4">.</span><span class="s1">columns</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">ro_non_memoized_property</span>
    <span class="s3">def </span><span class="s1">c</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; ReadOnlyColumnCollection</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">KeyedColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]:</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">element</span><span class="s4">.</span><span class="s1">columns</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">primary_key</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Iterable</span><span class="s4">[</span><span class="s1">NamedColumn</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]:</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">element</span><span class="s4">.</span><span class="s1">primary_key</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">foreign_keys</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Iterable</span><span class="s4">[</span><span class="s1">ForeignKey</span><span class="s4">]:</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">element</span><span class="s4">.</span><span class="s1">foreign_keys</span>

    <span class="s3">def </span><span class="s1">is_derived_from</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">fromclause</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">FromClause</span><span class="s4">]) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">element</span><span class="s4">.</span><span class="s1">is_derived_from</span><span class="s4">(</span><span class="s1">fromclause</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">alias</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">name</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">, </span><span class="s1">flat</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span>
    <span class="s4">) </span><span class="s1">-&gt; NamedFromGrouping</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">NamedFromGrouping</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">element</span><span class="s4">.</span><span class="s1">alias</span><span class="s4">(</span><span class="s1">name</span><span class="s4">=</span><span class="s1">name</span><span class="s4">, </span><span class="s1">flat</span><span class="s4">=</span><span class="s1">flat</span><span class="s4">))</span>

    <span class="s3">def </span><span class="s1">_anonymous_fromclause</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; FromGrouping</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">FromGrouping</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">element</span><span class="s4">.</span><span class="s1">_anonymous_fromclause</span><span class="s4">(**</span><span class="s1">kw</span><span class="s4">))</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">ro_non_memoized_property</span>
    <span class="s3">def </span><span class="s1">_hide_froms</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Iterable</span><span class="s4">[</span><span class="s1">FromClause</span><span class="s4">]:</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">element</span><span class="s4">.</span><span class="s1">_hide_froms</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">ro_non_memoized_property</span>
    <span class="s3">def </span><span class="s1">_from_objects</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; List</span><span class="s4">[</span><span class="s1">FromClause</span><span class="s4">]:</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">element</span><span class="s4">.</span><span class="s1">_from_objects</span>

    <span class="s3">def </span><span class="s1">__getstate__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Dict</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">FromClause</span><span class="s4">]:</span>
        <span class="s3">return </span><span class="s4">{</span><span class="s5">&quot;element&quot;</span><span class="s4">: </span><span class="s1">self</span><span class="s4">.</span><span class="s1">element</span><span class="s4">}</span>

    <span class="s3">def </span><span class="s1">__setstate__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">state</span><span class="s4">: </span><span class="s1">Dict</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">FromClause</span><span class="s4">]) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">element </span><span class="s4">= </span><span class="s1">state</span><span class="s4">[</span><span class="s5">&quot;element&quot;</span><span class="s4">]</span>

    <span class="s3">if </span><span class="s1">TYPE_CHECKING</span><span class="s4">:</span>

        <span class="s3">def </span><span class="s1">self_group</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">, </span><span class="s1">against</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">OperatorType</span><span class="s4">] = </span><span class="s3">None</span>
        <span class="s4">) </span><span class="s1">-&gt; Self</span><span class="s4">: ...</span>


<span class="s3">class </span><span class="s1">NamedFromGrouping</span><span class="s4">(</span><span class="s1">FromGrouping</span><span class="s4">, </span><span class="s1">NamedFromClause</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;represent a grouping of a named FROM clause 
 
    .. versionadded:: 2.0 
 
    &quot;&quot;&quot;</span>

    <span class="s1">inherit_cache </span><span class="s4">= </span><span class="s3">True</span>

    <span class="s3">if </span><span class="s1">TYPE_CHECKING</span><span class="s4">:</span>

        <span class="s3">def </span><span class="s1">self_group</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">, </span><span class="s1">against</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">OperatorType</span><span class="s4">] = </span><span class="s3">None</span>
        <span class="s4">) </span><span class="s1">-&gt; Self</span><span class="s4">: ...</span>


<span class="s3">class </span><span class="s1">TableClause</span><span class="s4">(</span><span class="s1">roles</span><span class="s4">.</span><span class="s1">DMLTableRole</span><span class="s4">, </span><span class="s1">Immutable</span><span class="s4">, </span><span class="s1">NamedFromClause</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Represents a minimal &quot;table&quot; construct. 
 
    This is a lightweight table object that has only a name, a 
    collection of columns, which are typically produced 
    by the :func:`_expression.column` function, and a schema:: 
 
        from sqlalchemy import table, column 
 
        user = table(&quot;user&quot;, 
                column(&quot;id&quot;), 
                column(&quot;name&quot;), 
                column(&quot;description&quot;), 
        ) 
 
    The :class:`_expression.TableClause` construct serves as the base for 
    the more commonly used :class:`_schema.Table` object, providing 
    the usual set of :class:`_expression.FromClause` services including 
    the ``.c.`` collection and statement generation methods. 
 
    It does **not** provide all the additional schema-level services 
    of :class:`_schema.Table`, including constraints, references to other 
    tables, or support for :class:`_schema.MetaData`-level services. 
    It's useful 
    on its own as an ad-hoc construct used to generate quick SQL 
    statements when a more fully fledged :class:`_schema.Table` 
    is not on hand. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;table&quot;</span>

    <span class="s1">_traverse_internals</span><span class="s4">: </span><span class="s1">_TraverseInternalsType </span><span class="s4">= [</span>
        <span class="s4">(</span>
            <span class="s5">&quot;columns&quot;</span><span class="s4">,</span>
            <span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_fromclause_canonical_column_collection</span><span class="s4">,</span>
        <span class="s4">),</span>
        <span class="s4">(</span><span class="s5">&quot;name&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_string</span><span class="s4">),</span>
        <span class="s4">(</span><span class="s5">&quot;schema&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_string</span><span class="s4">),</span>
    <span class="s4">]</span>

    <span class="s1">_is_table </span><span class="s4">= </span><span class="s3">True</span>

    <span class="s1">fullname</span><span class="s4">: </span><span class="s1">str</span>

    <span class="s1">implicit_returning </span><span class="s4">= </span><span class="s3">False</span>
    <span class="s5">&quot;&quot;&quot;:class:`_expression.TableClause` 
    doesn't support having a primary key or column 
    -level defaults, so implicit returning doesn't apply.&quot;&quot;&quot;</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">ro_memoized_property</span>
    <span class="s3">def </span><span class="s1">_autoincrement_column</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Optional</span><span class="s4">[</span><span class="s1">ColumnClause</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]:</span>
        <span class="s2">&quot;&quot;&quot;No PK or default support so no autoincrement column.&quot;&quot;&quot;</span>
        <span class="s3">return None</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">name</span><span class="s4">: </span><span class="s1">str</span><span class="s4">, *</span><span class="s1">columns</span><span class="s4">: </span><span class="s1">ColumnClause</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">], **</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">):</span>
        <span class="s1">super</span><span class="s4">().</span><span class="s1">__init__</span><span class="s4">()</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">name </span><span class="s4">= </span><span class="s1">name</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_columns </span><span class="s4">= </span><span class="s1">DedupeColumnCollection</span><span class="s4">()</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">primary_key </span><span class="s4">= </span><span class="s1">ColumnSet</span><span class="s4">()  </span><span class="s0"># type: ignore</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">foreign_keys </span><span class="s4">= </span><span class="s1">set</span><span class="s4">()  </span><span class="s0"># type: ignore</span>
        <span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">columns</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">append_column</span><span class="s4">(</span><span class="s1">c</span><span class="s4">)</span>

        <span class="s1">schema </span><span class="s4">= </span><span class="s1">kw</span><span class="s4">.</span><span class="s1">pop</span><span class="s4">(</span><span class="s5">&quot;schema&quot;</span><span class="s4">, </span><span class="s3">None</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">schema </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">schema </span><span class="s4">= </span><span class="s1">schema</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">schema </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">fullname </span><span class="s4">= </span><span class="s5">&quot;%s.%s&quot; </span><span class="s4">% (</span><span class="s1">self</span><span class="s4">.</span><span class="s1">schema</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">name</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">fullname </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">name</span>
        <span class="s3">if </span><span class="s1">kw</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">exc</span><span class="s4">.</span><span class="s1">ArgumentError</span><span class="s4">(</span><span class="s5">&quot;Unsupported argument(s): %s&quot; </span><span class="s4">% </span><span class="s1">list</span><span class="s4">(</span><span class="s1">kw</span><span class="s4">))</span>

    <span class="s3">if </span><span class="s1">TYPE_CHECKING</span><span class="s4">:</span>

        <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">ro_non_memoized_property</span>
        <span class="s3">def </span><span class="s1">columns</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">,</span>
        <span class="s4">) </span><span class="s1">-&gt; ReadOnlyColumnCollection</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">ColumnClause</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]: ...</span>

        <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">ro_non_memoized_property</span>
        <span class="s3">def </span><span class="s1">c</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; ReadOnlyColumnCollection</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">ColumnClause</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]: ...</span>

    <span class="s3">def </span><span class="s1">__str__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; str</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">schema </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">schema </span><span class="s4">+ </span><span class="s5">&quot;.&quot; </span><span class="s4">+ </span><span class="s1">self</span><span class="s4">.</span><span class="s1">name</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">name</span>

    <span class="s3">def </span><span class="s1">_refresh_for_new_column</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">column</span><span class="s4">: </span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s3">pass</span>

    <span class="s3">def </span><span class="s1">_init_collections</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s3">pass</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">ro_memoized_property</span>
    <span class="s3">def </span><span class="s1">description</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; str</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">name</span>

    <span class="s3">def </span><span class="s1">append_column</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">c</span><span class="s4">: </span><span class="s1">ColumnClause</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s1">existing </span><span class="s4">= </span><span class="s1">c</span><span class="s4">.</span><span class="s1">table</span>
        <span class="s3">if </span><span class="s1">existing </span><span class="s3">is not None and </span><span class="s1">existing </span><span class="s3">is not </span><span class="s1">self</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">exc</span><span class="s4">.</span><span class="s1">ArgumentError</span><span class="s4">(</span>
                <span class="s5">&quot;column object '%s' already assigned to table '%s'&quot;</span>
                <span class="s4">% (</span><span class="s1">c</span><span class="s4">.</span><span class="s1">key</span><span class="s4">, </span><span class="s1">existing</span><span class="s4">)</span>
            <span class="s4">)</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">_columns</span><span class="s4">.</span><span class="s1">add</span><span class="s4">(</span><span class="s1">c</span><span class="s4">)</span>
        <span class="s1">c</span><span class="s4">.</span><span class="s1">table </span><span class="s4">= </span><span class="s1">self</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">preload_module</span><span class="s4">(</span><span class="s5">&quot;sqlalchemy.sql.dml&quot;</span><span class="s4">)</span>
    <span class="s3">def </span><span class="s1">insert</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; util</span><span class="s4">.</span><span class="s1">preloaded</span><span class="s4">.</span><span class="s1">sql_dml</span><span class="s4">.</span><span class="s1">Insert</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Generate an :class:`_sql.Insert` construct against this 
        :class:`_expression.TableClause`. 
 
        E.g.:: 
 
            table.insert().values(name='foo') 
 
        See :func:`_expression.insert` for argument and usage information. 
 
        &quot;&quot;&quot;</span>

        <span class="s3">return </span><span class="s1">util</span><span class="s4">.</span><span class="s1">preloaded</span><span class="s4">.</span><span class="s1">sql_dml</span><span class="s4">.</span><span class="s1">Insert</span><span class="s4">(</span><span class="s1">self</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">preload_module</span><span class="s4">(</span><span class="s5">&quot;sqlalchemy.sql.dml&quot;</span><span class="s4">)</span>
    <span class="s3">def </span><span class="s1">update</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Update</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Generate an :func:`_expression.update` construct against this 
        :class:`_expression.TableClause`. 
 
        E.g.:: 
 
            table.update().where(table.c.id==7).values(name='foo') 
 
        See :func:`_expression.update` for argument and usage information. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">util</span><span class="s4">.</span><span class="s1">preloaded</span><span class="s4">.</span><span class="s1">sql_dml</span><span class="s4">.</span><span class="s1">Update</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">,</span>
        <span class="s4">)</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">preload_module</span><span class="s4">(</span><span class="s5">&quot;sqlalchemy.sql.dml&quot;</span><span class="s4">)</span>
    <span class="s3">def </span><span class="s1">delete</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Delete</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Generate a :func:`_expression.delete` construct against this 
        :class:`_expression.TableClause`. 
 
        E.g.:: 
 
            table.delete().where(table.c.id==7) 
 
        See :func:`_expression.delete` for argument and usage information. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">util</span><span class="s4">.</span><span class="s1">preloaded</span><span class="s4">.</span><span class="s1">sql_dml</span><span class="s4">.</span><span class="s1">Delete</span><span class="s4">(</span><span class="s1">self</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">ro_non_memoized_property</span>
    <span class="s3">def </span><span class="s1">_from_objects</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; List</span><span class="s4">[</span><span class="s1">FromClause</span><span class="s4">]:</span>
        <span class="s3">return </span><span class="s4">[</span><span class="s1">self</span><span class="s4">]</span>


<span class="s1">ForUpdateParameter </span><span class="s4">= </span><span class="s1">Union</span><span class="s4">[</span><span class="s5">&quot;ForUpdateArg&quot;</span><span class="s4">, </span><span class="s3">None</span><span class="s4">, </span><span class="s1">bool</span><span class="s4">, </span><span class="s1">Dict</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">Any</span><span class="s4">]]</span>


<span class="s3">class </span><span class="s1">ForUpdateArg</span><span class="s4">(</span><span class="s1">ClauseElement</span><span class="s4">):</span>
    <span class="s1">_traverse_internals</span><span class="s4">: </span><span class="s1">_TraverseInternalsType </span><span class="s4">= [</span>
        <span class="s4">(</span><span class="s5">&quot;of&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_clauseelement_list</span><span class="s4">),</span>
        <span class="s4">(</span><span class="s5">&quot;nowait&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_boolean</span><span class="s4">),</span>
        <span class="s4">(</span><span class="s5">&quot;read&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_boolean</span><span class="s4">),</span>
        <span class="s4">(</span><span class="s5">&quot;skip_locked&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_boolean</span><span class="s4">),</span>
        <span class="s4">(</span><span class="s5">&quot;key_share&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_boolean</span><span class="s4">),</span>
    <span class="s4">]</span>

    <span class="s1">of</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Sequence</span><span class="s4">[</span><span class="s1">ClauseElement</span><span class="s4">]]</span>
    <span class="s1">nowait</span><span class="s4">: </span><span class="s1">bool</span>
    <span class="s1">read</span><span class="s4">: </span><span class="s1">bool</span>
    <span class="s1">skip_locked</span><span class="s4">: </span><span class="s1">bool</span>

    <span class="s4">@</span><span class="s1">classmethod</span>
    <span class="s3">def </span><span class="s1">_from_argument</span><span class="s4">(</span>
        <span class="s1">cls</span><span class="s4">, </span><span class="s1">with_for_update</span><span class="s4">: </span><span class="s1">ForUpdateParameter</span>
    <span class="s4">) </span><span class="s1">-&gt; Optional</span><span class="s4">[</span><span class="s1">ForUpdateArg</span><span class="s4">]:</span>
        <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">with_for_update</span><span class="s4">, </span><span class="s1">ForUpdateArg</span><span class="s4">):</span>
            <span class="s3">return </span><span class="s1">with_for_update</span>
        <span class="s3">elif </span><span class="s1">with_for_update </span><span class="s3">in </span><span class="s4">(</span><span class="s3">None</span><span class="s4">, </span><span class="s3">False</span><span class="s4">):</span>
            <span class="s3">return None</span>
        <span class="s3">elif </span><span class="s1">with_for_update </span><span class="s3">is True</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">ForUpdateArg</span><span class="s4">()</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">ForUpdateArg</span><span class="s4">(**</span><span class="s1">cast</span><span class="s4">(</span><span class="s5">&quot;Dict[str, Any]&quot;</span><span class="s4">, </span><span class="s1">with_for_update</span><span class="s4">))</span>

    <span class="s3">def </span><span class="s1">__eq__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s4">(</span>
            <span class="s1">isinstance</span><span class="s4">(</span><span class="s1">other</span><span class="s4">, </span><span class="s1">ForUpdateArg</span><span class="s4">)</span>
            <span class="s3">and </span><span class="s1">other</span><span class="s4">.</span><span class="s1">nowait </span><span class="s4">== </span><span class="s1">self</span><span class="s4">.</span><span class="s1">nowait</span>
            <span class="s3">and </span><span class="s1">other</span><span class="s4">.</span><span class="s1">read </span><span class="s4">== </span><span class="s1">self</span><span class="s4">.</span><span class="s1">read</span>
            <span class="s3">and </span><span class="s1">other</span><span class="s4">.</span><span class="s1">skip_locked </span><span class="s4">== </span><span class="s1">self</span><span class="s4">.</span><span class="s1">skip_locked</span>
            <span class="s3">and </span><span class="s1">other</span><span class="s4">.</span><span class="s1">key_share </span><span class="s4">== </span><span class="s1">self</span><span class="s4">.</span><span class="s1">key_share</span>
            <span class="s3">and </span><span class="s1">other</span><span class="s4">.</span><span class="s1">of </span><span class="s3">is </span><span class="s1">self</span><span class="s4">.</span><span class="s1">of</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">__ne__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
        <span class="s3">return not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">__eq__</span><span class="s4">(</span><span class="s1">other</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">__hash__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; int</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">id</span><span class="s4">(</span><span class="s1">self</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s4">*,</span>
        <span class="s1">nowait</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
        <span class="s1">read</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
        <span class="s1">of</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_ForUpdateOfArgument</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">skip_locked</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
        <span class="s1">key_share</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
    <span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Represents arguments specified to 
        :meth:`_expression.Select.for_update`. 
 
        &quot;&quot;&quot;</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">nowait </span><span class="s4">= </span><span class="s1">nowait</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">read </span><span class="s4">= </span><span class="s1">read</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">skip_locked </span><span class="s4">= </span><span class="s1">skip_locked</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">key_share </span><span class="s4">= </span><span class="s1">key_share</span>
        <span class="s3">if </span><span class="s1">of </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">of </span><span class="s4">= [</span>
                <span class="s1">coercions</span><span class="s4">.</span><span class="s1">expect</span><span class="s4">(</span><span class="s1">roles</span><span class="s4">.</span><span class="s1">ColumnsClauseRole</span><span class="s4">, </span><span class="s1">elem</span><span class="s4">)</span>
                <span class="s3">for </span><span class="s1">elem </span><span class="s3">in </span><span class="s1">util</span><span class="s4">.</span><span class="s1">to_list</span><span class="s4">(</span><span class="s1">of</span><span class="s4">)</span>
            <span class="s4">]</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">of </span><span class="s4">= </span><span class="s3">None</span>


<span class="s3">class </span><span class="s1">Values</span><span class="s4">(</span><span class="s1">roles</span><span class="s4">.</span><span class="s1">InElementRole</span><span class="s4">, </span><span class="s1">Generative</span><span class="s4">, </span><span class="s1">LateralFromClause</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Represent a ``VALUES`` construct that can be used as a FROM element 
    in a statement. 
 
    The :class:`_expression.Values` object is created from the 
    :func:`_expression.values` function. 
 
    .. versionadded:: 1.4 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;values&quot;</span>

    <span class="s1">_data</span><span class="s4">: </span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">Sequence</span><span class="s4">[</span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">, ...]], ...] = ()</span>

    <span class="s1">_unnamed</span><span class="s4">: </span><span class="s1">bool</span>
    <span class="s1">_traverse_internals</span><span class="s4">: </span><span class="s1">_TraverseInternalsType </span><span class="s4">= [</span>
        <span class="s4">(</span><span class="s5">&quot;_column_args&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_clauseelement_list</span><span class="s4">),</span>
        <span class="s4">(</span><span class="s5">&quot;_data&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_dml_multi_values</span><span class="s4">),</span>
        <span class="s4">(</span><span class="s5">&quot;name&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_string</span><span class="s4">),</span>
        <span class="s4">(</span><span class="s5">&quot;literal_binds&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_boolean</span><span class="s4">),</span>
    <span class="s4">]</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s4">*</span><span class="s1">columns</span><span class="s4">: </span><span class="s1">ColumnClause</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">],</span>
        <span class="s1">name</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">literal_binds</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
    <span class="s4">):</span>
        <span class="s1">super</span><span class="s4">().</span><span class="s1">__init__</span><span class="s4">()</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_column_args </span><span class="s4">= </span><span class="s1">columns</span>

        <span class="s3">if </span><span class="s1">name </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_unnamed </span><span class="s4">= </span><span class="s3">True</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">name </span><span class="s4">= </span><span class="s1">_anonymous_label</span><span class="s4">.</span><span class="s1">safe_construct</span><span class="s4">(</span><span class="s1">id</span><span class="s4">(</span><span class="s1">self</span><span class="s4">), </span><span class="s5">&quot;anon&quot;</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_unnamed </span><span class="s4">= </span><span class="s3">False</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">name </span><span class="s4">= </span><span class="s1">name</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">literal_binds </span><span class="s4">= </span><span class="s1">literal_binds</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">named_with_column </span><span class="s4">= </span><span class="s3">not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_unnamed</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">_column_types</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; List</span><span class="s4">[</span><span class="s1">TypeEngine</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]:</span>
        <span class="s3">return </span><span class="s4">[</span><span class="s1">col</span><span class="s4">.</span><span class="s1">type </span><span class="s3">for </span><span class="s1">col </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_column_args</span><span class="s4">]</span>

    <span class="s4">@</span><span class="s1">_generative</span>
    <span class="s3">def </span><span class="s1">alias</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">name</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">, </span><span class="s1">flat</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Return a new :class:`_expression.Values` 
        construct that is a copy of this 
        one with the given name. 
 
        This method is a VALUES-specific specialization of the 
        :meth:`_expression.FromClause.alias` method. 
 
        .. seealso:: 
 
            :ref:`tutorial_using_aliases` 
 
            :func:`_expression.alias` 
 
        &quot;&quot;&quot;</span>
        <span class="s1">non_none_name</span><span class="s4">: </span><span class="s1">str</span>

        <span class="s3">if </span><span class="s1">name </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s1">non_none_name </span><span class="s4">= </span><span class="s1">_anonymous_label</span><span class="s4">.</span><span class="s1">safe_construct</span><span class="s4">(</span><span class="s1">id</span><span class="s4">(</span><span class="s1">self</span><span class="s4">), </span><span class="s5">&quot;anon&quot;</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">non_none_name </span><span class="s4">= </span><span class="s1">name</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">name </span><span class="s4">= </span><span class="s1">non_none_name</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">named_with_column </span><span class="s4">= </span><span class="s3">True</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_unnamed </span><span class="s4">= </span><span class="s3">False</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s4">@</span><span class="s1">_generative</span>
    <span class="s3">def </span><span class="s1">lateral</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">name</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">) </span><span class="s1">-&gt; LateralFromClause</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Return a new :class:`_expression.Values` with the lateral flag set, 
        so that 
        it renders as LATERAL. 
 
        .. seealso:: 
 
            :func:`_expression.lateral` 
 
        &quot;&quot;&quot;</span>
        <span class="s1">non_none_name</span><span class="s4">: </span><span class="s1">str</span>

        <span class="s3">if </span><span class="s1">name </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s1">non_none_name </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">name</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">non_none_name </span><span class="s4">= </span><span class="s1">name</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">_is_lateral </span><span class="s4">= </span><span class="s3">True</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">name </span><span class="s4">= </span><span class="s1">non_none_name</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_unnamed </span><span class="s4">= </span><span class="s3">False</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s4">@</span><span class="s1">_generative</span>
    <span class="s3">def </span><span class="s1">data</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">values</span><span class="s4">: </span><span class="s1">Sequence</span><span class="s4">[</span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">, ...]]) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Return a new :class:`_expression.Values` construct, 
        adding the given data to the data list. 
 
        E.g.:: 
 
            my_values = my_values.data([(1, 'value 1'), (2, 'value2')]) 
 
        :param values: a sequence (i.e. list) of tuples that map to the 
         column expressions given in the :class:`_expression.Values` 
         constructor. 
 
        &quot;&quot;&quot;</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">_data </span><span class="s4">+= (</span><span class="s1">values</span><span class="s4">,)</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">scalar_values</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; ScalarValues</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Returns a scalar ``VALUES`` construct that can be used as a 
        COLUMN element in a statement. 
 
        .. versionadded:: 2.0.0b4 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">ScalarValues</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_column_args</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_data</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">literal_binds</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_populate_column_collection</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_column_args</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">c</span><span class="s4">.</span><span class="s1">table </span><span class="s3">is not None and </span><span class="s1">c</span><span class="s4">.</span><span class="s1">table </span><span class="s3">is not </span><span class="s1">self</span><span class="s4">:</span>
                <span class="s1">_</span><span class="s4">, </span><span class="s1">c </span><span class="s4">= </span><span class="s1">c</span><span class="s4">.</span><span class="s1">_make_proxy</span><span class="s4">(</span><span class="s1">self</span><span class="s4">)</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s0"># if the column was used in other contexts, ensure</span>
                <span class="s0"># no memoizations of other FROM clauses.</span>
                <span class="s0"># see test_values.py -&gt; test_auto_proxy_select_direct_col</span>
                <span class="s1">c</span><span class="s4">.</span><span class="s1">_reset_memoizations</span><span class="s4">()</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_columns</span><span class="s4">.</span><span class="s1">add</span><span class="s4">(</span><span class="s1">c</span><span class="s4">)</span>
            <span class="s1">c</span><span class="s4">.</span><span class="s1">table </span><span class="s4">= </span><span class="s1">self</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">ro_non_memoized_property</span>
    <span class="s3">def </span><span class="s1">_from_objects</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; List</span><span class="s4">[</span><span class="s1">FromClause</span><span class="s4">]:</span>
        <span class="s3">return </span><span class="s4">[</span><span class="s1">self</span><span class="s4">]</span>


<span class="s3">class </span><span class="s1">ScalarValues</span><span class="s4">(</span><span class="s1">roles</span><span class="s4">.</span><span class="s1">InElementRole</span><span class="s4">, </span><span class="s1">GroupedElement</span><span class="s4">, </span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]):</span>
    <span class="s2">&quot;&quot;&quot;Represent a scalar ``VALUES`` construct that can be used as a 
    COLUMN element in a statement. 
 
    The :class:`_expression.ScalarValues` object is created from the 
    :meth:`_expression.Values.scalar_values` method. It's also 
    automatically generated when a :class:`_expression.Values` is used in 
    an ``IN`` or ``NOT IN`` condition. 
 
    .. versionadded:: 2.0.0b4 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;scalar_values&quot;</span>

    <span class="s1">_traverse_internals</span><span class="s4">: </span><span class="s1">_TraverseInternalsType </span><span class="s4">= [</span>
        <span class="s4">(</span><span class="s5">&quot;_column_args&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_clauseelement_list</span><span class="s4">),</span>
        <span class="s4">(</span><span class="s5">&quot;_data&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_dml_multi_values</span><span class="s4">),</span>
        <span class="s4">(</span><span class="s5">&quot;literal_binds&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_boolean</span><span class="s4">),</span>
    <span class="s4">]</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">columns</span><span class="s4">: </span><span class="s1">Sequence</span><span class="s4">[</span><span class="s1">ColumnClause</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]],</span>
        <span class="s1">data</span><span class="s4">: </span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">Sequence</span><span class="s4">[</span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">, ...]], ...],</span>
        <span class="s1">literal_binds</span><span class="s4">: </span><span class="s1">bool</span><span class="s4">,</span>
    <span class="s4">):</span>
        <span class="s1">super</span><span class="s4">().</span><span class="s1">__init__</span><span class="s4">()</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_column_args </span><span class="s4">= </span><span class="s1">columns</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_data </span><span class="s4">= </span><span class="s1">data</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">literal_binds </span><span class="s4">= </span><span class="s1">literal_binds</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">_column_types</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; List</span><span class="s4">[</span><span class="s1">TypeEngine</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]:</span>
        <span class="s3">return </span><span class="s4">[</span><span class="s1">col</span><span class="s4">.</span><span class="s1">type </span><span class="s3">for </span><span class="s1">col </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_column_args</span><span class="s4">]</span>

    <span class="s3">def </span><span class="s1">__clause_element__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; ScalarValues</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">if </span><span class="s1">TYPE_CHECKING</span><span class="s4">:</span>

        <span class="s3">def </span><span class="s1">self_group</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">, </span><span class="s1">against</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">OperatorType</span><span class="s4">] = </span><span class="s3">None</span>
        <span class="s4">) </span><span class="s1">-&gt; Self</span><span class="s4">: ...</span>


<span class="s3">class </span><span class="s1">SelectBase</span><span class="s4">(</span>
    <span class="s1">roles</span><span class="s4">.</span><span class="s1">SelectStatementRole</span><span class="s4">,</span>
    <span class="s1">roles</span><span class="s4">.</span><span class="s1">DMLSelectRole</span><span class="s4">,</span>
    <span class="s1">roles</span><span class="s4">.</span><span class="s1">CompoundElementRole</span><span class="s4">,</span>
    <span class="s1">roles</span><span class="s4">.</span><span class="s1">InElementRole</span><span class="s4">,</span>
    <span class="s1">HasCTE</span><span class="s4">,</span>
    <span class="s1">SupportsCloneAnnotations</span><span class="s4">,</span>
    <span class="s1">Selectable</span><span class="s4">,</span>
<span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Base class for SELECT statements. 
 
 
    This includes :class:`_expression.Select`, 
    :class:`_expression.CompoundSelect` and 
    :class:`_expression.TextualSelect`. 
 
 
    &quot;&quot;&quot;</span>

    <span class="s1">_is_select_base </span><span class="s4">= </span><span class="s3">True</span>
    <span class="s1">is_select </span><span class="s4">= </span><span class="s3">True</span>

    <span class="s1">_label_style</span><span class="s4">: </span><span class="s1">SelectLabelStyle </span><span class="s4">= </span><span class="s1">LABEL_STYLE_NONE</span>

    <span class="s3">def </span><span class="s1">_refresh_for_new_column</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">column</span><span class="s4">: </span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_reset_memoizations</span><span class="s4">()</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">ro_non_memoized_property</span>
    <span class="s3">def </span><span class="s1">selected_columns</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; ColumnCollection</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]:</span>
        <span class="s2">&quot;&quot;&quot;A :class:`_expression.ColumnCollection` 
        representing the columns that 
        this SELECT statement or similar construct returns in its result set. 
 
        This collection differs from the :attr:`_expression.FromClause.columns` 
        collection of a :class:`_expression.FromClause` in that the columns 
        within this collection cannot be directly nested inside another SELECT 
        statement; a subquery must be applied first which provides for the 
        necessary parenthesization required by SQL. 
 
        .. note:: 
 
            The :attr:`_sql.SelectBase.selected_columns` collection does not 
            include expressions established in the columns clause using the 
            :func:`_sql.text` construct; these are silently omitted from the 
            collection. To use plain textual column expressions inside of a 
            :class:`_sql.Select` construct, use the :func:`_sql.literal_column` 
            construct. 
 
        .. seealso:: 
 
            :attr:`_sql.Select.selected_columns` 
 
        .. versionadded:: 1.4 
 
        &quot;&quot;&quot;</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">_generate_fromclause_column_proxies</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">subquery</span><span class="s4">: </span><span class="s1">FromClause</span><span class="s4">,</span>
        <span class="s4">*,</span>
        <span class="s1">proxy_compound_columns</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span>
            <span class="s1">Iterable</span><span class="s4">[</span><span class="s1">Sequence</span><span class="s4">[</span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]]</span>
        <span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">ro_non_memoized_property</span>
    <span class="s3">def </span><span class="s1">_all_selected_columns</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; _SelectIterable</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;A sequence of expressions that correspond to what is rendered 
        in the columns clause, including :class:`_sql.TextClause` 
        constructs. 
 
        .. versionadded:: 1.4.12 
 
        .. seealso:: 
 
            :attr:`_sql.SelectBase.exported_columns` 
 
        &quot;&quot;&quot;</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">exported_columns</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; ReadOnlyColumnCollection</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]:</span>
        <span class="s2">&quot;&quot;&quot;A :class:`_expression.ColumnCollection` 
        that represents the &quot;exported&quot; 
        columns of this :class:`_expression.Selectable`, not including 
        :class:`_sql.TextClause` constructs. 
 
        The &quot;exported&quot; columns for a :class:`_expression.SelectBase` 
        object are synonymous 
        with the :attr:`_expression.SelectBase.selected_columns` collection. 
 
        .. versionadded:: 1.4 
 
        .. seealso:: 
 
            :attr:`_expression.Select.exported_columns` 
 
            :attr:`_expression.Selectable.exported_columns` 
 
            :attr:`_expression.FromClause.exported_columns` 
 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">selected_columns</span><span class="s4">.</span><span class="s1">as_readonly</span><span class="s4">()</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">deprecated</span><span class="s4">(</span>
        <span class="s5">&quot;1.4&quot;</span><span class="s4">,</span>
        <span class="s5">&quot;The :attr:`_expression.SelectBase.c` and &quot;</span>
        <span class="s5">&quot;:attr:`_expression.SelectBase.columns` attributes &quot;</span>
        <span class="s5">&quot;are deprecated and will be removed in a future release; these &quot;</span>
        <span class="s5">&quot;attributes implicitly create a subquery that should be explicit.  &quot;</span>
        <span class="s5">&quot;Please call :meth:`_expression.SelectBase.subquery` &quot;</span>
        <span class="s5">&quot;first in order to create &quot;</span>
        <span class="s5">&quot;a subquery, which then contains this attribute.  To access the &quot;</span>
        <span class="s5">&quot;columns that this SELECT object SELECTs &quot;</span>
        <span class="s5">&quot;from, use the :attr:`_expression.SelectBase.selected_columns` &quot;</span>
        <span class="s5">&quot;attribute.&quot;</span><span class="s4">,</span>
    <span class="s4">)</span>
    <span class="s3">def </span><span class="s1">c</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; ReadOnlyColumnCollection</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">KeyedColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]:</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_implicit_subquery</span><span class="s4">.</span><span class="s1">columns</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">columns</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; ReadOnlyColumnCollection</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">KeyedColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]:</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">c</span>

    <span class="s3">def </span><span class="s1">get_label_style</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; SelectLabelStyle</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot; 
        Retrieve the current label style. 
 
        Implemented by subclasses. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">set_label_style</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">style</span><span class="s4">: </span><span class="s1">SelectLabelStyle</span><span class="s4">) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Return a new selectable with the specified label style. 
 
        Implemented by subclasses. 
 
        &quot;&quot;&quot;</span>

        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">deprecated</span><span class="s4">(</span>
        <span class="s5">&quot;1.4&quot;</span><span class="s4">,</span>
        <span class="s5">&quot;The :meth:`_expression.SelectBase.select` method is deprecated &quot;</span>
        <span class="s5">&quot;and will be removed in a future release; this method implicitly &quot;</span>
        <span class="s5">&quot;creates a subquery that should be explicit.  &quot;</span>
        <span class="s5">&quot;Please call :meth:`_expression.SelectBase.subquery` &quot;</span>
        <span class="s5">&quot;first in order to create &quot;</span>
        <span class="s5">&quot;a subquery, which then can be selected.&quot;</span><span class="s4">,</span>
    <span class="s4">)</span>
    <span class="s3">def </span><span class="s1">select</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, *</span><span class="s1">arg</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; Select</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]:</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_implicit_subquery</span><span class="s4">.</span><span class="s1">select</span><span class="s4">(*</span><span class="s1">arg</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">HasMemoized</span><span class="s4">.</span><span class="s1">memoized_attribute</span>
    <span class="s3">def </span><span class="s1">_implicit_subquery</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Subquery</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">subquery</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">_scalar_type</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; TypeEngine</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]:</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">deprecated</span><span class="s4">(</span>
        <span class="s5">&quot;1.4&quot;</span><span class="s4">,</span>
        <span class="s5">&quot;The :meth:`_expression.SelectBase.as_scalar` &quot;</span>
        <span class="s5">&quot;method is deprecated and will be &quot;</span>
        <span class="s5">&quot;removed in a future release.  Please refer to &quot;</span>
        <span class="s5">&quot;:meth:`_expression.SelectBase.scalar_subquery`.&quot;</span><span class="s4">,</span>
    <span class="s4">)</span>
    <span class="s3">def </span><span class="s1">as_scalar</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; ScalarSelect</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]:</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">scalar_subquery</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">exists</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Exists</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Return an :class:`_sql.Exists` representation of this selectable, 
        which can be used as a column expression. 
 
        The returned object is an instance of :class:`_sql.Exists`. 
 
        .. seealso:: 
 
            :func:`_sql.exists` 
 
            :ref:`tutorial_exists` - in the :term:`2.0 style` tutorial. 
 
        .. versionadded:: 1.4 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">Exists</span><span class="s4">(</span><span class="s1">self</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">scalar_subquery</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; ScalarSelect</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;Return a 'scalar' representation of this selectable, which can be 
        used as a column expression. 
 
        The returned object is an instance of :class:`_sql.ScalarSelect`. 
 
        Typically, a select statement which has only one column in its columns 
        clause is eligible to be used as a scalar expression.  The scalar 
        subquery can then be used in the WHERE clause or columns clause of 
        an enclosing SELECT. 
 
        Note that the scalar subquery differentiates from the FROM-level 
        subquery that can be produced using the 
        :meth:`_expression.SelectBase.subquery` 
        method. 
 
        .. versionchanged: 1.4 - the ``.as_scalar()`` method was renamed to 
           :meth:`_expression.SelectBase.scalar_subquery`. 
 
        .. seealso:: 
 
            :ref:`tutorial_scalar_subquery` - in the 2.0 tutorial 
 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_label_style </span><span class="s3">is not </span><span class="s1">LABEL_STYLE_NONE</span><span class="s4">:</span>
            <span class="s1">self </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">set_label_style</span><span class="s4">(</span><span class="s1">LABEL_STYLE_NONE</span><span class="s4">)</span>

        <span class="s3">return </span><span class="s1">ScalarSelect</span><span class="s4">(</span><span class="s1">self</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">label</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">name</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]) </span><span class="s1">-&gt; Label</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;Return a 'scalar' representation of this selectable, embedded as a 
        subquery with a label. 
 
        .. seealso:: 
 
            :meth:`_expression.SelectBase.scalar_subquery`. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">scalar_subquery</span><span class="s4">().</span><span class="s1">label</span><span class="s4">(</span><span class="s1">name</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">lateral</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">name</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">) </span><span class="s1">-&gt; LateralFromClause</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Return a LATERAL alias of this :class:`_expression.Selectable`. 
 
        The return value is the :class:`_expression.Lateral` construct also 
        provided by the top-level :func:`_expression.lateral` function. 
 
        .. seealso:: 
 
            :ref:`tutorial_lateral_correlation` -  overview of usage. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">Lateral</span><span class="s4">.</span><span class="s1">_factory</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">name</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">subquery</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">name</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">) </span><span class="s1">-&gt; Subquery</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Return a subquery of this :class:`_expression.SelectBase`. 
 
        A subquery is from a SQL perspective a parenthesized, named 
        construct that can be placed in the FROM clause of another 
        SELECT statement. 
 
        Given a SELECT statement such as:: 
 
            stmt = select(table.c.id, table.c.name) 
 
        The above statement might look like:: 
 
            SELECT table.id, table.name FROM table 
 
        The subquery form by itself renders the same way, however when 
        embedded into the FROM clause of another SELECT statement, it becomes 
        a named sub-element:: 
 
            subq = stmt.subquery() 
            new_stmt = select(subq) 
 
        The above renders as:: 
 
            SELECT anon_1.id, anon_1.name 
            FROM (SELECT table.id, table.name FROM table) AS anon_1 
 
        Historically, :meth:`_expression.SelectBase.subquery` 
        is equivalent to calling 
        the :meth:`_expression.FromClause.alias` 
        method on a FROM object; however, 
        as a :class:`_expression.SelectBase` 
        object is not directly  FROM object, 
        the :meth:`_expression.SelectBase.subquery` 
        method provides clearer semantics. 
 
        .. versionadded:: 1.4 
 
        &quot;&quot;&quot;</span>

        <span class="s3">return </span><span class="s1">Subquery</span><span class="s4">.</span><span class="s1">_construct</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_ensure_disambiguated_names</span><span class="s4">(), </span><span class="s1">name</span><span class="s4">=</span><span class="s1">name</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_ensure_disambiguated_names</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Ensure that the names generated by this selectbase will be 
        disambiguated in some way, if possible. 
 
        &quot;&quot;&quot;</span>

        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">alias</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">name</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">, </span><span class="s1">flat</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span>
    <span class="s4">) </span><span class="s1">-&gt; Subquery</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Return a named subquery against this 
        :class:`_expression.SelectBase`. 
 
        For a :class:`_expression.SelectBase` (as opposed to a 
        :class:`_expression.FromClause`), 
        this returns a :class:`.Subquery` object which behaves mostly the 
        same as the :class:`_expression.Alias` object that is used with a 
        :class:`_expression.FromClause`. 
 
        .. versionchanged:: 1.4 The :meth:`_expression.SelectBase.alias` 
           method is now 
           a synonym for the :meth:`_expression.SelectBase.subquery` method. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">subquery</span><span class="s4">(</span><span class="s1">name</span><span class="s4">=</span><span class="s1">name</span><span class="s4">)</span>


<span class="s1">_SB </span><span class="s4">= </span><span class="s1">TypeVar</span><span class="s4">(</span><span class="s5">&quot;_SB&quot;</span><span class="s4">, </span><span class="s1">bound</span><span class="s4">=</span><span class="s1">SelectBase</span><span class="s4">)</span>


<span class="s3">class </span><span class="s1">SelectStatementGrouping</span><span class="s4">(</span><span class="s1">GroupedElement</span><span class="s4">, </span><span class="s1">SelectBase</span><span class="s4">, </span><span class="s1">Generic</span><span class="s4">[</span><span class="s1">_SB</span><span class="s4">]):</span>
    <span class="s2">&quot;&quot;&quot;Represent a grouping of a :class:`_expression.SelectBase`. 
 
    This differs from :class:`.Subquery` in that we are still 
    an &quot;inner&quot; SELECT statement, this is strictly for grouping inside of 
    compound selects. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;select_statement_grouping&quot;</span>
    <span class="s1">_traverse_internals</span><span class="s4">: </span><span class="s1">_TraverseInternalsType </span><span class="s4">= [</span>
        <span class="s4">(</span><span class="s5">&quot;element&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_clauseelement</span><span class="s4">)</span>
    <span class="s4">] + </span><span class="s1">SupportsCloneAnnotations</span><span class="s4">.</span><span class="s1">_clone_annotations_traverse_internals</span>

    <span class="s1">_is_select_container </span><span class="s4">= </span><span class="s3">True</span>

    <span class="s1">element</span><span class="s4">: </span><span class="s1">_SB</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">element</span><span class="s4">: </span><span class="s1">_SB</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">element </span><span class="s4">= </span><span class="s1">cast</span><span class="s4">(</span>
            <span class="s1">_SB</span><span class="s4">, </span><span class="s1">coercions</span><span class="s4">.</span><span class="s1">expect</span><span class="s4">(</span><span class="s1">roles</span><span class="s4">.</span><span class="s1">SelectStatementRole</span><span class="s4">, </span><span class="s1">element</span><span class="s4">)</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_ensure_disambiguated_names</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; SelectStatementGrouping</span><span class="s4">[</span><span class="s1">_SB</span><span class="s4">]:</span>
        <span class="s1">new_element </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">element</span><span class="s4">.</span><span class="s1">_ensure_disambiguated_names</span><span class="s4">()</span>
        <span class="s3">if </span><span class="s1">new_element </span><span class="s3">is not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">element</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">SelectStatementGrouping</span><span class="s4">(</span><span class="s1">new_element</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">get_label_style</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; SelectLabelStyle</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">element</span><span class="s4">.</span><span class="s1">get_label_style</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">set_label_style</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">label_style</span><span class="s4">: </span><span class="s1">SelectLabelStyle</span>
    <span class="s4">) </span><span class="s1">-&gt; SelectStatementGrouping</span><span class="s4">[</span><span class="s1">_SB</span><span class="s4">]:</span>
        <span class="s3">return </span><span class="s1">SelectStatementGrouping</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">element</span><span class="s4">.</span><span class="s1">set_label_style</span><span class="s4">(</span><span class="s1">label_style</span><span class="s4">)</span>
        <span class="s4">)</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">select_statement</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; _SB</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">element</span>

    <span class="s3">def </span><span class="s1">self_group</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">against</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">OperatorType</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">if </span><span class="s1">TYPE_CHECKING</span><span class="s4">:</span>

        <span class="s3">def </span><span class="s1">_ungroup</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; _SB</span><span class="s4">: ...</span>

    <span class="s0"># def _generate_columns_plus_names(</span>
    <span class="s0">#    self, anon_for_dupe_key: bool</span>
    <span class="s0"># ) -&gt; List[Tuple[str, str, str, ColumnElement[Any], bool]]:</span>
    <span class="s0">#    return self.element._generate_columns_plus_names(anon_for_dupe_key)</span>

    <span class="s3">def </span><span class="s1">_generate_fromclause_column_proxies</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">subquery</span><span class="s4">: </span><span class="s1">FromClause</span><span class="s4">,</span>
        <span class="s4">*,</span>
        <span class="s1">proxy_compound_columns</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span>
            <span class="s1">Iterable</span><span class="s4">[</span><span class="s1">Sequence</span><span class="s4">[</span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]]</span>
        <span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">element</span><span class="s4">.</span><span class="s1">_generate_fromclause_column_proxies</span><span class="s4">(</span>
            <span class="s1">subquery</span><span class="s4">, </span><span class="s1">proxy_compound_columns</span><span class="s4">=</span><span class="s1">proxy_compound_columns</span>
        <span class="s4">)</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">ro_non_memoized_property</span>
    <span class="s3">def </span><span class="s1">_all_selected_columns</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; _SelectIterable</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">element</span><span class="s4">.</span><span class="s1">_all_selected_columns</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">ro_non_memoized_property</span>
    <span class="s3">def </span><span class="s1">selected_columns</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; ColumnCollection</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]:</span>
        <span class="s2">&quot;&quot;&quot;A :class:`_expression.ColumnCollection` 
        representing the columns that 
        the embedded SELECT statement returns in its result set, not including 
        :class:`_sql.TextClause` constructs. 
 
        .. versionadded:: 1.4 
 
        .. seealso:: 
 
            :attr:`_sql.Select.selected_columns` 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">element</span><span class="s4">.</span><span class="s1">selected_columns</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">ro_non_memoized_property</span>
    <span class="s3">def </span><span class="s1">_from_objects</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; List</span><span class="s4">[</span><span class="s1">FromClause</span><span class="s4">]:</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">element</span><span class="s4">.</span><span class="s1">_from_objects</span>

    <span class="s3">def </span><span class="s1">add_cte</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, *</span><span class="s1">ctes</span><span class="s4">: </span><span class="s1">CTE</span><span class="s4">, </span><span class="s1">nest_here</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s0"># SelectStatementGrouping not generative: has no attribute '_generate'</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError</span>


<span class="s3">class </span><span class="s1">GenerativeSelect</span><span class="s4">(</span><span class="s1">SelectBase</span><span class="s4">, </span><span class="s1">Generative</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Base class for SELECT statements where additional elements can be 
    added. 
 
    This serves as the base for :class:`_expression.Select` and 
    :class:`_expression.CompoundSelect` 
    where elements such as ORDER BY, GROUP BY can be added and column 
    rendering can be controlled.  Compare to 
    :class:`_expression.TextualSelect`, which, 
    while it subclasses :class:`_expression.SelectBase` 
    and is also a SELECT construct, 
    represents a fixed textual string which cannot be altered at this level, 
    only wrapped as a subquery. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">_order_by_clauses</span><span class="s4">: </span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">], ...] = ()</span>
    <span class="s1">_group_by_clauses</span><span class="s4">: </span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">], ...] = ()</span>
    <span class="s1">_limit_clause</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]] = </span><span class="s3">None</span>
    <span class="s1">_offset_clause</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]] = </span><span class="s3">None</span>
    <span class="s1">_fetch_clause</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]] = </span><span class="s3">None</span>
    <span class="s1">_fetch_clause_options</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Dict</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">bool</span><span class="s4">]] = </span><span class="s3">None</span>
    <span class="s1">_for_update_arg</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">ForUpdateArg</span><span class="s4">] = </span><span class="s3">None</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">_label_style</span><span class="s4">: </span><span class="s1">SelectLabelStyle </span><span class="s4">= </span><span class="s1">LABEL_STYLE_DEFAULT</span><span class="s4">):</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_label_style </span><span class="s4">= </span><span class="s1">_label_style</span>

    <span class="s4">@</span><span class="s1">_generative</span>
    <span class="s3">def </span><span class="s1">with_for_update</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s4">*,</span>
        <span class="s1">nowait</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
        <span class="s1">read</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
        <span class="s1">of</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_ForUpdateOfArgument</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">skip_locked</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
        <span class="s1">key_share</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Specify a ``FOR UPDATE`` clause for this 
        :class:`_expression.GenerativeSelect`. 
 
        E.g.:: 
 
            stmt = select(table).with_for_update(nowait=True) 
 
        On a database like PostgreSQL or Oracle, the above would render a 
        statement like:: 
 
            SELECT table.a, table.b FROM table FOR UPDATE NOWAIT 
 
        on other backends, the ``nowait`` option is ignored and instead 
        would produce:: 
 
            SELECT table.a, table.b FROM table FOR UPDATE 
 
        When called with no arguments, the statement will render with 
        the suffix ``FOR UPDATE``.   Additional arguments can then be 
        provided which allow for common database-specific 
        variants. 
 
        :param nowait: boolean; will render ``FOR UPDATE NOWAIT`` on Oracle 
         and PostgreSQL dialects. 
 
        :param read: boolean; will render ``LOCK IN SHARE MODE`` on MySQL, 
         ``FOR SHARE`` on PostgreSQL.  On PostgreSQL, when combined with 
         ``nowait``, will render ``FOR SHARE NOWAIT``. 
 
        :param of: SQL expression or list of SQL expression elements, 
         (typically :class:`_schema.Column` objects or a compatible expression, 
         for some backends may also be a table expression) which will render 
         into a ``FOR UPDATE OF`` clause; supported by PostgreSQL, Oracle, some 
         MySQL versions and possibly others. May render as a table or as a 
         column depending on backend. 
 
        :param skip_locked: boolean, will render ``FOR UPDATE SKIP LOCKED`` 
         on Oracle and PostgreSQL dialects or ``FOR SHARE SKIP LOCKED`` if 
         ``read=True`` is also specified. 
 
        :param key_share: boolean, will render ``FOR NO KEY UPDATE``, 
         or if combined with ``read=True`` will render ``FOR KEY SHARE``, 
         on the PostgreSQL dialect. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_for_update_arg </span><span class="s4">= </span><span class="s1">ForUpdateArg</span><span class="s4">(</span>
            <span class="s1">nowait</span><span class="s4">=</span><span class="s1">nowait</span><span class="s4">,</span>
            <span class="s1">read</span><span class="s4">=</span><span class="s1">read</span><span class="s4">,</span>
            <span class="s1">of</span><span class="s4">=</span><span class="s1">of</span><span class="s4">,</span>
            <span class="s1">skip_locked</span><span class="s4">=</span><span class="s1">skip_locked</span><span class="s4">,</span>
            <span class="s1">key_share</span><span class="s4">=</span><span class="s1">key_share</span><span class="s4">,</span>
        <span class="s4">)</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">get_label_style</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; SelectLabelStyle</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot; 
        Retrieve the current label style. 
 
        .. versionadded:: 1.4 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_label_style</span>

    <span class="s3">def </span><span class="s1">set_label_style</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">style</span><span class="s4">: </span><span class="s1">SelectLabelStyle</span><span class="s4">) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Return a new selectable with the specified label style. 
 
        There are three &quot;label styles&quot; available, 
        :attr:`_sql.SelectLabelStyle.LABEL_STYLE_DISAMBIGUATE_ONLY`, 
        :attr:`_sql.SelectLabelStyle.LABEL_STYLE_TABLENAME_PLUS_COL`, and 
        :attr:`_sql.SelectLabelStyle.LABEL_STYLE_NONE`.   The default style is 
        :attr:`_sql.SelectLabelStyle.LABEL_STYLE_DISAMBIGUATE_ONLY`. 
 
        In modern SQLAlchemy, there is not generally a need to change the 
        labeling style, as per-expression labels are more effectively used by 
        making use of the :meth:`_sql.ColumnElement.label` method. In past 
        versions, :data:`_sql.LABEL_STYLE_TABLENAME_PLUS_COL` was used to 
        disambiguate same-named columns from different tables, aliases, or 
        subqueries; the newer :data:`_sql.LABEL_STYLE_DISAMBIGUATE_ONLY` now 
        applies labels only to names that conflict with an existing name so 
        that the impact of this labeling is minimal. 
 
        The rationale for disambiguation is mostly so that all column 
        expressions are available from a given :attr:`_sql.FromClause.c` 
        collection when a subquery is created. 
 
        .. versionadded:: 1.4 - the 
            :meth:`_sql.GenerativeSelect.set_label_style` method replaces the 
            previous combination of ``.apply_labels()``, ``.with_labels()`` and 
            ``use_labels=True`` methods and/or parameters. 
 
        .. seealso:: 
 
            :data:`_sql.LABEL_STYLE_DISAMBIGUATE_ONLY` 
 
            :data:`_sql.LABEL_STYLE_TABLENAME_PLUS_COL` 
 
            :data:`_sql.LABEL_STYLE_NONE` 
 
            :data:`_sql.LABEL_STYLE_DEFAULT` 
 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_label_style </span><span class="s3">is not </span><span class="s1">style</span><span class="s4">:</span>
            <span class="s1">self </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_generate</span><span class="s4">()</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_label_style </span><span class="s4">= </span><span class="s1">style</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">_group_by_clause</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; ClauseList</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;ClauseList access to group_by_clauses for legacy dialects&quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">ClauseList</span><span class="s4">.</span><span class="s1">_construct_raw</span><span class="s4">(</span>
            <span class="s1">operators</span><span class="s4">.</span><span class="s1">comma_op</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_group_by_clauses</span>
        <span class="s4">)</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">_order_by_clause</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; ClauseList</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;ClauseList access to order_by_clauses for legacy dialects&quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">ClauseList</span><span class="s4">.</span><span class="s1">_construct_raw</span><span class="s4">(</span>
            <span class="s1">operators</span><span class="s4">.</span><span class="s1">comma_op</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_order_by_clauses</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_offset_or_limit_clause</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">element</span><span class="s4">: </span><span class="s1">_LimitOffsetType</span><span class="s4">,</span>
        <span class="s1">name</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">type_</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_TypeEngineArgument</span><span class="s4">[</span><span class="s1">int</span><span class="s4">]] = </span><span class="s3">None</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;Convert the given value to an &quot;offset or limit&quot; clause. 
 
        This handles incoming integers and converts to an expression; if 
        an expression is already given, it is passed through. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">coercions</span><span class="s4">.</span><span class="s1">expect</span><span class="s4">(</span>
            <span class="s1">roles</span><span class="s4">.</span><span class="s1">LimitOffsetRole</span><span class="s4">, </span><span class="s1">element</span><span class="s4">, </span><span class="s1">name</span><span class="s4">=</span><span class="s1">name</span><span class="s4">, </span><span class="s1">type_</span><span class="s4">=</span><span class="s1">type_</span>
        <span class="s4">)</span>

    <span class="s4">@</span><span class="s1">overload</span>
    <span class="s3">def </span><span class="s1">_offset_or_limit_clause_asint</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">clause</span><span class="s4">: </span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">], </span><span class="s1">attrname</span><span class="s4">: </span><span class="s1">str</span>
    <span class="s4">) </span><span class="s1">-&gt; NoReturn</span><span class="s4">: ...</span>

    <span class="s4">@</span><span class="s1">overload</span>
    <span class="s3">def </span><span class="s1">_offset_or_limit_clause_asint</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">clause</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_OffsetLimitParam</span><span class="s4">], </span><span class="s1">attrname</span><span class="s4">: </span><span class="s1">str</span>
    <span class="s4">) </span><span class="s1">-&gt; Optional</span><span class="s4">[</span><span class="s1">int</span><span class="s4">]: ...</span>

    <span class="s3">def </span><span class="s1">_offset_or_limit_clause_asint</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">clause</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]], </span><span class="s1">attrname</span><span class="s4">: </span><span class="s1">str</span>
    <span class="s4">) </span><span class="s1">-&gt; Union</span><span class="s4">[</span><span class="s1">NoReturn</span><span class="s4">, </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">int</span><span class="s4">]]:</span>
        <span class="s2">&quot;&quot;&quot;Convert the &quot;offset or limit&quot; clause of a select construct to an 
        integer. 
 
        This is only possible if the value is stored as a simple bound 
        parameter. Otherwise, a compilation error is raised. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">clause </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s3">return None</span>
        <span class="s3">try</span><span class="s4">:</span>
            <span class="s1">value </span><span class="s4">= </span><span class="s1">clause</span><span class="s4">.</span><span class="s1">_limit_offset_value</span>
        <span class="s3">except </span><span class="s1">AttributeError </span><span class="s3">as </span><span class="s1">err</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">exc</span><span class="s4">.</span><span class="s1">CompileError</span><span class="s4">(</span>
                <span class="s5">&quot;This SELECT structure does not use a simple &quot;</span>
                <span class="s5">&quot;integer value for %s&quot; </span><span class="s4">% </span><span class="s1">attrname</span>
            <span class="s4">) </span><span class="s3">from </span><span class="s1">err</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">util</span><span class="s4">.</span><span class="s1">asint</span><span class="s4">(</span><span class="s1">value</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">_limit</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Optional</span><span class="s4">[</span><span class="s1">int</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;Get an integer value for the limit.  This should only be used 
        by code that cannot support a limit as a BindParameter or 
        other custom clause as it will throw an exception if the limit 
        isn't currently set to an integer. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_offset_or_limit_clause_asint</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_limit_clause</span><span class="s4">, </span><span class="s5">&quot;limit&quot;</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_simple_int_clause</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">clause</span><span class="s4">: </span><span class="s1">ClauseElement</span><span class="s4">) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;True if the clause is a simple integer, False 
        if it is not present or is a SQL expression. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">clause</span><span class="s4">, </span><span class="s1">_OffsetLimitParam</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">_offset</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Optional</span><span class="s4">[</span><span class="s1">int</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;Get an integer value for the offset.  This should only be used 
        by code that cannot support an offset as a BindParameter or 
        other custom clause as it will throw an exception if the 
        offset isn't currently set to an integer. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_offset_or_limit_clause_asint</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_offset_clause</span><span class="s4">, </span><span class="s5">&quot;offset&quot;</span>
        <span class="s4">)</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">_has_row_limiting_clause</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_limit_clause </span><span class="s3">is not None</span>
            <span class="s3">or </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_offset_clause </span><span class="s3">is not None</span>
            <span class="s3">or </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_fetch_clause </span><span class="s3">is not None</span>
        <span class="s4">)</span>

    <span class="s4">@</span><span class="s1">_generative</span>
    <span class="s3">def </span><span class="s1">limit</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">limit</span><span class="s4">: </span><span class="s1">_LimitOffsetType</span><span class="s4">) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Return a new selectable with the given LIMIT criterion 
        applied. 
 
        This is a numerical value which usually renders as a ``LIMIT`` 
        expression in the resulting select.  Backends that don't 
        support ``LIMIT`` will attempt to provide similar 
        functionality. 
 
        .. note:: 
 
           The :meth:`_sql.GenerativeSelect.limit` method will replace 
           any clause applied with :meth:`_sql.GenerativeSelect.fetch`. 
 
        :param limit: an integer LIMIT parameter, or a SQL expression 
         that provides an integer result. Pass ``None`` to reset it. 
 
        .. seealso:: 
 
           :meth:`_sql.GenerativeSelect.fetch` 
 
           :meth:`_sql.GenerativeSelect.offset` 
 
        &quot;&quot;&quot;</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">_fetch_clause </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_fetch_clause_options </span><span class="s4">= </span><span class="s3">None</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_limit_clause </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_offset_or_limit_clause</span><span class="s4">(</span><span class="s1">limit</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s4">@</span><span class="s1">_generative</span>
    <span class="s3">def </span><span class="s1">fetch</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">count</span><span class="s4">: </span><span class="s1">_LimitOffsetType</span><span class="s4">,</span>
        <span class="s1">with_ties</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
        <span class="s1">percent</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Return a new selectable with the given FETCH FIRST criterion 
        applied. 
 
        This is a numeric value which usually renders as 
        ``FETCH {FIRST | NEXT} [ count ] {ROW | ROWS} {ONLY | WITH TIES}`` 
        expression in the resulting select. This functionality is 
        is currently implemented for Oracle, PostgreSQL, MSSQL. 
 
        Use :meth:`_sql.GenerativeSelect.offset` to specify the offset. 
 
        .. note:: 
 
           The :meth:`_sql.GenerativeSelect.fetch` method will replace 
           any clause applied with :meth:`_sql.GenerativeSelect.limit`. 
 
        .. versionadded:: 1.4 
 
        :param count: an integer COUNT parameter, or a SQL expression 
         that provides an integer result. When ``percent=True`` this will 
         represent the percentage of rows to return, not the absolute value. 
         Pass ``None`` to reset it. 
 
        :param with_ties: When ``True``, the WITH TIES option is used 
         to return any additional rows that tie for the last place in the 
         result set according to the ``ORDER BY`` clause. The 
         ``ORDER BY`` may be mandatory in this case. Defaults to ``False`` 
 
        :param percent: When ``True``, ``count`` represents the percentage 
         of the total number of selected rows to return. Defaults to ``False`` 
 
        .. seealso:: 
 
           :meth:`_sql.GenerativeSelect.limit` 
 
           :meth:`_sql.GenerativeSelect.offset` 
 
        &quot;&quot;&quot;</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">_limit_clause </span><span class="s4">= </span><span class="s3">None</span>
        <span class="s3">if </span><span class="s1">count </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_fetch_clause </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_fetch_clause_options </span><span class="s4">= </span><span class="s3">None</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_fetch_clause </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_offset_or_limit_clause</span><span class="s4">(</span><span class="s1">count</span><span class="s4">)</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_fetch_clause_options </span><span class="s4">= {</span>
                <span class="s5">&quot;with_ties&quot;</span><span class="s4">: </span><span class="s1">with_ties</span><span class="s4">,</span>
                <span class="s5">&quot;percent&quot;</span><span class="s4">: </span><span class="s1">percent</span><span class="s4">,</span>
            <span class="s4">}</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s4">@</span><span class="s1">_generative</span>
    <span class="s3">def </span><span class="s1">offset</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">offset</span><span class="s4">: </span><span class="s1">_LimitOffsetType</span><span class="s4">) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Return a new selectable with the given OFFSET criterion 
        applied. 
 
 
        This is a numeric value which usually renders as an ``OFFSET`` 
        expression in the resulting select.  Backends that don't 
        support ``OFFSET`` will attempt to provide similar 
        functionality. 
 
        :param offset: an integer OFFSET parameter, or a SQL expression 
         that provides an integer result. Pass ``None`` to reset it. 
 
        .. seealso:: 
 
           :meth:`_sql.GenerativeSelect.limit` 
 
           :meth:`_sql.GenerativeSelect.fetch` 
 
        &quot;&quot;&quot;</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">_offset_clause </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_offset_or_limit_clause</span><span class="s4">(</span><span class="s1">offset</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s4">@</span><span class="s1">_generative</span>
    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">preload_module</span><span class="s4">(</span><span class="s5">&quot;sqlalchemy.sql.util&quot;</span><span class="s4">)</span>
    <span class="s3">def </span><span class="s1">slice</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">start</span><span class="s4">: </span><span class="s1">int</span><span class="s4">,</span>
        <span class="s1">stop</span><span class="s4">: </span><span class="s1">int</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Apply LIMIT / OFFSET to this statement based on a slice. 
 
        The start and stop indices behave like the argument to Python's 
        built-in :func:`range` function. This method provides an 
        alternative to using ``LIMIT``/``OFFSET`` to get a slice of the 
        query. 
 
        For example, :: 
 
            stmt = select(User).order_by(User.id).slice(1, 3) 
 
        renders as 
 
        .. sourcecode:: sql 
 
           SELECT users.id AS users_id, 
                  users.name AS users_name 
           FROM users ORDER BY users.id 
           LIMIT ? OFFSET ? 
           (2, 1) 
 
        .. note:: 
 
           The :meth:`_sql.GenerativeSelect.slice` method will replace 
           any clause applied with :meth:`_sql.GenerativeSelect.fetch`. 
 
        .. versionadded:: 1.4  Added the :meth:`_sql.GenerativeSelect.slice` 
           method generalized from the ORM. 
 
        .. seealso:: 
 
           :meth:`_sql.GenerativeSelect.limit` 
 
           :meth:`_sql.GenerativeSelect.offset` 
 
           :meth:`_sql.GenerativeSelect.fetch` 
 
        &quot;&quot;&quot;</span>
        <span class="s1">sql_util </span><span class="s4">= </span><span class="s1">util</span><span class="s4">.</span><span class="s1">preloaded</span><span class="s4">.</span><span class="s1">sql_util</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_fetch_clause </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_fetch_clause_options </span><span class="s4">= </span><span class="s3">None</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_limit_clause</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_offset_clause </span><span class="s4">= </span><span class="s1">sql_util</span><span class="s4">.</span><span class="s1">_make_slice</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_limit_clause</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_offset_clause</span><span class="s4">, </span><span class="s1">start</span><span class="s4">, </span><span class="s1">stop</span>
        <span class="s4">)</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s4">@</span><span class="s1">_generative</span>
    <span class="s3">def </span><span class="s1">order_by</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">__first</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span>
            <span class="s1">Literal</span><span class="s4">[</span><span class="s3">None</span><span class="s4">, </span><span class="s1">_NoArg</span><span class="s4">.</span><span class="s1">NO_ARG</span><span class="s4">],</span>
            <span class="s1">_ColumnExpressionOrStrLabelArgument</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">],</span>
        <span class="s4">] = </span><span class="s1">_NoArg</span><span class="s4">.</span><span class="s1">NO_ARG</span><span class="s4">,</span>
        <span class="s4">*</span><span class="s1">clauses</span><span class="s4">: </span><span class="s1">_ColumnExpressionOrStrLabelArgument</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">],</span>
    <span class="s4">) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s2">r&quot;&quot;&quot;Return a new selectable with the given list of ORDER BY 
        criteria applied. 
 
        e.g.:: 
 
            stmt = select(table).order_by(table.c.id, table.c.name) 
 
        Calling this method multiple times is equivalent to calling it once 
        with all the clauses concatenated. All existing ORDER BY criteria may 
        be cancelled by passing ``None`` by itself.  New ORDER BY criteria may 
        then be added by invoking :meth:`_orm.Query.order_by` again, e.g.:: 
 
            # will erase all ORDER BY and ORDER BY new_col alone 
            stmt = stmt.order_by(None).order_by(new_col) 
 
        :param \*clauses: a series of :class:`_expression.ColumnElement` 
         constructs 
         which will be used to generate an ORDER BY clause. 
 
        .. seealso:: 
 
            :ref:`tutorial_order_by` - in the :ref:`unified_tutorial` 
 
            :ref:`tutorial_order_by_label` - in the :ref:`unified_tutorial` 
 
        &quot;&quot;&quot;</span>

        <span class="s3">if not </span><span class="s1">clauses </span><span class="s3">and </span><span class="s1">__first </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_order_by_clauses </span><span class="s4">= ()</span>
        <span class="s3">elif </span><span class="s1">__first </span><span class="s3">is not </span><span class="s1">_NoArg</span><span class="s4">.</span><span class="s1">NO_ARG</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_order_by_clauses </span><span class="s4">+= </span><span class="s1">tuple</span><span class="s4">(</span>
                <span class="s1">coercions</span><span class="s4">.</span><span class="s1">expect</span><span class="s4">(</span>
                    <span class="s1">roles</span><span class="s4">.</span><span class="s1">OrderByRole</span><span class="s4">, </span><span class="s1">clause</span><span class="s4">, </span><span class="s1">apply_propagate_attrs</span><span class="s4">=</span><span class="s1">self</span>
                <span class="s4">)</span>
                <span class="s3">for </span><span class="s1">clause </span><span class="s3">in </span><span class="s4">(</span><span class="s1">__first</span><span class="s4">,) + </span><span class="s1">clauses</span>
            <span class="s4">)</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s4">@</span><span class="s1">_generative</span>
    <span class="s3">def </span><span class="s1">group_by</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">__first</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span>
            <span class="s1">Literal</span><span class="s4">[</span><span class="s3">None</span><span class="s4">, </span><span class="s1">_NoArg</span><span class="s4">.</span><span class="s1">NO_ARG</span><span class="s4">],</span>
            <span class="s1">_ColumnExpressionOrStrLabelArgument</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">],</span>
        <span class="s4">] = </span><span class="s1">_NoArg</span><span class="s4">.</span><span class="s1">NO_ARG</span><span class="s4">,</span>
        <span class="s4">*</span><span class="s1">clauses</span><span class="s4">: </span><span class="s1">_ColumnExpressionOrStrLabelArgument</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">],</span>
    <span class="s4">) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s2">r&quot;&quot;&quot;Return a new selectable with the given list of GROUP BY 
        criterion applied. 
 
        All existing GROUP BY settings can be suppressed by passing ``None``. 
 
        e.g.:: 
 
            stmt = select(table.c.name, func.max(table.c.stat)).\ 
            group_by(table.c.name) 
 
        :param \*clauses: a series of :class:`_expression.ColumnElement` 
         constructs 
         which will be used to generate an GROUP BY clause. 
 
        .. seealso:: 
 
            :ref:`tutorial_group_by_w_aggregates` - in the 
            :ref:`unified_tutorial` 
 
            :ref:`tutorial_order_by_label` - in the :ref:`unified_tutorial` 
 
        &quot;&quot;&quot;</span>

        <span class="s3">if not </span><span class="s1">clauses </span><span class="s3">and </span><span class="s1">__first </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_group_by_clauses </span><span class="s4">= ()</span>
        <span class="s3">elif </span><span class="s1">__first </span><span class="s3">is not </span><span class="s1">_NoArg</span><span class="s4">.</span><span class="s1">NO_ARG</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_group_by_clauses </span><span class="s4">+= </span><span class="s1">tuple</span><span class="s4">(</span>
                <span class="s1">coercions</span><span class="s4">.</span><span class="s1">expect</span><span class="s4">(</span>
                    <span class="s1">roles</span><span class="s4">.</span><span class="s1">GroupByRole</span><span class="s4">, </span><span class="s1">clause</span><span class="s4">, </span><span class="s1">apply_propagate_attrs</span><span class="s4">=</span><span class="s1">self</span>
                <span class="s4">)</span>
                <span class="s3">for </span><span class="s1">clause </span><span class="s3">in </span><span class="s4">(</span><span class="s1">__first</span><span class="s4">,) + </span><span class="s1">clauses</span>
            <span class="s4">)</span>
        <span class="s3">return </span><span class="s1">self</span>


<span class="s4">@</span><span class="s1">CompileState</span><span class="s4">.</span><span class="s1">plugin_for</span><span class="s4">(</span><span class="s5">&quot;default&quot;</span><span class="s4">, </span><span class="s5">&quot;compound_select&quot;</span><span class="s4">)</span>
<span class="s3">class </span><span class="s1">CompoundSelectState</span><span class="s4">(</span><span class="s1">CompileState</span><span class="s4">):</span>
    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">memoized_property</span>
    <span class="s3">def </span><span class="s1">_label_resolve_dict</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; Tuple</span><span class="s4">[</span>
        <span class="s1">Dict</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]],</span>
        <span class="s1">Dict</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]],</span>
        <span class="s1">Dict</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]],</span>
    <span class="s4">]:</span>
        <span class="s0"># TODO: this is hacky and slow</span>
        <span class="s1">hacky_subquery </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">statement</span><span class="s4">.</span><span class="s1">subquery</span><span class="s4">()</span>
        <span class="s1">hacky_subquery</span><span class="s4">.</span><span class="s1">named_with_column </span><span class="s4">= </span><span class="s3">False</span>
        <span class="s1">d </span><span class="s4">= {</span><span class="s1">c</span><span class="s4">.</span><span class="s1">key</span><span class="s4">: </span><span class="s1">c </span><span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">hacky_subquery</span><span class="s4">.</span><span class="s1">c</span><span class="s4">}</span>
        <span class="s3">return </span><span class="s1">d</span><span class="s4">, </span><span class="s1">d</span><span class="s4">, </span><span class="s1">d</span>


<span class="s3">class </span><span class="s1">_CompoundSelectKeyword</span><span class="s4">(</span><span class="s1">Enum</span><span class="s4">):</span>
    <span class="s1">UNION </span><span class="s4">= </span><span class="s5">&quot;UNION&quot;</span>
    <span class="s1">UNION_ALL </span><span class="s4">= </span><span class="s5">&quot;UNION ALL&quot;</span>
    <span class="s1">EXCEPT </span><span class="s4">= </span><span class="s5">&quot;EXCEPT&quot;</span>
    <span class="s1">EXCEPT_ALL </span><span class="s4">= </span><span class="s5">&quot;EXCEPT ALL&quot;</span>
    <span class="s1">INTERSECT </span><span class="s4">= </span><span class="s5">&quot;INTERSECT&quot;</span>
    <span class="s1">INTERSECT_ALL </span><span class="s4">= </span><span class="s5">&quot;INTERSECT ALL&quot;</span>


<span class="s3">class </span><span class="s1">CompoundSelect</span><span class="s4">(</span><span class="s1">HasCompileState</span><span class="s4">, </span><span class="s1">GenerativeSelect</span><span class="s4">, </span><span class="s1">ExecutableReturnsRows</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Forms the basis of ``UNION``, ``UNION ALL``, and other 
    SELECT-based set operations. 
 
 
    .. seealso:: 
 
        :func:`_expression.union` 
 
        :func:`_expression.union_all` 
 
        :func:`_expression.intersect` 
 
        :func:`_expression.intersect_all` 
 
        :func:`_expression.except` 
 
        :func:`_expression.except_all` 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;compound_select&quot;</span>

    <span class="s1">_traverse_internals</span><span class="s4">: </span><span class="s1">_TraverseInternalsType </span><span class="s4">= (</span>
        <span class="s4">[</span>
            <span class="s4">(</span><span class="s5">&quot;selects&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_clauseelement_list</span><span class="s4">),</span>
            <span class="s4">(</span><span class="s5">&quot;_limit_clause&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_clauseelement</span><span class="s4">),</span>
            <span class="s4">(</span><span class="s5">&quot;_offset_clause&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_clauseelement</span><span class="s4">),</span>
            <span class="s4">(</span><span class="s5">&quot;_fetch_clause&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_clauseelement</span><span class="s4">),</span>
            <span class="s4">(</span><span class="s5">&quot;_fetch_clause_options&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_plain_dict</span><span class="s4">),</span>
            <span class="s4">(</span><span class="s5">&quot;_order_by_clauses&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_clauseelement_list</span><span class="s4">),</span>
            <span class="s4">(</span><span class="s5">&quot;_group_by_clauses&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_clauseelement_list</span><span class="s4">),</span>
            <span class="s4">(</span><span class="s5">&quot;_for_update_arg&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_clauseelement</span><span class="s4">),</span>
            <span class="s4">(</span><span class="s5">&quot;keyword&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_string</span><span class="s4">),</span>
        <span class="s4">]</span>
        <span class="s4">+ </span><span class="s1">SupportsCloneAnnotations</span><span class="s4">.</span><span class="s1">_clone_annotations_traverse_internals</span>
        <span class="s4">+ </span><span class="s1">HasCTE</span><span class="s4">.</span><span class="s1">_has_ctes_traverse_internals</span>
    <span class="s4">)</span>

    <span class="s1">selects</span><span class="s4">: </span><span class="s1">List</span><span class="s4">[</span><span class="s1">SelectBase</span><span class="s4">]</span>

    <span class="s1">_is_from_container </span><span class="s4">= </span><span class="s3">True</span>
    <span class="s1">_auto_correlate </span><span class="s4">= </span><span class="s3">False</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">keyword</span><span class="s4">: </span><span class="s1">_CompoundSelectKeyword</span><span class="s4">,</span>
        <span class="s4">*</span><span class="s1">selects</span><span class="s4">: </span><span class="s1">_SelectStatementForCompoundArgument</span><span class="s4">,</span>
    <span class="s4">):</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">keyword </span><span class="s4">= </span><span class="s1">keyword</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">selects </span><span class="s4">= [</span>
            <span class="s1">coercions</span><span class="s4">.</span><span class="s1">expect</span><span class="s4">(</span>
                <span class="s1">roles</span><span class="s4">.</span><span class="s1">CompoundElementRole</span><span class="s4">, </span><span class="s1">s</span><span class="s4">, </span><span class="s1">apply_propagate_attrs</span><span class="s4">=</span><span class="s1">self</span>
            <span class="s4">).</span><span class="s1">self_group</span><span class="s4">(</span><span class="s1">against</span><span class="s4">=</span><span class="s1">self</span><span class="s4">)</span>
            <span class="s3">for </span><span class="s1">s </span><span class="s3">in </span><span class="s1">selects</span>
        <span class="s4">]</span>

        <span class="s1">GenerativeSelect</span><span class="s4">.</span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">classmethod</span>
    <span class="s3">def </span><span class="s1">_create_union</span><span class="s4">(</span>
        <span class="s1">cls</span><span class="s4">, *</span><span class="s1">selects</span><span class="s4">: </span><span class="s1">_SelectStatementForCompoundArgument</span>
    <span class="s4">) </span><span class="s1">-&gt; CompoundSelect</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">CompoundSelect</span><span class="s4">(</span><span class="s1">_CompoundSelectKeyword</span><span class="s4">.</span><span class="s1">UNION</span><span class="s4">, *</span><span class="s1">selects</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">classmethod</span>
    <span class="s3">def </span><span class="s1">_create_union_all</span><span class="s4">(</span>
        <span class="s1">cls</span><span class="s4">, *</span><span class="s1">selects</span><span class="s4">: </span><span class="s1">_SelectStatementForCompoundArgument</span>
    <span class="s4">) </span><span class="s1">-&gt; CompoundSelect</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">CompoundSelect</span><span class="s4">(</span><span class="s1">_CompoundSelectKeyword</span><span class="s4">.</span><span class="s1">UNION_ALL</span><span class="s4">, *</span><span class="s1">selects</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">classmethod</span>
    <span class="s3">def </span><span class="s1">_create_except</span><span class="s4">(</span>
        <span class="s1">cls</span><span class="s4">, *</span><span class="s1">selects</span><span class="s4">: </span><span class="s1">_SelectStatementForCompoundArgument</span>
    <span class="s4">) </span><span class="s1">-&gt; CompoundSelect</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">CompoundSelect</span><span class="s4">(</span><span class="s1">_CompoundSelectKeyword</span><span class="s4">.</span><span class="s1">EXCEPT</span><span class="s4">, *</span><span class="s1">selects</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">classmethod</span>
    <span class="s3">def </span><span class="s1">_create_except_all</span><span class="s4">(</span>
        <span class="s1">cls</span><span class="s4">, *</span><span class="s1">selects</span><span class="s4">: </span><span class="s1">_SelectStatementForCompoundArgument</span>
    <span class="s4">) </span><span class="s1">-&gt; CompoundSelect</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">CompoundSelect</span><span class="s4">(</span><span class="s1">_CompoundSelectKeyword</span><span class="s4">.</span><span class="s1">EXCEPT_ALL</span><span class="s4">, *</span><span class="s1">selects</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">classmethod</span>
    <span class="s3">def </span><span class="s1">_create_intersect</span><span class="s4">(</span>
        <span class="s1">cls</span><span class="s4">, *</span><span class="s1">selects</span><span class="s4">: </span><span class="s1">_SelectStatementForCompoundArgument</span>
    <span class="s4">) </span><span class="s1">-&gt; CompoundSelect</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">CompoundSelect</span><span class="s4">(</span><span class="s1">_CompoundSelectKeyword</span><span class="s4">.</span><span class="s1">INTERSECT</span><span class="s4">, *</span><span class="s1">selects</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">classmethod</span>
    <span class="s3">def </span><span class="s1">_create_intersect_all</span><span class="s4">(</span>
        <span class="s1">cls</span><span class="s4">, *</span><span class="s1">selects</span><span class="s4">: </span><span class="s1">_SelectStatementForCompoundArgument</span>
    <span class="s4">) </span><span class="s1">-&gt; CompoundSelect</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">CompoundSelect</span><span class="s4">(</span><span class="s1">_CompoundSelectKeyword</span><span class="s4">.</span><span class="s1">INTERSECT_ALL</span><span class="s4">, *</span><span class="s1">selects</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_scalar_type</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; TypeEngine</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]:</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">selects</span><span class="s4">[</span><span class="s6">0</span><span class="s4">].</span><span class="s1">_scalar_type</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">self_group</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">against</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">OperatorType</span><span class="s4">] = </span><span class="s3">None</span>
    <span class="s4">) </span><span class="s1">-&gt; GroupedElement</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">SelectStatementGrouping</span><span class="s4">(</span><span class="s1">self</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">is_derived_from</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">fromclause</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">FromClause</span><span class="s4">]) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
        <span class="s3">for </span><span class="s1">s </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">selects</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">s</span><span class="s4">.</span><span class="s1">is_derived_from</span><span class="s4">(</span><span class="s1">fromclause</span><span class="s4">):</span>
                <span class="s3">return True</span>
        <span class="s3">return False</span>

    <span class="s3">def </span><span class="s1">set_label_style</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">style</span><span class="s4">: </span><span class="s1">SelectLabelStyle</span><span class="s4">) </span><span class="s1">-&gt; CompoundSelect</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_label_style </span><span class="s3">is not </span><span class="s1">style</span><span class="s4">:</span>
            <span class="s1">self </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_generate</span><span class="s4">()</span>
            <span class="s1">select_0 </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">selects</span><span class="s4">[</span><span class="s6">0</span><span class="s4">].</span><span class="s1">set_label_style</span><span class="s4">(</span><span class="s1">style</span><span class="s4">)</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">selects </span><span class="s4">= [</span><span class="s1">select_0</span><span class="s4">] + </span><span class="s1">self</span><span class="s4">.</span><span class="s1">selects</span><span class="s4">[</span><span class="s6">1</span><span class="s4">:]</span>

        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">_ensure_disambiguated_names</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; CompoundSelect</span><span class="s4">:</span>
        <span class="s1">new_select </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">selects</span><span class="s4">[</span><span class="s6">0</span><span class="s4">].</span><span class="s1">_ensure_disambiguated_names</span><span class="s4">()</span>
        <span class="s3">if </span><span class="s1">new_select </span><span class="s3">is not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">selects</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]:</span>
            <span class="s1">self </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_generate</span><span class="s4">()</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">selects </span><span class="s4">= [</span><span class="s1">new_select</span><span class="s4">] + </span><span class="s1">self</span><span class="s4">.</span><span class="s1">selects</span><span class="s4">[</span><span class="s6">1</span><span class="s4">:]</span>

        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">_generate_fromclause_column_proxies</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">subquery</span><span class="s4">: </span><span class="s1">FromClause</span><span class="s4">,</span>
        <span class="s4">*,</span>
        <span class="s1">proxy_compound_columns</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span>
            <span class="s1">Iterable</span><span class="s4">[</span><span class="s1">Sequence</span><span class="s4">[</span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]]</span>
        <span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s0"># this is a slightly hacky thing - the union exports a</span>
        <span class="s0"># column that resembles just that of the *first* selectable.</span>
        <span class="s0"># to get at a &quot;composite&quot; column, particularly foreign keys,</span>
        <span class="s0"># you have to dig through the proxies collection which we</span>
        <span class="s0"># generate below.</span>
        <span class="s1">select_0 </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">selects</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]</span>

        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_label_style </span><span class="s3">is not </span><span class="s1">LABEL_STYLE_DEFAULT</span><span class="s4">:</span>
            <span class="s1">select_0 </span><span class="s4">= </span><span class="s1">select_0</span><span class="s4">.</span><span class="s1">set_label_style</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_label_style</span><span class="s4">)</span>

        <span class="s0"># hand-construct the &quot;_proxies&quot; collection to include all</span>
        <span class="s0"># derived columns place a 'weight' annotation corresponding</span>
        <span class="s0"># to how low in the list of select()s the column occurs, so</span>
        <span class="s0"># that the corresponding_column() operation can resolve</span>
        <span class="s0"># conflicts</span>
        <span class="s1">extra_col_iterator </span><span class="s4">= </span><span class="s1">zip</span><span class="s4">(</span>
            <span class="s4">*[</span>
                <span class="s4">[</span>
                    <span class="s1">c</span><span class="s4">.</span><span class="s1">_annotate</span><span class="s4">(</span><span class="s1">dd</span><span class="s4">)</span>
                    <span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">stmt</span><span class="s4">.</span><span class="s1">_all_selected_columns</span>
                    <span class="s3">if </span><span class="s1">is_column_element</span><span class="s4">(</span><span class="s1">c</span><span class="s4">)</span>
                <span class="s4">]</span>
                <span class="s3">for </span><span class="s1">dd</span><span class="s4">, </span><span class="s1">stmt </span><span class="s3">in </span><span class="s4">[</span>
                    <span class="s4">({</span><span class="s5">&quot;weight&quot;</span><span class="s4">: </span><span class="s1">i </span><span class="s4">+ </span><span class="s6">1</span><span class="s4">}, </span><span class="s1">stmt</span><span class="s4">)</span>
                    <span class="s3">for </span><span class="s1">i</span><span class="s4">, </span><span class="s1">stmt </span><span class="s3">in </span><span class="s1">enumerate</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">selects</span><span class="s4">)</span>
                <span class="s4">]</span>
            <span class="s4">]</span>
        <span class="s4">)</span>

        <span class="s0"># the incoming proxy_compound_columns can be present also if this is</span>
        <span class="s0"># a compound embedded in a compound.  it's probably more appropriate</span>
        <span class="s0"># that we generate new weights local to this nested compound, though</span>
        <span class="s0"># i haven't tried to think what it means for compound nested in</span>
        <span class="s0"># compound</span>
        <span class="s1">select_0</span><span class="s4">.</span><span class="s1">_generate_fromclause_column_proxies</span><span class="s4">(</span>
            <span class="s1">subquery</span><span class="s4">, </span><span class="s1">proxy_compound_columns</span><span class="s4">=</span><span class="s1">extra_col_iterator</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_refresh_for_new_column</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">column</span><span class="s4">: </span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s1">super</span><span class="s4">().</span><span class="s1">_refresh_for_new_column</span><span class="s4">(</span><span class="s1">column</span><span class="s4">)</span>
        <span class="s3">for </span><span class="s1">select </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">selects</span><span class="s4">:</span>
            <span class="s1">select</span><span class="s4">.</span><span class="s1">_refresh_for_new_column</span><span class="s4">(</span><span class="s1">column</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">ro_non_memoized_property</span>
    <span class="s3">def </span><span class="s1">_all_selected_columns</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; _SelectIterable</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">selects</span><span class="s4">[</span><span class="s6">0</span><span class="s4">].</span><span class="s1">_all_selected_columns</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">ro_non_memoized_property</span>
    <span class="s3">def </span><span class="s1">selected_columns</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; ColumnCollection</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]:</span>
        <span class="s2">&quot;&quot;&quot;A :class:`_expression.ColumnCollection` 
        representing the columns that 
        this SELECT statement or similar construct returns in its result set, 
        not including :class:`_sql.TextClause` constructs. 
 
        For a :class:`_expression.CompoundSelect`, the 
        :attr:`_expression.CompoundSelect.selected_columns` 
        attribute returns the selected 
        columns of the first SELECT statement contained within the series of 
        statements within the set operation. 
 
        .. seealso:: 
 
            :attr:`_sql.Select.selected_columns` 
 
        .. versionadded:: 1.4 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">selects</span><span class="s4">[</span><span class="s6">0</span><span class="s4">].</span><span class="s1">selected_columns</span>


<span class="s0"># backwards compat</span>
<span class="s3">for </span><span class="s1">elem </span><span class="s3">in </span><span class="s1">_CompoundSelectKeyword</span><span class="s4">:</span>
    <span class="s1">setattr</span><span class="s4">(</span><span class="s1">CompoundSelect</span><span class="s4">, </span><span class="s1">elem</span><span class="s4">.</span><span class="s1">name</span><span class="s4">, </span><span class="s1">elem</span><span class="s4">)</span>


<span class="s4">@</span><span class="s1">CompileState</span><span class="s4">.</span><span class="s1">plugin_for</span><span class="s4">(</span><span class="s5">&quot;default&quot;</span><span class="s4">, </span><span class="s5">&quot;select&quot;</span><span class="s4">)</span>
<span class="s3">class </span><span class="s1">SelectState</span><span class="s4">(</span><span class="s1">util</span><span class="s4">.</span><span class="s1">MemoizedSlots</span><span class="s4">, </span><span class="s1">CompileState</span><span class="s4">):</span>
    <span class="s1">__slots__ </span><span class="s4">= (</span>
        <span class="s5">&quot;from_clauses&quot;</span><span class="s4">,</span>
        <span class="s5">&quot;froms&quot;</span><span class="s4">,</span>
        <span class="s5">&quot;columns_plus_names&quot;</span><span class="s4">,</span>
        <span class="s5">&quot;_label_resolve_dict&quot;</span><span class="s4">,</span>
    <span class="s4">)</span>

    <span class="s3">if </span><span class="s1">TYPE_CHECKING</span><span class="s4">:</span>
        <span class="s1">default_select_compile_options</span><span class="s4">: </span><span class="s1">CacheableOptions</span>
    <span class="s3">else</span><span class="s4">:</span>

        <span class="s3">class </span><span class="s1">default_select_compile_options</span><span class="s4">(</span><span class="s1">CacheableOptions</span><span class="s4">):</span>
            <span class="s1">_cache_key_traversal </span><span class="s4">= []</span>

    <span class="s3">if </span><span class="s1">TYPE_CHECKING</span><span class="s4">:</span>

        <span class="s4">@</span><span class="s1">classmethod</span>
        <span class="s3">def </span><span class="s1">get_plugin_class</span><span class="s4">(</span>
            <span class="s1">cls</span><span class="s4">, </span><span class="s1">statement</span><span class="s4">: </span><span class="s1">Executable</span>
        <span class="s4">) </span><span class="s1">-&gt; Type</span><span class="s4">[</span><span class="s1">SelectState</span><span class="s4">]: ...</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">statement</span><span class="s4">: </span><span class="s1">Select</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">],</span>
        <span class="s1">compiler</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">SQLCompiler</span><span class="s4">],</span>
        <span class="s4">**</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
    <span class="s4">):</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">statement </span><span class="s4">= </span><span class="s1">statement</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">from_clauses </span><span class="s4">= </span><span class="s1">statement</span><span class="s4">.</span><span class="s1">_from_obj</span>

        <span class="s3">for </span><span class="s1">memoized_entities </span><span class="s3">in </span><span class="s1">statement</span><span class="s4">.</span><span class="s1">_memoized_select_entities</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_setup_joins</span><span class="s4">(</span>
                <span class="s1">memoized_entities</span><span class="s4">.</span><span class="s1">_setup_joins</span><span class="s4">, </span><span class="s1">memoized_entities</span><span class="s4">.</span><span class="s1">_raw_columns</span>
            <span class="s4">)</span>

        <span class="s3">if </span><span class="s1">statement</span><span class="s4">.</span><span class="s1">_setup_joins</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_setup_joins</span><span class="s4">(</span><span class="s1">statement</span><span class="s4">.</span><span class="s1">_setup_joins</span><span class="s4">, </span><span class="s1">statement</span><span class="s4">.</span><span class="s1">_raw_columns</span><span class="s4">)</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">froms </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_get_froms</span><span class="s4">(</span><span class="s1">statement</span><span class="s4">)</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">columns_plus_names </span><span class="s4">= </span><span class="s1">statement</span><span class="s4">.</span><span class="s1">_generate_columns_plus_names</span><span class="s4">(</span><span class="s3">True</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">classmethod</span>
    <span class="s3">def </span><span class="s1">_plugin_not_implemented</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">) </span><span class="s1">-&gt; NoReturn</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">(</span>
            <span class="s5">&quot;The default SELECT construct without plugins does not &quot;</span>
            <span class="s5">&quot;implement this method.&quot;</span>
        <span class="s4">)</span>

    <span class="s4">@</span><span class="s1">classmethod</span>
    <span class="s3">def </span><span class="s1">get_column_descriptions</span><span class="s4">(</span>
        <span class="s1">cls</span><span class="s4">, </span><span class="s1">statement</span><span class="s4">: </span><span class="s1">Select</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]</span>
    <span class="s4">) </span><span class="s1">-&gt; List</span><span class="s4">[</span><span class="s1">Dict</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">Any</span><span class="s4">]]:</span>
        <span class="s3">return </span><span class="s4">[</span>
            <span class="s4">{</span>
                <span class="s5">&quot;name&quot;</span><span class="s4">: </span><span class="s1">name</span><span class="s4">,</span>
                <span class="s5">&quot;type&quot;</span><span class="s4">: </span><span class="s1">element</span><span class="s4">.</span><span class="s1">type</span><span class="s4">,</span>
                <span class="s5">&quot;expr&quot;</span><span class="s4">: </span><span class="s1">element</span><span class="s4">,</span>
            <span class="s4">}</span>
            <span class="s3">for </span><span class="s1">_</span><span class="s4">, </span><span class="s1">name</span><span class="s4">, </span><span class="s1">_</span><span class="s4">, </span><span class="s1">element</span><span class="s4">, </span><span class="s1">_ </span><span class="s3">in </span><span class="s4">(</span>
                <span class="s1">statement</span><span class="s4">.</span><span class="s1">_generate_columns_plus_names</span><span class="s4">(</span><span class="s3">False</span><span class="s4">)</span>
            <span class="s4">)</span>
        <span class="s4">]</span>

    <span class="s4">@</span><span class="s1">classmethod</span>
    <span class="s3">def </span><span class="s1">from_statement</span><span class="s4">(</span>
        <span class="s1">cls</span><span class="s4">, </span><span class="s1">statement</span><span class="s4">: </span><span class="s1">Select</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">], </span><span class="s1">from_statement</span><span class="s4">: </span><span class="s1">roles</span><span class="s4">.</span><span class="s1">ReturnsRowsRole</span>
    <span class="s4">) </span><span class="s1">-&gt; ExecutableReturnsRows</span><span class="s4">:</span>
        <span class="s1">cls</span><span class="s4">.</span><span class="s1">_plugin_not_implemented</span><span class="s4">()</span>

    <span class="s4">@</span><span class="s1">classmethod</span>
    <span class="s3">def </span><span class="s1">get_columns_clause_froms</span><span class="s4">(</span>
        <span class="s1">cls</span><span class="s4">, </span><span class="s1">statement</span><span class="s4">: </span><span class="s1">Select</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]</span>
    <span class="s4">) </span><span class="s1">-&gt; List</span><span class="s4">[</span><span class="s1">FromClause</span><span class="s4">]:</span>
        <span class="s3">return </span><span class="s1">cls</span><span class="s4">.</span><span class="s1">_normalize_froms</span><span class="s4">(</span>
            <span class="s1">itertools</span><span class="s4">.</span><span class="s1">chain</span><span class="s4">.</span><span class="s1">from_iterable</span><span class="s4">(</span>
                <span class="s1">element</span><span class="s4">.</span><span class="s1">_from_objects </span><span class="s3">for </span><span class="s1">element </span><span class="s3">in </span><span class="s1">statement</span><span class="s4">.</span><span class="s1">_raw_columns</span>
            <span class="s4">)</span>
        <span class="s4">)</span>

    <span class="s4">@</span><span class="s1">classmethod</span>
    <span class="s3">def </span><span class="s1">_column_naming_convention</span><span class="s4">(</span>
        <span class="s1">cls</span><span class="s4">, </span><span class="s1">label_style</span><span class="s4">: </span><span class="s1">SelectLabelStyle</span>
    <span class="s4">) </span><span class="s1">-&gt; _LabelConventionCallable</span><span class="s4">:</span>
        <span class="s1">table_qualified </span><span class="s4">= </span><span class="s1">label_style </span><span class="s3">is </span><span class="s1">LABEL_STYLE_TABLENAME_PLUS_COL</span>

        <span class="s1">dedupe </span><span class="s4">= </span><span class="s1">label_style </span><span class="s3">is not </span><span class="s1">LABEL_STYLE_NONE</span>

        <span class="s1">pa </span><span class="s4">= </span><span class="s1">prefix_anon_map</span><span class="s4">()</span>
        <span class="s1">names </span><span class="s4">= </span><span class="s1">set</span><span class="s4">()</span>

        <span class="s3">def </span><span class="s1">go</span><span class="s4">(</span>
            <span class="s1">c</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">], </span><span class="s1">TextClause</span><span class="s4">],</span>
            <span class="s1">col_name</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s4">) </span><span class="s1">-&gt; Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]:</span>
            <span class="s3">if </span><span class="s1">is_text_clause</span><span class="s4">(</span><span class="s1">c</span><span class="s4">):</span>
                <span class="s3">return None</span>
            <span class="s3">elif </span><span class="s1">TYPE_CHECKING</span><span class="s4">:</span>
                <span class="s3">assert </span><span class="s1">is_column_element</span><span class="s4">(</span><span class="s1">c</span><span class="s4">)</span>

            <span class="s3">if not </span><span class="s1">dedupe</span><span class="s4">:</span>
                <span class="s1">name </span><span class="s4">= </span><span class="s1">c</span><span class="s4">.</span><span class="s1">_proxy_key</span>
                <span class="s3">if </span><span class="s1">name </span><span class="s3">is None</span><span class="s4">:</span>
                    <span class="s1">name </span><span class="s4">= </span><span class="s5">&quot;_no_label&quot;</span>
                <span class="s3">return </span><span class="s1">name</span>

            <span class="s1">name </span><span class="s4">= </span><span class="s1">c</span><span class="s4">.</span><span class="s1">_tq_key_label </span><span class="s3">if </span><span class="s1">table_qualified </span><span class="s3">else </span><span class="s1">c</span><span class="s4">.</span><span class="s1">_proxy_key</span>

            <span class="s3">if </span><span class="s1">name </span><span class="s3">is None</span><span class="s4">:</span>
                <span class="s1">name </span><span class="s4">= </span><span class="s5">&quot;_no_label&quot;</span>
                <span class="s3">if </span><span class="s1">name </span><span class="s3">in </span><span class="s1">names</span><span class="s4">:</span>
                    <span class="s3">return </span><span class="s1">c</span><span class="s4">.</span><span class="s1">_anon_label</span><span class="s4">(</span><span class="s1">name</span><span class="s4">) % </span><span class="s1">pa</span>
                <span class="s3">else</span><span class="s4">:</span>
                    <span class="s1">names</span><span class="s4">.</span><span class="s1">add</span><span class="s4">(</span><span class="s1">name</span><span class="s4">)</span>
                    <span class="s3">return </span><span class="s1">name</span>

            <span class="s3">elif </span><span class="s1">name </span><span class="s3">in </span><span class="s1">names</span><span class="s4">:</span>
                <span class="s3">return </span><span class="s4">(</span>
                    <span class="s1">c</span><span class="s4">.</span><span class="s1">_anon_tq_key_label </span><span class="s4">% </span><span class="s1">pa</span>
                    <span class="s3">if </span><span class="s1">table_qualified</span>
                    <span class="s3">else </span><span class="s1">c</span><span class="s4">.</span><span class="s1">_anon_key_label </span><span class="s4">% </span><span class="s1">pa</span>
                <span class="s4">)</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">names</span><span class="s4">.</span><span class="s1">add</span><span class="s4">(</span><span class="s1">name</span><span class="s4">)</span>
                <span class="s3">return </span><span class="s1">name</span>

        <span class="s3">return </span><span class="s1">go</span>

    <span class="s3">def </span><span class="s1">_get_froms</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">statement</span><span class="s4">: </span><span class="s1">Select</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]) </span><span class="s1">-&gt; List</span><span class="s4">[</span><span class="s1">FromClause</span><span class="s4">]:</span>
        <span class="s1">ambiguous_table_name_map</span><span class="s4">: </span><span class="s1">_AmbiguousTableNameMap</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_ambiguous_table_name_map </span><span class="s4">= </span><span class="s1">ambiguous_table_name_map </span><span class="s4">= {}</span>

        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_normalize_froms</span><span class="s4">(</span>
            <span class="s1">itertools</span><span class="s4">.</span><span class="s1">chain</span><span class="s4">(</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">from_clauses</span><span class="s4">,</span>
                <span class="s1">itertools</span><span class="s4">.</span><span class="s1">chain</span><span class="s4">.</span><span class="s1">from_iterable</span><span class="s4">(</span>
                    <span class="s4">[</span>
                        <span class="s1">element</span><span class="s4">.</span><span class="s1">_from_objects</span>
                        <span class="s3">for </span><span class="s1">element </span><span class="s3">in </span><span class="s1">statement</span><span class="s4">.</span><span class="s1">_raw_columns</span>
                    <span class="s4">]</span>
                <span class="s4">),</span>
                <span class="s1">itertools</span><span class="s4">.</span><span class="s1">chain</span><span class="s4">.</span><span class="s1">from_iterable</span><span class="s4">(</span>
                    <span class="s4">[</span>
                        <span class="s1">element</span><span class="s4">.</span><span class="s1">_from_objects</span>
                        <span class="s3">for </span><span class="s1">element </span><span class="s3">in </span><span class="s1">statement</span><span class="s4">.</span><span class="s1">_where_criteria</span>
                    <span class="s4">]</span>
                <span class="s4">),</span>
            <span class="s4">),</span>
            <span class="s1">check_statement</span><span class="s4">=</span><span class="s1">statement</span><span class="s4">,</span>
            <span class="s1">ambiguous_table_name_map</span><span class="s4">=</span><span class="s1">ambiguous_table_name_map</span><span class="s4">,</span>
        <span class="s4">)</span>

    <span class="s4">@</span><span class="s1">classmethod</span>
    <span class="s3">def </span><span class="s1">_normalize_froms</span><span class="s4">(</span>
        <span class="s1">cls</span><span class="s4">,</span>
        <span class="s1">iterable_of_froms</span><span class="s4">: </span><span class="s1">Iterable</span><span class="s4">[</span><span class="s1">FromClause</span><span class="s4">],</span>
        <span class="s1">check_statement</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Select</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">ambiguous_table_name_map</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_AmbiguousTableNameMap</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; List</span><span class="s4">[</span><span class="s1">FromClause</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;given an iterable of things to select FROM, reduce them to what 
        would actually render in the FROM clause of a SELECT. 
 
        This does the job of checking for JOINs, tables, etc. that are in fact 
        overlapping due to cloning, adaption, present in overlapping joins, 
        etc. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">seen</span><span class="s4">: </span><span class="s1">Set</span><span class="s4">[</span><span class="s1">FromClause</span><span class="s4">] = </span><span class="s1">set</span><span class="s4">()</span>
        <span class="s1">froms</span><span class="s4">: </span><span class="s1">List</span><span class="s4">[</span><span class="s1">FromClause</span><span class="s4">] = []</span>

        <span class="s3">for </span><span class="s1">item </span><span class="s3">in </span><span class="s1">iterable_of_froms</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">is_subquery</span><span class="s4">(</span><span class="s1">item</span><span class="s4">) </span><span class="s3">and </span><span class="s1">item</span><span class="s4">.</span><span class="s1">element </span><span class="s3">is </span><span class="s1">check_statement</span><span class="s4">:</span>
                <span class="s3">raise </span><span class="s1">exc</span><span class="s4">.</span><span class="s1">InvalidRequestError</span><span class="s4">(</span>
                    <span class="s5">&quot;select() construct refers to itself as a FROM&quot;</span>
                <span class="s4">)</span>

            <span class="s3">if not </span><span class="s1">seen</span><span class="s4">.</span><span class="s1">intersection</span><span class="s4">(</span><span class="s1">item</span><span class="s4">.</span><span class="s1">_cloned_set</span><span class="s4">):</span>
                <span class="s1">froms</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">item</span><span class="s4">)</span>
                <span class="s1">seen</span><span class="s4">.</span><span class="s1">update</span><span class="s4">(</span><span class="s1">item</span><span class="s4">.</span><span class="s1">_cloned_set</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s1">froms</span><span class="s4">:</span>
            <span class="s1">toremove </span><span class="s4">= </span><span class="s1">set</span><span class="s4">(</span>
                <span class="s1">itertools</span><span class="s4">.</span><span class="s1">chain</span><span class="s4">.</span><span class="s1">from_iterable</span><span class="s4">(</span>
                    <span class="s4">[</span><span class="s1">_expand_cloned</span><span class="s4">(</span><span class="s1">f</span><span class="s4">.</span><span class="s1">_hide_froms</span><span class="s4">) </span><span class="s3">for </span><span class="s1">f </span><span class="s3">in </span><span class="s1">froms</span><span class="s4">]</span>
                <span class="s4">)</span>
            <span class="s4">)</span>
            <span class="s3">if </span><span class="s1">toremove</span><span class="s4">:</span>
                <span class="s0"># filter out to FROM clauses not in the list,</span>
                <span class="s0"># using a list to maintain ordering</span>
                <span class="s1">froms </span><span class="s4">= [</span><span class="s1">f </span><span class="s3">for </span><span class="s1">f </span><span class="s3">in </span><span class="s1">froms </span><span class="s3">if </span><span class="s1">f </span><span class="s3">not in </span><span class="s1">toremove</span><span class="s4">]</span>

            <span class="s3">if </span><span class="s1">ambiguous_table_name_map </span><span class="s3">is not None</span><span class="s4">:</span>
                <span class="s1">ambiguous_table_name_map</span><span class="s4">.</span><span class="s1">update</span><span class="s4">(</span>
                    <span class="s4">(</span>
                        <span class="s1">fr</span><span class="s4">.</span><span class="s1">name</span><span class="s4">,</span>
                        <span class="s1">_anonymous_label</span><span class="s4">.</span><span class="s1">safe_construct</span><span class="s4">(</span>
                            <span class="s1">hash</span><span class="s4">(</span><span class="s1">fr</span><span class="s4">.</span><span class="s1">name</span><span class="s4">), </span><span class="s1">fr</span><span class="s4">.</span><span class="s1">name</span>
                        <span class="s4">),</span>
                    <span class="s4">)</span>
                    <span class="s3">for </span><span class="s1">item </span><span class="s3">in </span><span class="s1">froms</span>
                    <span class="s3">for </span><span class="s1">fr </span><span class="s3">in </span><span class="s1">item</span><span class="s4">.</span><span class="s1">_from_objects</span>
                    <span class="s3">if </span><span class="s1">is_table</span><span class="s4">(</span><span class="s1">fr</span><span class="s4">)</span>
                    <span class="s3">and </span><span class="s1">fr</span><span class="s4">.</span><span class="s1">schema</span>
                    <span class="s3">and </span><span class="s1">fr</span><span class="s4">.</span><span class="s1">name </span><span class="s3">not in </span><span class="s1">ambiguous_table_name_map</span>
                <span class="s4">)</span>

        <span class="s3">return </span><span class="s1">froms</span>

    <span class="s3">def </span><span class="s1">_get_display_froms</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">explicit_correlate_froms</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Sequence</span><span class="s4">[</span><span class="s1">FromClause</span><span class="s4">]] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">implicit_correlate_froms</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Sequence</span><span class="s4">[</span><span class="s1">FromClause</span><span class="s4">]] = </span><span class="s3">None</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; List</span><span class="s4">[</span><span class="s1">FromClause</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;Return the full list of 'from' clauses to be displayed. 
 
        Takes into account a set of existing froms which may be 
        rendered in the FROM clause of enclosing selects; this Select 
        may want to leave those absent if it is automatically 
        correlating. 
 
        &quot;&quot;&quot;</span>

        <span class="s1">froms </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">froms</span>

        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">statement</span><span class="s4">.</span><span class="s1">_correlate</span><span class="s4">:</span>
            <span class="s1">to_correlate </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">statement</span><span class="s4">.</span><span class="s1">_correlate</span>
            <span class="s3">if </span><span class="s1">to_correlate</span><span class="s4">:</span>
                <span class="s1">froms </span><span class="s4">= [</span>
                    <span class="s1">f</span>
                    <span class="s3">for </span><span class="s1">f </span><span class="s3">in </span><span class="s1">froms</span>
                    <span class="s3">if </span><span class="s1">f</span>
                    <span class="s3">not in </span><span class="s1">_cloned_intersection</span><span class="s4">(</span>
                        <span class="s1">_cloned_intersection</span><span class="s4">(</span>
                            <span class="s1">froms</span><span class="s4">, </span><span class="s1">explicit_correlate_froms </span><span class="s3">or </span><span class="s4">()</span>
                        <span class="s4">),</span>
                        <span class="s1">to_correlate</span><span class="s4">,</span>
                    <span class="s4">)</span>
                <span class="s4">]</span>

        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">statement</span><span class="s4">.</span><span class="s1">_correlate_except </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s1">froms </span><span class="s4">= [</span>
                <span class="s1">f</span>
                <span class="s3">for </span><span class="s1">f </span><span class="s3">in </span><span class="s1">froms</span>
                <span class="s3">if </span><span class="s1">f</span>
                <span class="s3">not in </span><span class="s1">_cloned_difference</span><span class="s4">(</span>
                    <span class="s1">_cloned_intersection</span><span class="s4">(</span>
                        <span class="s1">froms</span><span class="s4">, </span><span class="s1">explicit_correlate_froms </span><span class="s3">or </span><span class="s4">()</span>
                    <span class="s4">),</span>
                    <span class="s1">self</span><span class="s4">.</span><span class="s1">statement</span><span class="s4">.</span><span class="s1">_correlate_except</span><span class="s4">,</span>
                <span class="s4">)</span>
            <span class="s4">]</span>

        <span class="s3">if </span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">statement</span><span class="s4">.</span><span class="s1">_auto_correlate</span>
            <span class="s3">and </span><span class="s1">implicit_correlate_froms</span>
            <span class="s3">and </span><span class="s1">len</span><span class="s4">(</span><span class="s1">froms</span><span class="s4">) &gt; </span><span class="s6">1</span>
        <span class="s4">):</span>
            <span class="s1">froms </span><span class="s4">= [</span>
                <span class="s1">f</span>
                <span class="s3">for </span><span class="s1">f </span><span class="s3">in </span><span class="s1">froms</span>
                <span class="s3">if </span><span class="s1">f</span>
                <span class="s3">not in </span><span class="s1">_cloned_intersection</span><span class="s4">(</span><span class="s1">froms</span><span class="s4">, </span><span class="s1">implicit_correlate_froms</span><span class="s4">)</span>
            <span class="s4">]</span>

            <span class="s3">if not </span><span class="s1">len</span><span class="s4">(</span><span class="s1">froms</span><span class="s4">):</span>
                <span class="s3">raise </span><span class="s1">exc</span><span class="s4">.</span><span class="s1">InvalidRequestError</span><span class="s4">(</span>
                    <span class="s5">&quot;Select statement '%r&quot;</span>
                    <span class="s5">&quot;' returned no FROM clauses &quot;</span>
                    <span class="s5">&quot;due to auto-correlation; &quot;</span>
                    <span class="s5">&quot;specify correlate(&lt;tables&gt;) &quot;</span>
                    <span class="s5">&quot;to control correlation &quot;</span>
                    <span class="s5">&quot;manually.&quot; </span><span class="s4">% </span><span class="s1">self</span><span class="s4">.</span><span class="s1">statement</span>
                <span class="s4">)</span>

        <span class="s3">return </span><span class="s1">froms</span>

    <span class="s3">def </span><span class="s1">_memoized_attr__label_resolve_dict</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; Tuple</span><span class="s4">[</span>
        <span class="s1">Dict</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]],</span>
        <span class="s1">Dict</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]],</span>
        <span class="s1">Dict</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]],</span>
    <span class="s4">]:</span>
        <span class="s1">with_cols</span><span class="s4">: </span><span class="s1">Dict</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]] = {</span>
            <span class="s1">c</span><span class="s4">.</span><span class="s1">_tq_label </span><span class="s3">or </span><span class="s1">c</span><span class="s4">.</span><span class="s1">key</span><span class="s4">: </span><span class="s1">c</span>
            <span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">statement</span><span class="s4">.</span><span class="s1">_all_selected_columns</span>
            <span class="s3">if </span><span class="s1">c</span><span class="s4">.</span><span class="s1">_allow_label_resolve</span>
        <span class="s4">}</span>
        <span class="s1">only_froms</span><span class="s4">: </span><span class="s1">Dict</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]] = {</span>
            <span class="s1">c</span><span class="s4">.</span><span class="s1">key</span><span class="s4">: </span><span class="s1">c  </span><span class="s0"># type: ignore</span>
            <span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">_select_iterables</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">froms</span><span class="s4">)</span>
            <span class="s3">if </span><span class="s1">c</span><span class="s4">.</span><span class="s1">_allow_label_resolve</span>
        <span class="s4">}</span>
        <span class="s1">only_cols</span><span class="s4">: </span><span class="s1">Dict</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]] = </span><span class="s1">with_cols</span><span class="s4">.</span><span class="s1">copy</span><span class="s4">()</span>
        <span class="s3">for </span><span class="s1">key</span><span class="s4">, </span><span class="s1">value </span><span class="s3">in </span><span class="s1">only_froms</span><span class="s4">.</span><span class="s1">items</span><span class="s4">():</span>
            <span class="s1">with_cols</span><span class="s4">.</span><span class="s1">setdefault</span><span class="s4">(</span><span class="s1">key</span><span class="s4">, </span><span class="s1">value</span><span class="s4">)</span>

        <span class="s3">return </span><span class="s1">with_cols</span><span class="s4">, </span><span class="s1">only_froms</span><span class="s4">, </span><span class="s1">only_cols</span>

    <span class="s4">@</span><span class="s1">classmethod</span>
    <span class="s3">def </span><span class="s1">determine_last_joined_entity</span><span class="s4">(</span>
        <span class="s1">cls</span><span class="s4">, </span><span class="s1">stmt</span><span class="s4">: </span><span class="s1">Select</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]</span>
    <span class="s4">) </span><span class="s1">-&gt; Optional</span><span class="s4">[</span><span class="s1">_JoinTargetElement</span><span class="s4">]:</span>
        <span class="s3">if </span><span class="s1">stmt</span><span class="s4">.</span><span class="s1">_setup_joins</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">stmt</span><span class="s4">.</span><span class="s1">_setup_joins</span><span class="s4">[-</span><span class="s6">1</span><span class="s4">][</span><span class="s6">0</span><span class="s4">]</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return None</span>

    <span class="s4">@</span><span class="s1">classmethod</span>
    <span class="s3">def </span><span class="s1">all_selected_columns</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">, </span><span class="s1">statement</span><span class="s4">: </span><span class="s1">Select</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]) </span><span class="s1">-&gt; _SelectIterable</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s4">[</span><span class="s1">c </span><span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">_select_iterables</span><span class="s4">(</span><span class="s1">statement</span><span class="s4">.</span><span class="s1">_raw_columns</span><span class="s4">)]</span>

    <span class="s3">def </span><span class="s1">_setup_joins</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">args</span><span class="s4">: </span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">_SetupJoinsElement</span><span class="s4">, ...],</span>
        <span class="s1">raw_columns</span><span class="s4">: </span><span class="s1">List</span><span class="s4">[</span><span class="s1">_ColumnsClauseElement</span><span class="s4">],</span>
    <span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s3">for </span><span class="s1">right</span><span class="s4">, </span><span class="s1">onclause</span><span class="s4">, </span><span class="s1">left</span><span class="s4">, </span><span class="s1">flags </span><span class="s3">in </span><span class="s1">args</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">TYPE_CHECKING</span><span class="s4">:</span>
                <span class="s3">if </span><span class="s1">onclause </span><span class="s3">is not None</span><span class="s4">:</span>
                    <span class="s3">assert </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">onclause</span><span class="s4">, </span><span class="s1">ColumnElement</span><span class="s4">)</span>

            <span class="s1">isouter </span><span class="s4">= </span><span class="s1">flags</span><span class="s4">[</span><span class="s5">&quot;isouter&quot;</span><span class="s4">]</span>
            <span class="s1">full </span><span class="s4">= </span><span class="s1">flags</span><span class="s4">[</span><span class="s5">&quot;full&quot;</span><span class="s4">]</span>

            <span class="s3">if </span><span class="s1">left </span><span class="s3">is None</span><span class="s4">:</span>
                <span class="s4">(</span>
                    <span class="s1">left</span><span class="s4">,</span>
                    <span class="s1">replace_from_obj_index</span><span class="s4">,</span>
                <span class="s4">) = </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_join_determine_implicit_left_side</span><span class="s4">(</span>
                    <span class="s1">raw_columns</span><span class="s4">, </span><span class="s1">left</span><span class="s4">, </span><span class="s1">right</span><span class="s4">, </span><span class="s1">onclause</span>
                <span class="s4">)</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s4">(</span><span class="s1">replace_from_obj_index</span><span class="s4">) = </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_join_place_explicit_left_side</span><span class="s4">(</span>
                    <span class="s1">left</span>
                <span class="s4">)</span>

            <span class="s0"># these assertions can be made here, as if the right/onclause</span>
            <span class="s0"># contained ORM elements, the select() statement would have been</span>
            <span class="s0"># upgraded to an ORM select, and this method would not be called;</span>
            <span class="s0"># orm.context.ORMSelectCompileState._join() would be</span>
            <span class="s0"># used instead.</span>
            <span class="s3">if </span><span class="s1">TYPE_CHECKING</span><span class="s4">:</span>
                <span class="s3">assert </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">right</span><span class="s4">, </span><span class="s1">FromClause</span><span class="s4">)</span>
                <span class="s3">if </span><span class="s1">onclause </span><span class="s3">is not None</span><span class="s4">:</span>
                    <span class="s3">assert </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">onclause</span><span class="s4">, </span><span class="s1">ColumnElement</span><span class="s4">)</span>

            <span class="s3">if </span><span class="s1">replace_from_obj_index </span><span class="s3">is not None</span><span class="s4">:</span>
                <span class="s0"># splice into an existing element in the</span>
                <span class="s0"># self._from_obj list</span>
                <span class="s1">left_clause </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">from_clauses</span><span class="s4">[</span><span class="s1">replace_from_obj_index</span><span class="s4">]</span>

                <span class="s1">self</span><span class="s4">.</span><span class="s1">from_clauses </span><span class="s4">= (</span>
                    <span class="s1">self</span><span class="s4">.</span><span class="s1">from_clauses</span><span class="s4">[:</span><span class="s1">replace_from_obj_index</span><span class="s4">]</span>
                    <span class="s4">+ (</span>
                        <span class="s1">Join</span><span class="s4">(</span>
                            <span class="s1">left_clause</span><span class="s4">,</span>
                            <span class="s1">right</span><span class="s4">,</span>
                            <span class="s1">onclause</span><span class="s4">,</span>
                            <span class="s1">isouter</span><span class="s4">=</span><span class="s1">isouter</span><span class="s4">,</span>
                            <span class="s1">full</span><span class="s4">=</span><span class="s1">full</span><span class="s4">,</span>
                        <span class="s4">),</span>
                    <span class="s4">)</span>
                    <span class="s4">+ </span><span class="s1">self</span><span class="s4">.</span><span class="s1">from_clauses</span><span class="s4">[</span><span class="s1">replace_from_obj_index </span><span class="s4">+ </span><span class="s6">1 </span><span class="s4">:]</span>
                <span class="s4">)</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s3">assert </span><span class="s1">left </span><span class="s3">is not None</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">from_clauses </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">from_clauses </span><span class="s4">+ (</span>
                    <span class="s1">Join</span><span class="s4">(</span><span class="s1">left</span><span class="s4">, </span><span class="s1">right</span><span class="s4">, </span><span class="s1">onclause</span><span class="s4">, </span><span class="s1">isouter</span><span class="s4">=</span><span class="s1">isouter</span><span class="s4">, </span><span class="s1">full</span><span class="s4">=</span><span class="s1">full</span><span class="s4">),</span>
                <span class="s4">)</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">preload_module</span><span class="s4">(</span><span class="s5">&quot;sqlalchemy.sql.util&quot;</span><span class="s4">)</span>
    <span class="s3">def </span><span class="s1">_join_determine_implicit_left_side</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">raw_columns</span><span class="s4">: </span><span class="s1">List</span><span class="s4">[</span><span class="s1">_ColumnsClauseElement</span><span class="s4">],</span>
        <span class="s1">left</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">FromClause</span><span class="s4">],</span>
        <span class="s1">right</span><span class="s4">: </span><span class="s1">_JoinTargetElement</span><span class="s4">,</span>
        <span class="s1">onclause</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]],</span>
    <span class="s4">) </span><span class="s1">-&gt; Tuple</span><span class="s4">[</span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">FromClause</span><span class="s4">], </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">int</span><span class="s4">]]:</span>
        <span class="s2">&quot;&quot;&quot;When join conditions don't express the left side explicitly, 
        determine if an existing FROM or entity in this query 
        can serve as the left hand side. 
 
        &quot;&quot;&quot;</span>

        <span class="s1">sql_util </span><span class="s4">= </span><span class="s1">util</span><span class="s4">.</span><span class="s1">preloaded</span><span class="s4">.</span><span class="s1">sql_util</span>

        <span class="s1">replace_from_obj_index</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">int</span><span class="s4">] = </span><span class="s3">None</span>

        <span class="s1">from_clauses </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">from_clauses</span>

        <span class="s3">if </span><span class="s1">from_clauses</span><span class="s4">:</span>
            <span class="s1">indexes</span><span class="s4">: </span><span class="s1">List</span><span class="s4">[</span><span class="s1">int</span><span class="s4">] = </span><span class="s1">sql_util</span><span class="s4">.</span><span class="s1">find_left_clause_to_join_from</span><span class="s4">(</span>
                <span class="s1">from_clauses</span><span class="s4">, </span><span class="s1">right</span><span class="s4">, </span><span class="s1">onclause</span>
            <span class="s4">)</span>

            <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">indexes</span><span class="s4">) == </span><span class="s6">1</span><span class="s4">:</span>
                <span class="s1">replace_from_obj_index </span><span class="s4">= </span><span class="s1">indexes</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]</span>
                <span class="s1">left </span><span class="s4">= </span><span class="s1">from_clauses</span><span class="s4">[</span><span class="s1">replace_from_obj_index</span><span class="s4">]</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">potential </span><span class="s4">= {}</span>
            <span class="s1">statement </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">statement</span>

            <span class="s3">for </span><span class="s1">from_clause </span><span class="s3">in </span><span class="s1">itertools</span><span class="s4">.</span><span class="s1">chain</span><span class="s4">(</span>
                <span class="s1">itertools</span><span class="s4">.</span><span class="s1">chain</span><span class="s4">.</span><span class="s1">from_iterable</span><span class="s4">(</span>
                    <span class="s4">[</span><span class="s1">element</span><span class="s4">.</span><span class="s1">_from_objects </span><span class="s3">for </span><span class="s1">element </span><span class="s3">in </span><span class="s1">raw_columns</span><span class="s4">]</span>
                <span class="s4">),</span>
                <span class="s1">itertools</span><span class="s4">.</span><span class="s1">chain</span><span class="s4">.</span><span class="s1">from_iterable</span><span class="s4">(</span>
                    <span class="s4">[</span>
                        <span class="s1">element</span><span class="s4">.</span><span class="s1">_from_objects</span>
                        <span class="s3">for </span><span class="s1">element </span><span class="s3">in </span><span class="s1">statement</span><span class="s4">.</span><span class="s1">_where_criteria</span>
                    <span class="s4">]</span>
                <span class="s4">),</span>
            <span class="s4">):</span>
                <span class="s1">potential</span><span class="s4">[</span><span class="s1">from_clause</span><span class="s4">] = ()</span>

            <span class="s1">all_clauses </span><span class="s4">= </span><span class="s1">list</span><span class="s4">(</span><span class="s1">potential</span><span class="s4">.</span><span class="s1">keys</span><span class="s4">())</span>
            <span class="s1">indexes </span><span class="s4">= </span><span class="s1">sql_util</span><span class="s4">.</span><span class="s1">find_left_clause_to_join_from</span><span class="s4">(</span>
                <span class="s1">all_clauses</span><span class="s4">, </span><span class="s1">right</span><span class="s4">, </span><span class="s1">onclause</span>
            <span class="s4">)</span>

            <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">indexes</span><span class="s4">) == </span><span class="s6">1</span><span class="s4">:</span>
                <span class="s1">left </span><span class="s4">= </span><span class="s1">all_clauses</span><span class="s4">[</span><span class="s1">indexes</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]]</span>

        <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">indexes</span><span class="s4">) &gt; </span><span class="s6">1</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">exc</span><span class="s4">.</span><span class="s1">InvalidRequestError</span><span class="s4">(</span>
                <span class="s5">&quot;Can't determine which FROM clause to join &quot;</span>
                <span class="s5">&quot;from, there are multiple FROMS which can &quot;</span>
                <span class="s5">&quot;join to this entity. Please use the .select_from() &quot;</span>
                <span class="s5">&quot;method to establish an explicit left side, as well as &quot;</span>
                <span class="s5">&quot;providing an explicit ON clause if not present already to &quot;</span>
                <span class="s5">&quot;help resolve the ambiguity.&quot;</span>
            <span class="s4">)</span>
        <span class="s3">elif not </span><span class="s1">indexes</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">exc</span><span class="s4">.</span><span class="s1">InvalidRequestError</span><span class="s4">(</span>
                <span class="s5">&quot;Don't know how to join to %r. &quot;</span>
                <span class="s5">&quot;Please use the .select_from() &quot;</span>
                <span class="s5">&quot;method to establish an explicit left side, as well as &quot;</span>
                <span class="s5">&quot;providing an explicit ON clause if not present already to &quot;</span>
                <span class="s5">&quot;help resolve the ambiguity.&quot; </span><span class="s4">% (</span><span class="s1">right</span><span class="s4">,)</span>
            <span class="s4">)</span>
        <span class="s3">return </span><span class="s1">left</span><span class="s4">, </span><span class="s1">replace_from_obj_index</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">preload_module</span><span class="s4">(</span><span class="s5">&quot;sqlalchemy.sql.util&quot;</span><span class="s4">)</span>
    <span class="s3">def </span><span class="s1">_join_place_explicit_left_side</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">left</span><span class="s4">: </span><span class="s1">FromClause</span>
    <span class="s4">) </span><span class="s1">-&gt; Optional</span><span class="s4">[</span><span class="s1">int</span><span class="s4">]:</span>
        <span class="s1">replace_from_obj_index</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">int</span><span class="s4">] = </span><span class="s3">None</span>

        <span class="s1">sql_util </span><span class="s4">= </span><span class="s1">util</span><span class="s4">.</span><span class="s1">preloaded</span><span class="s4">.</span><span class="s1">sql_util</span>

        <span class="s1">from_clauses </span><span class="s4">= </span><span class="s1">list</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">statement</span><span class="s4">.</span><span class="s1">_iterate_from_elements</span><span class="s4">())</span>

        <span class="s3">if </span><span class="s1">from_clauses</span><span class="s4">:</span>
            <span class="s1">indexes</span><span class="s4">: </span><span class="s1">List</span><span class="s4">[</span><span class="s1">int</span><span class="s4">] = </span><span class="s1">sql_util</span><span class="s4">.</span><span class="s1">find_left_clause_that_matches_given</span><span class="s4">(</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">from_clauses</span><span class="s4">, </span><span class="s1">left</span>
            <span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">indexes </span><span class="s4">= []</span>

        <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">indexes</span><span class="s4">) &gt; </span><span class="s6">1</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">exc</span><span class="s4">.</span><span class="s1">InvalidRequestError</span><span class="s4">(</span>
                <span class="s5">&quot;Can't identify which entity in which to assign the &quot;</span>
                <span class="s5">&quot;left side of this join.   Please use a more specific &quot;</span>
                <span class="s5">&quot;ON clause.&quot;</span>
            <span class="s4">)</span>

        <span class="s0"># have an index, means the left side is already present in</span>
        <span class="s0"># an existing FROM in the self._from_obj tuple</span>
        <span class="s3">if </span><span class="s1">indexes</span><span class="s4">:</span>
            <span class="s1">replace_from_obj_index </span><span class="s4">= </span><span class="s1">indexes</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]</span>

        <span class="s0"># no index, means we need to add a new element to the</span>
        <span class="s0"># self._from_obj tuple</span>

        <span class="s3">return </span><span class="s1">replace_from_obj_index</span>


<span class="s3">class </span><span class="s1">_SelectFromElements</span><span class="s4">:</span>
    <span class="s1">__slots__ </span><span class="s4">= ()</span>

    <span class="s1">_raw_columns</span><span class="s4">: </span><span class="s1">List</span><span class="s4">[</span><span class="s1">_ColumnsClauseElement</span><span class="s4">]</span>
    <span class="s1">_where_criteria</span><span class="s4">: </span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">], ...]</span>
    <span class="s1">_from_obj</span><span class="s4">: </span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">FromClause</span><span class="s4">, ...]</span>

    <span class="s3">def </span><span class="s1">_iterate_from_elements</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Iterator</span><span class="s4">[</span><span class="s1">FromClause</span><span class="s4">]:</span>
        <span class="s0"># note this does not include elements</span>
        <span class="s0"># in _setup_joins</span>

        <span class="s1">seen </span><span class="s4">= </span><span class="s1">set</span><span class="s4">()</span>
        <span class="s3">for </span><span class="s1">element </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_raw_columns</span><span class="s4">:</span>
            <span class="s3">for </span><span class="s1">fr </span><span class="s3">in </span><span class="s1">element</span><span class="s4">.</span><span class="s1">_from_objects</span><span class="s4">:</span>
                <span class="s3">if </span><span class="s1">fr </span><span class="s3">in </span><span class="s1">seen</span><span class="s4">:</span>
                    <span class="s3">continue</span>
                <span class="s1">seen</span><span class="s4">.</span><span class="s1">add</span><span class="s4">(</span><span class="s1">fr</span><span class="s4">)</span>
                <span class="s3">yield </span><span class="s1">fr</span>
        <span class="s3">for </span><span class="s1">element </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_where_criteria</span><span class="s4">:</span>
            <span class="s3">for </span><span class="s1">fr </span><span class="s3">in </span><span class="s1">element</span><span class="s4">.</span><span class="s1">_from_objects</span><span class="s4">:</span>
                <span class="s3">if </span><span class="s1">fr </span><span class="s3">in </span><span class="s1">seen</span><span class="s4">:</span>
                    <span class="s3">continue</span>
                <span class="s1">seen</span><span class="s4">.</span><span class="s1">add</span><span class="s4">(</span><span class="s1">fr</span><span class="s4">)</span>
                <span class="s3">yield </span><span class="s1">fr</span>
        <span class="s3">for </span><span class="s1">element </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_from_obj</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">element </span><span class="s3">in </span><span class="s1">seen</span><span class="s4">:</span>
                <span class="s3">continue</span>
            <span class="s1">seen</span><span class="s4">.</span><span class="s1">add</span><span class="s4">(</span><span class="s1">element</span><span class="s4">)</span>
            <span class="s3">yield </span><span class="s1">element</span>


<span class="s3">class </span><span class="s1">_MemoizedSelectEntities</span><span class="s4">(</span>
    <span class="s1">cache_key</span><span class="s4">.</span><span class="s1">HasCacheKey</span><span class="s4">, </span><span class="s1">traversals</span><span class="s4">.</span><span class="s1">HasCopyInternals</span><span class="s4">, </span><span class="s1">visitors</span><span class="s4">.</span><span class="s1">Traversible</span>
<span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;represents partial state from a Select object, for the case 
    where Select.columns() has redefined the set of columns/entities the 
    statement will be SELECTing from.  This object represents 
    the entities from the SELECT before that transformation was applied, 
    so that transformations that were made in terms of the SELECT at that 
    time, such as join() as well as options(), can access the correct context. 
 
    In previous SQLAlchemy versions, this wasn't needed because these 
    constructs calculated everything up front, like when you called join() 
    or options(), it did everything to figure out how that would translate 
    into specific SQL constructs that would be ready to send directly to the 
    SQL compiler when needed.  But as of 
    1.4, all of that stuff is done in the compilation phase, during the 
    &quot;compile state&quot; portion of the process, so that the work can all be 
    cached.  So it needs to be able to resolve joins/options2 based on what 
    the list of entities was when those methods were called. 
 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;memoized_select_entities&quot;</span>

    <span class="s1">_traverse_internals</span><span class="s4">: </span><span class="s1">_TraverseInternalsType </span><span class="s4">= [</span>
        <span class="s4">(</span><span class="s5">&quot;_raw_columns&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_clauseelement_list</span><span class="s4">),</span>
        <span class="s4">(</span><span class="s5">&quot;_setup_joins&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_setup_join_tuple</span><span class="s4">),</span>
        <span class="s4">(</span><span class="s5">&quot;_with_options&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_executable_options</span><span class="s4">),</span>
    <span class="s4">]</span>

    <span class="s1">_is_clone_of</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">ClauseElement</span><span class="s4">]</span>
    <span class="s1">_raw_columns</span><span class="s4">: </span><span class="s1">List</span><span class="s4">[</span><span class="s1">_ColumnsClauseElement</span><span class="s4">]</span>
    <span class="s1">_setup_joins</span><span class="s4">: </span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">_SetupJoinsElement</span><span class="s4">, ...]</span>
    <span class="s1">_with_options</span><span class="s4">: </span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">ExecutableOption</span><span class="s4">, ...]</span>

    <span class="s1">_annotations </span><span class="s4">= </span><span class="s1">util</span><span class="s4">.</span><span class="s1">EMPTY_DICT</span>

    <span class="s3">def </span><span class="s1">_clone</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s1">c </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">__class__</span><span class="s4">.</span><span class="s1">__new__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">__class__</span><span class="s4">)</span>
        <span class="s1">c</span><span class="s4">.</span><span class="s1">__dict__ </span><span class="s4">= {</span><span class="s1">k</span><span class="s4">: </span><span class="s1">v </span><span class="s3">for </span><span class="s1">k</span><span class="s4">, </span><span class="s1">v </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">__dict__</span><span class="s4">.</span><span class="s1">items</span><span class="s4">()}</span>

        <span class="s1">c</span><span class="s4">.</span><span class="s1">_is_clone_of </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">__dict__</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s5">&quot;_is_clone_of&quot;</span><span class="s4">, </span><span class="s1">self</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">c</span>

    <span class="s4">@</span><span class="s1">classmethod</span>
    <span class="s3">def </span><span class="s1">_generate_for_statement</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">, </span><span class="s1">select_stmt</span><span class="s4">: </span><span class="s1">Select</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">select_stmt</span><span class="s4">.</span><span class="s1">_setup_joins </span><span class="s3">or </span><span class="s1">select_stmt</span><span class="s4">.</span><span class="s1">_with_options</span><span class="s4">:</span>
            <span class="s1">self </span><span class="s4">= </span><span class="s1">_MemoizedSelectEntities</span><span class="s4">()</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_raw_columns </span><span class="s4">= </span><span class="s1">select_stmt</span><span class="s4">.</span><span class="s1">_raw_columns</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_setup_joins </span><span class="s4">= </span><span class="s1">select_stmt</span><span class="s4">.</span><span class="s1">_setup_joins</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_with_options </span><span class="s4">= </span><span class="s1">select_stmt</span><span class="s4">.</span><span class="s1">_with_options</span>

            <span class="s1">select_stmt</span><span class="s4">.</span><span class="s1">_memoized_select_entities </span><span class="s4">+= (</span><span class="s1">self</span><span class="s4">,)</span>
            <span class="s1">select_stmt</span><span class="s4">.</span><span class="s1">_raw_columns </span><span class="s4">= []</span>
            <span class="s1">select_stmt</span><span class="s4">.</span><span class="s1">_setup_joins </span><span class="s4">= </span><span class="s1">select_stmt</span><span class="s4">.</span><span class="s1">_with_options </span><span class="s4">= ()</span>


<span class="s3">class </span><span class="s1">Select</span><span class="s4">(</span>
    <span class="s1">HasPrefixes</span><span class="s4">,</span>
    <span class="s1">HasSuffixes</span><span class="s4">,</span>
    <span class="s1">HasHints</span><span class="s4">,</span>
    <span class="s1">HasCompileState</span><span class="s4">,</span>
    <span class="s1">_SelectFromElements</span><span class="s4">,</span>
    <span class="s1">GenerativeSelect</span><span class="s4">,</span>
    <span class="s1">TypedReturnsRows</span><span class="s4">[</span><span class="s1">_TP</span><span class="s4">],</span>
<span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Represents a ``SELECT`` statement. 
 
    The :class:`_sql.Select` object is normally constructed using the 
    :func:`_sql.select` function.  See that function for details. 
 
    .. seealso:: 
 
        :func:`_sql.select` 
 
        :ref:`tutorial_selecting_data` - in the 2.0 tutorial 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;select&quot;</span>

    <span class="s1">_setup_joins</span><span class="s4">: </span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">_SetupJoinsElement</span><span class="s4">, ...] = ()</span>
    <span class="s1">_memoized_select_entities</span><span class="s4">: </span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">TODO_Any</span><span class="s4">, ...] = ()</span>

    <span class="s1">_raw_columns</span><span class="s4">: </span><span class="s1">List</span><span class="s4">[</span><span class="s1">_ColumnsClauseElement</span><span class="s4">]</span>

    <span class="s1">_distinct</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span>
    <span class="s1">_distinct_on</span><span class="s4">: </span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">], ...] = ()</span>
    <span class="s1">_correlate</span><span class="s4">: </span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">FromClause</span><span class="s4">, ...] = ()</span>
    <span class="s1">_correlate_except</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">FromClause</span><span class="s4">, ...]] = </span><span class="s3">None</span>
    <span class="s1">_where_criteria</span><span class="s4">: </span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">], ...] = ()</span>
    <span class="s1">_having_criteria</span><span class="s4">: </span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">], ...] = ()</span>
    <span class="s1">_from_obj</span><span class="s4">: </span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">FromClause</span><span class="s4">, ...] = ()</span>
    <span class="s1">_auto_correlate </span><span class="s4">= </span><span class="s3">True</span>
    <span class="s1">_is_select_statement </span><span class="s4">= </span><span class="s3">True</span>
    <span class="s1">_compile_options</span><span class="s4">: </span><span class="s1">CacheableOptions </span><span class="s4">= (</span>
        <span class="s1">SelectState</span><span class="s4">.</span><span class="s1">default_select_compile_options</span>
    <span class="s4">)</span>

    <span class="s1">_traverse_internals</span><span class="s4">: </span><span class="s1">_TraverseInternalsType </span><span class="s4">= (</span>
        <span class="s4">[</span>
            <span class="s4">(</span><span class="s5">&quot;_raw_columns&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_clauseelement_list</span><span class="s4">),</span>
            <span class="s4">(</span>
                <span class="s5">&quot;_memoized_select_entities&quot;</span><span class="s4">,</span>
                <span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_memoized_select_entities</span><span class="s4">,</span>
            <span class="s4">),</span>
            <span class="s4">(</span><span class="s5">&quot;_from_obj&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_clauseelement_list</span><span class="s4">),</span>
            <span class="s4">(</span><span class="s5">&quot;_where_criteria&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_clauseelement_tuple</span><span class="s4">),</span>
            <span class="s4">(</span><span class="s5">&quot;_having_criteria&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_clauseelement_tuple</span><span class="s4">),</span>
            <span class="s4">(</span><span class="s5">&quot;_order_by_clauses&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_clauseelement_tuple</span><span class="s4">),</span>
            <span class="s4">(</span><span class="s5">&quot;_group_by_clauses&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_clauseelement_tuple</span><span class="s4">),</span>
            <span class="s4">(</span><span class="s5">&quot;_setup_joins&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_setup_join_tuple</span><span class="s4">),</span>
            <span class="s4">(</span><span class="s5">&quot;_correlate&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_clauseelement_tuple</span><span class="s4">),</span>
            <span class="s4">(</span><span class="s5">&quot;_correlate_except&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_clauseelement_tuple</span><span class="s4">),</span>
            <span class="s4">(</span><span class="s5">&quot;_limit_clause&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_clauseelement</span><span class="s4">),</span>
            <span class="s4">(</span><span class="s5">&quot;_offset_clause&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_clauseelement</span><span class="s4">),</span>
            <span class="s4">(</span><span class="s5">&quot;_fetch_clause&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_clauseelement</span><span class="s4">),</span>
            <span class="s4">(</span><span class="s5">&quot;_fetch_clause_options&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_plain_dict</span><span class="s4">),</span>
            <span class="s4">(</span><span class="s5">&quot;_for_update_arg&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_clauseelement</span><span class="s4">),</span>
            <span class="s4">(</span><span class="s5">&quot;_distinct&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_boolean</span><span class="s4">),</span>
            <span class="s4">(</span><span class="s5">&quot;_distinct_on&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_clauseelement_tuple</span><span class="s4">),</span>
            <span class="s4">(</span><span class="s5">&quot;_label_style&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_plain_obj</span><span class="s4">),</span>
        <span class="s4">]</span>
        <span class="s4">+ </span><span class="s1">HasCTE</span><span class="s4">.</span><span class="s1">_has_ctes_traverse_internals</span>
        <span class="s4">+ </span><span class="s1">HasPrefixes</span><span class="s4">.</span><span class="s1">_has_prefixes_traverse_internals</span>
        <span class="s4">+ </span><span class="s1">HasSuffixes</span><span class="s4">.</span><span class="s1">_has_suffixes_traverse_internals</span>
        <span class="s4">+ </span><span class="s1">HasHints</span><span class="s4">.</span><span class="s1">_has_hints_traverse_internals</span>
        <span class="s4">+ </span><span class="s1">SupportsCloneAnnotations</span><span class="s4">.</span><span class="s1">_clone_annotations_traverse_internals</span>
        <span class="s4">+ </span><span class="s1">Executable</span><span class="s4">.</span><span class="s1">_executable_traverse_internals</span>
    <span class="s4">)</span>

    <span class="s1">_cache_key_traversal</span><span class="s4">: </span><span class="s1">_CacheKeyTraversalType </span><span class="s4">= </span><span class="s1">_traverse_internals </span><span class="s4">+ [</span>
        <span class="s4">(</span><span class="s5">&quot;_compile_options&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_has_cache_key</span><span class="s4">)</span>
    <span class="s4">]</span>

    <span class="s1">_compile_state_factory</span><span class="s4">: </span><span class="s1">Type</span><span class="s4">[</span><span class="s1">SelectState</span><span class="s4">]</span>

    <span class="s4">@</span><span class="s1">classmethod</span>
    <span class="s3">def </span><span class="s1">_create_raw_select</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; Select</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;Create a :class:`.Select` using raw ``__new__`` with no coercions. 
 
        Used internally to build up :class:`.Select` constructs with 
        pre-established state. 
 
        &quot;&quot;&quot;</span>

        <span class="s1">stmt </span><span class="s4">= </span><span class="s1">Select</span><span class="s4">.</span><span class="s1">__new__</span><span class="s4">(</span><span class="s1">Select</span><span class="s4">)</span>
        <span class="s1">stmt</span><span class="s4">.</span><span class="s1">__dict__</span><span class="s4">.</span><span class="s1">update</span><span class="s4">(</span><span class="s1">kw</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">stmt</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, *</span><span class="s1">entities</span><span class="s4">: </span><span class="s1">_ColumnsClauseArgument</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]):</span>
        <span class="s2">r&quot;&quot;&quot;Construct a new :class:`_expression.Select`. 
 
        The public constructor for :class:`_expression.Select` is the 
        :func:`_sql.select` function. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_raw_columns </span><span class="s4">= [</span>
            <span class="s1">coercions</span><span class="s4">.</span><span class="s1">expect</span><span class="s4">(</span>
                <span class="s1">roles</span><span class="s4">.</span><span class="s1">ColumnsClauseRole</span><span class="s4">, </span><span class="s1">ent</span><span class="s4">, </span><span class="s1">apply_propagate_attrs</span><span class="s4">=</span><span class="s1">self</span>
            <span class="s4">)</span>
            <span class="s3">for </span><span class="s1">ent </span><span class="s3">in </span><span class="s1">entities</span>
        <span class="s4">]</span>

        <span class="s1">GenerativeSelect</span><span class="s4">.</span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_scalar_type</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; TypeEngine</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]:</span>
        <span class="s3">if not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_raw_columns</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">NULLTYPE</span>
        <span class="s1">elem </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_raw_columns</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]</span>
        <span class="s1">cols </span><span class="s4">= </span><span class="s1">list</span><span class="s4">(</span><span class="s1">elem</span><span class="s4">.</span><span class="s1">_select_iterable</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">cols</span><span class="s4">[</span><span class="s6">0</span><span class="s4">].</span><span class="s1">type</span>

    <span class="s3">def </span><span class="s1">filter</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, *</span><span class="s1">criteria</span><span class="s4">: </span><span class="s1">_ColumnExpressionArgument</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">]) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;A synonym for the :meth:`_sql.Select.where` method.&quot;&quot;&quot;</span>

        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">where</span><span class="s4">(*</span><span class="s1">criteria</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_filter_by_zero</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; Union</span><span class="s4">[</span>
        <span class="s1">FromClause</span><span class="s4">, </span><span class="s1">_JoinTargetProtocol</span><span class="s4">, </span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">], </span><span class="s1">TextClause</span>
    <span class="s4">]:</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_setup_joins</span><span class="s4">:</span>
            <span class="s1">meth </span><span class="s4">= </span><span class="s1">SelectState</span><span class="s4">.</span><span class="s1">get_plugin_class</span><span class="s4">(</span>
                <span class="s1">self</span>
            <span class="s4">).</span><span class="s1">determine_last_joined_entity</span>
            <span class="s1">_last_joined_entity </span><span class="s4">= </span><span class="s1">meth</span><span class="s4">(</span><span class="s1">self</span><span class="s4">)</span>
            <span class="s3">if </span><span class="s1">_last_joined_entity </span><span class="s3">is not None</span><span class="s4">:</span>
                <span class="s3">return </span><span class="s1">_last_joined_entity</span>

        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_from_obj</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_from_obj</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]</span>

        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_raw_columns</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]</span>

    <span class="s3">if </span><span class="s1">TYPE_CHECKING</span><span class="s4">:</span>

        <span class="s4">@</span><span class="s1">overload</span>
        <span class="s3">def </span><span class="s1">scalar_subquery</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">: </span><span class="s1">Select</span><span class="s4">[</span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">_MAYBE_ENTITY</span><span class="s4">]],</span>
        <span class="s4">) </span><span class="s1">-&gt; ScalarSelect</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]: ...</span>

        <span class="s4">@</span><span class="s1">overload</span>
        <span class="s3">def </span><span class="s1">scalar_subquery</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">: </span><span class="s1">Select</span><span class="s4">[</span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">_NOT_ENTITY</span><span class="s4">]],</span>
        <span class="s4">) </span><span class="s1">-&gt; ScalarSelect</span><span class="s4">[</span><span class="s1">_NOT_ENTITY</span><span class="s4">]: ...</span>

        <span class="s4">@</span><span class="s1">overload</span>
        <span class="s3">def </span><span class="s1">scalar_subquery</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; ScalarSelect</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]: ...</span>

        <span class="s3">def </span><span class="s1">scalar_subquery</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; ScalarSelect</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]: ...</span>

    <span class="s3">def </span><span class="s1">filter_by</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, **</span><span class="s1">kwargs</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s2">r&quot;&quot;&quot;apply the given filtering criterion as a WHERE clause 
        to this select. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">from_entity </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_filter_by_zero</span><span class="s4">()</span>

        <span class="s1">clauses </span><span class="s4">= [</span>
            <span class="s1">_entity_namespace_key</span><span class="s4">(</span><span class="s1">from_entity</span><span class="s4">, </span><span class="s1">key</span><span class="s4">) == </span><span class="s1">value</span>
            <span class="s3">for </span><span class="s1">key</span><span class="s4">, </span><span class="s1">value </span><span class="s3">in </span><span class="s1">kwargs</span><span class="s4">.</span><span class="s1">items</span><span class="s4">()</span>
        <span class="s4">]</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">filter</span><span class="s4">(*</span><span class="s1">clauses</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">column_descriptions</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Any</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Return a :term:`plugin-enabled` 'column descriptions' structure 
        referring to the columns which are SELECTed by this statement. 
 
        This attribute is generally useful when using the ORM, as an 
        extended structure which includes information about mapped 
        entities is returned.  The section :ref:`queryguide_inspection` 
        contains more background. 
 
        For a Core-only statement, the structure returned by this accessor 
        is derived from the same objects that are returned by the 
        :attr:`.Select.selected_columns` accessor, formatted as a list of 
        dictionaries which contain the keys ``name``, ``type`` and ``expr``, 
        which indicate the column expressions to be selected:: 
 
            &gt;&gt;&gt; stmt = select(user_table) 
            &gt;&gt;&gt; stmt.column_descriptions 
            [ 
                { 
                    'name': 'id', 
                    'type': Integer(), 
                    'expr': Column('id', Integer(), ...)}, 
                { 
                    'name': 'name', 
                    'type': String(length=30), 
                    'expr': Column('name', String(length=30), ...)} 
            ] 
 
        .. versionchanged:: 1.4.33 The :attr:`.Select.column_descriptions` 
           attribute returns a structure for a Core-only set of entities, 
           not just ORM-only entities. 
 
        .. seealso:: 
 
            :attr:`.UpdateBase.entity_description` - entity information for 
            an :func:`.insert`, :func:`.update`, or :func:`.delete` 
 
            :ref:`queryguide_inspection` - ORM background 
 
        &quot;&quot;&quot;</span>
        <span class="s1">meth </span><span class="s4">= </span><span class="s1">SelectState</span><span class="s4">.</span><span class="s1">get_plugin_class</span><span class="s4">(</span><span class="s1">self</span><span class="s4">).</span><span class="s1">get_column_descriptions</span>
        <span class="s3">return </span><span class="s1">meth</span><span class="s4">(</span><span class="s1">self</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">from_statement</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">statement</span><span class="s4">: </span><span class="s1">roles</span><span class="s4">.</span><span class="s1">ReturnsRowsRole</span>
    <span class="s4">) </span><span class="s1">-&gt; ExecutableReturnsRows</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Apply the columns which this :class:`.Select` would select 
        onto another statement. 
 
        This operation is :term:`plugin-specific` and will raise a not 
        supported exception if this :class:`_sql.Select` does not select from 
        plugin-enabled entities. 
 
 
        The statement is typically either a :func:`_expression.text` or 
        :func:`_expression.select` construct, and should return the set of 
        columns appropriate to the entities represented by this 
        :class:`.Select`. 
 
        .. seealso:: 
 
            :ref:`orm_queryguide_selecting_text` - usage examples in the 
            ORM Querying Guide 
 
        &quot;&quot;&quot;</span>
        <span class="s1">meth </span><span class="s4">= </span><span class="s1">SelectState</span><span class="s4">.</span><span class="s1">get_plugin_class</span><span class="s4">(</span><span class="s1">self</span><span class="s4">).</span><span class="s1">from_statement</span>
        <span class="s3">return </span><span class="s1">meth</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">statement</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">_generative</span>
    <span class="s3">def </span><span class="s1">join</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">target</span><span class="s4">: </span><span class="s1">_JoinTargetArgument</span><span class="s4">,</span>
        <span class="s1">onclause</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_OnClauseArgument</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s4">*,</span>
        <span class="s1">isouter</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
        <span class="s1">full</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s5">r&quot;&quot;&quot;Create a SQL JOIN against this :class:`_expression.Select` 
        object's criterion 
        and apply generatively, returning the newly resulting 
        :class:`_expression.Select`. 
 
        E.g.:: 
 
            stmt = select(user_table).join(address_table, user_table.c.id == address_table.c.user_id) 
 
        The above statement generates SQL similar to:: 
 
            SELECT user.id, user.name FROM user JOIN address ON user.id = address.user_id 
 
        .. versionchanged:: 1.4 :meth:`_expression.Select.join` now creates 
           a :class:`_sql.Join` object between a :class:`_sql.FromClause` 
           source that is within the FROM clause of the existing SELECT, 
           and a given target :class:`_sql.FromClause`, and then adds 
           this :class:`_sql.Join` to the FROM clause of the newly generated 
           SELECT statement.    This is completely reworked from the behavior 
           in 1.3, which would instead create a subquery of the entire 
           :class:`_expression.Select` and then join that subquery to the 
           target. 
 
           This is a **backwards incompatible change** as the previous behavior 
           was mostly useless, producing an unnamed subquery rejected by 
           most databases in any case.   The new behavior is modeled after 
           that of the very successful :meth:`_orm.Query.join` method in the 
           ORM, in order to support the functionality of :class:`_orm.Query` 
           being available by using a :class:`_sql.Select` object with an 
           :class:`_orm.Session`. 
 
           See the notes for this change at :ref:`change_select_join`. 
 
 
        :param target: target table to join towards 
 
        :param onclause: ON clause of the join.  If omitted, an ON clause 
         is generated automatically based on the :class:`_schema.ForeignKey` 
         linkages between the two tables, if one can be unambiguously 
         determined, otherwise an error is raised. 
 
        :param isouter: if True, generate LEFT OUTER join.  Same as 
         :meth:`_expression.Select.outerjoin`. 
 
        :param full: if True, generate FULL OUTER join. 
 
        .. seealso:: 
 
            :ref:`tutorial_select_join` - in the :doc:`/tutorial/index` 
 
            :ref:`orm_queryguide_joins` - in the :ref:`queryguide_toplevel` 
 
            :meth:`_expression.Select.join_from` 
 
            :meth:`_expression.Select.outerjoin` 
 
        &quot;&quot;&quot;  </span><span class="s0"># noqa: E501</span>
        <span class="s1">join_target </span><span class="s4">= </span><span class="s1">coercions</span><span class="s4">.</span><span class="s1">expect</span><span class="s4">(</span>
            <span class="s1">roles</span><span class="s4">.</span><span class="s1">JoinTargetRole</span><span class="s4">, </span><span class="s1">target</span><span class="s4">, </span><span class="s1">apply_propagate_attrs</span><span class="s4">=</span><span class="s1">self</span>
        <span class="s4">)</span>
        <span class="s3">if </span><span class="s1">onclause </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s1">onclause_element </span><span class="s4">= </span><span class="s1">coercions</span><span class="s4">.</span><span class="s1">expect</span><span class="s4">(</span><span class="s1">roles</span><span class="s4">.</span><span class="s1">OnClauseRole</span><span class="s4">, </span><span class="s1">onclause</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">onclause_element </span><span class="s4">= </span><span class="s3">None</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">_setup_joins </span><span class="s4">+= (</span>
            <span class="s4">(</span>
                <span class="s1">join_target</span><span class="s4">,</span>
                <span class="s1">onclause_element</span><span class="s4">,</span>
                <span class="s3">None</span><span class="s4">,</span>
                <span class="s4">{</span><span class="s5">&quot;isouter&quot;</span><span class="s4">: </span><span class="s1">isouter</span><span class="s4">, </span><span class="s5">&quot;full&quot;</span><span class="s4">: </span><span class="s1">full</span><span class="s4">},</span>
            <span class="s4">),</span>
        <span class="s4">)</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">outerjoin_from</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">from_</span><span class="s4">: </span><span class="s1">_FromClauseArgument</span><span class="s4">,</span>
        <span class="s1">target</span><span class="s4">: </span><span class="s1">_JoinTargetArgument</span><span class="s4">,</span>
        <span class="s1">onclause</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_OnClauseArgument</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s4">*,</span>
        <span class="s1">full</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s2">r&quot;&quot;&quot;Create a SQL LEFT OUTER JOIN against this 
        :class:`_expression.Select` object's criterion and apply generatively, 
        returning the newly resulting :class:`_expression.Select`. 
 
        Usage is the same as that of :meth:`_selectable.Select.join_from`. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">join_from</span><span class="s4">(</span>
            <span class="s1">from_</span><span class="s4">, </span><span class="s1">target</span><span class="s4">, </span><span class="s1">onclause</span><span class="s4">=</span><span class="s1">onclause</span><span class="s4">, </span><span class="s1">isouter</span><span class="s4">=</span><span class="s3">True</span><span class="s4">, </span><span class="s1">full</span><span class="s4">=</span><span class="s1">full</span>
        <span class="s4">)</span>

    <span class="s4">@</span><span class="s1">_generative</span>
    <span class="s3">def </span><span class="s1">join_from</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">from_</span><span class="s4">: </span><span class="s1">_FromClauseArgument</span><span class="s4">,</span>
        <span class="s1">target</span><span class="s4">: </span><span class="s1">_JoinTargetArgument</span><span class="s4">,</span>
        <span class="s1">onclause</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_OnClauseArgument</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s4">*,</span>
        <span class="s1">isouter</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
        <span class="s1">full</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s5">r&quot;&quot;&quot;Create a SQL JOIN against this :class:`_expression.Select` 
        object's criterion 
        and apply generatively, returning the newly resulting 
        :class:`_expression.Select`. 
 
        E.g.:: 
 
            stmt = select(user_table, address_table).join_from( 
                user_table, address_table, user_table.c.id == address_table.c.user_id 
            ) 
 
        The above statement generates SQL similar to:: 
 
            SELECT user.id, user.name, address.id, address.email, address.user_id 
            FROM user JOIN address ON user.id = address.user_id 
 
        .. versionadded:: 1.4 
 
        :param from\_: the left side of the join, will be rendered in the 
         FROM clause and is roughly equivalent to using the 
         :meth:`.Select.select_from` method. 
 
        :param target: target table to join towards 
 
        :param onclause: ON clause of the join. 
 
        :param isouter: if True, generate LEFT OUTER join.  Same as 
         :meth:`_expression.Select.outerjoin`. 
 
        :param full: if True, generate FULL OUTER join. 
 
        .. seealso:: 
 
            :ref:`tutorial_select_join` - in the :doc:`/tutorial/index` 
 
            :ref:`orm_queryguide_joins` - in the :ref:`queryguide_toplevel` 
 
            :meth:`_expression.Select.join` 
 
        &quot;&quot;&quot;  </span><span class="s0"># noqa: E501</span>

        <span class="s0"># note the order of parsing from vs. target is important here, as we</span>
        <span class="s0"># are also deriving the source of the plugin (i.e. the subject mapper</span>
        <span class="s0"># in an ORM query) which should favor the &quot;from_&quot; over the &quot;target&quot;</span>

        <span class="s1">from_ </span><span class="s4">= </span><span class="s1">coercions</span><span class="s4">.</span><span class="s1">expect</span><span class="s4">(</span>
            <span class="s1">roles</span><span class="s4">.</span><span class="s1">FromClauseRole</span><span class="s4">, </span><span class="s1">from_</span><span class="s4">, </span><span class="s1">apply_propagate_attrs</span><span class="s4">=</span><span class="s1">self</span>
        <span class="s4">)</span>
        <span class="s1">join_target </span><span class="s4">= </span><span class="s1">coercions</span><span class="s4">.</span><span class="s1">expect</span><span class="s4">(</span>
            <span class="s1">roles</span><span class="s4">.</span><span class="s1">JoinTargetRole</span><span class="s4">, </span><span class="s1">target</span><span class="s4">, </span><span class="s1">apply_propagate_attrs</span><span class="s4">=</span><span class="s1">self</span>
        <span class="s4">)</span>
        <span class="s3">if </span><span class="s1">onclause </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s1">onclause_element </span><span class="s4">= </span><span class="s1">coercions</span><span class="s4">.</span><span class="s1">expect</span><span class="s4">(</span><span class="s1">roles</span><span class="s4">.</span><span class="s1">OnClauseRole</span><span class="s4">, </span><span class="s1">onclause</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">onclause_element </span><span class="s4">= </span><span class="s3">None</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">_setup_joins </span><span class="s4">+= (</span>
            <span class="s4">(</span>
                <span class="s1">join_target</span><span class="s4">,</span>
                <span class="s1">onclause_element</span><span class="s4">,</span>
                <span class="s1">from_</span><span class="s4">,</span>
                <span class="s4">{</span><span class="s5">&quot;isouter&quot;</span><span class="s4">: </span><span class="s1">isouter</span><span class="s4">, </span><span class="s5">&quot;full&quot;</span><span class="s4">: </span><span class="s1">full</span><span class="s4">},</span>
            <span class="s4">),</span>
        <span class="s4">)</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">outerjoin</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">target</span><span class="s4">: </span><span class="s1">_JoinTargetArgument</span><span class="s4">,</span>
        <span class="s1">onclause</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_OnClauseArgument</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s4">*,</span>
        <span class="s1">full</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Create a left outer join. 
 
        Parameters are the same as that of :meth:`_expression.Select.join`. 
 
        .. versionchanged:: 1.4 :meth:`_expression.Select.outerjoin` now 
           creates a :class:`_sql.Join` object between a 
           :class:`_sql.FromClause` source that is within the FROM clause of 
           the existing SELECT, and a given target :class:`_sql.FromClause`, 
           and then adds this :class:`_sql.Join` to the FROM clause of the 
           newly generated SELECT statement.    This is completely reworked 
           from the behavior in 1.3, which would instead create a subquery of 
           the entire 
           :class:`_expression.Select` and then join that subquery to the 
           target. 
 
           This is a **backwards incompatible change** as the previous behavior 
           was mostly useless, producing an unnamed subquery rejected by 
           most databases in any case.   The new behavior is modeled after 
           that of the very successful :meth:`_orm.Query.join` method in the 
           ORM, in order to support the functionality of :class:`_orm.Query` 
           being available by using a :class:`_sql.Select` object with an 
           :class:`_orm.Session`. 
 
           See the notes for this change at :ref:`change_select_join`. 
 
        .. seealso:: 
 
            :ref:`tutorial_select_join` - in the :doc:`/tutorial/index` 
 
            :ref:`orm_queryguide_joins` - in the :ref:`queryguide_toplevel` 
 
            :meth:`_expression.Select.join` 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span><span class="s1">target</span><span class="s4">, </span><span class="s1">onclause</span><span class="s4">=</span><span class="s1">onclause</span><span class="s4">, </span><span class="s1">isouter</span><span class="s4">=</span><span class="s3">True</span><span class="s4">, </span><span class="s1">full</span><span class="s4">=</span><span class="s1">full</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">get_final_froms</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Sequence</span><span class="s4">[</span><span class="s1">FromClause</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;Compute the final displayed list of :class:`_expression.FromClause` 
        elements. 
 
        This method will run through the full computation required to 
        determine what FROM elements will be displayed in the resulting 
        SELECT statement, including shadowing individual tables with 
        JOIN objects, as well as full computation for ORM use cases including 
        eager loading clauses. 
 
        For ORM use, this accessor returns the **post compilation** 
        list of FROM objects; this collection will include elements such as 
        eagerly loaded tables and joins.  The objects will **not** be 
        ORM enabled and not work as a replacement for the 
        :meth:`_sql.Select.select_froms` collection; additionally, the 
        method is not well performing for an ORM enabled statement as it 
        will incur the full ORM construction process. 
 
        To retrieve the FROM list that's implied by the &quot;columns&quot; collection 
        passed to the :class:`_sql.Select` originally, use the 
        :attr:`_sql.Select.columns_clause_froms` accessor. 
 
        To select from an alternative set of columns while maintaining the 
        FROM list, use the :meth:`_sql.Select.with_only_columns` method and 
        pass the 
        :paramref:`_sql.Select.with_only_columns.maintain_column_froms` 
        parameter. 
 
        .. versionadded:: 1.4.23 - the :meth:`_sql.Select.get_final_froms` 
           method replaces the previous :attr:`_sql.Select.froms` accessor, 
           which is deprecated. 
 
        .. seealso:: 
 
            :attr:`_sql.Select.columns_clause_froms` 
 
        &quot;&quot;&quot;</span>

        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_compile_state_factory</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s3">None</span><span class="s4">).</span><span class="s1">_get_display_froms</span><span class="s4">()</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">deprecated</span><span class="s4">(</span>
        <span class="s5">&quot;1.4.23&quot;</span><span class="s4">,</span>
        <span class="s5">&quot;The :attr:`_expression.Select.froms` attribute is moved to &quot;</span>
        <span class="s5">&quot;the :meth:`_expression.Select.get_final_froms` method.&quot;</span><span class="s4">,</span>
    <span class="s4">)</span>
    <span class="s3">def </span><span class="s1">froms</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Sequence</span><span class="s4">[</span><span class="s1">FromClause</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;Return the displayed list of :class:`_expression.FromClause` 
        elements. 
 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">get_final_froms</span><span class="s4">()</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">columns_clause_froms</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; List</span><span class="s4">[</span><span class="s1">FromClause</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;Return the set of :class:`_expression.FromClause` objects implied 
        by the columns clause of this SELECT statement. 
 
        .. versionadded:: 1.4.23 
 
        .. seealso:: 
 
            :attr:`_sql.Select.froms` - &quot;final&quot; FROM list taking the full 
            statement into account 
 
            :meth:`_sql.Select.with_only_columns` - makes use of this 
            collection to set up a new FROM list 
 
        &quot;&quot;&quot;</span>

        <span class="s3">return </span><span class="s1">SelectState</span><span class="s4">.</span><span class="s1">get_plugin_class</span><span class="s4">(</span><span class="s1">self</span><span class="s4">).</span><span class="s1">get_columns_clause_froms</span><span class="s4">(</span>
            <span class="s1">self</span>
        <span class="s4">)</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">inner_columns</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; _SelectIterable</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;An iterator of all :class:`_expression.ColumnElement` 
        expressions which would 
        be rendered into the columns clause of the resulting SELECT statement. 
 
        This method is legacy as of 1.4 and is superseded by the 
        :attr:`_expression.Select.exported_columns` collection. 
 
        &quot;&quot;&quot;</span>

        <span class="s3">return </span><span class="s1">iter</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_all_selected_columns</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">is_derived_from</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">fromclause</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">FromClause</span><span class="s4">]) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">fromclause </span><span class="s3">is not None and </span><span class="s1">self </span><span class="s3">in </span><span class="s1">fromclause</span><span class="s4">.</span><span class="s1">_cloned_set</span><span class="s4">:</span>
            <span class="s3">return True</span>

        <span class="s3">for </span><span class="s1">f </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_iterate_from_elements</span><span class="s4">():</span>
            <span class="s3">if </span><span class="s1">f</span><span class="s4">.</span><span class="s1">is_derived_from</span><span class="s4">(</span><span class="s1">fromclause</span><span class="s4">):</span>
                <span class="s3">return True</span>
        <span class="s3">return False</span>

    <span class="s3">def </span><span class="s1">_copy_internals</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">clone</span><span class="s4">: </span><span class="s1">_CloneCallableType </span><span class="s4">= </span><span class="s1">_clone</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span>
    <span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s0"># Select() object has been cloned and probably adapted by the</span>
        <span class="s0"># given clone function.  Apply the cloning function to internal</span>
        <span class="s0"># objects</span>

        <span class="s0"># 1. keep a dictionary of the froms we've cloned, and what</span>
        <span class="s0"># they've become.  This allows us to ensure the same cloned from</span>
        <span class="s0"># is used when other items such as columns are &quot;cloned&quot;</span>

        <span class="s1">all_the_froms </span><span class="s4">= </span><span class="s1">set</span><span class="s4">(</span>
            <span class="s1">itertools</span><span class="s4">.</span><span class="s1">chain</span><span class="s4">(</span>
                <span class="s1">_from_objects</span><span class="s4">(*</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_raw_columns</span><span class="s4">),</span>
                <span class="s1">_from_objects</span><span class="s4">(*</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_where_criteria</span><span class="s4">),</span>
                <span class="s1">_from_objects</span><span class="s4">(*[</span><span class="s1">elem</span><span class="s4">[</span><span class="s6">0</span><span class="s4">] </span><span class="s3">for </span><span class="s1">elem </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_setup_joins</span><span class="s4">]),</span>
            <span class="s4">)</span>
        <span class="s4">)</span>

        <span class="s0"># do a clone for the froms we've gathered.  what is important here</span>
        <span class="s0"># is if any of the things we are selecting from, like tables,</span>
        <span class="s0"># were converted into Join objects.   if so, these need to be</span>
        <span class="s0"># added to _from_obj explicitly, because otherwise they won't be</span>
        <span class="s0"># part of the new state, as they don't associate themselves with</span>
        <span class="s0"># their columns.</span>
        <span class="s1">new_froms </span><span class="s4">= {</span><span class="s1">f</span><span class="s4">: </span><span class="s1">clone</span><span class="s4">(</span><span class="s1">f</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">) </span><span class="s3">for </span><span class="s1">f </span><span class="s3">in </span><span class="s1">all_the_froms</span><span class="s4">}</span>

        <span class="s0"># 2. copy FROM collections, adding in joins that we've created.</span>
        <span class="s1">existing_from_obj </span><span class="s4">= [</span><span class="s1">clone</span><span class="s4">(</span><span class="s1">f</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">) </span><span class="s3">for </span><span class="s1">f </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_from_obj</span><span class="s4">]</span>
        <span class="s1">add_froms </span><span class="s4">= (</span>
            <span class="s4">{</span><span class="s1">f </span><span class="s3">for </span><span class="s1">f </span><span class="s3">in </span><span class="s1">new_froms</span><span class="s4">.</span><span class="s1">values</span><span class="s4">() </span><span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">f</span><span class="s4">, </span><span class="s1">Join</span><span class="s4">)}</span>
            <span class="s4">.</span><span class="s1">difference</span><span class="s4">(</span><span class="s1">all_the_froms</span><span class="s4">)</span>
            <span class="s4">.</span><span class="s1">difference</span><span class="s4">(</span><span class="s1">existing_from_obj</span><span class="s4">)</span>
        <span class="s4">)</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">_from_obj </span><span class="s4">= </span><span class="s1">tuple</span><span class="s4">(</span><span class="s1">existing_from_obj</span><span class="s4">) + </span><span class="s1">tuple</span><span class="s4">(</span><span class="s1">add_froms</span><span class="s4">)</span>

        <span class="s0"># 3. clone everything else, making sure we use columns</span>
        <span class="s0"># corresponding to the froms we just made.</span>
        <span class="s3">def </span><span class="s1">replace</span><span class="s4">(</span>
            <span class="s1">obj</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span><span class="s1">BinaryExpression</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">], </span><span class="s1">ColumnClause</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]],</span>
            <span class="s4">**</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
        <span class="s4">) </span><span class="s1">-&gt; Optional</span><span class="s4">[</span><span class="s1">KeyedColumnElement</span><span class="s4">[</span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]]:</span>
            <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">obj</span><span class="s4">, </span><span class="s1">ColumnClause</span><span class="s4">) </span><span class="s3">and </span><span class="s1">obj</span><span class="s4">.</span><span class="s1">table </span><span class="s3">in </span><span class="s1">new_froms</span><span class="s4">:</span>
                <span class="s1">newelem </span><span class="s4">= </span><span class="s1">new_froms</span><span class="s4">[</span><span class="s1">obj</span><span class="s4">.</span><span class="s1">table</span><span class="s4">].</span><span class="s1">corresponding_column</span><span class="s4">(</span><span class="s1">obj</span><span class="s4">)</span>
                <span class="s3">return </span><span class="s1">newelem</span>
            <span class="s3">return None</span>

        <span class="s1">kw</span><span class="s4">[</span><span class="s5">&quot;replace&quot;</span><span class="s4">] = </span><span class="s1">replace</span>

        <span class="s0"># copy everything else.   for table-ish things like correlate,</span>
        <span class="s0"># correlate_except, setup_joins, these clone normally.  For</span>
        <span class="s0"># column-expression oriented things like raw_columns, where_criteria,</span>
        <span class="s0"># order by, we get this from the new froms.</span>
        <span class="s1">super</span><span class="s4">().</span><span class="s1">_copy_internals</span><span class="s4">(</span><span class="s1">clone</span><span class="s4">=</span><span class="s1">clone</span><span class="s4">, </span><span class="s1">omit_attrs</span><span class="s4">=(</span><span class="s5">&quot;_from_obj&quot;</span><span class="s4">,), **</span><span class="s1">kw</span><span class="s4">)</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">_reset_memoizations</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">get_children</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; Iterable</span><span class="s4">[</span><span class="s1">ClauseElement</span><span class="s4">]:</span>
        <span class="s3">return </span><span class="s1">itertools</span><span class="s4">.</span><span class="s1">chain</span><span class="s4">(</span>
            <span class="s1">super</span><span class="s4">().</span><span class="s1">get_children</span><span class="s4">(</span>
                <span class="s1">omit_attrs</span><span class="s4">=(</span><span class="s5">&quot;_from_obj&quot;</span><span class="s4">, </span><span class="s5">&quot;_correlate&quot;</span><span class="s4">, </span><span class="s5">&quot;_correlate_except&quot;</span><span class="s4">),</span>
                <span class="s4">**</span><span class="s1">kw</span><span class="s4">,</span>
            <span class="s4">),</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_iterate_from_elements</span><span class="s4">(),</span>
        <span class="s4">)</span>

    <span class="s4">@</span><span class="s1">_generative</span>
    <span class="s3">def </span><span class="s1">add_columns</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, *</span><span class="s1">entities</span><span class="s4">: </span><span class="s1">_ColumnsClauseArgument</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]</span>
    <span class="s4">) </span><span class="s1">-&gt; Select</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]:</span>
        <span class="s2">r&quot;&quot;&quot;Return a new :func:`_expression.select` construct with 
        the given entities appended to its columns clause. 
 
        E.g.:: 
 
            my_select = my_select.add_columns(table.c.new_column) 
 
        The original expressions in the columns clause remain in place. 
        To replace the original expressions with new ones, see the method 
        :meth:`_expression.Select.with_only_columns`. 
 
        :param \*entities: column, table, or other entity expressions to be 
         added to the columns clause 
 
        .. seealso:: 
 
            :meth:`_expression.Select.with_only_columns` - replaces existing 
            expressions rather than appending. 
 
            :ref:`orm_queryguide_select_multiple_entities` - ORM-centric 
            example 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_reset_memoizations</span><span class="s4">()</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">_raw_columns </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_raw_columns </span><span class="s4">+ [</span>
            <span class="s1">coercions</span><span class="s4">.</span><span class="s1">expect</span><span class="s4">(</span>
                <span class="s1">roles</span><span class="s4">.</span><span class="s1">ColumnsClauseRole</span><span class="s4">, </span><span class="s1">column</span><span class="s4">, </span><span class="s1">apply_propagate_attrs</span><span class="s4">=</span><span class="s1">self</span>
            <span class="s4">)</span>
            <span class="s3">for </span><span class="s1">column </span><span class="s3">in </span><span class="s1">entities</span>
        <span class="s4">]</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">_set_entities</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">entities</span><span class="s4">: </span><span class="s1">Iterable</span><span class="s4">[</span><span class="s1">_ColumnsClauseArgument</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]</span>
    <span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_raw_columns </span><span class="s4">= [</span>
            <span class="s1">coercions</span><span class="s4">.</span><span class="s1">expect</span><span class="s4">(</span>
                <span class="s1">roles</span><span class="s4">.</span><span class="s1">ColumnsClauseRole</span><span class="s4">, </span><span class="s1">ent</span><span class="s4">, </span><span class="s1">apply_propagate_attrs</span><span class="s4">=</span><span class="s1">self</span>
            <span class="s4">)</span>
            <span class="s3">for </span><span class="s1">ent </span><span class="s3">in </span><span class="s1">util</span><span class="s4">.</span><span class="s1">to_list</span><span class="s4">(</span><span class="s1">entities</span><span class="s4">)</span>
        <span class="s4">]</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">deprecated</span><span class="s4">(</span>
        <span class="s5">&quot;1.4&quot;</span><span class="s4">,</span>
        <span class="s5">&quot;The :meth:`_expression.Select.column` method is deprecated and will &quot;</span>
        <span class="s5">&quot;be removed in a future release.  Please use &quot;</span>
        <span class="s5">&quot;:meth:`_expression.Select.add_columns`&quot;</span><span class="s4">,</span>
    <span class="s4">)</span>
    <span class="s3">def </span><span class="s1">column</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">column</span><span class="s4">: </span><span class="s1">_ColumnsClauseArgument</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]) </span><span class="s1">-&gt; Select</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;Return a new :func:`_expression.select` construct with 
        the given column expression added to its columns clause. 
 
        E.g.:: 
 
            my_select = my_select.column(table.c.new_column) 
 
        See the documentation for 
        :meth:`_expression.Select.with_only_columns` 
        for guidelines on adding /replacing the columns of a 
        :class:`_expression.Select` object. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">add_columns</span><span class="s4">(</span><span class="s1">column</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">preload_module</span><span class="s4">(</span><span class="s5">&quot;sqlalchemy.sql.util&quot;</span><span class="s4">)</span>
    <span class="s3">def </span><span class="s1">reduce_columns</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">only_synonyms</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">True</span><span class="s4">) </span><span class="s1">-&gt; Select</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;Return a new :func:`_expression.select` construct with redundantly 
        named, equivalently-valued columns removed from the columns clause. 
 
        &quot;Redundant&quot; here means two columns where one refers to the 
        other either based on foreign key, or via a simple equality 
        comparison in the WHERE clause of the statement.   The primary purpose 
        of this method is to automatically construct a select statement 
        with all uniquely-named columns, without the need to use 
        table-qualified labels as 
        :meth:`_expression.Select.set_label_style` 
        does. 
 
        When columns are omitted based on foreign key, the referred-to 
        column is the one that's kept.  When columns are omitted based on 
        WHERE equivalence, the first column in the columns clause is the 
        one that's kept. 
 
        :param only_synonyms: when True, limit the removal of columns 
         to those which have the same name as the equivalent.   Otherwise, 
         all columns that are equivalent to another are removed. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">woc</span><span class="s4">: </span><span class="s1">Select</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]</span>
        <span class="s1">woc </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">with_only_columns</span><span class="s4">(</span>
            <span class="s4">*</span><span class="s1">util</span><span class="s4">.</span><span class="s1">preloaded</span><span class="s4">.</span><span class="s1">sql_util</span><span class="s4">.</span><span class="s1">reduce_columns</span><span class="s4">(</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">_all_selected_columns</span><span class="s4">,</span>
                <span class="s1">only_synonyms</span><span class="s4">=</span><span class="s1">only_synonyms</span><span class="s4">,</span>
                <span class="s4">*(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_where_criteria </span><span class="s4">+ </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_from_obj</span><span class="s4">),</span>
            <span class="s4">)</span>
        <span class="s4">)</span>
        <span class="s3">return </span><span class="s1">woc</span>

    <span class="s0"># START OVERLOADED FUNCTIONS self.with_only_columns Select 1-8 &quot;, *, maintain_column_froms: bool =...&quot; # noqa: E501</span>

    <span class="s0"># code within this block is **programmatically,</span>
    <span class="s0"># statically generated** by tools/generate_tuple_map_overloads.py</span>

    <span class="s4">@</span><span class="s1">overload</span>
    <span class="s3">def </span><span class="s1">with_only_columns</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">__ent0</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T0</span><span class="s4">], *, </span><span class="s1">maintain_column_froms</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= ...</span>
    <span class="s4">) </span><span class="s1">-&gt; Select</span><span class="s4">[</span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">_T0</span><span class="s4">]]: ...</span>

    <span class="s4">@</span><span class="s1">overload</span>
    <span class="s3">def </span><span class="s1">with_only_columns</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">__ent0</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T0</span><span class="s4">],</span>
        <span class="s1">__ent1</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T1</span><span class="s4">],</span>
        <span class="s4">*,</span>
        <span class="s1">maintain_column_froms</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= ...,</span>
    <span class="s4">) </span><span class="s1">-&gt; Select</span><span class="s4">[</span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">_T0</span><span class="s4">, </span><span class="s1">_T1</span><span class="s4">]]: ...</span>

    <span class="s4">@</span><span class="s1">overload</span>
    <span class="s3">def </span><span class="s1">with_only_columns</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">__ent0</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T0</span><span class="s4">],</span>
        <span class="s1">__ent1</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T1</span><span class="s4">],</span>
        <span class="s1">__ent2</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T2</span><span class="s4">],</span>
        <span class="s4">*,</span>
        <span class="s1">maintain_column_froms</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= ...,</span>
    <span class="s4">) </span><span class="s1">-&gt; Select</span><span class="s4">[</span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">_T0</span><span class="s4">, </span><span class="s1">_T1</span><span class="s4">, </span><span class="s1">_T2</span><span class="s4">]]: ...</span>

    <span class="s4">@</span><span class="s1">overload</span>
    <span class="s3">def </span><span class="s1">with_only_columns</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">__ent0</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T0</span><span class="s4">],</span>
        <span class="s1">__ent1</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T1</span><span class="s4">],</span>
        <span class="s1">__ent2</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T2</span><span class="s4">],</span>
        <span class="s1">__ent3</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T3</span><span class="s4">],</span>
        <span class="s4">*,</span>
        <span class="s1">maintain_column_froms</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= ...,</span>
    <span class="s4">) </span><span class="s1">-&gt; Select</span><span class="s4">[</span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">_T0</span><span class="s4">, </span><span class="s1">_T1</span><span class="s4">, </span><span class="s1">_T2</span><span class="s4">, </span><span class="s1">_T3</span><span class="s4">]]: ...</span>

    <span class="s4">@</span><span class="s1">overload</span>
    <span class="s3">def </span><span class="s1">with_only_columns</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">__ent0</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T0</span><span class="s4">],</span>
        <span class="s1">__ent1</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T1</span><span class="s4">],</span>
        <span class="s1">__ent2</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T2</span><span class="s4">],</span>
        <span class="s1">__ent3</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T3</span><span class="s4">],</span>
        <span class="s1">__ent4</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T4</span><span class="s4">],</span>
        <span class="s4">*,</span>
        <span class="s1">maintain_column_froms</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= ...,</span>
    <span class="s4">) </span><span class="s1">-&gt; Select</span><span class="s4">[</span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">_T0</span><span class="s4">, </span><span class="s1">_T1</span><span class="s4">, </span><span class="s1">_T2</span><span class="s4">, </span><span class="s1">_T3</span><span class="s4">, </span><span class="s1">_T4</span><span class="s4">]]: ...</span>

    <span class="s4">@</span><span class="s1">overload</span>
    <span class="s3">def </span><span class="s1">with_only_columns</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">__ent0</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T0</span><span class="s4">],</span>
        <span class="s1">__ent1</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T1</span><span class="s4">],</span>
        <span class="s1">__ent2</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T2</span><span class="s4">],</span>
        <span class="s1">__ent3</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T3</span><span class="s4">],</span>
        <span class="s1">__ent4</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T4</span><span class="s4">],</span>
        <span class="s1">__ent5</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T5</span><span class="s4">],</span>
        <span class="s4">*,</span>
        <span class="s1">maintain_column_froms</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= ...,</span>
    <span class="s4">) </span><span class="s1">-&gt; Select</span><span class="s4">[</span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">_T0</span><span class="s4">, </span><span class="s1">_T1</span><span class="s4">, </span><span class="s1">_T2</span><span class="s4">, </span><span class="s1">_T3</span><span class="s4">, </span><span class="s1">_T4</span><span class="s4">, </span><span class="s1">_T5</span><span class="s4">]]: ...</span>

    <span class="s4">@</span><span class="s1">overload</span>
    <span class="s3">def </span><span class="s1">with_only_columns</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">__ent0</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T0</span><span class="s4">],</span>
        <span class="s1">__ent1</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T1</span><span class="s4">],</span>
        <span class="s1">__ent2</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T2</span><span class="s4">],</span>
        <span class="s1">__ent3</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T3</span><span class="s4">],</span>
        <span class="s1">__ent4</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T4</span><span class="s4">],</span>
        <span class="s1">__ent5</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T5</span><span class="s4">],</span>
        <span class="s1">__ent6</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T6</span><span class="s4">],</span>
        <span class="s4">*,</span>
        <span class="s1">maintain_column_froms</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= ...,</span>
    <span class="s4">) </span><span class="s1">-&gt; Select</span><span class="s4">[</span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">_T0</span><span class="s4">, </span><span class="s1">_T1</span><span class="s4">, </span><span class="s1">_T2</span><span class="s4">, </span><span class="s1">_T3</span><span class="s4">, </span><span class="s1">_T4</span><span class="s4">, </span><span class="s1">_T5</span><span class="s4">, </span><span class="s1">_T6</span><span class="s4">]]: ...</span>

    <span class="s4">@</span><span class="s1">overload</span>
    <span class="s3">def </span><span class="s1">with_only_columns</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">__ent0</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T0</span><span class="s4">],</span>
        <span class="s1">__ent1</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T1</span><span class="s4">],</span>
        <span class="s1">__ent2</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T2</span><span class="s4">],</span>
        <span class="s1">__ent3</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T3</span><span class="s4">],</span>
        <span class="s1">__ent4</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T4</span><span class="s4">],</span>
        <span class="s1">__ent5</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T5</span><span class="s4">],</span>
        <span class="s1">__ent6</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T6</span><span class="s4">],</span>
        <span class="s1">__ent7</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T7</span><span class="s4">],</span>
        <span class="s4">*,</span>
        <span class="s1">maintain_column_froms</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= ...,</span>
    <span class="s4">) </span><span class="s1">-&gt; Select</span><span class="s4">[</span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">_T0</span><span class="s4">, </span><span class="s1">_T1</span><span class="s4">, </span><span class="s1">_T2</span><span class="s4">, </span><span class="s1">_T3</span><span class="s4">, </span><span class="s1">_T4</span><span class="s4">, </span><span class="s1">_T5</span><span class="s4">, </span><span class="s1">_T6</span><span class="s4">, </span><span class="s1">_T7</span><span class="s4">]]: ...</span>

    <span class="s0"># END OVERLOADED FUNCTIONS self.with_only_columns</span>

    <span class="s4">@</span><span class="s1">overload</span>
    <span class="s3">def </span><span class="s1">with_only_columns</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s4">*</span><span class="s1">entities</span><span class="s4">: </span><span class="s1">_ColumnsClauseArgument</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">],</span>
        <span class="s1">maintain_column_froms</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
        <span class="s4">**</span><span class="s1">__kw</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; Select</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]: ...</span>

    <span class="s4">@</span><span class="s1">_generative</span>
    <span class="s3">def </span><span class="s1">with_only_columns</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s4">*</span><span class="s1">entities</span><span class="s4">: </span><span class="s1">_ColumnsClauseArgument</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">],</span>
        <span class="s1">maintain_column_froms</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
        <span class="s4">**</span><span class="s1">__kw</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; Select</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]:</span>
        <span class="s5">r&quot;&quot;&quot;Return a new :func:`_expression.select` construct with its columns 
        clause replaced with the given entities. 
 
        By default, this method is exactly equivalent to as if the original 
        :func:`_expression.select` had been called with the given entities. 
        E.g. a statement:: 
 
            s = select(table1.c.a, table1.c.b) 
            s = s.with_only_columns(table1.c.b) 
 
        should be exactly equivalent to:: 
 
            s = select(table1.c.b) 
 
        In this mode of operation, :meth:`_sql.Select.with_only_columns` 
        will also dynamically alter the FROM clause of the 
        statement if it is not explicitly stated. 
        To maintain the existing set of FROMs including those implied by the 
        current columns clause, add the 
        :paramref:`_sql.Select.with_only_columns.maintain_column_froms` 
        parameter:: 
 
            s = select(table1.c.a, table2.c.b) 
            s = s.with_only_columns(table1.c.a, maintain_column_froms=True) 
 
        The above parameter performs a transfer of the effective FROMs 
        in the columns collection to the :meth:`_sql.Select.select_from` 
        method, as though the following were invoked:: 
 
            s = select(table1.c.a, table2.c.b) 
            s = s.select_from(table1, table2).with_only_columns(table1.c.a) 
 
        The :paramref:`_sql.Select.with_only_columns.maintain_column_froms` 
        parameter makes use of the :attr:`_sql.Select.columns_clause_froms` 
        collection and performs an operation equivalent to the following:: 
 
            s = select(table1.c.a, table2.c.b) 
            s = s.select_from(*s.columns_clause_froms).with_only_columns(table1.c.a) 
 
        :param \*entities: column expressions to be used. 
 
        :param maintain_column_froms: boolean parameter that will ensure the 
         FROM list implied from the current columns clause will be transferred 
         to the :meth:`_sql.Select.select_from` method first. 
 
         .. versionadded:: 1.4.23 
 
        &quot;&quot;&quot;  </span><span class="s0"># noqa: E501</span>

        <span class="s3">if </span><span class="s1">__kw</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">_no_kw</span><span class="s4">()</span>

        <span class="s0"># memoizations should be cleared here as of</span>
        <span class="s0"># I95c560ffcbfa30b26644999412fb6a385125f663 , asserting this</span>
        <span class="s0"># is the case for now.</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_assert_no_memoizations</span><span class="s4">()</span>

        <span class="s3">if </span><span class="s1">maintain_column_froms</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">select_from</span><span class="s4">.</span><span class="s1">non_generative</span><span class="s4">(  </span><span class="s0"># type: ignore</span>
                <span class="s1">self</span><span class="s4">, *</span><span class="s1">self</span><span class="s4">.</span><span class="s1">columns_clause_froms</span>
            <span class="s4">)</span>

        <span class="s0"># then memoize the FROMs etc.</span>
        <span class="s1">_MemoizedSelectEntities</span><span class="s4">.</span><span class="s1">_generate_for_statement</span><span class="s4">(</span><span class="s1">self</span><span class="s4">)</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">_raw_columns </span><span class="s4">= [</span>
            <span class="s1">coercions</span><span class="s4">.</span><span class="s1">expect</span><span class="s4">(</span><span class="s1">roles</span><span class="s4">.</span><span class="s1">ColumnsClauseRole</span><span class="s4">, </span><span class="s1">c</span><span class="s4">)</span>
            <span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">coercions</span><span class="s4">.</span><span class="s1">_expression_collection_was_a_list</span><span class="s4">(</span>
                <span class="s5">&quot;entities&quot;</span><span class="s4">, </span><span class="s5">&quot;Select.with_only_columns&quot;</span><span class="s4">, </span><span class="s1">entities</span>
            <span class="s4">)</span>
        <span class="s4">]</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">whereclause</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Optional</span><span class="s4">[</span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]:</span>
        <span class="s2">&quot;&quot;&quot;Return the completed WHERE clause for this 
        :class:`_expression.Select` statement. 
 
        This assembles the current collection of WHERE criteria 
        into a single :class:`_expression.BooleanClauseList` construct. 
 
 
        .. versionadded:: 1.4 
 
        &quot;&quot;&quot;</span>

        <span class="s3">return </span><span class="s1">BooleanClauseList</span><span class="s4">.</span><span class="s1">_construct_for_whereclause</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_where_criteria</span>
        <span class="s4">)</span>

    <span class="s1">_whereclause </span><span class="s4">= </span><span class="s1">whereclause</span>

    <span class="s4">@</span><span class="s1">_generative</span>
    <span class="s3">def </span><span class="s1">where</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, *</span><span class="s1">whereclause</span><span class="s4">: </span><span class="s1">_ColumnExpressionArgument</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">]) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Return a new :func:`_expression.select` construct with 
        the given expression added to 
        its WHERE clause, joined to the existing clause via AND, if any. 
 
        &quot;&quot;&quot;</span>

        <span class="s3">assert </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_where_criteria</span><span class="s4">, </span><span class="s1">tuple</span><span class="s4">)</span>

        <span class="s3">for </span><span class="s1">criterion </span><span class="s3">in </span><span class="s1">whereclause</span><span class="s4">:</span>
            <span class="s1">where_criteria</span><span class="s4">: </span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">] = </span><span class="s1">coercions</span><span class="s4">.</span><span class="s1">expect</span><span class="s4">(</span>
                <span class="s1">roles</span><span class="s4">.</span><span class="s1">WhereHavingRole</span><span class="s4">, </span><span class="s1">criterion</span><span class="s4">, </span><span class="s1">apply_propagate_attrs</span><span class="s4">=</span><span class="s1">self</span>
            <span class="s4">)</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_where_criteria </span><span class="s4">+= (</span><span class="s1">where_criteria</span><span class="s4">,)</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s4">@</span><span class="s1">_generative</span>
    <span class="s3">def </span><span class="s1">having</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, *</span><span class="s1">having</span><span class="s4">: </span><span class="s1">_ColumnExpressionArgument</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">]) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Return a new :func:`_expression.select` construct with 
        the given expression added to 
        its HAVING clause, joined to the existing clause via AND, if any. 
 
        &quot;&quot;&quot;</span>

        <span class="s3">for </span><span class="s1">criterion </span><span class="s3">in </span><span class="s1">having</span><span class="s4">:</span>
            <span class="s1">having_criteria </span><span class="s4">= </span><span class="s1">coercions</span><span class="s4">.</span><span class="s1">expect</span><span class="s4">(</span>
                <span class="s1">roles</span><span class="s4">.</span><span class="s1">WhereHavingRole</span><span class="s4">, </span><span class="s1">criterion</span><span class="s4">, </span><span class="s1">apply_propagate_attrs</span><span class="s4">=</span><span class="s1">self</span>
            <span class="s4">)</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_having_criteria </span><span class="s4">+= (</span><span class="s1">having_criteria</span><span class="s4">,)</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s4">@</span><span class="s1">_generative</span>
    <span class="s3">def </span><span class="s1">distinct</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, *</span><span class="s1">expr</span><span class="s4">: </span><span class="s1">_ColumnExpressionArgument</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s2">r&quot;&quot;&quot;Return a new :func:`_expression.select` construct which 
        will apply DISTINCT to the SELECT statement overall. 
 
        E.g.:: 
 
            from sqlalchemy import select 
            stmt = select(users_table.c.id, users_table.c.name).distinct() 
 
        The above would produce an statement resembling:: 
 
            SELECT DISTINCT user.id, user.name FROM user 
 
        The method also accepts an ``*expr`` parameter which produces the 
        PostgreSQL dialect-specific ``DISTINCT ON`` expression.  Using this 
        parameter on other backends which don't support this syntax will 
        raise an error. 
 
        :param \*expr: optional column expressions.  When present, 
         the PostgreSQL dialect will render a ``DISTINCT ON (&lt;expressions&gt;)`` 
         construct.  A deprecation warning and/or :class:`_exc.CompileError` 
         will be raised on other backends. 
 
         .. deprecated:: 1.4 Using \*expr in other dialects is deprecated 
            and will raise :class:`_exc.CompileError` in a future version. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">expr</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_distinct </span><span class="s4">= </span><span class="s3">True</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_distinct_on </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_distinct_on </span><span class="s4">+ </span><span class="s1">tuple</span><span class="s4">(</span>
                <span class="s1">coercions</span><span class="s4">.</span><span class="s1">expect</span><span class="s4">(</span><span class="s1">roles</span><span class="s4">.</span><span class="s1">ByOfRole</span><span class="s4">, </span><span class="s1">e</span><span class="s4">, </span><span class="s1">apply_propagate_attrs</span><span class="s4">=</span><span class="s1">self</span><span class="s4">)</span>
                <span class="s3">for </span><span class="s1">e </span><span class="s3">in </span><span class="s1">expr</span>
            <span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_distinct </span><span class="s4">= </span><span class="s3">True</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s4">@</span><span class="s1">_generative</span>
    <span class="s3">def </span><span class="s1">select_from</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, *</span><span class="s1">froms</span><span class="s4">: </span><span class="s1">_FromClauseArgument</span><span class="s4">) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s2">r&quot;&quot;&quot;Return a new :func:`_expression.select` construct with the 
        given FROM expression(s) 
        merged into its list of FROM objects. 
 
        E.g.:: 
 
            table1 = table('t1', column('a')) 
            table2 = table('t2', column('b')) 
            s = select(table1.c.a).\ 
                select_from( 
                    table1.join(table2, table1.c.a==table2.c.b) 
                ) 
 
        The &quot;from&quot; list is a unique set on the identity of each element, 
        so adding an already present :class:`_schema.Table` 
        or other selectable 
        will have no effect.   Passing a :class:`_expression.Join` that refers 
        to an already present :class:`_schema.Table` 
        or other selectable will have 
        the effect of concealing the presence of that selectable as 
        an individual element in the rendered FROM list, instead 
        rendering it into a JOIN clause. 
 
        While the typical purpose of :meth:`_expression.Select.select_from` 
        is to 
        replace the default, derived FROM clause with a join, it can 
        also be called with individual table elements, multiple times 
        if desired, in the case that the FROM clause cannot be fully 
        derived from the columns clause:: 
 
            select(func.count('*')).select_from(table1) 
 
        &quot;&quot;&quot;</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">_from_obj </span><span class="s4">+= </span><span class="s1">tuple</span><span class="s4">(</span>
            <span class="s1">coercions</span><span class="s4">.</span><span class="s1">expect</span><span class="s4">(</span>
                <span class="s1">roles</span><span class="s4">.</span><span class="s1">FromClauseRole</span><span class="s4">, </span><span class="s1">fromclause</span><span class="s4">, </span><span class="s1">apply_propagate_attrs</span><span class="s4">=</span><span class="s1">self</span>
            <span class="s4">)</span>
            <span class="s3">for </span><span class="s1">fromclause </span><span class="s3">in </span><span class="s1">froms</span>
        <span class="s4">)</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s4">@</span><span class="s1">_generative</span>
    <span class="s3">def </span><span class="s1">correlate</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s4">*</span><span class="s1">fromclauses</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span><span class="s1">Literal</span><span class="s4">[</span><span class="s3">None</span><span class="s4">, </span><span class="s3">False</span><span class="s4">], </span><span class="s1">_FromClauseArgument</span><span class="s4">],</span>
    <span class="s4">) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s2">r&quot;&quot;&quot;Return a new :class:`_expression.Select` 
        which will correlate the given FROM 
        clauses to that of an enclosing :class:`_expression.Select`. 
 
        Calling this method turns off the :class:`_expression.Select` object's 
        default behavior of &quot;auto-correlation&quot;.  Normally, FROM elements 
        which appear in a :class:`_expression.Select` 
        that encloses this one via 
        its :term:`WHERE clause`, ORDER BY, HAVING or 
        :term:`columns clause` will be omitted from this 
        :class:`_expression.Select` 
        object's :term:`FROM clause`. 
        Setting an explicit correlation collection using the 
        :meth:`_expression.Select.correlate` 
        method provides a fixed list of FROM objects 
        that can potentially take place in this process. 
 
        When :meth:`_expression.Select.correlate` 
        is used to apply specific FROM clauses 
        for correlation, the FROM elements become candidates for 
        correlation regardless of how deeply nested this 
        :class:`_expression.Select` 
        object is, relative to an enclosing :class:`_expression.Select` 
        which refers to 
        the same FROM object.  This is in contrast to the behavior of 
        &quot;auto-correlation&quot; which only correlates to an immediate enclosing 
        :class:`_expression.Select`. 
        Multi-level correlation ensures that the link 
        between enclosed and enclosing :class:`_expression.Select` 
        is always via 
        at least one WHERE/ORDER BY/HAVING/columns clause in order for 
        correlation to take place. 
 
        If ``None`` is passed, the :class:`_expression.Select` 
        object will correlate 
        none of its FROM entries, and all will render unconditionally 
        in the local FROM clause. 
 
        :param \*fromclauses: one or more :class:`.FromClause` or other 
         FROM-compatible construct such as an ORM mapped entity to become part 
         of the correlate collection; alternatively pass a single value 
         ``None`` to remove all existing correlations. 
 
        .. seealso:: 
 
            :meth:`_expression.Select.correlate_except` 
 
            :ref:`tutorial_scalar_subquery` 
 
        &quot;&quot;&quot;</span>

        <span class="s0"># tests failing when we try to change how these</span>
        <span class="s0"># arguments are passed</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">_auto_correlate </span><span class="s4">= </span><span class="s3">False</span>
        <span class="s3">if not </span><span class="s1">fromclauses </span><span class="s3">or </span><span class="s1">fromclauses</span><span class="s4">[</span><span class="s6">0</span><span class="s4">] </span><span class="s3">in </span><span class="s4">{</span><span class="s3">None</span><span class="s4">, </span><span class="s3">False</span><span class="s4">}:</span>
            <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">fromclauses</span><span class="s4">) &gt; </span><span class="s6">1</span><span class="s4">:</span>
                <span class="s3">raise </span><span class="s1">exc</span><span class="s4">.</span><span class="s1">ArgumentError</span><span class="s4">(</span>
                    <span class="s5">&quot;additional FROM objects not accepted when &quot;</span>
                    <span class="s5">&quot;passing None/False to correlate()&quot;</span>
                <span class="s4">)</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_correlate </span><span class="s4">= ()</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_correlate </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_correlate </span><span class="s4">+ </span><span class="s1">tuple</span><span class="s4">(</span>
                <span class="s1">coercions</span><span class="s4">.</span><span class="s1">expect</span><span class="s4">(</span><span class="s1">roles</span><span class="s4">.</span><span class="s1">FromClauseRole</span><span class="s4">, </span><span class="s1">f</span><span class="s4">) </span><span class="s3">for </span><span class="s1">f </span><span class="s3">in </span><span class="s1">fromclauses</span>
            <span class="s4">)</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s4">@</span><span class="s1">_generative</span>
    <span class="s3">def </span><span class="s1">correlate_except</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s4">*</span><span class="s1">fromclauses</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span><span class="s1">Literal</span><span class="s4">[</span><span class="s3">None</span><span class="s4">, </span><span class="s3">False</span><span class="s4">], </span><span class="s1">_FromClauseArgument</span><span class="s4">],</span>
    <span class="s4">) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s2">r&quot;&quot;&quot;Return a new :class:`_expression.Select` 
        which will omit the given FROM 
        clauses from the auto-correlation process. 
 
        Calling :meth:`_expression.Select.correlate_except` turns off the 
        :class:`_expression.Select` object's default behavior of 
        &quot;auto-correlation&quot; for the given FROM elements.  An element 
        specified here will unconditionally appear in the FROM list, while 
        all other FROM elements remain subject to normal auto-correlation 
        behaviors. 
 
        If ``None`` is passed, or no arguments are passed, 
        the :class:`_expression.Select` object will correlate all of its 
        FROM entries. 
 
        :param \*fromclauses: a list of one or more 
         :class:`_expression.FromClause` 
         constructs, or other compatible constructs (i.e. ORM-mapped 
         classes) to become part of the correlate-exception collection. 
 
        .. seealso:: 
 
            :meth:`_expression.Select.correlate` 
 
            :ref:`tutorial_scalar_subquery` 
 
        &quot;&quot;&quot;</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">_auto_correlate </span><span class="s4">= </span><span class="s3">False</span>
        <span class="s3">if not </span><span class="s1">fromclauses </span><span class="s3">or </span><span class="s1">fromclauses</span><span class="s4">[</span><span class="s6">0</span><span class="s4">] </span><span class="s3">in </span><span class="s4">{</span><span class="s3">None</span><span class="s4">, </span><span class="s3">False</span><span class="s4">}:</span>
            <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">fromclauses</span><span class="s4">) &gt; </span><span class="s6">1</span><span class="s4">:</span>
                <span class="s3">raise </span><span class="s1">exc</span><span class="s4">.</span><span class="s1">ArgumentError</span><span class="s4">(</span>
                    <span class="s5">&quot;additional FROM objects not accepted when &quot;</span>
                    <span class="s5">&quot;passing None/False to correlate_except()&quot;</span>
                <span class="s4">)</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_correlate_except </span><span class="s4">= ()</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_correlate_except </span><span class="s4">= (</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_correlate_except </span><span class="s3">or </span><span class="s4">()) + </span><span class="s1">tuple</span><span class="s4">(</span>
                <span class="s1">coercions</span><span class="s4">.</span><span class="s1">expect</span><span class="s4">(</span><span class="s1">roles</span><span class="s4">.</span><span class="s1">FromClauseRole</span><span class="s4">, </span><span class="s1">f</span><span class="s4">) </span><span class="s3">for </span><span class="s1">f </span><span class="s3">in </span><span class="s1">fromclauses</span>
            <span class="s4">)</span>

        <span class="s3">return </span><span class="s1">self</span>

    <span class="s4">@</span><span class="s1">HasMemoized_ro_memoized_attribute</span>
    <span class="s3">def </span><span class="s1">selected_columns</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; ColumnCollection</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]:</span>
        <span class="s2">&quot;&quot;&quot;A :class:`_expression.ColumnCollection` 
        representing the columns that 
        this SELECT statement or similar construct returns in its result set, 
        not including :class:`_sql.TextClause` constructs. 
 
        This collection differs from the :attr:`_expression.FromClause.columns` 
        collection of a :class:`_expression.FromClause` in that the columns 
        within this collection cannot be directly nested inside another SELECT 
        statement; a subquery must be applied first which provides for the 
        necessary parenthesization required by SQL. 
 
        For a :func:`_expression.select` construct, the collection here is 
        exactly what would be rendered inside the &quot;SELECT&quot; statement, and the 
        :class:`_expression.ColumnElement` objects are directly present as they 
        were given, e.g.:: 
 
            col1 = column('q', Integer) 
            col2 = column('p', Integer) 
            stmt = select(col1, col2) 
 
        Above, ``stmt.selected_columns`` would be a collection that contains 
        the ``col1`` and ``col2`` objects directly. For a statement that is 
        against a :class:`_schema.Table` or other 
        :class:`_expression.FromClause`, the collection will use the 
        :class:`_expression.ColumnElement` objects that are in the 
        :attr:`_expression.FromClause.c` collection of the from element. 
 
        A use case for the :attr:`_sql.Select.selected_columns` collection is 
        to allow the existing columns to be referenced when adding additional 
        criteria, e.g.:: 
 
            def filter_on_id(my_select, id): 
                return my_select.where(my_select.selected_columns['id'] == id) 
 
            stmt = select(MyModel) 
 
            # adds &quot;WHERE id=:param&quot; to the statement 
            stmt = filter_on_id(stmt, 42) 
 
        .. note:: 
 
            The :attr:`_sql.Select.selected_columns` collection does not 
            include expressions established in the columns clause using the 
            :func:`_sql.text` construct; these are silently omitted from the 
            collection. To use plain textual column expressions inside of a 
            :class:`_sql.Select` construct, use the :func:`_sql.literal_column` 
            construct. 
 
 
        .. versionadded:: 1.4 
 
        &quot;&quot;&quot;</span>

        <span class="s0"># compare to SelectState._generate_columns_plus_names, which</span>
        <span class="s0"># generates the actual names used in the SELECT string.  that</span>
        <span class="s0"># method is more complex because it also renders columns that are</span>
        <span class="s0"># fully ambiguous, e.g. same column more than once.</span>
        <span class="s1">conv </span><span class="s4">= </span><span class="s1">cast</span><span class="s4">(</span>
            <span class="s5">&quot;Callable[[Any], str]&quot;</span><span class="s4">,</span>
            <span class="s1">SelectState</span><span class="s4">.</span><span class="s1">_column_naming_convention</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_label_style</span><span class="s4">),</span>
        <span class="s4">)</span>

        <span class="s1">cc</span><span class="s4">: </span><span class="s1">ColumnCollection</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]] = </span><span class="s1">ColumnCollection</span><span class="s4">(</span>
            <span class="s4">[</span>
                <span class="s4">(</span><span class="s1">conv</span><span class="s4">(</span><span class="s1">c</span><span class="s4">), </span><span class="s1">c</span><span class="s4">)</span>
                <span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_all_selected_columns</span>
                <span class="s3">if </span><span class="s1">is_column_element</span><span class="s4">(</span><span class="s1">c</span><span class="s4">)</span>
            <span class="s4">]</span>
        <span class="s4">)</span>
        <span class="s3">return </span><span class="s1">cc</span><span class="s4">.</span><span class="s1">as_readonly</span><span class="s4">()</span>

    <span class="s4">@</span><span class="s1">HasMemoized_ro_memoized_attribute</span>
    <span class="s3">def </span><span class="s1">_all_selected_columns</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; _SelectIterable</span><span class="s4">:</span>
        <span class="s1">meth </span><span class="s4">= </span><span class="s1">SelectState</span><span class="s4">.</span><span class="s1">get_plugin_class</span><span class="s4">(</span><span class="s1">self</span><span class="s4">).</span><span class="s1">all_selected_columns</span>
        <span class="s3">return </span><span class="s1">list</span><span class="s4">(</span><span class="s1">meth</span><span class="s4">(</span><span class="s1">self</span><span class="s4">))</span>

    <span class="s3">def </span><span class="s1">_ensure_disambiguated_names</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Select</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]:</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_label_style </span><span class="s3">is </span><span class="s1">LABEL_STYLE_NONE</span><span class="s4">:</span>
            <span class="s1">self </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">set_label_style</span><span class="s4">(</span><span class="s1">LABEL_STYLE_DISAMBIGUATE_ONLY</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">_generate_fromclause_column_proxies</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">subquery</span><span class="s4">: </span><span class="s1">FromClause</span><span class="s4">,</span>
        <span class="s4">*,</span>
        <span class="s1">proxy_compound_columns</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span>
            <span class="s1">Iterable</span><span class="s4">[</span><span class="s1">Sequence</span><span class="s4">[</span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]]</span>
        <span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Generate column proxies to place in the exported ``.c`` 
        collection of a subquery.&quot;&quot;&quot;</span>

        <span class="s3">if </span><span class="s1">proxy_compound_columns</span><span class="s4">:</span>
            <span class="s1">extra_col_iterator </span><span class="s4">= </span><span class="s1">proxy_compound_columns</span>
            <span class="s1">prox </span><span class="s4">= [</span>
                <span class="s1">c</span><span class="s4">.</span><span class="s1">_make_proxy</span><span class="s4">(</span>
                    <span class="s1">subquery</span><span class="s4">,</span>
                    <span class="s1">key</span><span class="s4">=</span><span class="s1">proxy_key</span><span class="s4">,</span>
                    <span class="s1">name</span><span class="s4">=</span><span class="s1">required_label_name</span><span class="s4">,</span>
                    <span class="s1">name_is_truncatable</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
                    <span class="s1">compound_select_cols</span><span class="s4">=</span><span class="s1">extra_cols</span><span class="s4">,</span>
                <span class="s4">)</span>
                <span class="s3">for </span><span class="s4">(</span>
                    <span class="s4">(</span>
                        <span class="s1">required_label_name</span><span class="s4">,</span>
                        <span class="s1">proxy_key</span><span class="s4">,</span>
                        <span class="s1">fallback_label_name</span><span class="s4">,</span>
                        <span class="s1">c</span><span class="s4">,</span>
                        <span class="s1">repeated</span><span class="s4">,</span>
                    <span class="s4">),</span>
                    <span class="s1">extra_cols</span><span class="s4">,</span>
                <span class="s4">) </span><span class="s3">in </span><span class="s4">(</span>
                    <span class="s1">zip</span><span class="s4">(</span>
                        <span class="s1">self</span><span class="s4">.</span><span class="s1">_generate_columns_plus_names</span><span class="s4">(</span><span class="s3">False</span><span class="s4">),</span>
                        <span class="s1">extra_col_iterator</span><span class="s4">,</span>
                    <span class="s4">)</span>
                <span class="s4">)</span>
                <span class="s3">if </span><span class="s1">is_column_element</span><span class="s4">(</span><span class="s1">c</span><span class="s4">)</span>
            <span class="s4">]</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">prox </span><span class="s4">= [</span>
                <span class="s1">c</span><span class="s4">.</span><span class="s1">_make_proxy</span><span class="s4">(</span>
                    <span class="s1">subquery</span><span class="s4">,</span>
                    <span class="s1">key</span><span class="s4">=</span><span class="s1">proxy_key</span><span class="s4">,</span>
                    <span class="s1">name</span><span class="s4">=</span><span class="s1">required_label_name</span><span class="s4">,</span>
                    <span class="s1">name_is_truncatable</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
                <span class="s4">)</span>
                <span class="s3">for </span><span class="s4">(</span>
                    <span class="s1">required_label_name</span><span class="s4">,</span>
                    <span class="s1">proxy_key</span><span class="s4">,</span>
                    <span class="s1">fallback_label_name</span><span class="s4">,</span>
                    <span class="s1">c</span><span class="s4">,</span>
                    <span class="s1">repeated</span><span class="s4">,</span>
                <span class="s4">) </span><span class="s3">in </span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_generate_columns_plus_names</span><span class="s4">(</span><span class="s3">False</span><span class="s4">))</span>
                <span class="s3">if </span><span class="s1">is_column_element</span><span class="s4">(</span><span class="s1">c</span><span class="s4">)</span>
            <span class="s4">]</span>

        <span class="s1">subquery</span><span class="s4">.</span><span class="s1">_columns</span><span class="s4">.</span><span class="s1">_populate_separate_keys</span><span class="s4">(</span><span class="s1">prox</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_needs_parens_for_grouping</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_has_row_limiting_clause </span><span class="s3">or </span><span class="s1">bool</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_order_by_clause</span><span class="s4">.</span><span class="s1">clauses</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">self_group</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">against</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">OperatorType</span><span class="s4">] = </span><span class="s3">None</span>
    <span class="s4">) </span><span class="s1">-&gt; Union</span><span class="s4">[</span><span class="s1">SelectStatementGrouping</span><span class="s4">[</span><span class="s1">Self</span><span class="s4">], </span><span class="s1">Self</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;Return a 'grouping' construct as per the 
        :class:`_expression.ClauseElement` specification. 
 
        This produces an element that can be embedded in an expression. Note 
        that this method is called automatically as needed when constructing 
        expressions and should not require explicit use. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s4">(</span>
            <span class="s1">isinstance</span><span class="s4">(</span><span class="s1">against</span><span class="s4">, </span><span class="s1">CompoundSelect</span><span class="s4">)</span>
            <span class="s3">and not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_needs_parens_for_grouping</span><span class="s4">()</span>
        <span class="s4">):</span>
            <span class="s3">return </span><span class="s1">self</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">SelectStatementGrouping</span><span class="s4">(</span><span class="s1">self</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">union</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, *</span><span class="s1">other</span><span class="s4">: </span><span class="s1">_SelectStatementForCompoundArgument</span>
    <span class="s4">) </span><span class="s1">-&gt; CompoundSelect</span><span class="s4">:</span>
        <span class="s2">r&quot;&quot;&quot;Return a SQL ``UNION`` of this select() construct against 
        the given selectables provided as positional arguments. 
 
        :param \*other: one or more elements with which to create a 
         UNION. 
 
         .. versionchanged:: 1.4.28 
 
            multiple elements are now accepted. 
 
        :param \**kwargs: keyword arguments are forwarded to the constructor 
         for the newly created :class:`_sql.CompoundSelect` object. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">CompoundSelect</span><span class="s4">.</span><span class="s1">_create_union</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, *</span><span class="s1">other</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">union_all</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, *</span><span class="s1">other</span><span class="s4">: </span><span class="s1">_SelectStatementForCompoundArgument</span>
    <span class="s4">) </span><span class="s1">-&gt; CompoundSelect</span><span class="s4">:</span>
        <span class="s2">r&quot;&quot;&quot;Return a SQL ``UNION ALL`` of this select() construct against 
        the given selectables provided as positional arguments. 
 
        :param \*other: one or more elements with which to create a 
         UNION. 
 
         .. versionchanged:: 1.4.28 
 
            multiple elements are now accepted. 
 
        :param \**kwargs: keyword arguments are forwarded to the constructor 
         for the newly created :class:`_sql.CompoundSelect` object. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">CompoundSelect</span><span class="s4">.</span><span class="s1">_create_union_all</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, *</span><span class="s1">other</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">except_</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, *</span><span class="s1">other</span><span class="s4">: </span><span class="s1">_SelectStatementForCompoundArgument</span>
    <span class="s4">) </span><span class="s1">-&gt; CompoundSelect</span><span class="s4">:</span>
        <span class="s2">r&quot;&quot;&quot;Return a SQL ``EXCEPT`` of this select() construct against 
        the given selectable provided as positional arguments. 
 
        :param \*other: one or more elements with which to create a 
         UNION. 
 
         .. versionchanged:: 1.4.28 
 
            multiple elements are now accepted. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">CompoundSelect</span><span class="s4">.</span><span class="s1">_create_except</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, *</span><span class="s1">other</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">except_all</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, *</span><span class="s1">other</span><span class="s4">: </span><span class="s1">_SelectStatementForCompoundArgument</span>
    <span class="s4">) </span><span class="s1">-&gt; CompoundSelect</span><span class="s4">:</span>
        <span class="s2">r&quot;&quot;&quot;Return a SQL ``EXCEPT ALL`` of this select() construct against 
        the given selectables provided as positional arguments. 
 
        :param \*other: one or more elements with which to create a 
         UNION. 
 
         .. versionchanged:: 1.4.28 
 
            multiple elements are now accepted. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">CompoundSelect</span><span class="s4">.</span><span class="s1">_create_except_all</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, *</span><span class="s1">other</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">intersect</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, *</span><span class="s1">other</span><span class="s4">: </span><span class="s1">_SelectStatementForCompoundArgument</span>
    <span class="s4">) </span><span class="s1">-&gt; CompoundSelect</span><span class="s4">:</span>
        <span class="s2">r&quot;&quot;&quot;Return a SQL ``INTERSECT`` of this select() construct against 
        the given selectables provided as positional arguments. 
 
        :param \*other: one or more elements with which to create a 
         UNION. 
 
         .. versionchanged:: 1.4.28 
 
            multiple elements are now accepted. 
 
        :param \**kwargs: keyword arguments are forwarded to the constructor 
         for the newly created :class:`_sql.CompoundSelect` object. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">CompoundSelect</span><span class="s4">.</span><span class="s1">_create_intersect</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, *</span><span class="s1">other</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">intersect_all</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, *</span><span class="s1">other</span><span class="s4">: </span><span class="s1">_SelectStatementForCompoundArgument</span>
    <span class="s4">) </span><span class="s1">-&gt; CompoundSelect</span><span class="s4">:</span>
        <span class="s2">r&quot;&quot;&quot;Return a SQL ``INTERSECT ALL`` of this select() construct 
        against the given selectables provided as positional arguments. 
 
        :param \*other: one or more elements with which to create a 
         UNION. 
 
         .. versionchanged:: 1.4.28 
 
            multiple elements are now accepted. 
 
        :param \**kwargs: keyword arguments are forwarded to the constructor 
         for the newly created :class:`_sql.CompoundSelect` object. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">CompoundSelect</span><span class="s4">.</span><span class="s1">_create_intersect_all</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, *</span><span class="s1">other</span><span class="s4">)</span>


<span class="s3">class </span><span class="s1">ScalarSelect</span><span class="s4">(</span>
    <span class="s1">roles</span><span class="s4">.</span><span class="s1">InElementRole</span><span class="s4">, </span><span class="s1">Generative</span><span class="s4">, </span><span class="s1">GroupedElement</span><span class="s4">, </span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]</span>
<span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Represent a scalar subquery. 
 
 
    A :class:`_sql.ScalarSelect` is created by invoking the 
    :meth:`_sql.SelectBase.scalar_subquery` method.   The object 
    then participates in other SQL expressions as a SQL column expression 
    within the :class:`_sql.ColumnElement` hierarchy. 
 
    .. seealso:: 
 
        :meth:`_sql.SelectBase.scalar_subquery` 
 
        :ref:`tutorial_scalar_subquery` - in the 2.0 tutorial 
 
    &quot;&quot;&quot;</span>

    <span class="s1">_traverse_internals</span><span class="s4">: </span><span class="s1">_TraverseInternalsType </span><span class="s4">= [</span>
        <span class="s4">(</span><span class="s5">&quot;element&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_clauseelement</span><span class="s4">),</span>
        <span class="s4">(</span><span class="s5">&quot;type&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_type</span><span class="s4">),</span>
    <span class="s4">]</span>

    <span class="s1">_from_objects</span><span class="s4">: </span><span class="s1">List</span><span class="s4">[</span><span class="s1">FromClause</span><span class="s4">] = []</span>
    <span class="s1">_is_from_container </span><span class="s4">= </span><span class="s3">True</span>
    <span class="s3">if not </span><span class="s1">TYPE_CHECKING</span><span class="s4">:</span>
        <span class="s1">_is_implicitly_boolean </span><span class="s4">= </span><span class="s3">False</span>
    <span class="s1">inherit_cache </span><span class="s4">= </span><span class="s3">True</span>

    <span class="s1">element</span><span class="s4">: </span><span class="s1">SelectBase</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">element</span><span class="s4">: </span><span class="s1">SelectBase</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">element </span><span class="s4">= </span><span class="s1">element</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">type </span><span class="s4">= </span><span class="s1">element</span><span class="s4">.</span><span class="s1">_scalar_type</span><span class="s4">()</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_propagate_attrs </span><span class="s4">= </span><span class="s1">element</span><span class="s4">.</span><span class="s1">_propagate_attrs</span>

    <span class="s3">def </span><span class="s1">__getattr__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">attr</span><span class="s4">: </span><span class="s1">str</span><span class="s4">) </span><span class="s1">-&gt; Any</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">getattr</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">element</span><span class="s4">, </span><span class="s1">attr</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">__getstate__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Dict</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">Any</span><span class="s4">]:</span>
        <span class="s3">return </span><span class="s4">{</span><span class="s5">&quot;element&quot;</span><span class="s4">: </span><span class="s1">self</span><span class="s4">.</span><span class="s1">element</span><span class="s4">, </span><span class="s5">&quot;type&quot;</span><span class="s4">: </span><span class="s1">self</span><span class="s4">.</span><span class="s1">type</span><span class="s4">}</span>

    <span class="s3">def </span><span class="s1">__setstate__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">state</span><span class="s4">: </span><span class="s1">Dict</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">Any</span><span class="s4">]) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">element </span><span class="s4">= </span><span class="s1">state</span><span class="s4">[</span><span class="s5">&quot;element&quot;</span><span class="s4">]</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">type </span><span class="s4">= </span><span class="s1">state</span><span class="s4">[</span><span class="s5">&quot;type&quot;</span><span class="s4">]</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">columns</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; NoReturn</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">exc</span><span class="s4">.</span><span class="s1">InvalidRequestError</span><span class="s4">(</span>
            <span class="s5">&quot;Scalar Select expression has no &quot;</span>
            <span class="s5">&quot;columns; use this object directly &quot;</span>
            <span class="s5">&quot;within a column-level expression.&quot;</span>
        <span class="s4">)</span>

    <span class="s1">c </span><span class="s4">= </span><span class="s1">columns</span>

    <span class="s4">@</span><span class="s1">_generative</span>
    <span class="s3">def </span><span class="s1">where</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">crit</span><span class="s4">: </span><span class="s1">_ColumnExpressionArgument</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">]) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Apply a WHERE clause to the SELECT statement referred to 
        by this :class:`_expression.ScalarSelect`. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">element </span><span class="s4">= </span><span class="s1">cast</span><span class="s4">(</span><span class="s5">&quot;Select[Any]&quot;</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">element</span><span class="s4">).</span><span class="s1">where</span><span class="s4">(</span><span class="s1">crit</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">self_group</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">against</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">OperatorType</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">if </span><span class="s1">TYPE_CHECKING</span><span class="s4">:</span>

        <span class="s3">def </span><span class="s1">_ungroup</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Select</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]: ...</span>

    <span class="s4">@</span><span class="s1">_generative</span>
    <span class="s3">def </span><span class="s1">correlate</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s4">*</span><span class="s1">fromclauses</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span><span class="s1">Literal</span><span class="s4">[</span><span class="s3">None</span><span class="s4">, </span><span class="s3">False</span><span class="s4">], </span><span class="s1">_FromClauseArgument</span><span class="s4">],</span>
    <span class="s4">) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s2">r&quot;&quot;&quot;Return a new :class:`_expression.ScalarSelect` 
        which will correlate the given FROM 
        clauses to that of an enclosing :class:`_expression.Select`. 
 
        This method is mirrored from the :meth:`_sql.Select.correlate` method 
        of the underlying :class:`_sql.Select`.  The method applies the 
        :meth:_sql.Select.correlate` method, then returns a new 
        :class:`_sql.ScalarSelect` against that statement. 
 
        .. versionadded:: 1.4 Previously, the 
           :meth:`_sql.ScalarSelect.correlate` 
           method was only available from :class:`_sql.Select`. 
 
        :param \*fromclauses: a list of one or more 
         :class:`_expression.FromClause` 
         constructs, or other compatible constructs (i.e. ORM-mapped 
         classes) to become part of the correlate collection. 
 
        .. seealso:: 
 
            :meth:`_expression.ScalarSelect.correlate_except` 
 
            :ref:`tutorial_scalar_subquery` - in the 2.0 tutorial 
 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">element </span><span class="s4">= </span><span class="s1">cast</span><span class="s4">(</span><span class="s5">&quot;Select[Any]&quot;</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">element</span><span class="s4">).</span><span class="s1">correlate</span><span class="s4">(</span>
            <span class="s4">*</span><span class="s1">fromclauses</span>
        <span class="s4">)</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s4">@</span><span class="s1">_generative</span>
    <span class="s3">def </span><span class="s1">correlate_except</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s4">*</span><span class="s1">fromclauses</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span><span class="s1">Literal</span><span class="s4">[</span><span class="s3">None</span><span class="s4">, </span><span class="s3">False</span><span class="s4">], </span><span class="s1">_FromClauseArgument</span><span class="s4">],</span>
    <span class="s4">) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s2">r&quot;&quot;&quot;Return a new :class:`_expression.ScalarSelect` 
        which will omit the given FROM 
        clauses from the auto-correlation process. 
 
        This method is mirrored from the 
        :meth:`_sql.Select.correlate_except` method of the underlying 
        :class:`_sql.Select`.  The method applies the 
        :meth:_sql.Select.correlate_except` method, then returns a new 
        :class:`_sql.ScalarSelect` against that statement. 
 
        .. versionadded:: 1.4 Previously, the 
           :meth:`_sql.ScalarSelect.correlate_except` 
           method was only available from :class:`_sql.Select`. 
 
        :param \*fromclauses: a list of one or more 
         :class:`_expression.FromClause` 
         constructs, or other compatible constructs (i.e. ORM-mapped 
         classes) to become part of the correlate-exception collection. 
 
        .. seealso:: 
 
            :meth:`_expression.ScalarSelect.correlate` 
 
            :ref:`tutorial_scalar_subquery` - in the 2.0 tutorial 
 
 
        &quot;&quot;&quot;</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">element </span><span class="s4">= </span><span class="s1">cast</span><span class="s4">(</span><span class="s5">&quot;Select[Any]&quot;</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">element</span><span class="s4">).</span><span class="s1">correlate_except</span><span class="s4">(</span>
            <span class="s4">*</span><span class="s1">fromclauses</span>
        <span class="s4">)</span>
        <span class="s3">return </span><span class="s1">self</span>


<span class="s3">class </span><span class="s1">Exists</span><span class="s4">(</span><span class="s1">UnaryExpression</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">]):</span>
    <span class="s2">&quot;&quot;&quot;Represent an ``EXISTS`` clause. 
 
    See :func:`_sql.exists` for a description of usage. 
 
    An ``EXISTS`` clause can also be constructed from a :func:`_sql.select` 
    instance by calling :meth:`_sql.SelectBase.exists`. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">inherit_cache </span><span class="s4">= </span><span class="s3">True</span>
    <span class="s1">element</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span><span class="s1">SelectStatementGrouping</span><span class="s4">[</span><span class="s1">Select</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]], </span><span class="s1">ScalarSelect</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">__argument</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span>
            <span class="s1">Union</span><span class="s4">[</span><span class="s1">_ColumnsClauseArgument</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">], </span><span class="s1">SelectBase</span><span class="s4">, </span><span class="s1">ScalarSelect</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]</span>
        <span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
    <span class="s4">):</span>
        <span class="s1">s</span><span class="s4">: </span><span class="s1">ScalarSelect</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]</span>

        <span class="s0"># TODO: this seems like we should be using coercions for this</span>
        <span class="s3">if </span><span class="s1">__argument </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s1">s </span><span class="s4">= </span><span class="s1">Select</span><span class="s4">(</span><span class="s1">literal_column</span><span class="s4">(</span><span class="s5">&quot;*&quot;</span><span class="s4">)).</span><span class="s1">scalar_subquery</span><span class="s4">()</span>
        <span class="s3">elif </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">__argument</span><span class="s4">, </span><span class="s1">SelectBase</span><span class="s4">):</span>
            <span class="s1">s </span><span class="s4">= </span><span class="s1">__argument</span><span class="s4">.</span><span class="s1">scalar_subquery</span><span class="s4">()</span>
            <span class="s1">s</span><span class="s4">.</span><span class="s1">_propagate_attrs </span><span class="s4">= </span><span class="s1">__argument</span><span class="s4">.</span><span class="s1">_propagate_attrs</span>
        <span class="s3">elif </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">__argument</span><span class="s4">, </span><span class="s1">ScalarSelect</span><span class="s4">):</span>
            <span class="s1">s </span><span class="s4">= </span><span class="s1">__argument</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">s </span><span class="s4">= </span><span class="s1">Select</span><span class="s4">(</span><span class="s1">__argument</span><span class="s4">).</span><span class="s1">scalar_subquery</span><span class="s4">()</span>

        <span class="s1">UnaryExpression</span><span class="s4">.</span><span class="s1">__init__</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">,</span>
            <span class="s1">s</span><span class="s4">,</span>
            <span class="s1">operator</span><span class="s4">=</span><span class="s1">operators</span><span class="s4">.</span><span class="s1">exists</span><span class="s4">,</span>
            <span class="s1">type_</span><span class="s4">=</span><span class="s1">type_api</span><span class="s4">.</span><span class="s1">BOOLEANTYPE</span><span class="s4">,</span>
            <span class="s1">wraps_column_expression</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
        <span class="s4">)</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">ro_non_memoized_property</span>
    <span class="s3">def </span><span class="s1">_from_objects</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; List</span><span class="s4">[</span><span class="s1">FromClause</span><span class="s4">]:</span>
        <span class="s3">return </span><span class="s4">[]</span>

    <span class="s3">def </span><span class="s1">_regroup</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">fn</span><span class="s4">: </span><span class="s1">Callable</span><span class="s4">[[</span><span class="s1">Select</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]], </span><span class="s1">Select</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]</span>
    <span class="s4">) </span><span class="s1">-&gt; SelectStatementGrouping</span><span class="s4">[</span><span class="s1">Select</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]:</span>
        <span class="s1">element </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">element</span><span class="s4">.</span><span class="s1">_ungroup</span><span class="s4">()</span>
        <span class="s1">new_element </span><span class="s4">= </span><span class="s1">fn</span><span class="s4">(</span><span class="s1">element</span><span class="s4">)</span>

        <span class="s1">return_value </span><span class="s4">= </span><span class="s1">new_element</span><span class="s4">.</span><span class="s1">self_group</span><span class="s4">(</span><span class="s1">against</span><span class="s4">=</span><span class="s1">operators</span><span class="s4">.</span><span class="s1">exists</span><span class="s4">)</span>
        <span class="s3">assert </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">return_value</span><span class="s4">, </span><span class="s1">SelectStatementGrouping</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">return_value</span>

    <span class="s3">def </span><span class="s1">select</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Select</span><span class="s4">[</span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">]]:</span>
        <span class="s5">r&quot;&quot;&quot;Return a SELECT of this :class:`_expression.Exists`. 
 
        e.g.:: 
 
            stmt = exists(some_table.c.id).where(some_table.c.id == 5).select() 
 
        This will produce a statement resembling:: 
 
            SELECT EXISTS (SELECT id FROM some_table WHERE some_table = :param) AS anon_1 
 
        .. seealso:: 
 
            :func:`_expression.select` - general purpose 
            method which allows for arbitrary column lists. 
 
        &quot;&quot;&quot;  </span><span class="s0"># noqa</span>

        <span class="s3">return </span><span class="s1">Select</span><span class="s4">(</span><span class="s1">self</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">correlate</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s4">*</span><span class="s1">fromclauses</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span><span class="s1">Literal</span><span class="s4">[</span><span class="s3">None</span><span class="s4">, </span><span class="s3">False</span><span class="s4">], </span><span class="s1">_FromClauseArgument</span><span class="s4">],</span>
    <span class="s4">) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Apply correlation to the subquery noted by this 
        :class:`_sql.Exists`. 
 
        .. seealso:: 
 
            :meth:`_sql.ScalarSelect.correlate` 
 
        &quot;&quot;&quot;</span>
        <span class="s1">e </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_clone</span><span class="s4">()</span>
        <span class="s1">e</span><span class="s4">.</span><span class="s1">element </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_regroup</span><span class="s4">(</span>
            <span class="s3">lambda </span><span class="s1">element</span><span class="s4">: </span><span class="s1">element</span><span class="s4">.</span><span class="s1">correlate</span><span class="s4">(*</span><span class="s1">fromclauses</span><span class="s4">)</span>
        <span class="s4">)</span>
        <span class="s3">return </span><span class="s1">e</span>

    <span class="s3">def </span><span class="s1">correlate_except</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s4">*</span><span class="s1">fromclauses</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span><span class="s1">Literal</span><span class="s4">[</span><span class="s3">None</span><span class="s4">, </span><span class="s3">False</span><span class="s4">], </span><span class="s1">_FromClauseArgument</span><span class="s4">],</span>
    <span class="s4">) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Apply correlation to the subquery noted by this 
        :class:`_sql.Exists`. 
 
        .. seealso:: 
 
            :meth:`_sql.ScalarSelect.correlate_except` 
 
        &quot;&quot;&quot;</span>

        <span class="s1">e </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_clone</span><span class="s4">()</span>
        <span class="s1">e</span><span class="s4">.</span><span class="s1">element </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_regroup</span><span class="s4">(</span>
            <span class="s3">lambda </span><span class="s1">element</span><span class="s4">: </span><span class="s1">element</span><span class="s4">.</span><span class="s1">correlate_except</span><span class="s4">(*</span><span class="s1">fromclauses</span><span class="s4">)</span>
        <span class="s4">)</span>
        <span class="s3">return </span><span class="s1">e</span>

    <span class="s3">def </span><span class="s1">select_from</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, *</span><span class="s1">froms</span><span class="s4">: </span><span class="s1">_FromClauseArgument</span><span class="s4">) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Return a new :class:`_expression.Exists` construct, 
        applying the given 
        expression to the :meth:`_expression.Select.select_from` 
        method of the select 
        statement contained. 
 
        .. note:: it is typically preferable to build a :class:`_sql.Select` 
           statement first, including the desired WHERE clause, then use the 
           :meth:`_sql.SelectBase.exists` method to produce an 
           :class:`_sql.Exists` object at once. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">e </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_clone</span><span class="s4">()</span>
        <span class="s1">e</span><span class="s4">.</span><span class="s1">element </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_regroup</span><span class="s4">(</span><span class="s3">lambda </span><span class="s1">element</span><span class="s4">: </span><span class="s1">element</span><span class="s4">.</span><span class="s1">select_from</span><span class="s4">(*</span><span class="s1">froms</span><span class="s4">))</span>
        <span class="s3">return </span><span class="s1">e</span>

    <span class="s3">def </span><span class="s1">where</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, *</span><span class="s1">clause</span><span class="s4">: </span><span class="s1">_ColumnExpressionArgument</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">]) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Return a new :func:`_expression.exists` construct with the 
        given expression added to 
        its WHERE clause, joined to the existing clause via AND, if any. 
 
 
        .. note:: it is typically preferable to build a :class:`_sql.Select` 
           statement first, including the desired WHERE clause, then use the 
           :meth:`_sql.SelectBase.exists` method to produce an 
           :class:`_sql.Exists` object at once. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">e </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_clone</span><span class="s4">()</span>
        <span class="s1">e</span><span class="s4">.</span><span class="s1">element </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_regroup</span><span class="s4">(</span><span class="s3">lambda </span><span class="s1">element</span><span class="s4">: </span><span class="s1">element</span><span class="s4">.</span><span class="s1">where</span><span class="s4">(*</span><span class="s1">clause</span><span class="s4">))</span>
        <span class="s3">return </span><span class="s1">e</span>


<span class="s3">class </span><span class="s1">TextualSelect</span><span class="s4">(</span><span class="s1">SelectBase</span><span class="s4">, </span><span class="s1">ExecutableReturnsRows</span><span class="s4">, </span><span class="s1">Generative</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Wrap a :class:`_expression.TextClause` construct within a 
    :class:`_expression.SelectBase` 
    interface. 
 
    This allows the :class:`_expression.TextClause` object to gain a 
    ``.c`` collection 
    and other FROM-like capabilities such as 
    :meth:`_expression.FromClause.alias`, 
    :meth:`_expression.SelectBase.cte`, etc. 
 
    The :class:`_expression.TextualSelect` construct is produced via the 
    :meth:`_expression.TextClause.columns` 
    method - see that method for details. 
 
    .. versionchanged:: 1.4 the :class:`_expression.TextualSelect` 
       class was renamed 
       from ``TextAsFrom``, to more correctly suit its role as a 
       SELECT-oriented object and not a FROM clause. 
 
    .. seealso:: 
 
        :func:`_expression.text` 
 
        :meth:`_expression.TextClause.columns` - primary creation interface. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;textual_select&quot;</span>

    <span class="s1">_label_style </span><span class="s4">= </span><span class="s1">LABEL_STYLE_NONE</span>

    <span class="s1">_traverse_internals</span><span class="s4">: </span><span class="s1">_TraverseInternalsType </span><span class="s4">= (</span>
        <span class="s4">[</span>
            <span class="s4">(</span><span class="s5">&quot;element&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_clauseelement</span><span class="s4">),</span>
            <span class="s4">(</span><span class="s5">&quot;column_args&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_clauseelement_list</span><span class="s4">),</span>
        <span class="s4">]</span>
        <span class="s4">+ </span><span class="s1">SupportsCloneAnnotations</span><span class="s4">.</span><span class="s1">_clone_annotations_traverse_internals</span>
        <span class="s4">+ </span><span class="s1">HasCTE</span><span class="s4">.</span><span class="s1">_has_ctes_traverse_internals</span>
    <span class="s4">)</span>

    <span class="s1">_is_textual </span><span class="s4">= </span><span class="s3">True</span>

    <span class="s1">is_text </span><span class="s4">= </span><span class="s3">True</span>
    <span class="s1">is_select </span><span class="s4">= </span><span class="s3">True</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">text</span><span class="s4">: </span><span class="s1">TextClause</span><span class="s4">,</span>
        <span class="s1">columns</span><span class="s4">: </span><span class="s1">List</span><span class="s4">[</span><span class="s1">_ColumnExpressionArgument</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]],</span>
        <span class="s1">positional</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_init</span><span class="s4">(</span>
            <span class="s1">text</span><span class="s4">,</span>
            <span class="s0"># convert for ORM attributes-&gt;columns, etc</span>
            <span class="s4">[</span>
                <span class="s1">coercions</span><span class="s4">.</span><span class="s1">expect</span><span class="s4">(</span><span class="s1">roles</span><span class="s4">.</span><span class="s1">LabeledColumnExprRole</span><span class="s4">, </span><span class="s1">c</span><span class="s4">)</span>
                <span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">columns</span>
            <span class="s4">],</span>
            <span class="s1">positional</span><span class="s4">,</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_init</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">text</span><span class="s4">: </span><span class="s1">TextClause</span><span class="s4">,</span>
        <span class="s1">columns</span><span class="s4">: </span><span class="s1">List</span><span class="s4">[</span><span class="s1">NamedColumn</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]],</span>
        <span class="s1">positional</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">element </span><span class="s4">= </span><span class="s1">text</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">column_args </span><span class="s4">= </span><span class="s1">columns</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">positional </span><span class="s4">= </span><span class="s1">positional</span>

    <span class="s4">@</span><span class="s1">HasMemoized_ro_memoized_attribute</span>
    <span class="s3">def </span><span class="s1">selected_columns</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; ColumnCollection</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">KeyedColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]:</span>
        <span class="s2">&quot;&quot;&quot;A :class:`_expression.ColumnCollection` 
        representing the columns that 
        this SELECT statement or similar construct returns in its result set, 
        not including :class:`_sql.TextClause` constructs. 
 
        This collection differs from the :attr:`_expression.FromClause.columns` 
        collection of a :class:`_expression.FromClause` in that the columns 
        within this collection cannot be directly nested inside another SELECT 
        statement; a subquery must be applied first which provides for the 
        necessary parenthesization required by SQL. 
 
        For a :class:`_expression.TextualSelect` construct, the collection 
        contains the :class:`_expression.ColumnElement` objects that were 
        passed to the constructor, typically via the 
        :meth:`_expression.TextClause.columns` method. 
 
 
        .. versionadded:: 1.4 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">ColumnCollection</span><span class="s4">(</span>
            <span class="s4">(</span><span class="s1">c</span><span class="s4">.</span><span class="s1">key</span><span class="s4">, </span><span class="s1">c</span><span class="s4">) </span><span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">column_args</span>
        <span class="s4">).</span><span class="s1">as_readonly</span><span class="s4">()</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">ro_non_memoized_property</span>
    <span class="s3">def </span><span class="s1">_all_selected_columns</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; _SelectIterable</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">column_args</span>

    <span class="s3">def </span><span class="s1">set_label_style</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">style</span><span class="s4">: </span><span class="s1">SelectLabelStyle</span><span class="s4">) </span><span class="s1">-&gt; TextualSelect</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">_ensure_disambiguated_names</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; TextualSelect</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s4">@</span><span class="s1">_generative</span>
    <span class="s3">def </span><span class="s1">bindparams</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s4">*</span><span class="s1">binds</span><span class="s4">: </span><span class="s1">BindParameter</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">],</span>
        <span class="s4">**</span><span class="s1">bind_as_values</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">element </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">element</span><span class="s4">.</span><span class="s1">bindparams</span><span class="s4">(*</span><span class="s1">binds</span><span class="s4">, **</span><span class="s1">bind_as_values</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">_generate_fromclause_column_proxies</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">fromclause</span><span class="s4">: </span><span class="s1">FromClause</span><span class="s4">,</span>
        <span class="s4">*,</span>
        <span class="s1">proxy_compound_columns</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span>
            <span class="s1">Iterable</span><span class="s4">[</span><span class="s1">Sequence</span><span class="s4">[</span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]]</span>
        <span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">TYPE_CHECKING</span><span class="s4">:</span>
            <span class="s3">assert </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">fromclause</span><span class="s4">, </span><span class="s1">Subquery</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s1">proxy_compound_columns</span><span class="s4">:</span>
            <span class="s1">fromclause</span><span class="s4">.</span><span class="s1">_columns</span><span class="s4">.</span><span class="s1">_populate_separate_keys</span><span class="s4">(</span>
                <span class="s1">c</span><span class="s4">.</span><span class="s1">_make_proxy</span><span class="s4">(</span><span class="s1">fromclause</span><span class="s4">, </span><span class="s1">compound_select_cols</span><span class="s4">=</span><span class="s1">extra_cols</span><span class="s4">)</span>
                <span class="s3">for </span><span class="s1">c</span><span class="s4">, </span><span class="s1">extra_cols </span><span class="s3">in </span><span class="s1">zip</span><span class="s4">(</span>
                    <span class="s1">self</span><span class="s4">.</span><span class="s1">column_args</span><span class="s4">, </span><span class="s1">proxy_compound_columns</span>
                <span class="s4">)</span>
            <span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">fromclause</span><span class="s4">.</span><span class="s1">_columns</span><span class="s4">.</span><span class="s1">_populate_separate_keys</span><span class="s4">(</span>
                <span class="s1">c</span><span class="s4">.</span><span class="s1">_make_proxy</span><span class="s4">(</span><span class="s1">fromclause</span><span class="s4">) </span><span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">column_args</span>
            <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_scalar_type</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Union</span><span class="s4">[</span><span class="s1">TypeEngine</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">], </span><span class="s1">Any</span><span class="s4">]:</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">column_args</span><span class="s4">[</span><span class="s6">0</span><span class="s4">].</span><span class="s1">type</span>


<span class="s1">TextAsFrom </span><span class="s4">= </span><span class="s1">TextualSelect</span>
<span class="s5">&quot;&quot;&quot;Backwards compatibility with the previous name&quot;&quot;&quot;</span>


<span class="s3">class </span><span class="s1">AnnotatedFromClause</span><span class="s4">(</span><span class="s1">Annotated</span><span class="s4">):</span>
    <span class="s3">def </span><span class="s1">_copy_internals</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s1">super</span><span class="s4">().</span><span class="s1">_copy_internals</span><span class="s4">(**</span><span class="s1">kw</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">kw</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s5">&quot;ind_cols_on_fromclause&quot;</span><span class="s4">, </span><span class="s3">False</span><span class="s4">):</span>
            <span class="s1">ee </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_Annotated__element  </span><span class="s0"># type: ignore</span>

            <span class="s1">self</span><span class="s4">.</span><span class="s1">c </span><span class="s4">= </span><span class="s1">ee</span><span class="s4">.</span><span class="s1">__class__</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">fget</span><span class="s4">(</span><span class="s1">self</span><span class="s4">)  </span><span class="s0"># type: ignore</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">ro_memoized_property</span>
    <span class="s3">def </span><span class="s1">c</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; ReadOnlyColumnCollection</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">KeyedColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]:</span>
        <span class="s2">&quot;&quot;&quot;proxy the .c collection of the underlying FromClause. 
 
        Originally implemented in 2008 as a simple load of the .c collection 
        when the annotated construct was created (see d3621ae961a), in modern 
        SQLAlchemy versions this can be expensive for statements constructed 
        with ORM aliases.   So for #8796 SQLAlchemy 2.0 we instead proxy 
        it, which works just as well. 
 
        Two different use cases seem to require the collection either copied 
        from the underlying one, or unique to this AnnotatedFromClause. 
 
        See test_selectable-&gt;test_annotated_corresponding_column 
 
        &quot;&quot;&quot;</span>
        <span class="s1">ee </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_Annotated__element  </span><span class="s0"># type: ignore</span>
        <span class="s3">return </span><span class="s1">ee</span><span class="s4">.</span><span class="s1">c  </span><span class="s0"># type: ignore</span>
</pre>
</body>
</html>