<html>
<head>
<title>_decomp_qz.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #6aab73;}
.s4 { color: #7a7e85;}
.s5 { color: #2aacb8;}
.s6 { color: #5f826b; font-style: italic;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_decomp_qz.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">warnings</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">from </span><span class="s1">numpy </span><span class="s0">import </span><span class="s1">asarray_chkfinite</span>
<span class="s0">from </span><span class="s2">.</span><span class="s1">_misc </span><span class="s0">import </span><span class="s1">LinAlgError</span><span class="s2">, </span><span class="s1">_datacopied</span><span class="s2">, </span><span class="s1">LinAlgWarning</span>
<span class="s0">from </span><span class="s2">.</span><span class="s1">lapack </span><span class="s0">import </span><span class="s1">get_lapack_funcs</span>


<span class="s1">__all__ </span><span class="s2">= [</span><span class="s3">'qz'</span><span class="s2">, </span><span class="s3">'ordqz'</span><span class="s2">]</span>

<span class="s1">_double_precision </span><span class="s2">= [</span><span class="s3">'i'</span><span class="s2">, </span><span class="s3">'l'</span><span class="s2">, </span><span class="s3">'d'</span><span class="s2">]</span>


<span class="s0">def </span><span class="s1">_select_function</span><span class="s2">(</span><span class="s1">sort</span><span class="s2">):</span>
    <span class="s0">if </span><span class="s1">callable</span><span class="s2">(</span><span class="s1">sort</span><span class="s2">):</span>
        <span class="s4"># assume the user knows what they're doing</span>
        <span class="s1">sfunction </span><span class="s2">= </span><span class="s1">sort</span>
    <span class="s0">elif </span><span class="s1">sort </span><span class="s2">== </span><span class="s3">'lhp'</span><span class="s2">:</span>
        <span class="s1">sfunction </span><span class="s2">= </span><span class="s1">_lhp</span>
    <span class="s0">elif </span><span class="s1">sort </span><span class="s2">== </span><span class="s3">'rhp'</span><span class="s2">:</span>
        <span class="s1">sfunction </span><span class="s2">= </span><span class="s1">_rhp</span>
    <span class="s0">elif </span><span class="s1">sort </span><span class="s2">== </span><span class="s3">'iuc'</span><span class="s2">:</span>
        <span class="s1">sfunction </span><span class="s2">= </span><span class="s1">_iuc</span>
    <span class="s0">elif </span><span class="s1">sort </span><span class="s2">== </span><span class="s3">'ouc'</span><span class="s2">:</span>
        <span class="s1">sfunction </span><span class="s2">= </span><span class="s1">_ouc</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;sort parameter must be None, a callable, or &quot;</span>
                         <span class="s3">&quot;one of ('lhp','rhp','iuc','ouc')&quot;</span><span class="s2">)</span>

    <span class="s0">return </span><span class="s1">sfunction</span>


<span class="s0">def </span><span class="s1">_lhp</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">):</span>
    <span class="s1">out </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty_like</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">bool</span><span class="s2">)</span>
    <span class="s1">nonzero </span><span class="s2">= (</span><span class="s1">y </span><span class="s2">!= </span><span class="s5">0</span><span class="s2">)</span>
    <span class="s4"># handles (x, y) = (0, 0) too</span>
    <span class="s1">out</span><span class="s2">[~</span><span class="s1">nonzero</span><span class="s2">] = </span><span class="s0">False</span>
    <span class="s1">out</span><span class="s2">[</span><span class="s1">nonzero</span><span class="s2">] = (</span><span class="s1">np</span><span class="s2">.</span><span class="s1">real</span><span class="s2">(</span><span class="s1">x</span><span class="s2">[</span><span class="s1">nonzero</span><span class="s2">]/</span><span class="s1">y</span><span class="s2">[</span><span class="s1">nonzero</span><span class="s2">]) &lt; </span><span class="s5">0.0</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">out</span>


<span class="s0">def </span><span class="s1">_rhp</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">):</span>
    <span class="s1">out </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty_like</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">bool</span><span class="s2">)</span>
    <span class="s1">nonzero </span><span class="s2">= (</span><span class="s1">y </span><span class="s2">!= </span><span class="s5">0</span><span class="s2">)</span>
    <span class="s4"># handles (x, y) = (0, 0) too</span>
    <span class="s1">out</span><span class="s2">[~</span><span class="s1">nonzero</span><span class="s2">] = </span><span class="s0">False</span>
    <span class="s1">out</span><span class="s2">[</span><span class="s1">nonzero</span><span class="s2">] = (</span><span class="s1">np</span><span class="s2">.</span><span class="s1">real</span><span class="s2">(</span><span class="s1">x</span><span class="s2">[</span><span class="s1">nonzero</span><span class="s2">]/</span><span class="s1">y</span><span class="s2">[</span><span class="s1">nonzero</span><span class="s2">]) &gt; </span><span class="s5">0.0</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">out</span>


<span class="s0">def </span><span class="s1">_iuc</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">):</span>
    <span class="s1">out </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty_like</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">bool</span><span class="s2">)</span>
    <span class="s1">nonzero </span><span class="s2">= (</span><span class="s1">y </span><span class="s2">!= </span><span class="s5">0</span><span class="s2">)</span>
    <span class="s4"># handles (x, y) = (0, 0) too</span>
    <span class="s1">out</span><span class="s2">[~</span><span class="s1">nonzero</span><span class="s2">] = </span><span class="s0">False</span>
    <span class="s1">out</span><span class="s2">[</span><span class="s1">nonzero</span><span class="s2">] = (</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">x</span><span class="s2">[</span><span class="s1">nonzero</span><span class="s2">]/</span><span class="s1">y</span><span class="s2">[</span><span class="s1">nonzero</span><span class="s2">]) &lt; </span><span class="s5">1.0</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">out</span>


<span class="s0">def </span><span class="s1">_ouc</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">):</span>
    <span class="s1">out </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty_like</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">bool</span><span class="s2">)</span>
    <span class="s1">xzero </span><span class="s2">= (</span><span class="s1">x </span><span class="s2">== </span><span class="s5">0</span><span class="s2">)</span>
    <span class="s1">yzero </span><span class="s2">= (</span><span class="s1">y </span><span class="s2">== </span><span class="s5">0</span><span class="s2">)</span>
    <span class="s1">out</span><span class="s2">[</span><span class="s1">xzero </span><span class="s2">&amp; </span><span class="s1">yzero</span><span class="s2">] = </span><span class="s0">False</span>
    <span class="s1">out</span><span class="s2">[~</span><span class="s1">xzero </span><span class="s2">&amp; </span><span class="s1">yzero</span><span class="s2">] = </span><span class="s0">True</span>
    <span class="s1">out</span><span class="s2">[~</span><span class="s1">yzero</span><span class="s2">] = (</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">x</span><span class="s2">[~</span><span class="s1">yzero</span><span class="s2">]/</span><span class="s1">y</span><span class="s2">[~</span><span class="s1">yzero</span><span class="s2">]) &gt; </span><span class="s5">1.0</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">out</span>


<span class="s0">def </span><span class="s1">_qz</span><span class="s2">(</span><span class="s1">A</span><span class="s2">, </span><span class="s1">B</span><span class="s2">, </span><span class="s1">output</span><span class="s2">=</span><span class="s3">'real'</span><span class="s2">, </span><span class="s1">lwork</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">sort</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">overwrite_a</span><span class="s2">=</span><span class="s0">False</span><span class="s2">,</span>
        <span class="s1">overwrite_b</span><span class="s2">=</span><span class="s0">False</span><span class="s2">, </span><span class="s1">check_finite</span><span class="s2">=</span><span class="s0">True</span><span class="s2">):</span>
    <span class="s0">if </span><span class="s1">sort </span><span class="s0">is not None</span><span class="s2">:</span>
        <span class="s4"># Disabled due to segfaults on win32, see ticket 1717.</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;The 'sort' input of qz() has to be None and will be &quot;</span>
                         <span class="s3">&quot;removed in a future release. Use ordqz instead.&quot;</span><span class="s2">)</span>

    <span class="s0">if </span><span class="s1">output </span><span class="s0">not in </span><span class="s2">[</span><span class="s3">'real'</span><span class="s2">, </span><span class="s3">'complex'</span><span class="s2">, </span><span class="s3">'r'</span><span class="s2">, </span><span class="s3">'c'</span><span class="s2">]:</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;argument must be 'real', or 'complex'&quot;</span><span class="s2">)</span>

    <span class="s0">if </span><span class="s1">check_finite</span><span class="s2">:</span>
        <span class="s1">a1 </span><span class="s2">= </span><span class="s1">asarray_chkfinite</span><span class="s2">(</span><span class="s1">A</span><span class="s2">)</span>
        <span class="s1">b1 </span><span class="s2">= </span><span class="s1">asarray_chkfinite</span><span class="s2">(</span><span class="s1">B</span><span class="s2">)</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">a1 </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">A</span><span class="s2">)</span>
        <span class="s1">b1 </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">B</span><span class="s2">)</span>

    <span class="s1">a_m</span><span class="s2">, </span><span class="s1">a_n </span><span class="s2">= </span><span class="s1">a1</span><span class="s2">.</span><span class="s1">shape</span>
    <span class="s1">b_m</span><span class="s2">, </span><span class="s1">b_n </span><span class="s2">= </span><span class="s1">b1</span><span class="s2">.</span><span class="s1">shape</span>
    <span class="s0">if not </span><span class="s2">(</span><span class="s1">a_m </span><span class="s2">== </span><span class="s1">a_n </span><span class="s2">== </span><span class="s1">b_m </span><span class="s2">== </span><span class="s1">b_n</span><span class="s2">):</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;Array dimensions must be square and agree&quot;</span><span class="s2">)</span>

    <span class="s1">typa </span><span class="s2">= </span><span class="s1">a1</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">char</span>
    <span class="s0">if </span><span class="s1">output </span><span class="s0">in </span><span class="s2">[</span><span class="s3">'complex'</span><span class="s2">, </span><span class="s3">'c'</span><span class="s2">] </span><span class="s0">and </span><span class="s1">typa </span><span class="s0">not in </span><span class="s2">[</span><span class="s3">'F'</span><span class="s2">, </span><span class="s3">'D'</span><span class="s2">]:</span>
        <span class="s0">if </span><span class="s1">typa </span><span class="s0">in </span><span class="s1">_double_precision</span><span class="s2">:</span>
            <span class="s1">a1 </span><span class="s2">= </span><span class="s1">a1</span><span class="s2">.</span><span class="s1">astype</span><span class="s2">(</span><span class="s3">'D'</span><span class="s2">)</span>
            <span class="s1">typa </span><span class="s2">= </span><span class="s3">'D'</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">a1 </span><span class="s2">= </span><span class="s1">a1</span><span class="s2">.</span><span class="s1">astype</span><span class="s2">(</span><span class="s3">'F'</span><span class="s2">)</span>
            <span class="s1">typa </span><span class="s2">= </span><span class="s3">'F'</span>
    <span class="s1">typb </span><span class="s2">= </span><span class="s1">b1</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">char</span>
    <span class="s0">if </span><span class="s1">output </span><span class="s0">in </span><span class="s2">[</span><span class="s3">'complex'</span><span class="s2">, </span><span class="s3">'c'</span><span class="s2">] </span><span class="s0">and </span><span class="s1">typb </span><span class="s0">not in </span><span class="s2">[</span><span class="s3">'F'</span><span class="s2">, </span><span class="s3">'D'</span><span class="s2">]:</span>
        <span class="s0">if </span><span class="s1">typb </span><span class="s0">in </span><span class="s1">_double_precision</span><span class="s2">:</span>
            <span class="s1">b1 </span><span class="s2">= </span><span class="s1">b1</span><span class="s2">.</span><span class="s1">astype</span><span class="s2">(</span><span class="s3">'D'</span><span class="s2">)</span>
            <span class="s1">typb </span><span class="s2">= </span><span class="s3">'D'</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">b1 </span><span class="s2">= </span><span class="s1">b1</span><span class="s2">.</span><span class="s1">astype</span><span class="s2">(</span><span class="s3">'F'</span><span class="s2">)</span>
            <span class="s1">typb </span><span class="s2">= </span><span class="s3">'F'</span>

    <span class="s1">overwrite_a </span><span class="s2">= </span><span class="s1">overwrite_a </span><span class="s0">or </span><span class="s2">(</span><span class="s1">_datacopied</span><span class="s2">(</span><span class="s1">a1</span><span class="s2">, </span><span class="s1">A</span><span class="s2">))</span>
    <span class="s1">overwrite_b </span><span class="s2">= </span><span class="s1">overwrite_b </span><span class="s0">or </span><span class="s2">(</span><span class="s1">_datacopied</span><span class="s2">(</span><span class="s1">b1</span><span class="s2">, </span><span class="s1">B</span><span class="s2">))</span>

    <span class="s1">gges</span><span class="s2">, = </span><span class="s1">get_lapack_funcs</span><span class="s2">((</span><span class="s3">'gges'</span><span class="s2">,), (</span><span class="s1">a1</span><span class="s2">, </span><span class="s1">b1</span><span class="s2">))</span>

    <span class="s0">if </span><span class="s1">lwork </span><span class="s0">is None or </span><span class="s1">lwork </span><span class="s2">== -</span><span class="s5">1</span><span class="s2">:</span>
        <span class="s4"># get optimal work array size</span>
        <span class="s1">result </span><span class="s2">= </span><span class="s1">gges</span><span class="s2">(</span><span class="s0">lambda </span><span class="s1">x</span><span class="s2">: </span><span class="s0">None</span><span class="s2">, </span><span class="s1">a1</span><span class="s2">, </span><span class="s1">b1</span><span class="s2">, </span><span class="s1">lwork</span><span class="s2">=-</span><span class="s5">1</span><span class="s2">)</span>
        <span class="s1">lwork </span><span class="s2">= </span><span class="s1">result</span><span class="s2">[-</span><span class="s5">2</span><span class="s2">][</span><span class="s5">0</span><span class="s2">].</span><span class="s1">real</span><span class="s2">.</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">int</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">sfunction</span><span class="s2">(</span><span class="s1">x</span><span class="s2">):</span>
        <span class="s0">return None</span>
    <span class="s1">result </span><span class="s2">= </span><span class="s1">gges</span><span class="s2">(</span><span class="s1">sfunction</span><span class="s2">, </span><span class="s1">a1</span><span class="s2">, </span><span class="s1">b1</span><span class="s2">, </span><span class="s1">lwork</span><span class="s2">=</span><span class="s1">lwork</span><span class="s2">, </span><span class="s1">overwrite_a</span><span class="s2">=</span><span class="s1">overwrite_a</span><span class="s2">,</span>
                  <span class="s1">overwrite_b</span><span class="s2">=</span><span class="s1">overwrite_b</span><span class="s2">, </span><span class="s1">sort_t</span><span class="s2">=</span><span class="s5">0</span><span class="s2">)</span>

    <span class="s1">info </span><span class="s2">= </span><span class="s1">result</span><span class="s2">[-</span><span class="s5">1</span><span class="s2">]</span>
    <span class="s0">if </span><span class="s1">info </span><span class="s2">&lt; </span><span class="s5">0</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">f&quot;Illegal value in argument </span><span class="s0">{</span><span class="s2">-</span><span class="s1">info</span><span class="s0">} </span><span class="s3">of gges&quot;</span><span class="s2">)</span>
    <span class="s0">elif </span><span class="s1">info </span><span class="s2">&gt; </span><span class="s5">0 </span><span class="s0">and </span><span class="s1">info </span><span class="s2">&lt;= </span><span class="s1">a_n</span><span class="s2">:</span>
        <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span><span class="s3">&quot;The QZ iteration failed. (a,b) are not in Schur &quot;</span>
                      <span class="s3">&quot;form, but ALPHAR(j), ALPHAI(j), and BETA(j) should be &quot;</span>
                      <span class="s3">f&quot;correct for J=</span><span class="s0">{</span><span class="s1">info</span><span class="s2">-</span><span class="s5">1</span><span class="s0">}</span><span class="s3">,...,N&quot;</span><span class="s2">, </span><span class="s1">LinAlgWarning</span><span class="s2">,</span>
                      <span class="s1">stacklevel</span><span class="s2">=</span><span class="s5">3</span><span class="s2">)</span>
    <span class="s0">elif </span><span class="s1">info </span><span class="s2">== </span><span class="s1">a_n</span><span class="s2">+</span><span class="s5">1</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">LinAlgError</span><span class="s2">(</span><span class="s3">&quot;Something other than QZ iteration failed&quot;</span><span class="s2">)</span>
    <span class="s0">elif </span><span class="s1">info </span><span class="s2">== </span><span class="s1">a_n</span><span class="s2">+</span><span class="s5">2</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">LinAlgError</span><span class="s2">(</span><span class="s3">&quot;After reordering, roundoff changed values of some &quot;</span>
                          <span class="s3">&quot;complex eigenvalues so that leading eigenvalues &quot;</span>
                          <span class="s3">&quot;in the Generalized Schur form no longer satisfy &quot;</span>
                          <span class="s3">&quot;sort=True. This could also be due to scaling.&quot;</span><span class="s2">)</span>
    <span class="s0">elif </span><span class="s1">info </span><span class="s2">== </span><span class="s1">a_n</span><span class="s2">+</span><span class="s5">3</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">LinAlgError</span><span class="s2">(</span><span class="s3">&quot;Reordering failed in &lt;s,d,c,z&gt;tgsen&quot;</span><span class="s2">)</span>

    <span class="s0">return </span><span class="s1">result</span><span class="s2">, </span><span class="s1">gges</span><span class="s2">.</span><span class="s1">typecode</span>


<span class="s0">def </span><span class="s1">qz</span><span class="s2">(</span><span class="s1">A</span><span class="s2">, </span><span class="s1">B</span><span class="s2">, </span><span class="s1">output</span><span class="s2">=</span><span class="s3">'real'</span><span class="s2">, </span><span class="s1">lwork</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">sort</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">overwrite_a</span><span class="s2">=</span><span class="s0">False</span><span class="s2">,</span>
       <span class="s1">overwrite_b</span><span class="s2">=</span><span class="s0">False</span><span class="s2">, </span><span class="s1">check_finite</span><span class="s2">=</span><span class="s0">True</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    QZ decomposition for generalized eigenvalues of a pair of matrices. 
 
    The QZ, or generalized Schur, decomposition for a pair of n-by-n 
    matrices (A,B) is:: 
 
        (A,B) = (Q @ AA @ Z*, Q @ BB @ Z*) 
 
    where AA, BB is in generalized Schur form if BB is upper-triangular 
    with non-negative diagonal and AA is upper-triangular, or for real QZ 
    decomposition (``output='real'``) block upper triangular with 1x1 
    and 2x2 blocks. In this case, the 1x1 blocks correspond to real 
    generalized eigenvalues and 2x2 blocks are 'standardized' by making 
    the corresponding elements of BB have the form:: 
 
        [ a 0 ] 
        [ 0 b ] 
 
    and the pair of corresponding 2x2 blocks in AA and BB will have a complex 
    conjugate pair of generalized eigenvalues. If (``output='complex'``) or 
    A and B are complex matrices, Z' denotes the conjugate-transpose of Z. 
    Q and Z are unitary matrices. 
 
    Parameters 
    ---------- 
    A : (N, N) array_like 
        2-D array to decompose 
    B : (N, N) array_like 
        2-D array to decompose 
    output : {'real', 'complex'}, optional 
        Construct the real or complex QZ decomposition for real matrices. 
        Default is 'real'. 
    lwork : int, optional 
        Work array size. If None or -1, it is automatically computed. 
    sort : {None, callable, 'lhp', 'rhp', 'iuc', 'ouc'}, optional 
        NOTE: THIS INPUT IS DISABLED FOR NOW. Use ordqz instead. 
 
        Specifies whether the upper eigenvalues should be sorted. A callable 
        may be passed that, given a eigenvalue, returns a boolean denoting 
        whether the eigenvalue should be sorted to the top-left (True). For 
        real matrix pairs, the sort function takes three real arguments 
        (alphar, alphai, beta). The eigenvalue 
        ``x = (alphar + alphai*1j)/beta``. For complex matrix pairs or 
        output='complex', the sort function takes two complex arguments 
        (alpha, beta). The eigenvalue ``x = (alpha/beta)``.  Alternatively, 
        string parameters may be used: 
 
            - 'lhp'   Left-hand plane (x.real &lt; 0.0) 
            - 'rhp'   Right-hand plane (x.real &gt; 0.0) 
            - 'iuc'   Inside the unit circle (x*x.conjugate() &lt; 1.0) 
            - 'ouc'   Outside the unit circle (x*x.conjugate() &gt; 1.0) 
 
        Defaults to None (no sorting). 
    overwrite_a : bool, optional 
        Whether to overwrite data in a (may improve performance) 
    overwrite_b : bool, optional 
        Whether to overwrite data in b (may improve performance) 
    check_finite : bool, optional 
        If true checks the elements of `A` and `B` are finite numbers. If 
        false does no checking and passes matrix through to 
        underlying algorithm. 
 
    Returns 
    ------- 
    AA : (N, N) ndarray 
        Generalized Schur form of A. 
    BB : (N, N) ndarray 
        Generalized Schur form of B. 
    Q : (N, N) ndarray 
        The left Schur vectors. 
    Z : (N, N) ndarray 
        The right Schur vectors. 
 
    See Also 
    -------- 
    ordqz 
 
    Notes 
    ----- 
    Q is transposed versus the equivalent function in Matlab. 
 
    .. versionadded:: 0.11.0 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.linalg import qz 
 
    &gt;&gt;&gt; A = np.array([[1, 2, -1], [5, 5, 5], [2, 4, -8]]) 
    &gt;&gt;&gt; B = np.array([[1, 1, -3], [3, 1, -1], [5, 6, -2]]) 
 
    Compute the decomposition.  The QZ decomposition is not unique, so 
    depending on the underlying library that is used, there may be 
    differences in the signs of coefficients in the following output. 
 
    &gt;&gt;&gt; AA, BB, Q, Z = qz(A, B) 
    &gt;&gt;&gt; AA 
    array([[-1.36949157, -4.05459025,  7.44389431], 
           [ 0.        ,  7.65653432,  5.13476017], 
           [ 0.        , -0.65978437,  2.4186015 ]])  # may vary 
    &gt;&gt;&gt; BB 
    array([[ 1.71890633, -1.64723705, -0.72696385], 
           [ 0.        ,  8.6965692 , -0.        ], 
           [ 0.        ,  0.        ,  2.27446233]])  # may vary 
    &gt;&gt;&gt; Q 
    array([[-0.37048362,  0.1903278 ,  0.90912992], 
           [-0.90073232,  0.16534124, -0.40167593], 
           [ 0.22676676,  0.96769706, -0.11017818]])  # may vary 
    &gt;&gt;&gt; Z 
    array([[-0.67660785,  0.63528924, -0.37230283], 
           [ 0.70243299,  0.70853819, -0.06753907], 
           [ 0.22088393, -0.30721526, -0.92565062]])  # may vary 
 
    Verify the QZ decomposition.  With real output, we only need the 
    transpose of ``Z`` in the following expressions. 
 
    &gt;&gt;&gt; Q @ AA @ Z.T  # Should be A 
    array([[ 1.,  2., -1.], 
           [ 5.,  5.,  5.], 
           [ 2.,  4., -8.]]) 
    &gt;&gt;&gt; Q @ BB @ Z.T  # Should be B 
    array([[ 1.,  1., -3.], 
           [ 3.,  1., -1.], 
           [ 5.,  6., -2.]]) 
 
    Repeat the decomposition, but with ``output='complex'``. 
 
    &gt;&gt;&gt; AA, BB, Q, Z = qz(A, B, output='complex') 
 
    For conciseness in the output, we use ``np.set_printoptions()`` to set 
    the output precision of NumPy arrays to 3 and display tiny values as 0. 
 
    &gt;&gt;&gt; np.set_printoptions(precision=3, suppress=True) 
    &gt;&gt;&gt; AA 
    array([[-1.369+0.j   ,  2.248+4.237j,  4.861-5.022j], 
           [ 0.   +0.j   ,  7.037+2.922j,  0.794+4.932j], 
           [ 0.   +0.j   ,  0.   +0.j   ,  2.655-1.103j]])  # may vary 
    &gt;&gt;&gt; BB 
    array([[ 1.719+0.j   , -1.115+1.j   , -0.763-0.646j], 
           [ 0.   +0.j   ,  7.24 +0.j   , -3.144+3.322j], 
           [ 0.   +0.j   ,  0.   +0.j   ,  2.732+0.j   ]])  # may vary 
    &gt;&gt;&gt; Q 
    array([[ 0.326+0.175j, -0.273-0.029j, -0.886-0.052j], 
           [ 0.794+0.426j, -0.093+0.134j,  0.402-0.02j ], 
           [-0.2  -0.107j, -0.816+0.482j,  0.151-0.167j]])  # may vary 
    &gt;&gt;&gt; Z 
    array([[ 0.596+0.32j , -0.31 +0.414j,  0.393-0.347j], 
           [-0.619-0.332j, -0.479+0.314j,  0.154-0.393j], 
           [-0.195-0.104j,  0.576+0.27j ,  0.715+0.187j]])  # may vary 
 
    With complex arrays, we must use ``Z.conj().T`` in the following 
    expressions to verify the decomposition. 
 
    &gt;&gt;&gt; Q @ AA @ Z.conj().T  # Should be A 
    array([[ 1.-0.j,  2.-0.j, -1.-0.j], 
           [ 5.+0.j,  5.+0.j,  5.-0.j], 
           [ 2.+0.j,  4.+0.j, -8.+0.j]]) 
    &gt;&gt;&gt; Q @ BB @ Z.conj().T  # Should be B 
    array([[ 1.+0.j,  1.+0.j, -3.+0.j], 
           [ 3.-0.j,  1.-0.j, -1.+0.j], 
           [ 5.+0.j,  6.+0.j, -2.+0.j]]) 
 
    &quot;&quot;&quot;</span>
    <span class="s4"># output for real</span>
    <span class="s4"># AA, BB, sdim, alphar, alphai, beta, vsl, vsr, work, info</span>
    <span class="s4"># output for complex</span>
    <span class="s4"># AA, BB, sdim, alpha, beta, vsl, vsr, work, info</span>
    <span class="s1">result</span><span class="s2">, </span><span class="s1">_ </span><span class="s2">= </span><span class="s1">_qz</span><span class="s2">(</span><span class="s1">A</span><span class="s2">, </span><span class="s1">B</span><span class="s2">, </span><span class="s1">output</span><span class="s2">=</span><span class="s1">output</span><span class="s2">, </span><span class="s1">lwork</span><span class="s2">=</span><span class="s1">lwork</span><span class="s2">, </span><span class="s1">sort</span><span class="s2">=</span><span class="s1">sort</span><span class="s2">,</span>
                    <span class="s1">overwrite_a</span><span class="s2">=</span><span class="s1">overwrite_a</span><span class="s2">, </span><span class="s1">overwrite_b</span><span class="s2">=</span><span class="s1">overwrite_b</span><span class="s2">,</span>
                    <span class="s1">check_finite</span><span class="s2">=</span><span class="s1">check_finite</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">result</span><span class="s2">[</span><span class="s5">0</span><span class="s2">], </span><span class="s1">result</span><span class="s2">[</span><span class="s5">1</span><span class="s2">], </span><span class="s1">result</span><span class="s2">[-</span><span class="s5">4</span><span class="s2">], </span><span class="s1">result</span><span class="s2">[-</span><span class="s5">3</span><span class="s2">]</span>


<span class="s0">def </span><span class="s1">ordqz</span><span class="s2">(</span><span class="s1">A</span><span class="s2">, </span><span class="s1">B</span><span class="s2">, </span><span class="s1">sort</span><span class="s2">=</span><span class="s3">'lhp'</span><span class="s2">, </span><span class="s1">output</span><span class="s2">=</span><span class="s3">'real'</span><span class="s2">, </span><span class="s1">overwrite_a</span><span class="s2">=</span><span class="s0">False</span><span class="s2">,</span>
          <span class="s1">overwrite_b</span><span class="s2">=</span><span class="s0">False</span><span class="s2">, </span><span class="s1">check_finite</span><span class="s2">=</span><span class="s0">True</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot;QZ decomposition for a pair of matrices with reordering. 
 
    Parameters 
    ---------- 
    A : (N, N) array_like 
        2-D array to decompose 
    B : (N, N) array_like 
        2-D array to decompose 
    sort : {callable, 'lhp', 'rhp', 'iuc', 'ouc'}, optional 
        Specifies whether the upper eigenvalues should be sorted. A 
        callable may be passed that, given an ordered pair ``(alpha, 
        beta)`` representing the eigenvalue ``x = (alpha/beta)``, 
        returns a boolean denoting whether the eigenvalue should be 
        sorted to the top-left (True). For the real matrix pairs 
        ``beta`` is real while ``alpha`` can be complex, and for 
        complex matrix pairs both ``alpha`` and ``beta`` can be 
        complex. The callable must be able to accept a NumPy 
        array. Alternatively, string parameters may be used: 
 
            - 'lhp'   Left-hand plane (x.real &lt; 0.0) 
            - 'rhp'   Right-hand plane (x.real &gt; 0.0) 
            - 'iuc'   Inside the unit circle (x*x.conjugate() &lt; 1.0) 
            - 'ouc'   Outside the unit circle (x*x.conjugate() &gt; 1.0) 
 
        With the predefined sorting functions, an infinite eigenvalue 
        (i.e., ``alpha != 0`` and ``beta = 0``) is considered to lie in 
        neither the left-hand nor the right-hand plane, but it is 
        considered to lie outside the unit circle. For the eigenvalue 
        ``(alpha, beta) = (0, 0)``, the predefined sorting functions 
        all return `False`. 
    output : str {'real','complex'}, optional 
        Construct the real or complex QZ decomposition for real matrices. 
        Default is 'real'. 
    overwrite_a : bool, optional 
        If True, the contents of A are overwritten. 
    overwrite_b : bool, optional 
        If True, the contents of B are overwritten. 
    check_finite : bool, optional 
        If true checks the elements of `A` and `B` are finite numbers. If 
        false does no checking and passes matrix through to 
        underlying algorithm. 
 
    Returns 
    ------- 
    AA : (N, N) ndarray 
        Generalized Schur form of A. 
    BB : (N, N) ndarray 
        Generalized Schur form of B. 
    alpha : (N,) ndarray 
        alpha = alphar + alphai * 1j. See notes. 
    beta : (N,) ndarray 
        See notes. 
    Q : (N, N) ndarray 
        The left Schur vectors. 
    Z : (N, N) ndarray 
        The right Schur vectors. 
 
    See Also 
    -------- 
    qz 
 
    Notes 
    ----- 
    On exit, ``(ALPHAR(j) + ALPHAI(j)*i)/BETA(j), j=1,...,N``, will be the 
    generalized eigenvalues.  ``ALPHAR(j) + ALPHAI(j)*i`` and 
    ``BETA(j),j=1,...,N`` are the diagonals of the complex Schur form (S,T) 
    that would result if the 2-by-2 diagonal blocks of the real generalized 
    Schur form of (A,B) were further reduced to triangular form using complex 
    unitary transformations. If ALPHAI(j) is zero, then the jth eigenvalue is 
    real; if positive, then the ``j``\\ th and ``(j+1)``\\ st eigenvalues are a 
    complex conjugate pair, with ``ALPHAI(j+1)`` negative. 
 
    .. versionadded:: 0.17.0 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.linalg import ordqz 
    &gt;&gt;&gt; A = np.array([[2, 5, 8, 7], [5, 2, 2, 8], [7, 5, 6, 6], [5, 4, 4, 8]]) 
    &gt;&gt;&gt; B = np.array([[0, 6, 0, 0], [5, 0, 2, 1], [5, 2, 6, 6], [4, 7, 7, 7]]) 
    &gt;&gt;&gt; AA, BB, alpha, beta, Q, Z = ordqz(A, B, sort='lhp') 
 
    Since we have sorted for left half plane eigenvalues, negatives come first 
 
    &gt;&gt;&gt; (alpha/beta).real &lt; 0 
    array([ True,  True, False, False], dtype=bool) 
 
    &quot;&quot;&quot;</span>
    <span class="s2">(</span><span class="s1">AA</span><span class="s2">, </span><span class="s1">BB</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, *</span><span class="s1">ab</span><span class="s2">, </span><span class="s1">Q</span><span class="s2">, </span><span class="s1">Z</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">_</span><span class="s2">), </span><span class="s1">typ </span><span class="s2">= </span><span class="s1">_qz</span><span class="s2">(</span><span class="s1">A</span><span class="s2">, </span><span class="s1">B</span><span class="s2">, </span><span class="s1">output</span><span class="s2">=</span><span class="s1">output</span><span class="s2">, </span><span class="s1">sort</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
                                            <span class="s1">overwrite_a</span><span class="s2">=</span><span class="s1">overwrite_a</span><span class="s2">,</span>
                                            <span class="s1">overwrite_b</span><span class="s2">=</span><span class="s1">overwrite_b</span><span class="s2">,</span>
                                            <span class="s1">check_finite</span><span class="s2">=</span><span class="s1">check_finite</span><span class="s2">)</span>

    <span class="s0">if </span><span class="s1">typ </span><span class="s2">== </span><span class="s3">'s'</span><span class="s2">:</span>
        <span class="s1">alpha</span><span class="s2">, </span><span class="s1">beta </span><span class="s2">= </span><span class="s1">ab</span><span class="s2">[</span><span class="s5">0</span><span class="s2">] + </span><span class="s1">ab</span><span class="s2">[</span><span class="s5">1</span><span class="s2">]*</span><span class="s1">np</span><span class="s2">.</span><span class="s1">complex64</span><span class="s2">(</span><span class="s5">1j</span><span class="s2">), </span><span class="s1">ab</span><span class="s2">[</span><span class="s5">2</span><span class="s2">]</span>
    <span class="s0">elif </span><span class="s1">typ </span><span class="s2">== </span><span class="s3">'d'</span><span class="s2">:</span>
        <span class="s1">alpha</span><span class="s2">, </span><span class="s1">beta </span><span class="s2">= </span><span class="s1">ab</span><span class="s2">[</span><span class="s5">0</span><span class="s2">] + </span><span class="s1">ab</span><span class="s2">[</span><span class="s5">1</span><span class="s2">]*</span><span class="s5">1.j</span><span class="s2">, </span><span class="s1">ab</span><span class="s2">[</span><span class="s5">2</span><span class="s2">]</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">alpha</span><span class="s2">, </span><span class="s1">beta </span><span class="s2">= </span><span class="s1">ab</span>

    <span class="s1">sfunction </span><span class="s2">= </span><span class="s1">_select_function</span><span class="s2">(</span><span class="s1">sort</span><span class="s2">)</span>
    <span class="s1">select </span><span class="s2">= </span><span class="s1">sfunction</span><span class="s2">(</span><span class="s1">alpha</span><span class="s2">, </span><span class="s1">beta</span><span class="s2">)</span>

    <span class="s1">tgsen </span><span class="s2">= </span><span class="s1">get_lapack_funcs</span><span class="s2">(</span><span class="s3">'tgsen'</span><span class="s2">, (</span><span class="s1">AA</span><span class="s2">, </span><span class="s1">BB</span><span class="s2">))</span>
    <span class="s4"># the real case needs 4n + 16 lwork</span>
    <span class="s1">lwork </span><span class="s2">= </span><span class="s5">4</span><span class="s2">*</span><span class="s1">AA</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">0</span><span class="s2">] + </span><span class="s5">16 </span><span class="s0">if </span><span class="s1">typ </span><span class="s0">in </span><span class="s3">'sd' </span><span class="s0">else </span><span class="s5">1</span>
    <span class="s1">AAA</span><span class="s2">, </span><span class="s1">BBB</span><span class="s2">, *</span><span class="s1">ab</span><span class="s2">, </span><span class="s1">QQ</span><span class="s2">, </span><span class="s1">ZZ</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">info </span><span class="s2">= </span><span class="s1">tgsen</span><span class="s2">(</span><span class="s1">select</span><span class="s2">, </span><span class="s1">AA</span><span class="s2">, </span><span class="s1">BB</span><span class="s2">, </span><span class="s1">Q</span><span class="s2">, </span><span class="s1">Z</span><span class="s2">,</span>
                                                    <span class="s1">ijob</span><span class="s2">=</span><span class="s5">0</span><span class="s2">,</span>
                                                    <span class="s1">lwork</span><span class="s2">=</span><span class="s1">lwork</span><span class="s2">, </span><span class="s1">liwork</span><span class="s2">=</span><span class="s5">1</span><span class="s2">)</span>

    <span class="s4"># Once more for tgsen output</span>
    <span class="s0">if </span><span class="s1">typ </span><span class="s2">== </span><span class="s3">'s'</span><span class="s2">:</span>
        <span class="s1">alpha</span><span class="s2">, </span><span class="s1">beta </span><span class="s2">= </span><span class="s1">ab</span><span class="s2">[</span><span class="s5">0</span><span class="s2">] + </span><span class="s1">ab</span><span class="s2">[</span><span class="s5">1</span><span class="s2">]*</span><span class="s1">np</span><span class="s2">.</span><span class="s1">complex64</span><span class="s2">(</span><span class="s5">1j</span><span class="s2">), </span><span class="s1">ab</span><span class="s2">[</span><span class="s5">2</span><span class="s2">]</span>
    <span class="s0">elif </span><span class="s1">typ </span><span class="s2">== </span><span class="s3">'d'</span><span class="s2">:</span>
        <span class="s1">alpha</span><span class="s2">, </span><span class="s1">beta </span><span class="s2">= </span><span class="s1">ab</span><span class="s2">[</span><span class="s5">0</span><span class="s2">] + </span><span class="s1">ab</span><span class="s2">[</span><span class="s5">1</span><span class="s2">]*</span><span class="s5">1.j</span><span class="s2">, </span><span class="s1">ab</span><span class="s2">[</span><span class="s5">2</span><span class="s2">]</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">alpha</span><span class="s2">, </span><span class="s1">beta </span><span class="s2">= </span><span class="s1">ab</span>

    <span class="s0">if </span><span class="s1">info </span><span class="s2">&lt; </span><span class="s5">0</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">f&quot;Illegal value in argument </span><span class="s0">{</span><span class="s2">-</span><span class="s1">info</span><span class="s0">} </span><span class="s3">of tgsen&quot;</span><span class="s2">)</span>
    <span class="s0">elif </span><span class="s1">info </span><span class="s2">== </span><span class="s5">1</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;Reordering of (A, B) failed because the transformed&quot;</span>
                         <span class="s3">&quot; matrix pair (A, B) would be too far from &quot;</span>
                         <span class="s3">&quot;generalized Schur form; the problem is very &quot;</span>
                         <span class="s3">&quot;ill-conditioned. (A, B) may have been partially &quot;</span>
                         <span class="s3">&quot;reordered.&quot;</span><span class="s2">)</span>

    <span class="s0">return </span><span class="s1">AAA</span><span class="s2">, </span><span class="s1">BBB</span><span class="s2">, </span><span class="s1">alpha</span><span class="s2">, </span><span class="s1">beta</span><span class="s2">, </span><span class="s1">QQ</span><span class="s2">, </span><span class="s1">ZZ</span>
</pre>
</body>
</html>