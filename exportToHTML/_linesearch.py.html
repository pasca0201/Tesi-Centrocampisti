<html>
<head>
<title>_linesearch.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #6aab73;}
.s5 { color: #2aacb8;}
.s6 { color: #7a7e85;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_linesearch.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Functions 
--------- 
.. autosummary:: 
   :toctree: generated/ 
 
    line_search_armijo 
    line_search_wolfe1 
    line_search_wolfe2 
    scalar_search_wolfe1 
    scalar_search_wolfe2 
 
&quot;&quot;&quot;</span>
<span class="s2">from </span><span class="s1">warnings </span><span class="s2">import </span><span class="s1">warn</span>

<span class="s2">from </span><span class="s3">.</span><span class="s1">_dcsrch </span><span class="s2">import </span><span class="s1">DCSRCH</span>
<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>

<span class="s1">__all__ </span><span class="s3">= [</span><span class="s4">'LineSearchWarning'</span><span class="s3">, </span><span class="s4">'line_search_wolfe1'</span><span class="s3">, </span><span class="s4">'line_search_wolfe2'</span><span class="s3">,</span>
           <span class="s4">'scalar_search_wolfe1'</span><span class="s3">, </span><span class="s4">'scalar_search_wolfe2'</span><span class="s3">,</span>
           <span class="s4">'line_search_armijo'</span><span class="s3">]</span>

<span class="s2">class </span><span class="s1">LineSearchWarning</span><span class="s3">(</span><span class="s1">RuntimeWarning</span><span class="s3">):</span>
    <span class="s2">pass</span>


<span class="s2">def </span><span class="s1">_check_c1_c2</span><span class="s3">(</span><span class="s1">c1</span><span class="s3">, </span><span class="s1">c2</span><span class="s3">):</span>
    <span class="s2">if not </span><span class="s3">(</span><span class="s5">0 </span><span class="s3">&lt; </span><span class="s1">c1 </span><span class="s3">&lt; </span><span class="s1">c2 </span><span class="s3">&lt; </span><span class="s5">1</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;'c1' and 'c2' do not satisfy&quot;</span>
                         <span class="s4">&quot;'0 &lt; c1 &lt; c2 &lt; 1'.&quot;</span><span class="s3">)</span>


<span class="s6">#------------------------------------------------------------------------------</span>
<span class="s6"># Minpack's Wolfe line and scalar searches</span>
<span class="s6">#------------------------------------------------------------------------------</span>

<span class="s2">def </span><span class="s1">line_search_wolfe1</span><span class="s3">(</span><span class="s1">f</span><span class="s3">, </span><span class="s1">fprime</span><span class="s3">, </span><span class="s1">xk</span><span class="s3">, </span><span class="s1">pk</span><span class="s3">, </span><span class="s1">gfk</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
                       <span class="s1">old_fval</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">old_old_fval</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
                       <span class="s1">args</span><span class="s3">=(), </span><span class="s1">c1</span><span class="s3">=</span><span class="s5">1e-4</span><span class="s3">, </span><span class="s1">c2</span><span class="s3">=</span><span class="s5">0.9</span><span class="s3">, </span><span class="s1">amax</span><span class="s3">=</span><span class="s5">50</span><span class="s3">, </span><span class="s1">amin</span><span class="s3">=</span><span class="s5">1e-8</span><span class="s3">,</span>
                       <span class="s1">xtol</span><span class="s3">=</span><span class="s5">1e-14</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    As `scalar_search_wolfe1` but do a line search to direction `pk` 
 
    Parameters 
    ---------- 
    f : callable 
        Function `f(x)` 
    fprime : callable 
        Gradient of `f` 
    xk : array_like 
        Current point 
    pk : array_like 
        Search direction 
    gfk : array_like, optional 
        Gradient of `f` at point `xk` 
    old_fval : float, optional 
        Value of `f` at point `xk` 
    old_old_fval : float, optional 
        Value of `f` at point preceding `xk` 
 
    The rest of the parameters are the same as for `scalar_search_wolfe1`. 
 
    Returns 
    ------- 
    stp, f_count, g_count, fval, old_fval 
        As in `line_search_wolfe1` 
    gval : array 
        Gradient of `f` at the final point 
 
    Notes 
    ----- 
    Parameters `c1` and `c2` must satisfy ``0 &lt; c1 &lt; c2 &lt; 1``. 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">gfk </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">gfk </span><span class="s3">= </span><span class="s1">fprime</span><span class="s3">(</span><span class="s1">xk</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">)</span>

    <span class="s1">gval </span><span class="s3">= [</span><span class="s1">gfk</span><span class="s3">]</span>
    <span class="s1">gc </span><span class="s3">= [</span><span class="s5">0</span><span class="s3">]</span>
    <span class="s1">fc </span><span class="s3">= [</span><span class="s5">0</span><span class="s3">]</span>

    <span class="s2">def </span><span class="s1">phi</span><span class="s3">(</span><span class="s1">s</span><span class="s3">):</span>
        <span class="s1">fc</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] += </span><span class="s5">1</span>
        <span class="s2">return </span><span class="s1">f</span><span class="s3">(</span><span class="s1">xk </span><span class="s3">+ </span><span class="s1">s</span><span class="s3">*</span><span class="s1">pk</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">derphi</span><span class="s3">(</span><span class="s1">s</span><span class="s3">):</span>
        <span class="s1">gval</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] = </span><span class="s1">fprime</span><span class="s3">(</span><span class="s1">xk </span><span class="s3">+ </span><span class="s1">s</span><span class="s3">*</span><span class="s1">pk</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">)</span>
        <span class="s1">gc</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] += </span><span class="s5">1</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">dot</span><span class="s3">(</span><span class="s1">gval</span><span class="s3">[</span><span class="s5">0</span><span class="s3">], </span><span class="s1">pk</span><span class="s3">)</span>

    <span class="s1">derphi0 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">dot</span><span class="s3">(</span><span class="s1">gfk</span><span class="s3">, </span><span class="s1">pk</span><span class="s3">)</span>

    <span class="s1">stp</span><span class="s3">, </span><span class="s1">fval</span><span class="s3">, </span><span class="s1">old_fval </span><span class="s3">= </span><span class="s1">scalar_search_wolfe1</span><span class="s3">(</span>
            <span class="s1">phi</span><span class="s3">, </span><span class="s1">derphi</span><span class="s3">, </span><span class="s1">old_fval</span><span class="s3">, </span><span class="s1">old_old_fval</span><span class="s3">, </span><span class="s1">derphi0</span><span class="s3">,</span>
            <span class="s1">c1</span><span class="s3">=</span><span class="s1">c1</span><span class="s3">, </span><span class="s1">c2</span><span class="s3">=</span><span class="s1">c2</span><span class="s3">, </span><span class="s1">amax</span><span class="s3">=</span><span class="s1">amax</span><span class="s3">, </span><span class="s1">amin</span><span class="s3">=</span><span class="s1">amin</span><span class="s3">, </span><span class="s1">xtol</span><span class="s3">=</span><span class="s1">xtol</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">stp</span><span class="s3">, </span><span class="s1">fc</span><span class="s3">[</span><span class="s5">0</span><span class="s3">], </span><span class="s1">gc</span><span class="s3">[</span><span class="s5">0</span><span class="s3">], </span><span class="s1">fval</span><span class="s3">, </span><span class="s1">old_fval</span><span class="s3">, </span><span class="s1">gval</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>


<span class="s2">def </span><span class="s1">scalar_search_wolfe1</span><span class="s3">(</span><span class="s1">phi</span><span class="s3">, </span><span class="s1">derphi</span><span class="s3">, </span><span class="s1">phi0</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">old_phi0</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">derphi0</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
                         <span class="s1">c1</span><span class="s3">=</span><span class="s5">1e-4</span><span class="s3">, </span><span class="s1">c2</span><span class="s3">=</span><span class="s5">0.9</span><span class="s3">,</span>
                         <span class="s1">amax</span><span class="s3">=</span><span class="s5">50</span><span class="s3">, </span><span class="s1">amin</span><span class="s3">=</span><span class="s5">1e-8</span><span class="s3">, </span><span class="s1">xtol</span><span class="s3">=</span><span class="s5">1e-14</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Scalar function search for alpha that satisfies strong Wolfe conditions 
 
    alpha &gt; 0 is assumed to be a descent direction. 
 
    Parameters 
    ---------- 
    phi : callable phi(alpha) 
        Function at point `alpha` 
    derphi : callable phi'(alpha) 
        Objective function derivative. Returns a scalar. 
    phi0 : float, optional 
        Value of phi at 0 
    old_phi0 : float, optional 
        Value of phi at previous point 
    derphi0 : float, optional 
        Value derphi at 0 
    c1 : float, optional 
        Parameter for Armijo condition rule. 
    c2 : float, optional 
        Parameter for curvature condition rule. 
    amax, amin : float, optional 
        Maximum and minimum step size 
    xtol : float, optional 
        Relative tolerance for an acceptable step. 
 
    Returns 
    ------- 
    alpha : float 
        Step size, or None if no suitable step was found 
    phi : float 
        Value of `phi` at the new point `alpha` 
    phi0 : float 
        Value of `phi` at `alpha=0` 
 
    Notes 
    ----- 
    Uses routine DCSRCH from MINPACK. 
     
    Parameters `c1` and `c2` must satisfy ``0 &lt; c1 &lt; c2 &lt; 1`` as described in [1]_. 
 
    References 
    ---------- 
     
    .. [1] Nocedal, J., &amp; Wright, S. J. (2006). Numerical optimization. 
       In Springer Series in Operations Research and Financial Engineering. 
       (Springer Series in Operations Research and Financial Engineering). 
       Springer Nature. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">_check_c1_c2</span><span class="s3">(</span><span class="s1">c1</span><span class="s3">, </span><span class="s1">c2</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">phi0 </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">phi0 </span><span class="s3">= </span><span class="s1">phi</span><span class="s3">(</span><span class="s5">0.</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">derphi0 </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">derphi0 </span><span class="s3">= </span><span class="s1">derphi</span><span class="s3">(</span><span class="s5">0.</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">old_phi0 </span><span class="s2">is not None and </span><span class="s1">derphi0 </span><span class="s3">!= </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s1">alpha1 </span><span class="s3">= </span><span class="s1">min</span><span class="s3">(</span><span class="s5">1.0</span><span class="s3">, </span><span class="s5">1.01</span><span class="s3">*</span><span class="s5">2</span><span class="s3">*(</span><span class="s1">phi0 </span><span class="s3">- </span><span class="s1">old_phi0</span><span class="s3">)/</span><span class="s1">derphi0</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">alpha1 </span><span class="s3">&lt; </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s1">alpha1 </span><span class="s3">= </span><span class="s5">1.0</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">alpha1 </span><span class="s3">= </span><span class="s5">1.0</span>

    <span class="s1">maxiter </span><span class="s3">= </span><span class="s5">100</span>

    <span class="s1">dcsrch </span><span class="s3">= </span><span class="s1">DCSRCH</span><span class="s3">(</span><span class="s1">phi</span><span class="s3">, </span><span class="s1">derphi</span><span class="s3">, </span><span class="s1">c1</span><span class="s3">, </span><span class="s1">c2</span><span class="s3">, </span><span class="s1">xtol</span><span class="s3">, </span><span class="s1">amin</span><span class="s3">, </span><span class="s1">amax</span><span class="s3">)</span>
    <span class="s1">stp</span><span class="s3">, </span><span class="s1">phi1</span><span class="s3">, </span><span class="s1">phi0</span><span class="s3">, </span><span class="s1">task </span><span class="s3">= </span><span class="s1">dcsrch</span><span class="s3">(</span>
        <span class="s1">alpha1</span><span class="s3">, </span><span class="s1">phi0</span><span class="s3">=</span><span class="s1">phi0</span><span class="s3">, </span><span class="s1">derphi0</span><span class="s3">=</span><span class="s1">derphi0</span><span class="s3">, </span><span class="s1">maxiter</span><span class="s3">=</span><span class="s1">maxiter</span>
    <span class="s3">)</span>

    <span class="s2">return </span><span class="s1">stp</span><span class="s3">, </span><span class="s1">phi1</span><span class="s3">, </span><span class="s1">phi0</span>


<span class="s1">line_search </span><span class="s3">= </span><span class="s1">line_search_wolfe1</span>


<span class="s6">#------------------------------------------------------------------------------</span>
<span class="s6"># Pure-Python Wolfe line and scalar searches</span>
<span class="s6">#------------------------------------------------------------------------------</span>

<span class="s6"># Note: `line_search_wolfe2` is the public `scipy.optimize.line_search`</span>

<span class="s2">def </span><span class="s1">line_search_wolfe2</span><span class="s3">(</span><span class="s1">f</span><span class="s3">, </span><span class="s1">myfprime</span><span class="s3">, </span><span class="s1">xk</span><span class="s3">, </span><span class="s1">pk</span><span class="s3">, </span><span class="s1">gfk</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">old_fval</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
                       <span class="s1">old_old_fval</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">args</span><span class="s3">=(), </span><span class="s1">c1</span><span class="s3">=</span><span class="s5">1e-4</span><span class="s3">, </span><span class="s1">c2</span><span class="s3">=</span><span class="s5">0.9</span><span class="s3">, </span><span class="s1">amax</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
                       <span class="s1">extra_condition</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">maxiter</span><span class="s3">=</span><span class="s5">10</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Find alpha that satisfies strong Wolfe conditions. 
 
    Parameters 
    ---------- 
    f : callable f(x,*args) 
        Objective function. 
    myfprime : callable f'(x,*args) 
        Objective function gradient. 
    xk : ndarray 
        Starting point. 
    pk : ndarray 
        Search direction. The search direction must be a descent direction 
        for the algorithm to converge. 
    gfk : ndarray, optional 
        Gradient value for x=xk (xk being the current parameter 
        estimate). Will be recomputed if omitted. 
    old_fval : float, optional 
        Function value for x=xk. Will be recomputed if omitted. 
    old_old_fval : float, optional 
        Function value for the point preceding x=xk. 
    args : tuple, optional 
        Additional arguments passed to objective function. 
    c1 : float, optional 
        Parameter for Armijo condition rule. 
    c2 : float, optional 
        Parameter for curvature condition rule. 
    amax : float, optional 
        Maximum step size 
    extra_condition : callable, optional 
        A callable of the form ``extra_condition(alpha, x, f, g)`` 
        returning a boolean. Arguments are the proposed step ``alpha`` 
        and the corresponding ``x``, ``f`` and ``g`` values. The line search 
        accepts the value of ``alpha`` only if this 
        callable returns ``True``. If the callable returns ``False`` 
        for the step length, the algorithm will continue with 
        new iterates. The callable is only called for iterates 
        satisfying the strong Wolfe conditions. 
    maxiter : int, optional 
        Maximum number of iterations to perform. 
 
    Returns 
    ------- 
    alpha : float or None 
        Alpha for which ``x_new = x0 + alpha * pk``, 
        or None if the line search algorithm did not converge. 
    fc : int 
        Number of function evaluations made. 
    gc : int 
        Number of gradient evaluations made. 
    new_fval : float or None 
        New function value ``f(x_new)=f(x0+alpha*pk)``, 
        or None if the line search algorithm did not converge. 
    old_fval : float 
        Old function value ``f(x0)``. 
    new_slope : float or None 
        The local slope along the search direction at the 
        new value ``&lt;myfprime(x_new), pk&gt;``, 
        or None if the line search algorithm did not converge. 
 
 
    Notes 
    ----- 
    Uses the line search algorithm to enforce strong Wolfe 
    conditions. See Wright and Nocedal, 'Numerical Optimization', 
    1999, pp. 59-61. 
 
    The search direction `pk` must be a descent direction (e.g. 
    ``-myfprime(xk)``) to find a step length that satisfies the strong Wolfe 
    conditions. If the search direction is not a descent direction (e.g. 
    ``myfprime(xk)``), then `alpha`, `new_fval`, and `new_slope` will be None. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.optimize import line_search 
 
    A objective function and its gradient are defined. 
 
    &gt;&gt;&gt; def obj_func(x): 
    ...     return (x[0])**2+(x[1])**2 
    &gt;&gt;&gt; def obj_grad(x): 
    ...     return [2*x[0], 2*x[1]] 
 
    We can find alpha that satisfies strong Wolfe conditions. 
 
    &gt;&gt;&gt; start_point = np.array([1.8, 1.7]) 
    &gt;&gt;&gt; search_gradient = np.array([-1.0, -1.0]) 
    &gt;&gt;&gt; line_search(obj_func, obj_grad, start_point, search_gradient) 
    (1.0, 2, 1, 1.1300000000000001, 6.13, [1.6, 1.4]) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">fc </span><span class="s3">= [</span><span class="s5">0</span><span class="s3">]</span>
    <span class="s1">gc </span><span class="s3">= [</span><span class="s5">0</span><span class="s3">]</span>
    <span class="s1">gval </span><span class="s3">= [</span><span class="s2">None</span><span class="s3">]</span>
    <span class="s1">gval_alpha </span><span class="s3">= [</span><span class="s2">None</span><span class="s3">]</span>

    <span class="s2">def </span><span class="s1">phi</span><span class="s3">(</span><span class="s1">alpha</span><span class="s3">):</span>
        <span class="s1">fc</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] += </span><span class="s5">1</span>
        <span class="s2">return </span><span class="s1">f</span><span class="s3">(</span><span class="s1">xk </span><span class="s3">+ </span><span class="s1">alpha </span><span class="s3">* </span><span class="s1">pk</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">)</span>

    <span class="s1">fprime </span><span class="s3">= </span><span class="s1">myfprime</span>

    <span class="s2">def </span><span class="s1">derphi</span><span class="s3">(</span><span class="s1">alpha</span><span class="s3">):</span>
        <span class="s1">gc</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] += </span><span class="s5">1</span>
        <span class="s1">gval</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] = </span><span class="s1">fprime</span><span class="s3">(</span><span class="s1">xk </span><span class="s3">+ </span><span class="s1">alpha </span><span class="s3">* </span><span class="s1">pk</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">)  </span><span class="s6"># store for later use</span>
        <span class="s1">gval_alpha</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] = </span><span class="s1">alpha</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">dot</span><span class="s3">(</span><span class="s1">gval</span><span class="s3">[</span><span class="s5">0</span><span class="s3">], </span><span class="s1">pk</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">gfk </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">gfk </span><span class="s3">= </span><span class="s1">fprime</span><span class="s3">(</span><span class="s1">xk</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">)</span>
    <span class="s1">derphi0 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">dot</span><span class="s3">(</span><span class="s1">gfk</span><span class="s3">, </span><span class="s1">pk</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">extra_condition </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s6"># Add the current gradient as argument, to avoid needless</span>
        <span class="s6"># re-evaluation</span>
        <span class="s2">def </span><span class="s1">extra_condition2</span><span class="s3">(</span><span class="s1">alpha</span><span class="s3">, </span><span class="s1">phi</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">gval_alpha</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] != </span><span class="s1">alpha</span><span class="s3">:</span>
                <span class="s1">derphi</span><span class="s3">(</span><span class="s1">alpha</span><span class="s3">)</span>
            <span class="s1">x </span><span class="s3">= </span><span class="s1">xk </span><span class="s3">+ </span><span class="s1">alpha </span><span class="s3">* </span><span class="s1">pk</span>
            <span class="s2">return </span><span class="s1">extra_condition</span><span class="s3">(</span><span class="s1">alpha</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">phi</span><span class="s3">, </span><span class="s1">gval</span><span class="s3">[</span><span class="s5">0</span><span class="s3">])</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">extra_condition2 </span><span class="s3">= </span><span class="s2">None</span>

    <span class="s1">alpha_star</span><span class="s3">, </span><span class="s1">phi_star</span><span class="s3">, </span><span class="s1">old_fval</span><span class="s3">, </span><span class="s1">derphi_star </span><span class="s3">= </span><span class="s1">scalar_search_wolfe2</span><span class="s3">(</span>
            <span class="s1">phi</span><span class="s3">, </span><span class="s1">derphi</span><span class="s3">, </span><span class="s1">old_fval</span><span class="s3">, </span><span class="s1">old_old_fval</span><span class="s3">, </span><span class="s1">derphi0</span><span class="s3">, </span><span class="s1">c1</span><span class="s3">, </span><span class="s1">c2</span><span class="s3">, </span><span class="s1">amax</span><span class="s3">,</span>
            <span class="s1">extra_condition2</span><span class="s3">, </span><span class="s1">maxiter</span><span class="s3">=</span><span class="s1">maxiter</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">derphi_star </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">warn</span><span class="s3">(</span><span class="s4">'The line search algorithm did not converge'</span><span class="s3">,</span>
             <span class="s1">LineSearchWarning</span><span class="s3">, </span><span class="s1">stacklevel</span><span class="s3">=</span><span class="s5">2</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s6"># derphi_star is a number (derphi) -- so use the most recently</span>
        <span class="s6"># calculated gradient used in computing it derphi = gfk*pk</span>
        <span class="s6"># this is the gradient at the next step no need to compute it</span>
        <span class="s6"># again in the outer loop.</span>
        <span class="s1">derphi_star </span><span class="s3">= </span><span class="s1">gval</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>

    <span class="s2">return </span><span class="s1">alpha_star</span><span class="s3">, </span><span class="s1">fc</span><span class="s3">[</span><span class="s5">0</span><span class="s3">], </span><span class="s1">gc</span><span class="s3">[</span><span class="s5">0</span><span class="s3">], </span><span class="s1">phi_star</span><span class="s3">, </span><span class="s1">old_fval</span><span class="s3">, </span><span class="s1">derphi_star</span>


<span class="s2">def </span><span class="s1">scalar_search_wolfe2</span><span class="s3">(</span><span class="s1">phi</span><span class="s3">, </span><span class="s1">derphi</span><span class="s3">, </span><span class="s1">phi0</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
                         <span class="s1">old_phi0</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">derphi0</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
                         <span class="s1">c1</span><span class="s3">=</span><span class="s5">1e-4</span><span class="s3">, </span><span class="s1">c2</span><span class="s3">=</span><span class="s5">0.9</span><span class="s3">, </span><span class="s1">amax</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
                         <span class="s1">extra_condition</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">maxiter</span><span class="s3">=</span><span class="s5">10</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Find alpha that satisfies strong Wolfe conditions. 
 
    alpha &gt; 0 is assumed to be a descent direction. 
 
    Parameters 
    ---------- 
    phi : callable phi(alpha) 
        Objective scalar function. 
    derphi : callable phi'(alpha) 
        Objective function derivative. Returns a scalar. 
    phi0 : float, optional 
        Value of phi at 0. 
    old_phi0 : float, optional 
        Value of phi at previous point. 
    derphi0 : float, optional 
        Value of derphi at 0 
    c1 : float, optional 
        Parameter for Armijo condition rule. 
    c2 : float, optional 
        Parameter for curvature condition rule. 
    amax : float, optional 
        Maximum step size. 
    extra_condition : callable, optional 
        A callable of the form ``extra_condition(alpha, phi_value)`` 
        returning a boolean. The line search accepts the value 
        of ``alpha`` only if this callable returns ``True``. 
        If the callable returns ``False`` for the step length, 
        the algorithm will continue with new iterates. 
        The callable is only called for iterates satisfying 
        the strong Wolfe conditions. 
    maxiter : int, optional 
        Maximum number of iterations to perform. 
 
    Returns 
    ------- 
    alpha_star : float or None 
        Best alpha, or None if the line search algorithm did not converge. 
    phi_star : float 
        phi at alpha_star. 
    phi0 : float 
        phi at 0. 
    derphi_star : float or None 
        derphi at alpha_star, or None if the line search algorithm 
        did not converge. 
 
    Notes 
    ----- 
    Uses the line search algorithm to enforce strong Wolfe 
    conditions. See Wright and Nocedal, 'Numerical Optimization', 
    1999, pp. 59-61. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">_check_c1_c2</span><span class="s3">(</span><span class="s1">c1</span><span class="s3">, </span><span class="s1">c2</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">phi0 </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">phi0 </span><span class="s3">= </span><span class="s1">phi</span><span class="s3">(</span><span class="s5">0.</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">derphi0 </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">derphi0 </span><span class="s3">= </span><span class="s1">derphi</span><span class="s3">(</span><span class="s5">0.</span><span class="s3">)</span>

    <span class="s1">alpha0 </span><span class="s3">= </span><span class="s5">0</span>
    <span class="s2">if </span><span class="s1">old_phi0 </span><span class="s2">is not None and </span><span class="s1">derphi0 </span><span class="s3">!= </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s1">alpha1 </span><span class="s3">= </span><span class="s1">min</span><span class="s3">(</span><span class="s5">1.0</span><span class="s3">, </span><span class="s5">1.01</span><span class="s3">*</span><span class="s5">2</span><span class="s3">*(</span><span class="s1">phi0 </span><span class="s3">- </span><span class="s1">old_phi0</span><span class="s3">)/</span><span class="s1">derphi0</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">alpha1 </span><span class="s3">= </span><span class="s5">1.0</span>

    <span class="s2">if </span><span class="s1">alpha1 </span><span class="s3">&lt; </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s1">alpha1 </span><span class="s3">= </span><span class="s5">1.0</span>

    <span class="s2">if </span><span class="s1">amax </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s1">alpha1 </span><span class="s3">= </span><span class="s1">min</span><span class="s3">(</span><span class="s1">alpha1</span><span class="s3">, </span><span class="s1">amax</span><span class="s3">)</span>

    <span class="s1">phi_a1 </span><span class="s3">= </span><span class="s1">phi</span><span class="s3">(</span><span class="s1">alpha1</span><span class="s3">)</span>
    <span class="s6">#derphi_a1 = derphi(alpha1) evaluated below</span>

    <span class="s1">phi_a0 </span><span class="s3">= </span><span class="s1">phi0</span>
    <span class="s1">derphi_a0 </span><span class="s3">= </span><span class="s1">derphi0</span>

    <span class="s2">if </span><span class="s1">extra_condition </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s2">def </span><span class="s1">extra_condition</span><span class="s3">(</span><span class="s1">alpha</span><span class="s3">, </span><span class="s1">phi</span><span class="s3">):</span>
            <span class="s2">return True</span>

    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">maxiter</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">alpha1 </span><span class="s3">== </span><span class="s5">0 </span><span class="s2">or </span><span class="s3">(</span><span class="s1">amax </span><span class="s2">is not None and </span><span class="s1">alpha0 </span><span class="s3">&gt; </span><span class="s1">amax</span><span class="s3">):</span>
            <span class="s6"># alpha1 == 0: This shouldn't happen. Perhaps the increment has</span>
            <span class="s6"># slipped below machine precision?</span>
            <span class="s1">alpha_star </span><span class="s3">= </span><span class="s2">None</span>
            <span class="s1">phi_star </span><span class="s3">= </span><span class="s1">phi0</span>
            <span class="s1">phi0 </span><span class="s3">= </span><span class="s1">old_phi0</span>
            <span class="s1">derphi_star </span><span class="s3">= </span><span class="s2">None</span>

            <span class="s2">if </span><span class="s1">alpha1 </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
                <span class="s1">msg </span><span class="s3">= </span><span class="s4">'Rounding errors prevent the line search from converging'</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">msg </span><span class="s3">= </span><span class="s4">&quot;The line search algorithm could not find a solution &quot; </span><span class="s3">+ </span><span class="s1">\</span>
                      <span class="s4">&quot;less than or equal to amax: %s&quot; </span><span class="s3">% </span><span class="s1">amax</span>

            <span class="s1">warn</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">, </span><span class="s1">LineSearchWarning</span><span class="s3">, </span><span class="s1">stacklevel</span><span class="s3">=</span><span class="s5">2</span><span class="s3">)</span>
            <span class="s2">break</span>

        <span class="s1">not_first_iteration </span><span class="s3">= </span><span class="s1">i </span><span class="s3">&gt; </span><span class="s5">0</span>
        <span class="s2">if </span><span class="s3">(</span><span class="s1">phi_a1 </span><span class="s3">&gt; </span><span class="s1">phi0 </span><span class="s3">+ </span><span class="s1">c1 </span><span class="s3">* </span><span class="s1">alpha1 </span><span class="s3">* </span><span class="s1">derphi0</span><span class="s3">) </span><span class="s2">or </span><span class="s1">\</span>
           <span class="s3">((</span><span class="s1">phi_a1 </span><span class="s3">&gt;= </span><span class="s1">phi_a0</span><span class="s3">) </span><span class="s2">and </span><span class="s1">not_first_iteration</span><span class="s3">):</span>
            <span class="s1">alpha_star</span><span class="s3">, </span><span class="s1">phi_star</span><span class="s3">, </span><span class="s1">derphi_star </span><span class="s3">= </span><span class="s1">\</span>
                        <span class="s1">_zoom</span><span class="s3">(</span><span class="s1">alpha0</span><span class="s3">, </span><span class="s1">alpha1</span><span class="s3">, </span><span class="s1">phi_a0</span><span class="s3">,</span>
                              <span class="s1">phi_a1</span><span class="s3">, </span><span class="s1">derphi_a0</span><span class="s3">, </span><span class="s1">phi</span><span class="s3">, </span><span class="s1">derphi</span><span class="s3">,</span>
                              <span class="s1">phi0</span><span class="s3">, </span><span class="s1">derphi0</span><span class="s3">, </span><span class="s1">c1</span><span class="s3">, </span><span class="s1">c2</span><span class="s3">, </span><span class="s1">extra_condition</span><span class="s3">)</span>
            <span class="s2">break</span>

        <span class="s1">derphi_a1 </span><span class="s3">= </span><span class="s1">derphi</span><span class="s3">(</span><span class="s1">alpha1</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s3">(</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">derphi_a1</span><span class="s3">) &lt;= -</span><span class="s1">c2</span><span class="s3">*</span><span class="s1">derphi0</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">extra_condition</span><span class="s3">(</span><span class="s1">alpha1</span><span class="s3">, </span><span class="s1">phi_a1</span><span class="s3">):</span>
                <span class="s1">alpha_star </span><span class="s3">= </span><span class="s1">alpha1</span>
                <span class="s1">phi_star </span><span class="s3">= </span><span class="s1">phi_a1</span>
                <span class="s1">derphi_star </span><span class="s3">= </span><span class="s1">derphi_a1</span>
                <span class="s2">break</span>

        <span class="s2">if </span><span class="s3">(</span><span class="s1">derphi_a1 </span><span class="s3">&gt;= </span><span class="s5">0</span><span class="s3">):</span>
            <span class="s1">alpha_star</span><span class="s3">, </span><span class="s1">phi_star</span><span class="s3">, </span><span class="s1">derphi_star </span><span class="s3">= </span><span class="s1">\</span>
                        <span class="s1">_zoom</span><span class="s3">(</span><span class="s1">alpha1</span><span class="s3">, </span><span class="s1">alpha0</span><span class="s3">, </span><span class="s1">phi_a1</span><span class="s3">,</span>
                              <span class="s1">phi_a0</span><span class="s3">, </span><span class="s1">derphi_a1</span><span class="s3">, </span><span class="s1">phi</span><span class="s3">, </span><span class="s1">derphi</span><span class="s3">,</span>
                              <span class="s1">phi0</span><span class="s3">, </span><span class="s1">derphi0</span><span class="s3">, </span><span class="s1">c1</span><span class="s3">, </span><span class="s1">c2</span><span class="s3">, </span><span class="s1">extra_condition</span><span class="s3">)</span>
            <span class="s2">break</span>

        <span class="s1">alpha2 </span><span class="s3">= </span><span class="s5">2 </span><span class="s3">* </span><span class="s1">alpha1  </span><span class="s6"># increase by factor of two on each iteration</span>
        <span class="s2">if </span><span class="s1">amax </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s1">alpha2 </span><span class="s3">= </span><span class="s1">min</span><span class="s3">(</span><span class="s1">alpha2</span><span class="s3">, </span><span class="s1">amax</span><span class="s3">)</span>
        <span class="s1">alpha0 </span><span class="s3">= </span><span class="s1">alpha1</span>
        <span class="s1">alpha1 </span><span class="s3">= </span><span class="s1">alpha2</span>
        <span class="s1">phi_a0 </span><span class="s3">= </span><span class="s1">phi_a1</span>
        <span class="s1">phi_a1 </span><span class="s3">= </span><span class="s1">phi</span><span class="s3">(</span><span class="s1">alpha1</span><span class="s3">)</span>
        <span class="s1">derphi_a0 </span><span class="s3">= </span><span class="s1">derphi_a1</span>

    <span class="s2">else</span><span class="s3">:</span>
        <span class="s6"># stopping test maxiter reached</span>
        <span class="s1">alpha_star </span><span class="s3">= </span><span class="s1">alpha1</span>
        <span class="s1">phi_star </span><span class="s3">= </span><span class="s1">phi_a1</span>
        <span class="s1">derphi_star </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s1">warn</span><span class="s3">(</span><span class="s4">'The line search algorithm did not converge'</span><span class="s3">,</span>
             <span class="s1">LineSearchWarning</span><span class="s3">, </span><span class="s1">stacklevel</span><span class="s3">=</span><span class="s5">2</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">alpha_star</span><span class="s3">, </span><span class="s1">phi_star</span><span class="s3">, </span><span class="s1">phi0</span><span class="s3">, </span><span class="s1">derphi_star</span>


<span class="s2">def </span><span class="s1">_cubicmin</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">fa</span><span class="s3">, </span><span class="s1">fpa</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">fb</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">fc</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Finds the minimizer for a cubic polynomial that goes through the 
    points (a,fa), (b,fb), and (c,fc) with derivative at a of fpa. 
 
    If no minimizer can be found, return None. 
 
    &quot;&quot;&quot;</span>
    <span class="s6"># f(x) = A *(x-a)^3 + B*(x-a)^2 + C*(x-a) + D</span>

    <span class="s2">with </span><span class="s1">np</span><span class="s3">.</span><span class="s1">errstate</span><span class="s3">(</span><span class="s1">divide</span><span class="s3">=</span><span class="s4">'raise'</span><span class="s3">, </span><span class="s1">over</span><span class="s3">=</span><span class="s4">'raise'</span><span class="s3">, </span><span class="s1">invalid</span><span class="s3">=</span><span class="s4">'raise'</span><span class="s3">):</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s1">C </span><span class="s3">= </span><span class="s1">fpa</span>
            <span class="s1">db </span><span class="s3">= </span><span class="s1">b </span><span class="s3">- </span><span class="s1">a</span>
            <span class="s1">dc </span><span class="s3">= </span><span class="s1">c </span><span class="s3">- </span><span class="s1">a</span>
            <span class="s1">denom </span><span class="s3">= (</span><span class="s1">db </span><span class="s3">* </span><span class="s1">dc</span><span class="s3">) ** </span><span class="s5">2 </span><span class="s3">* (</span><span class="s1">db </span><span class="s3">- </span><span class="s1">dc</span><span class="s3">)</span>
            <span class="s1">d1 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">((</span><span class="s5">2</span><span class="s3">, </span><span class="s5">2</span><span class="s3">))</span>
            <span class="s1">d1</span><span class="s3">[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">] = </span><span class="s1">dc </span><span class="s3">** </span><span class="s5">2</span>
            <span class="s1">d1</span><span class="s3">[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">] = -</span><span class="s1">db </span><span class="s3">** </span><span class="s5">2</span>
            <span class="s1">d1</span><span class="s3">[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s3">] = -</span><span class="s1">dc </span><span class="s3">** </span><span class="s5">3</span>
            <span class="s1">d1</span><span class="s3">[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">] = </span><span class="s1">db </span><span class="s3">** </span><span class="s5">3</span>
            <span class="s3">[</span><span class="s1">A</span><span class="s3">, </span><span class="s1">B</span><span class="s3">] = </span><span class="s1">np</span><span class="s3">.</span><span class="s1">dot</span><span class="s3">(</span><span class="s1">d1</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">([</span><span class="s1">fb </span><span class="s3">- </span><span class="s1">fa </span><span class="s3">- </span><span class="s1">C </span><span class="s3">* </span><span class="s1">db</span><span class="s3">,</span>
                                            <span class="s1">fc </span><span class="s3">- </span><span class="s1">fa </span><span class="s3">- </span><span class="s1">C </span><span class="s3">* </span><span class="s1">dc</span><span class="s3">]).</span><span class="s1">flatten</span><span class="s3">())</span>
            <span class="s1">A </span><span class="s3">/= </span><span class="s1">denom</span>
            <span class="s1">B </span><span class="s3">/= </span><span class="s1">denom</span>
            <span class="s1">radical </span><span class="s3">= </span><span class="s1">B </span><span class="s3">* </span><span class="s1">B </span><span class="s3">- </span><span class="s5">3 </span><span class="s3">* </span><span class="s1">A </span><span class="s3">* </span><span class="s1">C</span>
            <span class="s1">xmin </span><span class="s3">= </span><span class="s1">a </span><span class="s3">+ (-</span><span class="s1">B </span><span class="s3">+ </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s1">radical</span><span class="s3">)) / (</span><span class="s5">3 </span><span class="s3">* </span><span class="s1">A</span><span class="s3">)</span>
        <span class="s2">except </span><span class="s1">ArithmeticError</span><span class="s3">:</span>
            <span class="s2">return None</span>
    <span class="s2">if not </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isfinite</span><span class="s3">(</span><span class="s1">xmin</span><span class="s3">):</span>
        <span class="s2">return None</span>
    <span class="s2">return </span><span class="s1">xmin</span>


<span class="s2">def </span><span class="s1">_quadmin</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">fa</span><span class="s3">, </span><span class="s1">fpa</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">fb</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Finds the minimizer for a quadratic polynomial that goes through 
    the points (a,fa), (b,fb) with derivative at a of fpa. 
 
    &quot;&quot;&quot;</span>
    <span class="s6"># f(x) = B*(x-a)^2 + C*(x-a) + D</span>
    <span class="s2">with </span><span class="s1">np</span><span class="s3">.</span><span class="s1">errstate</span><span class="s3">(</span><span class="s1">divide</span><span class="s3">=</span><span class="s4">'raise'</span><span class="s3">, </span><span class="s1">over</span><span class="s3">=</span><span class="s4">'raise'</span><span class="s3">, </span><span class="s1">invalid</span><span class="s3">=</span><span class="s4">'raise'</span><span class="s3">):</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s1">D </span><span class="s3">= </span><span class="s1">fa</span>
            <span class="s1">C </span><span class="s3">= </span><span class="s1">fpa</span>
            <span class="s1">db </span><span class="s3">= </span><span class="s1">b </span><span class="s3">- </span><span class="s1">a </span><span class="s3">* </span><span class="s5">1.0</span>
            <span class="s1">B </span><span class="s3">= (</span><span class="s1">fb </span><span class="s3">- </span><span class="s1">D </span><span class="s3">- </span><span class="s1">C </span><span class="s3">* </span><span class="s1">db</span><span class="s3">) / (</span><span class="s1">db </span><span class="s3">* </span><span class="s1">db</span><span class="s3">)</span>
            <span class="s1">xmin </span><span class="s3">= </span><span class="s1">a </span><span class="s3">- </span><span class="s1">C </span><span class="s3">/ (</span><span class="s5">2.0 </span><span class="s3">* </span><span class="s1">B</span><span class="s3">)</span>
        <span class="s2">except </span><span class="s1">ArithmeticError</span><span class="s3">:</span>
            <span class="s2">return None</span>
    <span class="s2">if not </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isfinite</span><span class="s3">(</span><span class="s1">xmin</span><span class="s3">):</span>
        <span class="s2">return None</span>
    <span class="s2">return </span><span class="s1">xmin</span>


<span class="s2">def </span><span class="s1">_zoom</span><span class="s3">(</span><span class="s1">a_lo</span><span class="s3">, </span><span class="s1">a_hi</span><span class="s3">, </span><span class="s1">phi_lo</span><span class="s3">, </span><span class="s1">phi_hi</span><span class="s3">, </span><span class="s1">derphi_lo</span><span class="s3">,</span>
          <span class="s1">phi</span><span class="s3">, </span><span class="s1">derphi</span><span class="s3">, </span><span class="s1">phi0</span><span class="s3">, </span><span class="s1">derphi0</span><span class="s3">, </span><span class="s1">c1</span><span class="s3">, </span><span class="s1">c2</span><span class="s3">, </span><span class="s1">extra_condition</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Zoom stage of approximate linesearch satisfying strong Wolfe conditions. 
 
    Part of the optimization algorithm in `scalar_search_wolfe2`. 
 
    Notes 
    ----- 
    Implements Algorithm 3.6 (zoom) in Wright and Nocedal, 
    'Numerical Optimization', 1999, pp. 61. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">maxiter </span><span class="s3">= </span><span class="s5">10</span>
    <span class="s1">i </span><span class="s3">= </span><span class="s5">0</span>
    <span class="s1">delta1 </span><span class="s3">= </span><span class="s5">0.2  </span><span class="s6"># cubic interpolant check</span>
    <span class="s1">delta2 </span><span class="s3">= </span><span class="s5">0.1  </span><span class="s6"># quadratic interpolant check</span>
    <span class="s1">phi_rec </span><span class="s3">= </span><span class="s1">phi0</span>
    <span class="s1">a_rec </span><span class="s3">= </span><span class="s5">0</span>
    <span class="s2">while True</span><span class="s3">:</span>
        <span class="s6"># interpolate to find a trial step length between a_lo and</span>
        <span class="s6"># a_hi Need to choose interpolation here. Use cubic</span>
        <span class="s6"># interpolation and then if the result is within delta *</span>
        <span class="s6"># dalpha or outside of the interval bounded by a_lo or a_hi</span>
        <span class="s6"># then use quadratic interpolation, if the result is still too</span>
        <span class="s6"># close, then use bisection</span>

        <span class="s1">dalpha </span><span class="s3">= </span><span class="s1">a_hi </span><span class="s3">- </span><span class="s1">a_lo</span>
        <span class="s2">if </span><span class="s1">dalpha </span><span class="s3">&lt; </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s1">a</span><span class="s3">, </span><span class="s1">b </span><span class="s3">= </span><span class="s1">a_hi</span><span class="s3">, </span><span class="s1">a_lo</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">a</span><span class="s3">, </span><span class="s1">b </span><span class="s3">= </span><span class="s1">a_lo</span><span class="s3">, </span><span class="s1">a_hi</span>

        <span class="s6"># minimizer of cubic interpolant</span>
        <span class="s6"># (uses phi_lo, derphi_lo, phi_hi, and the most recent value of phi)</span>
        <span class="s6">#</span>
        <span class="s6"># if the result is too close to the end points (or out of the</span>
        <span class="s6"># interval), then use quadratic interpolation with phi_lo,</span>
        <span class="s6"># derphi_lo and phi_hi if the result is still too close to the</span>
        <span class="s6"># end points (or out of the interval) then use bisection</span>

        <span class="s2">if </span><span class="s3">(</span><span class="s1">i </span><span class="s3">&gt; </span><span class="s5">0</span><span class="s3">):</span>
            <span class="s1">cchk </span><span class="s3">= </span><span class="s1">delta1 </span><span class="s3">* </span><span class="s1">dalpha</span>
            <span class="s1">a_j </span><span class="s3">= </span><span class="s1">_cubicmin</span><span class="s3">(</span><span class="s1">a_lo</span><span class="s3">, </span><span class="s1">phi_lo</span><span class="s3">, </span><span class="s1">derphi_lo</span><span class="s3">, </span><span class="s1">a_hi</span><span class="s3">, </span><span class="s1">phi_hi</span><span class="s3">,</span>
                            <span class="s1">a_rec</span><span class="s3">, </span><span class="s1">phi_rec</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s3">(</span><span class="s1">i </span><span class="s3">== </span><span class="s5">0</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">a_j </span><span class="s2">is None</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">a_j </span><span class="s3">&gt; </span><span class="s1">b </span><span class="s3">- </span><span class="s1">cchk</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">a_j </span><span class="s3">&lt; </span><span class="s1">a </span><span class="s3">+ </span><span class="s1">cchk</span><span class="s3">):</span>
            <span class="s1">qchk </span><span class="s3">= </span><span class="s1">delta2 </span><span class="s3">* </span><span class="s1">dalpha</span>
            <span class="s1">a_j </span><span class="s3">= </span><span class="s1">_quadmin</span><span class="s3">(</span><span class="s1">a_lo</span><span class="s3">, </span><span class="s1">phi_lo</span><span class="s3">, </span><span class="s1">derphi_lo</span><span class="s3">, </span><span class="s1">a_hi</span><span class="s3">, </span><span class="s1">phi_hi</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s3">(</span><span class="s1">a_j </span><span class="s2">is None</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">a_j </span><span class="s3">&gt; </span><span class="s1">b</span><span class="s3">-</span><span class="s1">qchk</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">a_j </span><span class="s3">&lt; </span><span class="s1">a</span><span class="s3">+</span><span class="s1">qchk</span><span class="s3">):</span>
                <span class="s1">a_j </span><span class="s3">= </span><span class="s1">a_lo </span><span class="s3">+ </span><span class="s5">0.5</span><span class="s3">*</span><span class="s1">dalpha</span>

        <span class="s6"># Check new value of a_j</span>

        <span class="s1">phi_aj </span><span class="s3">= </span><span class="s1">phi</span><span class="s3">(</span><span class="s1">a_j</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s3">(</span><span class="s1">phi_aj </span><span class="s3">&gt; </span><span class="s1">phi0 </span><span class="s3">+ </span><span class="s1">c1</span><span class="s3">*</span><span class="s1">a_j</span><span class="s3">*</span><span class="s1">derphi0</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">phi_aj </span><span class="s3">&gt;= </span><span class="s1">phi_lo</span><span class="s3">):</span>
            <span class="s1">phi_rec </span><span class="s3">= </span><span class="s1">phi_hi</span>
            <span class="s1">a_rec </span><span class="s3">= </span><span class="s1">a_hi</span>
            <span class="s1">a_hi </span><span class="s3">= </span><span class="s1">a_j</span>
            <span class="s1">phi_hi </span><span class="s3">= </span><span class="s1">phi_aj</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">derphi_aj </span><span class="s3">= </span><span class="s1">derphi</span><span class="s3">(</span><span class="s1">a_j</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">derphi_aj</span><span class="s3">) &lt;= -</span><span class="s1">c2</span><span class="s3">*</span><span class="s1">derphi0 </span><span class="s2">and </span><span class="s1">extra_condition</span><span class="s3">(</span><span class="s1">a_j</span><span class="s3">, </span><span class="s1">phi_aj</span><span class="s3">):</span>
                <span class="s1">a_star </span><span class="s3">= </span><span class="s1">a_j</span>
                <span class="s1">val_star </span><span class="s3">= </span><span class="s1">phi_aj</span>
                <span class="s1">valprime_star </span><span class="s3">= </span><span class="s1">derphi_aj</span>
                <span class="s2">break</span>
            <span class="s2">if </span><span class="s1">derphi_aj</span><span class="s3">*(</span><span class="s1">a_hi </span><span class="s3">- </span><span class="s1">a_lo</span><span class="s3">) &gt;= </span><span class="s5">0</span><span class="s3">:</span>
                <span class="s1">phi_rec </span><span class="s3">= </span><span class="s1">phi_hi</span>
                <span class="s1">a_rec </span><span class="s3">= </span><span class="s1">a_hi</span>
                <span class="s1">a_hi </span><span class="s3">= </span><span class="s1">a_lo</span>
                <span class="s1">phi_hi </span><span class="s3">= </span><span class="s1">phi_lo</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">phi_rec </span><span class="s3">= </span><span class="s1">phi_lo</span>
                <span class="s1">a_rec </span><span class="s3">= </span><span class="s1">a_lo</span>
            <span class="s1">a_lo </span><span class="s3">= </span><span class="s1">a_j</span>
            <span class="s1">phi_lo </span><span class="s3">= </span><span class="s1">phi_aj</span>
            <span class="s1">derphi_lo </span><span class="s3">= </span><span class="s1">derphi_aj</span>
        <span class="s1">i </span><span class="s3">+= </span><span class="s5">1</span>
        <span class="s2">if </span><span class="s3">(</span><span class="s1">i </span><span class="s3">&gt; </span><span class="s1">maxiter</span><span class="s3">):</span>
            <span class="s6"># Failed to find a conforming step size</span>
            <span class="s1">a_star </span><span class="s3">= </span><span class="s2">None</span>
            <span class="s1">val_star </span><span class="s3">= </span><span class="s2">None</span>
            <span class="s1">valprime_star </span><span class="s3">= </span><span class="s2">None</span>
            <span class="s2">break</span>
    <span class="s2">return </span><span class="s1">a_star</span><span class="s3">, </span><span class="s1">val_star</span><span class="s3">, </span><span class="s1">valprime_star</span>


<span class="s6">#------------------------------------------------------------------------------</span>
<span class="s6"># Armijo line and scalar searches</span>
<span class="s6">#------------------------------------------------------------------------------</span>

<span class="s2">def </span><span class="s1">line_search_armijo</span><span class="s3">(</span><span class="s1">f</span><span class="s3">, </span><span class="s1">xk</span><span class="s3">, </span><span class="s1">pk</span><span class="s3">, </span><span class="s1">gfk</span><span class="s3">, </span><span class="s1">old_fval</span><span class="s3">, </span><span class="s1">args</span><span class="s3">=(), </span><span class="s1">c1</span><span class="s3">=</span><span class="s5">1e-4</span><span class="s3">, </span><span class="s1">alpha0</span><span class="s3">=</span><span class="s5">1</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Minimize over alpha, the function ``f(xk+alpha pk)``. 
 
    Parameters 
    ---------- 
    f : callable 
        Function to be minimized. 
    xk : array_like 
        Current point. 
    pk : array_like 
        Search direction. 
    gfk : array_like 
        Gradient of `f` at point `xk`. 
    old_fval : float 
        Value of `f` at point `xk`. 
    args : tuple, optional 
        Optional arguments. 
    c1 : float, optional 
        Value to control stopping criterion. 
    alpha0 : scalar, optional 
        Value of `alpha` at start of the optimization. 
 
    Returns 
    ------- 
    alpha 
    f_count 
    f_val_at_alpha 
 
    Notes 
    ----- 
    Uses the interpolation algorithm (Armijo backtracking) as suggested by 
    Wright and Nocedal in 'Numerical Optimization', 1999, pp. 56-57 
 
    &quot;&quot;&quot;</span>
    <span class="s1">xk </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">atleast_1d</span><span class="s3">(</span><span class="s1">xk</span><span class="s3">)</span>
    <span class="s1">fc </span><span class="s3">= [</span><span class="s5">0</span><span class="s3">]</span>

    <span class="s2">def </span><span class="s1">phi</span><span class="s3">(</span><span class="s1">alpha1</span><span class="s3">):</span>
        <span class="s1">fc</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] += </span><span class="s5">1</span>
        <span class="s2">return </span><span class="s1">f</span><span class="s3">(</span><span class="s1">xk </span><span class="s3">+ </span><span class="s1">alpha1</span><span class="s3">*</span><span class="s1">pk</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">old_fval </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">phi0 </span><span class="s3">= </span><span class="s1">phi</span><span class="s3">(</span><span class="s5">0.</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">phi0 </span><span class="s3">= </span><span class="s1">old_fval  </span><span class="s6"># compute f(xk) -- done in past loop</span>

    <span class="s1">derphi0 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">dot</span><span class="s3">(</span><span class="s1">gfk</span><span class="s3">, </span><span class="s1">pk</span><span class="s3">)</span>
    <span class="s1">alpha</span><span class="s3">, </span><span class="s1">phi1 </span><span class="s3">= </span><span class="s1">scalar_search_armijo</span><span class="s3">(</span><span class="s1">phi</span><span class="s3">, </span><span class="s1">phi0</span><span class="s3">, </span><span class="s1">derphi0</span><span class="s3">, </span><span class="s1">c1</span><span class="s3">=</span><span class="s1">c1</span><span class="s3">,</span>
                                       <span class="s1">alpha0</span><span class="s3">=</span><span class="s1">alpha0</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">alpha</span><span class="s3">, </span><span class="s1">fc</span><span class="s3">[</span><span class="s5">0</span><span class="s3">], </span><span class="s1">phi1</span>


<span class="s2">def </span><span class="s1">line_search_BFGS</span><span class="s3">(</span><span class="s1">f</span><span class="s3">, </span><span class="s1">xk</span><span class="s3">, </span><span class="s1">pk</span><span class="s3">, </span><span class="s1">gfk</span><span class="s3">, </span><span class="s1">old_fval</span><span class="s3">, </span><span class="s1">args</span><span class="s3">=(), </span><span class="s1">c1</span><span class="s3">=</span><span class="s5">1e-4</span><span class="s3">, </span><span class="s1">alpha0</span><span class="s3">=</span><span class="s5">1</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Compatibility wrapper for `line_search_armijo` 
    &quot;&quot;&quot;</span>
    <span class="s1">r </span><span class="s3">= </span><span class="s1">line_search_armijo</span><span class="s3">(</span><span class="s1">f</span><span class="s3">, </span><span class="s1">xk</span><span class="s3">, </span><span class="s1">pk</span><span class="s3">, </span><span class="s1">gfk</span><span class="s3">, </span><span class="s1">old_fval</span><span class="s3">, </span><span class="s1">args</span><span class="s3">=</span><span class="s1">args</span><span class="s3">, </span><span class="s1">c1</span><span class="s3">=</span><span class="s1">c1</span><span class="s3">,</span>
                           <span class="s1">alpha0</span><span class="s3">=</span><span class="s1">alpha0</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">r</span><span class="s3">[</span><span class="s5">0</span><span class="s3">], </span><span class="s1">r</span><span class="s3">[</span><span class="s5">1</span><span class="s3">], </span><span class="s5">0</span><span class="s3">, </span><span class="s1">r</span><span class="s3">[</span><span class="s5">2</span><span class="s3">]</span>


<span class="s2">def </span><span class="s1">scalar_search_armijo</span><span class="s3">(</span><span class="s1">phi</span><span class="s3">, </span><span class="s1">phi0</span><span class="s3">, </span><span class="s1">derphi0</span><span class="s3">, </span><span class="s1">c1</span><span class="s3">=</span><span class="s5">1e-4</span><span class="s3">, </span><span class="s1">alpha0</span><span class="s3">=</span><span class="s5">1</span><span class="s3">, </span><span class="s1">amin</span><span class="s3">=</span><span class="s5">0</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Minimize over alpha, the function ``phi(alpha)``. 
 
    Uses the interpolation algorithm (Armijo backtracking) as suggested by 
    Wright and Nocedal in 'Numerical Optimization', 1999, pp. 56-57 
 
    alpha &gt; 0 is assumed to be a descent direction. 
 
    Returns 
    ------- 
    alpha 
    phi1 
 
    &quot;&quot;&quot;</span>
    <span class="s1">phi_a0 </span><span class="s3">= </span><span class="s1">phi</span><span class="s3">(</span><span class="s1">alpha0</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">phi_a0 </span><span class="s3">&lt;= </span><span class="s1">phi0 </span><span class="s3">+ </span><span class="s1">c1</span><span class="s3">*</span><span class="s1">alpha0</span><span class="s3">*</span><span class="s1">derphi0</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">alpha0</span><span class="s3">, </span><span class="s1">phi_a0</span>

    <span class="s6"># Otherwise, compute the minimizer of a quadratic interpolant:</span>

    <span class="s1">alpha1 </span><span class="s3">= -(</span><span class="s1">derphi0</span><span class="s3">) * </span><span class="s1">alpha0</span><span class="s3">**</span><span class="s5">2 </span><span class="s3">/ </span><span class="s5">2.0 </span><span class="s3">/ (</span><span class="s1">phi_a0 </span><span class="s3">- </span><span class="s1">phi0 </span><span class="s3">- </span><span class="s1">derphi0 </span><span class="s3">* </span><span class="s1">alpha0</span><span class="s3">)</span>
    <span class="s1">phi_a1 </span><span class="s3">= </span><span class="s1">phi</span><span class="s3">(</span><span class="s1">alpha1</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s3">(</span><span class="s1">phi_a1 </span><span class="s3">&lt;= </span><span class="s1">phi0 </span><span class="s3">+ </span><span class="s1">c1</span><span class="s3">*</span><span class="s1">alpha1</span><span class="s3">*</span><span class="s1">derphi0</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">alpha1</span><span class="s3">, </span><span class="s1">phi_a1</span>

    <span class="s6"># Otherwise, loop with cubic interpolation until we find an alpha which</span>
    <span class="s6"># satisfies the first Wolfe condition (since we are backtracking, we will</span>
    <span class="s6"># assume that the value of alpha is not too small and satisfies the second</span>
    <span class="s6"># condition.</span>

    <span class="s2">while </span><span class="s1">alpha1 </span><span class="s3">&gt; </span><span class="s1">amin</span><span class="s3">:       </span><span class="s6"># we are assuming alpha&gt;0 is a descent direction</span>
        <span class="s1">factor </span><span class="s3">= </span><span class="s1">alpha0</span><span class="s3">**</span><span class="s5">2 </span><span class="s3">* </span><span class="s1">alpha1</span><span class="s3">**</span><span class="s5">2 </span><span class="s3">* (</span><span class="s1">alpha1</span><span class="s3">-</span><span class="s1">alpha0</span><span class="s3">)</span>
        <span class="s1">a </span><span class="s3">= </span><span class="s1">alpha0</span><span class="s3">**</span><span class="s5">2 </span><span class="s3">* (</span><span class="s1">phi_a1 </span><span class="s3">- </span><span class="s1">phi0 </span><span class="s3">- </span><span class="s1">derphi0</span><span class="s3">*</span><span class="s1">alpha1</span><span class="s3">) - </span><span class="s1">\</span>
            <span class="s1">alpha1</span><span class="s3">**</span><span class="s5">2 </span><span class="s3">* (</span><span class="s1">phi_a0 </span><span class="s3">- </span><span class="s1">phi0 </span><span class="s3">- </span><span class="s1">derphi0</span><span class="s3">*</span><span class="s1">alpha0</span><span class="s3">)</span>
        <span class="s1">a </span><span class="s3">= </span><span class="s1">a </span><span class="s3">/ </span><span class="s1">factor</span>
        <span class="s1">b </span><span class="s3">= -</span><span class="s1">alpha0</span><span class="s3">**</span><span class="s5">3 </span><span class="s3">* (</span><span class="s1">phi_a1 </span><span class="s3">- </span><span class="s1">phi0 </span><span class="s3">- </span><span class="s1">derphi0</span><span class="s3">*</span><span class="s1">alpha1</span><span class="s3">) + </span><span class="s1">\</span>
            <span class="s1">alpha1</span><span class="s3">**</span><span class="s5">3 </span><span class="s3">* (</span><span class="s1">phi_a0 </span><span class="s3">- </span><span class="s1">phi0 </span><span class="s3">- </span><span class="s1">derphi0</span><span class="s3">*</span><span class="s1">alpha0</span><span class="s3">)</span>
        <span class="s1">b </span><span class="s3">= </span><span class="s1">b </span><span class="s3">/ </span><span class="s1">factor</span>

        <span class="s1">alpha2 </span><span class="s3">= (-</span><span class="s1">b </span><span class="s3">+ </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">b</span><span class="s3">**</span><span class="s5">2 </span><span class="s3">- </span><span class="s5">3 </span><span class="s3">* </span><span class="s1">a </span><span class="s3">* </span><span class="s1">derphi0</span><span class="s3">))) / (</span><span class="s5">3.0</span><span class="s3">*</span><span class="s1">a</span><span class="s3">)</span>
        <span class="s1">phi_a2 </span><span class="s3">= </span><span class="s1">phi</span><span class="s3">(</span><span class="s1">alpha2</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s3">(</span><span class="s1">phi_a2 </span><span class="s3">&lt;= </span><span class="s1">phi0 </span><span class="s3">+ </span><span class="s1">c1</span><span class="s3">*</span><span class="s1">alpha2</span><span class="s3">*</span><span class="s1">derphi0</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">alpha2</span><span class="s3">, </span><span class="s1">phi_a2</span>

        <span class="s2">if </span><span class="s3">(</span><span class="s1">alpha1 </span><span class="s3">- </span><span class="s1">alpha2</span><span class="s3">) &gt; </span><span class="s1">alpha1 </span><span class="s3">/ </span><span class="s5">2.0 </span><span class="s2">or </span><span class="s3">(</span><span class="s5">1 </span><span class="s3">- </span><span class="s1">alpha2</span><span class="s3">/</span><span class="s1">alpha1</span><span class="s3">) &lt; </span><span class="s5">0.96</span><span class="s3">:</span>
            <span class="s1">alpha2 </span><span class="s3">= </span><span class="s1">alpha1 </span><span class="s3">/ </span><span class="s5">2.0</span>

        <span class="s1">alpha0 </span><span class="s3">= </span><span class="s1">alpha1</span>
        <span class="s1">alpha1 </span><span class="s3">= </span><span class="s1">alpha2</span>
        <span class="s1">phi_a0 </span><span class="s3">= </span><span class="s1">phi_a1</span>
        <span class="s1">phi_a1 </span><span class="s3">= </span><span class="s1">phi_a2</span>

    <span class="s6"># Failed to find a suitable step length</span>
    <span class="s2">return None</span><span class="s3">, </span><span class="s1">phi_a1</span>


<span class="s6">#------------------------------------------------------------------------------</span>
<span class="s6"># Non-monotone line search for DF-SANE</span>
<span class="s6">#------------------------------------------------------------------------------</span>

<span class="s2">def </span><span class="s1">_nonmonotone_line_search_cruz</span><span class="s3">(</span><span class="s1">f</span><span class="s3">, </span><span class="s1">x_k</span><span class="s3">, </span><span class="s1">d</span><span class="s3">, </span><span class="s1">prev_fs</span><span class="s3">, </span><span class="s1">eta</span><span class="s3">,</span>
                                  <span class="s1">gamma</span><span class="s3">=</span><span class="s5">1e-4</span><span class="s3">, </span><span class="s1">tau_min</span><span class="s3">=</span><span class="s5">0.1</span><span class="s3">, </span><span class="s1">tau_max</span><span class="s3">=</span><span class="s5">0.5</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Nonmonotone backtracking line search as described in [1]_ 
 
    Parameters 
    ---------- 
    f : callable 
        Function returning a tuple ``(f, F)`` where ``f`` is the value 
        of a merit function and ``F`` the residual. 
    x_k : ndarray 
        Initial position. 
    d : ndarray 
        Search direction. 
    prev_fs : float 
        List of previous merit function values. Should have ``len(prev_fs) &lt;= M`` 
        where ``M`` is the nonmonotonicity window parameter. 
    eta : float 
        Allowed merit function increase, see [1]_ 
    gamma, tau_min, tau_max : float, optional 
        Search parameters, see [1]_ 
 
    Returns 
    ------- 
    alpha : float 
        Step length 
    xp : ndarray 
        Next position 
    fp : float 
        Merit function value at next position 
    Fp : ndarray 
        Residual at next position 
 
    References 
    ---------- 
    [1] &quot;Spectral residual method without gradient information for solving 
        large-scale nonlinear systems of equations.&quot; W. La Cruz, 
        J.M. Martinez, M. Raydan. Math. Comp. **75**, 1429 (2006). 
 
    &quot;&quot;&quot;</span>
    <span class="s1">f_k </span><span class="s3">= </span><span class="s1">prev_fs</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">]</span>
    <span class="s1">f_bar </span><span class="s3">= </span><span class="s1">max</span><span class="s3">(</span><span class="s1">prev_fs</span><span class="s3">)</span>

    <span class="s1">alpha_p </span><span class="s3">= </span><span class="s5">1</span>
    <span class="s1">alpha_m </span><span class="s3">= </span><span class="s5">1</span>
    <span class="s1">alpha </span><span class="s3">= </span><span class="s5">1</span>

    <span class="s2">while True</span><span class="s3">:</span>
        <span class="s1">xp </span><span class="s3">= </span><span class="s1">x_k </span><span class="s3">+ </span><span class="s1">alpha_p </span><span class="s3">* </span><span class="s1">d</span>
        <span class="s1">fp</span><span class="s3">, </span><span class="s1">Fp </span><span class="s3">= </span><span class="s1">f</span><span class="s3">(</span><span class="s1">xp</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">fp </span><span class="s3">&lt;= </span><span class="s1">f_bar </span><span class="s3">+ </span><span class="s1">eta </span><span class="s3">- </span><span class="s1">gamma </span><span class="s3">* </span><span class="s1">alpha_p</span><span class="s3">**</span><span class="s5">2 </span><span class="s3">* </span><span class="s1">f_k</span><span class="s3">:</span>
            <span class="s1">alpha </span><span class="s3">= </span><span class="s1">alpha_p</span>
            <span class="s2">break</span>

        <span class="s1">alpha_tp </span><span class="s3">= </span><span class="s1">alpha_p</span><span class="s3">**</span><span class="s5">2 </span><span class="s3">* </span><span class="s1">f_k </span><span class="s3">/ (</span><span class="s1">fp </span><span class="s3">+ (</span><span class="s5">2</span><span class="s3">*</span><span class="s1">alpha_p </span><span class="s3">- </span><span class="s5">1</span><span class="s3">)*</span><span class="s1">f_k</span><span class="s3">)</span>

        <span class="s1">xp </span><span class="s3">= </span><span class="s1">x_k </span><span class="s3">- </span><span class="s1">alpha_m </span><span class="s3">* </span><span class="s1">d</span>
        <span class="s1">fp</span><span class="s3">, </span><span class="s1">Fp </span><span class="s3">= </span><span class="s1">f</span><span class="s3">(</span><span class="s1">xp</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">fp </span><span class="s3">&lt;= </span><span class="s1">f_bar </span><span class="s3">+ </span><span class="s1">eta </span><span class="s3">- </span><span class="s1">gamma </span><span class="s3">* </span><span class="s1">alpha_m</span><span class="s3">**</span><span class="s5">2 </span><span class="s3">* </span><span class="s1">f_k</span><span class="s3">:</span>
            <span class="s1">alpha </span><span class="s3">= -</span><span class="s1">alpha_m</span>
            <span class="s2">break</span>

        <span class="s1">alpha_tm </span><span class="s3">= </span><span class="s1">alpha_m</span><span class="s3">**</span><span class="s5">2 </span><span class="s3">* </span><span class="s1">f_k </span><span class="s3">/ (</span><span class="s1">fp </span><span class="s3">+ (</span><span class="s5">2</span><span class="s3">*</span><span class="s1">alpha_m </span><span class="s3">- </span><span class="s5">1</span><span class="s3">)*</span><span class="s1">f_k</span><span class="s3">)</span>

        <span class="s1">alpha_p </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">clip</span><span class="s3">(</span><span class="s1">alpha_tp</span><span class="s3">, </span><span class="s1">tau_min </span><span class="s3">* </span><span class="s1">alpha_p</span><span class="s3">, </span><span class="s1">tau_max </span><span class="s3">* </span><span class="s1">alpha_p</span><span class="s3">)</span>
        <span class="s1">alpha_m </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">clip</span><span class="s3">(</span><span class="s1">alpha_tm</span><span class="s3">, </span><span class="s1">tau_min </span><span class="s3">* </span><span class="s1">alpha_m</span><span class="s3">, </span><span class="s1">tau_max </span><span class="s3">* </span><span class="s1">alpha_m</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">alpha</span><span class="s3">, </span><span class="s1">xp</span><span class="s3">, </span><span class="s1">fp</span><span class="s3">, </span><span class="s1">Fp</span>


<span class="s2">def </span><span class="s1">_nonmonotone_line_search_cheng</span><span class="s3">(</span><span class="s1">f</span><span class="s3">, </span><span class="s1">x_k</span><span class="s3">, </span><span class="s1">d</span><span class="s3">, </span><span class="s1">f_k</span><span class="s3">, </span><span class="s1">C</span><span class="s3">, </span><span class="s1">Q</span><span class="s3">, </span><span class="s1">eta</span><span class="s3">,</span>
                                   <span class="s1">gamma</span><span class="s3">=</span><span class="s5">1e-4</span><span class="s3">, </span><span class="s1">tau_min</span><span class="s3">=</span><span class="s5">0.1</span><span class="s3">, </span><span class="s1">tau_max</span><span class="s3">=</span><span class="s5">0.5</span><span class="s3">,</span>
                                   <span class="s1">nu</span><span class="s3">=</span><span class="s5">0.85</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Nonmonotone line search from [1] 
 
    Parameters 
    ---------- 
    f : callable 
        Function returning a tuple ``(f, F)`` where ``f`` is the value 
        of a merit function and ``F`` the residual. 
    x_k : ndarray 
        Initial position. 
    d : ndarray 
        Search direction. 
    f_k : float 
        Initial merit function value. 
    C, Q : float 
        Control parameters. On the first iteration, give values 
        Q=1.0, C=f_k 
    eta : float 
        Allowed merit function increase, see [1]_ 
    nu, gamma, tau_min, tau_max : float, optional 
        Search parameters, see [1]_ 
 
    Returns 
    ------- 
    alpha : float 
        Step length 
    xp : ndarray 
        Next position 
    fp : float 
        Merit function value at next position 
    Fp : ndarray 
        Residual at next position 
    C : float 
        New value for the control parameter C 
    Q : float 
        New value for the control parameter Q 
 
    References 
    ---------- 
    .. [1] W. Cheng &amp; D.-H. Li, ''A derivative-free nonmonotone line 
           search and its application to the spectral residual 
           method'', IMA J. Numer. Anal. 29, 814 (2009). 
 
    &quot;&quot;&quot;</span>
    <span class="s1">alpha_p </span><span class="s3">= </span><span class="s5">1</span>
    <span class="s1">alpha_m </span><span class="s3">= </span><span class="s5">1</span>
    <span class="s1">alpha </span><span class="s3">= </span><span class="s5">1</span>

    <span class="s2">while True</span><span class="s3">:</span>
        <span class="s1">xp </span><span class="s3">= </span><span class="s1">x_k </span><span class="s3">+ </span><span class="s1">alpha_p </span><span class="s3">* </span><span class="s1">d</span>
        <span class="s1">fp</span><span class="s3">, </span><span class="s1">Fp </span><span class="s3">= </span><span class="s1">f</span><span class="s3">(</span><span class="s1">xp</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">fp </span><span class="s3">&lt;= </span><span class="s1">C </span><span class="s3">+ </span><span class="s1">eta </span><span class="s3">- </span><span class="s1">gamma </span><span class="s3">* </span><span class="s1">alpha_p</span><span class="s3">**</span><span class="s5">2 </span><span class="s3">* </span><span class="s1">f_k</span><span class="s3">:</span>
            <span class="s1">alpha </span><span class="s3">= </span><span class="s1">alpha_p</span>
            <span class="s2">break</span>

        <span class="s1">alpha_tp </span><span class="s3">= </span><span class="s1">alpha_p</span><span class="s3">**</span><span class="s5">2 </span><span class="s3">* </span><span class="s1">f_k </span><span class="s3">/ (</span><span class="s1">fp </span><span class="s3">+ (</span><span class="s5">2</span><span class="s3">*</span><span class="s1">alpha_p </span><span class="s3">- </span><span class="s5">1</span><span class="s3">)*</span><span class="s1">f_k</span><span class="s3">)</span>

        <span class="s1">xp </span><span class="s3">= </span><span class="s1">x_k </span><span class="s3">- </span><span class="s1">alpha_m </span><span class="s3">* </span><span class="s1">d</span>
        <span class="s1">fp</span><span class="s3">, </span><span class="s1">Fp </span><span class="s3">= </span><span class="s1">f</span><span class="s3">(</span><span class="s1">xp</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">fp </span><span class="s3">&lt;= </span><span class="s1">C </span><span class="s3">+ </span><span class="s1">eta </span><span class="s3">- </span><span class="s1">gamma </span><span class="s3">* </span><span class="s1">alpha_m</span><span class="s3">**</span><span class="s5">2 </span><span class="s3">* </span><span class="s1">f_k</span><span class="s3">:</span>
            <span class="s1">alpha </span><span class="s3">= -</span><span class="s1">alpha_m</span>
            <span class="s2">break</span>

        <span class="s1">alpha_tm </span><span class="s3">= </span><span class="s1">alpha_m</span><span class="s3">**</span><span class="s5">2 </span><span class="s3">* </span><span class="s1">f_k </span><span class="s3">/ (</span><span class="s1">fp </span><span class="s3">+ (</span><span class="s5">2</span><span class="s3">*</span><span class="s1">alpha_m </span><span class="s3">- </span><span class="s5">1</span><span class="s3">)*</span><span class="s1">f_k</span><span class="s3">)</span>

        <span class="s1">alpha_p </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">clip</span><span class="s3">(</span><span class="s1">alpha_tp</span><span class="s3">, </span><span class="s1">tau_min </span><span class="s3">* </span><span class="s1">alpha_p</span><span class="s3">, </span><span class="s1">tau_max </span><span class="s3">* </span><span class="s1">alpha_p</span><span class="s3">)</span>
        <span class="s1">alpha_m </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">clip</span><span class="s3">(</span><span class="s1">alpha_tm</span><span class="s3">, </span><span class="s1">tau_min </span><span class="s3">* </span><span class="s1">alpha_m</span><span class="s3">, </span><span class="s1">tau_max </span><span class="s3">* </span><span class="s1">alpha_m</span><span class="s3">)</span>

    <span class="s6"># Update C and Q</span>
    <span class="s1">Q_next </span><span class="s3">= </span><span class="s1">nu </span><span class="s3">* </span><span class="s1">Q </span><span class="s3">+ </span><span class="s5">1</span>
    <span class="s1">C </span><span class="s3">= (</span><span class="s1">nu </span><span class="s3">* </span><span class="s1">Q </span><span class="s3">* (</span><span class="s1">C </span><span class="s3">+ </span><span class="s1">eta</span><span class="s3">) + </span><span class="s1">fp</span><span class="s3">) / </span><span class="s1">Q_next</span>
    <span class="s1">Q </span><span class="s3">= </span><span class="s1">Q_next</span>

    <span class="s2">return </span><span class="s1">alpha</span><span class="s3">, </span><span class="s1">xp</span><span class="s3">, </span><span class="s1">fp</span><span class="s3">, </span><span class="s1">Fp</span><span class="s3">, </span><span class="s1">C</span><span class="s3">, </span><span class="s1">Q</span>
</pre>
</body>
</html>