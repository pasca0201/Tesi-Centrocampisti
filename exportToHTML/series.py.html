<html>
<head>
<title>series.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #6aab73;}
.s5 { color: #2aacb8;}
.s6 { color: #7a7e85;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
series.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Data structure for 1-dimensional cross-sectional and time series data 
&quot;&quot;&quot;</span>
<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">annotations</span>

<span class="s2">from </span><span class="s1">collections</span><span class="s3">.</span><span class="s1">abc </span><span class="s2">import </span><span class="s3">(</span>
    <span class="s1">Hashable</span><span class="s3">,</span>
    <span class="s1">Iterable</span><span class="s3">,</span>
    <span class="s1">Mapping</span><span class="s3">,</span>
    <span class="s1">Sequence</span><span class="s3">,</span>
<span class="s3">)</span>
<span class="s2">import </span><span class="s1">operator</span>
<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">from </span><span class="s1">textwrap </span><span class="s2">import </span><span class="s1">dedent</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s3">(</span>
    <span class="s1">IO</span><span class="s3">,</span>
    <span class="s1">TYPE_CHECKING</span><span class="s3">,</span>
    <span class="s1">Any</span><span class="s3">,</span>
    <span class="s1">Callable</span><span class="s3">,</span>
    <span class="s1">Literal</span><span class="s3">,</span>
    <span class="s1">cast</span><span class="s3">,</span>
    <span class="s1">overload</span><span class="s3">,</span>
<span class="s3">)</span>
<span class="s2">import </span><span class="s1">warnings</span>
<span class="s2">import </span><span class="s1">weakref</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>

<span class="s2">from </span><span class="s1">pandas</span><span class="s3">.</span><span class="s1">_config </span><span class="s2">import </span><span class="s3">(</span>
    <span class="s1">using_copy_on_write</span><span class="s3">,</span>
    <span class="s1">warn_copy_on_write</span><span class="s3">,</span>
<span class="s3">)</span>
<span class="s2">from </span><span class="s1">pandas</span><span class="s3">.</span><span class="s1">_config</span><span class="s3">.</span><span class="s1">config </span><span class="s2">import </span><span class="s1">_get_option</span>

<span class="s2">from </span><span class="s1">pandas</span><span class="s3">.</span><span class="s1">_libs </span><span class="s2">import </span><span class="s3">(</span>
    <span class="s1">lib</span><span class="s3">,</span>
    <span class="s1">properties</span><span class="s3">,</span>
    <span class="s1">reshape</span><span class="s3">,</span>
<span class="s3">)</span>
<span class="s2">from </span><span class="s1">pandas</span><span class="s3">.</span><span class="s1">_libs</span><span class="s3">.</span><span class="s1">lib </span><span class="s2">import </span><span class="s1">is_range_indexer</span>
<span class="s2">from </span><span class="s1">pandas</span><span class="s3">.</span><span class="s1">compat </span><span class="s2">import </span><span class="s1">PYPY</span>
<span class="s2">from </span><span class="s1">pandas</span><span class="s3">.</span><span class="s1">compat</span><span class="s3">.</span><span class="s1">_constants </span><span class="s2">import </span><span class="s1">REF_COUNT</span>
<span class="s2">from </span><span class="s1">pandas</span><span class="s3">.</span><span class="s1">compat</span><span class="s3">.</span><span class="s1">_optional </span><span class="s2">import </span><span class="s1">import_optional_dependency</span>
<span class="s2">from </span><span class="s1">pandas</span><span class="s3">.</span><span class="s1">compat</span><span class="s3">.</span><span class="s1">numpy </span><span class="s2">import </span><span class="s1">function </span><span class="s2">as </span><span class="s1">nv</span>
<span class="s2">from </span><span class="s1">pandas</span><span class="s3">.</span><span class="s1">errors </span><span class="s2">import </span><span class="s3">(</span>
    <span class="s1">ChainedAssignmentError</span><span class="s3">,</span>
    <span class="s1">InvalidIndexError</span><span class="s3">,</span>
    <span class="s1">_chained_assignment_method_msg</span><span class="s3">,</span>
    <span class="s1">_chained_assignment_msg</span><span class="s3">,</span>
    <span class="s1">_chained_assignment_warning_method_msg</span><span class="s3">,</span>
    <span class="s1">_chained_assignment_warning_msg</span><span class="s3">,</span>
    <span class="s1">_check_cacher</span><span class="s3">,</span>
<span class="s3">)</span>
<span class="s2">from </span><span class="s1">pandas</span><span class="s3">.</span><span class="s1">util</span><span class="s3">.</span><span class="s1">_decorators </span><span class="s2">import </span><span class="s3">(</span>
    <span class="s1">Appender</span><span class="s3">,</span>
    <span class="s1">Substitution</span><span class="s3">,</span>
    <span class="s1">deprecate_nonkeyword_arguments</span><span class="s3">,</span>
    <span class="s1">doc</span><span class="s3">,</span>
<span class="s3">)</span>
<span class="s2">from </span><span class="s1">pandas</span><span class="s3">.</span><span class="s1">util</span><span class="s3">.</span><span class="s1">_exceptions </span><span class="s2">import </span><span class="s1">find_stack_level</span>
<span class="s2">from </span><span class="s1">pandas</span><span class="s3">.</span><span class="s1">util</span><span class="s3">.</span><span class="s1">_validators </span><span class="s2">import </span><span class="s3">(</span>
    <span class="s1">validate_ascending</span><span class="s3">,</span>
    <span class="s1">validate_bool_kwarg</span><span class="s3">,</span>
    <span class="s1">validate_percentile</span><span class="s3">,</span>
<span class="s3">)</span>

<span class="s2">from </span><span class="s1">pandas</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">dtypes</span><span class="s3">.</span><span class="s1">astype </span><span class="s2">import </span><span class="s1">astype_is_view</span>
<span class="s2">from </span><span class="s1">pandas</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">dtypes</span><span class="s3">.</span><span class="s1">cast </span><span class="s2">import </span><span class="s3">(</span>
    <span class="s1">LossySetitemError</span><span class="s3">,</span>
    <span class="s1">construct_1d_arraylike_from_scalar</span><span class="s3">,</span>
    <span class="s1">find_common_type</span><span class="s3">,</span>
    <span class="s1">infer_dtype_from</span><span class="s3">,</span>
    <span class="s1">maybe_box_native</span><span class="s3">,</span>
    <span class="s1">maybe_cast_pointwise_result</span><span class="s3">,</span>
<span class="s3">)</span>
<span class="s2">from </span><span class="s1">pandas</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">dtypes</span><span class="s3">.</span><span class="s1">common </span><span class="s2">import </span><span class="s3">(</span>
    <span class="s1">is_dict_like</span><span class="s3">,</span>
    <span class="s1">is_integer</span><span class="s3">,</span>
    <span class="s1">is_iterator</span><span class="s3">,</span>
    <span class="s1">is_list_like</span><span class="s3">,</span>
    <span class="s1">is_object_dtype</span><span class="s3">,</span>
    <span class="s1">is_scalar</span><span class="s3">,</span>
    <span class="s1">pandas_dtype</span><span class="s3">,</span>
    <span class="s1">validate_all_hashable</span><span class="s3">,</span>
<span class="s3">)</span>
<span class="s2">from </span><span class="s1">pandas</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">dtypes</span><span class="s3">.</span><span class="s1">dtypes </span><span class="s2">import </span><span class="s3">(</span>
    <span class="s1">CategoricalDtype</span><span class="s3">,</span>
    <span class="s1">ExtensionDtype</span><span class="s3">,</span>
    <span class="s1">SparseDtype</span><span class="s3">,</span>
<span class="s3">)</span>
<span class="s2">from </span><span class="s1">pandas</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">dtypes</span><span class="s3">.</span><span class="s1">generic </span><span class="s2">import </span><span class="s3">(</span>
    <span class="s1">ABCDataFrame</span><span class="s3">,</span>
    <span class="s1">ABCSeries</span><span class="s3">,</span>
<span class="s3">)</span>
<span class="s2">from </span><span class="s1">pandas</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">dtypes</span><span class="s3">.</span><span class="s1">inference </span><span class="s2">import </span><span class="s1">is_hashable</span>
<span class="s2">from </span><span class="s1">pandas</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">dtypes</span><span class="s3">.</span><span class="s1">missing </span><span class="s2">import </span><span class="s3">(</span>
    <span class="s1">isna</span><span class="s3">,</span>
    <span class="s1">na_value_for_dtype</span><span class="s3">,</span>
    <span class="s1">notna</span><span class="s3">,</span>
    <span class="s1">remove_na_arraylike</span><span class="s3">,</span>
<span class="s3">)</span>

<span class="s2">from </span><span class="s1">pandas</span><span class="s3">.</span><span class="s1">core </span><span class="s2">import </span><span class="s3">(</span>
    <span class="s1">algorithms</span><span class="s3">,</span>
    <span class="s1">base</span><span class="s3">,</span>
    <span class="s1">common </span><span class="s2">as </span><span class="s1">com</span><span class="s3">,</span>
    <span class="s1">missing</span><span class="s3">,</span>
    <span class="s1">nanops</span><span class="s3">,</span>
    <span class="s1">ops</span><span class="s3">,</span>
    <span class="s1">roperator</span><span class="s3">,</span>
<span class="s3">)</span>
<span class="s2">from </span><span class="s1">pandas</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">accessor </span><span class="s2">import </span><span class="s1">CachedAccessor</span>
<span class="s2">from </span><span class="s1">pandas</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">apply </span><span class="s2">import </span><span class="s1">SeriesApply</span>
<span class="s2">from </span><span class="s1">pandas</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">arrays </span><span class="s2">import </span><span class="s1">ExtensionArray</span>
<span class="s2">from </span><span class="s1">pandas</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">arrays</span><span class="s3">.</span><span class="s1">arrow </span><span class="s2">import </span><span class="s3">(</span>
    <span class="s1">ListAccessor</span><span class="s3">,</span>
    <span class="s1">StructAccessor</span><span class="s3">,</span>
<span class="s3">)</span>
<span class="s2">from </span><span class="s1">pandas</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">arrays</span><span class="s3">.</span><span class="s1">categorical </span><span class="s2">import </span><span class="s1">CategoricalAccessor</span>
<span class="s2">from </span><span class="s1">pandas</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">arrays</span><span class="s3">.</span><span class="s1">sparse </span><span class="s2">import </span><span class="s1">SparseAccessor</span>
<span class="s2">from </span><span class="s1">pandas</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">arrays</span><span class="s3">.</span><span class="s1">string_ </span><span class="s2">import </span><span class="s1">StringDtype</span>
<span class="s2">from </span><span class="s1">pandas</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">construction </span><span class="s2">import </span><span class="s3">(</span>
    <span class="s1">array </span><span class="s2">as </span><span class="s1">pd_array</span><span class="s3">,</span>
    <span class="s1">extract_array</span><span class="s3">,</span>
    <span class="s1">sanitize_array</span><span class="s3">,</span>
<span class="s3">)</span>
<span class="s2">from </span><span class="s1">pandas</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">generic </span><span class="s2">import </span><span class="s3">(</span>
    <span class="s1">NDFrame</span><span class="s3">,</span>
    <span class="s1">make_doc</span><span class="s3">,</span>
<span class="s3">)</span>
<span class="s2">from </span><span class="s1">pandas</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">indexers </span><span class="s2">import </span><span class="s3">(</span>
    <span class="s1">disallow_ndim_indexing</span><span class="s3">,</span>
    <span class="s1">unpack_1tuple</span><span class="s3">,</span>
<span class="s3">)</span>
<span class="s2">from </span><span class="s1">pandas</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">indexes</span><span class="s3">.</span><span class="s1">accessors </span><span class="s2">import </span><span class="s1">CombinedDatetimelikeProperties</span>
<span class="s2">from </span><span class="s1">pandas</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">indexes</span><span class="s3">.</span><span class="s1">api </span><span class="s2">import </span><span class="s3">(</span>
    <span class="s1">DatetimeIndex</span><span class="s3">,</span>
    <span class="s1">Index</span><span class="s3">,</span>
    <span class="s1">MultiIndex</span><span class="s3">,</span>
    <span class="s1">PeriodIndex</span><span class="s3">,</span>
    <span class="s1">default_index</span><span class="s3">,</span>
    <span class="s1">ensure_index</span><span class="s3">,</span>
<span class="s3">)</span>
<span class="s2">import </span><span class="s1">pandas</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">indexes</span><span class="s3">.</span><span class="s1">base </span><span class="s2">as </span><span class="s1">ibase</span>
<span class="s2">from </span><span class="s1">pandas</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">indexes</span><span class="s3">.</span><span class="s1">multi </span><span class="s2">import </span><span class="s1">maybe_droplevels</span>
<span class="s2">from </span><span class="s1">pandas</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">indexing </span><span class="s2">import </span><span class="s3">(</span>
    <span class="s1">check_bool_indexer</span><span class="s3">,</span>
    <span class="s1">check_dict_or_set_indexers</span><span class="s3">,</span>
<span class="s3">)</span>
<span class="s2">from </span><span class="s1">pandas</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">internals </span><span class="s2">import </span><span class="s3">(</span>
    <span class="s1">SingleArrayManager</span><span class="s3">,</span>
    <span class="s1">SingleBlockManager</span><span class="s3">,</span>
<span class="s3">)</span>
<span class="s2">from </span><span class="s1">pandas</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">methods </span><span class="s2">import </span><span class="s1">selectn</span>
<span class="s2">from </span><span class="s1">pandas</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">shared_docs </span><span class="s2">import </span><span class="s1">_shared_docs</span>
<span class="s2">from </span><span class="s1">pandas</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">sorting </span><span class="s2">import </span><span class="s3">(</span>
    <span class="s1">ensure_key_mapped</span><span class="s3">,</span>
    <span class="s1">nargsort</span><span class="s3">,</span>
<span class="s3">)</span>
<span class="s2">from </span><span class="s1">pandas</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">strings</span><span class="s3">.</span><span class="s1">accessor </span><span class="s2">import </span><span class="s1">StringMethods</span>
<span class="s2">from </span><span class="s1">pandas</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">tools</span><span class="s3">.</span><span class="s1">datetimes </span><span class="s2">import </span><span class="s1">to_datetime</span>

<span class="s2">import </span><span class="s1">pandas</span><span class="s3">.</span><span class="s1">io</span><span class="s3">.</span><span class="s1">formats</span><span class="s3">.</span><span class="s1">format </span><span class="s2">as </span><span class="s1">fmt</span>
<span class="s2">from </span><span class="s1">pandas</span><span class="s3">.</span><span class="s1">io</span><span class="s3">.</span><span class="s1">formats</span><span class="s3">.</span><span class="s1">info </span><span class="s2">import </span><span class="s3">(</span>
    <span class="s1">INFO_DOCSTRING</span><span class="s3">,</span>
    <span class="s1">SeriesInfo</span><span class="s3">,</span>
    <span class="s1">series_sub_kwargs</span><span class="s3">,</span>
<span class="s3">)</span>
<span class="s2">import </span><span class="s1">pandas</span><span class="s3">.</span><span class="s1">plotting</span>

<span class="s2">if </span><span class="s1">TYPE_CHECKING</span><span class="s3">:</span>
    <span class="s2">from </span><span class="s1">pandas</span><span class="s3">.</span><span class="s1">_libs</span><span class="s3">.</span><span class="s1">internals </span><span class="s2">import </span><span class="s1">BlockValuesRefs</span>
    <span class="s2">from </span><span class="s1">pandas</span><span class="s3">.</span><span class="s1">_typing </span><span class="s2">import </span><span class="s3">(</span>
        <span class="s1">AggFuncType</span><span class="s3">,</span>
        <span class="s1">AnyAll</span><span class="s3">,</span>
        <span class="s1">AnyArrayLike</span><span class="s3">,</span>
        <span class="s1">ArrayLike</span><span class="s3">,</span>
        <span class="s1">Axis</span><span class="s3">,</span>
        <span class="s1">AxisInt</span><span class="s3">,</span>
        <span class="s1">CorrelationMethod</span><span class="s3">,</span>
        <span class="s1">DropKeep</span><span class="s3">,</span>
        <span class="s1">Dtype</span><span class="s3">,</span>
        <span class="s1">DtypeObj</span><span class="s3">,</span>
        <span class="s1">FilePath</span><span class="s3">,</span>
        <span class="s1">Frequency</span><span class="s3">,</span>
        <span class="s1">IgnoreRaise</span><span class="s3">,</span>
        <span class="s1">IndexKeyFunc</span><span class="s3">,</span>
        <span class="s1">IndexLabel</span><span class="s3">,</span>
        <span class="s1">Level</span><span class="s3">,</span>
        <span class="s1">MutableMappingT</span><span class="s3">,</span>
        <span class="s1">NaPosition</span><span class="s3">,</span>
        <span class="s1">NumpySorter</span><span class="s3">,</span>
        <span class="s1">NumpyValueArrayLike</span><span class="s3">,</span>
        <span class="s1">QuantileInterpolation</span><span class="s3">,</span>
        <span class="s1">ReindexMethod</span><span class="s3">,</span>
        <span class="s1">Renamer</span><span class="s3">,</span>
        <span class="s1">Scalar</span><span class="s3">,</span>
        <span class="s1">Self</span><span class="s3">,</span>
        <span class="s1">SingleManager</span><span class="s3">,</span>
        <span class="s1">SortKind</span><span class="s3">,</span>
        <span class="s1">StorageOptions</span><span class="s3">,</span>
        <span class="s1">Suffixes</span><span class="s3">,</span>
        <span class="s1">ValueKeyFunc</span><span class="s3">,</span>
        <span class="s1">WriteBuffer</span><span class="s3">,</span>
        <span class="s1">npt</span><span class="s3">,</span>
    <span class="s3">)</span>

    <span class="s2">from </span><span class="s1">pandas</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">frame </span><span class="s2">import </span><span class="s1">DataFrame</span>
    <span class="s2">from </span><span class="s1">pandas</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">groupby</span><span class="s3">.</span><span class="s1">generic </span><span class="s2">import </span><span class="s1">SeriesGroupBy</span>

<span class="s1">__all__ </span><span class="s3">= [</span><span class="s4">&quot;Series&quot;</span><span class="s3">]</span>

<span class="s1">_shared_doc_kwargs </span><span class="s3">= {</span>
    <span class="s4">&quot;axes&quot;</span><span class="s3">: </span><span class="s4">&quot;index&quot;</span><span class="s3">,</span>
    <span class="s4">&quot;klass&quot;</span><span class="s3">: </span><span class="s4">&quot;Series&quot;</span><span class="s3">,</span>
    <span class="s4">&quot;axes_single_arg&quot;</span><span class="s3">: </span><span class="s4">&quot;{0 or 'index'}&quot;</span><span class="s3">,</span>
    <span class="s4">&quot;axis&quot;</span><span class="s3">: </span><span class="s4">&quot;&quot;&quot;axis : {0 or 'index'} 
        Unused. Parameter needed for compatibility with DataFrame.&quot;&quot;&quot;</span><span class="s3">,</span>
    <span class="s4">&quot;inplace&quot;</span><span class="s3">: </span><span class="s4">&quot;&quot;&quot;inplace : bool, default False 
        If True, performs operation inplace and returns None.&quot;&quot;&quot;</span><span class="s3">,</span>
    <span class="s4">&quot;unique&quot;</span><span class="s3">: </span><span class="s4">&quot;np.ndarray&quot;</span><span class="s3">,</span>
    <span class="s4">&quot;duplicated&quot;</span><span class="s3">: </span><span class="s4">&quot;Series&quot;</span><span class="s3">,</span>
    <span class="s4">&quot;optional_by&quot;</span><span class="s3">: </span><span class="s4">&quot;&quot;</span><span class="s3">,</span>
    <span class="s4">&quot;optional_reindex&quot;</span><span class="s3">: </span><span class="s4">&quot;&quot;&quot; 
index : array-like, optional 
    New labels for the index. Preferably an Index object to avoid 
    duplicating data. 
axis : int or str, optional 
    Unused.&quot;&quot;&quot;</span><span class="s3">,</span>
<span class="s3">}</span>


<span class="s2">def </span><span class="s1">_coerce_method</span><span class="s3">(</span><span class="s1">converter</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Install the scalar coercion methods. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">wrapper</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) == </span><span class="s5">1</span><span class="s3">:</span>
            <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span>
                <span class="s4">f&quot;Calling </span><span class="s2">{</span><span class="s1">converter</span><span class="s3">.</span><span class="s1">__name__</span><span class="s2">} </span><span class="s4">on a single element Series is &quot;</span>
                <span class="s4">&quot;deprecated and will raise a TypeError in the future. &quot;</span>
                <span class="s4">f&quot;Use </span><span class="s2">{</span><span class="s1">converter</span><span class="s3">.</span><span class="s1">__name__</span><span class="s2">}</span><span class="s4">(ser.iloc[0]) instead&quot;</span><span class="s3">,</span>
                <span class="s1">FutureWarning</span><span class="s3">,</span>
                <span class="s1">stacklevel</span><span class="s3">=</span><span class="s1">find_stack_level</span><span class="s3">(),</span>
            <span class="s3">)</span>
            <span class="s2">return </span><span class="s1">converter</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">iloc</span><span class="s3">[</span><span class="s5">0</span><span class="s3">])</span>
        <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s4">f&quot;cannot convert the series to </span><span class="s2">{</span><span class="s1">converter</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s3">)</span>

    <span class="s1">wrapper</span><span class="s3">.</span><span class="s1">__name__ </span><span class="s3">= </span><span class="s4">f&quot;__</span><span class="s2">{</span><span class="s1">converter</span><span class="s3">.</span><span class="s1">__name__</span><span class="s2">}</span><span class="s4">__&quot;</span>
    <span class="s2">return </span><span class="s1">wrapper</span>


<span class="s6"># ----------------------------------------------------------------------</span>
<span class="s6"># Series class</span>


<span class="s6"># error: Cannot override final attribute &quot;ndim&quot; (previously declared in base</span>
<span class="s6"># class &quot;NDFrame&quot;)</span>
<span class="s6"># error: Cannot override final attribute &quot;size&quot; (previously declared in base</span>
<span class="s6"># class &quot;NDFrame&quot;)</span>
<span class="s6"># definition in base class &quot;NDFrame&quot;</span>
<span class="s2">class </span><span class="s1">Series</span><span class="s3">(</span><span class="s1">base</span><span class="s3">.</span><span class="s1">IndexOpsMixin</span><span class="s3">, </span><span class="s1">NDFrame</span><span class="s3">):  </span><span class="s6"># type: ignore[misc]</span>
    <span class="s0">&quot;&quot;&quot; 
    One-dimensional ndarray with axis labels (including time series). 
 
    Labels need not be unique but must be a hashable type. The object 
    supports both integer- and label-based indexing and provides a host of 
    methods for performing operations involving the index. Statistical 
    methods from ndarray have been overridden to automatically exclude 
    missing data (currently represented as NaN). 
 
    Operations between Series (+, -, /, \\*, \\*\\*) align values based on their 
    associated index values-- they need not be the same length. The result 
    index will be the sorted union of the two indexes. 
 
    Parameters 
    ---------- 
    data : array-like, Iterable, dict, or scalar value 
        Contains data stored in Series. If data is a dict, argument order is 
        maintained. 
    index : array-like or Index (1d) 
        Values must be hashable and have the same length as `data`. 
        Non-unique index values are allowed. Will default to 
        RangeIndex (0, 1, 2, ..., n) if not provided. If data is dict-like 
        and index is None, then the keys in the data are used as the index. If the 
        index is not None, the resulting Series is reindexed with the index values. 
    dtype : str, numpy.dtype, or ExtensionDtype, optional 
        Data type for the output Series. If not specified, this will be 
        inferred from `data`. 
        See the :ref:`user guide &lt;basics.dtypes&gt;` for more usages. 
    name : Hashable, default None 
        The name to give to the Series. 
    copy : bool, default False 
        Copy input data. Only affects Series or 1d ndarray input. See examples. 
 
    Notes 
    ----- 
    Please reference the :ref:`User Guide &lt;basics.series&gt;` for more information. 
 
    Examples 
    -------- 
    Constructing Series from a dictionary with an Index specified 
 
    &gt;&gt;&gt; d = {'a': 1, 'b': 2, 'c': 3} 
    &gt;&gt;&gt; ser = pd.Series(data=d, index=['a', 'b', 'c']) 
    &gt;&gt;&gt; ser 
    a   1 
    b   2 
    c   3 
    dtype: int64 
 
    The keys of the dictionary match with the Index values, hence the Index 
    values have no effect. 
 
    &gt;&gt;&gt; d = {'a': 1, 'b': 2, 'c': 3} 
    &gt;&gt;&gt; ser = pd.Series(data=d, index=['x', 'y', 'z']) 
    &gt;&gt;&gt; ser 
    x   NaN 
    y   NaN 
    z   NaN 
    dtype: float64 
 
    Note that the Index is first build with the keys from the dictionary. 
    After this the Series is reindexed with the given Index values, hence we 
    get all NaN as a result. 
 
    Constructing Series from a list with `copy=False`. 
 
    &gt;&gt;&gt; r = [1, 2] 
    &gt;&gt;&gt; ser = pd.Series(r, copy=False) 
    &gt;&gt;&gt; ser.iloc[0] = 999 
    &gt;&gt;&gt; r 
    [1, 2] 
    &gt;&gt;&gt; ser 
    0    999 
    1      2 
    dtype: int64 
 
    Due to input data type the Series has a `copy` of 
    the original data even though `copy=False`, so 
    the data is unchanged. 
 
    Constructing Series from a 1d ndarray with `copy=False`. 
 
    &gt;&gt;&gt; r = np.array([1, 2]) 
    &gt;&gt;&gt; ser = pd.Series(r, copy=False) 
    &gt;&gt;&gt; ser.iloc[0] = 999 
    &gt;&gt;&gt; r 
    array([999,   2]) 
    &gt;&gt;&gt; ser 
    0    999 
    1      2 
    dtype: int64 
 
    Due to input data type the Series has a `view` on 
    the original data, so 
    the data is changed as well. 
    &quot;&quot;&quot;</span>

    <span class="s1">_typ </span><span class="s3">= </span><span class="s4">&quot;series&quot;</span>
    <span class="s1">_HANDLED_TYPES </span><span class="s3">= (</span><span class="s1">Index</span><span class="s3">, </span><span class="s1">ExtensionArray</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndarray</span><span class="s3">)</span>

    <span class="s1">_name</span><span class="s3">: </span><span class="s1">Hashable</span>
    <span class="s1">_metadata</span><span class="s3">: </span><span class="s1">list</span><span class="s3">[</span><span class="s1">str</span><span class="s3">] = [</span><span class="s4">&quot;_name&quot;</span><span class="s3">]</span>
    <span class="s1">_internal_names_set </span><span class="s3">= {</span><span class="s4">&quot;index&quot;</span><span class="s3">, </span><span class="s4">&quot;name&quot;</span><span class="s3">} | </span><span class="s1">NDFrame</span><span class="s3">.</span><span class="s1">_internal_names_set</span>
    <span class="s1">_accessors </span><span class="s3">= {</span><span class="s4">&quot;dt&quot;</span><span class="s3">, </span><span class="s4">&quot;cat&quot;</span><span class="s3">, </span><span class="s4">&quot;str&quot;</span><span class="s3">, </span><span class="s4">&quot;sparse&quot;</span><span class="s3">}</span>
    <span class="s1">_hidden_attrs </span><span class="s3">= (</span>
        <span class="s1">base</span><span class="s3">.</span><span class="s1">IndexOpsMixin</span><span class="s3">.</span><span class="s1">_hidden_attrs </span><span class="s3">| </span><span class="s1">NDFrame</span><span class="s3">.</span><span class="s1">_hidden_attrs </span><span class="s3">| </span><span class="s1">frozenset</span><span class="s3">([])</span>
    <span class="s3">)</span>

    <span class="s6"># similar to __array_priority__, positions Series after DataFrame</span>
    <span class="s6">#  but before Index and ExtensionArray.  Should NOT be overridden by subclasses.</span>
    <span class="s1">__pandas_priority__ </span><span class="s3">= </span><span class="s5">3000</span>

    <span class="s6"># Override cache_readonly bc Series is mutable</span>
    <span class="s6"># error: Incompatible types in assignment (expression has type &quot;property&quot;,</span>
    <span class="s6"># base class &quot;IndexOpsMixin&quot; defined the type as &quot;Callable[[IndexOpsMixin], bool]&quot;)</span>
    <span class="s1">hasnans </span><span class="s3">= </span><span class="s1">property</span><span class="s3">(  </span><span class="s6"># type: ignore[assignment]</span>
        <span class="s6"># error: &quot;Callable[[IndexOpsMixin], bool]&quot; has no attribute &quot;fget&quot;</span>
        <span class="s1">base</span><span class="s3">.</span><span class="s1">IndexOpsMixin</span><span class="s3">.</span><span class="s1">hasnans</span><span class="s3">.</span><span class="s1">fget</span><span class="s3">,  </span><span class="s6"># type: ignore[attr-defined]</span>
        <span class="s1">doc</span><span class="s3">=</span><span class="s1">base</span><span class="s3">.</span><span class="s1">IndexOpsMixin</span><span class="s3">.</span><span class="s1">hasnans</span><span class="s3">.</span><span class="s1">__doc__</span><span class="s3">,</span>
    <span class="s3">)</span>
    <span class="s1">_mgr</span><span class="s3">: </span><span class="s1">SingleManager</span>

    <span class="s6"># ----------------------------------------------------------------------</span>
    <span class="s6"># Constructors</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">data</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">index</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">dtype</span><span class="s3">: </span><span class="s1">Dtype </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">name</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">copy</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">fastpath</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s1">lib</span><span class="s3">.</span><span class="s1">NoDefault </span><span class="s3">= </span><span class="s1">lib</span><span class="s3">.</span><span class="s1">no_default</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">fastpath </span><span class="s2">is not </span><span class="s1">lib</span><span class="s3">.</span><span class="s1">no_default</span><span class="s3">:</span>
            <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span>
                <span class="s4">&quot;The 'fastpath' keyword in pd.Series is deprecated and will &quot;</span>
                <span class="s4">&quot;be removed in a future version.&quot;</span><span class="s3">,</span>
                <span class="s1">DeprecationWarning</span><span class="s3">,</span>
                <span class="s1">stacklevel</span><span class="s3">=</span><span class="s1">find_stack_level</span><span class="s3">(),</span>
            <span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">fastpath </span><span class="s3">= </span><span class="s2">False</span>

        <span class="s1">allow_mgr </span><span class="s3">= </span><span class="s2">False</span>
        <span class="s2">if </span><span class="s3">(</span>
            <span class="s1">isinstance</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, (</span><span class="s1">SingleBlockManager</span><span class="s3">, </span><span class="s1">SingleArrayManager</span><span class="s3">))</span>
            <span class="s2">and </span><span class="s1">index </span><span class="s2">is None</span>
            <span class="s2">and </span><span class="s1">dtype </span><span class="s2">is None</span>
            <span class="s2">and </span><span class="s3">(</span><span class="s1">copy </span><span class="s2">is False or </span><span class="s1">copy </span><span class="s2">is None</span><span class="s3">)</span>
        <span class="s3">):</span>
            <span class="s2">if not </span><span class="s1">allow_mgr</span><span class="s3">:</span>
                <span class="s6"># GH#52419</span>
                <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span>
                    <span class="s4">f&quot;Passing a </span><span class="s2">{</span><span class="s1">type</span><span class="s3">(</span><span class="s1">data</span><span class="s3">).</span><span class="s1">__name__</span><span class="s2">} </span><span class="s4">to </span><span class="s2">{</span><span class="s1">type</span><span class="s3">(</span><span class="s1">self</span><span class="s3">).</span><span class="s1">__name__</span><span class="s2">} </span><span class="s4">&quot;</span>
                    <span class="s4">&quot;is deprecated and will raise in a future version. &quot;</span>
                    <span class="s4">&quot;Use public APIs instead.&quot;</span><span class="s3">,</span>
                    <span class="s1">DeprecationWarning</span><span class="s3">,</span>
                    <span class="s1">stacklevel</span><span class="s3">=</span><span class="s5">2</span><span class="s3">,</span>
                <span class="s3">)</span>
            <span class="s2">if </span><span class="s1">using_copy_on_write</span><span class="s3">():</span>
                <span class="s1">data </span><span class="s3">= </span><span class="s1">data</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">(</span><span class="s1">deep</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
            <span class="s6"># GH#33357 called with just the SingleBlockManager</span>
            <span class="s1">NDFrame</span><span class="s3">.</span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">data</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">fastpath</span><span class="s3">:</span>
                <span class="s6"># e.g. from _box_col_values, skip validation of name</span>
                <span class="s1">object</span><span class="s3">.</span><span class="s1">__setattr__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s4">&quot;_name&quot;</span><span class="s3">, </span><span class="s1">name</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">name </span><span class="s3">= </span><span class="s1">name</span>
            <span class="s2">return</span>

        <span class="s1">is_pandas_object </span><span class="s3">= </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, (</span><span class="s1">Series</span><span class="s3">, </span><span class="s1">Index</span><span class="s3">, </span><span class="s1">ExtensionArray</span><span class="s3">))</span>
        <span class="s1">data_dtype </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s4">&quot;dtype&quot;</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
        <span class="s1">original_dtype </span><span class="s3">= </span><span class="s1">dtype</span>

        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, (</span><span class="s1">ExtensionArray</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndarray</span><span class="s3">)):</span>
            <span class="s2">if </span><span class="s1">copy </span><span class="s2">is not False and </span><span class="s1">using_copy_on_write</span><span class="s3">():</span>
                <span class="s2">if </span><span class="s1">dtype </span><span class="s2">is None or </span><span class="s1">astype_is_view</span><span class="s3">(</span><span class="s1">data</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">pandas_dtype</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">)):</span>
                    <span class="s1">data </span><span class="s3">= </span><span class="s1">data</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>
        <span class="s2">if </span><span class="s1">copy </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s1">copy </span><span class="s3">= </span><span class="s2">False</span>

        <span class="s6"># we are called internally, so short-circuit</span>
        <span class="s2">if </span><span class="s1">fastpath</span><span class="s3">:</span>
            <span class="s6"># data is a ndarray, index is defined</span>
            <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, (</span><span class="s1">SingleBlockManager</span><span class="s3">, </span><span class="s1">SingleArrayManager</span><span class="s3">)):</span>
                <span class="s1">manager </span><span class="s3">= </span><span class="s1">_get_option</span><span class="s3">(</span><span class="s4">&quot;mode.data_manager&quot;</span><span class="s3">, </span><span class="s1">silent</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
                <span class="s2">if </span><span class="s1">manager </span><span class="s3">== </span><span class="s4">&quot;block&quot;</span><span class="s3">:</span>
                    <span class="s1">data </span><span class="s3">= </span><span class="s1">SingleBlockManager</span><span class="s3">.</span><span class="s1">from_array</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">index</span><span class="s3">)</span>
                <span class="s2">elif </span><span class="s1">manager </span><span class="s3">== </span><span class="s4">&quot;array&quot;</span><span class="s3">:</span>
                    <span class="s1">data </span><span class="s3">= </span><span class="s1">SingleArrayManager</span><span class="s3">.</span><span class="s1">from_array</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">index</span><span class="s3">)</span>
                <span class="s1">allow_mgr </span><span class="s3">= </span><span class="s2">True</span>
            <span class="s2">elif </span><span class="s1">using_copy_on_write</span><span class="s3">() </span><span class="s2">and not </span><span class="s1">copy</span><span class="s3">:</span>
                <span class="s1">data </span><span class="s3">= </span><span class="s1">data</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">(</span><span class="s1">deep</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>

            <span class="s2">if not </span><span class="s1">allow_mgr</span><span class="s3">:</span>
                <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span>
                    <span class="s4">f&quot;Passing a </span><span class="s2">{</span><span class="s1">type</span><span class="s3">(</span><span class="s1">data</span><span class="s3">).</span><span class="s1">__name__</span><span class="s2">} </span><span class="s4">to </span><span class="s2">{</span><span class="s1">type</span><span class="s3">(</span><span class="s1">self</span><span class="s3">).</span><span class="s1">__name__</span><span class="s2">} </span><span class="s4">&quot;</span>
                    <span class="s4">&quot;is deprecated and will raise in a future version. &quot;</span>
                    <span class="s4">&quot;Use public APIs instead.&quot;</span><span class="s3">,</span>
                    <span class="s1">DeprecationWarning</span><span class="s3">,</span>
                    <span class="s1">stacklevel</span><span class="s3">=</span><span class="s5">2</span><span class="s3">,</span>
                <span class="s3">)</span>

            <span class="s2">if </span><span class="s1">copy</span><span class="s3">:</span>
                <span class="s1">data </span><span class="s3">= </span><span class="s1">data</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>
            <span class="s6"># skips validation of the name</span>
            <span class="s1">object</span><span class="s3">.</span><span class="s1">__setattr__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s4">&quot;_name&quot;</span><span class="s3">, </span><span class="s1">name</span><span class="s3">)</span>
            <span class="s1">NDFrame</span><span class="s3">.</span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">data</span><span class="s3">)</span>
            <span class="s2">return</span>

        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">SingleBlockManager</span><span class="s3">) </span><span class="s2">and </span><span class="s1">using_copy_on_write</span><span class="s3">() </span><span class="s2">and not </span><span class="s1">copy</span><span class="s3">:</span>
            <span class="s1">data </span><span class="s3">= </span><span class="s1">data</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">(</span><span class="s1">deep</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>

            <span class="s2">if not </span><span class="s1">allow_mgr</span><span class="s3">:</span>
                <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span>
                    <span class="s4">f&quot;Passing a </span><span class="s2">{</span><span class="s1">type</span><span class="s3">(</span><span class="s1">data</span><span class="s3">).</span><span class="s1">__name__</span><span class="s2">} </span><span class="s4">to </span><span class="s2">{</span><span class="s1">type</span><span class="s3">(</span><span class="s1">self</span><span class="s3">).</span><span class="s1">__name__</span><span class="s2">} </span><span class="s4">&quot;</span>
                    <span class="s4">&quot;is deprecated and will raise in a future version. &quot;</span>
                    <span class="s4">&quot;Use public APIs instead.&quot;</span><span class="s3">,</span>
                    <span class="s1">DeprecationWarning</span><span class="s3">,</span>
                    <span class="s1">stacklevel</span><span class="s3">=</span><span class="s5">2</span><span class="s3">,</span>
                <span class="s3">)</span>

        <span class="s1">name </span><span class="s3">= </span><span class="s1">ibase</span><span class="s3">.</span><span class="s1">maybe_extract_name</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">type</span><span class="s3">(</span><span class="s1">self</span><span class="s3">))</span>

        <span class="s2">if </span><span class="s1">index </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s1">index </span><span class="s3">= </span><span class="s1">ensure_index</span><span class="s3">(</span><span class="s1">index</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">dtype </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s1">dtype </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_validate_dtype</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">data </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s1">index </span><span class="s3">= </span><span class="s1">index </span><span class="s2">if </span><span class="s1">index </span><span class="s2">is not None else </span><span class="s1">default_index</span><span class="s3">(</span><span class="s5">0</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">index</span><span class="s3">) </span><span class="s2">or </span><span class="s1">dtype </span><span class="s2">is not None</span><span class="s3">:</span>
                <span class="s1">data </span><span class="s3">= </span><span class="s1">na_value_for_dtype</span><span class="s3">(</span><span class="s1">pandas_dtype</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">), </span><span class="s1">compat</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">data </span><span class="s3">= []</span>

        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">MultiIndex</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">NotImplementedError</span><span class="s3">(</span>
                <span class="s4">&quot;initializing a Series from a MultiIndex is not supported&quot;</span>
            <span class="s3">)</span>

        <span class="s1">refs </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">Index</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">dtype </span><span class="s2">is not None</span><span class="s3">:</span>
                <span class="s1">data </span><span class="s3">= </span><span class="s1">data</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>

            <span class="s2">if </span><span class="s1">using_copy_on_write</span><span class="s3">():</span>
                <span class="s1">refs </span><span class="s3">= </span><span class="s1">data</span><span class="s3">.</span><span class="s1">_references</span>
                <span class="s1">data </span><span class="s3">= </span><span class="s1">data</span><span class="s3">.</span><span class="s1">_values</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s6"># GH#24096 we need to ensure the index remains immutable</span>
                <span class="s1">data </span><span class="s3">= </span><span class="s1">data</span><span class="s3">.</span><span class="s1">_values</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>
            <span class="s1">copy </span><span class="s3">= </span><span class="s2">False</span>

        <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndarray</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">data</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">):</span>
                <span class="s6"># GH#13296 we are dealing with a compound dtype, which</span>
                <span class="s6">#  should be treated as 2D</span>
                <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span>
                    <span class="s4">&quot;Cannot construct a Series from an ndarray with &quot;</span>
                    <span class="s4">&quot;compound dtype.  Use DataFrame instead.&quot;</span>
                <span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">Series</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">index </span><span class="s2">is None</span><span class="s3">:</span>
                <span class="s1">index </span><span class="s3">= </span><span class="s1">data</span><span class="s3">.</span><span class="s1">index</span>
                <span class="s1">data </span><span class="s3">= </span><span class="s1">data</span><span class="s3">.</span><span class="s1">_mgr</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">(</span><span class="s1">deep</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">data </span><span class="s3">= </span><span class="s1">data</span><span class="s3">.</span><span class="s1">reindex</span><span class="s3">(</span><span class="s1">index</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s1">copy</span><span class="s3">)</span>
                <span class="s1">copy </span><span class="s3">= </span><span class="s2">False</span>
                <span class="s1">data </span><span class="s3">= </span><span class="s1">data</span><span class="s3">.</span><span class="s1">_mgr</span>
        <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">Mapping</span><span class="s3">):</span>
            <span class="s1">data</span><span class="s3">, </span><span class="s1">index </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_init_dict</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">index</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">)</span>
            <span class="s1">dtype </span><span class="s3">= </span><span class="s2">None</span>
            <span class="s1">copy </span><span class="s3">= </span><span class="s2">False</span>
        <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, (</span><span class="s1">SingleBlockManager</span><span class="s3">, </span><span class="s1">SingleArrayManager</span><span class="s3">)):</span>
            <span class="s2">if </span><span class="s1">index </span><span class="s2">is None</span><span class="s3">:</span>
                <span class="s1">index </span><span class="s3">= </span><span class="s1">data</span><span class="s3">.</span><span class="s1">index</span>
            <span class="s2">elif not </span><span class="s1">data</span><span class="s3">.</span><span class="s1">index</span><span class="s3">.</span><span class="s1">equals</span><span class="s3">(</span><span class="s1">index</span><span class="s3">) </span><span class="s2">or </span><span class="s1">copy</span><span class="s3">:</span>
                <span class="s6"># GH#19275 SingleBlockManager input should only be called</span>
                <span class="s6"># internally</span>
                <span class="s2">raise </span><span class="s1">AssertionError</span><span class="s3">(</span>
                    <span class="s4">&quot;Cannot pass both SingleBlockManager &quot;</span>
                    <span class="s4">&quot;`data` argument and a different &quot;</span>
                    <span class="s4">&quot;`index` argument. `copy` must be False.&quot;</span>
                <span class="s3">)</span>

            <span class="s2">if not </span><span class="s1">allow_mgr</span><span class="s3">:</span>
                <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span>
                    <span class="s4">f&quot;Passing a </span><span class="s2">{</span><span class="s1">type</span><span class="s3">(</span><span class="s1">data</span><span class="s3">).</span><span class="s1">__name__</span><span class="s2">} </span><span class="s4">to </span><span class="s2">{</span><span class="s1">type</span><span class="s3">(</span><span class="s1">self</span><span class="s3">).</span><span class="s1">__name__</span><span class="s2">} </span><span class="s4">&quot;</span>
                    <span class="s4">&quot;is deprecated and will raise in a future version. &quot;</span>
                    <span class="s4">&quot;Use public APIs instead.&quot;</span><span class="s3">,</span>
                    <span class="s1">DeprecationWarning</span><span class="s3">,</span>
                    <span class="s1">stacklevel</span><span class="s3">=</span><span class="s5">2</span><span class="s3">,</span>
                <span class="s3">)</span>
                <span class="s1">allow_mgr </span><span class="s3">= </span><span class="s2">True</span>

        <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">ExtensionArray</span><span class="s3">):</span>
            <span class="s2">pass</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">data </span><span class="s3">= </span><span class="s1">com</span><span class="s3">.</span><span class="s1">maybe_iterable_to_list</span><span class="s3">(</span><span class="s1">data</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">is_list_like</span><span class="s3">(</span><span class="s1">data</span><span class="s3">) </span><span class="s2">and not </span><span class="s1">len</span><span class="s3">(</span><span class="s1">data</span><span class="s3">) </span><span class="s2">and </span><span class="s1">dtype </span><span class="s2">is None</span><span class="s3">:</span>
                <span class="s6"># GH 29405: Pre-2.0, this defaulted to float.</span>
                <span class="s1">dtype </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">(</span><span class="s1">object</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">index </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s2">if not </span><span class="s1">is_list_like</span><span class="s3">(</span><span class="s1">data</span><span class="s3">):</span>
                <span class="s1">data </span><span class="s3">= [</span><span class="s1">data</span><span class="s3">]</span>
            <span class="s1">index </span><span class="s3">= </span><span class="s1">default_index</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">data</span><span class="s3">))</span>
        <span class="s2">elif </span><span class="s1">is_list_like</span><span class="s3">(</span><span class="s1">data</span><span class="s3">):</span>
            <span class="s1">com</span><span class="s3">.</span><span class="s1">require_length_match</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">index</span><span class="s3">)</span>

        <span class="s6"># create/copy the manager</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, (</span><span class="s1">SingleBlockManager</span><span class="s3">, </span><span class="s1">SingleArrayManager</span><span class="s3">)):</span>
            <span class="s2">if </span><span class="s1">dtype </span><span class="s2">is not None</span><span class="s3">:</span>
                <span class="s1">data </span><span class="s3">= </span><span class="s1">data</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">errors</span><span class="s3">=</span><span class="s4">&quot;ignore&quot;</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s1">copy</span><span class="s3">)</span>
            <span class="s2">elif </span><span class="s1">copy</span><span class="s3">:</span>
                <span class="s1">data </span><span class="s3">= </span><span class="s1">data</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">data </span><span class="s3">= </span><span class="s1">sanitize_array</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">index</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">)</span>

            <span class="s1">manager </span><span class="s3">= </span><span class="s1">_get_option</span><span class="s3">(</span><span class="s4">&quot;mode.data_manager&quot;</span><span class="s3">, </span><span class="s1">silent</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">manager </span><span class="s3">== </span><span class="s4">&quot;block&quot;</span><span class="s3">:</span>
                <span class="s1">data </span><span class="s3">= </span><span class="s1">SingleBlockManager</span><span class="s3">.</span><span class="s1">from_array</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">index</span><span class="s3">, </span><span class="s1">refs</span><span class="s3">=</span><span class="s1">refs</span><span class="s3">)</span>
            <span class="s2">elif </span><span class="s1">manager </span><span class="s3">== </span><span class="s4">&quot;array&quot;</span><span class="s3">:</span>
                <span class="s1">data </span><span class="s3">= </span><span class="s1">SingleArrayManager</span><span class="s3">.</span><span class="s1">from_array</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">index</span><span class="s3">)</span>

        <span class="s1">NDFrame</span><span class="s3">.</span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">data</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">name </span><span class="s3">= </span><span class="s1">name</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_set_axis</span><span class="s3">(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">index</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">original_dtype </span><span class="s2">is None and </span><span class="s1">is_pandas_object </span><span class="s2">and </span><span class="s1">data_dtype </span><span class="s3">== </span><span class="s1">np</span><span class="s3">.</span><span class="s1">object_</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">dtype </span><span class="s3">!= </span><span class="s1">data_dtype</span><span class="s3">:</span>
                <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span>
                    <span class="s4">&quot;Dtype inference on a pandas object &quot;</span>
                    <span class="s4">&quot;(Series, Index, ExtensionArray) is deprecated. The Series &quot;</span>
                    <span class="s4">&quot;constructor will keep the original dtype in the future. &quot;</span>
                    <span class="s4">&quot;Call `infer_objects` on the result to get the old behavior.&quot;</span><span class="s3">,</span>
                    <span class="s1">FutureWarning</span><span class="s3">,</span>
                    <span class="s1">stacklevel</span><span class="s3">=</span><span class="s1">find_stack_level</span><span class="s3">(),</span>
                <span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_init_dict</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">data</span><span class="s3">: </span><span class="s1">Mapping</span><span class="s3">, </span><span class="s1">index</span><span class="s3">: </span><span class="s1">Index </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">: </span><span class="s1">DtypeObj </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span>
    <span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Derive the &quot;_mgr&quot; and &quot;index&quot; attributes of a new Series from a 
        dictionary input. 
 
        Parameters 
        ---------- 
        data : dict or dict-like 
            Data used to populate the new Series. 
        index : Index or None, default None 
            Index for the new Series: if None, use dict keys. 
        dtype : np.dtype, ExtensionDtype, or None, default None 
            The dtype for the new Series: if None, infer from data. 
 
        Returns 
        ------- 
        _data : BlockManager for the new Series 
        index : index for the new Series 
        &quot;&quot;&quot;</span>
        <span class="s1">keys</span><span class="s3">: </span><span class="s1">Index </span><span class="s3">| </span><span class="s1">tuple</span>

        <span class="s6"># Looking for NaN in dict doesn't work ({np.nan : 1}[float('nan')]</span>
        <span class="s6"># raises KeyError), so we iterate the entire dict, and align</span>
        <span class="s2">if </span><span class="s1">data</span><span class="s3">:</span>
            <span class="s6"># GH:34717, issue was using zip to extract key and values from data.</span>
            <span class="s6"># using generators in effects the performance.</span>
            <span class="s6"># Below is the new way of extracting the keys and values</span>

            <span class="s1">keys </span><span class="s3">= </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">data</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">())</span>
            <span class="s1">values </span><span class="s3">= </span><span class="s1">list</span><span class="s3">(</span><span class="s1">data</span><span class="s3">.</span><span class="s1">values</span><span class="s3">())  </span><span class="s6"># Generating list of values- faster way</span>
        <span class="s2">elif </span><span class="s1">index </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s6"># fastpath for Series(data=None). Just use broadcasting a scalar</span>
            <span class="s6"># instead of reindexing.</span>
            <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">index</span><span class="s3">) </span><span class="s2">or </span><span class="s1">dtype </span><span class="s2">is not None</span><span class="s3">:</span>
                <span class="s1">values </span><span class="s3">= </span><span class="s1">na_value_for_dtype</span><span class="s3">(</span><span class="s1">pandas_dtype</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">), </span><span class="s1">compat</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">values </span><span class="s3">= []</span>
            <span class="s1">keys </span><span class="s3">= </span><span class="s1">index</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">keys</span><span class="s3">, </span><span class="s1">values </span><span class="s3">= </span><span class="s1">default_index</span><span class="s3">(</span><span class="s5">0</span><span class="s3">), []</span>

        <span class="s6"># Input is now list-like, so rely on &quot;standard&quot; construction:</span>
        <span class="s1">s </span><span class="s3">= </span><span class="s1">Series</span><span class="s3">(</span><span class="s1">values</span><span class="s3">, </span><span class="s1">index</span><span class="s3">=</span><span class="s1">keys</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dtype</span><span class="s3">)</span>

        <span class="s6"># Now we just make sure the order is respected, if any</span>
        <span class="s2">if </span><span class="s1">data </span><span class="s2">and </span><span class="s1">index </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s1">s </span><span class="s3">= </span><span class="s1">s</span><span class="s3">.</span><span class="s1">reindex</span><span class="s3">(</span><span class="s1">index</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">s</span><span class="s3">.</span><span class="s1">_mgr</span><span class="s3">, </span><span class="s1">s</span><span class="s3">.</span><span class="s1">index</span>

    <span class="s6"># ----------------------------------------------------------------------</span>

    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">_constructor</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; Callable</span><span class="s3">[..., </span><span class="s1">Series</span><span class="s3">]:</span>
        <span class="s2">return </span><span class="s1">Series</span>

    <span class="s2">def </span><span class="s1">_constructor_from_mgr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">mgr</span><span class="s3">, </span><span class="s1">axes</span><span class="s3">):</span>
        <span class="s1">ser </span><span class="s3">= </span><span class="s1">Series</span><span class="s3">.</span><span class="s1">_from_mgr</span><span class="s3">(</span><span class="s1">mgr</span><span class="s3">, </span><span class="s1">axes</span><span class="s3">=</span><span class="s1">axes</span><span class="s3">)</span>
        <span class="s1">ser</span><span class="s3">.</span><span class="s1">_name </span><span class="s3">= </span><span class="s2">None  </span><span class="s6"># caller is responsible for setting real name</span>

        <span class="s2">if </span><span class="s1">type</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s2">is </span><span class="s1">Series</span><span class="s3">:</span>
            <span class="s6"># This would also work `if self._constructor is Series`, but</span>
            <span class="s6">#  this check is slightly faster, benefiting the most-common case.</span>
            <span class="s2">return </span><span class="s1">ser</span>

        <span class="s6"># We assume that the subclass __init__ knows how to handle a</span>
        <span class="s6">#  pd.Series object.</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_constructor</span><span class="s3">(</span><span class="s1">ser</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">_constructor_expanddim</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; Callable</span><span class="s3">[..., </span><span class="s1">DataFrame</span><span class="s3">]:</span>
        <span class="s0">&quot;&quot;&quot; 
        Used when a manipulation result has one higher dimension as the 
        original, such as Series.to_frame() 
        &quot;&quot;&quot;</span>
        <span class="s2">from </span><span class="s1">pandas</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">frame </span><span class="s2">import </span><span class="s1">DataFrame</span>

        <span class="s2">return </span><span class="s1">DataFrame</span>

    <span class="s2">def </span><span class="s1">_constructor_expanddim_from_mgr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">mgr</span><span class="s3">, </span><span class="s1">axes</span><span class="s3">):</span>
        <span class="s2">from </span><span class="s1">pandas</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">frame </span><span class="s2">import </span><span class="s1">DataFrame</span>

        <span class="s1">df </span><span class="s3">= </span><span class="s1">DataFrame</span><span class="s3">.</span><span class="s1">_from_mgr</span><span class="s3">(</span><span class="s1">mgr</span><span class="s3">, </span><span class="s1">axes</span><span class="s3">=</span><span class="s1">mgr</span><span class="s3">.</span><span class="s1">axes</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">type</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s2">is </span><span class="s1">Series</span><span class="s3">:</span>
            <span class="s6"># This would also work `if self._constructor_expanddim is DataFrame`,</span>
            <span class="s6">#  but this check is slightly faster, benefiting the most-common case.</span>
            <span class="s2">return </span><span class="s1">df</span>

        <span class="s6"># We assume that the subclass __init__ knows how to handle a</span>
        <span class="s6">#  pd.DataFrame object.</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_constructor_expanddim</span><span class="s3">(</span><span class="s1">df</span><span class="s3">)</span>

    <span class="s6"># types</span>
    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">_can_hold_na</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_mgr</span><span class="s3">.</span><span class="s1">_can_hold_na</span>

    <span class="s6"># ndarray compatibility</span>
    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">dtype</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; DtypeObj</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the dtype object of the underlying data. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; s = pd.Series([1, 2, 3]) 
        &gt;&gt;&gt; s.dtype 
        dtype('int64') 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_mgr</span><span class="s3">.</span><span class="s1">dtype</span>

    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">dtypes</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; DtypeObj</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the dtype object of the underlying data. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; s = pd.Series([1, 2, 3]) 
        &gt;&gt;&gt; s.dtypes 
        dtype('int64') 
        &quot;&quot;&quot;</span>
        <span class="s6"># DataFrame compatibility</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">dtype</span>

    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">name</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; Hashable</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the name of the Series. 
 
        The name of a Series becomes its index or column name if it is used 
        to form a DataFrame. It is also used whenever displaying the Series 
        using the interpreter. 
 
        Returns 
        ------- 
        label (hashable object) 
            The name of the Series, also the column name if part of a DataFrame. 
 
        See Also 
        -------- 
        Series.rename : Sets the Series name when given a scalar input. 
        Index.name : Corresponding Index property. 
 
        Examples 
        -------- 
        The Series name can be set initially when calling the constructor. 
 
        &gt;&gt;&gt; s = pd.Series([1, 2, 3], dtype=np.int64, name='Numbers') 
        &gt;&gt;&gt; s 
        0    1 
        1    2 
        2    3 
        Name: Numbers, dtype: int64 
        &gt;&gt;&gt; s.name = &quot;Integers&quot; 
        &gt;&gt;&gt; s 
        0    1 
        1    2 
        2    3 
        Name: Integers, dtype: int64 
 
        The name of a Series within a DataFrame is its column name. 
 
        &gt;&gt;&gt; df = pd.DataFrame([[1, 2], [3, 4], [5, 6]], 
        ...                   columns=[&quot;Odd Numbers&quot;, &quot;Even Numbers&quot;]) 
        &gt;&gt;&gt; df 
           Odd Numbers  Even Numbers 
        0            1             2 
        1            3             4 
        2            5             6 
        &gt;&gt;&gt; df[&quot;Even Numbers&quot;].name 
        'Even Numbers' 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_name</span>

    <span class="s3">@</span><span class="s1">name</span><span class="s3">.</span><span class="s1">setter</span>
    <span class="s2">def </span><span class="s1">name</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">value</span><span class="s3">: </span><span class="s1">Hashable</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s1">validate_all_hashable</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">error_name</span><span class="s3">=</span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">type</span><span class="s3">(</span><span class="s1">self</span><span class="s3">).</span><span class="s1">__name__</span><span class="s2">}</span><span class="s4">.name&quot;</span><span class="s3">)</span>
        <span class="s1">object</span><span class="s3">.</span><span class="s1">__setattr__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s4">&quot;_name&quot;</span><span class="s3">, </span><span class="s1">value</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">values</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return Series as ndarray or ndarray-like depending on the dtype. 
 
        .. warning:: 
 
           We recommend using :attr:`Series.array` or 
           :meth:`Series.to_numpy`, depending on whether you need 
           a reference to the underlying data or a NumPy array. 
 
        Returns 
        ------- 
        numpy.ndarray or ndarray-like 
 
        See Also 
        -------- 
        Series.array : Reference to the underlying data. 
        Series.to_numpy : A NumPy array representing the underlying data. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; pd.Series([1, 2, 3]).values 
        array([1, 2, 3]) 
 
        &gt;&gt;&gt; pd.Series(list('aabc')).values 
        array(['a', 'a', 'b', 'c'], dtype=object) 
 
        &gt;&gt;&gt; pd.Series(list('aabc')).astype('category').values 
        ['a', 'a', 'b', 'c'] 
        Categories (3, object): ['a', 'b', 'c'] 
 
        Timezone aware datetime data is converted to UTC: 
 
        &gt;&gt;&gt; pd.Series(pd.date_range('20130101', periods=3, 
        ...                         tz='US/Eastern')).values 
        array(['2013-01-01T05:00:00.000000000', 
               '2013-01-02T05:00:00.000000000', 
               '2013-01-03T05:00:00.000000000'], dtype='datetime64[ns]') 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_mgr</span><span class="s3">.</span><span class="s1">external_values</span><span class="s3">()</span>

    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">_values</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the internal repr of this data (defined by Block.interval_values). 
        This are the values as stored in the Block (ndarray or ExtensionArray 
        depending on the Block class), with datetime64[ns] and timedelta64[ns] 
        wrapped in ExtensionArrays to match Index._values behavior. 
 
        Differs from the public ``.values`` for certain data types, because of 
        historical backwards compatibility of the public attribute (e.g. period 
        returns object ndarray and datetimetz a datetime64[ns] ndarray for 
        ``.values`` while it returns an ExtensionArray for ``._values`` in those 
        cases). 
 
        Differs from ``.array`` in that this still returns the numpy array if 
        the Block is backed by a numpy array (except for datetime64 and 
        timedelta64 dtypes), while ``.array`` ensures to always return an 
        ExtensionArray. 
 
        Overview: 
 
        dtype       | values        | _values       | array                 | 
        ----------- | ------------- | ------------- | --------------------- | 
        Numeric     | ndarray       | ndarray       | NumpyExtensionArray   | 
        Category    | Categorical   | Categorical   | Categorical           | 
        dt64[ns]    | ndarray[M8ns] | DatetimeArray | DatetimeArray         | 
        dt64[ns tz] | ndarray[M8ns] | DatetimeArray | DatetimeArray         | 
        td64[ns]    | ndarray[m8ns] | TimedeltaArray| TimedeltaArray        | 
        Period      | ndarray[obj]  | PeriodArray   | PeriodArray           | 
        Nullable    | EA            | EA            | EA                    | 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_mgr</span><span class="s3">.</span><span class="s1">internal_values</span><span class="s3">()</span>

    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">_references</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; BlockValuesRefs </span><span class="s3">| </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_mgr</span><span class="s3">, </span><span class="s1">SingleArrayManager</span><span class="s3">):</span>
            <span class="s2">return None</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_mgr</span><span class="s3">.</span><span class="s1">_block</span><span class="s3">.</span><span class="s1">refs</span>

    <span class="s6"># error: Decorated property not supported</span>
    <span class="s3">@</span><span class="s1">Appender</span><span class="s3">(</span><span class="s1">base</span><span class="s3">.</span><span class="s1">IndexOpsMixin</span><span class="s3">.</span><span class="s1">array</span><span class="s3">.</span><span class="s1">__doc__</span><span class="s3">)  </span><span class="s6"># type: ignore[misc]</span>
    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">array</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; ExtensionArray</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_mgr</span><span class="s3">.</span><span class="s1">array_values</span><span class="s3">()</span>

    <span class="s6"># ops</span>
    <span class="s2">def </span><span class="s1">ravel</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">order</span><span class="s3">: </span><span class="s1">str </span><span class="s3">= </span><span class="s4">&quot;C&quot;</span><span class="s3">) </span><span class="s1">-&gt; ArrayLike</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the flattened underlying data as an ndarray or ExtensionArray. 
 
        .. deprecated:: 2.2.0 
            Series.ravel is deprecated. The underlying array is already 1D, so 
            ravel is not necessary.  Use :meth:`to_numpy` for conversion to a numpy 
            array instead. 
 
        Returns 
        ------- 
        numpy.ndarray or ExtensionArray 
            Flattened data of the Series. 
 
        See Also 
        -------- 
        numpy.ndarray.ravel : Return a flattened array. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; s = pd.Series([1, 2, 3]) 
        &gt;&gt;&gt; s.ravel()  # doctest: +SKIP 
        array([1, 2, 3]) 
        &quot;&quot;&quot;</span>
        <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span>
            <span class="s4">&quot;Series.ravel is deprecated. The underlying array is already 1D, so &quot;</span>
            <span class="s4">&quot;ravel is not necessary.  Use `to_numpy()` for conversion to a numpy &quot;</span>
            <span class="s4">&quot;array instead.&quot;</span><span class="s3">,</span>
            <span class="s1">FutureWarning</span><span class="s3">,</span>
            <span class="s1">stacklevel</span><span class="s3">=</span><span class="s5">2</span><span class="s3">,</span>
        <span class="s3">)</span>
        <span class="s1">arr </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_values</span><span class="s3">.</span><span class="s1">ravel</span><span class="s3">(</span><span class="s1">order</span><span class="s3">=</span><span class="s1">order</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndarray</span><span class="s3">) </span><span class="s2">and </span><span class="s1">using_copy_on_write</span><span class="s3">():</span>
            <span class="s1">arr</span><span class="s3">.</span><span class="s1">flags</span><span class="s3">.</span><span class="s1">writeable </span><span class="s3">= </span><span class="s2">False</span>
        <span class="s2">return </span><span class="s1">arr</span>

    <span class="s2">def </span><span class="s1">__len__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; int</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the length of the Series. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_mgr</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">view</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">: </span><span class="s1">Dtype </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">) </span><span class="s1">-&gt; Series</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Create a new view of the Series. 
 
        .. deprecated:: 2.2.0 
            ``Series.view`` is deprecated and will be removed in a future version. 
            Use :meth:`Series.astype` as an alternative to change the dtype. 
 
        This function will return a new Series with a view of the same 
        underlying values in memory, optionally reinterpreted with a new data 
        type. The new data type must preserve the same size in bytes as to not 
        cause index misalignment. 
 
        Parameters 
        ---------- 
        dtype : data type 
            Data type object or one of their string representations. 
 
        Returns 
        ------- 
        Series 
            A new Series object as a view of the same data in memory. 
 
        See Also 
        -------- 
        numpy.ndarray.view : Equivalent numpy function to create a new view of 
            the same data in memory. 
 
        Notes 
        ----- 
        Series are instantiated with ``dtype=float64`` by default. While 
        ``numpy.ndarray.view()`` will return a view with the same data type as 
        the original array, ``Series.view()`` (without specified dtype) 
        will try using ``float64`` and may fail if the original data type size 
        in bytes is not the same. 
 
        Examples 
        -------- 
        Use ``astype`` to change the dtype instead. 
        &quot;&quot;&quot;</span>
        <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span>
            <span class="s4">&quot;Series.view is deprecated and will be removed in a future version. &quot;</span>
            <span class="s4">&quot;Use ``astype`` as an alternative to change the dtype.&quot;</span><span class="s3">,</span>
            <span class="s1">FutureWarning</span><span class="s3">,</span>
            <span class="s1">stacklevel</span><span class="s3">=</span><span class="s5">2</span><span class="s3">,</span>
        <span class="s3">)</span>
        <span class="s6"># self.array instead of self._values so we piggyback on NumpyExtensionArray</span>
        <span class="s6">#  implementation</span>
        <span class="s1">res_values </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">array</span><span class="s3">.</span><span class="s1">view</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">)</span>
        <span class="s1">res_ser </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_constructor</span><span class="s3">(</span><span class="s1">res_values</span><span class="s3">, </span><span class="s1">index</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">index</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">res_ser</span><span class="s3">.</span><span class="s1">_mgr</span><span class="s3">, </span><span class="s1">SingleBlockManager</span><span class="s3">):</span>
            <span class="s1">blk </span><span class="s3">= </span><span class="s1">res_ser</span><span class="s3">.</span><span class="s1">_mgr</span><span class="s3">.</span><span class="s1">_block</span>
            <span class="s1">blk</span><span class="s3">.</span><span class="s1">refs </span><span class="s3">= </span><span class="s1">cast</span><span class="s3">(</span><span class="s4">&quot;BlockValuesRefs&quot;</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_references</span><span class="s3">)</span>
            <span class="s1">blk</span><span class="s3">.</span><span class="s1">refs</span><span class="s3">.</span><span class="s1">add_reference</span><span class="s3">(</span><span class="s1">blk</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">res_ser</span><span class="s3">.</span><span class="s1">__finalize__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">method</span><span class="s3">=</span><span class="s4">&quot;view&quot;</span><span class="s3">)</span>

    <span class="s6"># ----------------------------------------------------------------------</span>
    <span class="s6"># NDArray Compat</span>
    <span class="s2">def </span><span class="s1">__array__</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">: </span><span class="s1">npt</span><span class="s3">.</span><span class="s1">DTypeLike </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span>
    <span class="s3">) </span><span class="s1">-&gt; np</span><span class="s3">.</span><span class="s1">ndarray</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the values as a NumPy array. 
 
        Users should not call this directly. Rather, it is invoked by 
        :func:`numpy.array` and :func:`numpy.asarray`. 
 
        Parameters 
        ---------- 
        dtype : str or numpy.dtype, optional 
            The dtype to use for the resulting NumPy array. By default, 
            the dtype is inferred from the data. 
 
        copy : bool or None, optional 
            Unused. 
 
        Returns 
        ------- 
        numpy.ndarray 
            The values in the series converted to a :class:`numpy.ndarray` 
            with the specified `dtype`. 
 
        See Also 
        -------- 
        array : Create a new array from data. 
        Series.array : Zero-copy view to the array backing the Series. 
        Series.to_numpy : Series method for similar behavior. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; ser = pd.Series([1, 2, 3]) 
        &gt;&gt;&gt; np.asarray(ser) 
        array([1, 2, 3]) 
 
        For timezone-aware data, the timezones may be retained with 
        ``dtype='object'`` 
 
        &gt;&gt;&gt; tzser = pd.Series(pd.date_range('2000', periods=2, tz=&quot;CET&quot;)) 
        &gt;&gt;&gt; np.asarray(tzser, dtype=&quot;object&quot;) 
        array([Timestamp('2000-01-01 00:00:00+0100', tz='CET'), 
               Timestamp('2000-01-02 00:00:00+0100', tz='CET')], 
              dtype=object) 
 
        Or the values may be localized to UTC and the tzinfo discarded with 
        ``dtype='datetime64[ns]'`` 
 
        &gt;&gt;&gt; np.asarray(tzser, dtype=&quot;datetime64[ns]&quot;)  # doctest: +ELLIPSIS 
        array(['1999-12-31T23:00:00.000000000', ...], 
              dtype='datetime64[ns]') 
        &quot;&quot;&quot;</span>
        <span class="s1">values </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_values</span>
        <span class="s1">arr </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">values</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dtype</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">using_copy_on_write</span><span class="s3">() </span><span class="s2">and </span><span class="s1">astype_is_view</span><span class="s3">(</span><span class="s1">values</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">):</span>
            <span class="s1">arr </span><span class="s3">= </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">view</span><span class="s3">()</span>
            <span class="s1">arr</span><span class="s3">.</span><span class="s1">flags</span><span class="s3">.</span><span class="s1">writeable </span><span class="s3">= </span><span class="s2">False</span>
        <span class="s2">return </span><span class="s1">arr</span>

    <span class="s6"># ----------------------------------------------------------------------</span>

    <span class="s2">def </span><span class="s1">__column_consortium_standard__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, *, </span><span class="s1">api_version</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">) </span><span class="s1">-&gt; Any</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Provide entry point to the Consortium DataFrame Standard API. 
 
        This is developed and maintained outside of pandas. 
        Please report any issues to https://github.com/data-apis/dataframe-api-compat. 
        &quot;&quot;&quot;</span>
        <span class="s1">dataframe_api_compat </span><span class="s3">= </span><span class="s1">import_optional_dependency</span><span class="s3">(</span><span class="s4">&quot;dataframe_api_compat&quot;</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s3">(</span>
            <span class="s1">dataframe_api_compat</span><span class="s3">.</span><span class="s1">pandas_standard</span><span class="s3">.</span><span class="s1">convert_to_standard_compliant_column</span><span class="s3">(</span>
                <span class="s1">self</span><span class="s3">, </span><span class="s1">api_version</span><span class="s3">=</span><span class="s1">api_version</span>
            <span class="s3">)</span>
        <span class="s3">)</span>

    <span class="s6"># ----------------------------------------------------------------------</span>
    <span class="s6"># Unary Methods</span>

    <span class="s6"># coercion</span>
    <span class="s1">__float__ </span><span class="s3">= </span><span class="s1">_coerce_method</span><span class="s3">(</span><span class="s1">float</span><span class="s3">)</span>
    <span class="s1">__int__ </span><span class="s3">= </span><span class="s1">_coerce_method</span><span class="s3">(</span><span class="s1">int</span><span class="s3">)</span>

    <span class="s6"># ----------------------------------------------------------------------</span>

    <span class="s6"># indexers</span>
    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">axes</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; list</span><span class="s3">[</span><span class="s1">Index</span><span class="s3">]:</span>
        <span class="s0">&quot;&quot;&quot; 
        Return a list of the row axis labels. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">index</span><span class="s3">]</span>

    <span class="s6"># ----------------------------------------------------------------------</span>
    <span class="s6"># Indexing Methods</span>

    <span class="s2">def </span><span class="s1">_ixs</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">i</span><span class="s3">: </span><span class="s1">int</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">: </span><span class="s1">AxisInt </span><span class="s3">= </span><span class="s5">0</span><span class="s3">) </span><span class="s1">-&gt; Any</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the i-th value or values in the Series by location. 
 
        Parameters 
        ---------- 
        i : int 
 
        Returns 
        ------- 
        scalar 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_values</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>

    <span class="s2">def </span><span class="s1">_slice</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">slobj</span><span class="s3">: </span><span class="s1">slice</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">: </span><span class="s1">AxisInt </span><span class="s3">= </span><span class="s5">0</span><span class="s3">) </span><span class="s1">-&gt; Series</span><span class="s3">:</span>
        <span class="s6"># axis kwarg is retained for compat with NDFrame method</span>
        <span class="s6">#  _slice is *always* positional</span>
        <span class="s1">mgr </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_mgr</span><span class="s3">.</span><span class="s1">get_slice</span><span class="s3">(</span><span class="s1">slobj</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">)</span>
        <span class="s1">out </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_constructor_from_mgr</span><span class="s3">(</span><span class="s1">mgr</span><span class="s3">, </span><span class="s1">axes</span><span class="s3">=</span><span class="s1">mgr</span><span class="s3">.</span><span class="s1">axes</span><span class="s3">)</span>
        <span class="s1">out</span><span class="s3">.</span><span class="s1">_name </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_name</span>
        <span class="s2">return </span><span class="s1">out</span><span class="s3">.</span><span class="s1">__finalize__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__getitem__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">key</span><span class="s3">):</span>
        <span class="s1">check_dict_or_set_indexers</span><span class="s3">(</span><span class="s1">key</span><span class="s3">)</span>
        <span class="s1">key </span><span class="s3">= </span><span class="s1">com</span><span class="s3">.</span><span class="s1">apply_if_callable</span><span class="s3">(</span><span class="s1">key</span><span class="s3">, </span><span class="s1">self</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">key </span><span class="s2">is </span><span class="s1">Ellipsis</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">using_copy_on_write</span><span class="s3">() </span><span class="s2">or </span><span class="s1">warn_copy_on_write</span><span class="s3">():</span>
                <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">(</span><span class="s1">deep</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">self</span>

        <span class="s1">key_is_scalar </span><span class="s3">= </span><span class="s1">is_scalar</span><span class="s3">(</span><span class="s1">key</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">key</span><span class="s3">, (</span><span class="s1">list</span><span class="s3">, </span><span class="s1">tuple</span><span class="s3">)):</span>
            <span class="s1">key </span><span class="s3">= </span><span class="s1">unpack_1tuple</span><span class="s3">(</span><span class="s1">key</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">is_integer</span><span class="s3">(</span><span class="s1">key</span><span class="s3">) </span><span class="s2">and </span><span class="s1">self</span><span class="s3">.</span><span class="s1">index</span><span class="s3">.</span><span class="s1">_should_fallback_to_positional</span><span class="s3">:</span>
            <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span>
                <span class="s6"># GH#50617</span>
                <span class="s4">&quot;Series.__getitem__ treating keys as positions is deprecated. &quot;</span>
                <span class="s4">&quot;In a future version, integer keys will always be treated &quot;</span>
                <span class="s4">&quot;as labels (consistent with DataFrame behavior). To access &quot;</span>
                <span class="s4">&quot;a value by position, use `ser.iloc[pos]`&quot;</span><span class="s3">,</span>
                <span class="s1">FutureWarning</span><span class="s3">,</span>
                <span class="s1">stacklevel</span><span class="s3">=</span><span class="s1">find_stack_level</span><span class="s3">(),</span>
            <span class="s3">)</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_values</span><span class="s3">[</span><span class="s1">key</span><span class="s3">]</span>

        <span class="s2">elif </span><span class="s1">key_is_scalar</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_value</span><span class="s3">(</span><span class="s1">key</span><span class="s3">)</span>

        <span class="s6"># Convert generator to list before going through hashable part</span>
        <span class="s6"># (We will iterate through the generator there to check for slices)</span>
        <span class="s2">if </span><span class="s1">is_iterator</span><span class="s3">(</span><span class="s1">key</span><span class="s3">):</span>
            <span class="s1">key </span><span class="s3">= </span><span class="s1">list</span><span class="s3">(</span><span class="s1">key</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">is_hashable</span><span class="s3">(</span><span class="s1">key</span><span class="s3">) </span><span class="s2">and not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">key</span><span class="s3">, </span><span class="s1">slice</span><span class="s3">):</span>
            <span class="s6"># Otherwise index.get_value will raise InvalidIndexError</span>
            <span class="s2">try</span><span class="s3">:</span>
                <span class="s6"># For labels that don't resolve as scalars like tuples and frozensets</span>
                <span class="s1">result </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_value</span><span class="s3">(</span><span class="s1">key</span><span class="s3">)</span>

                <span class="s2">return </span><span class="s1">result</span>

            <span class="s2">except </span><span class="s3">(</span><span class="s1">KeyError</span><span class="s3">, </span><span class="s1">TypeError</span><span class="s3">, </span><span class="s1">InvalidIndexError</span><span class="s3">):</span>
                <span class="s6"># InvalidIndexError for e.g. generator</span>
                <span class="s6">#  see test_series_getitem_corner_generator</span>
                <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">key</span><span class="s3">, </span><span class="s1">tuple</span><span class="s3">) </span><span class="s2">and </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">index</span><span class="s3">, </span><span class="s1">MultiIndex</span><span class="s3">):</span>
                    <span class="s6"># We still have the corner case where a tuple is a key</span>
                    <span class="s6"># in the first level of our MultiIndex</span>
                    <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_values_tuple</span><span class="s3">(</span><span class="s1">key</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">key</span><span class="s3">, </span><span class="s1">slice</span><span class="s3">):</span>
            <span class="s6"># Do slice check before somewhat-costly is_bool_indexer</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_getitem_slice</span><span class="s3">(</span><span class="s1">key</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">com</span><span class="s3">.</span><span class="s1">is_bool_indexer</span><span class="s3">(</span><span class="s1">key</span><span class="s3">):</span>
            <span class="s1">key </span><span class="s3">= </span><span class="s1">check_bool_indexer</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">index</span><span class="s3">, </span><span class="s1">key</span><span class="s3">)</span>
            <span class="s1">key </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">key</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">bool</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_rows_with_mask</span><span class="s3">(</span><span class="s1">key</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_with</span><span class="s3">(</span><span class="s1">key</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_get_with</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">key</span><span class="s3">):</span>
        <span class="s6"># other: fancy integer or otherwise</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">key</span><span class="s3">, </span><span class="s1">ABCDataFrame</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span>
                <span class="s4">&quot;Indexing a Series with DataFrame is not &quot;</span>
                <span class="s4">&quot;supported, use the appropriate DataFrame column&quot;</span>
            <span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">key</span><span class="s3">, </span><span class="s1">tuple</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_values_tuple</span><span class="s3">(</span><span class="s1">key</span><span class="s3">)</span>

        <span class="s2">elif not </span><span class="s1">is_list_like</span><span class="s3">(</span><span class="s1">key</span><span class="s3">):</span>
            <span class="s6"># e.g. scalars that aren't recognized by lib.is_scalar, GH#32684</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">[</span><span class="s1">key</span><span class="s3">]</span>

        <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">key</span><span class="s3">, (</span><span class="s1">list</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndarray</span><span class="s3">, </span><span class="s1">ExtensionArray</span><span class="s3">, </span><span class="s1">Series</span><span class="s3">, </span><span class="s1">Index</span><span class="s3">)):</span>
            <span class="s1">key </span><span class="s3">= </span><span class="s1">list</span><span class="s3">(</span><span class="s1">key</span><span class="s3">)</span>

        <span class="s1">key_type </span><span class="s3">= </span><span class="s1">lib</span><span class="s3">.</span><span class="s1">infer_dtype</span><span class="s3">(</span><span class="s1">key</span><span class="s3">, </span><span class="s1">skipna</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>

        <span class="s6"># Note: The key_type == &quot;boolean&quot; case should be caught by the</span>
        <span class="s6">#  com.is_bool_indexer check in __getitem__</span>
        <span class="s2">if </span><span class="s1">key_type </span><span class="s3">== </span><span class="s4">&quot;integer&quot;</span><span class="s3">:</span>
            <span class="s6"># We need to decide whether to treat this as a positional indexer</span>
            <span class="s6">#  (i.e. self.iloc) or label-based (i.e. self.loc)</span>
            <span class="s2">if not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">index</span><span class="s3">.</span><span class="s1">_should_fallback_to_positional</span><span class="s3">:</span>
                <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">[</span><span class="s1">key</span><span class="s3">]</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span>
                    <span class="s6"># GH#50617</span>
                    <span class="s4">&quot;Series.__getitem__ treating keys as positions is deprecated. &quot;</span>
                    <span class="s4">&quot;In a future version, integer keys will always be treated &quot;</span>
                    <span class="s4">&quot;as labels (consistent with DataFrame behavior). To access &quot;</span>
                    <span class="s4">&quot;a value by position, use `ser.iloc[pos]`&quot;</span><span class="s3">,</span>
                    <span class="s1">FutureWarning</span><span class="s3">,</span>
                    <span class="s1">stacklevel</span><span class="s3">=</span><span class="s1">find_stack_level</span><span class="s3">(),</span>
                <span class="s3">)</span>
                <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">iloc</span><span class="s3">[</span><span class="s1">key</span><span class="s3">]</span>

        <span class="s6"># handle the dup indexing case GH#4246</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">[</span><span class="s1">key</span><span class="s3">]</span>

    <span class="s2">def </span><span class="s1">_get_values_tuple</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">key</span><span class="s3">: </span><span class="s1">tuple</span><span class="s3">):</span>
        <span class="s6"># mpl hackaround</span>
        <span class="s2">if </span><span class="s1">com</span><span class="s3">.</span><span class="s1">any_none</span><span class="s3">(*</span><span class="s1">key</span><span class="s3">):</span>
            <span class="s6"># mpl compat if we look up e.g. ser[:, np.newaxis];</span>
            <span class="s6">#  see tests.series.timeseries.test_mpl_compat_hack</span>
            <span class="s6"># the asarray is needed to avoid returning a 2D DatetimeArray</span>
            <span class="s1">result </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_values</span><span class="s3">[</span><span class="s1">key</span><span class="s3">])</span>
            <span class="s1">disallow_ndim_indexing</span><span class="s3">(</span><span class="s1">result</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">result</span>

        <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">index</span><span class="s3">, </span><span class="s1">MultiIndex</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">KeyError</span><span class="s3">(</span><span class="s4">&quot;key of type tuple not found and not a MultiIndex&quot;</span><span class="s3">)</span>

        <span class="s6"># If key is contained, would have returned by now</span>
        <span class="s1">indexer</span><span class="s3">, </span><span class="s1">new_index </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">index</span><span class="s3">.</span><span class="s1">get_loc_level</span><span class="s3">(</span><span class="s1">key</span><span class="s3">)</span>
        <span class="s1">new_ser </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_constructor</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_values</span><span class="s3">[</span><span class="s1">indexer</span><span class="s3">], </span><span class="s1">index</span><span class="s3">=</span><span class="s1">new_index</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">indexer</span><span class="s3">, </span><span class="s1">slice</span><span class="s3">):</span>
            <span class="s1">new_ser</span><span class="s3">.</span><span class="s1">_mgr</span><span class="s3">.</span><span class="s1">add_references</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_mgr</span><span class="s3">)  </span><span class="s6"># type: ignore[arg-type]</span>
        <span class="s2">return </span><span class="s1">new_ser</span><span class="s3">.</span><span class="s1">__finalize__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_get_rows_with_mask</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">indexer</span><span class="s3">: </span><span class="s1">npt</span><span class="s3">.</span><span class="s1">NDArray</span><span class="s3">[</span><span class="s1">np</span><span class="s3">.</span><span class="s1">bool_</span><span class="s3">]) </span><span class="s1">-&gt; Series</span><span class="s3">:</span>
        <span class="s1">new_mgr </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_mgr</span><span class="s3">.</span><span class="s1">get_rows_with_mask</span><span class="s3">(</span><span class="s1">indexer</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_constructor_from_mgr</span><span class="s3">(</span><span class="s1">new_mgr</span><span class="s3">, </span><span class="s1">axes</span><span class="s3">=</span><span class="s1">new_mgr</span><span class="s3">.</span><span class="s1">axes</span><span class="s3">).</span><span class="s1">__finalize__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_get_value</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">label</span><span class="s3">, </span><span class="s1">takeable</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Quickly retrieve single value at passed index label. 
 
        Parameters 
        ---------- 
        label : object 
        takeable : interpret the index as indexers, default False 
 
        Returns 
        ------- 
        scalar value 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">takeable</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_values</span><span class="s3">[</span><span class="s1">label</span><span class="s3">]</span>

        <span class="s6"># Similar to Index.get_value, but we do not fall back to positional</span>
        <span class="s1">loc </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">index</span><span class="s3">.</span><span class="s1">get_loc</span><span class="s3">(</span><span class="s1">label</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">is_integer</span><span class="s3">(</span><span class="s1">loc</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_values</span><span class="s3">[</span><span class="s1">loc</span><span class="s3">]</span>

        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">index</span><span class="s3">, </span><span class="s1">MultiIndex</span><span class="s3">):</span>
            <span class="s1">mi </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">index</span>
            <span class="s1">new_values </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_values</span><span class="s3">[</span><span class="s1">loc</span><span class="s3">]</span>
            <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">new_values</span><span class="s3">) == </span><span class="s5">1 </span><span class="s2">and </span><span class="s1">mi</span><span class="s3">.</span><span class="s1">nlevels </span><span class="s3">== </span><span class="s5">1</span><span class="s3">:</span>
                <span class="s6"># If more than one level left, we can not return a scalar</span>
                <span class="s2">return </span><span class="s1">new_values</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>

            <span class="s1">new_index </span><span class="s3">= </span><span class="s1">mi</span><span class="s3">[</span><span class="s1">loc</span><span class="s3">]</span>
            <span class="s1">new_index </span><span class="s3">= </span><span class="s1">maybe_droplevels</span><span class="s3">(</span><span class="s1">new_index</span><span class="s3">, </span><span class="s1">label</span><span class="s3">)</span>
            <span class="s1">new_ser </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_constructor</span><span class="s3">(</span>
                <span class="s1">new_values</span><span class="s3">, </span><span class="s1">index</span><span class="s3">=</span><span class="s1">new_index</span><span class="s3">, </span><span class="s1">name</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">name</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">False</span>
            <span class="s3">)</span>
            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">loc</span><span class="s3">, </span><span class="s1">slice</span><span class="s3">):</span>
                <span class="s1">new_ser</span><span class="s3">.</span><span class="s1">_mgr</span><span class="s3">.</span><span class="s1">add_references</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_mgr</span><span class="s3">)  </span><span class="s6"># type: ignore[arg-type]</span>
            <span class="s2">return </span><span class="s1">new_ser</span><span class="s3">.</span><span class="s1">__finalize__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">)</span>

        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">iloc</span><span class="s3">[</span><span class="s1">loc</span><span class="s3">]</span>

    <span class="s2">def </span><span class="s1">__setitem__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">key</span><span class="s3">, </span><span class="s1">value</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s1">warn </span><span class="s3">= </span><span class="s2">True</span>
        <span class="s2">if not </span><span class="s1">PYPY </span><span class="s2">and </span><span class="s1">using_copy_on_write</span><span class="s3">():</span>
            <span class="s2">if </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">getrefcount</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) &lt;= </span><span class="s5">3</span><span class="s3">:</span>
                <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span>
                    <span class="s1">_chained_assignment_msg</span><span class="s3">, </span><span class="s1">ChainedAssignmentError</span><span class="s3">, </span><span class="s1">stacklevel</span><span class="s3">=</span><span class="s5">2</span>
                <span class="s3">)</span>
        <span class="s2">elif not </span><span class="s1">PYPY </span><span class="s2">and not </span><span class="s1">using_copy_on_write</span><span class="s3">():</span>
            <span class="s1">ctr </span><span class="s3">= </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">getrefcount</span><span class="s3">(</span><span class="s1">self</span><span class="s3">)</span>
            <span class="s1">ref_count </span><span class="s3">= </span><span class="s5">3</span>
            <span class="s2">if not </span><span class="s1">warn_copy_on_write</span><span class="s3">() </span><span class="s2">and </span><span class="s1">_check_cacher</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
                <span class="s6"># see https://github.com/pandas-dev/pandas/pull/56060#discussion_r1399245221</span>
                <span class="s1">ref_count </span><span class="s3">+= </span><span class="s5">1</span>
            <span class="s2">if </span><span class="s1">ctr </span><span class="s3">&lt;= </span><span class="s1">ref_count </span><span class="s2">and </span><span class="s3">(</span>
                <span class="s1">warn_copy_on_write</span><span class="s3">()</span>
                <span class="s2">or </span><span class="s3">(</span>
                    <span class="s2">not </span><span class="s1">warn_copy_on_write</span><span class="s3">()</span>
                    <span class="s2">and </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_mgr</span><span class="s3">.</span><span class="s1">blocks</span><span class="s3">[</span><span class="s5">0</span><span class="s3">].</span><span class="s1">refs</span><span class="s3">.</span><span class="s1">has_reference</span><span class="s3">()  </span><span class="s6"># type: ignore[union-attr]</span>
                <span class="s3">)</span>
            <span class="s3">):</span>
                <span class="s1">warn </span><span class="s3">= </span><span class="s2">False</span>
                <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span>
                    <span class="s1">_chained_assignment_warning_msg</span><span class="s3">, </span><span class="s1">FutureWarning</span><span class="s3">, </span><span class="s1">stacklevel</span><span class="s3">=</span><span class="s5">2</span>
                <span class="s3">)</span>

        <span class="s1">check_dict_or_set_indexers</span><span class="s3">(</span><span class="s1">key</span><span class="s3">)</span>
        <span class="s1">key </span><span class="s3">= </span><span class="s1">com</span><span class="s3">.</span><span class="s1">apply_if_callable</span><span class="s3">(</span><span class="s1">key</span><span class="s3">, </span><span class="s1">self</span><span class="s3">)</span>
        <span class="s1">cacher_needs_updating </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_check_is_chained_assignment_possible</span><span class="s3">()</span>

        <span class="s2">if </span><span class="s1">key </span><span class="s2">is </span><span class="s1">Ellipsis</span><span class="s3">:</span>
            <span class="s1">key </span><span class="s3">= </span><span class="s1">slice</span><span class="s3">(</span><span class="s2">None</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">key</span><span class="s3">, </span><span class="s1">slice</span><span class="s3">):</span>
            <span class="s1">indexer </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">index</span><span class="s3">.</span><span class="s1">_convert_slice_indexer</span><span class="s3">(</span><span class="s1">key</span><span class="s3">, </span><span class="s1">kind</span><span class="s3">=</span><span class="s4">&quot;getitem&quot;</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_set_values</span><span class="s3">(</span><span class="s1">indexer</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">warn</span><span class="s3">=</span><span class="s1">warn</span><span class="s3">)</span>

        <span class="s2">try</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_set_with_engine</span><span class="s3">(</span><span class="s1">key</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">warn</span><span class="s3">=</span><span class="s1">warn</span><span class="s3">)</span>
        <span class="s2">except </span><span class="s1">KeyError</span><span class="s3">:</span>
            <span class="s6"># We have a scalar (or for MultiIndex or object-dtype, scalar-like)</span>
            <span class="s6">#  key that is not present in self.index.</span>
            <span class="s2">if </span><span class="s1">is_integer</span><span class="s3">(</span><span class="s1">key</span><span class="s3">):</span>
                <span class="s2">if not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">index</span><span class="s3">.</span><span class="s1">_should_fallback_to_positional</span><span class="s3">:</span>
                    <span class="s6"># GH#33469</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">[</span><span class="s1">key</span><span class="s3">] = </span><span class="s1">value</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s6"># positional setter</span>
                    <span class="s6"># can't use _mgr.setitem_inplace yet bc could have *both*</span>
                    <span class="s6">#  KeyError and then ValueError, xref GH#45070</span>
                    <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span>
                        <span class="s6"># GH#50617</span>
                        <span class="s4">&quot;Series.__setitem__ treating keys as positions is deprecated. &quot;</span>
                        <span class="s4">&quot;In a future version, integer keys will always be treated &quot;</span>
                        <span class="s4">&quot;as labels (consistent with DataFrame behavior). To set &quot;</span>
                        <span class="s4">&quot;a value by position, use `ser.iloc[pos] = value`&quot;</span><span class="s3">,</span>
                        <span class="s1">FutureWarning</span><span class="s3">,</span>
                        <span class="s1">stacklevel</span><span class="s3">=</span><span class="s1">find_stack_level</span><span class="s3">(),</span>
                    <span class="s3">)</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">_set_values</span><span class="s3">(</span><span class="s1">key</span><span class="s3">, </span><span class="s1">value</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s6"># GH#12862 adding a new key to the Series</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">[</span><span class="s1">key</span><span class="s3">] = </span><span class="s1">value</span>

        <span class="s2">except </span><span class="s3">(</span><span class="s1">TypeError</span><span class="s3">, </span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">LossySetitemError</span><span class="s3">):</span>
            <span class="s6"># The key was OK, but we cannot set the value losslessly</span>
            <span class="s1">indexer </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">index</span><span class="s3">.</span><span class="s1">get_loc</span><span class="s3">(</span><span class="s1">key</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_set_values</span><span class="s3">(</span><span class="s1">indexer</span><span class="s3">, </span><span class="s1">value</span><span class="s3">)</span>

        <span class="s2">except </span><span class="s1">InvalidIndexError </span><span class="s2">as </span><span class="s1">err</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">key</span><span class="s3">, </span><span class="s1">tuple</span><span class="s3">) </span><span class="s2">and not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">index</span><span class="s3">, </span><span class="s1">MultiIndex</span><span class="s3">):</span>
                <span class="s6"># cases with MultiIndex don't get here bc they raise KeyError</span>
                <span class="s6"># e.g. test_basic_getitem_setitem_corner</span>
                <span class="s2">raise </span><span class="s1">KeyError</span><span class="s3">(</span>
                    <span class="s4">&quot;key of type tuple not found and not a MultiIndex&quot;</span>
                <span class="s3">) </span><span class="s2">from </span><span class="s1">err</span>

            <span class="s2">if </span><span class="s1">com</span><span class="s3">.</span><span class="s1">is_bool_indexer</span><span class="s3">(</span><span class="s1">key</span><span class="s3">):</span>
                <span class="s1">key </span><span class="s3">= </span><span class="s1">check_bool_indexer</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">index</span><span class="s3">, </span><span class="s1">key</span><span class="s3">)</span>
                <span class="s1">key </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">key</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">bool</span><span class="s3">)</span>

                <span class="s2">if </span><span class="s3">(</span>
                    <span class="s1">is_list_like</span><span class="s3">(</span><span class="s1">value</span><span class="s3">)</span>
                    <span class="s2">and </span><span class="s1">len</span><span class="s3">(</span><span class="s1">value</span><span class="s3">) != </span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">)</span>
                    <span class="s2">and not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">Series</span><span class="s3">)</span>
                    <span class="s2">and not </span><span class="s1">is_object_dtype</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>
                <span class="s3">):</span>
                    <span class="s6"># Series will be reindexed to have matching length inside</span>
                    <span class="s6">#  _where call below</span>
                    <span class="s6"># GH#44265</span>
                    <span class="s1">indexer </span><span class="s3">= </span><span class="s1">key</span><span class="s3">.</span><span class="s1">nonzero</span><span class="s3">()[</span><span class="s5">0</span><span class="s3">]</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">_set_values</span><span class="s3">(</span><span class="s1">indexer</span><span class="s3">, </span><span class="s1">value</span><span class="s3">)</span>
                    <span class="s2">return</span>

                <span class="s6"># otherwise with listlike other we interpret series[mask] = other</span>
                <span class="s6">#  as series[mask] = other[mask]</span>
                <span class="s2">try</span><span class="s3">:</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">_where</span><span class="s3">(~</span><span class="s1">key</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">inplace</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">warn</span><span class="s3">=</span><span class="s1">warn</span><span class="s3">)</span>
                <span class="s2">except </span><span class="s1">InvalidIndexError</span><span class="s3">:</span>
                    <span class="s6"># test_where_dups</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">iloc</span><span class="s3">[</span><span class="s1">key</span><span class="s3">] = </span><span class="s1">value</span>
                <span class="s2">return</span>

            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">_set_with</span><span class="s3">(</span><span class="s1">key</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">warn</span><span class="s3">=</span><span class="s1">warn</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">cacher_needs_updating</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_maybe_update_cacher</span><span class="s3">(</span><span class="s1">inplace</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_set_with_engine</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">key</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">warn</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">True</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s1">loc </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">index</span><span class="s3">.</span><span class="s1">get_loc</span><span class="s3">(</span><span class="s1">key</span><span class="s3">)</span>

        <span class="s6"># this is equivalent to self._values[key] = value</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_mgr</span><span class="s3">.</span><span class="s1">setitem_inplace</span><span class="s3">(</span><span class="s1">loc</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">warn</span><span class="s3">=</span><span class="s1">warn</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_set_with</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">key</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">warn</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">True</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s6"># We got here via exception-handling off of InvalidIndexError, so</span>
        <span class="s6">#  key should always be listlike at this point.</span>
        <span class="s2">assert not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">key</span><span class="s3">, </span><span class="s1">tuple</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">is_iterator</span><span class="s3">(</span><span class="s1">key</span><span class="s3">):</span>
            <span class="s6"># Without this, the call to infer_dtype will consume the generator</span>
            <span class="s1">key </span><span class="s3">= </span><span class="s1">list</span><span class="s3">(</span><span class="s1">key</span><span class="s3">)</span>

        <span class="s2">if not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">index</span><span class="s3">.</span><span class="s1">_should_fallback_to_positional</span><span class="s3">:</span>
            <span class="s6"># Regardless of the key type, we're treating it as labels</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_set_labels</span><span class="s3">(</span><span class="s1">key</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">warn</span><span class="s3">=</span><span class="s1">warn</span><span class="s3">)</span>

        <span class="s2">else</span><span class="s3">:</span>
            <span class="s6"># Note: key_type == &quot;boolean&quot; should not occur because that</span>
            <span class="s6">#  should be caught by the is_bool_indexer check in __setitem__</span>
            <span class="s1">key_type </span><span class="s3">= </span><span class="s1">lib</span><span class="s3">.</span><span class="s1">infer_dtype</span><span class="s3">(</span><span class="s1">key</span><span class="s3">, </span><span class="s1">skipna</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>

            <span class="s2">if </span><span class="s1">key_type </span><span class="s3">== </span><span class="s4">&quot;integer&quot;</span><span class="s3">:</span>
                <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span>
                    <span class="s6"># GH#50617</span>
                    <span class="s4">&quot;Series.__setitem__ treating keys as positions is deprecated. &quot;</span>
                    <span class="s4">&quot;In a future version, integer keys will always be treated &quot;</span>
                    <span class="s4">&quot;as labels (consistent with DataFrame behavior). To set &quot;</span>
                    <span class="s4">&quot;a value by position, use `ser.iloc[pos] = value`&quot;</span><span class="s3">,</span>
                    <span class="s1">FutureWarning</span><span class="s3">,</span>
                    <span class="s1">stacklevel</span><span class="s3">=</span><span class="s1">find_stack_level</span><span class="s3">(),</span>
                <span class="s3">)</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">_set_values</span><span class="s3">(</span><span class="s1">key</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">warn</span><span class="s3">=</span><span class="s1">warn</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">_set_labels</span><span class="s3">(</span><span class="s1">key</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">warn</span><span class="s3">=</span><span class="s1">warn</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_set_labels</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">key</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">warn</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">True</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s1">key </span><span class="s3">= </span><span class="s1">com</span><span class="s3">.</span><span class="s1">asarray_tuplesafe</span><span class="s3">(</span><span class="s1">key</span><span class="s3">)</span>
        <span class="s1">indexer</span><span class="s3">: </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndarray </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">index</span><span class="s3">.</span><span class="s1">get_indexer</span><span class="s3">(</span><span class="s1">key</span><span class="s3">)</span>
        <span class="s1">mask </span><span class="s3">= </span><span class="s1">indexer </span><span class="s3">== -</span><span class="s5">1</span>
        <span class="s2">if </span><span class="s1">mask</span><span class="s3">.</span><span class="s1">any</span><span class="s3">():</span>
            <span class="s2">raise </span><span class="s1">KeyError</span><span class="s3">(</span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">key</span><span class="s3">[</span><span class="s1">mask</span><span class="s3">]</span><span class="s2">} </span><span class="s4">not in index&quot;</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_set_values</span><span class="s3">(</span><span class="s1">indexer</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">warn</span><span class="s3">=</span><span class="s1">warn</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_set_values</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">key</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">warn</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">True</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">key</span><span class="s3">, (</span><span class="s1">Index</span><span class="s3">, </span><span class="s1">Series</span><span class="s3">)):</span>
            <span class="s1">key </span><span class="s3">= </span><span class="s1">key</span><span class="s3">.</span><span class="s1">_values</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">_mgr </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_mgr</span><span class="s3">.</span><span class="s1">setitem</span><span class="s3">(</span><span class="s1">indexer</span><span class="s3">=</span><span class="s1">key</span><span class="s3">, </span><span class="s1">value</span><span class="s3">=</span><span class="s1">value</span><span class="s3">, </span><span class="s1">warn</span><span class="s3">=</span><span class="s1">warn</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_maybe_update_cacher</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">_set_value</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">label</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">takeable</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Quickly set single value at passed label. 
 
        If label is not contained, a new object is created with the label 
        placed at the end of the result index. 
 
        Parameters 
        ---------- 
        label : object 
            Partial indexing with MultiIndex not allowed. 
        value : object 
            Scalar value. 
        takeable : interpret the index as indexers, default False 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">takeable</span><span class="s3">:</span>
            <span class="s2">try</span><span class="s3">:</span>
                <span class="s1">loc </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">index</span><span class="s3">.</span><span class="s1">get_loc</span><span class="s3">(</span><span class="s1">label</span><span class="s3">)</span>
            <span class="s2">except </span><span class="s1">KeyError</span><span class="s3">:</span>
                <span class="s6"># set using a non-recursive method</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">[</span><span class="s1">label</span><span class="s3">] = </span><span class="s1">value</span>
                <span class="s2">return</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">loc </span><span class="s3">= </span><span class="s1">label</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">_set_values</span><span class="s3">(</span><span class="s1">loc</span><span class="s3">, </span><span class="s1">value</span><span class="s3">)</span>

    <span class="s6"># ----------------------------------------------------------------------</span>
    <span class="s6"># Lookup Caching</span>

    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">_is_cached</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Return boolean indicating if self is cached or not.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s4">&quot;_cacher&quot;</span><span class="s3">, </span><span class="s2">None</span><span class="s3">) </span><span class="s2">is not None</span>

    <span class="s2">def </span><span class="s1">_get_cacher</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;return my cacher or None&quot;&quot;&quot;</span>
        <span class="s1">cacher </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s4">&quot;_cacher&quot;</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">cacher </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s1">cacher </span><span class="s3">= </span><span class="s1">cacher</span><span class="s3">[</span><span class="s5">1</span><span class="s3">]()</span>
        <span class="s2">return </span><span class="s1">cacher</span>

    <span class="s2">def </span><span class="s1">_reset_cacher</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Reset the cacher. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s4">&quot;_cacher&quot;</span><span class="s3">):</span>
            <span class="s2">del </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_cacher</span>

    <span class="s2">def </span><span class="s1">_set_as_cached</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">item</span><span class="s3">, </span><span class="s1">cacher</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the _cacher attribute on the calling object with a weakref to 
        cacher. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">using_copy_on_write</span><span class="s3">():</span>
            <span class="s2">return</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_cacher </span><span class="s3">= (</span><span class="s1">item</span><span class="s3">, </span><span class="s1">weakref</span><span class="s3">.</span><span class="s1">ref</span><span class="s3">(</span><span class="s1">cacher</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">_clear_item_cache</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s6"># no-op for Series</span>
        <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">_check_is_chained_assignment_possible</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot; 
        See NDFrame._check_is_chained_assignment_possible.__doc__ 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_is_view </span><span class="s2">and </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_is_cached</span><span class="s3">:</span>
            <span class="s1">ref </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_cacher</span><span class="s3">()</span>
            <span class="s2">if </span><span class="s1">ref </span><span class="s2">is not None and </span><span class="s1">ref</span><span class="s3">.</span><span class="s1">_is_mixed_type</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">_check_setitem_copy</span><span class="s3">(</span><span class="s1">t</span><span class="s3">=</span><span class="s4">&quot;referent&quot;</span><span class="s3">, </span><span class="s1">force</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
            <span class="s2">return True</span>
        <span class="s2">return </span><span class="s1">super</span><span class="s3">().</span><span class="s1">_check_is_chained_assignment_possible</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">_maybe_update_cacher</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">clear</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span><span class="s3">, </span><span class="s1">verify_is_copy</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">True</span><span class="s3">, </span><span class="s1">inplace</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span>
    <span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot; 
        See NDFrame._maybe_update_cacher.__doc__ 
        &quot;&quot;&quot;</span>
        <span class="s6"># for CoW, we never want to update the parent DataFrame cache</span>
        <span class="s6"># if the Series changed, but don't keep track of any cacher</span>
        <span class="s2">if </span><span class="s1">using_copy_on_write</span><span class="s3">():</span>
            <span class="s2">return</span>
        <span class="s1">cacher </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s4">&quot;_cacher&quot;</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">cacher </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s1">ref</span><span class="s3">: </span><span class="s1">DataFrame </span><span class="s3">= </span><span class="s1">cacher</span><span class="s3">[</span><span class="s5">1</span><span class="s3">]()</span>

            <span class="s6"># we are trying to reference a dead referent, hence</span>
            <span class="s6"># a copy</span>
            <span class="s2">if </span><span class="s1">ref </span><span class="s2">is None</span><span class="s3">:</span>
                <span class="s2">del </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_cacher</span>
            <span class="s2">elif </span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) == </span><span class="s1">len</span><span class="s3">(</span><span class="s1">ref</span><span class="s3">) </span><span class="s2">and </span><span class="s1">self</span><span class="s3">.</span><span class="s1">name </span><span class="s2">in </span><span class="s1">ref</span><span class="s3">.</span><span class="s1">columns</span><span class="s3">:</span>
                <span class="s6"># GH#42530 self.name must be in ref.columns</span>
                <span class="s6"># to ensure column still in dataframe</span>
                <span class="s6"># otherwise, either self or ref has swapped in new arrays</span>
                <span class="s1">ref</span><span class="s3">.</span><span class="s1">_maybe_cache_changed</span><span class="s3">(</span><span class="s1">cacher</span><span class="s3">[</span><span class="s5">0</span><span class="s3">], </span><span class="s1">self</span><span class="s3">, </span><span class="s1">inplace</span><span class="s3">=</span><span class="s1">inplace</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s6"># GH#33675 we have swapped in a new array, so parent</span>
                <span class="s6">#  reference to self is now invalid</span>
                <span class="s1">ref</span><span class="s3">.</span><span class="s1">_item_cache</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">(</span><span class="s1">cacher</span><span class="s3">[</span><span class="s5">0</span><span class="s3">], </span><span class="s2">None</span><span class="s3">)</span>

        <span class="s1">super</span><span class="s3">().</span><span class="s1">_maybe_update_cacher</span><span class="s3">(</span>
            <span class="s1">clear</span><span class="s3">=</span><span class="s1">clear</span><span class="s3">, </span><span class="s1">verify_is_copy</span><span class="s3">=</span><span class="s1">verify_is_copy</span><span class="s3">, </span><span class="s1">inplace</span><span class="s3">=</span><span class="s1">inplace</span>
        <span class="s3">)</span>

    <span class="s6"># ----------------------------------------------------------------------</span>
    <span class="s6"># Unsorted</span>

    <span class="s2">def </span><span class="s1">repeat</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">repeats</span><span class="s3">: </span><span class="s1">int </span><span class="s3">| </span><span class="s1">Sequence</span><span class="s3">[</span><span class="s1">int</span><span class="s3">], </span><span class="s1">axis</span><span class="s3">: </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">) </span><span class="s1">-&gt; Series</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Repeat elements of a Series. 
 
        Returns a new Series where each element of the current Series 
        is repeated consecutively a given number of times. 
 
        Parameters 
        ---------- 
        repeats : int or array of ints 
            The number of repetitions for each element. This should be a 
            non-negative integer. Repeating 0 times will return an empty 
            Series. 
        axis : None 
            Unused. Parameter needed for compatibility with DataFrame. 
 
        Returns 
        ------- 
        Series 
            Newly created Series with repeated elements. 
 
        See Also 
        -------- 
        Index.repeat : Equivalent function for Index. 
        numpy.repeat : Similar method for :class:`numpy.ndarray`. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; s = pd.Series(['a', 'b', 'c']) 
        &gt;&gt;&gt; s 
        0    a 
        1    b 
        2    c 
        dtype: object 
        &gt;&gt;&gt; s.repeat(2) 
        0    a 
        0    a 
        1    b 
        1    b 
        2    c 
        2    c 
        dtype: object 
        &gt;&gt;&gt; s.repeat([1, 2, 3]) 
        0    a 
        1    b 
        1    b 
        2    c 
        2    c 
        2    c 
        dtype: object 
        &quot;&quot;&quot;</span>
        <span class="s1">nv</span><span class="s3">.</span><span class="s1">validate_repeat</span><span class="s3">((), {</span><span class="s4">&quot;axis&quot;</span><span class="s3">: </span><span class="s1">axis</span><span class="s3">})</span>
        <span class="s1">new_index </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">index</span><span class="s3">.</span><span class="s1">repeat</span><span class="s3">(</span><span class="s1">repeats</span><span class="s3">)</span>
        <span class="s1">new_values </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_values</span><span class="s3">.</span><span class="s1">repeat</span><span class="s3">(</span><span class="s1">repeats</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_constructor</span><span class="s3">(</span><span class="s1">new_values</span><span class="s3">, </span><span class="s1">index</span><span class="s3">=</span><span class="s1">new_index</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">False</span><span class="s3">).</span><span class="s1">__finalize__</span><span class="s3">(</span>
            <span class="s1">self</span><span class="s3">, </span><span class="s1">method</span><span class="s3">=</span><span class="s4">&quot;repeat&quot;</span>
        <span class="s3">)</span>

    <span class="s3">@</span><span class="s1">overload</span>
    <span class="s2">def </span><span class="s1">reset_index</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">level</span><span class="s3">: </span><span class="s1">IndexLabel </span><span class="s3">= ...,</span>
        <span class="s3">*,</span>
        <span class="s1">drop</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s2">False</span><span class="s3">] = ...,</span>
        <span class="s1">name</span><span class="s3">: </span><span class="s1">Level </span><span class="s3">= ...,</span>
        <span class="s1">inplace</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s2">False</span><span class="s3">] = ...,</span>
        <span class="s1">allow_duplicates</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= ...,</span>
    <span class="s3">) </span><span class="s1">-&gt; DataFrame</span><span class="s3">:</span>
        <span class="s3">...</span>

    <span class="s3">@</span><span class="s1">overload</span>
    <span class="s2">def </span><span class="s1">reset_index</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">level</span><span class="s3">: </span><span class="s1">IndexLabel </span><span class="s3">= ...,</span>
        <span class="s3">*,</span>
        <span class="s1">drop</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s2">True</span><span class="s3">],</span>
        <span class="s1">name</span><span class="s3">: </span><span class="s1">Level </span><span class="s3">= ...,</span>
        <span class="s1">inplace</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s2">False</span><span class="s3">] = ...,</span>
        <span class="s1">allow_duplicates</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= ...,</span>
    <span class="s3">) </span><span class="s1">-&gt; Series</span><span class="s3">:</span>
        <span class="s3">...</span>

    <span class="s3">@</span><span class="s1">overload</span>
    <span class="s2">def </span><span class="s1">reset_index</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">level</span><span class="s3">: </span><span class="s1">IndexLabel </span><span class="s3">= ...,</span>
        <span class="s3">*,</span>
        <span class="s1">drop</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= ...,</span>
        <span class="s1">name</span><span class="s3">: </span><span class="s1">Level </span><span class="s3">= ...,</span>
        <span class="s1">inplace</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s2">True</span><span class="s3">],</span>
        <span class="s1">allow_duplicates</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= ...,</span>
    <span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s3">...</span>

    <span class="s2">def </span><span class="s1">reset_index</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">level</span><span class="s3">: </span><span class="s1">IndexLabel </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s3">*,</span>
        <span class="s1">drop</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span><span class="s3">,</span>
        <span class="s1">name</span><span class="s3">: </span><span class="s1">Level </span><span class="s3">= </span><span class="s1">lib</span><span class="s3">.</span><span class="s1">no_default</span><span class="s3">,</span>
        <span class="s1">inplace</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span><span class="s3">,</span>
        <span class="s1">allow_duplicates</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">-&gt; DataFrame </span><span class="s3">| </span><span class="s1">Series </span><span class="s3">| </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Generate a new DataFrame or Series with the index reset. 
 
        This is useful when the index needs to be treated as a column, or 
        when the index is meaningless and needs to be reset to the default 
        before another operation. 
 
        Parameters 
        ---------- 
        level : int, str, tuple, or list, default optional 
            For a Series with a MultiIndex, only remove the specified levels 
            from the index. Removes all levels by default. 
        drop : bool, default False 
            Just reset the index, without inserting it as a column in 
            the new DataFrame. 
        name : object, optional 
            The name to use for the column containing the original Series 
            values. Uses ``self.name`` by default. This argument is ignored 
            when `drop` is True. 
        inplace : bool, default False 
            Modify the Series in place (do not create a new object). 
        allow_duplicates : bool, default False 
            Allow duplicate column labels to be created. 
 
            .. versionadded:: 1.5.0 
 
        Returns 
        ------- 
        Series or DataFrame or None 
            When `drop` is False (the default), a DataFrame is returned. 
            The newly created columns will come first in the DataFrame, 
            followed by the original Series values. 
            When `drop` is True, a `Series` is returned. 
            In either case, if ``inplace=True``, no value is returned. 
 
        See Also 
        -------- 
        DataFrame.reset_index: Analogous function for DataFrame. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; s = pd.Series([1, 2, 3, 4], name='foo', 
        ...               index=pd.Index(['a', 'b', 'c', 'd'], name='idx')) 
 
        Generate a DataFrame with default index. 
 
        &gt;&gt;&gt; s.reset_index() 
          idx  foo 
        0   a    1 
        1   b    2 
        2   c    3 
        3   d    4 
 
        To specify the name of the new column use `name`. 
 
        &gt;&gt;&gt; s.reset_index(name='values') 
          idx  values 
        0   a       1 
        1   b       2 
        2   c       3 
        3   d       4 
 
        To generate a new Series with the default set `drop` to True. 
 
        &gt;&gt;&gt; s.reset_index(drop=True) 
        0    1 
        1    2 
        2    3 
        3    4 
        Name: foo, dtype: int64 
 
        The `level` parameter is interesting for Series with a multi-level 
        index. 
 
        &gt;&gt;&gt; arrays = [np.array(['bar', 'bar', 'baz', 'baz']), 
        ...           np.array(['one', 'two', 'one', 'two'])] 
        &gt;&gt;&gt; s2 = pd.Series( 
        ...     range(4), name='foo', 
        ...     index=pd.MultiIndex.from_arrays(arrays, 
        ...                                     names=['a', 'b'])) 
 
        To remove a specific level from the Index, use `level`. 
 
        &gt;&gt;&gt; s2.reset_index(level='a') 
               a  foo 
        b 
        one  bar    0 
        two  bar    1 
        one  baz    2 
        two  baz    3 
 
        If `level` is not set, all levels are removed from the Index. 
 
        &gt;&gt;&gt; s2.reset_index() 
             a    b  foo 
        0  bar  one    0 
        1  bar  two    1 
        2  baz  one    2 
        3  baz  two    3 
        &quot;&quot;&quot;</span>
        <span class="s1">inplace </span><span class="s3">= </span><span class="s1">validate_bool_kwarg</span><span class="s3">(</span><span class="s1">inplace</span><span class="s3">, </span><span class="s4">&quot;inplace&quot;</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">drop</span><span class="s3">:</span>
            <span class="s1">new_index </span><span class="s3">= </span><span class="s1">default_index</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">))</span>
            <span class="s2">if </span><span class="s1">level </span><span class="s2">is not None</span><span class="s3">:</span>
                <span class="s1">level_list</span><span class="s3">: </span><span class="s1">Sequence</span><span class="s3">[</span><span class="s1">Hashable</span><span class="s3">]</span>
                <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">level</span><span class="s3">, (</span><span class="s1">tuple</span><span class="s3">, </span><span class="s1">list</span><span class="s3">)):</span>
                    <span class="s1">level_list </span><span class="s3">= [</span><span class="s1">level</span><span class="s3">]</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">level_list </span><span class="s3">= </span><span class="s1">level</span>
                <span class="s1">level_list </span><span class="s3">= [</span><span class="s1">self</span><span class="s3">.</span><span class="s1">index</span><span class="s3">.</span><span class="s1">_get_level_number</span><span class="s3">(</span><span class="s1">lev</span><span class="s3">) </span><span class="s2">for </span><span class="s1">lev </span><span class="s2">in </span><span class="s1">level_list</span><span class="s3">]</span>
                <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">level_list</span><span class="s3">) &lt; </span><span class="s1">self</span><span class="s3">.</span><span class="s1">index</span><span class="s3">.</span><span class="s1">nlevels</span><span class="s3">:</span>
                    <span class="s1">new_index </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">index</span><span class="s3">.</span><span class="s1">droplevel</span><span class="s3">(</span><span class="s1">level_list</span><span class="s3">)</span>

            <span class="s2">if </span><span class="s1">inplace</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">index </span><span class="s3">= </span><span class="s1">new_index</span>
            <span class="s2">elif </span><span class="s1">using_copy_on_write</span><span class="s3">():</span>
                <span class="s1">new_ser </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">(</span><span class="s1">deep</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
                <span class="s1">new_ser</span><span class="s3">.</span><span class="s1">index </span><span class="s3">= </span><span class="s1">new_index</span>
                <span class="s2">return </span><span class="s1">new_ser</span><span class="s3">.</span><span class="s1">__finalize__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">method</span><span class="s3">=</span><span class="s4">&quot;reset_index&quot;</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_constructor</span><span class="s3">(</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">_values</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">(), </span><span class="s1">index</span><span class="s3">=</span><span class="s1">new_index</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">dtype</span>
                <span class="s3">).</span><span class="s1">__finalize__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">method</span><span class="s3">=</span><span class="s4">&quot;reset_index&quot;</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">inplace</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span>
                <span class="s4">&quot;Cannot reset_index inplace on a Series to create a DataFrame&quot;</span>
            <span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">name </span><span class="s2">is </span><span class="s1">lib</span><span class="s3">.</span><span class="s1">no_default</span><span class="s3">:</span>
                <span class="s6"># For backwards compatibility, keep columns as [0] instead of</span>
                <span class="s6">#  [None] when self.name is None</span>
                <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">name </span><span class="s2">is None</span><span class="s3">:</span>
                    <span class="s1">name </span><span class="s3">= </span><span class="s5">0</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">name </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">name</span>

            <span class="s1">df </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">to_frame</span><span class="s3">(</span><span class="s1">name</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">df</span><span class="s3">.</span><span class="s1">reset_index</span><span class="s3">(</span>
                <span class="s1">level</span><span class="s3">=</span><span class="s1">level</span><span class="s3">, </span><span class="s1">drop</span><span class="s3">=</span><span class="s1">drop</span><span class="s3">, </span><span class="s1">allow_duplicates</span><span class="s3">=</span><span class="s1">allow_duplicates</span>
            <span class="s3">)</span>
        <span class="s2">return None</span>

    <span class="s6"># ----------------------------------------------------------------------</span>
    <span class="s6"># Rendering Methods</span>

    <span class="s2">def </span><span class="s1">__repr__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; str</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Return a string representation for a particular Series. 
        &quot;&quot;&quot;</span>
        <span class="s6"># pylint: disable=invalid-repr-returned</span>
        <span class="s1">repr_params </span><span class="s3">= </span><span class="s1">fmt</span><span class="s3">.</span><span class="s1">get_series_repr_params</span><span class="s3">()</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">to_string</span><span class="s3">(**</span><span class="s1">repr_params</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">overload</span>
    <span class="s2">def </span><span class="s1">to_string</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">buf</span><span class="s3">: </span><span class="s2">None </span><span class="s3">= ...,</span>
        <span class="s1">na_rep</span><span class="s3">: </span><span class="s1">str </span><span class="s3">= ...,</span>
        <span class="s1">float_format</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= ...,</span>
        <span class="s1">header</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= ...,</span>
        <span class="s1">index</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= ...,</span>
        <span class="s1">length</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= ...,</span>
        <span class="s1">dtype</span><span class="s3">=...,</span>
        <span class="s1">name</span><span class="s3">=...,</span>
        <span class="s1">max_rows</span><span class="s3">: </span><span class="s1">int </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= ...,</span>
        <span class="s1">min_rows</span><span class="s3">: </span><span class="s1">int </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= ...,</span>
    <span class="s3">) </span><span class="s1">-&gt; str</span><span class="s3">:</span>
        <span class="s3">...</span>

    <span class="s3">@</span><span class="s1">overload</span>
    <span class="s2">def </span><span class="s1">to_string</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">buf</span><span class="s3">: </span><span class="s1">FilePath </span><span class="s3">| </span><span class="s1">WriteBuffer</span><span class="s3">[</span><span class="s1">str</span><span class="s3">],</span>
        <span class="s1">na_rep</span><span class="s3">: </span><span class="s1">str </span><span class="s3">= ...,</span>
        <span class="s1">float_format</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= ...,</span>
        <span class="s1">header</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= ...,</span>
        <span class="s1">index</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= ...,</span>
        <span class="s1">length</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= ...,</span>
        <span class="s1">dtype</span><span class="s3">=...,</span>
        <span class="s1">name</span><span class="s3">=...,</span>
        <span class="s1">max_rows</span><span class="s3">: </span><span class="s1">int </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= ...,</span>
        <span class="s1">min_rows</span><span class="s3">: </span><span class="s1">int </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= ...,</span>
    <span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s3">...</span>

    <span class="s2">def </span><span class="s1">to_string</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">buf</span><span class="s3">: </span><span class="s1">FilePath </span><span class="s3">| </span><span class="s1">WriteBuffer</span><span class="s3">[</span><span class="s1">str</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">na_rep</span><span class="s3">: </span><span class="s1">str </span><span class="s3">= </span><span class="s4">&quot;NaN&quot;</span><span class="s3">,</span>
        <span class="s1">float_format</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">header</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">True</span><span class="s3">,</span>
        <span class="s1">index</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">True</span><span class="s3">,</span>
        <span class="s1">length</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span><span class="s3">,</span>
        <span class="s1">dtype</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span><span class="s3">,</span>
        <span class="s1">name</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span><span class="s3">,</span>
        <span class="s1">max_rows</span><span class="s3">: </span><span class="s1">int </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">min_rows</span><span class="s3">: </span><span class="s1">int </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">-&gt; str </span><span class="s3">| </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Render a string representation of the Series. 
 
        Parameters 
        ---------- 
        buf : StringIO-like, optional 
            Buffer to write to. 
        na_rep : str, optional 
            String representation of NaN to use, default 'NaN'. 
        float_format : one-parameter function, optional 
            Formatter function to apply to columns' elements if they are 
            floats, default None. 
        header : bool, default True 
            Add the Series header (index name). 
        index : bool, optional 
            Add index (row) labels, default True. 
        length : bool, default False 
            Add the Series length. 
        dtype : bool, default False 
            Add the Series dtype. 
        name : bool, default False 
            Add the Series name if not None. 
        max_rows : int, optional 
            Maximum number of rows to show before truncating. If None, show 
            all. 
        min_rows : int, optional 
            The number of rows to display in a truncated repr (when number 
            of rows is above `max_rows`). 
 
        Returns 
        ------- 
        str or None 
            String representation of Series if ``buf=None``, otherwise None. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; ser = pd.Series([1, 2, 3]).to_string() 
        &gt;&gt;&gt; ser 
        '0    1\\n1    2\\n2    3' 
        &quot;&quot;&quot;</span>
        <span class="s1">formatter </span><span class="s3">= </span><span class="s1">fmt</span><span class="s3">.</span><span class="s1">SeriesFormatter</span><span class="s3">(</span>
            <span class="s1">self</span><span class="s3">,</span>
            <span class="s1">name</span><span class="s3">=</span><span class="s1">name</span><span class="s3">,</span>
            <span class="s1">length</span><span class="s3">=</span><span class="s1">length</span><span class="s3">,</span>
            <span class="s1">header</span><span class="s3">=</span><span class="s1">header</span><span class="s3">,</span>
            <span class="s1">index</span><span class="s3">=</span><span class="s1">index</span><span class="s3">,</span>
            <span class="s1">dtype</span><span class="s3">=</span><span class="s1">dtype</span><span class="s3">,</span>
            <span class="s1">na_rep</span><span class="s3">=</span><span class="s1">na_rep</span><span class="s3">,</span>
            <span class="s1">float_format</span><span class="s3">=</span><span class="s1">float_format</span><span class="s3">,</span>
            <span class="s1">min_rows</span><span class="s3">=</span><span class="s1">min_rows</span><span class="s3">,</span>
            <span class="s1">max_rows</span><span class="s3">=</span><span class="s1">max_rows</span><span class="s3">,</span>
        <span class="s3">)</span>
        <span class="s1">result </span><span class="s3">= </span><span class="s1">formatter</span><span class="s3">.</span><span class="s1">to_string</span><span class="s3">()</span>

        <span class="s6"># catch contract violations</span>
        <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">result</span><span class="s3">, </span><span class="s1">str</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">AssertionError</span><span class="s3">(</span>
                <span class="s4">&quot;result must be of type str, type &quot;</span>
                <span class="s4">f&quot;of result is </span><span class="s2">{</span><span class="s1">repr</span><span class="s3">(</span><span class="s1">type</span><span class="s3">(</span><span class="s1">result</span><span class="s3">).</span><span class="s1">__name__</span><span class="s3">)</span><span class="s2">}</span><span class="s4">&quot;</span>
            <span class="s3">)</span>

        <span class="s2">if </span><span class="s1">buf </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">result</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">buf</span><span class="s3">, </span><span class="s4">&quot;write&quot;</span><span class="s3">):</span>
                <span class="s1">buf</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s1">result</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s2">with </span><span class="s1">open</span><span class="s3">(</span><span class="s1">buf</span><span class="s3">, </span><span class="s4">&quot;w&quot;</span><span class="s3">, </span><span class="s1">encoding</span><span class="s3">=</span><span class="s4">&quot;utf-8&quot;</span><span class="s3">) </span><span class="s2">as </span><span class="s1">f</span><span class="s3">:</span>
                    <span class="s1">f</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s1">result</span><span class="s3">)</span>
        <span class="s2">return None</span>

    <span class="s3">@</span><span class="s1">doc</span><span class="s3">(</span>
        <span class="s1">klass</span><span class="s3">=</span><span class="s1">_shared_doc_kwargs</span><span class="s3">[</span><span class="s4">&quot;klass&quot;</span><span class="s3">],</span>
        <span class="s1">storage_options</span><span class="s3">=</span><span class="s1">_shared_docs</span><span class="s3">[</span><span class="s4">&quot;storage_options&quot;</span><span class="s3">],</span>
        <span class="s1">examples</span><span class="s3">=</span><span class="s1">dedent</span><span class="s3">(</span>
            <span class="s4">&quot;&quot;&quot;Examples 
            -------- 
            &gt;&gt;&gt; s = pd.Series([&quot;elk&quot;, &quot;pig&quot;, &quot;dog&quot;, &quot;quetzal&quot;], name=&quot;animal&quot;) 
            &gt;&gt;&gt; print(s.to_markdown()) 
            |    | animal   | 
            |---:|:---------| 
            |  0 | elk      | 
            |  1 | pig      | 
            |  2 | dog      | 
            |  3 | quetzal  | 
 
            Output markdown with a tabulate option. 
 
            &gt;&gt;&gt; print(s.to_markdown(tablefmt=&quot;grid&quot;)) 
            +----+----------+ 
            |    | animal   | 
            +====+==========+ 
            |  0 | elk      | 
            +----+----------+ 
            |  1 | pig      | 
            +----+----------+ 
            |  2 | dog      | 
            +----+----------+ 
            |  3 | quetzal  | 
            +----+----------+&quot;&quot;&quot;</span>
        <span class="s3">),</span>
    <span class="s3">)</span>
    <span class="s2">def </span><span class="s1">to_markdown</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">buf</span><span class="s3">: </span><span class="s1">IO</span><span class="s3">[</span><span class="s1">str</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">mode</span><span class="s3">: </span><span class="s1">str </span><span class="s3">= </span><span class="s4">&quot;wt&quot;</span><span class="s3">,</span>
        <span class="s1">index</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">True</span><span class="s3">,</span>
        <span class="s1">storage_options</span><span class="s3">: </span><span class="s1">StorageOptions </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s3">**</span><span class="s1">kwargs</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">-&gt; str </span><span class="s3">| </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Print {klass} in Markdown-friendly format. 
 
        Parameters 
        ---------- 
        buf : str, Path or StringIO-like, optional, default None 
            Buffer to write to. If None, the output is returned as a string. 
        mode : str, optional 
            Mode in which file is opened, &quot;wt&quot; by default. 
        index : bool, optional, default True 
            Add index (row) labels. 
 
        {storage_options} 
 
        **kwargs 
            These parameters will be passed to `tabulate \ 
                &lt;https://pypi.org/project/tabulate&gt;`_. 
 
        Returns 
        ------- 
        str 
            {klass} in Markdown-friendly format. 
 
        Notes 
        ----- 
        Requires the `tabulate &lt;https://pypi.org/project/tabulate&gt;`_ package. 
 
        {examples} 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">to_frame</span><span class="s3">().</span><span class="s1">to_markdown</span><span class="s3">(</span>
            <span class="s1">buf</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">=</span><span class="s1">mode</span><span class="s3">, </span><span class="s1">index</span><span class="s3">=</span><span class="s1">index</span><span class="s3">, </span><span class="s1">storage_options</span><span class="s3">=</span><span class="s1">storage_options</span><span class="s3">, **</span><span class="s1">kwargs</span>
        <span class="s3">)</span>

    <span class="s6"># ----------------------------------------------------------------------</span>

    <span class="s2">def </span><span class="s1">items</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; Iterable</span><span class="s3">[</span><span class="s1">tuple</span><span class="s3">[</span><span class="s1">Hashable</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">]]:</span>
        <span class="s0">&quot;&quot;&quot; 
        Lazily iterate over (index, value) tuples. 
 
        This method returns an iterable tuple (index, value). This is 
        convenient if you want to create a lazy iterator. 
 
        Returns 
        ------- 
        iterable 
            Iterable of tuples containing the (index, value) pairs from a 
            Series. 
 
        See Also 
        -------- 
        DataFrame.items : Iterate over (column name, Series) pairs. 
        DataFrame.iterrows : Iterate over DataFrame rows as (index, Series) pairs. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; s = pd.Series(['A', 'B', 'C']) 
        &gt;&gt;&gt; for index, value in s.items(): 
        ...     print(f&quot;Index : {index}, Value : {value}&quot;) 
        Index : 0, Value : A 
        Index : 1, Value : B 
        Index : 2, Value : C 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">iter</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">index</span><span class="s3">), </span><span class="s1">iter</span><span class="s3">(</span><span class="s1">self</span><span class="s3">))</span>

    <span class="s6"># ----------------------------------------------------------------------</span>
    <span class="s6"># Misc public methods</span>

    <span class="s2">def </span><span class="s1">keys</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; Index</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Return alias for index. 
 
        Returns 
        ------- 
        Index 
            Index of the Series. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; s = pd.Series([1, 2, 3], index=[0, 1, 2]) 
        &gt;&gt;&gt; s.keys() 
        Index([0, 1, 2], dtype='int64') 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">index</span>

    <span class="s3">@</span><span class="s1">overload</span>
    <span class="s2">def </span><span class="s1">to_dict</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">, *, </span><span class="s1">into</span><span class="s3">: </span><span class="s1">type</span><span class="s3">[</span><span class="s1">MutableMappingT</span><span class="s3">] | </span><span class="s1">MutableMappingT</span>
    <span class="s3">) </span><span class="s1">-&gt; MutableMappingT</span><span class="s3">:</span>
        <span class="s3">...</span>

    <span class="s3">@</span><span class="s1">overload</span>
    <span class="s2">def </span><span class="s1">to_dict</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, *, </span><span class="s1">into</span><span class="s3">: </span><span class="s1">type</span><span class="s3">[</span><span class="s1">dict</span><span class="s3">] = ...) </span><span class="s1">-&gt; dict</span><span class="s3">:</span>
        <span class="s3">...</span>

    <span class="s6"># error: Incompatible default for argument &quot;into&quot; (default has type &quot;type[</span>
    <span class="s6"># dict[Any, Any]]&quot;, argument has type &quot;type[MutableMappingT] | MutableMappingT&quot;)</span>
    <span class="s3">@</span><span class="s1">deprecate_nonkeyword_arguments</span><span class="s3">(</span>
        <span class="s1">version</span><span class="s3">=</span><span class="s4">&quot;3.0&quot;</span><span class="s3">, </span><span class="s1">allowed_args</span><span class="s3">=[</span><span class="s4">&quot;self&quot;</span><span class="s3">], </span><span class="s1">name</span><span class="s3">=</span><span class="s4">&quot;to_dict&quot;</span>
    <span class="s3">)</span>
    <span class="s2">def </span><span class="s1">to_dict</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">into</span><span class="s3">: </span><span class="s1">type</span><span class="s3">[</span><span class="s1">MutableMappingT</span><span class="s3">]</span>
        <span class="s3">| </span><span class="s1">MutableMappingT </span><span class="s3">= </span><span class="s1">dict</span><span class="s3">,  </span><span class="s6"># type: ignore[assignment]</span>
    <span class="s3">) </span><span class="s1">-&gt; MutableMappingT</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Convert Series to {label -&gt; value} dict or dict-like object. 
 
        Parameters 
        ---------- 
        into : class, default dict 
            The collections.abc.MutableMapping subclass to use as the return 
            object. Can be the actual class or an empty instance of the mapping 
            type you want.  If you want a collections.defaultdict, you must 
            pass it initialized. 
 
        Returns 
        ------- 
        collections.abc.MutableMapping 
            Key-value representation of Series. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; s = pd.Series([1, 2, 3, 4]) 
        &gt;&gt;&gt; s.to_dict() 
        {0: 1, 1: 2, 2: 3, 3: 4} 
        &gt;&gt;&gt; from collections import OrderedDict, defaultdict 
        &gt;&gt;&gt; s.to_dict(into=OrderedDict) 
        OrderedDict([(0, 1), (1, 2), (2, 3), (3, 4)]) 
        &gt;&gt;&gt; dd = defaultdict(list) 
        &gt;&gt;&gt; s.to_dict(into=dd) 
        defaultdict(&lt;class 'list'&gt;, {0: 1, 1: 2, 2: 3, 3: 4}) 
        &quot;&quot;&quot;</span>
        <span class="s6"># GH16122</span>
        <span class="s1">into_c </span><span class="s3">= </span><span class="s1">com</span><span class="s3">.</span><span class="s1">standardize_mapping</span><span class="s3">(</span><span class="s1">into</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">is_object_dtype</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">) </span><span class="s2">or </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">ExtensionDtype</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">into_c</span><span class="s3">((</span><span class="s1">k</span><span class="s3">, </span><span class="s1">maybe_box_native</span><span class="s3">(</span><span class="s1">v</span><span class="s3">)) </span><span class="s2">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">items</span><span class="s3">())</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s6"># Not an object dtype =&gt; all types will be the same so let the default</span>
            <span class="s6"># indexer return native python type</span>
            <span class="s2">return </span><span class="s1">into_c</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">items</span><span class="s3">())</span>

    <span class="s2">def </span><span class="s1">to_frame</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">: </span><span class="s1">Hashable </span><span class="s3">= </span><span class="s1">lib</span><span class="s3">.</span><span class="s1">no_default</span><span class="s3">) </span><span class="s1">-&gt; DataFrame</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Convert Series to DataFrame. 
 
        Parameters 
        ---------- 
        name : object, optional 
            The passed name should substitute for the series name (if it has 
            one). 
 
        Returns 
        ------- 
        DataFrame 
            DataFrame representation of Series. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; s = pd.Series([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], 
        ...               name=&quot;vals&quot;) 
        &gt;&gt;&gt; s.to_frame() 
          vals 
        0    a 
        1    b 
        2    c 
        &quot;&quot;&quot;</span>
        <span class="s1">columns</span><span class="s3">: </span><span class="s1">Index</span>
        <span class="s2">if </span><span class="s1">name </span><span class="s2">is </span><span class="s1">lib</span><span class="s3">.</span><span class="s1">no_default</span><span class="s3">:</span>
            <span class="s1">name </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">name</span>
            <span class="s2">if </span><span class="s1">name </span><span class="s2">is None</span><span class="s3">:</span>
                <span class="s6"># default to [0], same as we would get with DataFrame(self)</span>
                <span class="s1">columns </span><span class="s3">= </span><span class="s1">default_index</span><span class="s3">(</span><span class="s5">1</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">columns </span><span class="s3">= </span><span class="s1">Index</span><span class="s3">([</span><span class="s1">name</span><span class="s3">])</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">columns </span><span class="s3">= </span><span class="s1">Index</span><span class="s3">([</span><span class="s1">name</span><span class="s3">])</span>

        <span class="s1">mgr </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_mgr</span><span class="s3">.</span><span class="s1">to_2d_mgr</span><span class="s3">(</span><span class="s1">columns</span><span class="s3">)</span>
        <span class="s1">df </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_constructor_expanddim_from_mgr</span><span class="s3">(</span><span class="s1">mgr</span><span class="s3">, </span><span class="s1">axes</span><span class="s3">=</span><span class="s1">mgr</span><span class="s3">.</span><span class="s1">axes</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">df</span><span class="s3">.</span><span class="s1">__finalize__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">method</span><span class="s3">=</span><span class="s4">&quot;to_frame&quot;</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_set_name</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">inplace</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span><span class="s3">, </span><span class="s1">deep</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span>
    <span class="s3">) </span><span class="s1">-&gt; Series</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the Series name. 
 
        Parameters 
        ---------- 
        name : str 
        inplace : bool 
            Whether to modify `self` directly or return a copy. 
        deep : bool|None, default None 
            Whether to do a deep copy, a shallow copy, or Copy on Write(None) 
        &quot;&quot;&quot;</span>
        <span class="s1">inplace </span><span class="s3">= </span><span class="s1">validate_bool_kwarg</span><span class="s3">(</span><span class="s1">inplace</span><span class="s3">, </span><span class="s4">&quot;inplace&quot;</span><span class="s3">)</span>
        <span class="s1">ser </span><span class="s3">= </span><span class="s1">self </span><span class="s2">if </span><span class="s1">inplace </span><span class="s2">else </span><span class="s1">self</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">(</span><span class="s1">deep </span><span class="s2">and not </span><span class="s1">using_copy_on_write</span><span class="s3">())</span>
        <span class="s1">ser</span><span class="s3">.</span><span class="s1">name </span><span class="s3">= </span><span class="s1">name</span>
        <span class="s2">return </span><span class="s1">ser</span>

    <span class="s3">@</span><span class="s1">Appender</span><span class="s3">(</span>
        <span class="s1">dedent</span><span class="s3">(</span>
            <span class="s4">&quot;&quot;&quot; 
        Examples 
        -------- 
        &gt;&gt;&gt; ser = pd.Series([390., 350., 30., 20.], 
        ...                 index=['Falcon', 'Falcon', 'Parrot', 'Parrot'], 
        ...                 name=&quot;Max Speed&quot;) 
        &gt;&gt;&gt; ser 
        Falcon    390.0 
        Falcon    350.0 
        Parrot     30.0 
        Parrot     20.0 
        Name: Max Speed, dtype: float64 
        &gt;&gt;&gt; ser.groupby([&quot;a&quot;, &quot;b&quot;, &quot;a&quot;, &quot;b&quot;]).mean() 
        a    210.0 
        b    185.0 
        Name: Max Speed, dtype: float64 
        &gt;&gt;&gt; ser.groupby(level=0).mean() 
        Falcon    370.0 
        Parrot     25.0 
        Name: Max Speed, dtype: float64 
        &gt;&gt;&gt; ser.groupby(ser &gt; 100).mean() 
        Max Speed 
        False     25.0 
        True     370.0 
        Name: Max Speed, dtype: float64 
 
        **Grouping by Indexes** 
 
        We can groupby different levels of a hierarchical index 
        using the `level` parameter: 
 
        &gt;&gt;&gt; arrays = [['Falcon', 'Falcon', 'Parrot', 'Parrot'], 
        ...           ['Captive', 'Wild', 'Captive', 'Wild']] 
        &gt;&gt;&gt; index = pd.MultiIndex.from_arrays(arrays, names=('Animal', 'Type')) 
        &gt;&gt;&gt; ser = pd.Series([390., 350., 30., 20.], index=index, name=&quot;Max Speed&quot;) 
        &gt;&gt;&gt; ser 
        Animal  Type 
        Falcon  Captive    390.0 
                Wild       350.0 
        Parrot  Captive     30.0 
                Wild        20.0 
        Name: Max Speed, dtype: float64 
        &gt;&gt;&gt; ser.groupby(level=0).mean() 
        Animal 
        Falcon    370.0 
        Parrot     25.0 
        Name: Max Speed, dtype: float64 
        &gt;&gt;&gt; ser.groupby(level=&quot;Type&quot;).mean() 
        Type 
        Captive    210.0 
        Wild       185.0 
        Name: Max Speed, dtype: float64 
 
        We can also choose to include `NA` in group keys or not by defining 
        `dropna` parameter, the default setting is `True`. 
 
        &gt;&gt;&gt; ser = pd.Series([1, 2, 3, 3], index=[&quot;a&quot;, 'a', 'b', np.nan]) 
        &gt;&gt;&gt; ser.groupby(level=0).sum() 
        a    3 
        b    3 
        dtype: int64 
 
        &gt;&gt;&gt; ser.groupby(level=0, dropna=False).sum() 
        a    3 
        b    3 
        NaN  3 
        dtype: int64 
 
        &gt;&gt;&gt; arrays = ['Falcon', 'Falcon', 'Parrot', 'Parrot'] 
        &gt;&gt;&gt; ser = pd.Series([390., 350., 30., 20.], index=arrays, name=&quot;Max Speed&quot;) 
        &gt;&gt;&gt; ser.groupby([&quot;a&quot;, &quot;b&quot;, &quot;a&quot;, np.nan]).mean() 
        a    210.0 
        b    350.0 
        Name: Max Speed, dtype: float64 
 
        &gt;&gt;&gt; ser.groupby([&quot;a&quot;, &quot;b&quot;, &quot;a&quot;, np.nan], dropna=False).mean() 
        a    210.0 
        b    350.0 
        NaN   20.0 
        Name: Max Speed, dtype: float64 
        &quot;&quot;&quot;</span>
        <span class="s3">)</span>
    <span class="s3">)</span>
    <span class="s3">@</span><span class="s1">Appender</span><span class="s3">(</span><span class="s1">_shared_docs</span><span class="s3">[</span><span class="s4">&quot;groupby&quot;</span><span class="s3">] % </span><span class="s1">_shared_doc_kwargs</span><span class="s3">)</span>
    <span class="s2">def </span><span class="s1">groupby</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">by</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">axis</span><span class="s3">: </span><span class="s1">Axis </span><span class="s3">= </span><span class="s5">0</span><span class="s3">,</span>
        <span class="s1">level</span><span class="s3">: </span><span class="s1">IndexLabel </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">as_index</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">True</span><span class="s3">,</span>
        <span class="s1">sort</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">True</span><span class="s3">,</span>
        <span class="s1">group_keys</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">True</span><span class="s3">,</span>
        <span class="s1">observed</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s1">lib</span><span class="s3">.</span><span class="s1">NoDefault </span><span class="s3">= </span><span class="s1">lib</span><span class="s3">.</span><span class="s1">no_default</span><span class="s3">,</span>
        <span class="s1">dropna</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">True</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">-&gt; SeriesGroupBy</span><span class="s3">:</span>
        <span class="s2">from </span><span class="s1">pandas</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">groupby</span><span class="s3">.</span><span class="s1">generic </span><span class="s2">import </span><span class="s1">SeriesGroupBy</span>

        <span class="s2">if </span><span class="s1">level </span><span class="s2">is None and </span><span class="s1">by </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s4">&quot;You have to supply one of 'by' and 'level'&quot;</span><span class="s3">)</span>
        <span class="s2">if not </span><span class="s1">as_index</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s4">&quot;as_index=False only valid with DataFrame&quot;</span><span class="s3">)</span>
        <span class="s1">axis </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_axis_number</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">SeriesGroupBy</span><span class="s3">(</span>
            <span class="s1">obj</span><span class="s3">=</span><span class="s1">self</span><span class="s3">,</span>
            <span class="s1">keys</span><span class="s3">=</span><span class="s1">by</span><span class="s3">,</span>
            <span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">,</span>
            <span class="s1">level</span><span class="s3">=</span><span class="s1">level</span><span class="s3">,</span>
            <span class="s1">as_index</span><span class="s3">=</span><span class="s1">as_index</span><span class="s3">,</span>
            <span class="s1">sort</span><span class="s3">=</span><span class="s1">sort</span><span class="s3">,</span>
            <span class="s1">group_keys</span><span class="s3">=</span><span class="s1">group_keys</span><span class="s3">,</span>
            <span class="s1">observed</span><span class="s3">=</span><span class="s1">observed</span><span class="s3">,</span>
            <span class="s1">dropna</span><span class="s3">=</span><span class="s1">dropna</span><span class="s3">,</span>
        <span class="s3">)</span>

    <span class="s6"># ----------------------------------------------------------------------</span>
    <span class="s6"># Statistics, overridden ndarray methods</span>

    <span class="s6"># TODO: integrate bottleneck</span>
    <span class="s2">def </span><span class="s1">count</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; int</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Return number of non-NA/null observations in the Series. 
 
        Returns 
        ------- 
        int 
            Number of non-null values in the Series. 
 
        See Also 
        -------- 
        DataFrame.count : Count non-NA cells for each column or row. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; s = pd.Series([0.0, 1.0, np.nan]) 
        &gt;&gt;&gt; s.count() 
        2 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">notna</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_values</span><span class="s3">).</span><span class="s1">sum</span><span class="s3">().</span><span class="s1">astype</span><span class="s3">(</span><span class="s4">&quot;int64&quot;</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">mode</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">dropna</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">True</span><span class="s3">) </span><span class="s1">-&gt; Series</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the mode(s) of the Series. 
 
        The mode is the value that appears most often. There can be multiple modes. 
 
        Always returns Series even if only one value is returned. 
 
        Parameters 
        ---------- 
        dropna : bool, default True 
            Don't consider counts of NaN/NaT. 
 
        Returns 
        ------- 
        Series 
            Modes of the Series in sorted order. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; s = pd.Series([2, 4, 2, 2, 4, None]) 
        &gt;&gt;&gt; s.mode() 
        0    2.0 
        dtype: float64 
 
        More than one mode: 
 
        &gt;&gt;&gt; s = pd.Series([2, 4, 8, 2, 4, None]) 
        &gt;&gt;&gt; s.mode() 
        0    2.0 
        1    4.0 
        dtype: float64 
 
        With and without considering null value: 
 
        &gt;&gt;&gt; s = pd.Series([2, 4, None, None, 4, None]) 
        &gt;&gt;&gt; s.mode(dropna=False) 
        0   NaN 
        dtype: float64 
        &gt;&gt;&gt; s = pd.Series([2, 4, None, None, 4, None]) 
        &gt;&gt;&gt; s.mode() 
        0    4.0 
        dtype: float64 
        &quot;&quot;&quot;</span>
        <span class="s6"># TODO: Add option for bins like value_counts()</span>
        <span class="s1">values </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_values</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">values</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndarray</span><span class="s3">):</span>
            <span class="s1">res_values </span><span class="s3">= </span><span class="s1">algorithms</span><span class="s3">.</span><span class="s1">mode</span><span class="s3">(</span><span class="s1">values</span><span class="s3">, </span><span class="s1">dropna</span><span class="s3">=</span><span class="s1">dropna</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">res_values </span><span class="s3">= </span><span class="s1">values</span><span class="s3">.</span><span class="s1">_mode</span><span class="s3">(</span><span class="s1">dropna</span><span class="s3">=</span><span class="s1">dropna</span><span class="s3">)</span>

        <span class="s6"># Ensure index is type stable (should always use int index)</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_constructor</span><span class="s3">(</span>
            <span class="s1">res_values</span><span class="s3">,</span>
            <span class="s1">index</span><span class="s3">=</span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">res_values</span><span class="s3">)),</span>
            <span class="s1">name</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">name</span><span class="s3">,</span>
            <span class="s1">copy</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
            <span class="s1">dtype</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">,</span>
        <span class="s3">).</span><span class="s1">__finalize__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">method</span><span class="s3">=</span><span class="s4">&quot;mode&quot;</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">unique</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; ArrayLike</span><span class="s3">:  </span><span class="s6"># pylint: disable=useless-parent-delegation</span>
        <span class="s0">&quot;&quot;&quot; 
        Return unique values of Series object. 
 
        Uniques are returned in order of appearance. Hash table-based unique, 
        therefore does NOT sort. 
 
        Returns 
        ------- 
        ndarray or ExtensionArray 
            The unique values returned as a NumPy array. See Notes. 
 
        See Also 
        -------- 
        Series.drop_duplicates : Return Series with duplicate values removed. 
        unique : Top-level unique method for any 1-d array-like object. 
        Index.unique : Return Index with unique values from an Index object. 
 
        Notes 
        ----- 
        Returns the unique values as a NumPy array. In case of an 
        extension-array backed Series, a new 
        :class:`~api.extensions.ExtensionArray` of that type with just 
        the unique values is returned. This includes 
 
            * Categorical 
            * Period 
            * Datetime with Timezone 
            * Datetime without Timezone 
            * Timedelta 
            * Interval 
            * Sparse 
            * IntegerNA 
 
        See Examples section. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; pd.Series([2, 1, 3, 3], name='A').unique() 
        array([2, 1, 3]) 
 
        &gt;&gt;&gt; pd.Series([pd.Timestamp('2016-01-01') for _ in range(3)]).unique() 
        &lt;DatetimeArray&gt; 
        ['2016-01-01 00:00:00'] 
        Length: 1, dtype: datetime64[ns] 
 
        &gt;&gt;&gt; pd.Series([pd.Timestamp('2016-01-01', tz='US/Eastern') 
        ...            for _ in range(3)]).unique() 
        &lt;DatetimeArray&gt; 
        ['2016-01-01 00:00:00-05:00'] 
        Length: 1, dtype: datetime64[ns, US/Eastern] 
 
        An Categorical will return categories in the order of 
        appearance and with the same dtype. 
 
        &gt;&gt;&gt; pd.Series(pd.Categorical(list('baabc'))).unique() 
        ['b', 'a', 'c'] 
        Categories (3, object): ['a', 'b', 'c'] 
        &gt;&gt;&gt; pd.Series(pd.Categorical(list('baabc'), categories=list('abc'), 
        ...                          ordered=True)).unique() 
        ['b', 'a', 'c'] 
        Categories (3, object): ['a' &lt; 'b' &lt; 'c'] 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">super</span><span class="s3">().</span><span class="s1">unique</span><span class="s3">()</span>

    <span class="s3">@</span><span class="s1">overload</span>
    <span class="s2">def </span><span class="s1">drop_duplicates</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s3">*,</span>
        <span class="s1">keep</span><span class="s3">: </span><span class="s1">DropKeep </span><span class="s3">= ...,</span>
        <span class="s1">inplace</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s2">False</span><span class="s3">] = ...,</span>
        <span class="s1">ignore_index</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= ...,</span>
    <span class="s3">) </span><span class="s1">-&gt; Series</span><span class="s3">:</span>
        <span class="s3">...</span>

    <span class="s3">@</span><span class="s1">overload</span>
    <span class="s2">def </span><span class="s1">drop_duplicates</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">, *, </span><span class="s1">keep</span><span class="s3">: </span><span class="s1">DropKeep </span><span class="s3">= ..., </span><span class="s1">inplace</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s2">True</span><span class="s3">], </span><span class="s1">ignore_index</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= ...</span>
    <span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s3">...</span>

    <span class="s3">@</span><span class="s1">overload</span>
    <span class="s2">def </span><span class="s1">drop_duplicates</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">, *, </span><span class="s1">keep</span><span class="s3">: </span><span class="s1">DropKeep </span><span class="s3">= ..., </span><span class="s1">inplace</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= ..., </span><span class="s1">ignore_index</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= ...</span>
    <span class="s3">) </span><span class="s1">-&gt; Series </span><span class="s3">| </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s3">...</span>

    <span class="s2">def </span><span class="s1">drop_duplicates</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s3">*,</span>
        <span class="s1">keep</span><span class="s3">: </span><span class="s1">DropKeep </span><span class="s3">= </span><span class="s4">&quot;first&quot;</span><span class="s3">,</span>
        <span class="s1">inplace</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span><span class="s3">,</span>
        <span class="s1">ignore_index</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">-&gt; Series </span><span class="s3">| </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Return Series with duplicate values removed. 
 
        Parameters 
        ---------- 
        keep : {'first', 'last', ``False``}, default 'first' 
            Method to handle dropping duplicates: 
 
            - 'first' : Drop duplicates except for the first occurrence. 
            - 'last' : Drop duplicates except for the last occurrence. 
            - ``False`` : Drop all duplicates. 
 
        inplace : bool, default ``False`` 
            If ``True``, performs operation inplace and returns None. 
 
        ignore_index : bool, default ``False`` 
            If ``True``, the resulting axis will be labeled 0, 1, …, n - 1. 
 
            .. versionadded:: 2.0.0 
 
        Returns 
        ------- 
        Series or None 
            Series with duplicates dropped or None if ``inplace=True``. 
 
        See Also 
        -------- 
        Index.drop_duplicates : Equivalent method on Index. 
        DataFrame.drop_duplicates : Equivalent method on DataFrame. 
        Series.duplicated : Related method on Series, indicating duplicate 
            Series values. 
        Series.unique : Return unique values as an array. 
 
        Examples 
        -------- 
        Generate a Series with duplicated entries. 
 
        &gt;&gt;&gt; s = pd.Series(['llama', 'cow', 'llama', 'beetle', 'llama', 'hippo'], 
        ...               name='animal') 
        &gt;&gt;&gt; s 
        0     llama 
        1       cow 
        2     llama 
        3    beetle 
        4     llama 
        5     hippo 
        Name: animal, dtype: object 
 
        With the 'keep' parameter, the selection behaviour of duplicated values 
        can be changed. The value 'first' keeps the first occurrence for each 
        set of duplicated entries. The default value of keep is 'first'. 
 
        &gt;&gt;&gt; s.drop_duplicates() 
        0     llama 
        1       cow 
        3    beetle 
        5     hippo 
        Name: animal, dtype: object 
 
        The value 'last' for parameter 'keep' keeps the last occurrence for 
        each set of duplicated entries. 
 
        &gt;&gt;&gt; s.drop_duplicates(keep='last') 
        1       cow 
        3    beetle 
        4     llama 
        5     hippo 
        Name: animal, dtype: object 
 
        The value ``False`` for parameter 'keep' discards all sets of 
        duplicated entries. 
 
        &gt;&gt;&gt; s.drop_duplicates(keep=False) 
        1       cow 
        3    beetle 
        5     hippo 
        Name: animal, dtype: object 
        &quot;&quot;&quot;</span>
        <span class="s1">inplace </span><span class="s3">= </span><span class="s1">validate_bool_kwarg</span><span class="s3">(</span><span class="s1">inplace</span><span class="s3">, </span><span class="s4">&quot;inplace&quot;</span><span class="s3">)</span>
        <span class="s1">result </span><span class="s3">= </span><span class="s1">super</span><span class="s3">().</span><span class="s1">drop_duplicates</span><span class="s3">(</span><span class="s1">keep</span><span class="s3">=</span><span class="s1">keep</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">ignore_index</span><span class="s3">:</span>
            <span class="s1">result</span><span class="s3">.</span><span class="s1">index </span><span class="s3">= </span><span class="s1">default_index</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">result</span><span class="s3">))</span>

        <span class="s2">if </span><span class="s1">inplace</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_update_inplace</span><span class="s3">(</span><span class="s1">result</span><span class="s3">)</span>
            <span class="s2">return None</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">result</span>

    <span class="s2">def </span><span class="s1">duplicated</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">keep</span><span class="s3">: </span><span class="s1">DropKeep </span><span class="s3">= </span><span class="s4">&quot;first&quot;</span><span class="s3">) </span><span class="s1">-&gt; Series</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Indicate duplicate Series values. 
 
        Duplicated values are indicated as ``True`` values in the resulting 
        Series. Either all duplicates, all except the first or all except the 
        last occurrence of duplicates can be indicated. 
 
        Parameters 
        ---------- 
        keep : {'first', 'last', False}, default 'first' 
            Method to handle dropping duplicates: 
 
            - 'first' : Mark duplicates as ``True`` except for the first 
              occurrence. 
            - 'last' : Mark duplicates as ``True`` except for the last 
              occurrence. 
            - ``False`` : Mark all duplicates as ``True``. 
 
        Returns 
        ------- 
        Series[bool] 
            Series indicating whether each value has occurred in the 
            preceding values. 
 
        See Also 
        -------- 
        Index.duplicated : Equivalent method on pandas.Index. 
        DataFrame.duplicated : Equivalent method on pandas.DataFrame. 
        Series.drop_duplicates : Remove duplicate values from Series. 
 
        Examples 
        -------- 
        By default, for each set of duplicated values, the first occurrence is 
        set on False and all others on True: 
 
        &gt;&gt;&gt; animals = pd.Series(['llama', 'cow', 'llama', 'beetle', 'llama']) 
        &gt;&gt;&gt; animals.duplicated() 
        0    False 
        1    False 
        2     True 
        3    False 
        4     True 
        dtype: bool 
 
        which is equivalent to 
 
        &gt;&gt;&gt; animals.duplicated(keep='first') 
        0    False 
        1    False 
        2     True 
        3    False 
        4     True 
        dtype: bool 
 
        By using 'last', the last occurrence of each set of duplicated values 
        is set on False and all others on True: 
 
        &gt;&gt;&gt; animals.duplicated(keep='last') 
        0     True 
        1    False 
        2     True 
        3    False 
        4    False 
        dtype: bool 
 
        By setting keep on ``False``, all duplicates are True: 
 
        &gt;&gt;&gt; animals.duplicated(keep=False) 
        0     True 
        1    False 
        2     True 
        3    False 
        4     True 
        dtype: bool 
        &quot;&quot;&quot;</span>
        <span class="s1">res </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_duplicated</span><span class="s3">(</span><span class="s1">keep</span><span class="s3">=</span><span class="s1">keep</span><span class="s3">)</span>
        <span class="s1">result </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_constructor</span><span class="s3">(</span><span class="s1">res</span><span class="s3">, </span><span class="s1">index</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">index</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">result</span><span class="s3">.</span><span class="s1">__finalize__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">method</span><span class="s3">=</span><span class="s4">&quot;duplicated&quot;</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">idxmin</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">: </span><span class="s1">Axis </span><span class="s3">= </span><span class="s5">0</span><span class="s3">, </span><span class="s1">skipna</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">True</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">) </span><span class="s1">-&gt; Hashable</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the row label of the minimum value. 
 
        If multiple values equal the minimum, the first row label with that 
        value is returned. 
 
        Parameters 
        ---------- 
        axis : {0 or 'index'} 
            Unused. Parameter needed for compatibility with DataFrame. 
        skipna : bool, default True 
            Exclude NA/null values. If the entire Series is NA, the result 
            will be NA. 
        *args, **kwargs 
            Additional arguments and keywords have no effect but might be 
            accepted for compatibility with NumPy. 
 
        Returns 
        ------- 
        Index 
            Label of the minimum value. 
 
        Raises 
        ------ 
        ValueError 
            If the Series is empty. 
 
        See Also 
        -------- 
        numpy.argmin : Return indices of the minimum values 
            along the given axis. 
        DataFrame.idxmin : Return index of first occurrence of minimum 
            over requested axis. 
        Series.idxmax : Return index *label* of the first occurrence 
            of maximum of values. 
 
        Notes 
        ----- 
        This method is the Series version of ``ndarray.argmin``. This method 
        returns the label of the minimum, while ``ndarray.argmin`` returns 
        the position. To get the position, use ``series.values.argmin()``. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; s = pd.Series(data=[1, None, 4, 1], 
        ...               index=['A', 'B', 'C', 'D']) 
        &gt;&gt;&gt; s 
        A    1.0 
        B    NaN 
        C    4.0 
        D    1.0 
        dtype: float64 
 
        &gt;&gt;&gt; s.idxmin() 
        'A' 
 
        If `skipna` is False and there is an NA value in the data, 
        the function returns ``nan``. 
 
        &gt;&gt;&gt; s.idxmin(skipna=False) 
        nan 
        &quot;&quot;&quot;</span>
        <span class="s1">axis </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_axis_number</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">)</span>
        <span class="s2">with </span><span class="s1">warnings</span><span class="s3">.</span><span class="s1">catch_warnings</span><span class="s3">():</span>
            <span class="s6"># TODO(3.0): this catching/filtering can be removed</span>
            <span class="s6"># ignore warning produced by argmin since we will issue a different</span>
            <span class="s6">#  warning for idxmin</span>
            <span class="s1">warnings</span><span class="s3">.</span><span class="s1">simplefilter</span><span class="s3">(</span><span class="s4">&quot;ignore&quot;</span><span class="s3">)</span>
            <span class="s1">i </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">argmin</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">, </span><span class="s1">skipna</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">i </span><span class="s3">== -</span><span class="s5">1</span><span class="s3">:</span>
            <span class="s6"># GH#43587 give correct NA value for Index.</span>
            <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span>
                <span class="s4">f&quot;The behavior of </span><span class="s2">{</span><span class="s1">type</span><span class="s3">(</span><span class="s1">self</span><span class="s3">).</span><span class="s1">__name__</span><span class="s2">}</span><span class="s4">.idxmin with all-NA &quot;</span>
                <span class="s4">&quot;values, or any-NA and skipna=False, is deprecated. In a future &quot;</span>
                <span class="s4">&quot;version this will raise ValueError&quot;</span><span class="s3">,</span>
                <span class="s1">FutureWarning</span><span class="s3">,</span>
                <span class="s1">stacklevel</span><span class="s3">=</span><span class="s1">find_stack_level</span><span class="s3">(),</span>
            <span class="s3">)</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">index</span><span class="s3">.</span><span class="s1">_na_value</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">index</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>

    <span class="s2">def </span><span class="s1">idxmax</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">: </span><span class="s1">Axis </span><span class="s3">= </span><span class="s5">0</span><span class="s3">, </span><span class="s1">skipna</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">True</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">) </span><span class="s1">-&gt; Hashable</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the row label of the maximum value. 
 
        If multiple values equal the maximum, the first row label with that 
        value is returned. 
 
        Parameters 
        ---------- 
        axis : {0 or 'index'} 
            Unused. Parameter needed for compatibility with DataFrame. 
        skipna : bool, default True 
            Exclude NA/null values. If the entire Series is NA, the result 
            will be NA. 
        *args, **kwargs 
            Additional arguments and keywords have no effect but might be 
            accepted for compatibility with NumPy. 
 
        Returns 
        ------- 
        Index 
            Label of the maximum value. 
 
        Raises 
        ------ 
        ValueError 
            If the Series is empty. 
 
        See Also 
        -------- 
        numpy.argmax : Return indices of the maximum values 
            along the given axis. 
        DataFrame.idxmax : Return index of first occurrence of maximum 
            over requested axis. 
        Series.idxmin : Return index *label* of the first occurrence 
            of minimum of values. 
 
        Notes 
        ----- 
        This method is the Series version of ``ndarray.argmax``. This method 
        returns the label of the maximum, while ``ndarray.argmax`` returns 
        the position. To get the position, use ``series.values.argmax()``. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; s = pd.Series(data=[1, None, 4, 3, 4], 
        ...               index=['A', 'B', 'C', 'D', 'E']) 
        &gt;&gt;&gt; s 
        A    1.0 
        B    NaN 
        C    4.0 
        D    3.0 
        E    4.0 
        dtype: float64 
 
        &gt;&gt;&gt; s.idxmax() 
        'C' 
 
        If `skipna` is False and there is an NA value in the data, 
        the function returns ``nan``. 
 
        &gt;&gt;&gt; s.idxmax(skipna=False) 
        nan 
        &quot;&quot;&quot;</span>
        <span class="s1">axis </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_axis_number</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">)</span>
        <span class="s2">with </span><span class="s1">warnings</span><span class="s3">.</span><span class="s1">catch_warnings</span><span class="s3">():</span>
            <span class="s6"># TODO(3.0): this catching/filtering can be removed</span>
            <span class="s6"># ignore warning produced by argmax since we will issue a different</span>
            <span class="s6">#  warning for argmax</span>
            <span class="s1">warnings</span><span class="s3">.</span><span class="s1">simplefilter</span><span class="s3">(</span><span class="s4">&quot;ignore&quot;</span><span class="s3">)</span>
            <span class="s1">i </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">argmax</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">, </span><span class="s1">skipna</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">i </span><span class="s3">== -</span><span class="s5">1</span><span class="s3">:</span>
            <span class="s6"># GH#43587 give correct NA value for Index.</span>
            <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span>
                <span class="s4">f&quot;The behavior of </span><span class="s2">{</span><span class="s1">type</span><span class="s3">(</span><span class="s1">self</span><span class="s3">).</span><span class="s1">__name__</span><span class="s2">}</span><span class="s4">.idxmax with all-NA &quot;</span>
                <span class="s4">&quot;values, or any-NA and skipna=False, is deprecated. In a future &quot;</span>
                <span class="s4">&quot;version this will raise ValueError&quot;</span><span class="s3">,</span>
                <span class="s1">FutureWarning</span><span class="s3">,</span>
                <span class="s1">stacklevel</span><span class="s3">=</span><span class="s1">find_stack_level</span><span class="s3">(),</span>
            <span class="s3">)</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">index</span><span class="s3">.</span><span class="s1">_na_value</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">index</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>

    <span class="s2">def </span><span class="s1">round</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">decimals</span><span class="s3">: </span><span class="s1">int </span><span class="s3">= </span><span class="s5">0</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">) </span><span class="s1">-&gt; Series</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Round each value in a Series to the given number of decimals. 
 
        Parameters 
        ---------- 
        decimals : int, default 0 
            Number of decimal places to round to. If decimals is negative, 
            it specifies the number of positions to the left of the decimal point. 
        *args, **kwargs 
            Additional arguments and keywords have no effect but might be 
            accepted for compatibility with NumPy. 
 
        Returns 
        ------- 
        Series 
            Rounded values of the Series. 
 
        See Also 
        -------- 
        numpy.around : Round values of an np.array. 
        DataFrame.round : Round values of a DataFrame. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; s = pd.Series([0.1, 1.3, 2.7]) 
        &gt;&gt;&gt; s.round() 
        0    0.0 
        1    1.0 
        2    3.0 
        dtype: float64 
        &quot;&quot;&quot;</span>
        <span class="s1">nv</span><span class="s3">.</span><span class="s1">validate_round</span><span class="s3">(</span><span class="s1">args</span><span class="s3">, </span><span class="s1">kwargs</span><span class="s3">)</span>
        <span class="s1">new_mgr </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_mgr</span><span class="s3">.</span><span class="s1">round</span><span class="s3">(</span><span class="s1">decimals</span><span class="s3">=</span><span class="s1">decimals</span><span class="s3">, </span><span class="s1">using_cow</span><span class="s3">=</span><span class="s1">using_copy_on_write</span><span class="s3">())</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_constructor_from_mgr</span><span class="s3">(</span><span class="s1">new_mgr</span><span class="s3">, </span><span class="s1">axes</span><span class="s3">=</span><span class="s1">new_mgr</span><span class="s3">.</span><span class="s1">axes</span><span class="s3">).</span><span class="s1">__finalize__</span><span class="s3">(</span>
            <span class="s1">self</span><span class="s3">, </span><span class="s1">method</span><span class="s3">=</span><span class="s4">&quot;round&quot;</span>
        <span class="s3">)</span>

    <span class="s3">@</span><span class="s1">overload</span>
    <span class="s2">def </span><span class="s1">quantile</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">q</span><span class="s3">: </span><span class="s1">float </span><span class="s3">= ..., </span><span class="s1">interpolation</span><span class="s3">: </span><span class="s1">QuantileInterpolation </span><span class="s3">= ...</span>
    <span class="s3">) </span><span class="s1">-&gt; float</span><span class="s3">:</span>
        <span class="s3">...</span>

    <span class="s3">@</span><span class="s1">overload</span>
    <span class="s2">def </span><span class="s1">quantile</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">q</span><span class="s3">: </span><span class="s1">Sequence</span><span class="s3">[</span><span class="s1">float</span><span class="s3">] | </span><span class="s1">AnyArrayLike</span><span class="s3">,</span>
        <span class="s1">interpolation</span><span class="s3">: </span><span class="s1">QuantileInterpolation </span><span class="s3">= ...,</span>
    <span class="s3">) </span><span class="s1">-&gt; Series</span><span class="s3">:</span>
        <span class="s3">...</span>

    <span class="s3">@</span><span class="s1">overload</span>
    <span class="s2">def </span><span class="s1">quantile</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">q</span><span class="s3">: </span><span class="s1">float </span><span class="s3">| </span><span class="s1">Sequence</span><span class="s3">[</span><span class="s1">float</span><span class="s3">] | </span><span class="s1">AnyArrayLike </span><span class="s3">= ...,</span>
        <span class="s1">interpolation</span><span class="s3">: </span><span class="s1">QuantileInterpolation </span><span class="s3">= ...,</span>
    <span class="s3">) </span><span class="s1">-&gt; float </span><span class="s3">| </span><span class="s1">Series</span><span class="s3">:</span>
        <span class="s3">...</span>

    <span class="s2">def </span><span class="s1">quantile</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">q</span><span class="s3">: </span><span class="s1">float </span><span class="s3">| </span><span class="s1">Sequence</span><span class="s3">[</span><span class="s1">float</span><span class="s3">] | </span><span class="s1">AnyArrayLike </span><span class="s3">= </span><span class="s5">0.5</span><span class="s3">,</span>
        <span class="s1">interpolation</span><span class="s3">: </span><span class="s1">QuantileInterpolation </span><span class="s3">= </span><span class="s4">&quot;linear&quot;</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">-&gt; float </span><span class="s3">| </span><span class="s1">Series</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Return value at the given quantile. 
 
        Parameters 
        ---------- 
        q : float or array-like, default 0.5 (50% quantile) 
            The quantile(s) to compute, which can lie in range: 0 &lt;= q &lt;= 1. 
        interpolation : {'linear', 'lower', 'higher', 'midpoint', 'nearest'} 
            This optional parameter specifies the interpolation method to use, 
            when the desired quantile lies between two data points `i` and `j`: 
 
                * linear: `i + (j - i) * (x-i)/(j-i)`, where `(x-i)/(j-i)` is 
                  the fractional part of the index surrounded by `i &gt; j`. 
                * lower: `i`. 
                * higher: `j`. 
                * nearest: `i` or `j` whichever is nearest. 
                * midpoint: (`i` + `j`) / 2. 
 
        Returns 
        ------- 
        float or Series 
            If ``q`` is an array, a Series will be returned where the 
            index is ``q`` and the values are the quantiles, otherwise 
            a float will be returned. 
 
        See Also 
        -------- 
        core.window.Rolling.quantile : Calculate the rolling quantile. 
        numpy.percentile : Returns the q-th percentile(s) of the array elements. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; s = pd.Series([1, 2, 3, 4]) 
        &gt;&gt;&gt; s.quantile(.5) 
        2.5 
        &gt;&gt;&gt; s.quantile([.25, .5, .75]) 
        0.25    1.75 
        0.50    2.50 
        0.75    3.25 
        dtype: float64 
        &quot;&quot;&quot;</span>
        <span class="s1">validate_percentile</span><span class="s3">(</span><span class="s1">q</span><span class="s3">)</span>

        <span class="s6"># We dispatch to DataFrame so that core.internals only has to worry</span>
        <span class="s6">#  about 2D cases.</span>
        <span class="s1">df </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">to_frame</span><span class="s3">()</span>

        <span class="s1">result </span><span class="s3">= </span><span class="s1">df</span><span class="s3">.</span><span class="s1">quantile</span><span class="s3">(</span><span class="s1">q</span><span class="s3">=</span><span class="s1">q</span><span class="s3">, </span><span class="s1">interpolation</span><span class="s3">=</span><span class="s1">interpolation</span><span class="s3">, </span><span class="s1">numeric_only</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">result</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s5">2</span><span class="s3">:</span>
            <span class="s1">result </span><span class="s3">= </span><span class="s1">result</span><span class="s3">.</span><span class="s1">iloc</span><span class="s3">[:, </span><span class="s5">0</span><span class="s3">]</span>

        <span class="s2">if </span><span class="s1">is_list_like</span><span class="s3">(</span><span class="s1">q</span><span class="s3">):</span>
            <span class="s1">result</span><span class="s3">.</span><span class="s1">name </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">name</span>
            <span class="s1">idx </span><span class="s3">= </span><span class="s1">Index</span><span class="s3">(</span><span class="s1">q</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_constructor</span><span class="s3">(</span><span class="s1">result</span><span class="s3">, </span><span class="s1">index</span><span class="s3">=</span><span class="s1">idx</span><span class="s3">, </span><span class="s1">name</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">name</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s6"># scalar</span>
            <span class="s2">return </span><span class="s1">result</span><span class="s3">.</span><span class="s1">iloc</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>

    <span class="s2">def </span><span class="s1">corr</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">other</span><span class="s3">: </span><span class="s1">Series</span><span class="s3">,</span>
        <span class="s1">method</span><span class="s3">: </span><span class="s1">CorrelationMethod </span><span class="s3">= </span><span class="s4">&quot;pearson&quot;</span><span class="s3">,</span>
        <span class="s1">min_periods</span><span class="s3">: </span><span class="s1">int </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">-&gt; float</span><span class="s3">:</span>
        <span class="s4">&quot;&quot;&quot; 
        Compute correlation with `other` Series, excluding missing values. 
 
        The two `Series` objects are not required to be the same length and will be 
        aligned internally before the correlation function is applied. 
 
        Parameters 
        ---------- 
        other : Series 
            Series with which to compute the correlation. 
        method : {'pearson', 'kendall', 'spearman'} or callable 
            Method used to compute correlation: 
 
            - pearson : Standard correlation coefficient 
            - kendall : Kendall Tau correlation coefficient 
            - spearman : Spearman rank correlation 
            - callable: Callable with input two 1d ndarrays and returning a float. 
 
            .. warning:: 
                Note that the returned matrix from corr will have 1 along the 
                diagonals and will be symmetric regardless of the callable's 
                behavior. 
        min_periods : int, optional 
            Minimum number of observations needed to have a valid result. 
 
        Returns 
        ------- 
        float 
            Correlation with other. 
 
        See Also 
        -------- 
        DataFrame.corr : Compute pairwise correlation between columns. 
        DataFrame.corrwith : Compute pairwise correlation with another 
            DataFrame or Series. 
 
        Notes 
        ----- 
        Pearson, Kendall and Spearman correlation are currently computed using pairwise complete observations. 
 
        * `Pearson correlation coefficient &lt;https://en.wikipedia.org/wiki/Pearson_correlation_coefficient&gt;`_ 
        * `Kendall rank correlation coefficient &lt;https://en.wikipedia.org/wiki/Kendall_rank_correlation_coefficient&gt;`_ 
        * `Spearman's rank correlation coefficient &lt;https://en.wikipedia.org/wiki/Spearman%27s_rank_correlation_coefficient&gt;`_ 
 
        Automatic data alignment: as with all pandas operations, automatic data alignment is performed for this method. 
        ``corr()`` automatically considers values with matching indices. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; def histogram_intersection(a, b): 
        ...     v = np.minimum(a, b).sum().round(decimals=1) 
        ...     return v 
        &gt;&gt;&gt; s1 = pd.Series([.2, .0, .6, .2]) 
        &gt;&gt;&gt; s2 = pd.Series([.3, .6, .0, .1]) 
        &gt;&gt;&gt; s1.corr(s2, method=histogram_intersection) 
        0.3 
 
        Pandas auto-aligns the values with matching indices 
 
        &gt;&gt;&gt; s1 = pd.Series([1, 2, 3], index=[0, 1, 2]) 
        &gt;&gt;&gt; s2 = pd.Series([1, 2, 3], index=[2, 1, 0]) 
        &gt;&gt;&gt; s1.corr(s2) 
        -1.0 
        &quot;&quot;&quot;  </span><span class="s6"># noqa: E501</span>
        <span class="s1">this</span><span class="s3">, </span><span class="s1">other </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">align</span><span class="s3">(</span><span class="s1">other</span><span class="s3">, </span><span class="s1">join</span><span class="s3">=</span><span class="s4">&quot;inner&quot;</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">this</span><span class="s3">) == </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span>

        <span class="s1">this_values </span><span class="s3">= </span><span class="s1">this</span><span class="s3">.</span><span class="s1">to_numpy</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">float</span><span class="s3">, </span><span class="s1">na_value</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
        <span class="s1">other_values </span><span class="s3">= </span><span class="s1">other</span><span class="s3">.</span><span class="s1">to_numpy</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">float</span><span class="s3">, </span><span class="s1">na_value</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">method </span><span class="s2">in </span><span class="s3">[</span><span class="s4">&quot;pearson&quot;</span><span class="s3">, </span><span class="s4">&quot;spearman&quot;</span><span class="s3">, </span><span class="s4">&quot;kendall&quot;</span><span class="s3">] </span><span class="s2">or </span><span class="s1">callable</span><span class="s3">(</span><span class="s1">method</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">nanops</span><span class="s3">.</span><span class="s1">nancorr</span><span class="s3">(</span>
                <span class="s1">this_values</span><span class="s3">, </span><span class="s1">other_values</span><span class="s3">, </span><span class="s1">method</span><span class="s3">=</span><span class="s1">method</span><span class="s3">, </span><span class="s1">min_periods</span><span class="s3">=</span><span class="s1">min_periods</span>
            <span class="s3">)</span>

        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span>
            <span class="s4">&quot;method must be either 'pearson', &quot;</span>
            <span class="s4">&quot;'spearman', 'kendall', or a callable, &quot;</span>
            <span class="s4">f&quot;'</span><span class="s2">{</span><span class="s1">method</span><span class="s2">}</span><span class="s4">' was supplied&quot;</span>
        <span class="s3">)</span>

    <span class="s2">def </span><span class="s1">cov</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">other</span><span class="s3">: </span><span class="s1">Series</span><span class="s3">,</span>
        <span class="s1">min_periods</span><span class="s3">: </span><span class="s1">int </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">ddof</span><span class="s3">: </span><span class="s1">int </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s5">1</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">-&gt; float</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Compute covariance with Series, excluding missing values. 
 
        The two `Series` objects are not required to be the same length and 
        will be aligned internally before the covariance is calculated. 
 
        Parameters 
        ---------- 
        other : Series 
            Series with which to compute the covariance. 
        min_periods : int, optional 
            Minimum number of observations needed to have a valid result. 
        ddof : int, default 1 
            Delta degrees of freedom.  The divisor used in calculations 
            is ``N - ddof``, where ``N`` represents the number of elements. 
 
        Returns 
        ------- 
        float 
            Covariance between Series and other normalized by N-1 
            (unbiased estimator). 
 
        See Also 
        -------- 
        DataFrame.cov : Compute pairwise covariance of columns. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; s1 = pd.Series([0.90010907, 0.13484424, 0.62036035]) 
        &gt;&gt;&gt; s2 = pd.Series([0.12528585, 0.26962463, 0.51111198]) 
        &gt;&gt;&gt; s1.cov(s2) 
        -0.01685762652715874 
        &quot;&quot;&quot;</span>
        <span class="s1">this</span><span class="s3">, </span><span class="s1">other </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">align</span><span class="s3">(</span><span class="s1">other</span><span class="s3">, </span><span class="s1">join</span><span class="s3">=</span><span class="s4">&quot;inner&quot;</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">this</span><span class="s3">) == </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span>
        <span class="s1">this_values </span><span class="s3">= </span><span class="s1">this</span><span class="s3">.</span><span class="s1">to_numpy</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">float</span><span class="s3">, </span><span class="s1">na_value</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
        <span class="s1">other_values </span><span class="s3">= </span><span class="s1">other</span><span class="s3">.</span><span class="s1">to_numpy</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">float</span><span class="s3">, </span><span class="s1">na_value</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">nanops</span><span class="s3">.</span><span class="s1">nancov</span><span class="s3">(</span>
            <span class="s1">this_values</span><span class="s3">, </span><span class="s1">other_values</span><span class="s3">, </span><span class="s1">min_periods</span><span class="s3">=</span><span class="s1">min_periods</span><span class="s3">, </span><span class="s1">ddof</span><span class="s3">=</span><span class="s1">ddof</span>
        <span class="s3">)</span>

    <span class="s3">@</span><span class="s1">doc</span><span class="s3">(</span>
        <span class="s1">klass</span><span class="s3">=</span><span class="s4">&quot;Series&quot;</span><span class="s3">,</span>
        <span class="s1">extra_params</span><span class="s3">=</span><span class="s4">&quot;&quot;</span><span class="s3">,</span>
        <span class="s1">other_klass</span><span class="s3">=</span><span class="s4">&quot;DataFrame&quot;</span><span class="s3">,</span>
        <span class="s1">examples</span><span class="s3">=</span><span class="s1">dedent</span><span class="s3">(</span>
            <span class="s4">&quot;&quot;&quot; 
        Difference with previous row 
 
        &gt;&gt;&gt; s = pd.Series([1, 1, 2, 3, 5, 8]) 
        &gt;&gt;&gt; s.diff() 
        0    NaN 
        1    0.0 
        2    1.0 
        3    1.0 
        4    2.0 
        5    3.0 
        dtype: float64 
 
        Difference with 3rd previous row 
 
        &gt;&gt;&gt; s.diff(periods=3) 
        0    NaN 
        1    NaN 
        2    NaN 
        3    2.0 
        4    4.0 
        5    6.0 
        dtype: float64 
 
        Difference with following row 
 
        &gt;&gt;&gt; s.diff(periods=-1) 
        0    0.0 
        1   -1.0 
        2   -1.0 
        3   -2.0 
        4   -3.0 
        5    NaN 
        dtype: float64 
 
        Overflow in input dtype 
 
        &gt;&gt;&gt; s = pd.Series([1, 0], dtype=np.uint8) 
        &gt;&gt;&gt; s.diff() 
        0      NaN 
        1    255.0 
        dtype: float64&quot;&quot;&quot;</span>
        <span class="s3">),</span>
    <span class="s3">)</span>
    <span class="s2">def </span><span class="s1">diff</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">periods</span><span class="s3">: </span><span class="s1">int </span><span class="s3">= </span><span class="s5">1</span><span class="s3">) </span><span class="s1">-&gt; Series</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot; 
        First discrete difference of element. 
 
        Calculates the difference of a {klass} element compared with another 
        element in the {klass} (default is element in previous row). 
 
        Parameters 
        ---------- 
        periods : int, default 1 
            Periods to shift for calculating difference, accepts negative 
            values. 
        {extra_params} 
        Returns 
        ------- 
        {klass} 
            First differences of the Series. 
 
        See Also 
        -------- 
        {klass}.pct_change: Percent change over given number of periods. 
        {klass}.shift: Shift index by desired number of periods with an 
            optional time freq. 
        {other_klass}.diff: First discrete difference of object. 
 
        Notes 
        ----- 
        For boolean dtypes, this uses :meth:`operator.xor` rather than 
        :meth:`operator.sub`. 
        The result is calculated according to current dtype in {klass}, 
        however dtype of the result is always float64. 
 
        Examples 
        -------- 
        {examples} 
        &quot;&quot;&quot;</span>
        <span class="s1">result </span><span class="s3">= </span><span class="s1">algorithms</span><span class="s3">.</span><span class="s1">diff</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_values</span><span class="s3">, </span><span class="s1">periods</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_constructor</span><span class="s3">(</span><span class="s1">result</span><span class="s3">, </span><span class="s1">index</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">index</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">False</span><span class="s3">).</span><span class="s1">__finalize__</span><span class="s3">(</span>
            <span class="s1">self</span><span class="s3">, </span><span class="s1">method</span><span class="s3">=</span><span class="s4">&quot;diff&quot;</span>
        <span class="s3">)</span>

    <span class="s2">def </span><span class="s1">autocorr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">lag</span><span class="s3">: </span><span class="s1">int </span><span class="s3">= </span><span class="s5">1</span><span class="s3">) </span><span class="s1">-&gt; float</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Compute the lag-N autocorrelation. 
 
        This method computes the Pearson correlation between 
        the Series and its shifted self. 
 
        Parameters 
        ---------- 
        lag : int, default 1 
            Number of lags to apply before performing autocorrelation. 
 
        Returns 
        ------- 
        float 
            The Pearson correlation between self and self.shift(lag). 
 
        See Also 
        -------- 
        Series.corr : Compute the correlation between two Series. 
        Series.shift : Shift index by desired number of periods. 
        DataFrame.corr : Compute pairwise correlation of columns. 
        DataFrame.corrwith : Compute pairwise correlation between rows or 
            columns of two DataFrame objects. 
 
        Notes 
        ----- 
        If the Pearson correlation is not well defined return 'NaN'. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; s = pd.Series([0.25, 0.5, 0.2, -0.05]) 
        &gt;&gt;&gt; s.autocorr()  # doctest: +ELLIPSIS 
        0.10355... 
        &gt;&gt;&gt; s.autocorr(lag=2)  # doctest: +ELLIPSIS 
        -0.99999... 
 
        If the Pearson correlation is not well defined, then 'NaN' is returned. 
 
        &gt;&gt;&gt; s = pd.Series([1, 0, 0, 0]) 
        &gt;&gt;&gt; s.autocorr() 
        nan 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">corr</span><span class="s3">(</span><span class="s1">cast</span><span class="s3">(</span><span class="s1">Series</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">shift</span><span class="s3">(</span><span class="s1">lag</span><span class="s3">)))</span>

    <span class="s2">def </span><span class="s1">dot</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">: </span><span class="s1">AnyArrayLike</span><span class="s3">) </span><span class="s1">-&gt; Series </span><span class="s3">| </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndarray</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Compute the dot product between the Series and the columns of other. 
 
        This method computes the dot product between the Series and another 
        one, or the Series and each columns of a DataFrame, or the Series and 
        each columns of an array. 
 
        It can also be called using `self @ other`. 
 
        Parameters 
        ---------- 
        other : Series, DataFrame or array-like 
            The other object to compute the dot product with its columns. 
 
        Returns 
        ------- 
        scalar, Series or numpy.ndarray 
            Return the dot product of the Series and other if other is a 
            Series, the Series of the dot product of Series and each rows of 
            other if other is a DataFrame or a numpy.ndarray between the Series 
            and each columns of the numpy array. 
 
        See Also 
        -------- 
        DataFrame.dot: Compute the matrix product with the DataFrame. 
        Series.mul: Multiplication of series and other, element-wise. 
 
        Notes 
        ----- 
        The Series and other has to share the same index if other is a Series 
        or a DataFrame. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; s = pd.Series([0, 1, 2, 3]) 
        &gt;&gt;&gt; other = pd.Series([-1, 2, -3, 4]) 
        &gt;&gt;&gt; s.dot(other) 
        8 
        &gt;&gt;&gt; s @ other 
        8 
        &gt;&gt;&gt; df = pd.DataFrame([[0, 1], [-2, 3], [4, -5], [6, 7]]) 
        &gt;&gt;&gt; s.dot(df) 
        0    24 
        1    14 
        dtype: int64 
        &gt;&gt;&gt; arr = np.array([[0, 1], [-2, 3], [4, -5], [6, 7]]) 
        &gt;&gt;&gt; s.dot(arr) 
        array([24, 14]) 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">other</span><span class="s3">, (</span><span class="s1">Series</span><span class="s3">, </span><span class="s1">ABCDataFrame</span><span class="s3">)):</span>
            <span class="s1">common </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">index</span><span class="s3">.</span><span class="s1">union</span><span class="s3">(</span><span class="s1">other</span><span class="s3">.</span><span class="s1">index</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">common</span><span class="s3">) &gt; </span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">index</span><span class="s3">) </span><span class="s2">or </span><span class="s1">len</span><span class="s3">(</span><span class="s1">common</span><span class="s3">) &gt; </span><span class="s1">len</span><span class="s3">(</span><span class="s1">other</span><span class="s3">.</span><span class="s1">index</span><span class="s3">):</span>
                <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;matrices are not aligned&quot;</span><span class="s3">)</span>

            <span class="s1">left </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">reindex</span><span class="s3">(</span><span class="s1">index</span><span class="s3">=</span><span class="s1">common</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
            <span class="s1">right </span><span class="s3">= </span><span class="s1">other</span><span class="s3">.</span><span class="s1">reindex</span><span class="s3">(</span><span class="s1">index</span><span class="s3">=</span><span class="s1">common</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
            <span class="s1">lvals </span><span class="s3">= </span><span class="s1">left</span><span class="s3">.</span><span class="s1">values</span>
            <span class="s1">rvals </span><span class="s3">= </span><span class="s1">right</span><span class="s3">.</span><span class="s1">values</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">lvals </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">values</span>
            <span class="s1">rvals </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">other</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">lvals</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] != </span><span class="s1">rvals</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]:</span>
                <span class="s2">raise </span><span class="s1">Exception</span><span class="s3">(</span>
                    <span class="s4">f&quot;Dot product shape mismatch, </span><span class="s2">{</span><span class="s1">lvals</span><span class="s3">.</span><span class="s1">shape</span><span class="s2">} </span><span class="s4">vs </span><span class="s2">{</span><span class="s1">rvals</span><span class="s3">.</span><span class="s1">shape</span><span class="s2">}</span><span class="s4">&quot;</span>
                <span class="s3">)</span>

        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">other</span><span class="s3">, </span><span class="s1">ABCDataFrame</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_constructor</span><span class="s3">(</span>
                <span class="s1">np</span><span class="s3">.</span><span class="s1">dot</span><span class="s3">(</span><span class="s1">lvals</span><span class="s3">, </span><span class="s1">rvals</span><span class="s3">), </span><span class="s1">index</span><span class="s3">=</span><span class="s1">other</span><span class="s3">.</span><span class="s1">columns</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">False</span>
            <span class="s3">).</span><span class="s1">__finalize__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">method</span><span class="s3">=</span><span class="s4">&quot;dot&quot;</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">other</span><span class="s3">, </span><span class="s1">Series</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">dot</span><span class="s3">(</span><span class="s1">lvals</span><span class="s3">, </span><span class="s1">rvals</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">rvals</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndarray</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">dot</span><span class="s3">(</span><span class="s1">lvals</span><span class="s3">, </span><span class="s1">rvals</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:  </span><span class="s6"># pragma: no cover</span>
            <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s4">f&quot;unsupported type: </span><span class="s2">{</span><span class="s1">type</span><span class="s3">(</span><span class="s1">other</span><span class="s3">)</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__matmul__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Matrix multiplication using binary `@` operator. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">dot</span><span class="s3">(</span><span class="s1">other</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__rmatmul__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Matrix multiplication using binary `@` operator. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">dot</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">transpose</span><span class="s3">(</span><span class="s1">other</span><span class="s3">))</span>

    <span class="s3">@</span><span class="s1">doc</span><span class="s3">(</span><span class="s1">base</span><span class="s3">.</span><span class="s1">IndexOpsMixin</span><span class="s3">.</span><span class="s1">searchsorted</span><span class="s3">, </span><span class="s1">klass</span><span class="s3">=</span><span class="s4">&quot;Series&quot;</span><span class="s3">)</span>
    <span class="s6"># Signature of &quot;searchsorted&quot; incompatible with supertype &quot;IndexOpsMixin&quot;</span>
    <span class="s2">def </span><span class="s1">searchsorted</span><span class="s3">(  </span><span class="s6"># type: ignore[override]</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">value</span><span class="s3">: </span><span class="s1">NumpyValueArrayLike </span><span class="s3">| </span><span class="s1">ExtensionArray</span><span class="s3">,</span>
        <span class="s1">side</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s4">&quot;left&quot;</span><span class="s3">, </span><span class="s4">&quot;right&quot;</span><span class="s3">] = </span><span class="s4">&quot;left&quot;</span><span class="s3">,</span>
        <span class="s1">sorter</span><span class="s3">: </span><span class="s1">NumpySorter </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">-&gt; npt</span><span class="s3">.</span><span class="s1">NDArray</span><span class="s3">[</span><span class="s1">np</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">] | </span><span class="s1">np</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">base</span><span class="s3">.</span><span class="s1">IndexOpsMixin</span><span class="s3">.</span><span class="s1">searchsorted</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">side</span><span class="s3">=</span><span class="s1">side</span><span class="s3">, </span><span class="s1">sorter</span><span class="s3">=</span><span class="s1">sorter</span><span class="s3">)</span>

    <span class="s6"># -------------------------------------------------------------------</span>
    <span class="s6"># Combination</span>

    <span class="s2">def </span><span class="s1">_append</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">to_append</span><span class="s3">, </span><span class="s1">ignore_index</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span><span class="s3">, </span><span class="s1">verify_integrity</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span>
    <span class="s3">):</span>
        <span class="s2">from </span><span class="s1">pandas</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">.</span><span class="s1">concat </span><span class="s2">import </span><span class="s1">concat</span>

        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">to_append</span><span class="s3">, (</span><span class="s1">list</span><span class="s3">, </span><span class="s1">tuple</span><span class="s3">)):</span>
            <span class="s1">to_concat </span><span class="s3">= [</span><span class="s1">self</span><span class="s3">]</span>
            <span class="s1">to_concat</span><span class="s3">.</span><span class="s1">extend</span><span class="s3">(</span><span class="s1">to_append</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">to_concat </span><span class="s3">= [</span><span class="s1">self</span><span class="s3">, </span><span class="s1">to_append</span><span class="s3">]</span>
        <span class="s2">if </span><span class="s1">any</span><span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, (</span><span class="s1">ABCDataFrame</span><span class="s3">,)) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">to_concat</span><span class="s3">[</span><span class="s5">1</span><span class="s3">:]):</span>
            <span class="s1">msg </span><span class="s3">= </span><span class="s4">&quot;to_append should be a Series or list/tuple of Series, got DataFrame&quot;</span>
            <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">concat</span><span class="s3">(</span>
            <span class="s1">to_concat</span><span class="s3">, </span><span class="s1">ignore_index</span><span class="s3">=</span><span class="s1">ignore_index</span><span class="s3">, </span><span class="s1">verify_integrity</span><span class="s3">=</span><span class="s1">verify_integrity</span>
        <span class="s3">)</span>

    <span class="s3">@</span><span class="s1">doc</span><span class="s3">(</span>
        <span class="s1">_shared_docs</span><span class="s3">[</span><span class="s4">&quot;compare&quot;</span><span class="s3">],</span>
        <span class="s1">dedent</span><span class="s3">(</span>
            <span class="s4">&quot;&quot;&quot; 
        Returns 
        ------- 
        Series or DataFrame 
            If axis is 0 or 'index' the result will be a Series. 
            The resulting index will be a MultiIndex with 'self' and 'other' 
            stacked alternately at the inner level. 
 
            If axis is 1 or 'columns' the result will be a DataFrame. 
            It will have two columns namely 'self' and 'other'. 
 
        See Also 
        -------- 
        DataFrame.compare : Compare with another DataFrame and show differences. 
 
        Notes 
        ----- 
        Matching NaNs will not appear as a difference. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; s1 = pd.Series([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]) 
        &gt;&gt;&gt; s2 = pd.Series([&quot;a&quot;, &quot;a&quot;, &quot;c&quot;, &quot;b&quot;, &quot;e&quot;]) 
 
        Align the differences on columns 
 
        &gt;&gt;&gt; s1.compare(s2) 
          self other 
        1    b     a 
        3    d     b 
 
        Stack the differences on indices 
 
        &gt;&gt;&gt; s1.compare(s2, align_axis=0) 
        1  self     b 
           other    a 
        3  self     d 
           other    b 
        dtype: object 
 
        Keep all original rows 
 
        &gt;&gt;&gt; s1.compare(s2, keep_shape=True) 
          self other 
        0  NaN   NaN 
        1    b     a 
        2  NaN   NaN 
        3    d     b 
        4  NaN   NaN 
 
        Keep all original rows and also all original values 
 
        &gt;&gt;&gt; s1.compare(s2, keep_shape=True, keep_equal=True) 
          self other 
        0    a     a 
        1    b     a 
        2    c     c 
        3    d     b 
        4    e     e 
        &quot;&quot;&quot;</span>
        <span class="s3">),</span>
        <span class="s1">klass</span><span class="s3">=</span><span class="s1">_shared_doc_kwargs</span><span class="s3">[</span><span class="s4">&quot;klass&quot;</span><span class="s3">],</span>
    <span class="s3">)</span>
    <span class="s2">def </span><span class="s1">compare</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">other</span><span class="s3">: </span><span class="s1">Series</span><span class="s3">,</span>
        <span class="s1">align_axis</span><span class="s3">: </span><span class="s1">Axis </span><span class="s3">= </span><span class="s5">1</span><span class="s3">,</span>
        <span class="s1">keep_shape</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span><span class="s3">,</span>
        <span class="s1">keep_equal</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span><span class="s3">,</span>
        <span class="s1">result_names</span><span class="s3">: </span><span class="s1">Suffixes </span><span class="s3">= (</span><span class="s4">&quot;self&quot;</span><span class="s3">, </span><span class="s4">&quot;other&quot;</span><span class="s3">),</span>
    <span class="s3">) </span><span class="s1">-&gt; DataFrame </span><span class="s3">| </span><span class="s1">Series</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">super</span><span class="s3">().</span><span class="s1">compare</span><span class="s3">(</span>
            <span class="s1">other</span><span class="s3">=</span><span class="s1">other</span><span class="s3">,</span>
            <span class="s1">align_axis</span><span class="s3">=</span><span class="s1">align_axis</span><span class="s3">,</span>
            <span class="s1">keep_shape</span><span class="s3">=</span><span class="s1">keep_shape</span><span class="s3">,</span>
            <span class="s1">keep_equal</span><span class="s3">=</span><span class="s1">keep_equal</span><span class="s3">,</span>
            <span class="s1">result_names</span><span class="s3">=</span><span class="s1">result_names</span><span class="s3">,</span>
        <span class="s3">)</span>

    <span class="s2">def </span><span class="s1">combine</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">other</span><span class="s3">: </span><span class="s1">Series </span><span class="s3">| </span><span class="s1">Hashable</span><span class="s3">,</span>
        <span class="s1">func</span><span class="s3">: </span><span class="s1">Callable</span><span class="s3">[[</span><span class="s1">Hashable</span><span class="s3">, </span><span class="s1">Hashable</span><span class="s3">], </span><span class="s1">Hashable</span><span class="s3">],</span>
        <span class="s1">fill_value</span><span class="s3">: </span><span class="s1">Hashable </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">-&gt; Series</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Combine the Series with a Series or scalar according to `func`. 
 
        Combine the Series and `other` using `func` to perform elementwise 
        selection for combined Series. 
        `fill_value` is assumed when value is missing at some index 
        from one of the two objects being combined. 
 
        Parameters 
        ---------- 
        other : Series or scalar 
            The value(s) to be combined with the `Series`. 
        func : function 
            Function that takes two scalars as inputs and returns an element. 
        fill_value : scalar, optional 
            The value to assume when an index is missing from 
            one Series or the other. The default specifies to use the 
            appropriate NaN value for the underlying dtype of the Series. 
 
        Returns 
        ------- 
        Series 
            The result of combining the Series with the other object. 
 
        See Also 
        -------- 
        Series.combine_first : Combine Series values, choosing the calling 
            Series' values first. 
 
        Examples 
        -------- 
        Consider 2 Datasets ``s1`` and ``s2`` containing 
        highest clocked speeds of different birds. 
 
        &gt;&gt;&gt; s1 = pd.Series({'falcon': 330.0, 'eagle': 160.0}) 
        &gt;&gt;&gt; s1 
        falcon    330.0 
        eagle     160.0 
        dtype: float64 
        &gt;&gt;&gt; s2 = pd.Series({'falcon': 345.0, 'eagle': 200.0, 'duck': 30.0}) 
        &gt;&gt;&gt; s2 
        falcon    345.0 
        eagle     200.0 
        duck       30.0 
        dtype: float64 
 
        Now, to combine the two datasets and view the highest speeds 
        of the birds across the two datasets 
 
        &gt;&gt;&gt; s1.combine(s2, max) 
        duck        NaN 
        eagle     200.0 
        falcon    345.0 
        dtype: float64 
 
        In the previous example, the resulting value for duck is missing, 
        because the maximum of a NaN and a float is a NaN. 
        So, in the example, we set ``fill_value=0``, 
        so the maximum value returned will be the value from some dataset. 
 
        &gt;&gt;&gt; s1.combine(s2, max, fill_value=0) 
        duck       30.0 
        eagle     200.0 
        falcon    345.0 
        dtype: float64 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">fill_value </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s1">fill_value </span><span class="s3">= </span><span class="s1">na_value_for_dtype</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">compat</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">other</span><span class="s3">, </span><span class="s1">Series</span><span class="s3">):</span>
            <span class="s6"># If other is a Series, result is based on union of Series,</span>
            <span class="s6"># so do this element by element</span>
            <span class="s1">new_index </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">index</span><span class="s3">.</span><span class="s1">union</span><span class="s3">(</span><span class="s1">other</span><span class="s3">.</span><span class="s1">index</span><span class="s3">)</span>
            <span class="s1">new_name </span><span class="s3">= </span><span class="s1">ops</span><span class="s3">.</span><span class="s1">get_op_result_name</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">)</span>
            <span class="s1">new_values </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">new_index</span><span class="s3">), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">object</span><span class="s3">)</span>
            <span class="s2">with </span><span class="s1">np</span><span class="s3">.</span><span class="s1">errstate</span><span class="s3">(</span><span class="s1">all</span><span class="s3">=</span><span class="s4">&quot;ignore&quot;</span><span class="s3">):</span>
                <span class="s2">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">idx </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">new_index</span><span class="s3">):</span>
                    <span class="s1">lv </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">idx</span><span class="s3">, </span><span class="s1">fill_value</span><span class="s3">)</span>
                    <span class="s1">rv </span><span class="s3">= </span><span class="s1">other</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">idx</span><span class="s3">, </span><span class="s1">fill_value</span><span class="s3">)</span>
                    <span class="s1">new_values</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">func</span><span class="s3">(</span><span class="s1">lv</span><span class="s3">, </span><span class="s1">rv</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s6"># Assume that other is a scalar, so apply the function for</span>
            <span class="s6"># each element in the Series</span>
            <span class="s1">new_index </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">index</span>
            <span class="s1">new_values </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">new_index</span><span class="s3">), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">object</span><span class="s3">)</span>
            <span class="s2">with </span><span class="s1">np</span><span class="s3">.</span><span class="s1">errstate</span><span class="s3">(</span><span class="s1">all</span><span class="s3">=</span><span class="s4">&quot;ignore&quot;</span><span class="s3">):</span>
                <span class="s1">new_values</span><span class="s3">[:] = [</span><span class="s1">func</span><span class="s3">(</span><span class="s1">lv</span><span class="s3">, </span><span class="s1">other</span><span class="s3">) </span><span class="s2">for </span><span class="s1">lv </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_values</span><span class="s3">]</span>
            <span class="s1">new_name </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">name</span>

        <span class="s6"># try_float=False is to match agg_series</span>
        <span class="s1">npvalues </span><span class="s3">= </span><span class="s1">lib</span><span class="s3">.</span><span class="s1">maybe_convert_objects</span><span class="s3">(</span><span class="s1">new_values</span><span class="s3">, </span><span class="s1">try_float</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
        <span class="s6"># same_dtype here is a kludge to avoid casting e.g. [True, False] to</span>
        <span class="s6">#  [&quot;True&quot;, &quot;False&quot;]</span>
        <span class="s1">same_dtype </span><span class="s3">= </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, (</span><span class="s1">StringDtype</span><span class="s3">, </span><span class="s1">CategoricalDtype</span><span class="s3">))</span>
        <span class="s1">res_values </span><span class="s3">= </span><span class="s1">maybe_cast_pointwise_result</span><span class="s3">(</span>
            <span class="s1">npvalues</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">same_dtype</span><span class="s3">=</span><span class="s1">same_dtype</span>
        <span class="s3">)</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_constructor</span><span class="s3">(</span><span class="s1">res_values</span><span class="s3">, </span><span class="s1">index</span><span class="s3">=</span><span class="s1">new_index</span><span class="s3">, </span><span class="s1">name</span><span class="s3">=</span><span class="s1">new_name</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">combine_first</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">) </span><span class="s1">-&gt; Series</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Update null elements with value in the same location in 'other'. 
 
        Combine two Series objects by filling null values in one Series with 
        non-null values from the other Series. Result index will be the union 
        of the two indexes. 
 
        Parameters 
        ---------- 
        other : Series 
            The value(s) to be used for filling null values. 
 
        Returns 
        ------- 
        Series 
            The result of combining the provided Series with the other object. 
 
        See Also 
        -------- 
        Series.combine : Perform element-wise operation on two Series 
            using a given function. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; s1 = pd.Series([1, np.nan]) 
        &gt;&gt;&gt; s2 = pd.Series([3, 4, 5]) 
        &gt;&gt;&gt; s1.combine_first(s2) 
        0    1.0 
        1    4.0 
        2    5.0 
        dtype: float64 
 
        Null values still persist if the location of that null value 
        does not exist in `other` 
 
        &gt;&gt;&gt; s1 = pd.Series({'falcon': np.nan, 'eagle': 160.0}) 
        &gt;&gt;&gt; s2 = pd.Series({'eagle': 200.0, 'duck': 30.0}) 
        &gt;&gt;&gt; s1.combine_first(s2) 
        duck       30.0 
        eagle     160.0 
        falcon      NaN 
        dtype: float64 
        &quot;&quot;&quot;</span>
        <span class="s2">from </span><span class="s1">pandas</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">.</span><span class="s1">concat </span><span class="s2">import </span><span class="s1">concat</span>

        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">dtype </span><span class="s3">== </span><span class="s1">other</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">index</span><span class="s3">.</span><span class="s1">equals</span><span class="s3">(</span><span class="s1">other</span><span class="s3">.</span><span class="s1">index</span><span class="s3">):</span>
                <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">mask</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">isna</span><span class="s3">(), </span><span class="s1">other</span><span class="s3">)</span>
            <span class="s2">elif </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_can_hold_na </span><span class="s2">and not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">SparseDtype</span><span class="s3">):</span>
                <span class="s1">this</span><span class="s3">, </span><span class="s1">other </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">align</span><span class="s3">(</span><span class="s1">other</span><span class="s3">, </span><span class="s1">join</span><span class="s3">=</span><span class="s4">&quot;outer&quot;</span><span class="s3">)</span>
                <span class="s2">return </span><span class="s1">this</span><span class="s3">.</span><span class="s1">mask</span><span class="s3">(</span><span class="s1">this</span><span class="s3">.</span><span class="s1">isna</span><span class="s3">(), </span><span class="s1">other</span><span class="s3">)</span>

        <span class="s1">new_index </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">index</span><span class="s3">.</span><span class="s1">union</span><span class="s3">(</span><span class="s1">other</span><span class="s3">.</span><span class="s1">index</span><span class="s3">)</span>

        <span class="s1">this </span><span class="s3">= </span><span class="s1">self</span>
        <span class="s6"># identify the index subset to keep for each series</span>
        <span class="s1">keep_other </span><span class="s3">= </span><span class="s1">other</span><span class="s3">.</span><span class="s1">index</span><span class="s3">.</span><span class="s1">difference</span><span class="s3">(</span><span class="s1">this</span><span class="s3">.</span><span class="s1">index</span><span class="s3">[</span><span class="s1">notna</span><span class="s3">(</span><span class="s1">this</span><span class="s3">)])</span>
        <span class="s1">keep_this </span><span class="s3">= </span><span class="s1">this</span><span class="s3">.</span><span class="s1">index</span><span class="s3">.</span><span class="s1">difference</span><span class="s3">(</span><span class="s1">keep_other</span><span class="s3">)</span>

        <span class="s1">this </span><span class="s3">= </span><span class="s1">this</span><span class="s3">.</span><span class="s1">reindex</span><span class="s3">(</span><span class="s1">keep_this</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
        <span class="s1">other </span><span class="s3">= </span><span class="s1">other</span><span class="s3">.</span><span class="s1">reindex</span><span class="s3">(</span><span class="s1">keep_other</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">this</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">kind </span><span class="s3">== </span><span class="s4">&quot;M&quot; </span><span class="s2">and </span><span class="s1">other</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">kind </span><span class="s3">!= </span><span class="s4">&quot;M&quot;</span><span class="s3">:</span>
            <span class="s1">other </span><span class="s3">= </span><span class="s1">to_datetime</span><span class="s3">(</span><span class="s1">other</span><span class="s3">)</span>
        <span class="s1">combined </span><span class="s3">= </span><span class="s1">concat</span><span class="s3">([</span><span class="s1">this</span><span class="s3">, </span><span class="s1">other</span><span class="s3">])</span>
        <span class="s1">combined </span><span class="s3">= </span><span class="s1">combined</span><span class="s3">.</span><span class="s1">reindex</span><span class="s3">(</span><span class="s1">new_index</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">combined</span><span class="s3">.</span><span class="s1">__finalize__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">method</span><span class="s3">=</span><span class="s4">&quot;combine_first&quot;</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">update</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">: </span><span class="s1">Series </span><span class="s3">| </span><span class="s1">Sequence </span><span class="s3">| </span><span class="s1">Mapping</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Modify Series in place using values from passed Series. 
 
        Uses non-NA values from passed Series to make updates. Aligns 
        on index. 
 
        Parameters 
        ---------- 
        other : Series, or object coercible into Series 
 
        Examples 
        -------- 
        &gt;&gt;&gt; s = pd.Series([1, 2, 3]) 
        &gt;&gt;&gt; s.update(pd.Series([4, 5, 6])) 
        &gt;&gt;&gt; s 
        0    4 
        1    5 
        2    6 
        dtype: int64 
 
        &gt;&gt;&gt; s = pd.Series(['a', 'b', 'c']) 
        &gt;&gt;&gt; s.update(pd.Series(['d', 'e'], index=[0, 2])) 
        &gt;&gt;&gt; s 
        0    d 
        1    b 
        2    e 
        dtype: object 
 
        &gt;&gt;&gt; s = pd.Series([1, 2, 3]) 
        &gt;&gt;&gt; s.update(pd.Series([4, 5, 6, 7, 8])) 
        &gt;&gt;&gt; s 
        0    4 
        1    5 
        2    6 
        dtype: int64 
 
        If ``other`` contains NaNs the corresponding values are not updated 
        in the original Series. 
 
        &gt;&gt;&gt; s = pd.Series([1, 2, 3]) 
        &gt;&gt;&gt; s.update(pd.Series([4, np.nan, 6])) 
        &gt;&gt;&gt; s 
        0    4 
        1    2 
        2    6 
        dtype: int64 
 
        ``other`` can also be a non-Series object type 
        that is coercible into a Series 
 
        &gt;&gt;&gt; s = pd.Series([1, 2, 3]) 
        &gt;&gt;&gt; s.update([4, np.nan, 6]) 
        &gt;&gt;&gt; s 
        0    4 
        1    2 
        2    6 
        dtype: int64 
 
        &gt;&gt;&gt; s = pd.Series([1, 2, 3]) 
        &gt;&gt;&gt; s.update({1: 9}) 
        &gt;&gt;&gt; s 
        0    1 
        1    9 
        2    3 
        dtype: int64 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">PYPY </span><span class="s2">and </span><span class="s1">using_copy_on_write</span><span class="s3">():</span>
            <span class="s2">if </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">getrefcount</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) &lt;= </span><span class="s1">REF_COUNT</span><span class="s3">:</span>
                <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span>
                    <span class="s1">_chained_assignment_method_msg</span><span class="s3">,</span>
                    <span class="s1">ChainedAssignmentError</span><span class="s3">,</span>
                    <span class="s1">stacklevel</span><span class="s3">=</span><span class="s5">2</span><span class="s3">,</span>
                <span class="s3">)</span>
        <span class="s2">elif not </span><span class="s1">PYPY </span><span class="s2">and not </span><span class="s1">using_copy_on_write</span><span class="s3">() </span><span class="s2">and </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_is_view_after_cow_rules</span><span class="s3">():</span>
            <span class="s1">ctr </span><span class="s3">= </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">getrefcount</span><span class="s3">(</span><span class="s1">self</span><span class="s3">)</span>
            <span class="s1">ref_count </span><span class="s3">= </span><span class="s1">REF_COUNT</span>
            <span class="s2">if </span><span class="s1">_check_cacher</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
                <span class="s6"># see https://github.com/pandas-dev/pandas/pull/56060#discussion_r1399245221</span>
                <span class="s1">ref_count </span><span class="s3">+= </span><span class="s5">1</span>
            <span class="s2">if </span><span class="s1">ctr </span><span class="s3">&lt;= </span><span class="s1">ref_count</span><span class="s3">:</span>
                <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span>
                    <span class="s1">_chained_assignment_warning_method_msg</span><span class="s3">,</span>
                    <span class="s1">FutureWarning</span><span class="s3">,</span>
                    <span class="s1">stacklevel</span><span class="s3">=</span><span class="s5">2</span><span class="s3">,</span>
                <span class="s3">)</span>

        <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">other</span><span class="s3">, </span><span class="s1">Series</span><span class="s3">):</span>
            <span class="s1">other </span><span class="s3">= </span><span class="s1">Series</span><span class="s3">(</span><span class="s1">other</span><span class="s3">)</span>

        <span class="s1">other </span><span class="s3">= </span><span class="s1">other</span><span class="s3">.</span><span class="s1">reindex_like</span><span class="s3">(</span><span class="s1">self</span><span class="s3">)</span>
        <span class="s1">mask </span><span class="s3">= </span><span class="s1">notna</span><span class="s3">(</span><span class="s1">other</span><span class="s3">)</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">_mgr </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_mgr</span><span class="s3">.</span><span class="s1">putmask</span><span class="s3">(</span><span class="s1">mask</span><span class="s3">=</span><span class="s1">mask</span><span class="s3">, </span><span class="s1">new</span><span class="s3">=</span><span class="s1">other</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_maybe_update_cacher</span><span class="s3">()</span>

    <span class="s6"># ----------------------------------------------------------------------</span>
    <span class="s6"># Reindexing, sorting</span>

    <span class="s3">@</span><span class="s1">overload</span>
    <span class="s2">def </span><span class="s1">sort_values</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s3">*,</span>
        <span class="s1">axis</span><span class="s3">: </span><span class="s1">Axis </span><span class="s3">= ...,</span>
        <span class="s1">ascending</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s1">Sequence</span><span class="s3">[</span><span class="s1">bool</span><span class="s3">] = ...,</span>
        <span class="s1">inplace</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s2">False</span><span class="s3">] = ...,</span>
        <span class="s1">kind</span><span class="s3">: </span><span class="s1">SortKind </span><span class="s3">= ...,</span>
        <span class="s1">na_position</span><span class="s3">: </span><span class="s1">NaPosition </span><span class="s3">= ...,</span>
        <span class="s1">ignore_index</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= ...,</span>
        <span class="s1">key</span><span class="s3">: </span><span class="s1">ValueKeyFunc </span><span class="s3">= ...,</span>
    <span class="s3">) </span><span class="s1">-&gt; Series</span><span class="s3">:</span>
        <span class="s3">...</span>

    <span class="s3">@</span><span class="s1">overload</span>
    <span class="s2">def </span><span class="s1">sort_values</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s3">*,</span>
        <span class="s1">axis</span><span class="s3">: </span><span class="s1">Axis </span><span class="s3">= ...,</span>
        <span class="s1">ascending</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s1">Sequence</span><span class="s3">[</span><span class="s1">bool</span><span class="s3">] = ...,</span>
        <span class="s1">inplace</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s2">True</span><span class="s3">],</span>
        <span class="s1">kind</span><span class="s3">: </span><span class="s1">SortKind </span><span class="s3">= ...,</span>
        <span class="s1">na_position</span><span class="s3">: </span><span class="s1">NaPosition </span><span class="s3">= ...,</span>
        <span class="s1">ignore_index</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= ...,</span>
        <span class="s1">key</span><span class="s3">: </span><span class="s1">ValueKeyFunc </span><span class="s3">= ...,</span>
    <span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s3">...</span>

    <span class="s3">@</span><span class="s1">overload</span>
    <span class="s2">def </span><span class="s1">sort_values</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s3">*,</span>
        <span class="s1">axis</span><span class="s3">: </span><span class="s1">Axis </span><span class="s3">= ...,</span>
        <span class="s1">ascending</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s1">Sequence</span><span class="s3">[</span><span class="s1">bool</span><span class="s3">] = ...,</span>
        <span class="s1">inplace</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= ...,</span>
        <span class="s1">kind</span><span class="s3">: </span><span class="s1">SortKind </span><span class="s3">= ...,</span>
        <span class="s1">na_position</span><span class="s3">: </span><span class="s1">NaPosition </span><span class="s3">= ...,</span>
        <span class="s1">ignore_index</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= ...,</span>
        <span class="s1">key</span><span class="s3">: </span><span class="s1">ValueKeyFunc </span><span class="s3">= ...,</span>
    <span class="s3">) </span><span class="s1">-&gt; Series </span><span class="s3">| </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s3">...</span>

    <span class="s2">def </span><span class="s1">sort_values</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s3">*,</span>
        <span class="s1">axis</span><span class="s3">: </span><span class="s1">Axis </span><span class="s3">= </span><span class="s5">0</span><span class="s3">,</span>
        <span class="s1">ascending</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s1">Sequence</span><span class="s3">[</span><span class="s1">bool</span><span class="s3">] = </span><span class="s2">True</span><span class="s3">,</span>
        <span class="s1">inplace</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span><span class="s3">,</span>
        <span class="s1">kind</span><span class="s3">: </span><span class="s1">SortKind </span><span class="s3">= </span><span class="s4">&quot;quicksort&quot;</span><span class="s3">,</span>
        <span class="s1">na_position</span><span class="s3">: </span><span class="s1">NaPosition </span><span class="s3">= </span><span class="s4">&quot;last&quot;</span><span class="s3">,</span>
        <span class="s1">ignore_index</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span><span class="s3">,</span>
        <span class="s1">key</span><span class="s3">: </span><span class="s1">ValueKeyFunc </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">-&gt; Series </span><span class="s3">| </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Sort by the values. 
 
        Sort a Series in ascending or descending order by some 
        criterion. 
 
        Parameters 
        ---------- 
        axis : {0 or 'index'} 
            Unused. Parameter needed for compatibility with DataFrame. 
        ascending : bool or list of bools, default True 
            If True, sort values in ascending order, otherwise descending. 
        inplace : bool, default False 
            If True, perform operation in-place. 
        kind : {'quicksort', 'mergesort', 'heapsort', 'stable'}, default 'quicksort' 
            Choice of sorting algorithm. See also :func:`numpy.sort` for more 
            information. 'mergesort' and 'stable' are the only stable  algorithms. 
        na_position : {'first' or 'last'}, default 'last' 
            Argument 'first' puts NaNs at the beginning, 'last' puts NaNs at 
            the end. 
        ignore_index : bool, default False 
            If True, the resulting axis will be labeled 0, 1, …, n - 1. 
        key : callable, optional 
            If not None, apply the key function to the series values 
            before sorting. This is similar to the `key` argument in the 
            builtin :meth:`sorted` function, with the notable difference that 
            this `key` function should be *vectorized*. It should expect a 
            ``Series`` and return an array-like. 
 
        Returns 
        ------- 
        Series or None 
            Series ordered by values or None if ``inplace=True``. 
 
        See Also 
        -------- 
        Series.sort_index : Sort by the Series indices. 
        DataFrame.sort_values : Sort DataFrame by the values along either axis. 
        DataFrame.sort_index : Sort DataFrame by indices. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; s = pd.Series([np.nan, 1, 3, 10, 5]) 
        &gt;&gt;&gt; s 
        0     NaN 
        1     1.0 
        2     3.0 
        3     10.0 
        4     5.0 
        dtype: float64 
 
        Sort values ascending order (default behaviour) 
 
        &gt;&gt;&gt; s.sort_values(ascending=True) 
        1     1.0 
        2     3.0 
        4     5.0 
        3    10.0 
        0     NaN 
        dtype: float64 
 
        Sort values descending order 
 
        &gt;&gt;&gt; s.sort_values(ascending=False) 
        3    10.0 
        4     5.0 
        2     3.0 
        1     1.0 
        0     NaN 
        dtype: float64 
 
        Sort values putting NAs first 
 
        &gt;&gt;&gt; s.sort_values(na_position='first') 
        0     NaN 
        1     1.0 
        2     3.0 
        4     5.0 
        3    10.0 
        dtype: float64 
 
        Sort a series of strings 
 
        &gt;&gt;&gt; s = pd.Series(['z', 'b', 'd', 'a', 'c']) 
        &gt;&gt;&gt; s 
        0    z 
        1    b 
        2    d 
        3    a 
        4    c 
        dtype: object 
 
        &gt;&gt;&gt; s.sort_values() 
        3    a 
        1    b 
        4    c 
        2    d 
        0    z 
        dtype: object 
 
        Sort using a key function. Your `key` function will be 
        given the ``Series`` of values and should return an array-like. 
 
        &gt;&gt;&gt; s = pd.Series(['a', 'B', 'c', 'D', 'e']) 
        &gt;&gt;&gt; s.sort_values() 
        1    B 
        3    D 
        0    a 
        2    c 
        4    e 
        dtype: object 
        &gt;&gt;&gt; s.sort_values(key=lambda x: x.str.lower()) 
        0    a 
        1    B 
        2    c 
        3    D 
        4    e 
        dtype: object 
 
        NumPy ufuncs work well here. For example, we can 
        sort by the ``sin`` of the value 
 
        &gt;&gt;&gt; s = pd.Series([-4, -2, 0, 2, 4]) 
        &gt;&gt;&gt; s.sort_values(key=np.sin) 
        1   -2 
        4    4 
        2    0 
        0   -4 
        3    2 
        dtype: int64 
 
        More complicated user-defined functions can be used, 
        as long as they expect a Series and return an array-like 
 
        &gt;&gt;&gt; s.sort_values(key=lambda x: (np.tan(x.cumsum()))) 
        0   -4 
        3    2 
        4    4 
        1   -2 
        2    0 
        dtype: int64 
        &quot;&quot;&quot;</span>
        <span class="s1">inplace </span><span class="s3">= </span><span class="s1">validate_bool_kwarg</span><span class="s3">(</span><span class="s1">inplace</span><span class="s3">, </span><span class="s4">&quot;inplace&quot;</span><span class="s3">)</span>
        <span class="s6"># Validate the axis parameter</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_get_axis_number</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">)</span>

        <span class="s6"># GH 5856/5853</span>
        <span class="s2">if </span><span class="s1">inplace </span><span class="s2">and </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_is_cached</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span>
                <span class="s4">&quot;This Series is a view of some other array, to &quot;</span>
                <span class="s4">&quot;sort in-place you must create a copy&quot;</span>
            <span class="s3">)</span>

        <span class="s2">if </span><span class="s1">is_list_like</span><span class="s3">(</span><span class="s1">ascending</span><span class="s3">):</span>
            <span class="s1">ascending </span><span class="s3">= </span><span class="s1">cast</span><span class="s3">(</span><span class="s1">Sequence</span><span class="s3">[</span><span class="s1">bool</span><span class="s3">], </span><span class="s1">ascending</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">ascending</span><span class="s3">) != </span><span class="s5">1</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span>
                    <span class="s4">f&quot;Length of ascending (</span><span class="s2">{</span><span class="s1">len</span><span class="s3">(</span><span class="s1">ascending</span><span class="s3">)</span><span class="s2">}</span><span class="s4">) must be 1 for Series&quot;</span>
                <span class="s3">)</span>
            <span class="s1">ascending </span><span class="s3">= </span><span class="s1">ascending</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>

        <span class="s1">ascending </span><span class="s3">= </span><span class="s1">validate_ascending</span><span class="s3">(</span><span class="s1">ascending</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">na_position </span><span class="s2">not in </span><span class="s3">[</span><span class="s4">&quot;first&quot;</span><span class="s3">, </span><span class="s4">&quot;last&quot;</span><span class="s3">]:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">f&quot;invalid na_position: </span><span class="s2">{</span><span class="s1">na_position</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s3">)</span>

        <span class="s6"># GH 35922. Make sorting stable by leveraging nargsort</span>
        <span class="s2">if </span><span class="s1">key</span><span class="s3">:</span>
            <span class="s1">values_to_sort </span><span class="s3">= </span><span class="s1">cast</span><span class="s3">(</span><span class="s1">Series</span><span class="s3">, </span><span class="s1">ensure_key_mapped</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">key</span><span class="s3">)).</span><span class="s1">_values</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">values_to_sort </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_values</span>
        <span class="s1">sorted_index </span><span class="s3">= </span><span class="s1">nargsort</span><span class="s3">(</span><span class="s1">values_to_sort</span><span class="s3">, </span><span class="s1">kind</span><span class="s3">, </span><span class="s1">bool</span><span class="s3">(</span><span class="s1">ascending</span><span class="s3">), </span><span class="s1">na_position</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">is_range_indexer</span><span class="s3">(</span><span class="s1">sorted_index</span><span class="s3">, </span><span class="s1">len</span><span class="s3">(</span><span class="s1">sorted_index</span><span class="s3">)):</span>
            <span class="s2">if </span><span class="s1">inplace</span><span class="s3">:</span>
                <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_update_inplace</span><span class="s3">(</span><span class="s1">self</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">(</span><span class="s1">deep</span><span class="s3">=</span><span class="s2">None</span><span class="s3">)</span>

        <span class="s1">result </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_constructor</span><span class="s3">(</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_values</span><span class="s3">[</span><span class="s1">sorted_index</span><span class="s3">], </span><span class="s1">index</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">index</span><span class="s3">[</span><span class="s1">sorted_index</span><span class="s3">], </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">False</span>
        <span class="s3">)</span>

        <span class="s2">if </span><span class="s1">ignore_index</span><span class="s3">:</span>
            <span class="s1">result</span><span class="s3">.</span><span class="s1">index </span><span class="s3">= </span><span class="s1">default_index</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">sorted_index</span><span class="s3">))</span>

        <span class="s2">if not </span><span class="s1">inplace</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">result</span><span class="s3">.</span><span class="s1">__finalize__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">method</span><span class="s3">=</span><span class="s4">&quot;sort_values&quot;</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_update_inplace</span><span class="s3">(</span><span class="s1">result</span><span class="s3">)</span>
        <span class="s2">return None</span>

    <span class="s3">@</span><span class="s1">overload</span>
    <span class="s2">def </span><span class="s1">sort_index</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s3">*,</span>
        <span class="s1">axis</span><span class="s3">: </span><span class="s1">Axis </span><span class="s3">= ...,</span>
        <span class="s1">level</span><span class="s3">: </span><span class="s1">IndexLabel </span><span class="s3">= ...,</span>
        <span class="s1">ascending</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s1">Sequence</span><span class="s3">[</span><span class="s1">bool</span><span class="s3">] = ...,</span>
        <span class="s1">inplace</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s2">True</span><span class="s3">],</span>
        <span class="s1">kind</span><span class="s3">: </span><span class="s1">SortKind </span><span class="s3">= ...,</span>
        <span class="s1">na_position</span><span class="s3">: </span><span class="s1">NaPosition </span><span class="s3">= ...,</span>
        <span class="s1">sort_remaining</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= ...,</span>
        <span class="s1">ignore_index</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= ...,</span>
        <span class="s1">key</span><span class="s3">: </span><span class="s1">IndexKeyFunc </span><span class="s3">= ...,</span>
    <span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s3">...</span>

    <span class="s3">@</span><span class="s1">overload</span>
    <span class="s2">def </span><span class="s1">sort_index</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s3">*,</span>
        <span class="s1">axis</span><span class="s3">: </span><span class="s1">Axis </span><span class="s3">= ...,</span>
        <span class="s1">level</span><span class="s3">: </span><span class="s1">IndexLabel </span><span class="s3">= ...,</span>
        <span class="s1">ascending</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s1">Sequence</span><span class="s3">[</span><span class="s1">bool</span><span class="s3">] = ...,</span>
        <span class="s1">inplace</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s2">False</span><span class="s3">] = ...,</span>
        <span class="s1">kind</span><span class="s3">: </span><span class="s1">SortKind </span><span class="s3">= ...,</span>
        <span class="s1">na_position</span><span class="s3">: </span><span class="s1">NaPosition </span><span class="s3">= ...,</span>
        <span class="s1">sort_remaining</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= ...,</span>
        <span class="s1">ignore_index</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= ...,</span>
        <span class="s1">key</span><span class="s3">: </span><span class="s1">IndexKeyFunc </span><span class="s3">= ...,</span>
    <span class="s3">) </span><span class="s1">-&gt; Series</span><span class="s3">:</span>
        <span class="s3">...</span>

    <span class="s3">@</span><span class="s1">overload</span>
    <span class="s2">def </span><span class="s1">sort_index</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s3">*,</span>
        <span class="s1">axis</span><span class="s3">: </span><span class="s1">Axis </span><span class="s3">= ...,</span>
        <span class="s1">level</span><span class="s3">: </span><span class="s1">IndexLabel </span><span class="s3">= ...,</span>
        <span class="s1">ascending</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s1">Sequence</span><span class="s3">[</span><span class="s1">bool</span><span class="s3">] = ...,</span>
        <span class="s1">inplace</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= ...,</span>
        <span class="s1">kind</span><span class="s3">: </span><span class="s1">SortKind </span><span class="s3">= ...,</span>
        <span class="s1">na_position</span><span class="s3">: </span><span class="s1">NaPosition </span><span class="s3">= ...,</span>
        <span class="s1">sort_remaining</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= ...,</span>
        <span class="s1">ignore_index</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= ...,</span>
        <span class="s1">key</span><span class="s3">: </span><span class="s1">IndexKeyFunc </span><span class="s3">= ...,</span>
    <span class="s3">) </span><span class="s1">-&gt; Series </span><span class="s3">| </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s3">...</span>

    <span class="s2">def </span><span class="s1">sort_index</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s3">*,</span>
        <span class="s1">axis</span><span class="s3">: </span><span class="s1">Axis </span><span class="s3">= </span><span class="s5">0</span><span class="s3">,</span>
        <span class="s1">level</span><span class="s3">: </span><span class="s1">IndexLabel </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">ascending</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s1">Sequence</span><span class="s3">[</span><span class="s1">bool</span><span class="s3">] = </span><span class="s2">True</span><span class="s3">,</span>
        <span class="s1">inplace</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span><span class="s3">,</span>
        <span class="s1">kind</span><span class="s3">: </span><span class="s1">SortKind </span><span class="s3">= </span><span class="s4">&quot;quicksort&quot;</span><span class="s3">,</span>
        <span class="s1">na_position</span><span class="s3">: </span><span class="s1">NaPosition </span><span class="s3">= </span><span class="s4">&quot;last&quot;</span><span class="s3">,</span>
        <span class="s1">sort_remaining</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">True</span><span class="s3">,</span>
        <span class="s1">ignore_index</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span><span class="s3">,</span>
        <span class="s1">key</span><span class="s3">: </span><span class="s1">IndexKeyFunc </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">-&gt; Series </span><span class="s3">| </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Sort Series by index labels. 
 
        Returns a new Series sorted by label if `inplace` argument is 
        ``False``, otherwise updates the original series and returns None. 
 
        Parameters 
        ---------- 
        axis : {0 or 'index'} 
            Unused. Parameter needed for compatibility with DataFrame. 
        level : int, optional 
            If not None, sort on values in specified index level(s). 
        ascending : bool or list-like of bools, default True 
            Sort ascending vs. descending. When the index is a MultiIndex the 
            sort direction can be controlled for each level individually. 
        inplace : bool, default False 
            If True, perform operation in-place. 
        kind : {'quicksort', 'mergesort', 'heapsort', 'stable'}, default 'quicksort' 
            Choice of sorting algorithm. See also :func:`numpy.sort` for more 
            information. 'mergesort' and 'stable' are the only stable algorithms. For 
            DataFrames, this option is only applied when sorting on a single 
            column or label. 
        na_position : {'first', 'last'}, default 'last' 
            If 'first' puts NaNs at the beginning, 'last' puts NaNs at the end. 
            Not implemented for MultiIndex. 
        sort_remaining : bool, default True 
            If True and sorting by level and index is multilevel, sort by other 
            levels too (in order) after sorting by specified level. 
        ignore_index : bool, default False 
            If True, the resulting axis will be labeled 0, 1, …, n - 1. 
        key : callable, optional 
            If not None, apply the key function to the index values 
            before sorting. This is similar to the `key` argument in the 
            builtin :meth:`sorted` function, with the notable difference that 
            this `key` function should be *vectorized*. It should expect an 
            ``Index`` and return an ``Index`` of the same shape. 
 
        Returns 
        ------- 
        Series or None 
            The original Series sorted by the labels or None if ``inplace=True``. 
 
        See Also 
        -------- 
        DataFrame.sort_index: Sort DataFrame by the index. 
        DataFrame.sort_values: Sort DataFrame by the value. 
        Series.sort_values : Sort Series by the value. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; s = pd.Series(['a', 'b', 'c', 'd'], index=[3, 2, 1, 4]) 
        &gt;&gt;&gt; s.sort_index() 
        1    c 
        2    b 
        3    a 
        4    d 
        dtype: object 
 
        Sort Descending 
 
        &gt;&gt;&gt; s.sort_index(ascending=False) 
        4    d 
        3    a 
        2    b 
        1    c 
        dtype: object 
 
        By default NaNs are put at the end, but use `na_position` to place 
        them at the beginning 
 
        &gt;&gt;&gt; s = pd.Series(['a', 'b', 'c', 'd'], index=[3, 2, 1, np.nan]) 
        &gt;&gt;&gt; s.sort_index(na_position='first') 
        NaN     d 
         1.0    c 
         2.0    b 
         3.0    a 
        dtype: object 
 
        Specify index level to sort 
 
        &gt;&gt;&gt; arrays = [np.array(['qux', 'qux', 'foo', 'foo', 
        ...                     'baz', 'baz', 'bar', 'bar']), 
        ...           np.array(['two', 'one', 'two', 'one', 
        ...                     'two', 'one', 'two', 'one'])] 
        &gt;&gt;&gt; s = pd.Series([1, 2, 3, 4, 5, 6, 7, 8], index=arrays) 
        &gt;&gt;&gt; s.sort_index(level=1) 
        bar  one    8 
        baz  one    6 
        foo  one    4 
        qux  one    2 
        bar  two    7 
        baz  two    5 
        foo  two    3 
        qux  two    1 
        dtype: int64 
 
        Does not sort by remaining levels when sorting by levels 
 
        &gt;&gt;&gt; s.sort_index(level=1, sort_remaining=False) 
        qux  one    2 
        foo  one    4 
        baz  one    6 
        bar  one    8 
        qux  two    1 
        foo  two    3 
        baz  two    5 
        bar  two    7 
        dtype: int64 
 
        Apply a key function before sorting 
 
        &gt;&gt;&gt; s = pd.Series([1, 2, 3, 4], index=['A', 'b', 'C', 'd']) 
        &gt;&gt;&gt; s.sort_index(key=lambda x : x.str.lower()) 
        A    1 
        b    2 
        C    3 
        d    4 
        dtype: int64 
        &quot;&quot;&quot;</span>

        <span class="s2">return </span><span class="s1">super</span><span class="s3">().</span><span class="s1">sort_index</span><span class="s3">(</span>
            <span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">,</span>
            <span class="s1">level</span><span class="s3">=</span><span class="s1">level</span><span class="s3">,</span>
            <span class="s1">ascending</span><span class="s3">=</span><span class="s1">ascending</span><span class="s3">,</span>
            <span class="s1">inplace</span><span class="s3">=</span><span class="s1">inplace</span><span class="s3">,</span>
            <span class="s1">kind</span><span class="s3">=</span><span class="s1">kind</span><span class="s3">,</span>
            <span class="s1">na_position</span><span class="s3">=</span><span class="s1">na_position</span><span class="s3">,</span>
            <span class="s1">sort_remaining</span><span class="s3">=</span><span class="s1">sort_remaining</span><span class="s3">,</span>
            <span class="s1">ignore_index</span><span class="s3">=</span><span class="s1">ignore_index</span><span class="s3">,</span>
            <span class="s1">key</span><span class="s3">=</span><span class="s1">key</span><span class="s3">,</span>
        <span class="s3">)</span>

    <span class="s2">def </span><span class="s1">argsort</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">axis</span><span class="s3">: </span><span class="s1">Axis </span><span class="s3">= </span><span class="s5">0</span><span class="s3">,</span>
        <span class="s1">kind</span><span class="s3">: </span><span class="s1">SortKind </span><span class="s3">= </span><span class="s4">&quot;quicksort&quot;</span><span class="s3">,</span>
        <span class="s1">order</span><span class="s3">: </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">stable</span><span class="s3">: </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">-&gt; Series</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the integer indices that would sort the Series values. 
 
        Override ndarray.argsort. Argsorts the value, omitting NA/null values, 
        and places the result in the same locations as the non-NA values. 
 
        Parameters 
        ---------- 
        axis : {0 or 'index'} 
            Unused. Parameter needed for compatibility with DataFrame. 
        kind : {'mergesort', 'quicksort', 'heapsort', 'stable'}, default 'quicksort' 
            Choice of sorting algorithm. See :func:`numpy.sort` for more 
            information. 'mergesort' and 'stable' are the only stable algorithms. 
        order : None 
            Has no effect but is accepted for compatibility with numpy. 
        stable : None 
            Has no effect but is accepted for compatibility with numpy. 
 
        Returns 
        ------- 
        Series[np.intp] 
            Positions of values within the sort order with -1 indicating 
            nan values. 
 
        See Also 
        -------- 
        numpy.ndarray.argsort : Returns the indices that would sort this array. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; s = pd.Series([3, 2, 1]) 
        &gt;&gt;&gt; s.argsort() 
        0    2 
        1    1 
        2    0 
        dtype: int64 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">axis </span><span class="s3">!= -</span><span class="s5">1</span><span class="s3">:</span>
            <span class="s6"># GH#54257 We allow -1 here so that np.argsort(series) works</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_get_axis_number</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">)</span>

        <span class="s1">values </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_values</span>
        <span class="s1">mask </span><span class="s3">= </span><span class="s1">isna</span><span class="s3">(</span><span class="s1">values</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">mask</span><span class="s3">.</span><span class="s1">any</span><span class="s3">():</span>
            <span class="s6"># TODO(3.0): once this deprecation is enforced we can call</span>
            <span class="s6">#  self.array.argsort directly, which will close GH#43840 and</span>
            <span class="s6">#  GH#12694</span>
            <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span>
                <span class="s4">&quot;The behavior of Series.argsort in the presence of NA values is &quot;</span>
                <span class="s4">&quot;deprecated. In a future version, NA values will be ordered &quot;</span>
                <span class="s4">&quot;last instead of set to -1.&quot;</span><span class="s3">,</span>
                <span class="s1">FutureWarning</span><span class="s3">,</span>
                <span class="s1">stacklevel</span><span class="s3">=</span><span class="s1">find_stack_level</span><span class="s3">(),</span>
            <span class="s3">)</span>
            <span class="s1">result </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">full</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">), -</span><span class="s5">1</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">)</span>
            <span class="s1">notmask </span><span class="s3">= ~</span><span class="s1">mask</span>
            <span class="s1">result</span><span class="s3">[</span><span class="s1">notmask</span><span class="s3">] = </span><span class="s1">np</span><span class="s3">.</span><span class="s1">argsort</span><span class="s3">(</span><span class="s1">values</span><span class="s3">[</span><span class="s1">notmask</span><span class="s3">], </span><span class="s1">kind</span><span class="s3">=</span><span class="s1">kind</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">result </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">argsort</span><span class="s3">(</span><span class="s1">values</span><span class="s3">, </span><span class="s1">kind</span><span class="s3">=</span><span class="s1">kind</span><span class="s3">)</span>

        <span class="s1">res </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_constructor</span><span class="s3">(</span>
            <span class="s1">result</span><span class="s3">, </span><span class="s1">index</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">index</span><span class="s3">, </span><span class="s1">name</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">name</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">False</span>
        <span class="s3">)</span>
        <span class="s2">return </span><span class="s1">res</span><span class="s3">.</span><span class="s1">__finalize__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">method</span><span class="s3">=</span><span class="s4">&quot;argsort&quot;</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">nlargest</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">n</span><span class="s3">: </span><span class="s1">int </span><span class="s3">= </span><span class="s5">5</span><span class="s3">, </span><span class="s1">keep</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s4">&quot;first&quot;</span><span class="s3">, </span><span class="s4">&quot;last&quot;</span><span class="s3">, </span><span class="s4">&quot;all&quot;</span><span class="s3">] = </span><span class="s4">&quot;first&quot;</span>
    <span class="s3">) </span><span class="s1">-&gt; Series</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the largest `n` elements. 
 
        Parameters 
        ---------- 
        n : int, default 5 
            Return this many descending sorted values. 
        keep : {'first', 'last', 'all'}, default 'first' 
            When there are duplicate values that cannot all fit in a 
            Series of `n` elements: 
 
            - ``first`` : return the first `n` occurrences in order 
              of appearance. 
            - ``last`` : return the last `n` occurrences in reverse 
              order of appearance. 
            - ``all`` : keep all occurrences. This can result in a Series of 
              size larger than `n`. 
 
        Returns 
        ------- 
        Series 
            The `n` largest values in the Series, sorted in decreasing order. 
 
        See Also 
        -------- 
        Series.nsmallest: Get the `n` smallest elements. 
        Series.sort_values: Sort Series by values. 
        Series.head: Return the first `n` rows. 
 
        Notes 
        ----- 
        Faster than ``.sort_values(ascending=False).head(n)`` for small `n` 
        relative to the size of the ``Series`` object. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; countries_population = {&quot;Italy&quot;: 59000000, &quot;France&quot;: 65000000, 
        ...                         &quot;Malta&quot;: 434000, &quot;Maldives&quot;: 434000, 
        ...                         &quot;Brunei&quot;: 434000, &quot;Iceland&quot;: 337000, 
        ...                         &quot;Nauru&quot;: 11300, &quot;Tuvalu&quot;: 11300, 
        ...                         &quot;Anguilla&quot;: 11300, &quot;Montserrat&quot;: 5200} 
        &gt;&gt;&gt; s = pd.Series(countries_population) 
        &gt;&gt;&gt; s 
        Italy       59000000 
        France      65000000 
        Malta         434000 
        Maldives      434000 
        Brunei        434000 
        Iceland       337000 
        Nauru          11300 
        Tuvalu         11300 
        Anguilla       11300 
        Montserrat      5200 
        dtype: int64 
 
        The `n` largest elements where ``n=5`` by default. 
 
        &gt;&gt;&gt; s.nlargest() 
        France      65000000 
        Italy       59000000 
        Malta         434000 
        Maldives      434000 
        Brunei        434000 
        dtype: int64 
 
        The `n` largest elements where ``n=3``. Default `keep` value is 'first' 
        so Malta will be kept. 
 
        &gt;&gt;&gt; s.nlargest(3) 
        France    65000000 
        Italy     59000000 
        Malta       434000 
        dtype: int64 
 
        The `n` largest elements where ``n=3`` and keeping the last duplicates. 
        Brunei will be kept since it is the last with value 434000 based on 
        the index order. 
 
        &gt;&gt;&gt; s.nlargest(3, keep='last') 
        France      65000000 
        Italy       59000000 
        Brunei        434000 
        dtype: int64 
 
        The `n` largest elements where ``n=3`` with all duplicates kept. Note 
        that the returned Series has five elements due to the three duplicates. 
 
        &gt;&gt;&gt; s.nlargest(3, keep='all') 
        France      65000000 
        Italy       59000000 
        Malta         434000 
        Maldives      434000 
        Brunei        434000 
        dtype: int64 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">selectn</span><span class="s3">.</span><span class="s1">SelectNSeries</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">n</span><span class="s3">=</span><span class="s1">n</span><span class="s3">, </span><span class="s1">keep</span><span class="s3">=</span><span class="s1">keep</span><span class="s3">).</span><span class="s1">nlargest</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">nsmallest</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">n</span><span class="s3">: </span><span class="s1">int </span><span class="s3">= </span><span class="s5">5</span><span class="s3">, </span><span class="s1">keep</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s4">&quot;first&quot;</span><span class="s3">, </span><span class="s4">&quot;last&quot;</span><span class="s3">, </span><span class="s4">&quot;all&quot;</span><span class="s3">] = </span><span class="s4">&quot;first&quot;</span>
    <span class="s3">) </span><span class="s1">-&gt; Series</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the smallest `n` elements. 
 
        Parameters 
        ---------- 
        n : int, default 5 
            Return this many ascending sorted values. 
        keep : {'first', 'last', 'all'}, default 'first' 
            When there are duplicate values that cannot all fit in a 
            Series of `n` elements: 
 
            - ``first`` : return the first `n` occurrences in order 
              of appearance. 
            - ``last`` : return the last `n` occurrences in reverse 
              order of appearance. 
            - ``all`` : keep all occurrences. This can result in a Series of 
              size larger than `n`. 
 
        Returns 
        ------- 
        Series 
            The `n` smallest values in the Series, sorted in increasing order. 
 
        See Also 
        -------- 
        Series.nlargest: Get the `n` largest elements. 
        Series.sort_values: Sort Series by values. 
        Series.head: Return the first `n` rows. 
 
        Notes 
        ----- 
        Faster than ``.sort_values().head(n)`` for small `n` relative to 
        the size of the ``Series`` object. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; countries_population = {&quot;Italy&quot;: 59000000, &quot;France&quot;: 65000000, 
        ...                         &quot;Brunei&quot;: 434000, &quot;Malta&quot;: 434000, 
        ...                         &quot;Maldives&quot;: 434000, &quot;Iceland&quot;: 337000, 
        ...                         &quot;Nauru&quot;: 11300, &quot;Tuvalu&quot;: 11300, 
        ...                         &quot;Anguilla&quot;: 11300, &quot;Montserrat&quot;: 5200} 
        &gt;&gt;&gt; s = pd.Series(countries_population) 
        &gt;&gt;&gt; s 
        Italy       59000000 
        France      65000000 
        Brunei        434000 
        Malta         434000 
        Maldives      434000 
        Iceland       337000 
        Nauru          11300 
        Tuvalu         11300 
        Anguilla       11300 
        Montserrat      5200 
        dtype: int64 
 
        The `n` smallest elements where ``n=5`` by default. 
 
        &gt;&gt;&gt; s.nsmallest() 
        Montserrat    5200 
        Nauru        11300 
        Tuvalu       11300 
        Anguilla     11300 
        Iceland     337000 
        dtype: int64 
 
        The `n` smallest elements where ``n=3``. Default `keep` value is 
        'first' so Nauru and Tuvalu will be kept. 
 
        &gt;&gt;&gt; s.nsmallest(3) 
        Montserrat   5200 
        Nauru       11300 
        Tuvalu      11300 
        dtype: int64 
 
        The `n` smallest elements where ``n=3`` and keeping the last 
        duplicates. Anguilla and Tuvalu will be kept since they are the last 
        with value 11300 based on the index order. 
 
        &gt;&gt;&gt; s.nsmallest(3, keep='last') 
        Montserrat   5200 
        Anguilla    11300 
        Tuvalu      11300 
        dtype: int64 
 
        The `n` smallest elements where ``n=3`` with all duplicates kept. Note 
        that the returned Series has four elements due to the three duplicates. 
 
        &gt;&gt;&gt; s.nsmallest(3, keep='all') 
        Montserrat   5200 
        Nauru       11300 
        Tuvalu      11300 
        Anguilla    11300 
        dtype: int64 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">selectn</span><span class="s3">.</span><span class="s1">SelectNSeries</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">n</span><span class="s3">=</span><span class="s1">n</span><span class="s3">, </span><span class="s1">keep</span><span class="s3">=</span><span class="s1">keep</span><span class="s3">).</span><span class="s1">nsmallest</span><span class="s3">()</span>

    <span class="s3">@</span><span class="s1">doc</span><span class="s3">(</span>
        <span class="s1">klass</span><span class="s3">=</span><span class="s1">_shared_doc_kwargs</span><span class="s3">[</span><span class="s4">&quot;klass&quot;</span><span class="s3">],</span>
        <span class="s1">extra_params</span><span class="s3">=</span><span class="s1">dedent</span><span class="s3">(</span>
            <span class="s4">&quot;&quot;&quot;copy : bool, default True 
            Whether to copy underlying data. 
 
            .. note:: 
                The `copy` keyword will change behavior in pandas 3.0. 
                `Copy-on-Write 
                &lt;https://pandas.pydata.org/docs/dev/user_guide/copy_on_write.html&gt;`__ 
                will be enabled by default, which means that all methods with a 
                `copy` keyword will use a lazy copy mechanism to defer the copy and 
                ignore the `copy` keyword. The `copy` keyword will be removed in a 
                future version of pandas. 
 
                You can already get the future behavior and improvements through 
                enabling copy on write ``pd.options.mode.copy_on_write = True``&quot;&quot;&quot;</span>
        <span class="s3">),</span>
        <span class="s1">examples</span><span class="s3">=</span><span class="s1">dedent</span><span class="s3">(</span>
            <span class="s4">&quot;&quot;&quot;</span><span class="s2">\ 
        </span><span class="s4">Examples 
        -------- 
        &gt;&gt;&gt; s = pd.Series( 
        ...     [&quot;A&quot;, &quot;B&quot;, &quot;A&quot;, &quot;C&quot;], 
        ...     index=[ 
        ...         [&quot;Final exam&quot;, &quot;Final exam&quot;, &quot;Coursework&quot;, &quot;Coursework&quot;], 
        ...         [&quot;History&quot;, &quot;Geography&quot;, &quot;History&quot;, &quot;Geography&quot;], 
        ...         [&quot;January&quot;, &quot;February&quot;, &quot;March&quot;, &quot;April&quot;], 
        ...     ], 
        ... ) 
        &gt;&gt;&gt; s 
        Final exam  History     January      A 
                    Geography   February     B 
        Coursework  History     March        A 
                    Geography   April        C 
        dtype: object 
 
        In the following example, we will swap the levels of the indices. 
        Here, we will swap the levels column-wise, but levels can be swapped row-wise 
        in a similar manner. Note that column-wise is the default behaviour. 
        By not supplying any arguments for i and j, we swap the last and second to 
        last indices. 
 
        &gt;&gt;&gt; s.swaplevel() 
        Final exam  January     History         A 
                    February    Geography       B 
        Coursework  March       History         A 
                    April       Geography       C 
        dtype: object 
 
        By supplying one argument, we can choose which index to swap the last 
        index with. We can for example swap the first index with the last one as 
        follows. 
 
        &gt;&gt;&gt; s.swaplevel(0) 
        January     History     Final exam      A 
        February    Geography   Final exam      B 
        March       History     Coursework      A 
        April       Geography   Coursework      C 
        dtype: object 
 
        We can also define explicitly which indices we want to swap by supplying values 
        for both i and j. Here, we for example swap the first and second indices. 
 
        &gt;&gt;&gt; s.swaplevel(0, 1) 
        History     Final exam  January         A 
        Geography   Final exam  February        B 
        History     Coursework  March           A 
        Geography   Coursework  April           C 
        dtype: object&quot;&quot;&quot;</span>
        <span class="s3">),</span>
    <span class="s3">)</span>
    <span class="s2">def </span><span class="s1">swaplevel</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">i</span><span class="s3">: </span><span class="s1">Level </span><span class="s3">= -</span><span class="s5">2</span><span class="s3">, </span><span class="s1">j</span><span class="s3">: </span><span class="s1">Level </span><span class="s3">= -</span><span class="s5">1</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span>
    <span class="s3">) </span><span class="s1">-&gt; Series</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Swap levels i and j in a :class:`MultiIndex`. 
 
        Default is to swap the two innermost levels of the index. 
 
        Parameters 
        ---------- 
        i, j : int or str 
            Levels of the indices to be swapped. Can pass level name as string. 
        {extra_params} 
 
        Returns 
        ------- 
        {klass} 
            {klass} with levels swapped in MultiIndex. 
 
        {examples} 
        &quot;&quot;&quot;</span>
        <span class="s2">assert </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">index</span><span class="s3">, </span><span class="s1">MultiIndex</span><span class="s3">)</span>
        <span class="s1">result </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">(</span><span class="s1">deep</span><span class="s3">=</span><span class="s1">copy </span><span class="s2">and not </span><span class="s1">using_copy_on_write</span><span class="s3">())</span>
        <span class="s1">result</span><span class="s3">.</span><span class="s1">index </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">index</span><span class="s3">.</span><span class="s1">swaplevel</span><span class="s3">(</span><span class="s1">i</span><span class="s3">, </span><span class="s1">j</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">result</span>

    <span class="s2">def </span><span class="s1">reorder_levels</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">order</span><span class="s3">: </span><span class="s1">Sequence</span><span class="s3">[</span><span class="s1">Level</span><span class="s3">]) </span><span class="s1">-&gt; Series</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Rearrange index levels using input order. 
 
        May not drop or duplicate levels. 
 
        Parameters 
        ---------- 
        order : list of int representing new level order 
            Reference level by number or key. 
 
        Returns 
        ------- 
        type of caller (new object) 
 
        Examples 
        -------- 
        &gt;&gt;&gt; arrays = [np.array([&quot;dog&quot;, &quot;dog&quot;, &quot;cat&quot;, &quot;cat&quot;, &quot;bird&quot;, &quot;bird&quot;]), 
        ...           np.array([&quot;white&quot;, &quot;black&quot;, &quot;white&quot;, &quot;black&quot;, &quot;white&quot;, &quot;black&quot;])] 
        &gt;&gt;&gt; s = pd.Series([1, 2, 3, 3, 5, 2], index=arrays) 
        &gt;&gt;&gt; s 
        dog   white    1 
              black    2 
        cat   white    3 
              black    3 
        bird  white    5 
              black    2 
        dtype: int64 
        &gt;&gt;&gt; s.reorder_levels([1, 0]) 
        white  dog     1 
        black  dog     2 
        white  cat     3 
        black  cat     3 
        white  bird    5 
        black  bird    2 
        dtype: int64 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">index</span><span class="s3">, </span><span class="s1">MultiIndex</span><span class="s3">):  </span><span class="s6"># pragma: no cover</span>
            <span class="s2">raise </span><span class="s1">Exception</span><span class="s3">(</span><span class="s4">&quot;Can only reorder levels on a hierarchical axis.&quot;</span><span class="s3">)</span>

        <span class="s1">result </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">(</span><span class="s1">deep</span><span class="s3">=</span><span class="s2">None</span><span class="s3">)</span>
        <span class="s2">assert </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">result</span><span class="s3">.</span><span class="s1">index</span><span class="s3">, </span><span class="s1">MultiIndex</span><span class="s3">)</span>
        <span class="s1">result</span><span class="s3">.</span><span class="s1">index </span><span class="s3">= </span><span class="s1">result</span><span class="s3">.</span><span class="s1">index</span><span class="s3">.</span><span class="s1">reorder_levels</span><span class="s3">(</span><span class="s1">order</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">result</span>

    <span class="s2">def </span><span class="s1">explode</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">ignore_index</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span><span class="s3">) </span><span class="s1">-&gt; Series</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Transform each element of a list-like to a row. 
 
        Parameters 
        ---------- 
        ignore_index : bool, default False 
            If True, the resulting index will be labeled 0, 1, …, n - 1. 
 
        Returns 
        ------- 
        Series 
            Exploded lists to rows; index will be duplicated for these rows. 
 
        See Also 
        -------- 
        Series.str.split : Split string values on specified separator. 
        Series.unstack : Unstack, a.k.a. pivot, Series with MultiIndex 
            to produce DataFrame. 
        DataFrame.melt : Unpivot a DataFrame from wide format to long format. 
        DataFrame.explode : Explode a DataFrame from list-like 
            columns to long format. 
 
        Notes 
        ----- 
        This routine will explode list-likes including lists, tuples, sets, 
        Series, and np.ndarray. The result dtype of the subset rows will 
        be object. Scalars will be returned unchanged, and empty list-likes will 
        result in a np.nan for that row. In addition, the ordering of elements in 
        the output will be non-deterministic when exploding sets. 
 
        Reference :ref:`the user guide &lt;reshaping.explode&gt;` for more examples. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; s = pd.Series([[1, 2, 3], 'foo', [], [3, 4]]) 
        &gt;&gt;&gt; s 
        0    [1, 2, 3] 
        1          foo 
        2           [] 
        3       [3, 4] 
        dtype: object 
 
        &gt;&gt;&gt; s.explode() 
        0      1 
        0      2 
        0      3 
        1    foo 
        2    NaN 
        3      3 
        3      4 
        dtype: object 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">ExtensionDtype</span><span class="s3">):</span>
            <span class="s1">values</span><span class="s3">, </span><span class="s1">counts </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_values</span><span class="s3">.</span><span class="s1">_explode</span><span class="s3">()</span>
        <span class="s2">elif </span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s2">and </span><span class="s1">is_object_dtype</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">):</span>
            <span class="s1">values</span><span class="s3">, </span><span class="s1">counts </span><span class="s3">= </span><span class="s1">reshape</span><span class="s3">.</span><span class="s1">explode</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_values</span><span class="s3">))</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">result </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>
            <span class="s2">return </span><span class="s1">result</span><span class="s3">.</span><span class="s1">reset_index</span><span class="s3">(</span><span class="s1">drop</span><span class="s3">=</span><span class="s2">True</span><span class="s3">) </span><span class="s2">if </span><span class="s1">ignore_index </span><span class="s2">else </span><span class="s1">result</span>

        <span class="s2">if </span><span class="s1">ignore_index</span><span class="s3">:</span>
            <span class="s1">index</span><span class="s3">: </span><span class="s1">Index </span><span class="s3">= </span><span class="s1">default_index</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">values</span><span class="s3">))</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">index </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">index</span><span class="s3">.</span><span class="s1">repeat</span><span class="s3">(</span><span class="s1">counts</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_constructor</span><span class="s3">(</span><span class="s1">values</span><span class="s3">, </span><span class="s1">index</span><span class="s3">=</span><span class="s1">index</span><span class="s3">, </span><span class="s1">name</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">name</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">unstack</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">level</span><span class="s3">: </span><span class="s1">IndexLabel </span><span class="s3">= -</span><span class="s5">1</span><span class="s3">,</span>
        <span class="s1">fill_value</span><span class="s3">: </span><span class="s1">Hashable </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">sort</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">True</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">-&gt; DataFrame</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Unstack, also known as pivot, Series with MultiIndex to produce DataFrame. 
 
        Parameters 
        ---------- 
        level : int, str, or list of these, default last level 
            Level(s) to unstack, can pass level name. 
        fill_value : scalar value, default None 
            Value to use when replacing NaN values. 
        sort : bool, default True 
            Sort the level(s) in the resulting MultiIndex columns. 
 
        Returns 
        ------- 
        DataFrame 
            Unstacked Series. 
 
        Notes 
        ----- 
        Reference :ref:`the user guide &lt;reshaping.stacking&gt;` for more examples. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; s = pd.Series([1, 2, 3, 4], 
        ...               index=pd.MultiIndex.from_product([['one', 'two'], 
        ...                                                 ['a', 'b']])) 
        &gt;&gt;&gt; s 
        one  a    1 
             b    2 
        two  a    3 
             b    4 
        dtype: int64 
 
        &gt;&gt;&gt; s.unstack(level=-1) 
             a  b 
        one  1  2 
        two  3  4 
 
        &gt;&gt;&gt; s.unstack(level=0) 
           one  two 
        a    1    3 
        b    2    4 
        &quot;&quot;&quot;</span>
        <span class="s2">from </span><span class="s1">pandas</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">.</span><span class="s1">reshape </span><span class="s2">import </span><span class="s1">unstack</span>

        <span class="s2">return </span><span class="s1">unstack</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">level</span><span class="s3">, </span><span class="s1">fill_value</span><span class="s3">, </span><span class="s1">sort</span><span class="s3">)</span>

    <span class="s6"># ----------------------------------------------------------------------</span>
    <span class="s6"># function application</span>

    <span class="s2">def </span><span class="s1">map</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">arg</span><span class="s3">: </span><span class="s1">Callable </span><span class="s3">| </span><span class="s1">Mapping </span><span class="s3">| </span><span class="s1">Series</span><span class="s3">,</span>
        <span class="s1">na_action</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s4">&quot;ignore&quot;</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">-&gt; Series</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Map values of Series according to an input mapping or function. 
 
        Used for substituting each value in a Series with another value, 
        that may be derived from a function, a ``dict`` or 
        a :class:`Series`. 
 
        Parameters 
        ---------- 
        arg : function, collections.abc.Mapping subclass or Series 
            Mapping correspondence. 
        na_action : {None, 'ignore'}, default None 
            If 'ignore', propagate NaN values, without passing them to the 
            mapping correspondence. 
 
        Returns 
        ------- 
        Series 
            Same index as caller. 
 
        See Also 
        -------- 
        Series.apply : For applying more complex functions on a Series. 
        Series.replace: Replace values given in `to_replace` with `value`. 
        DataFrame.apply : Apply a function row-/column-wise. 
        DataFrame.map : Apply a function elementwise on a whole DataFrame. 
 
        Notes 
        ----- 
        When ``arg`` is a dictionary, values in Series that are not in the 
        dictionary (as keys) are converted to ``NaN``. However, if the 
        dictionary is a ``dict`` subclass that defines ``__missing__`` (i.e. 
        provides a method for default values), then this default is used 
        rather than ``NaN``. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; s = pd.Series(['cat', 'dog', np.nan, 'rabbit']) 
        &gt;&gt;&gt; s 
        0      cat 
        1      dog 
        2      NaN 
        3   rabbit 
        dtype: object 
 
        ``map`` accepts a ``dict`` or a ``Series``. Values that are not found 
        in the ``dict`` are converted to ``NaN``, unless the dict has a default 
        value (e.g. ``defaultdict``): 
 
        &gt;&gt;&gt; s.map({'cat': 'kitten', 'dog': 'puppy'}) 
        0   kitten 
        1    puppy 
        2      NaN 
        3      NaN 
        dtype: object 
 
        It also accepts a function: 
 
        &gt;&gt;&gt; s.map('I am a {}'.format) 
        0       I am a cat 
        1       I am a dog 
        2       I am a nan 
        3    I am a rabbit 
        dtype: object 
 
        To avoid applying the function to missing values (and keep them as 
        ``NaN``) ``na_action='ignore'`` can be used: 
 
        &gt;&gt;&gt; s.map('I am a {}'.format, na_action='ignore') 
        0     I am a cat 
        1     I am a dog 
        2            NaN 
        3  I am a rabbit 
        dtype: object 
        &quot;&quot;&quot;</span>
        <span class="s1">new_values </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_map_values</span><span class="s3">(</span><span class="s1">arg</span><span class="s3">, </span><span class="s1">na_action</span><span class="s3">=</span><span class="s1">na_action</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_constructor</span><span class="s3">(</span><span class="s1">new_values</span><span class="s3">, </span><span class="s1">index</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">index</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">False</span><span class="s3">).</span><span class="s1">__finalize__</span><span class="s3">(</span>
            <span class="s1">self</span><span class="s3">, </span><span class="s1">method</span><span class="s3">=</span><span class="s4">&quot;map&quot;</span>
        <span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_gotitem</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">key</span><span class="s3">, </span><span class="s1">ndim</span><span class="s3">, </span><span class="s1">subset</span><span class="s3">=</span><span class="s2">None</span><span class="s3">) </span><span class="s1">-&gt; Self</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Sub-classes to define. Return a sliced object. 
 
        Parameters 
        ---------- 
        key : string / list of selections 
        ndim : {1, 2} 
            Requested ndim of result. 
        subset : object, default None 
            Subset to act on. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s1">_agg_see_also_doc </span><span class="s3">= </span><span class="s1">dedent</span><span class="s3">(</span>
        <span class="s4">&quot;&quot;&quot; 
    See Also 
    -------- 
    Series.apply : Invoke function on a Series. 
    Series.transform : Transform function producing a Series with like indexes. 
    &quot;&quot;&quot;</span>
    <span class="s3">)</span>

    <span class="s1">_agg_examples_doc </span><span class="s3">= </span><span class="s1">dedent</span><span class="s3">(</span>
        <span class="s4">&quot;&quot;&quot; 
    Examples 
    -------- 
    &gt;&gt;&gt; s = pd.Series([1, 2, 3, 4]) 
    &gt;&gt;&gt; s 
    0    1 
    1    2 
    2    3 
    3    4 
    dtype: int64 
 
    &gt;&gt;&gt; s.agg('min') 
    1 
 
    &gt;&gt;&gt; s.agg(['min', 'max']) 
    min   1 
    max   4 
    dtype: int64 
    &quot;&quot;&quot;</span>
    <span class="s3">)</span>

    <span class="s3">@</span><span class="s1">doc</span><span class="s3">(</span>
        <span class="s1">_shared_docs</span><span class="s3">[</span><span class="s4">&quot;aggregate&quot;</span><span class="s3">],</span>
        <span class="s1">klass</span><span class="s3">=</span><span class="s1">_shared_doc_kwargs</span><span class="s3">[</span><span class="s4">&quot;klass&quot;</span><span class="s3">],</span>
        <span class="s1">axis</span><span class="s3">=</span><span class="s1">_shared_doc_kwargs</span><span class="s3">[</span><span class="s4">&quot;axis&quot;</span><span class="s3">],</span>
        <span class="s1">see_also</span><span class="s3">=</span><span class="s1">_agg_see_also_doc</span><span class="s3">,</span>
        <span class="s1">examples</span><span class="s3">=</span><span class="s1">_agg_examples_doc</span><span class="s3">,</span>
    <span class="s3">)</span>
    <span class="s2">def </span><span class="s1">aggregate</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">func</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">: </span><span class="s1">Axis </span><span class="s3">= </span><span class="s5">0</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">):</span>
        <span class="s6"># Validate the axis parameter</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_get_axis_number</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">)</span>

        <span class="s6"># if func is None, will switch to user-provided &quot;named aggregation&quot; kwargs</span>
        <span class="s2">if </span><span class="s1">func </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s1">func </span><span class="s3">= </span><span class="s1">dict</span><span class="s3">(</span><span class="s1">kwargs</span><span class="s3">.</span><span class="s1">items</span><span class="s3">())</span>

        <span class="s1">op </span><span class="s3">= </span><span class="s1">SeriesApply</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">func</span><span class="s3">, </span><span class="s1">args</span><span class="s3">=</span><span class="s1">args</span><span class="s3">, </span><span class="s1">kwargs</span><span class="s3">=</span><span class="s1">kwargs</span><span class="s3">)</span>
        <span class="s1">result </span><span class="s3">= </span><span class="s1">op</span><span class="s3">.</span><span class="s1">agg</span><span class="s3">()</span>
        <span class="s2">return </span><span class="s1">result</span>

    <span class="s1">agg </span><span class="s3">= </span><span class="s1">aggregate</span>

    <span class="s3">@</span><span class="s1">doc</span><span class="s3">(</span>
        <span class="s1">_shared_docs</span><span class="s3">[</span><span class="s4">&quot;transform&quot;</span><span class="s3">],</span>
        <span class="s1">klass</span><span class="s3">=</span><span class="s1">_shared_doc_kwargs</span><span class="s3">[</span><span class="s4">&quot;klass&quot;</span><span class="s3">],</span>
        <span class="s1">axis</span><span class="s3">=</span><span class="s1">_shared_doc_kwargs</span><span class="s3">[</span><span class="s4">&quot;axis&quot;</span><span class="s3">],</span>
    <span class="s3">)</span>
    <span class="s2">def </span><span class="s1">transform</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">func</span><span class="s3">: </span><span class="s1">AggFuncType</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">: </span><span class="s1">Axis </span><span class="s3">= </span><span class="s5">0</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kwargs</span>
    <span class="s3">) </span><span class="s1">-&gt; DataFrame </span><span class="s3">| </span><span class="s1">Series</span><span class="s3">:</span>
        <span class="s6"># Validate axis argument</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_get_axis_number</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">)</span>
        <span class="s1">ser </span><span class="s3">= (</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">(</span><span class="s1">deep</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">using_copy_on_write</span><span class="s3">() </span><span class="s2">or </span><span class="s1">warn_copy_on_write</span><span class="s3">()</span>
            <span class="s2">else </span><span class="s1">self</span>
        <span class="s3">)</span>
        <span class="s1">result </span><span class="s3">= </span><span class="s1">SeriesApply</span><span class="s3">(</span><span class="s1">ser</span><span class="s3">, </span><span class="s1">func</span><span class="s3">=</span><span class="s1">func</span><span class="s3">, </span><span class="s1">args</span><span class="s3">=</span><span class="s1">args</span><span class="s3">, </span><span class="s1">kwargs</span><span class="s3">=</span><span class="s1">kwargs</span><span class="s3">).</span><span class="s1">transform</span><span class="s3">()</span>
        <span class="s2">return </span><span class="s1">result</span>

    <span class="s2">def </span><span class="s1">apply</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">func</span><span class="s3">: </span><span class="s1">AggFuncType</span><span class="s3">,</span>
        <span class="s1">convert_dtype</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s1">lib</span><span class="s3">.</span><span class="s1">NoDefault </span><span class="s3">= </span><span class="s1">lib</span><span class="s3">.</span><span class="s1">no_default</span><span class="s3">,</span>
        <span class="s1">args</span><span class="s3">: </span><span class="s1">tuple</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">, ...] = (),</span>
        <span class="s3">*,</span>
        <span class="s1">by_row</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s2">False</span><span class="s3">, </span><span class="s4">&quot;compat&quot;</span><span class="s3">] = </span><span class="s4">&quot;compat&quot;</span><span class="s3">,</span>
        <span class="s3">**</span><span class="s1">kwargs</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">-&gt; DataFrame </span><span class="s3">| </span><span class="s1">Series</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Invoke function on values of Series. 
 
        Can be ufunc (a NumPy function that applies to the entire Series) 
        or a Python function that only works on single values. 
 
        Parameters 
        ---------- 
        func : function 
            Python function or NumPy ufunc to apply. 
        convert_dtype : bool, default True 
            Try to find better dtype for elementwise function results. If 
            False, leave as dtype=object. Note that the dtype is always 
            preserved for some extension array dtypes, such as Categorical. 
 
            .. deprecated:: 2.1.0 
                ``convert_dtype`` has been deprecated. Do ``ser.astype(object).apply()`` 
                instead if you want ``convert_dtype=False``. 
        args : tuple 
            Positional arguments passed to func after the series value. 
        by_row : False or &quot;compat&quot;, default &quot;compat&quot; 
            If ``&quot;compat&quot;`` and func is a callable, func will be passed each element of 
            the Series, like ``Series.map``. If func is a list or dict of 
            callables, will first try to translate each func into pandas methods. If 
            that doesn't work, will try call to apply again with ``by_row=&quot;compat&quot;`` 
            and if that fails, will call apply again with ``by_row=False`` 
            (backward compatible). 
            If False, the func will be passed the whole Series at once. 
 
            ``by_row`` has no effect when ``func`` is a string. 
 
            .. versionadded:: 2.1.0 
        **kwargs 
            Additional keyword arguments passed to func. 
 
        Returns 
        ------- 
        Series or DataFrame 
            If func returns a Series object the result will be a DataFrame. 
 
        See Also 
        -------- 
        Series.map: For element-wise operations. 
        Series.agg: Only perform aggregating type operations. 
        Series.transform: Only perform transforming type operations. 
 
        Notes 
        ----- 
        Functions that mutate the passed object can produce unexpected 
        behavior or errors and are not supported. See :ref:`gotchas.udf-mutation` 
        for more details. 
 
        Examples 
        -------- 
        Create a series with typical summer temperatures for each city. 
 
        &gt;&gt;&gt; s = pd.Series([20, 21, 12], 
        ...               index=['London', 'New York', 'Helsinki']) 
        &gt;&gt;&gt; s 
        London      20 
        New York    21 
        Helsinki    12 
        dtype: int64 
 
        Square the values by defining a function and passing it as an 
        argument to ``apply()``. 
 
        &gt;&gt;&gt; def square(x): 
        ...     return x ** 2 
        &gt;&gt;&gt; s.apply(square) 
        London      400 
        New York    441 
        Helsinki    144 
        dtype: int64 
 
        Square the values by passing an anonymous function as an 
        argument to ``apply()``. 
 
        &gt;&gt;&gt; s.apply(lambda x: x ** 2) 
        London      400 
        New York    441 
        Helsinki    144 
        dtype: int64 
 
        Define a custom function that needs additional positional 
        arguments and pass these additional arguments using the 
        ``args`` keyword. 
 
        &gt;&gt;&gt; def subtract_custom_value(x, custom_value): 
        ...     return x - custom_value 
 
        &gt;&gt;&gt; s.apply(subtract_custom_value, args=(5,)) 
        London      15 
        New York    16 
        Helsinki     7 
        dtype: int64 
 
        Define a custom function that takes keyword arguments 
        and pass these arguments to ``apply``. 
 
        &gt;&gt;&gt; def add_custom_values(x, **kwargs): 
        ...     for month in kwargs: 
        ...         x += kwargs[month] 
        ...     return x 
 
        &gt;&gt;&gt; s.apply(add_custom_values, june=30, july=20, august=25) 
        London      95 
        New York    96 
        Helsinki    87 
        dtype: int64 
 
        Use a function from the Numpy library. 
 
        &gt;&gt;&gt; s.apply(np.log) 
        London      2.995732 
        New York    3.044522 
        Helsinki    2.484907 
        dtype: float64 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">SeriesApply</span><span class="s3">(</span>
            <span class="s1">self</span><span class="s3">,</span>
            <span class="s1">func</span><span class="s3">,</span>
            <span class="s1">convert_dtype</span><span class="s3">=</span><span class="s1">convert_dtype</span><span class="s3">,</span>
            <span class="s1">by_row</span><span class="s3">=</span><span class="s1">by_row</span><span class="s3">,</span>
            <span class="s1">args</span><span class="s3">=</span><span class="s1">args</span><span class="s3">,</span>
            <span class="s1">kwargs</span><span class="s3">=</span><span class="s1">kwargs</span><span class="s3">,</span>
        <span class="s3">).</span><span class="s1">apply</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">_reindex_indexer</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">new_index</span><span class="s3">: </span><span class="s1">Index </span><span class="s3">| </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">indexer</span><span class="s3">: </span><span class="s1">npt</span><span class="s3">.</span><span class="s1">NDArray</span><span class="s3">[</span><span class="s1">np</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">] | </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">copy</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">-&gt; Series</span><span class="s3">:</span>
        <span class="s6"># Note: new_index is None iff indexer is None</span>
        <span class="s6"># if not None, indexer is np.intp</span>
        <span class="s2">if </span><span class="s1">indexer </span><span class="s2">is None and </span><span class="s3">(</span>
            <span class="s1">new_index </span><span class="s2">is None or </span><span class="s1">new_index</span><span class="s3">.</span><span class="s1">names </span><span class="s3">== </span><span class="s1">self</span><span class="s3">.</span><span class="s1">index</span><span class="s3">.</span><span class="s1">names</span>
        <span class="s3">):</span>
            <span class="s2">if </span><span class="s1">using_copy_on_write</span><span class="s3">():</span>
                <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">(</span><span class="s1">deep</span><span class="s3">=</span><span class="s1">copy</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">copy </span><span class="s2">or </span><span class="s1">copy </span><span class="s2">is None</span><span class="s3">:</span>
                <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">(</span><span class="s1">deep</span><span class="s3">=</span><span class="s1">copy</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">self</span>

        <span class="s1">new_values </span><span class="s3">= </span><span class="s1">algorithms</span><span class="s3">.</span><span class="s1">take_nd</span><span class="s3">(</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_values</span><span class="s3">, </span><span class="s1">indexer</span><span class="s3">, </span><span class="s1">allow_fill</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">fill_value</span><span class="s3">=</span><span class="s2">None</span>
        <span class="s3">)</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_constructor</span><span class="s3">(</span><span class="s1">new_values</span><span class="s3">, </span><span class="s1">index</span><span class="s3">=</span><span class="s1">new_index</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_needs_reindex_multi</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">axes</span><span class="s3">, </span><span class="s1">method</span><span class="s3">, </span><span class="s1">level</span><span class="s3">) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Check if we do need a multi reindex; this is for compat with 
        higher dims. 
        &quot;&quot;&quot;</span>
        <span class="s2">return False</span>

    <span class="s3">@</span><span class="s1">overload</span>
    <span class="s2">def </span><span class="s1">rename</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">index</span><span class="s3">: </span><span class="s1">Renamer </span><span class="s3">| </span><span class="s1">Hashable </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= ...,</span>
        <span class="s3">*,</span>
        <span class="s1">axis</span><span class="s3">: </span><span class="s1">Axis </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= ...,</span>
        <span class="s1">copy</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= ...,</span>
        <span class="s1">inplace</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s2">True</span><span class="s3">],</span>
        <span class="s1">level</span><span class="s3">: </span><span class="s1">Level </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= ...,</span>
        <span class="s1">errors</span><span class="s3">: </span><span class="s1">IgnoreRaise </span><span class="s3">= ...,</span>
    <span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s3">...</span>

    <span class="s3">@</span><span class="s1">overload</span>
    <span class="s2">def </span><span class="s1">rename</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">index</span><span class="s3">: </span><span class="s1">Renamer </span><span class="s3">| </span><span class="s1">Hashable </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= ...,</span>
        <span class="s3">*,</span>
        <span class="s1">axis</span><span class="s3">: </span><span class="s1">Axis </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= ...,</span>
        <span class="s1">copy</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= ...,</span>
        <span class="s1">inplace</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s2">False</span><span class="s3">] = ...,</span>
        <span class="s1">level</span><span class="s3">: </span><span class="s1">Level </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= ...,</span>
        <span class="s1">errors</span><span class="s3">: </span><span class="s1">IgnoreRaise </span><span class="s3">= ...,</span>
    <span class="s3">) </span><span class="s1">-&gt; Series</span><span class="s3">:</span>
        <span class="s3">...</span>

    <span class="s3">@</span><span class="s1">overload</span>
    <span class="s2">def </span><span class="s1">rename</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">index</span><span class="s3">: </span><span class="s1">Renamer </span><span class="s3">| </span><span class="s1">Hashable </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= ...,</span>
        <span class="s3">*,</span>
        <span class="s1">axis</span><span class="s3">: </span><span class="s1">Axis </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= ...,</span>
        <span class="s1">copy</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= ...,</span>
        <span class="s1">inplace</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= ...,</span>
        <span class="s1">level</span><span class="s3">: </span><span class="s1">Level </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= ...,</span>
        <span class="s1">errors</span><span class="s3">: </span><span class="s1">IgnoreRaise </span><span class="s3">= ...,</span>
    <span class="s3">) </span><span class="s1">-&gt; Series </span><span class="s3">| </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s3">...</span>

    <span class="s2">def </span><span class="s1">rename</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">index</span><span class="s3">: </span><span class="s1">Renamer </span><span class="s3">| </span><span class="s1">Hashable </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s3">*,</span>
        <span class="s1">axis</span><span class="s3">: </span><span class="s1">Axis </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">copy</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">inplace</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span><span class="s3">,</span>
        <span class="s1">level</span><span class="s3">: </span><span class="s1">Level </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">errors</span><span class="s3">: </span><span class="s1">IgnoreRaise </span><span class="s3">= </span><span class="s4">&quot;ignore&quot;</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">-&gt; Series </span><span class="s3">| </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Alter Series index labels or name. 
 
        Function / dict values must be unique (1-to-1). Labels not contained in 
        a dict / Series will be left as-is. Extra labels listed don't throw an 
        error. 
 
        Alternatively, change ``Series.name`` with a scalar value. 
 
        See the :ref:`user guide &lt;basics.rename&gt;` for more. 
 
        Parameters 
        ---------- 
        index : scalar, hashable sequence, dict-like or function optional 
            Functions or dict-like are transformations to apply to 
            the index. 
            Scalar or hashable sequence-like will alter the ``Series.name`` 
            attribute. 
        axis : {0 or 'index'} 
            Unused. Parameter needed for compatibility with DataFrame. 
        copy : bool, default True 
            Also copy underlying data. 
 
            .. note:: 
                The `copy` keyword will change behavior in pandas 3.0. 
                `Copy-on-Write 
                &lt;https://pandas.pydata.org/docs/dev/user_guide/copy_on_write.html&gt;`__ 
                will be enabled by default, which means that all methods with a 
                `copy` keyword will use a lazy copy mechanism to defer the copy and 
                ignore the `copy` keyword. The `copy` keyword will be removed in a 
                future version of pandas. 
 
                You can already get the future behavior and improvements through 
                enabling copy on write ``pd.options.mode.copy_on_write = True`` 
        inplace : bool, default False 
            Whether to return a new Series. If True the value of copy is ignored. 
        level : int or level name, default None 
            In case of MultiIndex, only rename labels in the specified level. 
        errors : {'ignore', 'raise'}, default 'ignore' 
            If 'raise', raise `KeyError` when a `dict-like mapper` or 
            `index` contains labels that are not present in the index being transformed. 
            If 'ignore', existing keys will be renamed and extra keys will be ignored. 
 
        Returns 
        ------- 
        Series or None 
            Series with index labels or name altered or None if ``inplace=True``. 
 
        See Also 
        -------- 
        DataFrame.rename : Corresponding DataFrame method. 
        Series.rename_axis : Set the name of the axis. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; s = pd.Series([1, 2, 3]) 
        &gt;&gt;&gt; s 
        0    1 
        1    2 
        2    3 
        dtype: int64 
        &gt;&gt;&gt; s.rename(&quot;my_name&quot;)  # scalar, changes Series.name 
        0    1 
        1    2 
        2    3 
        Name: my_name, dtype: int64 
        &gt;&gt;&gt; s.rename(lambda x: x ** 2)  # function, changes labels 
        0    1 
        1    2 
        4    3 
        dtype: int64 
        &gt;&gt;&gt; s.rename({1: 3, 2: 5})  # mapping, changes labels 
        0    1 
        3    2 
        5    3 
        dtype: int64 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">axis </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s6"># Make sure we raise if an invalid 'axis' is passed.</span>
            <span class="s1">axis </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_axis_number</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">callable</span><span class="s3">(</span><span class="s1">index</span><span class="s3">) </span><span class="s2">or </span><span class="s1">is_dict_like</span><span class="s3">(</span><span class="s1">index</span><span class="s3">):</span>
            <span class="s6"># error: Argument 1 to &quot;_rename&quot; of &quot;NDFrame&quot; has incompatible</span>
            <span class="s6"># type &quot;Union[Union[Mapping[Any, Hashable], Callable[[Any],</span>
            <span class="s6"># Hashable]], Hashable, None]&quot;; expected &quot;Union[Mapping[Any,</span>
            <span class="s6"># Hashable], Callable[[Any], Hashable], None]&quot;</span>
            <span class="s2">return </span><span class="s1">super</span><span class="s3">().</span><span class="s1">_rename</span><span class="s3">(</span>
                <span class="s1">index</span><span class="s3">,  </span><span class="s6"># type: ignore[arg-type]</span>
                <span class="s1">copy</span><span class="s3">=</span><span class="s1">copy</span><span class="s3">,</span>
                <span class="s1">inplace</span><span class="s3">=</span><span class="s1">inplace</span><span class="s3">,</span>
                <span class="s1">level</span><span class="s3">=</span><span class="s1">level</span><span class="s3">,</span>
                <span class="s1">errors</span><span class="s3">=</span><span class="s1">errors</span><span class="s3">,</span>
            <span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_set_name</span><span class="s3">(</span><span class="s1">index</span><span class="s3">, </span><span class="s1">inplace</span><span class="s3">=</span><span class="s1">inplace</span><span class="s3">, </span><span class="s1">deep</span><span class="s3">=</span><span class="s1">copy</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">Appender</span><span class="s3">(</span>
        <span class="s4">&quot;&quot;&quot; 
        Examples 
        -------- 
        &gt;&gt;&gt; s = pd.Series([1, 2, 3]) 
        &gt;&gt;&gt; s 
        0    1 
        1    2 
        2    3 
        dtype: int64 
 
        &gt;&gt;&gt; s.set_axis(['a', 'b', 'c'], axis=0) 
        a    1 
        b    2 
        c    3 
        dtype: int64 
    &quot;&quot;&quot;</span>
    <span class="s3">)</span>
    <span class="s3">@</span><span class="s1">Substitution</span><span class="s3">(</span>
        <span class="s1">klass</span><span class="s3">=</span><span class="s1">_shared_doc_kwargs</span><span class="s3">[</span><span class="s4">&quot;klass&quot;</span><span class="s3">],</span>
        <span class="s1">axes_single_arg</span><span class="s3">=</span><span class="s1">_shared_doc_kwargs</span><span class="s3">[</span><span class="s4">&quot;axes_single_arg&quot;</span><span class="s3">],</span>
        <span class="s1">extended_summary_sub</span><span class="s3">=</span><span class="s4">&quot;&quot;</span><span class="s3">,</span>
        <span class="s1">axis_description_sub</span><span class="s3">=</span><span class="s4">&quot;&quot;</span><span class="s3">,</span>
        <span class="s1">see_also_sub</span><span class="s3">=</span><span class="s4">&quot;&quot;</span><span class="s3">,</span>
    <span class="s3">)</span>
    <span class="s3">@</span><span class="s1">Appender</span><span class="s3">(</span><span class="s1">NDFrame</span><span class="s3">.</span><span class="s1">set_axis</span><span class="s3">.</span><span class="s1">__doc__</span><span class="s3">)</span>
    <span class="s2">def </span><span class="s1">set_axis</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">labels</span><span class="s3">,</span>
        <span class="s3">*,</span>
        <span class="s1">axis</span><span class="s3">: </span><span class="s1">Axis </span><span class="s3">= </span><span class="s5">0</span><span class="s3">,</span>
        <span class="s1">copy</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">-&gt; Series</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">super</span><span class="s3">().</span><span class="s1">set_axis</span><span class="s3">(</span><span class="s1">labels</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s1">copy</span><span class="s3">)</span>

    <span class="s6"># error: Cannot determine type of 'reindex'</span>
    <span class="s3">@</span><span class="s1">doc</span><span class="s3">(</span>
        <span class="s1">NDFrame</span><span class="s3">.</span><span class="s1">reindex</span><span class="s3">,  </span><span class="s6"># type: ignore[has-type]</span>
        <span class="s1">klass</span><span class="s3">=</span><span class="s1">_shared_doc_kwargs</span><span class="s3">[</span><span class="s4">&quot;klass&quot;</span><span class="s3">],</span>
        <span class="s1">optional_reindex</span><span class="s3">=</span><span class="s1">_shared_doc_kwargs</span><span class="s3">[</span><span class="s4">&quot;optional_reindex&quot;</span><span class="s3">],</span>
    <span class="s3">)</span>
    <span class="s2">def </span><span class="s1">reindex</span><span class="s3">(  </span><span class="s6"># type: ignore[override]</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">index</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
        <span class="s3">*,</span>
        <span class="s1">axis</span><span class="s3">: </span><span class="s1">Axis </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">method</span><span class="s3">: </span><span class="s1">ReindexMethod </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">copy</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">level</span><span class="s3">: </span><span class="s1">Level </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">fill_value</span><span class="s3">: </span><span class="s1">Scalar </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">limit</span><span class="s3">: </span><span class="s1">int </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">tolerance</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">-&gt; Series</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">super</span><span class="s3">().</span><span class="s1">reindex</span><span class="s3">(</span>
            <span class="s1">index</span><span class="s3">=</span><span class="s1">index</span><span class="s3">,</span>
            <span class="s1">method</span><span class="s3">=</span><span class="s1">method</span><span class="s3">,</span>
            <span class="s1">copy</span><span class="s3">=</span><span class="s1">copy</span><span class="s3">,</span>
            <span class="s1">level</span><span class="s3">=</span><span class="s1">level</span><span class="s3">,</span>
            <span class="s1">fill_value</span><span class="s3">=</span><span class="s1">fill_value</span><span class="s3">,</span>
            <span class="s1">limit</span><span class="s3">=</span><span class="s1">limit</span><span class="s3">,</span>
            <span class="s1">tolerance</span><span class="s3">=</span><span class="s1">tolerance</span><span class="s3">,</span>
        <span class="s3">)</span>

    <span class="s3">@</span><span class="s1">overload  </span><span class="s6"># type: ignore[override]</span>
    <span class="s2">def </span><span class="s1">rename_axis</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">mapper</span><span class="s3">: </span><span class="s1">IndexLabel </span><span class="s3">| </span><span class="s1">lib</span><span class="s3">.</span><span class="s1">NoDefault </span><span class="s3">= ...,</span>
        <span class="s3">*,</span>
        <span class="s1">index</span><span class="s3">=...,</span>
        <span class="s1">axis</span><span class="s3">: </span><span class="s1">Axis </span><span class="s3">= ...,</span>
        <span class="s1">copy</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= ...,</span>
        <span class="s1">inplace</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s2">True</span><span class="s3">],</span>
    <span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s3">...</span>

    <span class="s3">@</span><span class="s1">overload</span>
    <span class="s2">def </span><span class="s1">rename_axis</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">mapper</span><span class="s3">: </span><span class="s1">IndexLabel </span><span class="s3">| </span><span class="s1">lib</span><span class="s3">.</span><span class="s1">NoDefault </span><span class="s3">= ...,</span>
        <span class="s3">*,</span>
        <span class="s1">index</span><span class="s3">=...,</span>
        <span class="s1">axis</span><span class="s3">: </span><span class="s1">Axis </span><span class="s3">= ...,</span>
        <span class="s1">copy</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= ...,</span>
        <span class="s1">inplace</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s2">False</span><span class="s3">] = ...,</span>
    <span class="s3">) </span><span class="s1">-&gt; Self</span><span class="s3">:</span>
        <span class="s3">...</span>

    <span class="s3">@</span><span class="s1">overload</span>
    <span class="s2">def </span><span class="s1">rename_axis</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">mapper</span><span class="s3">: </span><span class="s1">IndexLabel </span><span class="s3">| </span><span class="s1">lib</span><span class="s3">.</span><span class="s1">NoDefault </span><span class="s3">= ...,</span>
        <span class="s3">*,</span>
        <span class="s1">index</span><span class="s3">=...,</span>
        <span class="s1">axis</span><span class="s3">: </span><span class="s1">Axis </span><span class="s3">= ...,</span>
        <span class="s1">copy</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= ...,</span>
        <span class="s1">inplace</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= ...,</span>
    <span class="s3">) </span><span class="s1">-&gt; Self </span><span class="s3">| </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s3">...</span>

    <span class="s3">@</span><span class="s1">doc</span><span class="s3">(</span><span class="s1">NDFrame</span><span class="s3">.</span><span class="s1">rename_axis</span><span class="s3">)</span>
    <span class="s2">def </span><span class="s1">rename_axis</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">mapper</span><span class="s3">: </span><span class="s1">IndexLabel </span><span class="s3">| </span><span class="s1">lib</span><span class="s3">.</span><span class="s1">NoDefault </span><span class="s3">= </span><span class="s1">lib</span><span class="s3">.</span><span class="s1">no_default</span><span class="s3">,</span>
        <span class="s3">*,</span>
        <span class="s1">index</span><span class="s3">=</span><span class="s1">lib</span><span class="s3">.</span><span class="s1">no_default</span><span class="s3">,</span>
        <span class="s1">axis</span><span class="s3">: </span><span class="s1">Axis </span><span class="s3">= </span><span class="s5">0</span><span class="s3">,</span>
        <span class="s1">copy</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">True</span><span class="s3">,</span>
        <span class="s1">inplace</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">-&gt; Self </span><span class="s3">| </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">super</span><span class="s3">().</span><span class="s1">rename_axis</span><span class="s3">(</span>
            <span class="s1">mapper</span><span class="s3">=</span><span class="s1">mapper</span><span class="s3">,</span>
            <span class="s1">index</span><span class="s3">=</span><span class="s1">index</span><span class="s3">,</span>
            <span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">,</span>
            <span class="s1">copy</span><span class="s3">=</span><span class="s1">copy</span><span class="s3">,</span>
            <span class="s1">inplace</span><span class="s3">=</span><span class="s1">inplace</span><span class="s3">,</span>
        <span class="s3">)</span>

    <span class="s3">@</span><span class="s1">overload</span>
    <span class="s2">def </span><span class="s1">drop</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">labels</span><span class="s3">: </span><span class="s1">IndexLabel </span><span class="s3">= ...,</span>
        <span class="s3">*,</span>
        <span class="s1">axis</span><span class="s3">: </span><span class="s1">Axis </span><span class="s3">= ...,</span>
        <span class="s1">index</span><span class="s3">: </span><span class="s1">IndexLabel </span><span class="s3">= ...,</span>
        <span class="s1">columns</span><span class="s3">: </span><span class="s1">IndexLabel </span><span class="s3">= ...,</span>
        <span class="s1">level</span><span class="s3">: </span><span class="s1">Level </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= ...,</span>
        <span class="s1">inplace</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s2">True</span><span class="s3">],</span>
        <span class="s1">errors</span><span class="s3">: </span><span class="s1">IgnoreRaise </span><span class="s3">= ...,</span>
    <span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s3">...</span>

    <span class="s3">@</span><span class="s1">overload</span>
    <span class="s2">def </span><span class="s1">drop</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">labels</span><span class="s3">: </span><span class="s1">IndexLabel </span><span class="s3">= ...,</span>
        <span class="s3">*,</span>
        <span class="s1">axis</span><span class="s3">: </span><span class="s1">Axis </span><span class="s3">= ...,</span>
        <span class="s1">index</span><span class="s3">: </span><span class="s1">IndexLabel </span><span class="s3">= ...,</span>
        <span class="s1">columns</span><span class="s3">: </span><span class="s1">IndexLabel </span><span class="s3">= ...,</span>
        <span class="s1">level</span><span class="s3">: </span><span class="s1">Level </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= ...,</span>
        <span class="s1">inplace</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s2">False</span><span class="s3">] = ...,</span>
        <span class="s1">errors</span><span class="s3">: </span><span class="s1">IgnoreRaise </span><span class="s3">= ...,</span>
    <span class="s3">) </span><span class="s1">-&gt; Series</span><span class="s3">:</span>
        <span class="s3">...</span>

    <span class="s3">@</span><span class="s1">overload</span>
    <span class="s2">def </span><span class="s1">drop</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">labels</span><span class="s3">: </span><span class="s1">IndexLabel </span><span class="s3">= ...,</span>
        <span class="s3">*,</span>
        <span class="s1">axis</span><span class="s3">: </span><span class="s1">Axis </span><span class="s3">= ...,</span>
        <span class="s1">index</span><span class="s3">: </span><span class="s1">IndexLabel </span><span class="s3">= ...,</span>
        <span class="s1">columns</span><span class="s3">: </span><span class="s1">IndexLabel </span><span class="s3">= ...,</span>
        <span class="s1">level</span><span class="s3">: </span><span class="s1">Level </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= ...,</span>
        <span class="s1">inplace</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= ...,</span>
        <span class="s1">errors</span><span class="s3">: </span><span class="s1">IgnoreRaise </span><span class="s3">= ...,</span>
    <span class="s3">) </span><span class="s1">-&gt; Series </span><span class="s3">| </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s3">...</span>

    <span class="s2">def </span><span class="s1">drop</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">labels</span><span class="s3">: </span><span class="s1">IndexLabel </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s3">*,</span>
        <span class="s1">axis</span><span class="s3">: </span><span class="s1">Axis </span><span class="s3">= </span><span class="s5">0</span><span class="s3">,</span>
        <span class="s1">index</span><span class="s3">: </span><span class="s1">IndexLabel </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">columns</span><span class="s3">: </span><span class="s1">IndexLabel </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">level</span><span class="s3">: </span><span class="s1">Level </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">inplace</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span><span class="s3">,</span>
        <span class="s1">errors</span><span class="s3">: </span><span class="s1">IgnoreRaise </span><span class="s3">= </span><span class="s4">&quot;raise&quot;</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">-&gt; Series </span><span class="s3">| </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Return Series with specified index labels removed. 
 
        Remove elements of a Series based on specifying the index labels. 
        When using a multi-index, labels on different levels can be removed 
        by specifying the level. 
 
        Parameters 
        ---------- 
        labels : single label or list-like 
            Index labels to drop. 
        axis : {0 or 'index'} 
            Unused. Parameter needed for compatibility with DataFrame. 
        index : single label or list-like 
            Redundant for application on Series, but 'index' can be used instead 
            of 'labels'. 
        columns : single label or list-like 
            No change is made to the Series; use 'index' or 'labels' instead. 
        level : int or level name, optional 
            For MultiIndex, level for which the labels will be removed. 
        inplace : bool, default False 
            If True, do operation inplace and return None. 
        errors : {'ignore', 'raise'}, default 'raise' 
            If 'ignore', suppress error and only existing labels are dropped. 
 
        Returns 
        ------- 
        Series or None 
            Series with specified index labels removed or None if ``inplace=True``. 
 
        Raises 
        ------ 
        KeyError 
            If none of the labels are found in the index. 
 
        See Also 
        -------- 
        Series.reindex : Return only specified index labels of Series. 
        Series.dropna : Return series without null values. 
        Series.drop_duplicates : Return Series with duplicate values removed. 
        DataFrame.drop : Drop specified labels from rows or columns. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; s = pd.Series(data=np.arange(3), index=['A', 'B', 'C']) 
        &gt;&gt;&gt; s 
        A  0 
        B  1 
        C  2 
        dtype: int64 
 
        Drop labels B en C 
 
        &gt;&gt;&gt; s.drop(labels=['B', 'C']) 
        A  0 
        dtype: int64 
 
        Drop 2nd level label in MultiIndex Series 
 
        &gt;&gt;&gt; midx = pd.MultiIndex(levels=[['llama', 'cow', 'falcon'], 
        ...                              ['speed', 'weight', 'length']], 
        ...                      codes=[[0, 0, 0, 1, 1, 1, 2, 2, 2], 
        ...                             [0, 1, 2, 0, 1, 2, 0, 1, 2]]) 
        &gt;&gt;&gt; s = pd.Series([45, 200, 1.2, 30, 250, 1.5, 320, 1, 0.3], 
        ...               index=midx) 
        &gt;&gt;&gt; s 
        llama   speed      45.0 
                weight    200.0 
                length      1.2 
        cow     speed      30.0 
                weight    250.0 
                length      1.5 
        falcon  speed     320.0 
                weight      1.0 
                length      0.3 
        dtype: float64 
 
        &gt;&gt;&gt; s.drop(labels='weight', level=1) 
        llama   speed      45.0 
                length      1.2 
        cow     speed      30.0 
                length      1.5 
        falcon  speed     320.0 
                length      0.3 
        dtype: float64 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">super</span><span class="s3">().</span><span class="s1">drop</span><span class="s3">(</span>
            <span class="s1">labels</span><span class="s3">=</span><span class="s1">labels</span><span class="s3">,</span>
            <span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">,</span>
            <span class="s1">index</span><span class="s3">=</span><span class="s1">index</span><span class="s3">,</span>
            <span class="s1">columns</span><span class="s3">=</span><span class="s1">columns</span><span class="s3">,</span>
            <span class="s1">level</span><span class="s3">=</span><span class="s1">level</span><span class="s3">,</span>
            <span class="s1">inplace</span><span class="s3">=</span><span class="s1">inplace</span><span class="s3">,</span>
            <span class="s1">errors</span><span class="s3">=</span><span class="s1">errors</span><span class="s3">,</span>
        <span class="s3">)</span>

    <span class="s2">def </span><span class="s1">pop</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">item</span><span class="s3">: </span><span class="s1">Hashable</span><span class="s3">) </span><span class="s1">-&gt; Any</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Return item and drops from series. Raise KeyError if not found. 
 
        Parameters 
        ---------- 
        item : label 
            Index of the element that needs to be removed. 
 
        Returns 
        ------- 
        Value that is popped from series. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; ser = pd.Series([1, 2, 3]) 
 
        &gt;&gt;&gt; ser.pop(0) 
        1 
 
        &gt;&gt;&gt; ser 
        1    2 
        2    3 
        dtype: int64 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">super</span><span class="s3">().</span><span class="s1">pop</span><span class="s3">(</span><span class="s1">item</span><span class="s3">=</span><span class="s1">item</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">doc</span><span class="s3">(</span><span class="s1">INFO_DOCSTRING</span><span class="s3">, **</span><span class="s1">series_sub_kwargs</span><span class="s3">)</span>
    <span class="s2">def </span><span class="s1">info</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">verbose</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">buf</span><span class="s3">: </span><span class="s1">IO</span><span class="s3">[</span><span class="s1">str</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">max_cols</span><span class="s3">: </span><span class="s1">int </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">memory_usage</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">show_counts</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">True</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">SeriesInfo</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">memory_usage</span><span class="s3">).</span><span class="s1">render</span><span class="s3">(</span>
            <span class="s1">buf</span><span class="s3">=</span><span class="s1">buf</span><span class="s3">,</span>
            <span class="s1">max_cols</span><span class="s3">=</span><span class="s1">max_cols</span><span class="s3">,</span>
            <span class="s1">verbose</span><span class="s3">=</span><span class="s1">verbose</span><span class="s3">,</span>
            <span class="s1">show_counts</span><span class="s3">=</span><span class="s1">show_counts</span><span class="s3">,</span>
        <span class="s3">)</span>

    <span class="s6"># TODO(3.0): this can be removed once GH#33302 deprecation is enforced</span>
    <span class="s2">def </span><span class="s1">_replace_single</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">to_replace</span><span class="s3">, </span><span class="s1">method</span><span class="s3">: </span><span class="s1">str</span><span class="s3">, </span><span class="s1">inplace</span><span class="s3">: </span><span class="s1">bool</span><span class="s3">, </span><span class="s1">limit</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Replaces values in a Series using the fill method specified when no 
        replacement value is given in the replace method 
        &quot;&quot;&quot;</span>

        <span class="s1">result </span><span class="s3">= </span><span class="s1">self </span><span class="s2">if </span><span class="s1">inplace </span><span class="s2">else </span><span class="s1">self</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>

        <span class="s1">values </span><span class="s3">= </span><span class="s1">result</span><span class="s3">.</span><span class="s1">_values</span>
        <span class="s1">mask </span><span class="s3">= </span><span class="s1">missing</span><span class="s3">.</span><span class="s1">mask_missing</span><span class="s3">(</span><span class="s1">values</span><span class="s3">, </span><span class="s1">to_replace</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">values</span><span class="s3">, </span><span class="s1">ExtensionArray</span><span class="s3">):</span>
            <span class="s6"># dispatch to the EA's _pad_mask_inplace method</span>
            <span class="s1">values</span><span class="s3">.</span><span class="s1">_fill_mask_inplace</span><span class="s3">(</span><span class="s1">method</span><span class="s3">, </span><span class="s1">limit</span><span class="s3">, </span><span class="s1">mask</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">fill_f </span><span class="s3">= </span><span class="s1">missing</span><span class="s3">.</span><span class="s1">get_fill_func</span><span class="s3">(</span><span class="s1">method</span><span class="s3">)</span>
            <span class="s1">fill_f</span><span class="s3">(</span><span class="s1">values</span><span class="s3">, </span><span class="s1">limit</span><span class="s3">=</span><span class="s1">limit</span><span class="s3">, </span><span class="s1">mask</span><span class="s3">=</span><span class="s1">mask</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">inplace</span><span class="s3">:</span>
            <span class="s2">return</span>
        <span class="s2">return </span><span class="s1">result</span>

    <span class="s2">def </span><span class="s1">memory_usage</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">index</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">True</span><span class="s3">, </span><span class="s1">deep</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span><span class="s3">) </span><span class="s1">-&gt; int</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the memory usage of the Series. 
 
        The memory usage can optionally include the contribution of 
        the index and of elements of `object` dtype. 
 
        Parameters 
        ---------- 
        index : bool, default True 
            Specifies whether to include the memory usage of the Series index. 
        deep : bool, default False 
            If True, introspect the data deeply by interrogating 
            `object` dtypes for system-level memory consumption, and include 
            it in the returned value. 
 
        Returns 
        ------- 
        int 
            Bytes of memory consumed. 
 
        See Also 
        -------- 
        numpy.ndarray.nbytes : Total bytes consumed by the elements of the 
            array. 
        DataFrame.memory_usage : Bytes consumed by a DataFrame. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; s = pd.Series(range(3)) 
        &gt;&gt;&gt; s.memory_usage() 
        152 
 
        Not including the index gives the size of the rest of the data, which 
        is necessarily smaller: 
 
        &gt;&gt;&gt; s.memory_usage(index=False) 
        24 
 
        The memory footprint of `object` values is ignored by default: 
 
        &gt;&gt;&gt; s = pd.Series([&quot;a&quot;, &quot;b&quot;]) 
        &gt;&gt;&gt; s.values 
        array(['a', 'b'], dtype=object) 
        &gt;&gt;&gt; s.memory_usage() 
        144 
        &gt;&gt;&gt; s.memory_usage(deep=True) 
        244 
        &quot;&quot;&quot;</span>
        <span class="s1">v </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_memory_usage</span><span class="s3">(</span><span class="s1">deep</span><span class="s3">=</span><span class="s1">deep</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">index</span><span class="s3">:</span>
            <span class="s1">v </span><span class="s3">+= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">index</span><span class="s3">.</span><span class="s1">memory_usage</span><span class="s3">(</span><span class="s1">deep</span><span class="s3">=</span><span class="s1">deep</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">v</span>

    <span class="s2">def </span><span class="s1">isin</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">values</span><span class="s3">) </span><span class="s1">-&gt; Series</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Whether elements in Series are contained in `values`. 
 
        Return a boolean Series showing whether each element in the Series 
        matches an element in the passed sequence of `values` exactly. 
 
        Parameters 
        ---------- 
        values : set or list-like 
            The sequence of values to test. Passing in a single string will 
            raise a ``TypeError``. Instead, turn a single string into a 
            list of one element. 
 
        Returns 
        ------- 
        Series 
            Series of booleans indicating if each element is in values. 
 
        Raises 
        ------ 
        TypeError 
          * If `values` is a string 
 
        See Also 
        -------- 
        DataFrame.isin : Equivalent method on DataFrame. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; s = pd.Series(['llama', 'cow', 'llama', 'beetle', 'llama', 
        ...                'hippo'], name='animal') 
        &gt;&gt;&gt; s.isin(['cow', 'llama']) 
        0     True 
        1     True 
        2     True 
        3    False 
        4     True 
        5    False 
        Name: animal, dtype: bool 
 
        To invert the boolean values, use the ``~`` operator: 
 
        &gt;&gt;&gt; ~s.isin(['cow', 'llama']) 
        0    False 
        1    False 
        2    False 
        3     True 
        4    False 
        5     True 
        Name: animal, dtype: bool 
 
        Passing a single string as ``s.isin('llama')`` will raise an error. Use 
        a list of one element instead: 
 
        &gt;&gt;&gt; s.isin(['llama']) 
        0     True 
        1    False 
        2     True 
        3    False 
        4     True 
        5    False 
        Name: animal, dtype: bool 
 
        Strings and integers are distinct and are therefore not comparable: 
 
        &gt;&gt;&gt; pd.Series([1]).isin(['1']) 
        0    False 
        dtype: bool 
        &gt;&gt;&gt; pd.Series([1.1]).isin(['1.1']) 
        0    False 
        dtype: bool 
        &quot;&quot;&quot;</span>
        <span class="s1">result </span><span class="s3">= </span><span class="s1">algorithms</span><span class="s3">.</span><span class="s1">isin</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_values</span><span class="s3">, </span><span class="s1">values</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_constructor</span><span class="s3">(</span><span class="s1">result</span><span class="s3">, </span><span class="s1">index</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">index</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">False</span><span class="s3">).</span><span class="s1">__finalize__</span><span class="s3">(</span>
            <span class="s1">self</span><span class="s3">, </span><span class="s1">method</span><span class="s3">=</span><span class="s4">&quot;isin&quot;</span>
        <span class="s3">)</span>

    <span class="s2">def </span><span class="s1">between</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">left</span><span class="s3">,</span>
        <span class="s1">right</span><span class="s3">,</span>
        <span class="s1">inclusive</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s4">&quot;both&quot;</span><span class="s3">, </span><span class="s4">&quot;neither&quot;</span><span class="s3">, </span><span class="s4">&quot;left&quot;</span><span class="s3">, </span><span class="s4">&quot;right&quot;</span><span class="s3">] = </span><span class="s4">&quot;both&quot;</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">-&gt; Series</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Return boolean Series equivalent to left &lt;= series &lt;= right. 
 
        This function returns a boolean vector containing `True` wherever the 
        corresponding Series element is between the boundary values `left` and 
        `right`. NA values are treated as `False`. 
 
        Parameters 
        ---------- 
        left : scalar or list-like 
            Left boundary. 
        right : scalar or list-like 
            Right boundary. 
        inclusive : {&quot;both&quot;, &quot;neither&quot;, &quot;left&quot;, &quot;right&quot;} 
            Include boundaries. Whether to set each bound as closed or open. 
 
            .. versionchanged:: 1.3.0 
 
        Returns 
        ------- 
        Series 
            Series representing whether each element is between left and 
            right (inclusive). 
 
        See Also 
        -------- 
        Series.gt : Greater than of series and other. 
        Series.lt : Less than of series and other. 
 
        Notes 
        ----- 
        This function is equivalent to ``(left &lt;= ser) &amp; (ser &lt;= right)`` 
 
        Examples 
        -------- 
        &gt;&gt;&gt; s = pd.Series([2, 0, 4, 8, np.nan]) 
 
        Boundary values are included by default: 
 
        &gt;&gt;&gt; s.between(1, 4) 
        0     True 
        1    False 
        2     True 
        3    False 
        4    False 
        dtype: bool 
 
        With `inclusive` set to ``&quot;neither&quot;`` boundary values are excluded: 
 
        &gt;&gt;&gt; s.between(1, 4, inclusive=&quot;neither&quot;) 
        0     True 
        1    False 
        2    False 
        3    False 
        4    False 
        dtype: bool 
 
        `left` and `right` can be any scalar value: 
 
        &gt;&gt;&gt; s = pd.Series(['Alice', 'Bob', 'Carol', 'Eve']) 
        &gt;&gt;&gt; s.between('Anna', 'Daniel') 
        0    False 
        1     True 
        2     True 
        3    False 
        dtype: bool 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">inclusive </span><span class="s3">== </span><span class="s4">&quot;both&quot;</span><span class="s3">:</span>
            <span class="s1">lmask </span><span class="s3">= </span><span class="s1">self </span><span class="s3">&gt;= </span><span class="s1">left</span>
            <span class="s1">rmask </span><span class="s3">= </span><span class="s1">self </span><span class="s3">&lt;= </span><span class="s1">right</span>
        <span class="s2">elif </span><span class="s1">inclusive </span><span class="s3">== </span><span class="s4">&quot;left&quot;</span><span class="s3">:</span>
            <span class="s1">lmask </span><span class="s3">= </span><span class="s1">self </span><span class="s3">&gt;= </span><span class="s1">left</span>
            <span class="s1">rmask </span><span class="s3">= </span><span class="s1">self </span><span class="s3">&lt; </span><span class="s1">right</span>
        <span class="s2">elif </span><span class="s1">inclusive </span><span class="s3">== </span><span class="s4">&quot;right&quot;</span><span class="s3">:</span>
            <span class="s1">lmask </span><span class="s3">= </span><span class="s1">self </span><span class="s3">&gt; </span><span class="s1">left</span>
            <span class="s1">rmask </span><span class="s3">= </span><span class="s1">self </span><span class="s3">&lt;= </span><span class="s1">right</span>
        <span class="s2">elif </span><span class="s1">inclusive </span><span class="s3">== </span><span class="s4">&quot;neither&quot;</span><span class="s3">:</span>
            <span class="s1">lmask </span><span class="s3">= </span><span class="s1">self </span><span class="s3">&gt; </span><span class="s1">left</span>
            <span class="s1">rmask </span><span class="s3">= </span><span class="s1">self </span><span class="s3">&lt; </span><span class="s1">right</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span>
                <span class="s4">&quot;Inclusive has to be either string of 'both',&quot;</span>
                <span class="s4">&quot;'left', 'right', or 'neither'.&quot;</span>
            <span class="s3">)</span>

        <span class="s2">return </span><span class="s1">lmask </span><span class="s3">&amp; </span><span class="s1">rmask</span>

    <span class="s2">def </span><span class="s1">case_when</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">caselist</span><span class="s3">: </span><span class="s1">list</span><span class="s3">[</span>
            <span class="s1">tuple</span><span class="s3">[</span>
                <span class="s1">ArrayLike </span><span class="s3">| </span><span class="s1">Callable</span><span class="s3">[[</span><span class="s1">Series</span><span class="s3">], </span><span class="s1">Series </span><span class="s3">| </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndarray </span><span class="s3">| </span><span class="s1">Sequence</span><span class="s3">[</span><span class="s1">bool</span><span class="s3">]],</span>
                <span class="s1">ArrayLike </span><span class="s3">| </span><span class="s1">Scalar </span><span class="s3">| </span><span class="s1">Callable</span><span class="s3">[[</span><span class="s1">Series</span><span class="s3">], </span><span class="s1">Series </span><span class="s3">| </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndarray</span><span class="s3">],</span>
            <span class="s3">],</span>
        <span class="s3">],</span>
    <span class="s3">) </span><span class="s1">-&gt; Series</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Replace values where the conditions are True. 
 
        Parameters 
        ---------- 
        caselist : A list of tuples of conditions and expected replacements 
            Takes the form:  ``(condition0, replacement0)``, 
            ``(condition1, replacement1)``, ... . 
            ``condition`` should be a 1-D boolean array-like object 
            or a callable. If ``condition`` is a callable, 
            it is computed on the Series 
            and should return a boolean Series or array. 
            The callable must not change the input Series 
            (though pandas doesn`t check it). ``replacement`` should be a 
            1-D array-like object, a scalar or a callable. 
            If ``replacement`` is a callable, it is computed on the Series 
            and should return a scalar or Series. The callable 
            must not change the input Series 
            (though pandas doesn`t check it). 
 
            .. versionadded:: 2.2.0 
 
        Returns 
        ------- 
        Series 
 
        See Also 
        -------- 
        Series.mask : Replace values where the condition is True. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; c = pd.Series([6, 7, 8, 9], name='c') 
        &gt;&gt;&gt; a = pd.Series([0, 0, 1, 2]) 
        &gt;&gt;&gt; b = pd.Series([0, 3, 4, 5]) 
 
        &gt;&gt;&gt; c.case_when(caselist=[(a.gt(0), a),  # condition, replacement 
        ...                       (b.gt(0), b)]) 
        0    6 
        1    3 
        2    1 
        3    2 
        Name: c, dtype: int64 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">caselist</span><span class="s3">, </span><span class="s1">list</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span>
                <span class="s4">f&quot;The caselist argument should be a list; instead got </span><span class="s2">{</span><span class="s1">type</span><span class="s3">(</span><span class="s1">caselist</span><span class="s3">)</span><span class="s2">}</span><span class="s4">&quot;</span>
            <span class="s3">)</span>

        <span class="s2">if not </span><span class="s1">caselist</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span>
                <span class="s4">&quot;provide at least one boolean condition, &quot;</span>
                <span class="s4">&quot;with a corresponding replacement.&quot;</span>
            <span class="s3">)</span>

        <span class="s2">for </span><span class="s1">num</span><span class="s3">, </span><span class="s1">entry </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">caselist</span><span class="s3">):</span>
            <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">entry</span><span class="s3">, </span><span class="s1">tuple</span><span class="s3">):</span>
                <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span>
                    <span class="s4">f&quot;Argument </span><span class="s2">{</span><span class="s1">num</span><span class="s2">} </span><span class="s4">must be a tuple; instead got </span><span class="s2">{</span><span class="s1">type</span><span class="s3">(</span><span class="s1">entry</span><span class="s3">)</span><span class="s2">}</span><span class="s4">.&quot;</span>
                <span class="s3">)</span>
            <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">entry</span><span class="s3">) != </span><span class="s5">2</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span>
                    <span class="s4">f&quot;Argument </span><span class="s2">{</span><span class="s1">num</span><span class="s2">} </span><span class="s4">must have length 2; &quot;</span>
                    <span class="s4">&quot;a condition and replacement; &quot;</span>
                    <span class="s4">f&quot;instead got length </span><span class="s2">{</span><span class="s1">len</span><span class="s3">(</span><span class="s1">entry</span><span class="s3">)</span><span class="s2">}</span><span class="s4">.&quot;</span>
                <span class="s3">)</span>
        <span class="s1">caselist </span><span class="s3">= [</span>
            <span class="s3">(</span>
                <span class="s1">com</span><span class="s3">.</span><span class="s1">apply_if_callable</span><span class="s3">(</span><span class="s1">condition</span><span class="s3">, </span><span class="s1">self</span><span class="s3">),</span>
                <span class="s1">com</span><span class="s3">.</span><span class="s1">apply_if_callable</span><span class="s3">(</span><span class="s1">replacement</span><span class="s3">, </span><span class="s1">self</span><span class="s3">),</span>
            <span class="s3">)</span>
            <span class="s2">for </span><span class="s1">condition</span><span class="s3">, </span><span class="s1">replacement </span><span class="s2">in </span><span class="s1">caselist</span>
        <span class="s3">]</span>
        <span class="s1">default </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>
        <span class="s1">conditions</span><span class="s3">, </span><span class="s1">replacements </span><span class="s3">= </span><span class="s1">zip</span><span class="s3">(*</span><span class="s1">caselist</span><span class="s3">)</span>
        <span class="s1">common_dtypes </span><span class="s3">= [</span><span class="s1">infer_dtype_from</span><span class="s3">(</span><span class="s1">arg</span><span class="s3">)[</span><span class="s5">0</span><span class="s3">] </span><span class="s2">for </span><span class="s1">arg </span><span class="s2">in </span><span class="s3">[*</span><span class="s1">replacements</span><span class="s3">, </span><span class="s1">default</span><span class="s3">]]</span>
        <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">set</span><span class="s3">(</span><span class="s1">common_dtypes</span><span class="s3">)) &gt; </span><span class="s5">1</span><span class="s3">:</span>
            <span class="s1">common_dtype </span><span class="s3">= </span><span class="s1">find_common_type</span><span class="s3">(</span><span class="s1">common_dtypes</span><span class="s3">)</span>
            <span class="s1">updated_replacements </span><span class="s3">= []</span>
            <span class="s2">for </span><span class="s1">condition</span><span class="s3">, </span><span class="s1">replacement </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">conditions</span><span class="s3">, </span><span class="s1">replacements</span><span class="s3">):</span>
                <span class="s2">if </span><span class="s1">is_scalar</span><span class="s3">(</span><span class="s1">replacement</span><span class="s3">):</span>
                    <span class="s1">replacement </span><span class="s3">= </span><span class="s1">construct_1d_arraylike_from_scalar</span><span class="s3">(</span>
                        <span class="s1">value</span><span class="s3">=</span><span class="s1">replacement</span><span class="s3">, </span><span class="s1">length</span><span class="s3">=</span><span class="s1">len</span><span class="s3">(</span><span class="s1">condition</span><span class="s3">), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">common_dtype</span>
                    <span class="s3">)</span>
                <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">replacement</span><span class="s3">, </span><span class="s1">ABCSeries</span><span class="s3">):</span>
                    <span class="s1">replacement </span><span class="s3">= </span><span class="s1">replacement</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">common_dtype</span><span class="s3">)</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">replacement </span><span class="s3">= </span><span class="s1">pd_array</span><span class="s3">(</span><span class="s1">replacement</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">common_dtype</span><span class="s3">)</span>
                <span class="s1">updated_replacements</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">replacement</span><span class="s3">)</span>
            <span class="s1">replacements </span><span class="s3">= </span><span class="s1">updated_replacements</span>
            <span class="s1">default </span><span class="s3">= </span><span class="s1">default</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">common_dtype</span><span class="s3">)</span>

        <span class="s1">counter </span><span class="s3">= </span><span class="s1">reversed</span><span class="s3">(</span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">conditions</span><span class="s3">)))</span>
        <span class="s2">for </span><span class="s1">position</span><span class="s3">, </span><span class="s1">condition</span><span class="s3">, </span><span class="s1">replacement </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span>
            <span class="s1">counter</span><span class="s3">, </span><span class="s1">conditions</span><span class="s3">[::-</span><span class="s5">1</span><span class="s3">], </span><span class="s1">replacements</span><span class="s3">[::-</span><span class="s5">1</span><span class="s3">]</span>
        <span class="s3">):</span>
            <span class="s2">try</span><span class="s3">:</span>
                <span class="s1">default </span><span class="s3">= </span><span class="s1">default</span><span class="s3">.</span><span class="s1">mask</span><span class="s3">(</span>
                    <span class="s1">condition</span><span class="s3">, </span><span class="s1">other</span><span class="s3">=</span><span class="s1">replacement</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">inplace</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">level</span><span class="s3">=</span><span class="s2">None</span>
                <span class="s3">)</span>
            <span class="s2">except </span><span class="s1">Exception </span><span class="s2">as </span><span class="s1">error</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span>
                    <span class="s4">f&quot;Failed to apply condition</span><span class="s2">{</span><span class="s1">position</span><span class="s2">} </span><span class="s4">and replacement</span><span class="s2">{</span><span class="s1">position</span><span class="s2">}</span><span class="s4">.&quot;</span>
                <span class="s3">) </span><span class="s2">from </span><span class="s1">error</span>
        <span class="s2">return </span><span class="s1">default</span>

    <span class="s6"># error: Cannot determine type of 'isna'</span>
    <span class="s3">@</span><span class="s1">doc</span><span class="s3">(</span><span class="s1">NDFrame</span><span class="s3">.</span><span class="s1">isna</span><span class="s3">, </span><span class="s1">klass</span><span class="s3">=</span><span class="s1">_shared_doc_kwargs</span><span class="s3">[</span><span class="s4">&quot;klass&quot;</span><span class="s3">])  </span><span class="s6"># type: ignore[has-type]</span>
    <span class="s2">def </span><span class="s1">isna</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; Series</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">NDFrame</span><span class="s3">.</span><span class="s1">isna</span><span class="s3">(</span><span class="s1">self</span><span class="s3">)</span>

    <span class="s6"># error: Cannot determine type of 'isna'</span>
    <span class="s3">@</span><span class="s1">doc</span><span class="s3">(</span><span class="s1">NDFrame</span><span class="s3">.</span><span class="s1">isna</span><span class="s3">, </span><span class="s1">klass</span><span class="s3">=</span><span class="s1">_shared_doc_kwargs</span><span class="s3">[</span><span class="s4">&quot;klass&quot;</span><span class="s3">])  </span><span class="s6"># type: ignore[has-type]</span>
    <span class="s2">def </span><span class="s1">isnull</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; Series</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Series.isnull is an alias for Series.isna. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">super</span><span class="s3">().</span><span class="s1">isnull</span><span class="s3">()</span>

    <span class="s6"># error: Cannot determine type of 'notna'</span>
    <span class="s3">@</span><span class="s1">doc</span><span class="s3">(</span><span class="s1">NDFrame</span><span class="s3">.</span><span class="s1">notna</span><span class="s3">, </span><span class="s1">klass</span><span class="s3">=</span><span class="s1">_shared_doc_kwargs</span><span class="s3">[</span><span class="s4">&quot;klass&quot;</span><span class="s3">])  </span><span class="s6"># type: ignore[has-type]</span>
    <span class="s2">def </span><span class="s1">notna</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; Series</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">super</span><span class="s3">().</span><span class="s1">notna</span><span class="s3">()</span>

    <span class="s6"># error: Cannot determine type of 'notna'</span>
    <span class="s3">@</span><span class="s1">doc</span><span class="s3">(</span><span class="s1">NDFrame</span><span class="s3">.</span><span class="s1">notna</span><span class="s3">, </span><span class="s1">klass</span><span class="s3">=</span><span class="s1">_shared_doc_kwargs</span><span class="s3">[</span><span class="s4">&quot;klass&quot;</span><span class="s3">])  </span><span class="s6"># type: ignore[has-type]</span>
    <span class="s2">def </span><span class="s1">notnull</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; Series</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Series.notnull is an alias for Series.notna. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">super</span><span class="s3">().</span><span class="s1">notnull</span><span class="s3">()</span>

    <span class="s3">@</span><span class="s1">overload</span>
    <span class="s2">def </span><span class="s1">dropna</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s3">*,</span>
        <span class="s1">axis</span><span class="s3">: </span><span class="s1">Axis </span><span class="s3">= ...,</span>
        <span class="s1">inplace</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s2">False</span><span class="s3">] = ...,</span>
        <span class="s1">how</span><span class="s3">: </span><span class="s1">AnyAll </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= ...,</span>
        <span class="s1">ignore_index</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= ...,</span>
    <span class="s3">) </span><span class="s1">-&gt; Series</span><span class="s3">:</span>
        <span class="s3">...</span>

    <span class="s3">@</span><span class="s1">overload</span>
    <span class="s2">def </span><span class="s1">dropna</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s3">*,</span>
        <span class="s1">axis</span><span class="s3">: </span><span class="s1">Axis </span><span class="s3">= ...,</span>
        <span class="s1">inplace</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s2">True</span><span class="s3">],</span>
        <span class="s1">how</span><span class="s3">: </span><span class="s1">AnyAll </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= ...,</span>
        <span class="s1">ignore_index</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= ...,</span>
    <span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s3">...</span>

    <span class="s2">def </span><span class="s1">dropna</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s3">*,</span>
        <span class="s1">axis</span><span class="s3">: </span><span class="s1">Axis </span><span class="s3">= </span><span class="s5">0</span><span class="s3">,</span>
        <span class="s1">inplace</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span><span class="s3">,</span>
        <span class="s1">how</span><span class="s3">: </span><span class="s1">AnyAll </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">ignore_index</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">-&gt; Series </span><span class="s3">| </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Return a new Series with missing values removed. 
 
        See the :ref:`User Guide &lt;missing_data&gt;` for more on which values are 
        considered missing, and how to work with missing data. 
 
        Parameters 
        ---------- 
        axis : {0 or 'index'} 
            Unused. Parameter needed for compatibility with DataFrame. 
        inplace : bool, default False 
            If True, do operation inplace and return None. 
        how : str, optional 
            Not in use. Kept for compatibility. 
        ignore_index : bool, default ``False`` 
            If ``True``, the resulting axis will be labeled 0, 1, …, n - 1. 
 
            .. versionadded:: 2.0.0 
 
        Returns 
        ------- 
        Series or None 
            Series with NA entries dropped from it or None if ``inplace=True``. 
 
        See Also 
        -------- 
        Series.isna: Indicate missing values. 
        Series.notna : Indicate existing (non-missing) values. 
        Series.fillna : Replace missing values. 
        DataFrame.dropna : Drop rows or columns which contain NA values. 
        Index.dropna : Drop missing indices. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; ser = pd.Series([1., 2., np.nan]) 
        &gt;&gt;&gt; ser 
        0    1.0 
        1    2.0 
        2    NaN 
        dtype: float64 
 
        Drop NA values from a Series. 
 
        &gt;&gt;&gt; ser.dropna() 
        0    1.0 
        1    2.0 
        dtype: float64 
 
        Empty strings are not considered NA values. ``None`` is considered an 
        NA value. 
 
        &gt;&gt;&gt; ser = pd.Series([np.nan, 2, pd.NaT, '', None, 'I stay']) 
        &gt;&gt;&gt; ser 
        0       NaN 
        1         2 
        2       NaT 
        3 
        4      None 
        5    I stay 
        dtype: object 
        &gt;&gt;&gt; ser.dropna() 
        1         2 
        3 
        5    I stay 
        dtype: object 
        &quot;&quot;&quot;</span>
        <span class="s1">inplace </span><span class="s3">= </span><span class="s1">validate_bool_kwarg</span><span class="s3">(</span><span class="s1">inplace</span><span class="s3">, </span><span class="s4">&quot;inplace&quot;</span><span class="s3">)</span>
        <span class="s1">ignore_index </span><span class="s3">= </span><span class="s1">validate_bool_kwarg</span><span class="s3">(</span><span class="s1">ignore_index</span><span class="s3">, </span><span class="s4">&quot;ignore_index&quot;</span><span class="s3">)</span>
        <span class="s6"># Validate the axis parameter</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_get_axis_number</span><span class="s3">(</span><span class="s1">axis </span><span class="s2">or </span><span class="s5">0</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_can_hold_na</span><span class="s3">:</span>
            <span class="s1">result </span><span class="s3">= </span><span class="s1">remove_na_arraylike</span><span class="s3">(</span><span class="s1">self</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">if not </span><span class="s1">inplace</span><span class="s3">:</span>
                <span class="s1">result </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">(</span><span class="s1">deep</span><span class="s3">=</span><span class="s2">None</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">result </span><span class="s3">= </span><span class="s1">self</span>

        <span class="s2">if </span><span class="s1">ignore_index</span><span class="s3">:</span>
            <span class="s1">result</span><span class="s3">.</span><span class="s1">index </span><span class="s3">= </span><span class="s1">default_index</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">result</span><span class="s3">))</span>

        <span class="s2">if </span><span class="s1">inplace</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_update_inplace</span><span class="s3">(</span><span class="s1">result</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">result</span>

    <span class="s6"># ----------------------------------------------------------------------</span>
    <span class="s6"># Time series-oriented methods</span>

    <span class="s2">def </span><span class="s1">to_timestamp</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">freq</span><span class="s3">: </span><span class="s1">Frequency </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">how</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s4">&quot;s&quot;</span><span class="s3">, </span><span class="s4">&quot;e&quot;</span><span class="s3">, </span><span class="s4">&quot;start&quot;</span><span class="s3">, </span><span class="s4">&quot;end&quot;</span><span class="s3">] = </span><span class="s4">&quot;start&quot;</span><span class="s3">,</span>
        <span class="s1">copy</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">-&gt; Series</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Cast to DatetimeIndex of Timestamps, at *beginning* of period. 
 
        Parameters 
        ---------- 
        freq : str, default frequency of PeriodIndex 
            Desired frequency. 
        how : {'s', 'e', 'start', 'end'} 
            Convention for converting period to timestamp; start of period 
            vs. end. 
        copy : bool, default True 
            Whether or not to return a copy. 
 
            .. note:: 
                The `copy` keyword will change behavior in pandas 3.0. 
                `Copy-on-Write 
                &lt;https://pandas.pydata.org/docs/dev/user_guide/copy_on_write.html&gt;`__ 
                will be enabled by default, which means that all methods with a 
                `copy` keyword will use a lazy copy mechanism to defer the copy and 
                ignore the `copy` keyword. The `copy` keyword will be removed in a 
                future version of pandas. 
 
                You can already get the future behavior and improvements through 
                enabling copy on write ``pd.options.mode.copy_on_write = True`` 
 
        Returns 
        ------- 
        Series with DatetimeIndex 
 
        Examples 
        -------- 
        &gt;&gt;&gt; idx = pd.PeriodIndex(['2023', '2024', '2025'], freq='Y') 
        &gt;&gt;&gt; s1 = pd.Series([1, 2, 3], index=idx) 
        &gt;&gt;&gt; s1 
        2023    1 
        2024    2 
        2025    3 
        Freq: Y-DEC, dtype: int64 
 
        The resulting frequency of the Timestamps is `YearBegin` 
 
        &gt;&gt;&gt; s1 = s1.to_timestamp() 
        &gt;&gt;&gt; s1 
        2023-01-01    1 
        2024-01-01    2 
        2025-01-01    3 
        Freq: YS-JAN, dtype: int64 
 
        Using `freq` which is the offset that the Timestamps will have 
 
        &gt;&gt;&gt; s2 = pd.Series([1, 2, 3], index=idx) 
        &gt;&gt;&gt; s2 = s2.to_timestamp(freq='M') 
        &gt;&gt;&gt; s2 
        2023-01-31    1 
        2024-01-31    2 
        2025-01-31    3 
        Freq: YE-JAN, dtype: int64 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">index</span><span class="s3">, </span><span class="s1">PeriodIndex</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s4">f&quot;unsupported Type </span><span class="s2">{</span><span class="s1">type</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">index</span><span class="s3">).</span><span class="s1">__name__</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s3">)</span>

        <span class="s1">new_obj </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">(</span><span class="s1">deep</span><span class="s3">=</span><span class="s1">copy </span><span class="s2">and not </span><span class="s1">using_copy_on_write</span><span class="s3">())</span>
        <span class="s1">new_index </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">index</span><span class="s3">.</span><span class="s1">to_timestamp</span><span class="s3">(</span><span class="s1">freq</span><span class="s3">=</span><span class="s1">freq</span><span class="s3">, </span><span class="s1">how</span><span class="s3">=</span><span class="s1">how</span><span class="s3">)</span>
        <span class="s1">setattr</span><span class="s3">(</span><span class="s1">new_obj</span><span class="s3">, </span><span class="s4">&quot;index&quot;</span><span class="s3">, </span><span class="s1">new_index</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">new_obj</span>

    <span class="s2">def </span><span class="s1">to_period</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">freq</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">) </span><span class="s1">-&gt; Series</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Convert Series from DatetimeIndex to PeriodIndex. 
 
        Parameters 
        ---------- 
        freq : str, default None 
            Frequency associated with the PeriodIndex. 
        copy : bool, default True 
            Whether or not to return a copy. 
 
            .. note:: 
                The `copy` keyword will change behavior in pandas 3.0. 
                `Copy-on-Write 
                &lt;https://pandas.pydata.org/docs/dev/user_guide/copy_on_write.html&gt;`__ 
                will be enabled by default, which means that all methods with a 
                `copy` keyword will use a lazy copy mechanism to defer the copy and 
                ignore the `copy` keyword. The `copy` keyword will be removed in a 
                future version of pandas. 
 
                You can already get the future behavior and improvements through 
                enabling copy on write ``pd.options.mode.copy_on_write = True`` 
 
        Returns 
        ------- 
        Series 
            Series with index converted to PeriodIndex. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; idx = pd.DatetimeIndex(['2023', '2024', '2025']) 
        &gt;&gt;&gt; s = pd.Series([1, 2, 3], index=idx) 
        &gt;&gt;&gt; s = s.to_period() 
        &gt;&gt;&gt; s 
        2023    1 
        2024    2 
        2025    3 
        Freq: Y-DEC, dtype: int64 
 
        Viewing the index 
 
        &gt;&gt;&gt; s.index 
        PeriodIndex(['2023', '2024', '2025'], dtype='period[Y-DEC]') 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">index</span><span class="s3">, </span><span class="s1">DatetimeIndex</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s4">f&quot;unsupported Type </span><span class="s2">{</span><span class="s1">type</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">index</span><span class="s3">).</span><span class="s1">__name__</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s3">)</span>

        <span class="s1">new_obj </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">(</span><span class="s1">deep</span><span class="s3">=</span><span class="s1">copy </span><span class="s2">and not </span><span class="s1">using_copy_on_write</span><span class="s3">())</span>
        <span class="s1">new_index </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">index</span><span class="s3">.</span><span class="s1">to_period</span><span class="s3">(</span><span class="s1">freq</span><span class="s3">=</span><span class="s1">freq</span><span class="s3">)</span>
        <span class="s1">setattr</span><span class="s3">(</span><span class="s1">new_obj</span><span class="s3">, </span><span class="s4">&quot;index&quot;</span><span class="s3">, </span><span class="s1">new_index</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">new_obj</span>

    <span class="s6"># ----------------------------------------------------------------------</span>
    <span class="s6"># Add index</span>
    <span class="s1">_AXIS_ORDERS</span><span class="s3">: </span><span class="s1">list</span><span class="s3">[</span><span class="s1">Literal</span><span class="s3">[</span><span class="s4">&quot;index&quot;</span><span class="s3">, </span><span class="s4">&quot;columns&quot;</span><span class="s3">]] = [</span><span class="s4">&quot;index&quot;</span><span class="s3">]</span>
    <span class="s1">_AXIS_LEN </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">_AXIS_ORDERS</span><span class="s3">)</span>
    <span class="s1">_info_axis_number</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] = </span><span class="s5">0</span>
    <span class="s1">_info_axis_name</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s4">&quot;index&quot;</span><span class="s3">] = </span><span class="s4">&quot;index&quot;</span>

    <span class="s1">index </span><span class="s3">= </span><span class="s1">properties</span><span class="s3">.</span><span class="s1">AxisProperty</span><span class="s3">(</span>
        <span class="s1">axis</span><span class="s3">=</span><span class="s5">0</span><span class="s3">,</span>
        <span class="s1">doc</span><span class="s3">=</span><span class="s4">&quot;&quot;&quot; 
        The index (axis labels) of the Series. 
 
        The index of a Series is used to label and identify each element of the 
        underlying data. The index can be thought of as an immutable ordered set 
        (technically a multi-set, as it may contain duplicate labels), and is 
        used to index and align data in pandas. 
 
        Returns 
        ------- 
        Index 
            The index labels of the Series. 
 
        See Also 
        -------- 
        Series.reindex : Conform Series to new index. 
        Index : The base pandas index type. 
 
        Notes 
        ----- 
        For more information on pandas indexing, see the `indexing user guide 
        &lt;https://pandas.pydata.org/docs/user_guide/indexing.html&gt;`__. 
 
        Examples 
        -------- 
        To create a Series with a custom index and view the index labels: 
 
        &gt;&gt;&gt; cities = ['Kolkata', 'Chicago', 'Toronto', 'Lisbon'] 
        &gt;&gt;&gt; populations = [14.85, 2.71, 2.93, 0.51] 
        &gt;&gt;&gt; city_series = pd.Series(populations, index=cities) 
        &gt;&gt;&gt; city_series.index 
        Index(['Kolkata', 'Chicago', 'Toronto', 'Lisbon'], dtype='object') 
 
        To change the index labels of an existing Series: 
 
        &gt;&gt;&gt; city_series.index = ['KOL', 'CHI', 'TOR', 'LIS'] 
        &gt;&gt;&gt; city_series.index 
        Index(['KOL', 'CHI', 'TOR', 'LIS'], dtype='object') 
        &quot;&quot;&quot;</span><span class="s3">,</span>
    <span class="s3">)</span>

    <span class="s6"># ----------------------------------------------------------------------</span>
    <span class="s6"># Accessor Methods</span>
    <span class="s6"># ----------------------------------------------------------------------</span>
    <span class="s1">str </span><span class="s3">= </span><span class="s1">CachedAccessor</span><span class="s3">(</span><span class="s4">&quot;str&quot;</span><span class="s3">, </span><span class="s1">StringMethods</span><span class="s3">)</span>
    <span class="s1">dt </span><span class="s3">= </span><span class="s1">CachedAccessor</span><span class="s3">(</span><span class="s4">&quot;dt&quot;</span><span class="s3">, </span><span class="s1">CombinedDatetimelikeProperties</span><span class="s3">)</span>
    <span class="s1">cat </span><span class="s3">= </span><span class="s1">CachedAccessor</span><span class="s3">(</span><span class="s4">&quot;cat&quot;</span><span class="s3">, </span><span class="s1">CategoricalAccessor</span><span class="s3">)</span>
    <span class="s1">plot </span><span class="s3">= </span><span class="s1">CachedAccessor</span><span class="s3">(</span><span class="s4">&quot;plot&quot;</span><span class="s3">, </span><span class="s1">pandas</span><span class="s3">.</span><span class="s1">plotting</span><span class="s3">.</span><span class="s1">PlotAccessor</span><span class="s3">)</span>
    <span class="s1">sparse </span><span class="s3">= </span><span class="s1">CachedAccessor</span><span class="s3">(</span><span class="s4">&quot;sparse&quot;</span><span class="s3">, </span><span class="s1">SparseAccessor</span><span class="s3">)</span>
    <span class="s1">struct </span><span class="s3">= </span><span class="s1">CachedAccessor</span><span class="s3">(</span><span class="s4">&quot;struct&quot;</span><span class="s3">, </span><span class="s1">StructAccessor</span><span class="s3">)</span>
    <span class="s1">list </span><span class="s3">= </span><span class="s1">CachedAccessor</span><span class="s3">(</span><span class="s4">&quot;list&quot;</span><span class="s3">, </span><span class="s1">ListAccessor</span><span class="s3">)</span>

    <span class="s6"># ----------------------------------------------------------------------</span>
    <span class="s6"># Add plotting methods to Series</span>
    <span class="s1">hist </span><span class="s3">= </span><span class="s1">pandas</span><span class="s3">.</span><span class="s1">plotting</span><span class="s3">.</span><span class="s1">hist_series</span>

    <span class="s6"># ----------------------------------------------------------------------</span>
    <span class="s6"># Template-Based Arithmetic/Comparison Methods</span>

    <span class="s2">def </span><span class="s1">_cmp_method</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">, </span><span class="s1">op</span><span class="s3">):</span>
        <span class="s1">res_name </span><span class="s3">= </span><span class="s1">ops</span><span class="s3">.</span><span class="s1">get_op_result_name</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">other</span><span class="s3">, </span><span class="s1">Series</span><span class="s3">) </span><span class="s2">and not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_indexed_same</span><span class="s3">(</span><span class="s1">other</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Can only compare identically-labeled Series objects&quot;</span><span class="s3">)</span>

        <span class="s1">lvalues </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_values</span>
        <span class="s1">rvalues </span><span class="s3">= </span><span class="s1">extract_array</span><span class="s3">(</span><span class="s1">other</span><span class="s3">, </span><span class="s1">extract_numpy</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">extract_range</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

        <span class="s1">res_values </span><span class="s3">= </span><span class="s1">ops</span><span class="s3">.</span><span class="s1">comparison_op</span><span class="s3">(</span><span class="s1">lvalues</span><span class="s3">, </span><span class="s1">rvalues</span><span class="s3">, </span><span class="s1">op</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_construct_result</span><span class="s3">(</span><span class="s1">res_values</span><span class="s3">, </span><span class="s1">name</span><span class="s3">=</span><span class="s1">res_name</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_logical_method</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">, </span><span class="s1">op</span><span class="s3">):</span>
        <span class="s1">res_name </span><span class="s3">= </span><span class="s1">ops</span><span class="s3">.</span><span class="s1">get_op_result_name</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">other </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_align_for_op</span><span class="s3">(</span><span class="s1">other</span><span class="s3">, </span><span class="s1">align_asobject</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

        <span class="s1">lvalues </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_values</span>
        <span class="s1">rvalues </span><span class="s3">= </span><span class="s1">extract_array</span><span class="s3">(</span><span class="s1">other</span><span class="s3">, </span><span class="s1">extract_numpy</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">extract_range</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

        <span class="s1">res_values </span><span class="s3">= </span><span class="s1">ops</span><span class="s3">.</span><span class="s1">logical_op</span><span class="s3">(</span><span class="s1">lvalues</span><span class="s3">, </span><span class="s1">rvalues</span><span class="s3">, </span><span class="s1">op</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_construct_result</span><span class="s3">(</span><span class="s1">res_values</span><span class="s3">, </span><span class="s1">name</span><span class="s3">=</span><span class="s1">res_name</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_arith_method</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">, </span><span class="s1">op</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">other </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_align_for_op</span><span class="s3">(</span><span class="s1">other</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">base</span><span class="s3">.</span><span class="s1">IndexOpsMixin</span><span class="s3">.</span><span class="s1">_arith_method</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">, </span><span class="s1">op</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_align_for_op</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">right</span><span class="s3">, </span><span class="s1">align_asobject</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;align lhs and rhs Series&quot;&quot;&quot;</span>
        <span class="s6"># TODO: Different from DataFrame._align_for_op, list, tuple and ndarray</span>
        <span class="s6"># are not coerced here</span>
        <span class="s6"># because Series has inconsistencies described in GH#13637</span>
        <span class="s1">left </span><span class="s3">= </span><span class="s1">self</span>

        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">right</span><span class="s3">, </span><span class="s1">Series</span><span class="s3">):</span>
            <span class="s6"># avoid repeated alignment</span>
            <span class="s2">if not </span><span class="s1">left</span><span class="s3">.</span><span class="s1">index</span><span class="s3">.</span><span class="s1">equals</span><span class="s3">(</span><span class="s1">right</span><span class="s3">.</span><span class="s1">index</span><span class="s3">):</span>
                <span class="s2">if </span><span class="s1">align_asobject</span><span class="s3">:</span>
                    <span class="s2">if </span><span class="s1">left</span><span class="s3">.</span><span class="s1">dtype </span><span class="s2">not in </span><span class="s3">(</span><span class="s1">object</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">bool_</span><span class="s3">) </span><span class="s2">or </span><span class="s1">right</span><span class="s3">.</span><span class="s1">dtype </span><span class="s2">not in </span><span class="s3">(</span>
                        <span class="s1">object</span><span class="s3">,</span>
                        <span class="s1">np</span><span class="s3">.</span><span class="s1">bool_</span><span class="s3">,</span>
                    <span class="s3">):</span>
                        <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span>
                            <span class="s4">&quot;Operation between non boolean Series with different &quot;</span>
                            <span class="s4">&quot;indexes will no longer return a boolean result in &quot;</span>
                            <span class="s4">&quot;a future version. Cast both Series to object type &quot;</span>
                            <span class="s4">&quot;to maintain the prior behavior.&quot;</span><span class="s3">,</span>
                            <span class="s1">FutureWarning</span><span class="s3">,</span>
                            <span class="s1">stacklevel</span><span class="s3">=</span><span class="s1">find_stack_level</span><span class="s3">(),</span>
                        <span class="s3">)</span>
                    <span class="s6"># to keep original value's dtype for bool ops</span>
                    <span class="s1">left </span><span class="s3">= </span><span class="s1">left</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">object</span><span class="s3">)</span>
                    <span class="s1">right </span><span class="s3">= </span><span class="s1">right</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">object</span><span class="s3">)</span>

                <span class="s1">left</span><span class="s3">, </span><span class="s1">right </span><span class="s3">= </span><span class="s1">left</span><span class="s3">.</span><span class="s1">align</span><span class="s3">(</span><span class="s1">right</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">left</span><span class="s3">, </span><span class="s1">right</span>

    <span class="s2">def </span><span class="s1">_binop</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">: </span><span class="s1">Series</span><span class="s3">, </span><span class="s1">func</span><span class="s3">, </span><span class="s1">level</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">fill_value</span><span class="s3">=</span><span class="s2">None</span><span class="s3">) </span><span class="s1">-&gt; Series</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Perform generic binary operation with optional fill value. 
 
        Parameters 
        ---------- 
        other : Series 
        func : binary operator 
        fill_value : float or object 
            Value to substitute for NA/null values. If both Series are NA in a 
            location, the result will be NA regardless of the passed fill value. 
        level : int or level name, default None 
            Broadcast across a level, matching Index values on the 
            passed MultiIndex level. 
 
        Returns 
        ------- 
        Series 
        &quot;&quot;&quot;</span>
        <span class="s1">this </span><span class="s3">= </span><span class="s1">self</span>

        <span class="s2">if not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">index</span><span class="s3">.</span><span class="s1">equals</span><span class="s3">(</span><span class="s1">other</span><span class="s3">.</span><span class="s1">index</span><span class="s3">):</span>
            <span class="s1">this</span><span class="s3">, </span><span class="s1">other </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">align</span><span class="s3">(</span><span class="s1">other</span><span class="s3">, </span><span class="s1">level</span><span class="s3">=</span><span class="s1">level</span><span class="s3">, </span><span class="s1">join</span><span class="s3">=</span><span class="s4">&quot;outer&quot;</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>

        <span class="s1">this_vals</span><span class="s3">, </span><span class="s1">other_vals </span><span class="s3">= </span><span class="s1">ops</span><span class="s3">.</span><span class="s1">fill_binop</span><span class="s3">(</span><span class="s1">this</span><span class="s3">.</span><span class="s1">_values</span><span class="s3">, </span><span class="s1">other</span><span class="s3">.</span><span class="s1">_values</span><span class="s3">, </span><span class="s1">fill_value</span><span class="s3">)</span>

        <span class="s2">with </span><span class="s1">np</span><span class="s3">.</span><span class="s1">errstate</span><span class="s3">(</span><span class="s1">all</span><span class="s3">=</span><span class="s4">&quot;ignore&quot;</span><span class="s3">):</span>
            <span class="s1">result </span><span class="s3">= </span><span class="s1">func</span><span class="s3">(</span><span class="s1">this_vals</span><span class="s3">, </span><span class="s1">other_vals</span><span class="s3">)</span>

        <span class="s1">name </span><span class="s3">= </span><span class="s1">ops</span><span class="s3">.</span><span class="s1">get_op_result_name</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">)</span>
        <span class="s1">out </span><span class="s3">= </span><span class="s1">this</span><span class="s3">.</span><span class="s1">_construct_result</span><span class="s3">(</span><span class="s1">result</span><span class="s3">, </span><span class="s1">name</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">cast</span><span class="s3">(</span><span class="s1">Series</span><span class="s3">, </span><span class="s1">out</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_construct_result</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">result</span><span class="s3">: </span><span class="s1">ArrayLike </span><span class="s3">| </span><span class="s1">tuple</span><span class="s3">[</span><span class="s1">ArrayLike</span><span class="s3">, </span><span class="s1">ArrayLike</span><span class="s3">], </span><span class="s1">name</span><span class="s3">: </span><span class="s1">Hashable</span>
    <span class="s3">) </span><span class="s1">-&gt; Series </span><span class="s3">| </span><span class="s1">tuple</span><span class="s3">[</span><span class="s1">Series</span><span class="s3">, </span><span class="s1">Series</span><span class="s3">]:</span>
        <span class="s0">&quot;&quot;&quot; 
        Construct an appropriately-labelled Series from the result of an op. 
 
        Parameters 
        ---------- 
        result : ndarray or ExtensionArray 
        name : Label 
 
        Returns 
        ------- 
        Series 
            In the case of __divmod__ or __rdivmod__, a 2-tuple of Series. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">result</span><span class="s3">, </span><span class="s1">tuple</span><span class="s3">):</span>
            <span class="s6"># produced by divmod or rdivmod</span>

            <span class="s1">res1 </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_construct_result</span><span class="s3">(</span><span class="s1">result</span><span class="s3">[</span><span class="s5">0</span><span class="s3">], </span><span class="s1">name</span><span class="s3">=</span><span class="s1">name</span><span class="s3">)</span>
            <span class="s1">res2 </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_construct_result</span><span class="s3">(</span><span class="s1">result</span><span class="s3">[</span><span class="s5">1</span><span class="s3">], </span><span class="s1">name</span><span class="s3">=</span><span class="s1">name</span><span class="s3">)</span>

            <span class="s6"># GH#33427 assertions to keep mypy happy</span>
            <span class="s2">assert </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">res1</span><span class="s3">, </span><span class="s1">Series</span><span class="s3">)</span>
            <span class="s2">assert </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">res2</span><span class="s3">, </span><span class="s1">Series</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s3">(</span><span class="s1">res1</span><span class="s3">, </span><span class="s1">res2</span><span class="s3">)</span>

        <span class="s6"># TODO: result should always be ArrayLike, but this fails for some</span>
        <span class="s6">#  JSONArray tests</span>
        <span class="s1">dtype </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">result</span><span class="s3">, </span><span class="s4">&quot;dtype&quot;</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
        <span class="s1">out </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_constructor</span><span class="s3">(</span><span class="s1">result</span><span class="s3">, </span><span class="s1">index</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">index</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
        <span class="s1">out </span><span class="s3">= </span><span class="s1">out</span><span class="s3">.</span><span class="s1">__finalize__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">)</span>

        <span class="s6"># Set the result's name after __finalize__ is called because __finalize__</span>
        <span class="s6">#  would set it back to self.name</span>
        <span class="s1">out</span><span class="s3">.</span><span class="s1">name </span><span class="s3">= </span><span class="s1">name</span>
        <span class="s2">return </span><span class="s1">out</span>

    <span class="s2">def </span><span class="s1">_flex_method</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">, </span><span class="s1">op</span><span class="s3">, *, </span><span class="s1">level</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">fill_value</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">: </span><span class="s1">Axis </span><span class="s3">= </span><span class="s5">0</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">axis </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_get_axis_number</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">)</span>

        <span class="s1">res_name </span><span class="s3">= </span><span class="s1">ops</span><span class="s3">.</span><span class="s1">get_op_result_name</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">other</span><span class="s3">, </span><span class="s1">Series</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_binop</span><span class="s3">(</span><span class="s1">other</span><span class="s3">, </span><span class="s1">op</span><span class="s3">, </span><span class="s1">level</span><span class="s3">=</span><span class="s1">level</span><span class="s3">, </span><span class="s1">fill_value</span><span class="s3">=</span><span class="s1">fill_value</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">other</span><span class="s3">, (</span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndarray</span><span class="s3">, </span><span class="s1">list</span><span class="s3">, </span><span class="s1">tuple</span><span class="s3">)):</span>
            <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">other</span><span class="s3">) != </span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
                <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Lengths must be equal&quot;</span><span class="s3">)</span>
            <span class="s1">other </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_constructor</span><span class="s3">(</span><span class="s1">other</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">index</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
            <span class="s1">result </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_binop</span><span class="s3">(</span><span class="s1">other</span><span class="s3">, </span><span class="s1">op</span><span class="s3">, </span><span class="s1">level</span><span class="s3">=</span><span class="s1">level</span><span class="s3">, </span><span class="s1">fill_value</span><span class="s3">=</span><span class="s1">fill_value</span><span class="s3">)</span>
            <span class="s1">result</span><span class="s3">.</span><span class="s1">_name </span><span class="s3">= </span><span class="s1">res_name</span>
            <span class="s2">return </span><span class="s1">result</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">fill_value </span><span class="s2">is not None</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">isna</span><span class="s3">(</span><span class="s1">other</span><span class="s3">):</span>
                    <span class="s2">return </span><span class="s1">op</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">fill_value</span><span class="s3">)</span>
                <span class="s1">self </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">fillna</span><span class="s3">(</span><span class="s1">fill_value</span><span class="s3">)</span>

            <span class="s2">return </span><span class="s1">op</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">Appender</span><span class="s3">(</span><span class="s1">ops</span><span class="s3">.</span><span class="s1">make_flex_doc</span><span class="s3">(</span><span class="s4">&quot;eq&quot;</span><span class="s3">, </span><span class="s4">&quot;series&quot;</span><span class="s3">))</span>
    <span class="s2">def </span><span class="s1">eq</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">other</span><span class="s3">,</span>
        <span class="s1">level</span><span class="s3">: </span><span class="s1">Level </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">fill_value</span><span class="s3">: </span><span class="s1">float </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">axis</span><span class="s3">: </span><span class="s1">Axis </span><span class="s3">= </span><span class="s5">0</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">-&gt; Series</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_flex_method</span><span class="s3">(</span>
            <span class="s1">other</span><span class="s3">, </span><span class="s1">operator</span><span class="s3">.</span><span class="s1">eq</span><span class="s3">, </span><span class="s1">level</span><span class="s3">=</span><span class="s1">level</span><span class="s3">, </span><span class="s1">fill_value</span><span class="s3">=</span><span class="s1">fill_value</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span>
        <span class="s3">)</span>

    <span class="s3">@</span><span class="s1">Appender</span><span class="s3">(</span><span class="s1">ops</span><span class="s3">.</span><span class="s1">make_flex_doc</span><span class="s3">(</span><span class="s4">&quot;ne&quot;</span><span class="s3">, </span><span class="s4">&quot;series&quot;</span><span class="s3">))</span>
    <span class="s2">def </span><span class="s1">ne</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">, </span><span class="s1">level</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">fill_value</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">: </span><span class="s1">Axis </span><span class="s3">= </span><span class="s5">0</span><span class="s3">) </span><span class="s1">-&gt; Series</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_flex_method</span><span class="s3">(</span>
            <span class="s1">other</span><span class="s3">, </span><span class="s1">operator</span><span class="s3">.</span><span class="s1">ne</span><span class="s3">, </span><span class="s1">level</span><span class="s3">=</span><span class="s1">level</span><span class="s3">, </span><span class="s1">fill_value</span><span class="s3">=</span><span class="s1">fill_value</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span>
        <span class="s3">)</span>

    <span class="s3">@</span><span class="s1">Appender</span><span class="s3">(</span><span class="s1">ops</span><span class="s3">.</span><span class="s1">make_flex_doc</span><span class="s3">(</span><span class="s4">&quot;le&quot;</span><span class="s3">, </span><span class="s4">&quot;series&quot;</span><span class="s3">))</span>
    <span class="s2">def </span><span class="s1">le</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">, </span><span class="s1">level</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">fill_value</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">: </span><span class="s1">Axis </span><span class="s3">= </span><span class="s5">0</span><span class="s3">) </span><span class="s1">-&gt; Series</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_flex_method</span><span class="s3">(</span>
            <span class="s1">other</span><span class="s3">, </span><span class="s1">operator</span><span class="s3">.</span><span class="s1">le</span><span class="s3">, </span><span class="s1">level</span><span class="s3">=</span><span class="s1">level</span><span class="s3">, </span><span class="s1">fill_value</span><span class="s3">=</span><span class="s1">fill_value</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span>
        <span class="s3">)</span>

    <span class="s3">@</span><span class="s1">Appender</span><span class="s3">(</span><span class="s1">ops</span><span class="s3">.</span><span class="s1">make_flex_doc</span><span class="s3">(</span><span class="s4">&quot;lt&quot;</span><span class="s3">, </span><span class="s4">&quot;series&quot;</span><span class="s3">))</span>
    <span class="s2">def </span><span class="s1">lt</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">, </span><span class="s1">level</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">fill_value</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">: </span><span class="s1">Axis </span><span class="s3">= </span><span class="s5">0</span><span class="s3">) </span><span class="s1">-&gt; Series</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_flex_method</span><span class="s3">(</span>
            <span class="s1">other</span><span class="s3">, </span><span class="s1">operator</span><span class="s3">.</span><span class="s1">lt</span><span class="s3">, </span><span class="s1">level</span><span class="s3">=</span><span class="s1">level</span><span class="s3">, </span><span class="s1">fill_value</span><span class="s3">=</span><span class="s1">fill_value</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span>
        <span class="s3">)</span>

    <span class="s3">@</span><span class="s1">Appender</span><span class="s3">(</span><span class="s1">ops</span><span class="s3">.</span><span class="s1">make_flex_doc</span><span class="s3">(</span><span class="s4">&quot;ge&quot;</span><span class="s3">, </span><span class="s4">&quot;series&quot;</span><span class="s3">))</span>
    <span class="s2">def </span><span class="s1">ge</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">, </span><span class="s1">level</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">fill_value</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">: </span><span class="s1">Axis </span><span class="s3">= </span><span class="s5">0</span><span class="s3">) </span><span class="s1">-&gt; Series</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_flex_method</span><span class="s3">(</span>
            <span class="s1">other</span><span class="s3">, </span><span class="s1">operator</span><span class="s3">.</span><span class="s1">ge</span><span class="s3">, </span><span class="s1">level</span><span class="s3">=</span><span class="s1">level</span><span class="s3">, </span><span class="s1">fill_value</span><span class="s3">=</span><span class="s1">fill_value</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span>
        <span class="s3">)</span>

    <span class="s3">@</span><span class="s1">Appender</span><span class="s3">(</span><span class="s1">ops</span><span class="s3">.</span><span class="s1">make_flex_doc</span><span class="s3">(</span><span class="s4">&quot;gt&quot;</span><span class="s3">, </span><span class="s4">&quot;series&quot;</span><span class="s3">))</span>
    <span class="s2">def </span><span class="s1">gt</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">, </span><span class="s1">level</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">fill_value</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">: </span><span class="s1">Axis </span><span class="s3">= </span><span class="s5">0</span><span class="s3">) </span><span class="s1">-&gt; Series</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_flex_method</span><span class="s3">(</span>
            <span class="s1">other</span><span class="s3">, </span><span class="s1">operator</span><span class="s3">.</span><span class="s1">gt</span><span class="s3">, </span><span class="s1">level</span><span class="s3">=</span><span class="s1">level</span><span class="s3">, </span><span class="s1">fill_value</span><span class="s3">=</span><span class="s1">fill_value</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span>
        <span class="s3">)</span>

    <span class="s3">@</span><span class="s1">Appender</span><span class="s3">(</span><span class="s1">ops</span><span class="s3">.</span><span class="s1">make_flex_doc</span><span class="s3">(</span><span class="s4">&quot;add&quot;</span><span class="s3">, </span><span class="s4">&quot;series&quot;</span><span class="s3">))</span>
    <span class="s2">def </span><span class="s1">add</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">, </span><span class="s1">level</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">fill_value</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">: </span><span class="s1">Axis </span><span class="s3">= </span><span class="s5">0</span><span class="s3">) </span><span class="s1">-&gt; Series</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_flex_method</span><span class="s3">(</span>
            <span class="s1">other</span><span class="s3">, </span><span class="s1">operator</span><span class="s3">.</span><span class="s1">add</span><span class="s3">, </span><span class="s1">level</span><span class="s3">=</span><span class="s1">level</span><span class="s3">, </span><span class="s1">fill_value</span><span class="s3">=</span><span class="s1">fill_value</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span>
        <span class="s3">)</span>

    <span class="s3">@</span><span class="s1">Appender</span><span class="s3">(</span><span class="s1">ops</span><span class="s3">.</span><span class="s1">make_flex_doc</span><span class="s3">(</span><span class="s4">&quot;radd&quot;</span><span class="s3">, </span><span class="s4">&quot;series&quot;</span><span class="s3">))</span>
    <span class="s2">def </span><span class="s1">radd</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">, </span><span class="s1">level</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">fill_value</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">: </span><span class="s1">Axis </span><span class="s3">= </span><span class="s5">0</span><span class="s3">) </span><span class="s1">-&gt; Series</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_flex_method</span><span class="s3">(</span>
            <span class="s1">other</span><span class="s3">, </span><span class="s1">roperator</span><span class="s3">.</span><span class="s1">radd</span><span class="s3">, </span><span class="s1">level</span><span class="s3">=</span><span class="s1">level</span><span class="s3">, </span><span class="s1">fill_value</span><span class="s3">=</span><span class="s1">fill_value</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span>
        <span class="s3">)</span>

    <span class="s3">@</span><span class="s1">Appender</span><span class="s3">(</span><span class="s1">ops</span><span class="s3">.</span><span class="s1">make_flex_doc</span><span class="s3">(</span><span class="s4">&quot;sub&quot;</span><span class="s3">, </span><span class="s4">&quot;series&quot;</span><span class="s3">))</span>
    <span class="s2">def </span><span class="s1">sub</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">, </span><span class="s1">level</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">fill_value</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">: </span><span class="s1">Axis </span><span class="s3">= </span><span class="s5">0</span><span class="s3">) </span><span class="s1">-&gt; Series</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_flex_method</span><span class="s3">(</span>
            <span class="s1">other</span><span class="s3">, </span><span class="s1">operator</span><span class="s3">.</span><span class="s1">sub</span><span class="s3">, </span><span class="s1">level</span><span class="s3">=</span><span class="s1">level</span><span class="s3">, </span><span class="s1">fill_value</span><span class="s3">=</span><span class="s1">fill_value</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span>
        <span class="s3">)</span>

    <span class="s1">subtract </span><span class="s3">= </span><span class="s1">sub</span>

    <span class="s3">@</span><span class="s1">Appender</span><span class="s3">(</span><span class="s1">ops</span><span class="s3">.</span><span class="s1">make_flex_doc</span><span class="s3">(</span><span class="s4">&quot;rsub&quot;</span><span class="s3">, </span><span class="s4">&quot;series&quot;</span><span class="s3">))</span>
    <span class="s2">def </span><span class="s1">rsub</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">, </span><span class="s1">level</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">fill_value</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">: </span><span class="s1">Axis </span><span class="s3">= </span><span class="s5">0</span><span class="s3">) </span><span class="s1">-&gt; Series</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_flex_method</span><span class="s3">(</span>
            <span class="s1">other</span><span class="s3">, </span><span class="s1">roperator</span><span class="s3">.</span><span class="s1">rsub</span><span class="s3">, </span><span class="s1">level</span><span class="s3">=</span><span class="s1">level</span><span class="s3">, </span><span class="s1">fill_value</span><span class="s3">=</span><span class="s1">fill_value</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span>
        <span class="s3">)</span>

    <span class="s3">@</span><span class="s1">Appender</span><span class="s3">(</span><span class="s1">ops</span><span class="s3">.</span><span class="s1">make_flex_doc</span><span class="s3">(</span><span class="s4">&quot;mul&quot;</span><span class="s3">, </span><span class="s4">&quot;series&quot;</span><span class="s3">))</span>
    <span class="s2">def </span><span class="s1">mul</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">other</span><span class="s3">,</span>
        <span class="s1">level</span><span class="s3">: </span><span class="s1">Level </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">fill_value</span><span class="s3">: </span><span class="s1">float </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">axis</span><span class="s3">: </span><span class="s1">Axis </span><span class="s3">= </span><span class="s5">0</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">-&gt; Series</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_flex_method</span><span class="s3">(</span>
            <span class="s1">other</span><span class="s3">, </span><span class="s1">operator</span><span class="s3">.</span><span class="s1">mul</span><span class="s3">, </span><span class="s1">level</span><span class="s3">=</span><span class="s1">level</span><span class="s3">, </span><span class="s1">fill_value</span><span class="s3">=</span><span class="s1">fill_value</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span>
        <span class="s3">)</span>

    <span class="s1">multiply </span><span class="s3">= </span><span class="s1">mul</span>

    <span class="s3">@</span><span class="s1">Appender</span><span class="s3">(</span><span class="s1">ops</span><span class="s3">.</span><span class="s1">make_flex_doc</span><span class="s3">(</span><span class="s4">&quot;rmul&quot;</span><span class="s3">, </span><span class="s4">&quot;series&quot;</span><span class="s3">))</span>
    <span class="s2">def </span><span class="s1">rmul</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">, </span><span class="s1">level</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">fill_value</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">: </span><span class="s1">Axis </span><span class="s3">= </span><span class="s5">0</span><span class="s3">) </span><span class="s1">-&gt; Series</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_flex_method</span><span class="s3">(</span>
            <span class="s1">other</span><span class="s3">, </span><span class="s1">roperator</span><span class="s3">.</span><span class="s1">rmul</span><span class="s3">, </span><span class="s1">level</span><span class="s3">=</span><span class="s1">level</span><span class="s3">, </span><span class="s1">fill_value</span><span class="s3">=</span><span class="s1">fill_value</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span>
        <span class="s3">)</span>

    <span class="s3">@</span><span class="s1">Appender</span><span class="s3">(</span><span class="s1">ops</span><span class="s3">.</span><span class="s1">make_flex_doc</span><span class="s3">(</span><span class="s4">&quot;truediv&quot;</span><span class="s3">, </span><span class="s4">&quot;series&quot;</span><span class="s3">))</span>
    <span class="s2">def </span><span class="s1">truediv</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">, </span><span class="s1">level</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">fill_value</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">: </span><span class="s1">Axis </span><span class="s3">= </span><span class="s5">0</span><span class="s3">) </span><span class="s1">-&gt; Series</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_flex_method</span><span class="s3">(</span>
            <span class="s1">other</span><span class="s3">, </span><span class="s1">operator</span><span class="s3">.</span><span class="s1">truediv</span><span class="s3">, </span><span class="s1">level</span><span class="s3">=</span><span class="s1">level</span><span class="s3">, </span><span class="s1">fill_value</span><span class="s3">=</span><span class="s1">fill_value</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span>
        <span class="s3">)</span>

    <span class="s1">div </span><span class="s3">= </span><span class="s1">truediv</span>
    <span class="s1">divide </span><span class="s3">= </span><span class="s1">truediv</span>

    <span class="s3">@</span><span class="s1">Appender</span><span class="s3">(</span><span class="s1">ops</span><span class="s3">.</span><span class="s1">make_flex_doc</span><span class="s3">(</span><span class="s4">&quot;rtruediv&quot;</span><span class="s3">, </span><span class="s4">&quot;series&quot;</span><span class="s3">))</span>
    <span class="s2">def </span><span class="s1">rtruediv</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">, </span><span class="s1">level</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">fill_value</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">: </span><span class="s1">Axis </span><span class="s3">= </span><span class="s5">0</span><span class="s3">) </span><span class="s1">-&gt; Series</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_flex_method</span><span class="s3">(</span>
            <span class="s1">other</span><span class="s3">, </span><span class="s1">roperator</span><span class="s3">.</span><span class="s1">rtruediv</span><span class="s3">, </span><span class="s1">level</span><span class="s3">=</span><span class="s1">level</span><span class="s3">, </span><span class="s1">fill_value</span><span class="s3">=</span><span class="s1">fill_value</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span>
        <span class="s3">)</span>

    <span class="s1">rdiv </span><span class="s3">= </span><span class="s1">rtruediv</span>

    <span class="s3">@</span><span class="s1">Appender</span><span class="s3">(</span><span class="s1">ops</span><span class="s3">.</span><span class="s1">make_flex_doc</span><span class="s3">(</span><span class="s4">&quot;floordiv&quot;</span><span class="s3">, </span><span class="s4">&quot;series&quot;</span><span class="s3">))</span>
    <span class="s2">def </span><span class="s1">floordiv</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">, </span><span class="s1">level</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">fill_value</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">: </span><span class="s1">Axis </span><span class="s3">= </span><span class="s5">0</span><span class="s3">) </span><span class="s1">-&gt; Series</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_flex_method</span><span class="s3">(</span>
            <span class="s1">other</span><span class="s3">, </span><span class="s1">operator</span><span class="s3">.</span><span class="s1">floordiv</span><span class="s3">, </span><span class="s1">level</span><span class="s3">=</span><span class="s1">level</span><span class="s3">, </span><span class="s1">fill_value</span><span class="s3">=</span><span class="s1">fill_value</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span>
        <span class="s3">)</span>

    <span class="s3">@</span><span class="s1">Appender</span><span class="s3">(</span><span class="s1">ops</span><span class="s3">.</span><span class="s1">make_flex_doc</span><span class="s3">(</span><span class="s4">&quot;rfloordiv&quot;</span><span class="s3">, </span><span class="s4">&quot;series&quot;</span><span class="s3">))</span>
    <span class="s2">def </span><span class="s1">rfloordiv</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">, </span><span class="s1">level</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">fill_value</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">: </span><span class="s1">Axis </span><span class="s3">= </span><span class="s5">0</span><span class="s3">) </span><span class="s1">-&gt; Series</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_flex_method</span><span class="s3">(</span>
            <span class="s1">other</span><span class="s3">, </span><span class="s1">roperator</span><span class="s3">.</span><span class="s1">rfloordiv</span><span class="s3">, </span><span class="s1">level</span><span class="s3">=</span><span class="s1">level</span><span class="s3">, </span><span class="s1">fill_value</span><span class="s3">=</span><span class="s1">fill_value</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span>
        <span class="s3">)</span>

    <span class="s3">@</span><span class="s1">Appender</span><span class="s3">(</span><span class="s1">ops</span><span class="s3">.</span><span class="s1">make_flex_doc</span><span class="s3">(</span><span class="s4">&quot;mod&quot;</span><span class="s3">, </span><span class="s4">&quot;series&quot;</span><span class="s3">))</span>
    <span class="s2">def </span><span class="s1">mod</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">, </span><span class="s1">level</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">fill_value</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">: </span><span class="s1">Axis </span><span class="s3">= </span><span class="s5">0</span><span class="s3">) </span><span class="s1">-&gt; Series</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_flex_method</span><span class="s3">(</span>
            <span class="s1">other</span><span class="s3">, </span><span class="s1">operator</span><span class="s3">.</span><span class="s1">mod</span><span class="s3">, </span><span class="s1">level</span><span class="s3">=</span><span class="s1">level</span><span class="s3">, </span><span class="s1">fill_value</span><span class="s3">=</span><span class="s1">fill_value</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span>
        <span class="s3">)</span>

    <span class="s3">@</span><span class="s1">Appender</span><span class="s3">(</span><span class="s1">ops</span><span class="s3">.</span><span class="s1">make_flex_doc</span><span class="s3">(</span><span class="s4">&quot;rmod&quot;</span><span class="s3">, </span><span class="s4">&quot;series&quot;</span><span class="s3">))</span>
    <span class="s2">def </span><span class="s1">rmod</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">, </span><span class="s1">level</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">fill_value</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">: </span><span class="s1">Axis </span><span class="s3">= </span><span class="s5">0</span><span class="s3">) </span><span class="s1">-&gt; Series</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_flex_method</span><span class="s3">(</span>
            <span class="s1">other</span><span class="s3">, </span><span class="s1">roperator</span><span class="s3">.</span><span class="s1">rmod</span><span class="s3">, </span><span class="s1">level</span><span class="s3">=</span><span class="s1">level</span><span class="s3">, </span><span class="s1">fill_value</span><span class="s3">=</span><span class="s1">fill_value</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span>
        <span class="s3">)</span>

    <span class="s3">@</span><span class="s1">Appender</span><span class="s3">(</span><span class="s1">ops</span><span class="s3">.</span><span class="s1">make_flex_doc</span><span class="s3">(</span><span class="s4">&quot;pow&quot;</span><span class="s3">, </span><span class="s4">&quot;series&quot;</span><span class="s3">))</span>
    <span class="s2">def </span><span class="s1">pow</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">, </span><span class="s1">level</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">fill_value</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">: </span><span class="s1">Axis </span><span class="s3">= </span><span class="s5">0</span><span class="s3">) </span><span class="s1">-&gt; Series</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_flex_method</span><span class="s3">(</span>
            <span class="s1">other</span><span class="s3">, </span><span class="s1">operator</span><span class="s3">.</span><span class="s1">pow</span><span class="s3">, </span><span class="s1">level</span><span class="s3">=</span><span class="s1">level</span><span class="s3">, </span><span class="s1">fill_value</span><span class="s3">=</span><span class="s1">fill_value</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span>
        <span class="s3">)</span>

    <span class="s3">@</span><span class="s1">Appender</span><span class="s3">(</span><span class="s1">ops</span><span class="s3">.</span><span class="s1">make_flex_doc</span><span class="s3">(</span><span class="s4">&quot;rpow&quot;</span><span class="s3">, </span><span class="s4">&quot;series&quot;</span><span class="s3">))</span>
    <span class="s2">def </span><span class="s1">rpow</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">, </span><span class="s1">level</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">fill_value</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">: </span><span class="s1">Axis </span><span class="s3">= </span><span class="s5">0</span><span class="s3">) </span><span class="s1">-&gt; Series</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_flex_method</span><span class="s3">(</span>
            <span class="s1">other</span><span class="s3">, </span><span class="s1">roperator</span><span class="s3">.</span><span class="s1">rpow</span><span class="s3">, </span><span class="s1">level</span><span class="s3">=</span><span class="s1">level</span><span class="s3">, </span><span class="s1">fill_value</span><span class="s3">=</span><span class="s1">fill_value</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span>
        <span class="s3">)</span>

    <span class="s3">@</span><span class="s1">Appender</span><span class="s3">(</span><span class="s1">ops</span><span class="s3">.</span><span class="s1">make_flex_doc</span><span class="s3">(</span><span class="s4">&quot;divmod&quot;</span><span class="s3">, </span><span class="s4">&quot;series&quot;</span><span class="s3">))</span>
    <span class="s2">def </span><span class="s1">divmod</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">, </span><span class="s1">level</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">fill_value</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">: </span><span class="s1">Axis </span><span class="s3">= </span><span class="s5">0</span><span class="s3">) </span><span class="s1">-&gt; Series</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_flex_method</span><span class="s3">(</span>
            <span class="s1">other</span><span class="s3">, </span><span class="s1">divmod</span><span class="s3">, </span><span class="s1">level</span><span class="s3">=</span><span class="s1">level</span><span class="s3">, </span><span class="s1">fill_value</span><span class="s3">=</span><span class="s1">fill_value</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span>
        <span class="s3">)</span>

    <span class="s3">@</span><span class="s1">Appender</span><span class="s3">(</span><span class="s1">ops</span><span class="s3">.</span><span class="s1">make_flex_doc</span><span class="s3">(</span><span class="s4">&quot;rdivmod&quot;</span><span class="s3">, </span><span class="s4">&quot;series&quot;</span><span class="s3">))</span>
    <span class="s2">def </span><span class="s1">rdivmod</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">, </span><span class="s1">level</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">fill_value</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">: </span><span class="s1">Axis </span><span class="s3">= </span><span class="s5">0</span><span class="s3">) </span><span class="s1">-&gt; Series</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_flex_method</span><span class="s3">(</span>
            <span class="s1">other</span><span class="s3">, </span><span class="s1">roperator</span><span class="s3">.</span><span class="s1">rdivmod</span><span class="s3">, </span><span class="s1">level</span><span class="s3">=</span><span class="s1">level</span><span class="s3">, </span><span class="s1">fill_value</span><span class="s3">=</span><span class="s1">fill_value</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span>
        <span class="s3">)</span>

    <span class="s6"># ----------------------------------------------------------------------</span>
    <span class="s6"># Reductions</span>

    <span class="s2">def </span><span class="s1">_reduce</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">op</span><span class="s3">,</span>
        <span class="s6"># error: Variable &quot;pandas.core.series.Series.str&quot; is not valid as a type</span>
        <span class="s1">name</span><span class="s3">: </span><span class="s1">str</span><span class="s3">,  </span><span class="s6"># type: ignore[valid-type]</span>
        <span class="s3">*,</span>
        <span class="s1">axis</span><span class="s3">: </span><span class="s1">Axis </span><span class="s3">= </span><span class="s5">0</span><span class="s3">,</span>
        <span class="s1">skipna</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">True</span><span class="s3">,</span>
        <span class="s1">numeric_only</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span><span class="s3">,</span>
        <span class="s1">filter_type</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
        <span class="s3">**</span><span class="s1">kwds</span><span class="s3">,</span>
    <span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Perform a reduction operation. 
 
        If we have an ndarray as a value, then simply perform the operation, 
        otherwise delegate to the object. 
        &quot;&quot;&quot;</span>
        <span class="s1">delegate </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_values</span>

        <span class="s2">if </span><span class="s1">axis </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_get_axis_number</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">delegate</span><span class="s3">, </span><span class="s1">ExtensionArray</span><span class="s3">):</span>
            <span class="s6"># dispatch to ExtensionArray interface</span>
            <span class="s2">return </span><span class="s1">delegate</span><span class="s3">.</span><span class="s1">_reduce</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">skipna</span><span class="s3">=</span><span class="s1">skipna</span><span class="s3">, **</span><span class="s1">kwds</span><span class="s3">)</span>

        <span class="s2">else</span><span class="s3">:</span>
            <span class="s6"># dispatch to numpy arrays</span>
            <span class="s2">if </span><span class="s1">numeric_only </span><span class="s2">and </span><span class="s1">self</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">kind </span><span class="s2">not in </span><span class="s4">&quot;iufcb&quot;</span><span class="s3">:</span>
                <span class="s6"># i.e. not is_numeric_dtype(self.dtype)</span>
                <span class="s1">kwd_name </span><span class="s3">= </span><span class="s4">&quot;numeric_only&quot;</span>
                <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s3">[</span><span class="s4">&quot;any&quot;</span><span class="s3">, </span><span class="s4">&quot;all&quot;</span><span class="s3">]:</span>
                    <span class="s1">kwd_name </span><span class="s3">= </span><span class="s4">&quot;bool_only&quot;</span>
                <span class="s6"># GH#47500 - change to TypeError to match other methods</span>
                <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span>
                    <span class="s4">f&quot;Series.</span><span class="s2">{</span><span class="s1">name</span><span class="s2">} </span><span class="s4">does not allow </span><span class="s2">{</span><span class="s1">kwd_name</span><span class="s2">}</span><span class="s4">=</span><span class="s2">{</span><span class="s1">numeric_only</span><span class="s2">} </span><span class="s4">&quot;</span>
                    <span class="s4">&quot;with non-numeric dtypes.&quot;</span>
                <span class="s3">)</span>
            <span class="s2">return </span><span class="s1">op</span><span class="s3">(</span><span class="s1">delegate</span><span class="s3">, </span><span class="s1">skipna</span><span class="s3">=</span><span class="s1">skipna</span><span class="s3">, **</span><span class="s1">kwds</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">Appender</span><span class="s3">(</span><span class="s1">make_doc</span><span class="s3">(</span><span class="s4">&quot;any&quot;</span><span class="s3">, </span><span class="s1">ndim</span><span class="s3">=</span><span class="s5">1</span><span class="s3">))</span>
    <span class="s6"># error: Signature of &quot;any&quot; incompatible with supertype &quot;NDFrame&quot;</span>
    <span class="s2">def </span><span class="s1">any</span><span class="s3">(  </span><span class="s6"># type: ignore[override]</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s3">*,</span>
        <span class="s1">axis</span><span class="s3">: </span><span class="s1">Axis </span><span class="s3">= </span><span class="s5">0</span><span class="s3">,</span>
        <span class="s1">bool_only</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span><span class="s3">,</span>
        <span class="s1">skipna</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">True</span><span class="s3">,</span>
        <span class="s3">**</span><span class="s1">kwargs</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
        <span class="s1">nv</span><span class="s3">.</span><span class="s1">validate_logical_func</span><span class="s3">((), </span><span class="s1">kwargs</span><span class="s3">, </span><span class="s1">fname</span><span class="s3">=</span><span class="s4">&quot;any&quot;</span><span class="s3">)</span>
        <span class="s1">validate_bool_kwarg</span><span class="s3">(</span><span class="s1">skipna</span><span class="s3">, </span><span class="s4">&quot;skipna&quot;</span><span class="s3">, </span><span class="s1">none_allowed</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_reduce</span><span class="s3">(</span>
            <span class="s1">nanops</span><span class="s3">.</span><span class="s1">nanany</span><span class="s3">,</span>
            <span class="s1">name</span><span class="s3">=</span><span class="s4">&quot;any&quot;</span><span class="s3">,</span>
            <span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">,</span>
            <span class="s1">numeric_only</span><span class="s3">=</span><span class="s1">bool_only</span><span class="s3">,</span>
            <span class="s1">skipna</span><span class="s3">=</span><span class="s1">skipna</span><span class="s3">,</span>
            <span class="s1">filter_type</span><span class="s3">=</span><span class="s4">&quot;bool&quot;</span><span class="s3">,</span>
        <span class="s3">)</span>

    <span class="s3">@</span><span class="s1">Appender</span><span class="s3">(</span><span class="s1">make_doc</span><span class="s3">(</span><span class="s4">&quot;all&quot;</span><span class="s3">, </span><span class="s1">ndim</span><span class="s3">=</span><span class="s5">1</span><span class="s3">))</span>
    <span class="s2">def </span><span class="s1">all</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">axis</span><span class="s3">: </span><span class="s1">Axis </span><span class="s3">= </span><span class="s5">0</span><span class="s3">,</span>
        <span class="s1">bool_only</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span><span class="s3">,</span>
        <span class="s1">skipna</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">True</span><span class="s3">,</span>
        <span class="s3">**</span><span class="s1">kwargs</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
        <span class="s1">nv</span><span class="s3">.</span><span class="s1">validate_logical_func</span><span class="s3">((), </span><span class="s1">kwargs</span><span class="s3">, </span><span class="s1">fname</span><span class="s3">=</span><span class="s4">&quot;all&quot;</span><span class="s3">)</span>
        <span class="s1">validate_bool_kwarg</span><span class="s3">(</span><span class="s1">skipna</span><span class="s3">, </span><span class="s4">&quot;skipna&quot;</span><span class="s3">, </span><span class="s1">none_allowed</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_reduce</span><span class="s3">(</span>
            <span class="s1">nanops</span><span class="s3">.</span><span class="s1">nanall</span><span class="s3">,</span>
            <span class="s1">name</span><span class="s3">=</span><span class="s4">&quot;all&quot;</span><span class="s3">,</span>
            <span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">,</span>
            <span class="s1">numeric_only</span><span class="s3">=</span><span class="s1">bool_only</span><span class="s3">,</span>
            <span class="s1">skipna</span><span class="s3">=</span><span class="s1">skipna</span><span class="s3">,</span>
            <span class="s1">filter_type</span><span class="s3">=</span><span class="s4">&quot;bool&quot;</span><span class="s3">,</span>
        <span class="s3">)</span>

    <span class="s3">@</span><span class="s1">doc</span><span class="s3">(</span><span class="s1">make_doc</span><span class="s3">(</span><span class="s4">&quot;min&quot;</span><span class="s3">, </span><span class="s1">ndim</span><span class="s3">=</span><span class="s5">1</span><span class="s3">))</span>
    <span class="s2">def </span><span class="s1">min</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">axis</span><span class="s3">: </span><span class="s1">Axis </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s5">0</span><span class="s3">,</span>
        <span class="s1">skipna</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">True</span><span class="s3">,</span>
        <span class="s1">numeric_only</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span><span class="s3">,</span>
        <span class="s3">**</span><span class="s1">kwargs</span><span class="s3">,</span>
    <span class="s3">):</span>
        <span class="s2">return </span><span class="s1">NDFrame</span><span class="s3">.</span><span class="s1">min</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">skipna</span><span class="s3">, </span><span class="s1">numeric_only</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">doc</span><span class="s3">(</span><span class="s1">make_doc</span><span class="s3">(</span><span class="s4">&quot;max&quot;</span><span class="s3">, </span><span class="s1">ndim</span><span class="s3">=</span><span class="s5">1</span><span class="s3">))</span>
    <span class="s2">def </span><span class="s1">max</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">axis</span><span class="s3">: </span><span class="s1">Axis </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s5">0</span><span class="s3">,</span>
        <span class="s1">skipna</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">True</span><span class="s3">,</span>
        <span class="s1">numeric_only</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span><span class="s3">,</span>
        <span class="s3">**</span><span class="s1">kwargs</span><span class="s3">,</span>
    <span class="s3">):</span>
        <span class="s2">return </span><span class="s1">NDFrame</span><span class="s3">.</span><span class="s1">max</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">skipna</span><span class="s3">, </span><span class="s1">numeric_only</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">doc</span><span class="s3">(</span><span class="s1">make_doc</span><span class="s3">(</span><span class="s4">&quot;sum&quot;</span><span class="s3">, </span><span class="s1">ndim</span><span class="s3">=</span><span class="s5">1</span><span class="s3">))</span>
    <span class="s2">def </span><span class="s1">sum</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">axis</span><span class="s3">: </span><span class="s1">Axis </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">skipna</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">True</span><span class="s3">,</span>
        <span class="s1">numeric_only</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span><span class="s3">,</span>
        <span class="s1">min_count</span><span class="s3">: </span><span class="s1">int </span><span class="s3">= </span><span class="s5">0</span><span class="s3">,</span>
        <span class="s3">**</span><span class="s1">kwargs</span><span class="s3">,</span>
    <span class="s3">):</span>
        <span class="s2">return </span><span class="s1">NDFrame</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">skipna</span><span class="s3">, </span><span class="s1">numeric_only</span><span class="s3">, </span><span class="s1">min_count</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">doc</span><span class="s3">(</span><span class="s1">make_doc</span><span class="s3">(</span><span class="s4">&quot;prod&quot;</span><span class="s3">, </span><span class="s1">ndim</span><span class="s3">=</span><span class="s5">1</span><span class="s3">))</span>
    <span class="s2">def </span><span class="s1">prod</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">axis</span><span class="s3">: </span><span class="s1">Axis </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">skipna</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">True</span><span class="s3">,</span>
        <span class="s1">numeric_only</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span><span class="s3">,</span>
        <span class="s1">min_count</span><span class="s3">: </span><span class="s1">int </span><span class="s3">= </span><span class="s5">0</span><span class="s3">,</span>
        <span class="s3">**</span><span class="s1">kwargs</span><span class="s3">,</span>
    <span class="s3">):</span>
        <span class="s2">return </span><span class="s1">NDFrame</span><span class="s3">.</span><span class="s1">prod</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">skipna</span><span class="s3">, </span><span class="s1">numeric_only</span><span class="s3">, </span><span class="s1">min_count</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">doc</span><span class="s3">(</span><span class="s1">make_doc</span><span class="s3">(</span><span class="s4">&quot;mean&quot;</span><span class="s3">, </span><span class="s1">ndim</span><span class="s3">=</span><span class="s5">1</span><span class="s3">))</span>
    <span class="s2">def </span><span class="s1">mean</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">axis</span><span class="s3">: </span><span class="s1">Axis </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s5">0</span><span class="s3">,</span>
        <span class="s1">skipna</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">True</span><span class="s3">,</span>
        <span class="s1">numeric_only</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span><span class="s3">,</span>
        <span class="s3">**</span><span class="s1">kwargs</span><span class="s3">,</span>
    <span class="s3">):</span>
        <span class="s2">return </span><span class="s1">NDFrame</span><span class="s3">.</span><span class="s1">mean</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">skipna</span><span class="s3">, </span><span class="s1">numeric_only</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">doc</span><span class="s3">(</span><span class="s1">make_doc</span><span class="s3">(</span><span class="s4">&quot;median&quot;</span><span class="s3">, </span><span class="s1">ndim</span><span class="s3">=</span><span class="s5">1</span><span class="s3">))</span>
    <span class="s2">def </span><span class="s1">median</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">axis</span><span class="s3">: </span><span class="s1">Axis </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s5">0</span><span class="s3">,</span>
        <span class="s1">skipna</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">True</span><span class="s3">,</span>
        <span class="s1">numeric_only</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span><span class="s3">,</span>
        <span class="s3">**</span><span class="s1">kwargs</span><span class="s3">,</span>
    <span class="s3">):</span>
        <span class="s2">return </span><span class="s1">NDFrame</span><span class="s3">.</span><span class="s1">median</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">skipna</span><span class="s3">, </span><span class="s1">numeric_only</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">doc</span><span class="s3">(</span><span class="s1">make_doc</span><span class="s3">(</span><span class="s4">&quot;sem&quot;</span><span class="s3">, </span><span class="s1">ndim</span><span class="s3">=</span><span class="s5">1</span><span class="s3">))</span>
    <span class="s2">def </span><span class="s1">sem</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">axis</span><span class="s3">: </span><span class="s1">Axis </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">skipna</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">True</span><span class="s3">,</span>
        <span class="s1">ddof</span><span class="s3">: </span><span class="s1">int </span><span class="s3">= </span><span class="s5">1</span><span class="s3">,</span>
        <span class="s1">numeric_only</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span><span class="s3">,</span>
        <span class="s3">**</span><span class="s1">kwargs</span><span class="s3">,</span>
    <span class="s3">):</span>
        <span class="s2">return </span><span class="s1">NDFrame</span><span class="s3">.</span><span class="s1">sem</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">skipna</span><span class="s3">, </span><span class="s1">ddof</span><span class="s3">, </span><span class="s1">numeric_only</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">doc</span><span class="s3">(</span><span class="s1">make_doc</span><span class="s3">(</span><span class="s4">&quot;var&quot;</span><span class="s3">, </span><span class="s1">ndim</span><span class="s3">=</span><span class="s5">1</span><span class="s3">))</span>
    <span class="s2">def </span><span class="s1">var</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">axis</span><span class="s3">: </span><span class="s1">Axis </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">skipna</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">True</span><span class="s3">,</span>
        <span class="s1">ddof</span><span class="s3">: </span><span class="s1">int </span><span class="s3">= </span><span class="s5">1</span><span class="s3">,</span>
        <span class="s1">numeric_only</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span><span class="s3">,</span>
        <span class="s3">**</span><span class="s1">kwargs</span><span class="s3">,</span>
    <span class="s3">):</span>
        <span class="s2">return </span><span class="s1">NDFrame</span><span class="s3">.</span><span class="s1">var</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">skipna</span><span class="s3">, </span><span class="s1">ddof</span><span class="s3">, </span><span class="s1">numeric_only</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">doc</span><span class="s3">(</span><span class="s1">make_doc</span><span class="s3">(</span><span class="s4">&quot;std&quot;</span><span class="s3">, </span><span class="s1">ndim</span><span class="s3">=</span><span class="s5">1</span><span class="s3">))</span>
    <span class="s2">def </span><span class="s1">std</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">axis</span><span class="s3">: </span><span class="s1">Axis </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">skipna</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">True</span><span class="s3">,</span>
        <span class="s1">ddof</span><span class="s3">: </span><span class="s1">int </span><span class="s3">= </span><span class="s5">1</span><span class="s3">,</span>
        <span class="s1">numeric_only</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span><span class="s3">,</span>
        <span class="s3">**</span><span class="s1">kwargs</span><span class="s3">,</span>
    <span class="s3">):</span>
        <span class="s2">return </span><span class="s1">NDFrame</span><span class="s3">.</span><span class="s1">std</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">skipna</span><span class="s3">, </span><span class="s1">ddof</span><span class="s3">, </span><span class="s1">numeric_only</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">doc</span><span class="s3">(</span><span class="s1">make_doc</span><span class="s3">(</span><span class="s4">&quot;skew&quot;</span><span class="s3">, </span><span class="s1">ndim</span><span class="s3">=</span><span class="s5">1</span><span class="s3">))</span>
    <span class="s2">def </span><span class="s1">skew</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">axis</span><span class="s3">: </span><span class="s1">Axis </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s5">0</span><span class="s3">,</span>
        <span class="s1">skipna</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">True</span><span class="s3">,</span>
        <span class="s1">numeric_only</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span><span class="s3">,</span>
        <span class="s3">**</span><span class="s1">kwargs</span><span class="s3">,</span>
    <span class="s3">):</span>
        <span class="s2">return </span><span class="s1">NDFrame</span><span class="s3">.</span><span class="s1">skew</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">skipna</span><span class="s3">, </span><span class="s1">numeric_only</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">doc</span><span class="s3">(</span><span class="s1">make_doc</span><span class="s3">(</span><span class="s4">&quot;kurt&quot;</span><span class="s3">, </span><span class="s1">ndim</span><span class="s3">=</span><span class="s5">1</span><span class="s3">))</span>
    <span class="s2">def </span><span class="s1">kurt</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">axis</span><span class="s3">: </span><span class="s1">Axis </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s5">0</span><span class="s3">,</span>
        <span class="s1">skipna</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">True</span><span class="s3">,</span>
        <span class="s1">numeric_only</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span><span class="s3">,</span>
        <span class="s3">**</span><span class="s1">kwargs</span><span class="s3">,</span>
    <span class="s3">):</span>
        <span class="s2">return </span><span class="s1">NDFrame</span><span class="s3">.</span><span class="s1">kurt</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">skipna</span><span class="s3">, </span><span class="s1">numeric_only</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">)</span>

    <span class="s1">kurtosis </span><span class="s3">= </span><span class="s1">kurt</span>
    <span class="s1">product </span><span class="s3">= </span><span class="s1">prod</span>

    <span class="s3">@</span><span class="s1">doc</span><span class="s3">(</span><span class="s1">make_doc</span><span class="s3">(</span><span class="s4">&quot;cummin&quot;</span><span class="s3">, </span><span class="s1">ndim</span><span class="s3">=</span><span class="s5">1</span><span class="s3">))</span>
    <span class="s2">def </span><span class="s1">cummin</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">: </span><span class="s1">Axis </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">, </span><span class="s1">skipna</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">True</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">NDFrame</span><span class="s3">.</span><span class="s1">cummin</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">skipna</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">doc</span><span class="s3">(</span><span class="s1">make_doc</span><span class="s3">(</span><span class="s4">&quot;cummax&quot;</span><span class="s3">, </span><span class="s1">ndim</span><span class="s3">=</span><span class="s5">1</span><span class="s3">))</span>
    <span class="s2">def </span><span class="s1">cummax</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">: </span><span class="s1">Axis </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">, </span><span class="s1">skipna</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">True</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">NDFrame</span><span class="s3">.</span><span class="s1">cummax</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">skipna</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">doc</span><span class="s3">(</span><span class="s1">make_doc</span><span class="s3">(</span><span class="s4">&quot;cumsum&quot;</span><span class="s3">, </span><span class="s1">ndim</span><span class="s3">=</span><span class="s5">1</span><span class="s3">))</span>
    <span class="s2">def </span><span class="s1">cumsum</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">: </span><span class="s1">Axis </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">, </span><span class="s1">skipna</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">True</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">NDFrame</span><span class="s3">.</span><span class="s1">cumsum</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">skipna</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">doc</span><span class="s3">(</span><span class="s1">make_doc</span><span class="s3">(</span><span class="s4">&quot;cumprod&quot;</span><span class="s3">, </span><span class="s5">1</span><span class="s3">))</span>
    <span class="s2">def </span><span class="s1">cumprod</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">: </span><span class="s1">Axis </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">, </span><span class="s1">skipna</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">True</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">NDFrame</span><span class="s3">.</span><span class="s1">cumprod</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">skipna</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">)</span>
</pre>
</body>
</html>