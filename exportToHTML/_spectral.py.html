<html>
<head>
<title>_spectral.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #7a7e85;}
.s3 { color: #cf8e6d;}
.s4 { color: #bcbec4;}
.s5 { color: #2aacb8;}
.s6 { color: #6aab73;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_spectral.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Algorithms for spectral clustering&quot;&quot;&quot;</span>

<span class="s2"># Author: Gael Varoquaux &lt;gael.varoquaux@normalesup.org&gt;</span>
<span class="s2">#         Brian Cheung</span>
<span class="s2">#         Wei LI &lt;kuantkid@gmail.com&gt;</span>
<span class="s2">#         Andrew Knyazev &lt;Andrew.Knyazev@ucdenver.edu&gt;</span>
<span class="s2"># License: BSD 3 clause</span>

<span class="s3">import </span><span class="s1">warnings</span>
<span class="s3">from </span><span class="s1">numbers </span><span class="s3">import </span><span class="s1">Integral</span><span class="s4">, </span><span class="s1">Real</span>

<span class="s3">import </span><span class="s1">numpy </span><span class="s3">as </span><span class="s1">np</span>
<span class="s3">from </span><span class="s1">scipy</span><span class="s4">.</span><span class="s1">linalg </span><span class="s3">import </span><span class="s1">LinAlgError</span><span class="s4">, </span><span class="s1">qr</span><span class="s4">, </span><span class="s1">svd</span>
<span class="s3">from </span><span class="s1">scipy</span><span class="s4">.</span><span class="s1">sparse </span><span class="s3">import </span><span class="s1">csc_matrix</span>

<span class="s3">from </span><span class="s4">..</span><span class="s1">base </span><span class="s3">import </span><span class="s1">BaseEstimator</span><span class="s4">, </span><span class="s1">ClusterMixin</span><span class="s4">, </span><span class="s1">_fit_context</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">manifold</span><span class="s4">.</span><span class="s1">_spectral_embedding </span><span class="s3">import </span><span class="s1">_spectral_embedding</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">metrics</span><span class="s4">.</span><span class="s1">pairwise </span><span class="s3">import </span><span class="s1">KERNEL_PARAMS</span><span class="s4">, </span><span class="s1">pairwise_kernels</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">neighbors </span><span class="s3">import </span><span class="s1">NearestNeighbors</span><span class="s4">, </span><span class="s1">kneighbors_graph</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">utils </span><span class="s3">import </span><span class="s1">as_float_array</span><span class="s4">, </span><span class="s1">check_random_state</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">utils</span><span class="s4">.</span><span class="s1">_param_validation </span><span class="s3">import </span><span class="s1">Interval</span><span class="s4">, </span><span class="s1">StrOptions</span><span class="s4">, </span><span class="s1">validate_params</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">_kmeans </span><span class="s3">import </span><span class="s1">k_means</span>


<span class="s3">def </span><span class="s1">cluster_qr</span><span class="s4">(</span><span class="s1">vectors</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Find the discrete partition closest to the eigenvector embedding. 
 
        This implementation was proposed in [1]_. 
 
    .. versionadded:: 1.1 
 
        Parameters 
        ---------- 
        vectors : array-like, shape: (n_samples, n_clusters) 
            The embedding space of the samples. 
 
        Returns 
        ------- 
        labels : array of integers, shape: n_samples 
            The cluster labels of vectors. 
 
        References 
        ---------- 
        .. [1] :doi:`Simple, direct, and efficient multi-way spectral clustering, 2019 
            Anil Damle, Victor Minden, Lexing Ying 
            &lt;10.1093/imaiai/iay008&gt;` 
 
    &quot;&quot;&quot;</span>

    <span class="s1">k </span><span class="s4">= </span><span class="s1">vectors</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s5">1</span><span class="s4">]</span>
    <span class="s1">_</span><span class="s4">, </span><span class="s1">_</span><span class="s4">, </span><span class="s1">piv </span><span class="s4">= </span><span class="s1">qr</span><span class="s4">(</span><span class="s1">vectors</span><span class="s4">.</span><span class="s1">T</span><span class="s4">, </span><span class="s1">pivoting</span><span class="s4">=</span><span class="s3">True</span><span class="s4">)</span>
    <span class="s1">ut</span><span class="s4">, </span><span class="s1">_</span><span class="s4">, </span><span class="s1">v </span><span class="s4">= </span><span class="s1">svd</span><span class="s4">(</span><span class="s1">vectors</span><span class="s4">[</span><span class="s1">piv</span><span class="s4">[:</span><span class="s1">k</span><span class="s4">], :].</span><span class="s1">T</span><span class="s4">)</span>
    <span class="s1">vectors </span><span class="s4">= </span><span class="s1">abs</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">dot</span><span class="s4">(</span><span class="s1">vectors</span><span class="s4">, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">dot</span><span class="s4">(</span><span class="s1">ut</span><span class="s4">, </span><span class="s1">v</span><span class="s4">.</span><span class="s1">conj</span><span class="s4">())))</span>
    <span class="s3">return </span><span class="s1">vectors</span><span class="s4">.</span><span class="s1">argmax</span><span class="s4">(</span><span class="s1">axis</span><span class="s4">=</span><span class="s5">1</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">discretize</span><span class="s4">(</span>
    <span class="s1">vectors</span><span class="s4">, *, </span><span class="s1">copy</span><span class="s4">=</span><span class="s3">True</span><span class="s4">, </span><span class="s1">max_svd_restarts</span><span class="s4">=</span><span class="s5">30</span><span class="s4">, </span><span class="s1">n_iter_max</span><span class="s4">=</span><span class="s5">20</span><span class="s4">, </span><span class="s1">random_state</span><span class="s4">=</span><span class="s3">None</span>
<span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Search for a partition matrix which is closest to the eigenvector embedding. 
 
    This implementation was proposed in [1]_. 
 
    Parameters 
    ---------- 
    vectors : array-like of shape (n_samples, n_clusters) 
        The embedding space of the samples. 
 
    copy : bool, default=True 
        Whether to copy vectors, or perform in-place normalization. 
 
    max_svd_restarts : int, default=30 
        Maximum number of attempts to restart SVD if convergence fails 
 
    n_iter_max : int, default=30 
        Maximum number of iterations to attempt in rotation and partition 
        matrix search if machine precision convergence is not reached 
 
    random_state : int, RandomState instance, default=None 
        Determines random number generation for rotation matrix initialization. 
        Use an int to make the randomness deterministic. 
        See :term:`Glossary &lt;random_state&gt;`. 
 
    Returns 
    ------- 
    labels : array of integers, shape: n_samples 
        The labels of the clusters. 
 
    References 
    ---------- 
 
    .. [1] `Multiclass spectral clustering, 2003 
           Stella X. Yu, Jianbo Shi 
           &lt;https://people.eecs.berkeley.edu/~jordan/courses/281B-spring04/readings/yu-shi.pdf&gt;`_ 
 
    Notes 
    ----- 
 
    The eigenvector embedding is used to iteratively search for the 
    closest discrete partition.  First, the eigenvector embedding is 
    normalized to the space of partition matrices. An optimal discrete 
    partition matrix closest to this normalized embedding multiplied by 
    an initial rotation is calculated.  Fixing this discrete partition 
    matrix, an optimal rotation matrix is calculated.  These two 
    calculations are performed until convergence.  The discrete partition 
    matrix is returned as the clustering solution.  Used in spectral 
    clustering, this method tends to be faster and more robust to random 
    initialization than k-means. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">random_state </span><span class="s4">= </span><span class="s1">check_random_state</span><span class="s4">(</span><span class="s1">random_state</span><span class="s4">)</span>

    <span class="s1">vectors </span><span class="s4">= </span><span class="s1">as_float_array</span><span class="s4">(</span><span class="s1">vectors</span><span class="s4">, </span><span class="s1">copy</span><span class="s4">=</span><span class="s1">copy</span><span class="s4">)</span>

    <span class="s1">eps </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">finfo</span><span class="s4">(</span><span class="s1">float</span><span class="s4">).</span><span class="s1">eps</span>
    <span class="s1">n_samples</span><span class="s4">, </span><span class="s1">n_components </span><span class="s4">= </span><span class="s1">vectors</span><span class="s4">.</span><span class="s1">shape</span>

    <span class="s2"># Normalize the eigenvectors to an equal length of a vector of ones.</span>
    <span class="s2"># Reorient the eigenvectors to point in the negative direction with respect</span>
    <span class="s2"># to the first element.  This may have to do with constraining the</span>
    <span class="s2"># eigenvectors to lie in a specific quadrant to make the discretization</span>
    <span class="s2"># search easier.</span>
    <span class="s1">norm_ones </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">sqrt</span><span class="s4">(</span><span class="s1">n_samples</span><span class="s4">)</span>
    <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range</span><span class="s4">(</span><span class="s1">vectors</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s5">1</span><span class="s4">]):</span>
        <span class="s1">vectors</span><span class="s4">[:, </span><span class="s1">i</span><span class="s4">] = (</span><span class="s1">vectors</span><span class="s4">[:, </span><span class="s1">i</span><span class="s4">] / </span><span class="s1">np</span><span class="s4">.</span><span class="s1">linalg</span><span class="s4">.</span><span class="s1">norm</span><span class="s4">(</span><span class="s1">vectors</span><span class="s4">[:, </span><span class="s1">i</span><span class="s4">])) * </span><span class="s1">norm_ones</span>
        <span class="s3">if </span><span class="s1">vectors</span><span class="s4">[</span><span class="s5">0</span><span class="s4">, </span><span class="s1">i</span><span class="s4">] != </span><span class="s5">0</span><span class="s4">:</span>
            <span class="s1">vectors</span><span class="s4">[:, </span><span class="s1">i</span><span class="s4">] = -</span><span class="s5">1 </span><span class="s4">* </span><span class="s1">vectors</span><span class="s4">[:, </span><span class="s1">i</span><span class="s4">] * </span><span class="s1">np</span><span class="s4">.</span><span class="s1">sign</span><span class="s4">(</span><span class="s1">vectors</span><span class="s4">[</span><span class="s5">0</span><span class="s4">, </span><span class="s1">i</span><span class="s4">])</span>

    <span class="s2"># Normalize the rows of the eigenvectors.  Samples should lie on the unit</span>
    <span class="s2"># hypersphere centered at the origin.  This transforms the samples in the</span>
    <span class="s2"># embedding space to the space of partition matrices.</span>
    <span class="s1">vectors </span><span class="s4">= </span><span class="s1">vectors </span><span class="s4">/ </span><span class="s1">np</span><span class="s4">.</span><span class="s1">sqrt</span><span class="s4">((</span><span class="s1">vectors</span><span class="s4">**</span><span class="s5">2</span><span class="s4">).</span><span class="s1">sum</span><span class="s4">(</span><span class="s1">axis</span><span class="s4">=</span><span class="s5">1</span><span class="s4">))[:, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">newaxis</span><span class="s4">]</span>

    <span class="s1">svd_restarts </span><span class="s4">= </span><span class="s5">0</span>
    <span class="s1">has_converged </span><span class="s4">= </span><span class="s3">False</span>

    <span class="s2"># If there is an exception we try to randomize and rerun SVD again</span>
    <span class="s2"># do this max_svd_restarts times.</span>
    <span class="s3">while </span><span class="s4">(</span><span class="s1">svd_restarts </span><span class="s4">&lt; </span><span class="s1">max_svd_restarts</span><span class="s4">) </span><span class="s3">and not </span><span class="s1">has_converged</span><span class="s4">:</span>
        <span class="s2"># Initialize first column of rotation matrix with a row of the</span>
        <span class="s2"># eigenvectors</span>
        <span class="s1">rotation </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">zeros</span><span class="s4">((</span><span class="s1">n_components</span><span class="s4">, </span><span class="s1">n_components</span><span class="s4">))</span>
        <span class="s1">rotation</span><span class="s4">[:, </span><span class="s5">0</span><span class="s4">] = </span><span class="s1">vectors</span><span class="s4">[</span><span class="s1">random_state</span><span class="s4">.</span><span class="s1">randint</span><span class="s4">(</span><span class="s1">n_samples</span><span class="s4">), :].</span><span class="s1">T</span>

        <span class="s2"># To initialize the rest of the rotation matrix, find the rows</span>
        <span class="s2"># of the eigenvectors that are as orthogonal to each other as</span>
        <span class="s2"># possible</span>
        <span class="s1">c </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">zeros</span><span class="s4">(</span><span class="s1">n_samples</span><span class="s4">)</span>
        <span class="s3">for </span><span class="s1">j </span><span class="s3">in </span><span class="s1">range</span><span class="s4">(</span><span class="s5">1</span><span class="s4">, </span><span class="s1">n_components</span><span class="s4">):</span>
            <span class="s2"># Accumulate c to ensure row is as orthogonal as possible to</span>
            <span class="s2"># previous picks as well as current one</span>
            <span class="s1">c </span><span class="s4">+= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">abs</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">dot</span><span class="s4">(</span><span class="s1">vectors</span><span class="s4">, </span><span class="s1">rotation</span><span class="s4">[:, </span><span class="s1">j </span><span class="s4">- </span><span class="s5">1</span><span class="s4">]))</span>
            <span class="s1">rotation</span><span class="s4">[:, </span><span class="s1">j</span><span class="s4">] = </span><span class="s1">vectors</span><span class="s4">[</span><span class="s1">c</span><span class="s4">.</span><span class="s1">argmin</span><span class="s4">(), :].</span><span class="s1">T</span>

        <span class="s1">last_objective_value </span><span class="s4">= </span><span class="s5">0.0</span>
        <span class="s1">n_iter </span><span class="s4">= </span><span class="s5">0</span>

        <span class="s3">while not </span><span class="s1">has_converged</span><span class="s4">:</span>
            <span class="s1">n_iter </span><span class="s4">+= </span><span class="s5">1</span>

            <span class="s1">t_discrete </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">dot</span><span class="s4">(</span><span class="s1">vectors</span><span class="s4">, </span><span class="s1">rotation</span><span class="s4">)</span>

            <span class="s1">labels </span><span class="s4">= </span><span class="s1">t_discrete</span><span class="s4">.</span><span class="s1">argmax</span><span class="s4">(</span><span class="s1">axis</span><span class="s4">=</span><span class="s5">1</span><span class="s4">)</span>
            <span class="s1">vectors_discrete </span><span class="s4">= </span><span class="s1">csc_matrix</span><span class="s4">(</span>
                <span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">ones</span><span class="s4">(</span><span class="s1">len</span><span class="s4">(</span><span class="s1">labels</span><span class="s4">)), (</span><span class="s1">np</span><span class="s4">.</span><span class="s1">arange</span><span class="s4">(</span><span class="s5">0</span><span class="s4">, </span><span class="s1">n_samples</span><span class="s4">), </span><span class="s1">labels</span><span class="s4">)),</span>
                <span class="s1">shape</span><span class="s4">=(</span><span class="s1">n_samples</span><span class="s4">, </span><span class="s1">n_components</span><span class="s4">),</span>
            <span class="s4">)</span>

            <span class="s1">t_svd </span><span class="s4">= </span><span class="s1">vectors_discrete</span><span class="s4">.</span><span class="s1">T </span><span class="s4">* </span><span class="s1">vectors</span>

            <span class="s3">try</span><span class="s4">:</span>
                <span class="s1">U</span><span class="s4">, </span><span class="s1">S</span><span class="s4">, </span><span class="s1">Vh </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">linalg</span><span class="s4">.</span><span class="s1">svd</span><span class="s4">(</span><span class="s1">t_svd</span><span class="s4">)</span>
            <span class="s3">except </span><span class="s1">LinAlgError</span><span class="s4">:</span>
                <span class="s1">svd_restarts </span><span class="s4">+= </span><span class="s5">1</span>
                <span class="s1">print</span><span class="s4">(</span><span class="s6">&quot;SVD did not converge, randomizing and trying again&quot;</span><span class="s4">)</span>
                <span class="s3">break</span>

            <span class="s1">ncut_value </span><span class="s4">= </span><span class="s5">2.0 </span><span class="s4">* (</span><span class="s1">n_samples </span><span class="s4">- </span><span class="s1">S</span><span class="s4">.</span><span class="s1">sum</span><span class="s4">())</span>
            <span class="s3">if </span><span class="s4">(</span><span class="s1">abs</span><span class="s4">(</span><span class="s1">ncut_value </span><span class="s4">- </span><span class="s1">last_objective_value</span><span class="s4">) &lt; </span><span class="s1">eps</span><span class="s4">) </span><span class="s3">or </span><span class="s4">(</span><span class="s1">n_iter </span><span class="s4">&gt; </span><span class="s1">n_iter_max</span><span class="s4">):</span>
                <span class="s1">has_converged </span><span class="s4">= </span><span class="s3">True</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s2"># otherwise calculate rotation and continue</span>
                <span class="s1">last_objective_value </span><span class="s4">= </span><span class="s1">ncut_value</span>
                <span class="s1">rotation </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">dot</span><span class="s4">(</span><span class="s1">Vh</span><span class="s4">.</span><span class="s1">T</span><span class="s4">, </span><span class="s1">U</span><span class="s4">.</span><span class="s1">T</span><span class="s4">)</span>

    <span class="s3">if not </span><span class="s1">has_converged</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">LinAlgError</span><span class="s4">(</span><span class="s6">&quot;SVD did not converge&quot;</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s1">labels</span>


<span class="s4">@</span><span class="s1">validate_params</span><span class="s4">(</span>
    <span class="s4">{</span><span class="s6">&quot;affinity&quot;</span><span class="s4">: [</span><span class="s6">&quot;array-like&quot;</span><span class="s4">, </span><span class="s6">&quot;sparse matrix&quot;</span><span class="s4">]},</span>
    <span class="s1">prefer_skip_nested_validation</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
<span class="s4">)</span>
<span class="s3">def </span><span class="s1">spectral_clustering</span><span class="s4">(</span>
    <span class="s1">affinity</span><span class="s4">,</span>
    <span class="s4">*,</span>
    <span class="s1">n_clusters</span><span class="s4">=</span><span class="s5">8</span><span class="s4">,</span>
    <span class="s1">n_components</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
    <span class="s1">eigen_solver</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
    <span class="s1">random_state</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
    <span class="s1">n_init</span><span class="s4">=</span><span class="s5">10</span><span class="s4">,</span>
    <span class="s1">eigen_tol</span><span class="s4">=</span><span class="s6">&quot;auto&quot;</span><span class="s4">,</span>
    <span class="s1">assign_labels</span><span class="s4">=</span><span class="s6">&quot;kmeans&quot;</span><span class="s4">,</span>
    <span class="s1">verbose</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
<span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Apply clustering to a projection of the normalized Laplacian. 
 
    In practice Spectral Clustering is very useful when the structure of 
    the individual clusters is highly non-convex or more generally when 
    a measure of the center and spread of the cluster is not a suitable 
    description of the complete cluster. For instance, when clusters are 
    nested circles on the 2D plane. 
 
    If affinity is the adjacency matrix of a graph, this method can be 
    used to find normalized graph cuts [1]_, [2]_. 
 
    Read more in the :ref:`User Guide &lt;spectral_clustering&gt;`. 
 
    Parameters 
    ---------- 
    affinity : {array-like, sparse matrix} of shape (n_samples, n_samples) 
        The affinity matrix describing the relationship of the samples to 
        embed. **Must be symmetric**. 
 
        Possible examples: 
          - adjacency matrix of a graph, 
          - heat kernel of the pairwise distance matrix of the samples, 
          - symmetric k-nearest neighbours connectivity matrix of the samples. 
 
    n_clusters : int, default=None 
        Number of clusters to extract. 
 
    n_components : int, default=n_clusters 
        Number of eigenvectors to use for the spectral embedding. 
 
    eigen_solver : {None, 'arpack', 'lobpcg', or 'amg'} 
        The eigenvalue decomposition method. If None then ``'arpack'`` is used. 
        See [4]_ for more details regarding ``'lobpcg'``. 
        Eigensolver ``'amg'`` runs ``'lobpcg'`` with optional 
        Algebraic MultiGrid preconditioning and requires pyamg to be installed. 
        It can be faster on very large sparse problems [6]_ and [7]_. 
 
    random_state : int, RandomState instance, default=None 
        A pseudo random number generator used for the initialization 
        of the lobpcg eigenvectors decomposition when `eigen_solver == 
        'amg'`, and for the K-Means initialization. Use an int to make 
        the results deterministic across calls (See 
        :term:`Glossary &lt;random_state&gt;`). 
 
        .. note:: 
            When using `eigen_solver == 'amg'`, 
            it is necessary to also fix the global numpy seed with 
            `np.random.seed(int)` to get deterministic results. See 
            https://github.com/pyamg/pyamg/issues/139 for further 
            information. 
 
    n_init : int, default=10 
        Number of time the k-means algorithm will be run with different 
        centroid seeds. The final results will be the best output of n_init 
        consecutive runs in terms of inertia. Only used if 
        ``assign_labels='kmeans'``. 
 
    eigen_tol : float, default=&quot;auto&quot; 
        Stopping criterion for eigendecomposition of the Laplacian matrix. 
        If `eigen_tol=&quot;auto&quot;` then the passed tolerance will depend on the 
        `eigen_solver`: 
 
        - If `eigen_solver=&quot;arpack&quot;`, then `eigen_tol=0.0`; 
        - If `eigen_solver=&quot;lobpcg&quot;` or `eigen_solver=&quot;amg&quot;`, then 
          `eigen_tol=None` which configures the underlying `lobpcg` solver to 
          automatically resolve the value according to their heuristics. See, 
          :func:`scipy.sparse.linalg.lobpcg` for details. 
 
        Note that when using `eigen_solver=&quot;lobpcg&quot;` or `eigen_solver=&quot;amg&quot;` 
        values of `tol&lt;1e-5` may lead to convergence issues and should be 
        avoided. 
 
        .. versionadded:: 1.2 
           Added 'auto' option. 
 
    assign_labels : {'kmeans', 'discretize', 'cluster_qr'}, default='kmeans' 
        The strategy to use to assign labels in the embedding 
        space.  There are three ways to assign labels after the Laplacian 
        embedding.  k-means can be applied and is a popular choice. But it can 
        also be sensitive to initialization. Discretization is another 
        approach which is less sensitive to random initialization [3]_. 
        The cluster_qr method [5]_ directly extracts clusters from eigenvectors 
        in spectral clustering. In contrast to k-means and discretization, cluster_qr 
        has no tuning parameters and is not an iterative method, yet may outperform 
        k-means and discretization in terms of both quality and speed. 
 
        .. versionchanged:: 1.1 
           Added new labeling method 'cluster_qr'. 
 
    verbose : bool, default=False 
        Verbosity mode. 
 
        .. versionadded:: 0.24 
 
    Returns 
    ------- 
    labels : array of integers, shape: n_samples 
        The labels of the clusters. 
 
    Notes 
    ----- 
    The graph should contain only one connected component, elsewhere 
    the results make little sense. 
 
    This algorithm solves the normalized cut for `k=2`: it is a 
    normalized spectral clustering. 
 
    References 
    ---------- 
 
    .. [1] :doi:`Normalized cuts and image segmentation, 2000 
           Jianbo Shi, Jitendra Malik 
           &lt;10.1109/34.868688&gt;` 
 
    .. [2] :doi:`A Tutorial on Spectral Clustering, 2007 
           Ulrike von Luxburg 
           &lt;10.1007/s11222-007-9033-z&gt;` 
 
    .. [3] `Multiclass spectral clustering, 2003 
           Stella X. Yu, Jianbo Shi 
           &lt;https://people.eecs.berkeley.edu/~jordan/courses/281B-spring04/readings/yu-shi.pdf&gt;`_ 
 
    .. [4] :doi:`Toward the Optimal Preconditioned Eigensolver: 
           Locally Optimal Block Preconditioned Conjugate Gradient Method, 2001 
           A. V. Knyazev 
           SIAM Journal on Scientific Computing 23, no. 2, pp. 517-541. 
           &lt;10.1137/S1064827500366124&gt;` 
 
    .. [5] :doi:`Simple, direct, and efficient multi-way spectral clustering, 2019 
           Anil Damle, Victor Minden, Lexing Ying 
           &lt;10.1093/imaiai/iay008&gt;` 
 
    .. [6] :doi:`Multiscale Spectral Image Segmentation Multiscale preconditioning 
           for computing eigenvalues of graph Laplacians in image segmentation, 2006 
           Andrew Knyazev 
           &lt;10.13140/RG.2.2.35280.02565&gt;` 
 
    .. [7] :doi:`Preconditioned spectral clustering for stochastic block partition 
           streaming graph challenge (Preliminary version at arXiv.) 
           David Zhuzhunashvili, Andrew Knyazev 
           &lt;10.1109/HPEC.2017.8091045&gt;` 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from sklearn.metrics.pairwise import pairwise_kernels 
    &gt;&gt;&gt; from sklearn.cluster import spectral_clustering 
    &gt;&gt;&gt; X = np.array([[1, 1], [2, 1], [1, 0], 
    ...               [4, 7], [3, 5], [3, 6]]) 
    &gt;&gt;&gt; affinity = pairwise_kernels(X, metric='rbf') 
    &gt;&gt;&gt; spectral_clustering( 
    ...     affinity=affinity, n_clusters=2, assign_labels=&quot;discretize&quot;, random_state=0 
    ... ) 
    array([1, 1, 1, 0, 0, 0]) 
    &quot;&quot;&quot;</span>

    <span class="s1">clusterer </span><span class="s4">= </span><span class="s1">SpectralClustering</span><span class="s4">(</span>
        <span class="s1">n_clusters</span><span class="s4">=</span><span class="s1">n_clusters</span><span class="s4">,</span>
        <span class="s1">n_components</span><span class="s4">=</span><span class="s1">n_components</span><span class="s4">,</span>
        <span class="s1">eigen_solver</span><span class="s4">=</span><span class="s1">eigen_solver</span><span class="s4">,</span>
        <span class="s1">random_state</span><span class="s4">=</span><span class="s1">random_state</span><span class="s4">,</span>
        <span class="s1">n_init</span><span class="s4">=</span><span class="s1">n_init</span><span class="s4">,</span>
        <span class="s1">affinity</span><span class="s4">=</span><span class="s6">&quot;precomputed&quot;</span><span class="s4">,</span>
        <span class="s1">eigen_tol</span><span class="s4">=</span><span class="s1">eigen_tol</span><span class="s4">,</span>
        <span class="s1">assign_labels</span><span class="s4">=</span><span class="s1">assign_labels</span><span class="s4">,</span>
        <span class="s1">verbose</span><span class="s4">=</span><span class="s1">verbose</span><span class="s4">,</span>
    <span class="s4">).</span><span class="s1">fit</span><span class="s4">(</span><span class="s1">affinity</span><span class="s4">)</span>

    <span class="s3">return </span><span class="s1">clusterer</span><span class="s4">.</span><span class="s1">labels_</span>


<span class="s3">class </span><span class="s1">SpectralClustering</span><span class="s4">(</span><span class="s1">ClusterMixin</span><span class="s4">, </span><span class="s1">BaseEstimator</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Apply clustering to a projection of the normalized Laplacian. 
 
    In practice Spectral Clustering is very useful when the structure of 
    the individual clusters is highly non-convex, or more generally when 
    a measure of the center and spread of the cluster is not a suitable 
    description of the complete cluster, such as when clusters are 
    nested circles on the 2D plane. 
 
    If the affinity matrix is the adjacency matrix of a graph, this method 
    can be used to find normalized graph cuts [1]_, [2]_. 
 
    When calling ``fit``, an affinity matrix is constructed using either 
    a kernel function such the Gaussian (aka RBF) kernel with Euclidean 
    distance ``d(X, X)``:: 
 
            np.exp(-gamma * d(X,X) ** 2) 
 
    or a k-nearest neighbors connectivity matrix. 
 
    Alternatively, a user-provided affinity matrix can be specified by 
    setting ``affinity='precomputed'``. 
 
    Read more in the :ref:`User Guide &lt;spectral_clustering&gt;`. 
 
    Parameters 
    ---------- 
    n_clusters : int, default=8 
        The dimension of the projection subspace. 
 
    eigen_solver : {'arpack', 'lobpcg', 'amg'}, default=None 
        The eigenvalue decomposition strategy to use. AMG requires pyamg 
        to be installed. It can be faster on very large, sparse problems, 
        but may also lead to instabilities. If None, then ``'arpack'`` is 
        used. See [4]_ for more details regarding `'lobpcg'`. 
 
    n_components : int, default=None 
        Number of eigenvectors to use for the spectral embedding. If None, 
        defaults to `n_clusters`. 
 
    random_state : int, RandomState instance, default=None 
        A pseudo random number generator used for the initialization 
        of the lobpcg eigenvectors decomposition when `eigen_solver == 
        'amg'`, and for the K-Means initialization. Use an int to make 
        the results deterministic across calls (See 
        :term:`Glossary &lt;random_state&gt;`). 
 
        .. note:: 
            When using `eigen_solver == 'amg'`, 
            it is necessary to also fix the global numpy seed with 
            `np.random.seed(int)` to get deterministic results. See 
            https://github.com/pyamg/pyamg/issues/139 for further 
            information. 
 
    n_init : int, default=10 
        Number of time the k-means algorithm will be run with different 
        centroid seeds. The final results will be the best output of n_init 
        consecutive runs in terms of inertia. Only used if 
        ``assign_labels='kmeans'``. 
 
    gamma : float, default=1.0 
        Kernel coefficient for rbf, poly, sigmoid, laplacian and chi2 kernels. 
        Ignored for ``affinity='nearest_neighbors'``, ``affinity='precomputed'`` 
        or ``affinity='precomputed_nearest_neighbors'``. 
 
    affinity : str or callable, default='rbf' 
        How to construct the affinity matrix. 
         - 'nearest_neighbors': construct the affinity matrix by computing a 
           graph of nearest neighbors. 
         - 'rbf': construct the affinity matrix using a radial basis function 
           (RBF) kernel. 
         - 'precomputed': interpret ``X`` as a precomputed affinity matrix, 
           where larger values indicate greater similarity between instances. 
         - 'precomputed_nearest_neighbors': interpret ``X`` as a sparse graph 
           of precomputed distances, and construct a binary affinity matrix 
           from the ``n_neighbors`` nearest neighbors of each instance. 
         - one of the kernels supported by 
           :func:`~sklearn.metrics.pairwise.pairwise_kernels`. 
 
        Only kernels that produce similarity scores (non-negative values that 
        increase with similarity) should be used. This property is not checked 
        by the clustering algorithm. 
 
    n_neighbors : int, default=10 
        Number of neighbors to use when constructing the affinity matrix using 
        the nearest neighbors method. Ignored for ``affinity='rbf'``. 
 
    eigen_tol : float, default=&quot;auto&quot; 
        Stopping criterion for eigen decomposition of the Laplacian matrix. 
        If `eigen_tol=&quot;auto&quot;` then the passed tolerance will depend on the 
        `eigen_solver`: 
 
        - If `eigen_solver=&quot;arpack&quot;`, then `eigen_tol=0.0`; 
        - If `eigen_solver=&quot;lobpcg&quot;` or `eigen_solver=&quot;amg&quot;`, then 
          `eigen_tol=None` which configures the underlying `lobpcg` solver to 
          automatically resolve the value according to their heuristics. See, 
          :func:`scipy.sparse.linalg.lobpcg` for details. 
 
        Note that when using `eigen_solver=&quot;lobpcg&quot;` or `eigen_solver=&quot;amg&quot;` 
        values of `tol&lt;1e-5` may lead to convergence issues and should be 
        avoided. 
 
        .. versionadded:: 1.2 
           Added 'auto' option. 
 
    assign_labels : {'kmeans', 'discretize', 'cluster_qr'}, default='kmeans' 
        The strategy for assigning labels in the embedding space. There are two 
        ways to assign labels after the Laplacian embedding. k-means is a 
        popular choice, but it can be sensitive to initialization. 
        Discretization is another approach which is less sensitive to random 
        initialization [3]_. 
        The cluster_qr method [5]_ directly extract clusters from eigenvectors 
        in spectral clustering. In contrast to k-means and discretization, cluster_qr 
        has no tuning parameters and runs no iterations, yet may outperform 
        k-means and discretization in terms of both quality and speed. 
 
        .. versionchanged:: 1.1 
           Added new labeling method 'cluster_qr'. 
 
    degree : float, default=3 
        Degree of the polynomial kernel. Ignored by other kernels. 
 
    coef0 : float, default=1 
        Zero coefficient for polynomial and sigmoid kernels. 
        Ignored by other kernels. 
 
    kernel_params : dict of str to any, default=None 
        Parameters (keyword arguments) and values for kernel passed as 
        callable object. Ignored by other kernels. 
 
    n_jobs : int, default=None 
        The number of parallel jobs to run when `affinity='nearest_neighbors'` 
        or `affinity='precomputed_nearest_neighbors'`. The neighbors search 
        will be done in parallel. 
        ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context. 
        ``-1`` means using all processors. See :term:`Glossary &lt;n_jobs&gt;` 
        for more details. 
 
    verbose : bool, default=False 
        Verbosity mode. 
 
        .. versionadded:: 0.24 
 
    Attributes 
    ---------- 
    affinity_matrix_ : array-like of shape (n_samples, n_samples) 
        Affinity matrix used for clustering. Available only after calling 
        ``fit``. 
 
    labels_ : ndarray of shape (n_samples,) 
        Labels of each point 
 
    n_features_in_ : int 
        Number of features seen during :term:`fit`. 
 
        .. versionadded:: 0.24 
 
    feature_names_in_ : ndarray of shape (`n_features_in_`,) 
        Names of features seen during :term:`fit`. Defined only when `X` 
        has feature names that are all strings. 
 
        .. versionadded:: 1.0 
 
    See Also 
    -------- 
    sklearn.cluster.KMeans : K-Means clustering. 
    sklearn.cluster.DBSCAN : Density-Based Spatial Clustering of 
        Applications with Noise. 
 
    Notes 
    ----- 
    A distance matrix for which 0 indicates identical elements and high values 
    indicate very dissimilar elements can be transformed into an affinity / 
    similarity matrix that is well-suited for the algorithm by 
    applying the Gaussian (aka RBF, heat) kernel:: 
 
        np.exp(- dist_matrix ** 2 / (2. * delta ** 2)) 
 
    where ``delta`` is a free parameter representing the width of the Gaussian 
    kernel. 
 
    An alternative is to take a symmetric version of the k-nearest neighbors 
    connectivity matrix of the points. 
 
    If the pyamg package is installed, it is used: this greatly 
    speeds up computation. 
 
    References 
    ---------- 
    .. [1] :doi:`Normalized cuts and image segmentation, 2000 
           Jianbo Shi, Jitendra Malik 
           &lt;10.1109/34.868688&gt;` 
 
    .. [2] :doi:`A Tutorial on Spectral Clustering, 2007 
           Ulrike von Luxburg 
           &lt;10.1007/s11222-007-9033-z&gt;` 
 
    .. [3] `Multiclass spectral clustering, 2003 
           Stella X. Yu, Jianbo Shi 
           &lt;https://people.eecs.berkeley.edu/~jordan/courses/281B-spring04/readings/yu-shi.pdf&gt;`_ 
 
    .. [4] :doi:`Toward the Optimal Preconditioned Eigensolver: 
           Locally Optimal Block Preconditioned Conjugate Gradient Method, 2001 
           A. V. Knyazev 
           SIAM Journal on Scientific Computing 23, no. 2, pp. 517-541. 
           &lt;10.1137/S1064827500366124&gt;` 
 
    .. [5] :doi:`Simple, direct, and efficient multi-way spectral clustering, 2019 
           Anil Damle, Victor Minden, Lexing Ying 
           &lt;10.1093/imaiai/iay008&gt;` 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from sklearn.cluster import SpectralClustering 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; X = np.array([[1, 1], [2, 1], [1, 0], 
    ...               [4, 7], [3, 5], [3, 6]]) 
    &gt;&gt;&gt; clustering = SpectralClustering(n_clusters=2, 
    ...         assign_labels='discretize', 
    ...         random_state=0).fit(X) 
    &gt;&gt;&gt; clustering.labels_ 
    array([1, 1, 1, 0, 0, 0]) 
    &gt;&gt;&gt; clustering 
    SpectralClustering(assign_labels='discretize', n_clusters=2, 
        random_state=0) 
    &quot;&quot;&quot;</span>

    <span class="s1">_parameter_constraints</span><span class="s4">: </span><span class="s1">dict </span><span class="s4">= {</span>
        <span class="s6">&quot;n_clusters&quot;</span><span class="s4">: [</span><span class="s1">Interval</span><span class="s4">(</span><span class="s1">Integral</span><span class="s4">, </span><span class="s5">1</span><span class="s4">, </span><span class="s3">None</span><span class="s4">, </span><span class="s1">closed</span><span class="s4">=</span><span class="s6">&quot;left&quot;</span><span class="s4">)],</span>
        <span class="s6">&quot;eigen_solver&quot;</span><span class="s4">: [</span><span class="s1">StrOptions</span><span class="s4">({</span><span class="s6">&quot;arpack&quot;</span><span class="s4">, </span><span class="s6">&quot;lobpcg&quot;</span><span class="s4">, </span><span class="s6">&quot;amg&quot;</span><span class="s4">}), </span><span class="s3">None</span><span class="s4">],</span>
        <span class="s6">&quot;n_components&quot;</span><span class="s4">: [</span><span class="s1">Interval</span><span class="s4">(</span><span class="s1">Integral</span><span class="s4">, </span><span class="s5">1</span><span class="s4">, </span><span class="s3">None</span><span class="s4">, </span><span class="s1">closed</span><span class="s4">=</span><span class="s6">&quot;left&quot;</span><span class="s4">), </span><span class="s3">None</span><span class="s4">],</span>
        <span class="s6">&quot;random_state&quot;</span><span class="s4">: [</span><span class="s6">&quot;random_state&quot;</span><span class="s4">],</span>
        <span class="s6">&quot;n_init&quot;</span><span class="s4">: [</span><span class="s1">Interval</span><span class="s4">(</span><span class="s1">Integral</span><span class="s4">, </span><span class="s5">1</span><span class="s4">, </span><span class="s3">None</span><span class="s4">, </span><span class="s1">closed</span><span class="s4">=</span><span class="s6">&quot;left&quot;</span><span class="s4">)],</span>
        <span class="s6">&quot;gamma&quot;</span><span class="s4">: [</span><span class="s1">Interval</span><span class="s4">(</span><span class="s1">Real</span><span class="s4">, </span><span class="s5">0</span><span class="s4">, </span><span class="s3">None</span><span class="s4">, </span><span class="s1">closed</span><span class="s4">=</span><span class="s6">&quot;left&quot;</span><span class="s4">)],</span>
        <span class="s6">&quot;affinity&quot;</span><span class="s4">: [</span>
            <span class="s1">callable</span><span class="s4">,</span>
            <span class="s1">StrOptions</span><span class="s4">(</span>
                <span class="s1">set</span><span class="s4">(</span><span class="s1">KERNEL_PARAMS</span><span class="s4">)</span>
                <span class="s4">| {</span><span class="s6">&quot;nearest_neighbors&quot;</span><span class="s4">, </span><span class="s6">&quot;precomputed&quot;</span><span class="s4">, </span><span class="s6">&quot;precomputed_nearest_neighbors&quot;</span><span class="s4">}</span>
            <span class="s4">),</span>
        <span class="s4">],</span>
        <span class="s6">&quot;n_neighbors&quot;</span><span class="s4">: [</span><span class="s1">Interval</span><span class="s4">(</span><span class="s1">Integral</span><span class="s4">, </span><span class="s5">1</span><span class="s4">, </span><span class="s3">None</span><span class="s4">, </span><span class="s1">closed</span><span class="s4">=</span><span class="s6">&quot;left&quot;</span><span class="s4">)],</span>
        <span class="s6">&quot;eigen_tol&quot;</span><span class="s4">: [</span>
            <span class="s1">Interval</span><span class="s4">(</span><span class="s1">Real</span><span class="s4">, </span><span class="s5">0.0</span><span class="s4">, </span><span class="s3">None</span><span class="s4">, </span><span class="s1">closed</span><span class="s4">=</span><span class="s6">&quot;left&quot;</span><span class="s4">),</span>
            <span class="s1">StrOptions</span><span class="s4">({</span><span class="s6">&quot;auto&quot;</span><span class="s4">}),</span>
        <span class="s4">],</span>
        <span class="s6">&quot;assign_labels&quot;</span><span class="s4">: [</span><span class="s1">StrOptions</span><span class="s4">({</span><span class="s6">&quot;kmeans&quot;</span><span class="s4">, </span><span class="s6">&quot;discretize&quot;</span><span class="s4">, </span><span class="s6">&quot;cluster_qr&quot;</span><span class="s4">})],</span>
        <span class="s6">&quot;degree&quot;</span><span class="s4">: [</span><span class="s1">Interval</span><span class="s4">(</span><span class="s1">Real</span><span class="s4">, </span><span class="s5">0</span><span class="s4">, </span><span class="s3">None</span><span class="s4">, </span><span class="s1">closed</span><span class="s4">=</span><span class="s6">&quot;left&quot;</span><span class="s4">)],</span>
        <span class="s6">&quot;coef0&quot;</span><span class="s4">: [</span><span class="s1">Interval</span><span class="s4">(</span><span class="s1">Real</span><span class="s4">, </span><span class="s3">None</span><span class="s4">, </span><span class="s3">None</span><span class="s4">, </span><span class="s1">closed</span><span class="s4">=</span><span class="s6">&quot;neither&quot;</span><span class="s4">)],</span>
        <span class="s6">&quot;kernel_params&quot;</span><span class="s4">: [</span><span class="s1">dict</span><span class="s4">, </span><span class="s3">None</span><span class="s4">],</span>
        <span class="s6">&quot;n_jobs&quot;</span><span class="s4">: [</span><span class="s1">Integral</span><span class="s4">, </span><span class="s3">None</span><span class="s4">],</span>
        <span class="s6">&quot;verbose&quot;</span><span class="s4">: [</span><span class="s6">&quot;verbose&quot;</span><span class="s4">],</span>
    <span class="s4">}</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">n_clusters</span><span class="s4">=</span><span class="s5">8</span><span class="s4">,</span>
        <span class="s4">*,</span>
        <span class="s1">eigen_solver</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">n_components</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">random_state</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">n_init</span><span class="s4">=</span><span class="s5">10</span><span class="s4">,</span>
        <span class="s1">gamma</span><span class="s4">=</span><span class="s5">1.0</span><span class="s4">,</span>
        <span class="s1">affinity</span><span class="s4">=</span><span class="s6">&quot;rbf&quot;</span><span class="s4">,</span>
        <span class="s1">n_neighbors</span><span class="s4">=</span><span class="s5">10</span><span class="s4">,</span>
        <span class="s1">eigen_tol</span><span class="s4">=</span><span class="s6">&quot;auto&quot;</span><span class="s4">,</span>
        <span class="s1">assign_labels</span><span class="s4">=</span><span class="s6">&quot;kmeans&quot;</span><span class="s4">,</span>
        <span class="s1">degree</span><span class="s4">=</span><span class="s5">3</span><span class="s4">,</span>
        <span class="s1">coef0</span><span class="s4">=</span><span class="s5">1</span><span class="s4">,</span>
        <span class="s1">kernel_params</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">n_jobs</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">verbose</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
    <span class="s4">):</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">n_clusters </span><span class="s4">= </span><span class="s1">n_clusters</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">eigen_solver </span><span class="s4">= </span><span class="s1">eigen_solver</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">n_components </span><span class="s4">= </span><span class="s1">n_components</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">random_state </span><span class="s4">= </span><span class="s1">random_state</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">n_init </span><span class="s4">= </span><span class="s1">n_init</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">gamma </span><span class="s4">= </span><span class="s1">gamma</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">affinity </span><span class="s4">= </span><span class="s1">affinity</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">n_neighbors </span><span class="s4">= </span><span class="s1">n_neighbors</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">eigen_tol </span><span class="s4">= </span><span class="s1">eigen_tol</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">assign_labels </span><span class="s4">= </span><span class="s1">assign_labels</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">degree </span><span class="s4">= </span><span class="s1">degree</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">coef0 </span><span class="s4">= </span><span class="s1">coef0</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">kernel_params </span><span class="s4">= </span><span class="s1">kernel_params</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">n_jobs </span><span class="s4">= </span><span class="s1">n_jobs</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">verbose </span><span class="s4">= </span><span class="s1">verbose</span>

    <span class="s4">@</span><span class="s1">_fit_context</span><span class="s4">(</span><span class="s1">prefer_skip_nested_validation</span><span class="s4">=</span><span class="s3">True</span><span class="s4">)</span>
    <span class="s3">def </span><span class="s1">fit</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">X</span><span class="s4">, </span><span class="s1">y</span><span class="s4">=</span><span class="s3">None</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Perform spectral clustering from features, or affinity matrix. 
 
        Parameters 
        ---------- 
        X : {array-like, sparse matrix} of shape (n_samples, n_features) or \ 
                (n_samples, n_samples) 
            Training instances to cluster, similarities / affinities between 
            instances if ``affinity='precomputed'``, or distances between 
            instances if ``affinity='precomputed_nearest_neighbors``. If a 
            sparse matrix is provided in a format other than ``csr_matrix``, 
            ``csc_matrix``, or ``coo_matrix``, it will be converted into a 
            sparse ``csr_matrix``. 
 
        y : Ignored 
            Not used, present here for API consistency by convention. 
 
        Returns 
        ------- 
        self : object 
            A fitted instance of the estimator. 
        &quot;&quot;&quot;</span>
        <span class="s1">X </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_validate_data</span><span class="s4">(</span>
            <span class="s1">X</span><span class="s4">,</span>
            <span class="s1">accept_sparse</span><span class="s4">=[</span><span class="s6">&quot;csr&quot;</span><span class="s4">, </span><span class="s6">&quot;csc&quot;</span><span class="s4">, </span><span class="s6">&quot;coo&quot;</span><span class="s4">],</span>
            <span class="s1">dtype</span><span class="s4">=</span><span class="s1">np</span><span class="s4">.</span><span class="s1">float64</span><span class="s4">,</span>
            <span class="s1">ensure_min_samples</span><span class="s4">=</span><span class="s5">2</span><span class="s4">,</span>
        <span class="s4">)</span>
        <span class="s1">allow_squared </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">affinity </span><span class="s3">in </span><span class="s4">[</span>
            <span class="s6">&quot;precomputed&quot;</span><span class="s4">,</span>
            <span class="s6">&quot;precomputed_nearest_neighbors&quot;</span><span class="s4">,</span>
        <span class="s4">]</span>
        <span class="s3">if </span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s5">0</span><span class="s4">] == </span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s5">1</span><span class="s4">] </span><span class="s3">and not </span><span class="s1">allow_squared</span><span class="s4">:</span>
            <span class="s1">warnings</span><span class="s4">.</span><span class="s1">warn</span><span class="s4">(</span>
                <span class="s6">&quot;The spectral clustering API has changed. ``fit``&quot;</span>
                <span class="s6">&quot;now constructs an affinity matrix from data. To use&quot;</span>
                <span class="s6">&quot; a custom affinity matrix, &quot;</span>
                <span class="s6">&quot;set ``affinity=precomputed``.&quot;</span>
            <span class="s4">)</span>

        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">affinity </span><span class="s4">== </span><span class="s6">&quot;nearest_neighbors&quot;</span><span class="s4">:</span>
            <span class="s1">connectivity </span><span class="s4">= </span><span class="s1">kneighbors_graph</span><span class="s4">(</span>
                <span class="s1">X</span><span class="s4">, </span><span class="s1">n_neighbors</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">n_neighbors</span><span class="s4">, </span><span class="s1">include_self</span><span class="s4">=</span><span class="s3">True</span><span class="s4">, </span><span class="s1">n_jobs</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">n_jobs</span>
            <span class="s4">)</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">affinity_matrix_ </span><span class="s4">= </span><span class="s5">0.5 </span><span class="s4">* (</span><span class="s1">connectivity </span><span class="s4">+ </span><span class="s1">connectivity</span><span class="s4">.</span><span class="s1">T</span><span class="s4">)</span>
        <span class="s3">elif </span><span class="s1">self</span><span class="s4">.</span><span class="s1">affinity </span><span class="s4">== </span><span class="s6">&quot;precomputed_nearest_neighbors&quot;</span><span class="s4">:</span>
            <span class="s1">estimator </span><span class="s4">= </span><span class="s1">NearestNeighbors</span><span class="s4">(</span>
                <span class="s1">n_neighbors</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">n_neighbors</span><span class="s4">, </span><span class="s1">n_jobs</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">n_jobs</span><span class="s4">, </span><span class="s1">metric</span><span class="s4">=</span><span class="s6">&quot;precomputed&quot;</span>
            <span class="s4">).</span><span class="s1">fit</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)</span>
            <span class="s1">connectivity </span><span class="s4">= </span><span class="s1">estimator</span><span class="s4">.</span><span class="s1">kneighbors_graph</span><span class="s4">(</span><span class="s1">X</span><span class="s4">=</span><span class="s1">X</span><span class="s4">, </span><span class="s1">mode</span><span class="s4">=</span><span class="s6">&quot;connectivity&quot;</span><span class="s4">)</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">affinity_matrix_ </span><span class="s4">= </span><span class="s5">0.5 </span><span class="s4">* (</span><span class="s1">connectivity </span><span class="s4">+ </span><span class="s1">connectivity</span><span class="s4">.</span><span class="s1">T</span><span class="s4">)</span>
        <span class="s3">elif </span><span class="s1">self</span><span class="s4">.</span><span class="s1">affinity </span><span class="s4">== </span><span class="s6">&quot;precomputed&quot;</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">affinity_matrix_ </span><span class="s4">= </span><span class="s1">X</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">params </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">kernel_params</span>
            <span class="s3">if </span><span class="s1">params </span><span class="s3">is None</span><span class="s4">:</span>
                <span class="s1">params </span><span class="s4">= {}</span>
            <span class="s3">if not </span><span class="s1">callable</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">affinity</span><span class="s4">):</span>
                <span class="s1">params</span><span class="s4">[</span><span class="s6">&quot;gamma&quot;</span><span class="s4">] = </span><span class="s1">self</span><span class="s4">.</span><span class="s1">gamma</span>
                <span class="s1">params</span><span class="s4">[</span><span class="s6">&quot;degree&quot;</span><span class="s4">] = </span><span class="s1">self</span><span class="s4">.</span><span class="s1">degree</span>
                <span class="s1">params</span><span class="s4">[</span><span class="s6">&quot;coef0&quot;</span><span class="s4">] = </span><span class="s1">self</span><span class="s4">.</span><span class="s1">coef0</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">affinity_matrix_ </span><span class="s4">= </span><span class="s1">pairwise_kernels</span><span class="s4">(</span>
                <span class="s1">X</span><span class="s4">, </span><span class="s1">metric</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">affinity</span><span class="s4">, </span><span class="s1">filter_params</span><span class="s4">=</span><span class="s3">True</span><span class="s4">, **</span><span class="s1">params</span>
            <span class="s4">)</span>

        <span class="s1">random_state </span><span class="s4">= </span><span class="s1">check_random_state</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">random_state</span><span class="s4">)</span>
        <span class="s1">n_components </span><span class="s4">= (</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">n_clusters </span><span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">n_components </span><span class="s3">is None else </span><span class="s1">self</span><span class="s4">.</span><span class="s1">n_components</span>
        <span class="s4">)</span>
        <span class="s2"># We now obtain the real valued solution matrix to the</span>
        <span class="s2"># relaxed Ncut problem, solving the eigenvalue problem</span>
        <span class="s2"># L_sym x = lambda x  and recovering u = D^-1/2 x.</span>
        <span class="s2"># The first eigenvector is constant only for fully connected graphs</span>
        <span class="s2"># and should be kept for spectral clustering (drop_first = False)</span>
        <span class="s2"># See spectral_embedding documentation.</span>
        <span class="s1">maps </span><span class="s4">= </span><span class="s1">_spectral_embedding</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">affinity_matrix_</span><span class="s4">,</span>
            <span class="s1">n_components</span><span class="s4">=</span><span class="s1">n_components</span><span class="s4">,</span>
            <span class="s1">eigen_solver</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">eigen_solver</span><span class="s4">,</span>
            <span class="s1">random_state</span><span class="s4">=</span><span class="s1">random_state</span><span class="s4">,</span>
            <span class="s1">eigen_tol</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">eigen_tol</span><span class="s4">,</span>
            <span class="s1">drop_first</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
        <span class="s4">)</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">verbose</span><span class="s4">:</span>
            <span class="s1">print</span><span class="s4">(</span><span class="s6">f&quot;Computing label assignment using </span><span class="s3">{</span><span class="s1">self</span><span class="s4">.</span><span class="s1">assign_labels</span><span class="s3">}</span><span class="s6">&quot;</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">assign_labels </span><span class="s4">== </span><span class="s6">&quot;kmeans&quot;</span><span class="s4">:</span>
            <span class="s1">_</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">labels_</span><span class="s4">, </span><span class="s1">_ </span><span class="s4">= </span><span class="s1">k_means</span><span class="s4">(</span>
                <span class="s1">maps</span><span class="s4">,</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">n_clusters</span><span class="s4">,</span>
                <span class="s1">random_state</span><span class="s4">=</span><span class="s1">random_state</span><span class="s4">,</span>
                <span class="s1">n_init</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">n_init</span><span class="s4">,</span>
                <span class="s1">verbose</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">verbose</span><span class="s4">,</span>
            <span class="s4">)</span>
        <span class="s3">elif </span><span class="s1">self</span><span class="s4">.</span><span class="s1">assign_labels </span><span class="s4">== </span><span class="s6">&quot;cluster_qr&quot;</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">labels_ </span><span class="s4">= </span><span class="s1">cluster_qr</span><span class="s4">(</span><span class="s1">maps</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">labels_ </span><span class="s4">= </span><span class="s1">discretize</span><span class="s4">(</span><span class="s1">maps</span><span class="s4">, </span><span class="s1">random_state</span><span class="s4">=</span><span class="s1">random_state</span><span class="s4">)</span>

        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">fit_predict</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">X</span><span class="s4">, </span><span class="s1">y</span><span class="s4">=</span><span class="s3">None</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Perform spectral clustering on `X` and return cluster labels. 
 
        Parameters 
        ---------- 
        X : {array-like, sparse matrix} of shape (n_samples, n_features) or \ 
                (n_samples, n_samples) 
            Training instances to cluster, similarities / affinities between 
            instances if ``affinity='precomputed'``, or distances between 
            instances if ``affinity='precomputed_nearest_neighbors``. If a 
            sparse matrix is provided in a format other than ``csr_matrix``, 
            ``csc_matrix``, or ``coo_matrix``, it will be converted into a 
            sparse ``csr_matrix``. 
 
        y : Ignored 
            Not used, present here for API consistency by convention. 
 
        Returns 
        ------- 
        labels : ndarray of shape (n_samples,) 
            Cluster labels. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">super</span><span class="s4">().</span><span class="s1">fit_predict</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">y</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_more_tags</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s4">{</span>
            <span class="s6">&quot;pairwise&quot;</span><span class="s4">: </span><span class="s1">self</span><span class="s4">.</span><span class="s1">affinity</span>
            <span class="s3">in </span><span class="s4">[</span>
                <span class="s6">&quot;precomputed&quot;</span><span class="s4">,</span>
                <span class="s6">&quot;precomputed_nearest_neighbors&quot;</span><span class="s4">,</span>
            <span class="s4">]</span>
        <span class="s4">}</span>
</pre>
</body>
</html>