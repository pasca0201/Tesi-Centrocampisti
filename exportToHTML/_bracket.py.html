<html>
<head>
<title>_bracket.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #2aacb8;}
.s4 { color: #7a7e85;}
.s5 { color: #6aab73;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_bracket.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">import </span><span class="s1">scipy</span><span class="s2">.</span><span class="s1">_lib</span><span class="s2">.</span><span class="s1">_elementwise_iterative_method </span><span class="s0">as </span><span class="s1">eim</span>
<span class="s0">from </span><span class="s1">scipy</span><span class="s2">.</span><span class="s1">_lib</span><span class="s2">.</span><span class="s1">_util </span><span class="s0">import </span><span class="s1">_RichResult</span>

<span class="s1">_ELIMITS </span><span class="s2">= -</span><span class="s3">1  </span><span class="s4"># used in _bracket_root</span>
<span class="s1">_ESTOPONESIDE </span><span class="s2">= </span><span class="s3">2  </span><span class="s4"># used in _bracket_root</span>

<span class="s0">def </span><span class="s1">_bracket_root_iv</span><span class="s2">(</span><span class="s1">func</span><span class="s2">, </span><span class="s1">xl0</span><span class="s2">, </span><span class="s1">xr0</span><span class="s2">, </span><span class="s1">xmin</span><span class="s2">, </span><span class="s1">xmax</span><span class="s2">, </span><span class="s1">factor</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">maxiter</span><span class="s2">):</span>

    <span class="s0">if not </span><span class="s1">callable</span><span class="s2">(</span><span class="s1">func</span><span class="s2">):</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s5">'`func` must be callable.'</span><span class="s2">)</span>

    <span class="s0">if not </span><span class="s1">np</span><span class="s2">.</span><span class="s1">iterable</span><span class="s2">(</span><span class="s1">args</span><span class="s2">):</span>
        <span class="s1">args </span><span class="s2">= (</span><span class="s1">args</span><span class="s2">,)</span>

    <span class="s1">xl0 </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">xl0</span><span class="s2">)[()]</span>
    <span class="s0">if not </span><span class="s1">np</span><span class="s2">.</span><span class="s1">issubdtype</span><span class="s2">(</span><span class="s1">xl0</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">number</span><span class="s2">) </span><span class="s0">or </span><span class="s1">np</span><span class="s2">.</span><span class="s1">iscomplex</span><span class="s2">(</span><span class="s1">xl0</span><span class="s2">).</span><span class="s1">any</span><span class="s2">():</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s5">'`xl0` must be numeric and real.'</span><span class="s2">)</span>

    <span class="s1">xr0 </span><span class="s2">= </span><span class="s1">xl0 </span><span class="s2">+ </span><span class="s3">1 </span><span class="s0">if </span><span class="s1">xr0 </span><span class="s0">is None else </span><span class="s1">xr0</span>
    <span class="s1">xmin </span><span class="s2">= -</span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf </span><span class="s0">if </span><span class="s1">xmin </span><span class="s0">is None else </span><span class="s1">xmin</span>
    <span class="s1">xmax </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf </span><span class="s0">if </span><span class="s1">xmax </span><span class="s0">is None else </span><span class="s1">xmax</span>
    <span class="s1">factor </span><span class="s2">= </span><span class="s3">2. </span><span class="s0">if </span><span class="s1">factor </span><span class="s0">is None else </span><span class="s1">factor</span>
    <span class="s1">xl0</span><span class="s2">, </span><span class="s1">xr0</span><span class="s2">, </span><span class="s1">xmin</span><span class="s2">, </span><span class="s1">xmax</span><span class="s2">, </span><span class="s1">factor </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">broadcast_arrays</span><span class="s2">(</span><span class="s1">xl0</span><span class="s2">, </span><span class="s1">xr0</span><span class="s2">, </span><span class="s1">xmin</span><span class="s2">, </span><span class="s1">xmax</span><span class="s2">, </span><span class="s1">factor</span><span class="s2">)</span>

    <span class="s0">if not </span><span class="s1">np</span><span class="s2">.</span><span class="s1">issubdtype</span><span class="s2">(</span><span class="s1">xr0</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">number</span><span class="s2">) </span><span class="s0">or </span><span class="s1">np</span><span class="s2">.</span><span class="s1">iscomplex</span><span class="s2">(</span><span class="s1">xr0</span><span class="s2">).</span><span class="s1">any</span><span class="s2">():</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s5">'`xr0` must be numeric and real.'</span><span class="s2">)</span>

    <span class="s0">if not </span><span class="s1">np</span><span class="s2">.</span><span class="s1">issubdtype</span><span class="s2">(</span><span class="s1">xmin</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">number</span><span class="s2">) </span><span class="s0">or </span><span class="s1">np</span><span class="s2">.</span><span class="s1">iscomplex</span><span class="s2">(</span><span class="s1">xmin</span><span class="s2">).</span><span class="s1">any</span><span class="s2">():</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s5">'`xmin` must be numeric and real.'</span><span class="s2">)</span>

    <span class="s0">if not </span><span class="s1">np</span><span class="s2">.</span><span class="s1">issubdtype</span><span class="s2">(</span><span class="s1">xmax</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">number</span><span class="s2">) </span><span class="s0">or </span><span class="s1">np</span><span class="s2">.</span><span class="s1">iscomplex</span><span class="s2">(</span><span class="s1">xmax</span><span class="s2">).</span><span class="s1">any</span><span class="s2">():</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s5">'`xmax` must be numeric and real.'</span><span class="s2">)</span>

    <span class="s0">if not </span><span class="s1">np</span><span class="s2">.</span><span class="s1">issubdtype</span><span class="s2">(</span><span class="s1">factor</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">number</span><span class="s2">) </span><span class="s0">or </span><span class="s1">np</span><span class="s2">.</span><span class="s1">iscomplex</span><span class="s2">(</span><span class="s1">factor</span><span class="s2">).</span><span class="s1">any</span><span class="s2">():</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s5">'`factor` must be numeric and real.'</span><span class="s2">)</span>
    <span class="s0">if not </span><span class="s1">np</span><span class="s2">.</span><span class="s1">all</span><span class="s2">(</span><span class="s1">factor </span><span class="s2">&gt; </span><span class="s3">1</span><span class="s2">):</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s5">'All elements of `factor` must be greater than 1.'</span><span class="s2">)</span>

    <span class="s1">maxiter </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">maxiter</span><span class="s2">)</span>
    <span class="s1">message </span><span class="s2">= </span><span class="s5">'`maxiter` must be a non-negative integer.'</span>
    <span class="s0">if </span><span class="s2">(</span><span class="s0">not </span><span class="s1">np</span><span class="s2">.</span><span class="s1">issubdtype</span><span class="s2">(</span><span class="s1">maxiter</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">number</span><span class="s2">) </span><span class="s0">or </span><span class="s1">maxiter</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">!= </span><span class="s1">tuple</span><span class="s2">()</span>
            <span class="s0">or </span><span class="s1">np</span><span class="s2">.</span><span class="s1">iscomplex</span><span class="s2">(</span><span class="s1">maxiter</span><span class="s2">)):</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s1">message</span><span class="s2">)</span>
    <span class="s1">maxiter_int </span><span class="s2">= </span><span class="s1">int</span><span class="s2">(</span><span class="s1">maxiter</span><span class="s2">[()])</span>
    <span class="s0">if not </span><span class="s1">maxiter </span><span class="s2">== </span><span class="s1">maxiter_int </span><span class="s0">or </span><span class="s1">maxiter </span><span class="s2">&lt; </span><span class="s3">0</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s1">message</span><span class="s2">)</span>

    <span class="s0">return </span><span class="s1">func</span><span class="s2">, </span><span class="s1">xl0</span><span class="s2">, </span><span class="s1">xr0</span><span class="s2">, </span><span class="s1">xmin</span><span class="s2">, </span><span class="s1">xmax</span><span class="s2">, </span><span class="s1">factor</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">maxiter</span>


<span class="s0">def </span><span class="s1">_bracket_root</span><span class="s2">(</span><span class="s1">func</span><span class="s2">, </span><span class="s1">xl0</span><span class="s2">, </span><span class="s1">xr0</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, *, </span><span class="s1">xmin</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">xmax</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">factor</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
                  <span class="s1">args</span><span class="s2">=(), </span><span class="s1">maxiter</span><span class="s2">=</span><span class="s3">1000</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot;Bracket the root of a monotonic scalar function of one variable 
 
    This function works elementwise when `xl0`, `xr0`, `xmin`, `xmax`, `factor`, and 
    the elements of `args` are broadcastable arrays. 
 
    Parameters 
    ---------- 
    func : callable 
        The function for which the root is to be bracketed. 
        The signature must be:: 
 
            func(x: ndarray, *args) -&gt; ndarray 
 
        where each element of ``x`` is a finite real and ``args`` is a tuple, 
        which may contain an arbitrary number of arrays that are broadcastable 
        with `x`. ``func`` must be an elementwise function: each element 
        ``func(x)[i]`` must equal ``func(x[i])`` for all indices ``i``. 
    xl0, xr0: float array_like 
        Starting guess of bracket, which need not contain a root. If `xr0` is 
        not provided, ``xr0 = xl0 + 1``. Must be broadcastable with one another. 
    xmin, xmax : float array_like, optional 
        Minimum and maximum allowable endpoints of the bracket, inclusive. Must 
        be broadcastable with `xl0` and `xr0`. 
    factor : float array_like, default: 2 
        The factor used to grow the bracket. See notes for details. 
    args : tuple, optional 
        Additional positional arguments to be passed to `func`.  Must be arrays 
        broadcastable with `xl0`, `xr0`, `xmin`, and `xmax`. If the callable to be 
        bracketed requires arguments that are not broadcastable with these 
        arrays, wrap that callable with `func` such that `func` accepts 
        only `x` and broadcastable arrays. 
    maxiter : int, optional 
        The maximum number of iterations of the algorithm to perform. 
 
    Returns 
    ------- 
    res : _RichResult 
        An instance of `scipy._lib._util._RichResult` with the following 
        attributes. The descriptions are written as though the values will be 
        scalars; however, if `func` returns an array, the outputs will be 
        arrays of the same shape. 
 
        xl, xr : float 
            The lower and upper ends of the bracket, if the algorithm 
            terminated successfully. 
        fl, fr : float 
            The function value at the lower and upper ends of the bracket. 
        nfev : int 
            The number of function evaluations required to find the bracket. 
            This is distinct from the number of times `func` is *called* 
            because the function may evaluated at multiple points in a single 
            call. 
        nit : int 
            The number of iterations of the algorithm that were performed. 
        status : int 
            An integer representing the exit status of the algorithm. 
 
            - ``0`` : The algorithm produced a valid bracket. 
            - ``-1`` : The bracket expanded to the allowable limits without finding a bracket. 
            - ``-2`` : The maximum number of iterations was reached. 
            - ``-3`` : A non-finite value was encountered. 
            - ``-4`` : Iteration was terminated by `callback`. 
            - ``-5``: The initial bracket does not satisfy `xmin &lt;= xl0 &lt; xr0 &lt; xmax`. 
            - ``1`` : The algorithm is proceeding normally (in `callback` only). 
            - ``2`` : A bracket was found in the opposite search direction (in `callback` only). 
 
        success : bool 
            ``True`` when the algorithm terminated successfully (status ``0``). 
 
    Notes 
    ----- 
    This function generalizes an algorithm found in pieces throughout 
    `scipy.stats`. The strategy is to iteratively grow the bracket `(l, r)` 
     until ``func(l) &lt; 0 &lt; func(r)``. The bracket grows to the left as follows. 
 
    - If `xmin` is not provided, the distance between `xl0` and `l` is iteratively 
      increased by `factor`. 
    - If `xmin` is provided, the distance between `xmin` and `l` is iteratively 
      decreased by `factor`. Note that this also *increases* the bracket size. 
 
    Growth of the bracket to the right is analogous. 
 
    Growth of the bracket in one direction stops when the endpoint is no longer 
    finite, the function value at the endpoint is no longer finite, or the 
    endpoint reaches its limiting value (`xmin` or `xmax`). Iteration terminates 
    when the bracket stops growing in both directions, the bracket surrounds 
    the root, or a root is found (accidentally). 
 
    If two brackets are found - that is, a bracket is found on both sides in 
    the same iteration, the smaller of the two is returned. 
    If roots of the function are found, both `l` and `r` are set to the 
    leftmost root. 
 
    &quot;&quot;&quot;  </span><span class="s4"># noqa: E501</span>
    <span class="s4"># Todo:</span>
    <span class="s4"># - find bracket with sign change in specified direction</span>
    <span class="s4"># - Add tolerance</span>
    <span class="s4"># - allow factor &lt; 1?</span>

    <span class="s1">callback </span><span class="s2">= </span><span class="s0">None  </span><span class="s4"># works; I just don't want to test it</span>
    <span class="s1">temp </span><span class="s2">= </span><span class="s1">_bracket_root_iv</span><span class="s2">(</span><span class="s1">func</span><span class="s2">, </span><span class="s1">xl0</span><span class="s2">, </span><span class="s1">xr0</span><span class="s2">, </span><span class="s1">xmin</span><span class="s2">, </span><span class="s1">xmax</span><span class="s2">, </span><span class="s1">factor</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">maxiter</span><span class="s2">)</span>
    <span class="s1">func</span><span class="s2">, </span><span class="s1">xl0</span><span class="s2">, </span><span class="s1">xr0</span><span class="s2">, </span><span class="s1">xmin</span><span class="s2">, </span><span class="s1">xmax</span><span class="s2">, </span><span class="s1">factor</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">maxiter </span><span class="s2">= </span><span class="s1">temp</span>

    <span class="s1">xs </span><span class="s2">= (</span><span class="s1">xl0</span><span class="s2">, </span><span class="s1">xr0</span><span class="s2">)</span>
    <span class="s1">temp </span><span class="s2">= </span><span class="s1">eim</span><span class="s2">.</span><span class="s1">_initialize</span><span class="s2">(</span><span class="s1">func</span><span class="s2">, </span><span class="s1">xs</span><span class="s2">, </span><span class="s1">args</span><span class="s2">)</span>
    <span class="s1">func</span><span class="s2">, </span><span class="s1">xs</span><span class="s2">, </span><span class="s1">fs</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">shape</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">xp </span><span class="s2">= </span><span class="s1">temp  </span><span class="s4"># line split for PEP8</span>
    <span class="s1">xl0</span><span class="s2">, </span><span class="s1">xr0 </span><span class="s2">= </span><span class="s1">xs</span>
    <span class="s1">xmin </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">broadcast_to</span><span class="s2">(</span><span class="s1">xmin</span><span class="s2">, </span><span class="s1">shape</span><span class="s2">).</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s0">False</span><span class="s2">).</span><span class="s1">ravel</span><span class="s2">()</span>
    <span class="s1">xmax </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">broadcast_to</span><span class="s2">(</span><span class="s1">xmax</span><span class="s2">, </span><span class="s1">shape</span><span class="s2">).</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s0">False</span><span class="s2">).</span><span class="s1">ravel</span><span class="s2">()</span>
    <span class="s1">invalid_bracket </span><span class="s2">= ~((</span><span class="s1">xmin </span><span class="s2">&lt;= </span><span class="s1">xl0</span><span class="s2">) &amp; (</span><span class="s1">xl0 </span><span class="s2">&lt; </span><span class="s1">xr0</span><span class="s2">) &amp; (</span><span class="s1">xr0 </span><span class="s2">&lt;= </span><span class="s1">xmax</span><span class="s2">))</span>

    <span class="s4"># The approach is to treat the left and right searches as though they were</span>
    <span class="s4"># (almost) totally independent one-sided bracket searches. (The interaction</span>
    <span class="s4"># is considered when checking for termination and preparing the result</span>
    <span class="s4"># object.)</span>
    <span class="s4"># `x` is the &quot;moving&quot; end of the bracket</span>
    <span class="s1">x </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">concatenate</span><span class="s2">(</span><span class="s1">xs</span><span class="s2">)</span>
    <span class="s1">f </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">concatenate</span><span class="s2">(</span><span class="s1">fs</span><span class="s2">)</span>
    <span class="s1">invalid_bracket </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">concatenate</span><span class="s2">((</span><span class="s1">invalid_bracket</span><span class="s2">, </span><span class="s1">invalid_bracket</span><span class="s2">))</span>
    <span class="s1">n </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">x</span><span class="s2">) // </span><span class="s3">2</span>

    <span class="s4"># `x_last` is the previous location of the moving end of the bracket. If</span>
    <span class="s4"># the signs of `f` and `f_last` are different, `x` and `x_last` form a</span>
    <span class="s4"># bracket.</span>
    <span class="s1">x_last </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">concatenate</span><span class="s2">((</span><span class="s1">x</span><span class="s2">[</span><span class="s1">n</span><span class="s2">:], </span><span class="s1">x</span><span class="s2">[:</span><span class="s1">n</span><span class="s2">]))</span>
    <span class="s1">f_last </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">concatenate</span><span class="s2">((</span><span class="s1">f</span><span class="s2">[</span><span class="s1">n</span><span class="s2">:], </span><span class="s1">f</span><span class="s2">[:</span><span class="s1">n</span><span class="s2">]))</span>
    <span class="s4"># `x0` is the &quot;fixed&quot; end of the bracket.</span>
    <span class="s1">x0 </span><span class="s2">= </span><span class="s1">x_last</span>
    <span class="s4"># We don't need to retain the corresponding function value, since the</span>
    <span class="s4"># fixed end of the bracket is only needed to compute the new value of the</span>
    <span class="s4"># moving end; it is never returned.</span>
    <span class="s1">limit </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">concatenate</span><span class="s2">((</span><span class="s1">xmin</span><span class="s2">, </span><span class="s1">xmax</span><span class="s2">))</span>

    <span class="s1">factor </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">broadcast_to</span><span class="s2">(</span><span class="s1">factor</span><span class="s2">, </span><span class="s1">shape</span><span class="s2">).</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s0">False</span><span class="s2">).</span><span class="s1">ravel</span><span class="s2">()</span>
    <span class="s1">factor </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">concatenate</span><span class="s2">((</span><span class="s1">factor</span><span class="s2">, </span><span class="s1">factor</span><span class="s2">))</span>

    <span class="s1">active </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(</span><span class="s3">2</span><span class="s2">*</span><span class="s1">n</span><span class="s2">)</span>
    <span class="s1">args </span><span class="s2">= [</span><span class="s1">np</span><span class="s2">.</span><span class="s1">concatenate</span><span class="s2">((</span><span class="s1">arg</span><span class="s2">, </span><span class="s1">arg</span><span class="s2">)) </span><span class="s0">for </span><span class="s1">arg </span><span class="s0">in </span><span class="s1">args</span><span class="s2">]</span>

    <span class="s4"># This is needed due to inner workings of `eim._loop`.</span>
    <span class="s4"># We're abusing it a tiny bit.</span>
    <span class="s1">shape </span><span class="s2">= </span><span class="s1">shape </span><span class="s2">+ (</span><span class="s3">2</span><span class="s2">,)</span>

    <span class="s4"># `d` is for &quot;distance&quot;.</span>
    <span class="s4"># For searches without a limit, the distance between the fixed end of the</span>
    <span class="s4"># bracket `x0` and the moving end `x` will grow by `factor` each iteration.</span>
    <span class="s4"># For searches with a limit, the distance between the `limit` and moving</span>
    <span class="s4"># end of the bracket `x` will shrink by `factor` each iteration.</span>
    <span class="s1">i </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isinf</span><span class="s2">(</span><span class="s1">limit</span><span class="s2">)</span>
    <span class="s1">ni </span><span class="s2">= ~</span><span class="s1">i</span>
    <span class="s1">d </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros_like</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)</span>
    <span class="s1">d</span><span class="s2">[</span><span class="s1">i</span><span class="s2">] = </span><span class="s1">x</span><span class="s2">[</span><span class="s1">i</span><span class="s2">] - </span><span class="s1">x0</span><span class="s2">[</span><span class="s1">i</span><span class="s2">]</span>
    <span class="s1">d</span><span class="s2">[</span><span class="s1">ni</span><span class="s2">] = </span><span class="s1">limit</span><span class="s2">[</span><span class="s1">ni</span><span class="s2">] - </span><span class="s1">x</span><span class="s2">[</span><span class="s1">ni</span><span class="s2">]</span>

    <span class="s1">status </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">full_like</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">eim</span><span class="s2">.</span><span class="s1">_EINPROGRESS</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">int</span><span class="s2">)  </span><span class="s4"># in progress</span>
    <span class="s1">status</span><span class="s2">[</span><span class="s1">invalid_bracket</span><span class="s2">] = </span><span class="s1">eim</span><span class="s2">.</span><span class="s1">_EINPUTERR</span>
    <span class="s1">nit</span><span class="s2">, </span><span class="s1">nfev </span><span class="s2">= </span><span class="s3">0</span><span class="s2">, </span><span class="s3">1  </span><span class="s4"># one function evaluation per side performed above</span>

    <span class="s1">work </span><span class="s2">= </span><span class="s1">_RichResult</span><span class="s2">(</span><span class="s1">x</span><span class="s2">=</span><span class="s1">x</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">=</span><span class="s1">x0</span><span class="s2">, </span><span class="s1">f</span><span class="s2">=</span><span class="s1">f</span><span class="s2">, </span><span class="s1">limit</span><span class="s2">=</span><span class="s1">limit</span><span class="s2">, </span><span class="s1">factor</span><span class="s2">=</span><span class="s1">factor</span><span class="s2">,</span>
                       <span class="s1">active</span><span class="s2">=</span><span class="s1">active</span><span class="s2">, </span><span class="s1">d</span><span class="s2">=</span><span class="s1">d</span><span class="s2">, </span><span class="s1">x_last</span><span class="s2">=</span><span class="s1">x_last</span><span class="s2">, </span><span class="s1">f_last</span><span class="s2">=</span><span class="s1">f_last</span><span class="s2">,</span>
                       <span class="s1">nit</span><span class="s2">=</span><span class="s1">nit</span><span class="s2">, </span><span class="s1">nfev</span><span class="s2">=</span><span class="s1">nfev</span><span class="s2">, </span><span class="s1">status</span><span class="s2">=</span><span class="s1">status</span><span class="s2">, </span><span class="s1">args</span><span class="s2">=</span><span class="s1">args</span><span class="s2">,</span>
                       <span class="s1">xl</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">xr</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">fl</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">fr</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">n</span><span class="s2">=</span><span class="s1">n</span><span class="s2">)</span>
    <span class="s1">res_work_pairs </span><span class="s2">= [(</span><span class="s5">'status'</span><span class="s2">, </span><span class="s5">'status'</span><span class="s2">), (</span><span class="s5">'xl'</span><span class="s2">, </span><span class="s5">'xl'</span><span class="s2">), (</span><span class="s5">'xr'</span><span class="s2">, </span><span class="s5">'xr'</span><span class="s2">),</span>
                      <span class="s2">(</span><span class="s5">'nit'</span><span class="s2">, </span><span class="s5">'nit'</span><span class="s2">), (</span><span class="s5">'nfev'</span><span class="s2">, </span><span class="s5">'nfev'</span><span class="s2">), (</span><span class="s5">'fl'</span><span class="s2">, </span><span class="s5">'fl'</span><span class="s2">),</span>
                      <span class="s2">(</span><span class="s5">'fr'</span><span class="s2">, </span><span class="s5">'fr'</span><span class="s2">), (</span><span class="s5">'x'</span><span class="s2">, </span><span class="s5">'x'</span><span class="s2">), (</span><span class="s5">'f'</span><span class="s2">, </span><span class="s5">'f'</span><span class="s2">),</span>
                      <span class="s2">(</span><span class="s5">'x_last'</span><span class="s2">, </span><span class="s5">'x_last'</span><span class="s2">), (</span><span class="s5">'f_last'</span><span class="s2">, </span><span class="s5">'f_last'</span><span class="s2">)]</span>

    <span class="s0">def </span><span class="s1">pre_func_eval</span><span class="s2">(</span><span class="s1">work</span><span class="s2">):</span>
        <span class="s4"># Initialize moving end of bracket</span>
        <span class="s1">x </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros_like</span><span class="s2">(</span><span class="s1">work</span><span class="s2">.</span><span class="s1">x</span><span class="s2">)</span>

        <span class="s4"># Unlimited brackets grow by `factor` by increasing distance from fixed</span>
        <span class="s4"># end to moving end.</span>
        <span class="s1">i </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isinf</span><span class="s2">(</span><span class="s1">work</span><span class="s2">.</span><span class="s1">limit</span><span class="s2">)  </span><span class="s4"># indices of unlimited brackets</span>
        <span class="s1">work</span><span class="s2">.</span><span class="s1">d</span><span class="s2">[</span><span class="s1">i</span><span class="s2">] *= </span><span class="s1">work</span><span class="s2">.</span><span class="s1">factor</span><span class="s2">[</span><span class="s1">i</span><span class="s2">]</span>
        <span class="s1">x</span><span class="s2">[</span><span class="s1">i</span><span class="s2">] = </span><span class="s1">work</span><span class="s2">.</span><span class="s1">x0</span><span class="s2">[</span><span class="s1">i</span><span class="s2">] + </span><span class="s1">work</span><span class="s2">.</span><span class="s1">d</span><span class="s2">[</span><span class="s1">i</span><span class="s2">]</span>

        <span class="s4"># Limited brackets grow by decreasing the distance from the limit to</span>
        <span class="s4"># the moving end.</span>
        <span class="s1">ni </span><span class="s2">= ~</span><span class="s1">i  </span><span class="s4"># indices of limited brackets</span>
        <span class="s1">work</span><span class="s2">.</span><span class="s1">d</span><span class="s2">[</span><span class="s1">ni</span><span class="s2">] /= </span><span class="s1">work</span><span class="s2">.</span><span class="s1">factor</span><span class="s2">[</span><span class="s1">ni</span><span class="s2">]</span>
        <span class="s1">x</span><span class="s2">[</span><span class="s1">ni</span><span class="s2">] = </span><span class="s1">work</span><span class="s2">.</span><span class="s1">limit</span><span class="s2">[</span><span class="s1">ni</span><span class="s2">] - </span><span class="s1">work</span><span class="s2">.</span><span class="s1">d</span><span class="s2">[</span><span class="s1">ni</span><span class="s2">]</span>

        <span class="s0">return </span><span class="s1">x</span>

    <span class="s0">def </span><span class="s1">post_func_eval</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">f</span><span class="s2">, </span><span class="s1">work</span><span class="s2">):</span>
        <span class="s4"># Keep track of the previous location of the moving end so that we can</span>
        <span class="s4"># return a narrower bracket. (The alternative is to remember the</span>
        <span class="s4"># original fixed end, but then the bracket would be wider than needed.)</span>
        <span class="s1">work</span><span class="s2">.</span><span class="s1">x_last </span><span class="s2">= </span><span class="s1">work</span><span class="s2">.</span><span class="s1">x</span>
        <span class="s1">work</span><span class="s2">.</span><span class="s1">f_last </span><span class="s2">= </span><span class="s1">work</span><span class="s2">.</span><span class="s1">f</span>
        <span class="s1">work</span><span class="s2">.</span><span class="s1">x </span><span class="s2">= </span><span class="s1">x</span>
        <span class="s1">work</span><span class="s2">.</span><span class="s1">f </span><span class="s2">= </span><span class="s1">f</span>

    <span class="s0">def </span><span class="s1">check_termination</span><span class="s2">(</span><span class="s1">work</span><span class="s2">):</span>
        <span class="s4"># Condition 0: initial bracket is invalid</span>
        <span class="s1">stop </span><span class="s2">= (</span><span class="s1">work</span><span class="s2">.</span><span class="s1">status </span><span class="s2">== </span><span class="s1">eim</span><span class="s2">.</span><span class="s1">_EINPUTERR</span><span class="s2">)</span>

        <span class="s4"># Condition 1: a valid bracket (or the root itself) has been found</span>
        <span class="s1">sf </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sign</span><span class="s2">(</span><span class="s1">work</span><span class="s2">.</span><span class="s1">f</span><span class="s2">)</span>
        <span class="s1">sf_last </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sign</span><span class="s2">(</span><span class="s1">work</span><span class="s2">.</span><span class="s1">f_last</span><span class="s2">)</span>
        <span class="s1">i </span><span class="s2">= ((</span><span class="s1">sf_last </span><span class="s2">== -</span><span class="s1">sf</span><span class="s2">) | (</span><span class="s1">sf_last </span><span class="s2">== </span><span class="s3">0</span><span class="s2">) | (</span><span class="s1">sf </span><span class="s2">== </span><span class="s3">0</span><span class="s2">)) &amp; ~</span><span class="s1">stop</span>
        <span class="s1">work</span><span class="s2">.</span><span class="s1">status</span><span class="s2">[</span><span class="s1">i</span><span class="s2">] = </span><span class="s1">eim</span><span class="s2">.</span><span class="s1">_ECONVERGED</span>
        <span class="s1">stop</span><span class="s2">[</span><span class="s1">i</span><span class="s2">] = </span><span class="s0">True</span>

        <span class="s4"># Condition 2: the other side's search found a valid bracket.</span>
        <span class="s4"># (If we just found a bracket with the rightward search, we can stop</span>
        <span class="s4">#  the leftward search, and vice-versa.)</span>
        <span class="s4"># To do this, we need to set the status of the other side's search;</span>
        <span class="s4"># this is tricky because `work.status` contains only the *active*</span>
        <span class="s4"># elements, so we don't immediately know the index of the element we</span>
        <span class="s4"># need to set - or even if it's still there. (That search may have</span>
        <span class="s4"># terminated already, e.g. by reaching its `limit`.)</span>
        <span class="s4"># To facilitate this, `work.active` contains a unit integer index of</span>
        <span class="s4"># each search. Index `k` (`k &lt; n)` and `k + n` correspond with a</span>
        <span class="s4"># leftward and rightward search, respectively. Elements are removed</span>
        <span class="s4"># from `work.active` just as they are removed from `work.status`, so</span>
        <span class="s4"># we use `work.active` to help find the right location in</span>
        <span class="s4"># `work.status`.</span>
        <span class="s4"># Get the integer indices of the elements that can also stop</span>
        <span class="s1">also_stop </span><span class="s2">= (</span><span class="s1">work</span><span class="s2">.</span><span class="s1">active</span><span class="s2">[</span><span class="s1">i</span><span class="s2">] + </span><span class="s1">work</span><span class="s2">.</span><span class="s1">n</span><span class="s2">) % (</span><span class="s3">2</span><span class="s2">*</span><span class="s1">work</span><span class="s2">.</span><span class="s1">n</span><span class="s2">)</span>
        <span class="s4"># Check whether they are still active.</span>
        <span class="s4"># To start, we need to find out where in `work.active` they would</span>
        <span class="s4"># appear if they are indeed there.</span>
        <span class="s1">j </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">searchsorted</span><span class="s2">(</span><span class="s1">work</span><span class="s2">.</span><span class="s1">active</span><span class="s2">, </span><span class="s1">also_stop</span><span class="s2">)</span>
        <span class="s4"># If the location exceeds the length of the `work.active`, they are</span>
        <span class="s4"># not there.</span>
        <span class="s1">j </span><span class="s2">= </span><span class="s1">j</span><span class="s2">[</span><span class="s1">j </span><span class="s2">&lt; </span><span class="s1">len</span><span class="s2">(</span><span class="s1">work</span><span class="s2">.</span><span class="s1">active</span><span class="s2">)]</span>
        <span class="s4"># Check whether they are still there.</span>
        <span class="s1">j </span><span class="s2">= </span><span class="s1">j</span><span class="s2">[</span><span class="s1">also_stop </span><span class="s2">== </span><span class="s1">work</span><span class="s2">.</span><span class="s1">active</span><span class="s2">[</span><span class="s1">j</span><span class="s2">]]</span>
        <span class="s4"># Now convert these to boolean indices to use with `work.status`.</span>
        <span class="s1">i </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros_like</span><span class="s2">(</span><span class="s1">stop</span><span class="s2">)</span>
        <span class="s1">i</span><span class="s2">[</span><span class="s1">j</span><span class="s2">] = </span><span class="s0">True  </span><span class="s4"># boolean indices of elements that can also stop</span>
        <span class="s1">i </span><span class="s2">= </span><span class="s1">i </span><span class="s2">&amp; ~</span><span class="s1">stop</span>
        <span class="s1">work</span><span class="s2">.</span><span class="s1">status</span><span class="s2">[</span><span class="s1">i</span><span class="s2">] = </span><span class="s1">_ESTOPONESIDE</span>
        <span class="s1">stop</span><span class="s2">[</span><span class="s1">i</span><span class="s2">] = </span><span class="s0">True</span>

        <span class="s4"># Condition 3: moving end of bracket reaches limit</span>
        <span class="s1">i </span><span class="s2">= (</span><span class="s1">work</span><span class="s2">.</span><span class="s1">x </span><span class="s2">== </span><span class="s1">work</span><span class="s2">.</span><span class="s1">limit</span><span class="s2">) &amp; ~</span><span class="s1">stop</span>
        <span class="s1">work</span><span class="s2">.</span><span class="s1">status</span><span class="s2">[</span><span class="s1">i</span><span class="s2">] = </span><span class="s1">_ELIMITS</span>
        <span class="s1">stop</span><span class="s2">[</span><span class="s1">i</span><span class="s2">] = </span><span class="s0">True</span>

        <span class="s4"># Condition 4: non-finite value encountered</span>
        <span class="s1">i </span><span class="s2">= ~(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">isfinite</span><span class="s2">(</span><span class="s1">work</span><span class="s2">.</span><span class="s1">x</span><span class="s2">) &amp; </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isfinite</span><span class="s2">(</span><span class="s1">work</span><span class="s2">.</span><span class="s1">f</span><span class="s2">)) &amp; ~</span><span class="s1">stop</span>
        <span class="s1">work</span><span class="s2">.</span><span class="s1">status</span><span class="s2">[</span><span class="s1">i</span><span class="s2">] = </span><span class="s1">eim</span><span class="s2">.</span><span class="s1">_EVALUEERR</span>
        <span class="s1">stop</span><span class="s2">[</span><span class="s1">i</span><span class="s2">] = </span><span class="s0">True</span>

        <span class="s0">return </span><span class="s1">stop</span>

    <span class="s0">def </span><span class="s1">post_termination_check</span><span class="s2">(</span><span class="s1">work</span><span class="s2">):</span>
        <span class="s0">pass</span>

    <span class="s0">def </span><span class="s1">customize_result</span><span class="s2">(</span><span class="s1">res</span><span class="s2">, </span><span class="s1">shape</span><span class="s2">):</span>
        <span class="s1">n </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">res</span><span class="s2">[</span><span class="s5">'x'</span><span class="s2">]) // </span><span class="s3">2</span>

        <span class="s4"># To avoid ambiguity, below we refer to `xl0`, the initial left endpoint</span>
        <span class="s4"># as `a` and `xr0`, the initial right endpoint, as `b`.</span>
        <span class="s4"># Because we treat the two one-sided searches as though they were</span>
        <span class="s4"># independent, what we keep track of in `work` and what we want to</span>
        <span class="s4"># return in `res` look quite different. Combine the results from the</span>
        <span class="s4"># two one-sided searches before reporting the results to the user.</span>
        <span class="s4"># - &quot;a&quot; refers to the leftward search (the moving end started at `a`)</span>
        <span class="s4"># - &quot;b&quot; refers to the rightward search (the moving end started at `b`)</span>
        <span class="s4"># - &quot;l&quot; refers to the left end of the bracket (closer to -oo)</span>
        <span class="s4"># - &quot;r&quot; refers to the right end of the bracket (closer to +oo)</span>
        <span class="s1">xal </span><span class="s2">= </span><span class="s1">res</span><span class="s2">[</span><span class="s5">'x'</span><span class="s2">][:</span><span class="s1">n</span><span class="s2">]</span>
        <span class="s1">xar </span><span class="s2">= </span><span class="s1">res</span><span class="s2">[</span><span class="s5">'x_last'</span><span class="s2">][:</span><span class="s1">n</span><span class="s2">]</span>
        <span class="s1">xbl </span><span class="s2">= </span><span class="s1">res</span><span class="s2">[</span><span class="s5">'x_last'</span><span class="s2">][</span><span class="s1">n</span><span class="s2">:]</span>
        <span class="s1">xbr </span><span class="s2">= </span><span class="s1">res</span><span class="s2">[</span><span class="s5">'x'</span><span class="s2">][</span><span class="s1">n</span><span class="s2">:]</span>

        <span class="s1">fal </span><span class="s2">= </span><span class="s1">res</span><span class="s2">[</span><span class="s5">'f'</span><span class="s2">][:</span><span class="s1">n</span><span class="s2">]</span>
        <span class="s1">far </span><span class="s2">= </span><span class="s1">res</span><span class="s2">[</span><span class="s5">'f_last'</span><span class="s2">][:</span><span class="s1">n</span><span class="s2">]</span>
        <span class="s1">fbl </span><span class="s2">= </span><span class="s1">res</span><span class="s2">[</span><span class="s5">'f_last'</span><span class="s2">][</span><span class="s1">n</span><span class="s2">:]</span>
        <span class="s1">fbr </span><span class="s2">= </span><span class="s1">res</span><span class="s2">[</span><span class="s5">'f'</span><span class="s2">][</span><span class="s1">n</span><span class="s2">:]</span>

        <span class="s4"># Initialize the brackets and corresponding function values to return</span>
        <span class="s4"># to the user. Brackets may not be valid (e.g. there is no root,</span>
        <span class="s4"># there weren't enough iterations, NaN encountered), but we still need</span>
        <span class="s4"># to return something. One option would be all NaNs, but what I've</span>
        <span class="s4"># chosen here is the left- and right-most points at which the function</span>
        <span class="s4"># has been evaluated. This gives the user some information about what</span>
        <span class="s4"># interval of the real line has been searched and shows that there is</span>
        <span class="s4"># no sign change between the two ends.</span>
        <span class="s1">xl </span><span class="s2">= </span><span class="s1">xal</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>
        <span class="s1">fl </span><span class="s2">= </span><span class="s1">fal</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>
        <span class="s1">xr </span><span class="s2">= </span><span class="s1">xbr</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>
        <span class="s1">fr </span><span class="s2">= </span><span class="s1">fbr</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>

        <span class="s4"># `status` indicates whether the bracket is valid or not. If so,</span>
        <span class="s4"># we want to adjust the bracket we return to be the narrowest possible</span>
        <span class="s4"># given the points at which we evaluated the function.</span>
        <span class="s4"># For example if bracket &quot;a&quot; is valid and smaller than bracket &quot;b&quot; OR</span>
        <span class="s4"># if bracket &quot;a&quot; is valid and bracket &quot;b&quot; is not valid, we want to</span>
        <span class="s4"># return bracket &quot;a&quot; (and vice versa).</span>
        <span class="s1">sa </span><span class="s2">= </span><span class="s1">res</span><span class="s2">[</span><span class="s5">'status'</span><span class="s2">][:</span><span class="s1">n</span><span class="s2">]</span>
        <span class="s1">sb </span><span class="s2">= </span><span class="s1">res</span><span class="s2">[</span><span class="s5">'status'</span><span class="s2">][</span><span class="s1">n</span><span class="s2">:]</span>

        <span class="s1">da </span><span class="s2">= </span><span class="s1">xar </span><span class="s2">- </span><span class="s1">xal</span>
        <span class="s1">db </span><span class="s2">= </span><span class="s1">xbr </span><span class="s2">- </span><span class="s1">xbl</span>

        <span class="s1">i1 </span><span class="s2">= ((</span><span class="s1">da </span><span class="s2">&lt;= </span><span class="s1">db</span><span class="s2">) &amp; (</span><span class="s1">sa </span><span class="s2">== </span><span class="s3">0</span><span class="s2">)) | ((</span><span class="s1">sa </span><span class="s2">== </span><span class="s3">0</span><span class="s2">) &amp; (</span><span class="s1">sb </span><span class="s2">!= </span><span class="s3">0</span><span class="s2">))</span>
        <span class="s1">i2 </span><span class="s2">= ((</span><span class="s1">db </span><span class="s2">&lt;= </span><span class="s1">da</span><span class="s2">) &amp; (</span><span class="s1">sb </span><span class="s2">== </span><span class="s3">0</span><span class="s2">)) | ((</span><span class="s1">sb </span><span class="s2">== </span><span class="s3">0</span><span class="s2">) &amp; (</span><span class="s1">sa </span><span class="s2">!= </span><span class="s3">0</span><span class="s2">))</span>

        <span class="s1">xr</span><span class="s2">[</span><span class="s1">i1</span><span class="s2">] = </span><span class="s1">xar</span><span class="s2">[</span><span class="s1">i1</span><span class="s2">]</span>
        <span class="s1">fr</span><span class="s2">[</span><span class="s1">i1</span><span class="s2">] = </span><span class="s1">far</span><span class="s2">[</span><span class="s1">i1</span><span class="s2">]</span>
        <span class="s1">xl</span><span class="s2">[</span><span class="s1">i2</span><span class="s2">] = </span><span class="s1">xbl</span><span class="s2">[</span><span class="s1">i2</span><span class="s2">]</span>
        <span class="s1">fl</span><span class="s2">[</span><span class="s1">i2</span><span class="s2">] = </span><span class="s1">fbl</span><span class="s2">[</span><span class="s1">i2</span><span class="s2">]</span>

        <span class="s4"># Finish assembling the result object</span>
        <span class="s1">res</span><span class="s2">[</span><span class="s5">'xl'</span><span class="s2">] = </span><span class="s1">xl</span>
        <span class="s1">res</span><span class="s2">[</span><span class="s5">'xr'</span><span class="s2">] = </span><span class="s1">xr</span>
        <span class="s1">res</span><span class="s2">[</span><span class="s5">'fl'</span><span class="s2">] = </span><span class="s1">fl</span>
        <span class="s1">res</span><span class="s2">[</span><span class="s5">'fr'</span><span class="s2">] = </span><span class="s1">fr</span>

        <span class="s1">res</span><span class="s2">[</span><span class="s5">'nit'</span><span class="s2">] = </span><span class="s1">np</span><span class="s2">.</span><span class="s1">maximum</span><span class="s2">(</span><span class="s1">res</span><span class="s2">[</span><span class="s5">'nit'</span><span class="s2">][:</span><span class="s1">n</span><span class="s2">], </span><span class="s1">res</span><span class="s2">[</span><span class="s5">'nit'</span><span class="s2">][</span><span class="s1">n</span><span class="s2">:])</span>
        <span class="s1">res</span><span class="s2">[</span><span class="s5">'nfev'</span><span class="s2">] = </span><span class="s1">res</span><span class="s2">[</span><span class="s5">'nfev'</span><span class="s2">][:</span><span class="s1">n</span><span class="s2">] + </span><span class="s1">res</span><span class="s2">[</span><span class="s5">'nfev'</span><span class="s2">][</span><span class="s1">n</span><span class="s2">:]</span>
        <span class="s4"># If the status on one side is zero, the status is zero. In any case,</span>
        <span class="s4"># report the status from one side only.</span>
        <span class="s1">res</span><span class="s2">[</span><span class="s5">'status'</span><span class="s2">] = </span><span class="s1">np</span><span class="s2">.</span><span class="s1">choose</span><span class="s2">(</span><span class="s1">sa </span><span class="s2">== </span><span class="s3">0</span><span class="s2">, (</span><span class="s1">sb</span><span class="s2">, </span><span class="s1">sa</span><span class="s2">))</span>
        <span class="s1">res</span><span class="s2">[</span><span class="s5">'success'</span><span class="s2">] = (</span><span class="s1">res</span><span class="s2">[</span><span class="s5">'status'</span><span class="s2">] == </span><span class="s3">0</span><span class="s2">)</span>

        <span class="s0">del </span><span class="s1">res</span><span class="s2">[</span><span class="s5">'x'</span><span class="s2">]</span>
        <span class="s0">del </span><span class="s1">res</span><span class="s2">[</span><span class="s5">'f'</span><span class="s2">]</span>
        <span class="s0">del </span><span class="s1">res</span><span class="s2">[</span><span class="s5">'x_last'</span><span class="s2">]</span>
        <span class="s0">del </span><span class="s1">res</span><span class="s2">[</span><span class="s5">'f_last'</span><span class="s2">]</span>

        <span class="s0">return </span><span class="s1">shape</span><span class="s2">[:-</span><span class="s3">1</span><span class="s2">]</span>

    <span class="s0">return </span><span class="s1">eim</span><span class="s2">.</span><span class="s1">_loop</span><span class="s2">(</span><span class="s1">work</span><span class="s2">, </span><span class="s1">callback</span><span class="s2">, </span><span class="s1">shape</span><span class="s2">, </span><span class="s1">maxiter</span><span class="s2">, </span><span class="s1">func</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">,</span>
                     <span class="s1">pre_func_eval</span><span class="s2">, </span><span class="s1">post_func_eval</span><span class="s2">, </span><span class="s1">check_termination</span><span class="s2">,</span>
                     <span class="s1">post_termination_check</span><span class="s2">, </span><span class="s1">customize_result</span><span class="s2">, </span><span class="s1">res_work_pairs</span><span class="s2">,</span>
                     <span class="s1">xp</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">_bracket_minimum_iv</span><span class="s2">(</span><span class="s1">func</span><span class="s2">, </span><span class="s1">xm0</span><span class="s2">, </span><span class="s1">xl0</span><span class="s2">, </span><span class="s1">xr0</span><span class="s2">, </span><span class="s1">xmin</span><span class="s2">, </span><span class="s1">xmax</span><span class="s2">, </span><span class="s1">factor</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">maxiter</span><span class="s2">):</span>

    <span class="s0">if not </span><span class="s1">callable</span><span class="s2">(</span><span class="s1">func</span><span class="s2">):</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s5">'`func` must be callable.'</span><span class="s2">)</span>

    <span class="s0">if not </span><span class="s1">np</span><span class="s2">.</span><span class="s1">iterable</span><span class="s2">(</span><span class="s1">args</span><span class="s2">):</span>
        <span class="s1">args </span><span class="s2">= (</span><span class="s1">args</span><span class="s2">,)</span>

    <span class="s1">xm0 </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">xm0</span><span class="s2">)[()]</span>
    <span class="s0">if not </span><span class="s1">np</span><span class="s2">.</span><span class="s1">issubdtype</span><span class="s2">(</span><span class="s1">xm0</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">number</span><span class="s2">) </span><span class="s0">or </span><span class="s1">np</span><span class="s2">.</span><span class="s1">iscomplex</span><span class="s2">(</span><span class="s1">xm0</span><span class="s2">).</span><span class="s1">any</span><span class="s2">():</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s5">'`xm0` must be numeric and real.'</span><span class="s2">)</span>

    <span class="s1">xmin </span><span class="s2">= -</span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf </span><span class="s0">if </span><span class="s1">xmin </span><span class="s0">is None else </span><span class="s1">xmin</span>
    <span class="s1">xmax </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf </span><span class="s0">if </span><span class="s1">xmax </span><span class="s0">is None else </span><span class="s1">xmax</span>

    <span class="s4"># If xl0 (xr0) is not supplied, fill with a dummy value for the sake</span>
    <span class="s4"># of broadcasting. We need to wait until xmin (xmax) has been validated</span>
    <span class="s4"># to compute the default values.</span>
    <span class="s1">xl0_not_supplied </span><span class="s2">= </span><span class="s0">False</span>
    <span class="s0">if </span><span class="s1">xl0 </span><span class="s0">is None</span><span class="s2">:</span>
        <span class="s1">xl0 </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">nan</span>
        <span class="s1">xl0_not_supplied </span><span class="s2">= </span><span class="s0">True</span>

    <span class="s1">xr0_not_supplied </span><span class="s2">= </span><span class="s0">False</span>
    <span class="s0">if </span><span class="s1">xr0 </span><span class="s0">is None</span><span class="s2">:</span>
        <span class="s1">xr0 </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">nan</span>
        <span class="s1">xr0_not_supplied </span><span class="s2">= </span><span class="s0">True</span>

    <span class="s1">factor </span><span class="s2">= </span><span class="s3">2.0 </span><span class="s0">if </span><span class="s1">factor </span><span class="s0">is None else </span><span class="s1">factor</span>
    <span class="s1">xl0</span><span class="s2">, </span><span class="s1">xm0</span><span class="s2">, </span><span class="s1">xr0</span><span class="s2">, </span><span class="s1">xmin</span><span class="s2">, </span><span class="s1">xmax</span><span class="s2">, </span><span class="s1">factor </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">broadcast_arrays</span><span class="s2">(</span>
        <span class="s1">xl0</span><span class="s2">, </span><span class="s1">xm0</span><span class="s2">, </span><span class="s1">xr0</span><span class="s2">, </span><span class="s1">xmin</span><span class="s2">, </span><span class="s1">xmax</span><span class="s2">, </span><span class="s1">factor</span>
    <span class="s2">)</span>

    <span class="s0">if not </span><span class="s1">np</span><span class="s2">.</span><span class="s1">issubdtype</span><span class="s2">(</span><span class="s1">xl0</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">number</span><span class="s2">) </span><span class="s0">or </span><span class="s1">np</span><span class="s2">.</span><span class="s1">iscomplex</span><span class="s2">(</span><span class="s1">xl0</span><span class="s2">).</span><span class="s1">any</span><span class="s2">():</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s5">'`xl0` must be numeric and real.'</span><span class="s2">)</span>

    <span class="s0">if not </span><span class="s1">np</span><span class="s2">.</span><span class="s1">issubdtype</span><span class="s2">(</span><span class="s1">xr0</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">number</span><span class="s2">) </span><span class="s0">or </span><span class="s1">np</span><span class="s2">.</span><span class="s1">iscomplex</span><span class="s2">(</span><span class="s1">xr0</span><span class="s2">).</span><span class="s1">any</span><span class="s2">():</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s5">'`xr0` must be numeric and real.'</span><span class="s2">)</span>

    <span class="s0">if not </span><span class="s1">np</span><span class="s2">.</span><span class="s1">issubdtype</span><span class="s2">(</span><span class="s1">xmin</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">number</span><span class="s2">) </span><span class="s0">or </span><span class="s1">np</span><span class="s2">.</span><span class="s1">iscomplex</span><span class="s2">(</span><span class="s1">xmin</span><span class="s2">).</span><span class="s1">any</span><span class="s2">():</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s5">'`xmin` must be numeric and real.'</span><span class="s2">)</span>

    <span class="s0">if not </span><span class="s1">np</span><span class="s2">.</span><span class="s1">issubdtype</span><span class="s2">(</span><span class="s1">xmax</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">number</span><span class="s2">) </span><span class="s0">or </span><span class="s1">np</span><span class="s2">.</span><span class="s1">iscomplex</span><span class="s2">(</span><span class="s1">xmax</span><span class="s2">).</span><span class="s1">any</span><span class="s2">():</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s5">'`xmax` must be numeric and real.'</span><span class="s2">)</span>

    <span class="s0">if not </span><span class="s1">np</span><span class="s2">.</span><span class="s1">issubdtype</span><span class="s2">(</span><span class="s1">factor</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">number</span><span class="s2">) </span><span class="s0">or </span><span class="s1">np</span><span class="s2">.</span><span class="s1">iscomplex</span><span class="s2">(</span><span class="s1">factor</span><span class="s2">).</span><span class="s1">any</span><span class="s2">():</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s5">'`factor` must be numeric and real.'</span><span class="s2">)</span>
    <span class="s0">if not </span><span class="s1">np</span><span class="s2">.</span><span class="s1">all</span><span class="s2">(</span><span class="s1">factor </span><span class="s2">&gt; </span><span class="s3">1</span><span class="s2">):</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s5">'All elements of `factor` must be greater than 1.'</span><span class="s2">)</span>

    <span class="s4"># Calculate default values of xl0 and/or xr0 if they have not been supplied</span>
    <span class="s4"># by the user. We need to be careful to ensure xl0 and xr0 are not outside</span>
    <span class="s4"># of (xmin, xmax).</span>
    <span class="s0">if </span><span class="s1">xl0_not_supplied</span><span class="s2">:</span>
        <span class="s1">xl0 </span><span class="s2">= </span><span class="s1">xm0 </span><span class="s2">- </span><span class="s1">np</span><span class="s2">.</span><span class="s1">minimum</span><span class="s2">((</span><span class="s1">xm0 </span><span class="s2">- </span><span class="s1">xmin</span><span class="s2">)/</span><span class="s3">16</span><span class="s2">, </span><span class="s3">0.5</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">xr0_not_supplied</span><span class="s2">:</span>
        <span class="s1">xr0 </span><span class="s2">= </span><span class="s1">xm0 </span><span class="s2">+ </span><span class="s1">np</span><span class="s2">.</span><span class="s1">minimum</span><span class="s2">((</span><span class="s1">xmax </span><span class="s2">- </span><span class="s1">xm0</span><span class="s2">)/</span><span class="s3">16</span><span class="s2">, </span><span class="s3">0.5</span><span class="s2">)</span>

    <span class="s1">maxiter </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">maxiter</span><span class="s2">)</span>
    <span class="s1">message </span><span class="s2">= </span><span class="s5">'`maxiter` must be a non-negative integer.'</span>
    <span class="s0">if </span><span class="s2">(</span><span class="s0">not </span><span class="s1">np</span><span class="s2">.</span><span class="s1">issubdtype</span><span class="s2">(</span><span class="s1">maxiter</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">number</span><span class="s2">) </span><span class="s0">or </span><span class="s1">maxiter</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">!= </span><span class="s1">tuple</span><span class="s2">()</span>
            <span class="s0">or </span><span class="s1">np</span><span class="s2">.</span><span class="s1">iscomplex</span><span class="s2">(</span><span class="s1">maxiter</span><span class="s2">)):</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s1">message</span><span class="s2">)</span>
    <span class="s1">maxiter_int </span><span class="s2">= </span><span class="s1">int</span><span class="s2">(</span><span class="s1">maxiter</span><span class="s2">[()])</span>
    <span class="s0">if not </span><span class="s1">maxiter </span><span class="s2">== </span><span class="s1">maxiter_int </span><span class="s0">or </span><span class="s1">maxiter </span><span class="s2">&lt; </span><span class="s3">0</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s1">message</span><span class="s2">)</span>

    <span class="s0">return </span><span class="s1">func</span><span class="s2">, </span><span class="s1">xm0</span><span class="s2">, </span><span class="s1">xl0</span><span class="s2">, </span><span class="s1">xr0</span><span class="s2">, </span><span class="s1">xmin</span><span class="s2">, </span><span class="s1">xmax</span><span class="s2">, </span><span class="s1">factor</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">maxiter</span>


<span class="s0">def </span><span class="s1">_bracket_minimum</span><span class="s2">(</span><span class="s1">func</span><span class="s2">, </span><span class="s1">xm0</span><span class="s2">, *, </span><span class="s1">xl0</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">xr0</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">xmin</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">xmax</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
                     <span class="s1">factor</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">args</span><span class="s2">=(), </span><span class="s1">maxiter</span><span class="s2">=</span><span class="s3">1000</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot;Bracket the minimum of a unimodal scalar function of one variable 
 
    This function works elementwise when `xm0`, `xl0`, `xr0`, `xmin`, `xmax`, 
    and the elements of `args` are broadcastable arrays. 
 
    Parameters 
    ---------- 
    func : callable 
        The function for which the minimum is to be bracketed. 
        The signature must be:: 
 
            func(x: ndarray, *args) -&gt; ndarray 
 
        where each element of ``x`` is a finite real and ``args`` is a tuple, 
        which may contain an arbitrary number of arrays that are broadcastable 
        with ``x``. `func` must be an elementwise function: each element 
        ``func(x)[i]`` must equal ``func(x[i])`` for all indices `i`. 
    xm0: float array_like 
        Starting guess for middle point of bracket. 
    xl0, xr0: float array_like, optional 
        Starting guesses for left and right endpoints of the bracket. Must be 
        broadcastable with one another and with `xm0`. 
    xmin, xmax : float array_like, optional 
        Minimum and maximum allowable endpoints of the bracket, inclusive. Must 
        be broadcastable with `xl0`, `xm0`, and `xr0`. 
    factor : float array_like, optional 
        Controls expansion of bracket endpoint in downhill direction. Works 
        differently in the cases where a limit is set in the downhill direction 
        with `xmax` or `xmin`. See Notes. 
    args : tuple, optional 
        Additional positional arguments to be passed to `func`.  Must be arrays 
        broadcastable with `xl0`, `xm0`, `xr0`, `xmin`, and `xmax`. If the 
        callable to be bracketed requires arguments that are not broadcastable 
        with these arrays, wrap that callable with `func` such that `func` 
        accepts only ``x`` and broadcastable arrays. 
    maxiter : int, optional 
        The maximum number of iterations of the algorithm to perform. The number 
        of function evaluations is three greater than the number of iterations. 
 
    Returns 
    ------- 
    res : _RichResult 
        An instance of `scipy._lib._util._RichResult` with the following 
        attributes. The descriptions are written as though the values will be 
        scalars; however, if `func` returns an array, the outputs will be 
        arrays of the same shape. 
 
        xl, xm, xr : float 
            The left, middle, and right points of the bracket, if the algorithm 
            terminated successfully. 
        fl, fm, fr : float 
            The function value at the left, middle, and right points of the bracket. 
        nfev : int 
            The number of function evaluations required to find the bracket. 
        nit : int 
            The number of iterations of the algorithm that were performed. 
        status : int 
            An integer representing the exit status of the algorithm. 
 
            - ``0`` : The algorithm produced a valid bracket. 
            - ``-1`` : The bracket expanded to the allowable limits. Assuming 
                       unimodality, this implies the endpoint at the limit is a 
                       minimizer. 
            - ``-2`` : The maximum number of iterations was reached. 
            - ``-3`` : A non-finite value was encountered. 
            - ``-4`` : ``None`` shall pass. 
            - ``-5`` : The initial bracket does not satisfy 
                       `xmin &lt;= xl0 &lt; xm0 &lt; xr0 &lt;= xmax`. 
 
        success : bool 
            ``True`` when the algorithm terminated successfully (status ``0``). 
 
    Notes 
    ----- 
    Similar to `scipy.optimize.bracket`, this function seeks to find real 
    points ``xl &lt; xm &lt; xr`` such that ``f(xl) &gt;= f(xm)`` and ``f(xr) &gt;= f(xm)``, 
    where at least one of the inequalities is strict. Unlike `scipy.optimize.bracket`, 
    this function can operate in a vectorized manner on array input, so long as 
    the input arrays are broadcastable with each other. Also unlike 
    `scipy.optimize.bracket`, users may specify minimum and maximum endpoints 
    for the desired bracket. 
 
    Given an initial trio of points ``xl = xl0``, ``xm = xm0``, ``xr = xr0``, 
    the algorithm checks if these points already give a valid bracket. If not, 
    a new endpoint, ``w`` is chosen in the &quot;downhill&quot; direction, ``xm`` becomes the new 
    opposite endpoint, and either `xl` or `xr` becomes the new middle point, 
    depending on which direction is downhill. The algorithm repeats from here. 
 
    The new endpoint `w` is chosen differently depending on whether or not a 
    boundary `xmin` or `xmax` has been set in the downhill direction. Without 
    loss of generality, suppose the downhill direction is to the right, so that 
    ``f(xl) &gt; f(xm) &gt; f(xr)``. If there is no boundary to the right, then `w` 
    is chosen to be ``xr + factor * (xr - xm)`` where `factor` is controlled by 
    the user (defaults to 2.0) so that step sizes increase in geometric proportion. 
    If there is a boundary, `xmax` in this case, then `w` is chosen to be 
    ``xmax - (xmax - xr)/factor``, with steps slowing to a stop at 
    `xmax`. This cautious approach ensures that a minimum near but distinct from 
    the boundary isn't missed while also detecting whether or not the `xmax` is 
    a minimizer when `xmax` is reached after a finite number of steps. 
    &quot;&quot;&quot;  </span><span class="s4"># noqa: E501</span>
    <span class="s1">callback </span><span class="s2">= </span><span class="s0">None  </span><span class="s4"># works; I just don't want to test it</span>

    <span class="s1">temp </span><span class="s2">= </span><span class="s1">_bracket_minimum_iv</span><span class="s2">(</span><span class="s1">func</span><span class="s2">, </span><span class="s1">xm0</span><span class="s2">, </span><span class="s1">xl0</span><span class="s2">, </span><span class="s1">xr0</span><span class="s2">, </span><span class="s1">xmin</span><span class="s2">, </span><span class="s1">xmax</span><span class="s2">, </span><span class="s1">factor</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">maxiter</span><span class="s2">)</span>
    <span class="s1">func</span><span class="s2">, </span><span class="s1">xm0</span><span class="s2">, </span><span class="s1">xl0</span><span class="s2">, </span><span class="s1">xr0</span><span class="s2">, </span><span class="s1">xmin</span><span class="s2">, </span><span class="s1">xmax</span><span class="s2">, </span><span class="s1">factor</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">maxiter </span><span class="s2">= </span><span class="s1">temp</span>

    <span class="s1">xs </span><span class="s2">= (</span><span class="s1">xl0</span><span class="s2">, </span><span class="s1">xm0</span><span class="s2">, </span><span class="s1">xr0</span><span class="s2">)</span>
    <span class="s1">temp </span><span class="s2">= </span><span class="s1">eim</span><span class="s2">.</span><span class="s1">_initialize</span><span class="s2">(</span><span class="s1">func</span><span class="s2">, </span><span class="s1">xs</span><span class="s2">, </span><span class="s1">args</span><span class="s2">)</span>
    <span class="s1">func</span><span class="s2">, </span><span class="s1">xs</span><span class="s2">, </span><span class="s1">fs</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">shape</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">xp </span><span class="s2">= </span><span class="s1">temp</span>

    <span class="s1">xl0</span><span class="s2">, </span><span class="s1">xm0</span><span class="s2">, </span><span class="s1">xr0 </span><span class="s2">= </span><span class="s1">xs</span>
    <span class="s1">fl0</span><span class="s2">, </span><span class="s1">fm0</span><span class="s2">, </span><span class="s1">fr0 </span><span class="s2">= </span><span class="s1">fs</span>
    <span class="s1">xmin </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">broadcast_to</span><span class="s2">(</span><span class="s1">xmin</span><span class="s2">, </span><span class="s1">shape</span><span class="s2">).</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s0">False</span><span class="s2">).</span><span class="s1">ravel</span><span class="s2">()</span>
    <span class="s1">xmax </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">broadcast_to</span><span class="s2">(</span><span class="s1">xmax</span><span class="s2">, </span><span class="s1">shape</span><span class="s2">).</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s0">False</span><span class="s2">).</span><span class="s1">ravel</span><span class="s2">()</span>
    <span class="s1">invalid_bracket </span><span class="s2">= ~((</span><span class="s1">xmin </span><span class="s2">&lt;= </span><span class="s1">xl0</span><span class="s2">) &amp; (</span><span class="s1">xl0 </span><span class="s2">&lt; </span><span class="s1">xm0</span><span class="s2">) &amp; (</span><span class="s1">xm0 </span><span class="s2">&lt; </span><span class="s1">xr0</span><span class="s2">) &amp; (</span><span class="s1">xr0 </span><span class="s2">&lt;= </span><span class="s1">xmax</span><span class="s2">))</span>
    <span class="s4"># We will modify factor later on so make a copy. np.broadcast_to returns</span>
    <span class="s4"># a read-only view.</span>
    <span class="s1">factor </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">broadcast_to</span><span class="s2">(</span><span class="s1">factor</span><span class="s2">, </span><span class="s1">shape</span><span class="s2">).</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s0">True</span><span class="s2">).</span><span class="s1">ravel</span><span class="s2">()</span>

    <span class="s4"># To simplify the logic, swap xl and xr if f(xl) &lt; f(xr). We should always be</span>
    <span class="s4"># marching downhill in the direction from xl to xr.</span>
    <span class="s1">comp </span><span class="s2">= </span><span class="s1">fl0 </span><span class="s2">&lt; </span><span class="s1">fr0</span>
    <span class="s1">xl0</span><span class="s2">[</span><span class="s1">comp</span><span class="s2">], </span><span class="s1">xr0</span><span class="s2">[</span><span class="s1">comp</span><span class="s2">] = </span><span class="s1">xr0</span><span class="s2">[</span><span class="s1">comp</span><span class="s2">], </span><span class="s1">xl0</span><span class="s2">[</span><span class="s1">comp</span><span class="s2">]</span>
    <span class="s1">fl0</span><span class="s2">[</span><span class="s1">comp</span><span class="s2">], </span><span class="s1">fr0</span><span class="s2">[</span><span class="s1">comp</span><span class="s2">] = </span><span class="s1">fr0</span><span class="s2">[</span><span class="s1">comp</span><span class="s2">], </span><span class="s1">fl0</span><span class="s2">[</span><span class="s1">comp</span><span class="s2">]</span>
    <span class="s4"># We only need the boundary in the direction we're traveling.</span>
    <span class="s1">limit </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">where</span><span class="s2">(</span><span class="s1">comp</span><span class="s2">, </span><span class="s1">xmin</span><span class="s2">, </span><span class="s1">xmax</span><span class="s2">)</span>

    <span class="s1">unlimited </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isinf</span><span class="s2">(</span><span class="s1">limit</span><span class="s2">)</span>
    <span class="s1">limited </span><span class="s2">= ~</span><span class="s1">unlimited</span>
    <span class="s1">step </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty_like</span><span class="s2">(</span><span class="s1">xl0</span><span class="s2">)</span>

    <span class="s1">step</span><span class="s2">[</span><span class="s1">unlimited</span><span class="s2">] = (</span><span class="s1">xr0</span><span class="s2">[</span><span class="s1">unlimited</span><span class="s2">] - </span><span class="s1">xm0</span><span class="s2">[</span><span class="s1">unlimited</span><span class="s2">])</span>
    <span class="s1">step</span><span class="s2">[</span><span class="s1">limited</span><span class="s2">] = (</span><span class="s1">limit</span><span class="s2">[</span><span class="s1">limited</span><span class="s2">] - </span><span class="s1">xr0</span><span class="s2">[</span><span class="s1">limited</span><span class="s2">])</span>

    <span class="s4"># Step size is divided by factor for case where there is a limit.</span>
    <span class="s1">factor</span><span class="s2">[</span><span class="s1">limited</span><span class="s2">] = </span><span class="s3">1 </span><span class="s2">/ </span><span class="s1">factor</span><span class="s2">[</span><span class="s1">limited</span><span class="s2">]</span>

    <span class="s1">status </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">full_like</span><span class="s2">(</span><span class="s1">xl0</span><span class="s2">, </span><span class="s1">eim</span><span class="s2">.</span><span class="s1">_EINPROGRESS</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">int</span><span class="s2">)</span>
    <span class="s1">status</span><span class="s2">[</span><span class="s1">invalid_bracket</span><span class="s2">] = </span><span class="s1">eim</span><span class="s2">.</span><span class="s1">_EINPUTERR</span>
    <span class="s1">nit</span><span class="s2">, </span><span class="s1">nfev </span><span class="s2">= </span><span class="s3">0</span><span class="s2">, </span><span class="s3">3</span>

    <span class="s1">work </span><span class="s2">= </span><span class="s1">_RichResult</span><span class="s2">(</span><span class="s1">xl</span><span class="s2">=</span><span class="s1">xl0</span><span class="s2">, </span><span class="s1">xm</span><span class="s2">=</span><span class="s1">xm0</span><span class="s2">, </span><span class="s1">xr</span><span class="s2">=</span><span class="s1">xr0</span><span class="s2">, </span><span class="s1">xr0</span><span class="s2">=</span><span class="s1">xr0</span><span class="s2">, </span><span class="s1">fl</span><span class="s2">=</span><span class="s1">fl0</span><span class="s2">, </span><span class="s1">fm</span><span class="s2">=</span><span class="s1">fm0</span><span class="s2">, </span><span class="s1">fr</span><span class="s2">=</span><span class="s1">fr0</span><span class="s2">,</span>
                       <span class="s1">step</span><span class="s2">=</span><span class="s1">step</span><span class="s2">, </span><span class="s1">limit</span><span class="s2">=</span><span class="s1">limit</span><span class="s2">, </span><span class="s1">limited</span><span class="s2">=</span><span class="s1">limited</span><span class="s2">, </span><span class="s1">factor</span><span class="s2">=</span><span class="s1">factor</span><span class="s2">, </span><span class="s1">nit</span><span class="s2">=</span><span class="s1">nit</span><span class="s2">,</span>
                       <span class="s1">nfev</span><span class="s2">=</span><span class="s1">nfev</span><span class="s2">, </span><span class="s1">status</span><span class="s2">=</span><span class="s1">status</span><span class="s2">, </span><span class="s1">args</span><span class="s2">=</span><span class="s1">args</span><span class="s2">)</span>

    <span class="s1">res_work_pairs </span><span class="s2">= [(</span><span class="s5">'status'</span><span class="s2">, </span><span class="s5">'status'</span><span class="s2">), (</span><span class="s5">'xl'</span><span class="s2">, </span><span class="s5">'xl'</span><span class="s2">), (</span><span class="s5">'xm'</span><span class="s2">, </span><span class="s5">'xm'</span><span class="s2">), (</span><span class="s5">'xr'</span><span class="s2">, </span><span class="s5">'xr'</span><span class="s2">),</span>
                      <span class="s2">(</span><span class="s5">'nit'</span><span class="s2">, </span><span class="s5">'nit'</span><span class="s2">), (</span><span class="s5">'nfev'</span><span class="s2">, </span><span class="s5">'nfev'</span><span class="s2">), (</span><span class="s5">'fl'</span><span class="s2">, </span><span class="s5">'fl'</span><span class="s2">), (</span><span class="s5">'fm'</span><span class="s2">, </span><span class="s5">'fm'</span><span class="s2">),</span>
                      <span class="s2">(</span><span class="s5">'fr'</span><span class="s2">, </span><span class="s5">'fr'</span><span class="s2">)]</span>

    <span class="s0">def </span><span class="s1">pre_func_eval</span><span class="s2">(</span><span class="s1">work</span><span class="s2">):</span>
        <span class="s1">work</span><span class="s2">.</span><span class="s1">step </span><span class="s2">*= </span><span class="s1">work</span><span class="s2">.</span><span class="s1">factor</span>
        <span class="s1">x </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty_like</span><span class="s2">(</span><span class="s1">work</span><span class="s2">.</span><span class="s1">xr</span><span class="s2">)</span>
        <span class="s1">x</span><span class="s2">[~</span><span class="s1">work</span><span class="s2">.</span><span class="s1">limited</span><span class="s2">] = </span><span class="s1">work</span><span class="s2">.</span><span class="s1">xr0</span><span class="s2">[~</span><span class="s1">work</span><span class="s2">.</span><span class="s1">limited</span><span class="s2">] + </span><span class="s1">work</span><span class="s2">.</span><span class="s1">step</span><span class="s2">[~</span><span class="s1">work</span><span class="s2">.</span><span class="s1">limited</span><span class="s2">]</span>
        <span class="s1">x</span><span class="s2">[</span><span class="s1">work</span><span class="s2">.</span><span class="s1">limited</span><span class="s2">] = </span><span class="s1">work</span><span class="s2">.</span><span class="s1">limit</span><span class="s2">[</span><span class="s1">work</span><span class="s2">.</span><span class="s1">limited</span><span class="s2">] - </span><span class="s1">work</span><span class="s2">.</span><span class="s1">step</span><span class="s2">[</span><span class="s1">work</span><span class="s2">.</span><span class="s1">limited</span><span class="s2">]</span>
        <span class="s4"># Since the new bracket endpoint is calculated from an offset with the</span>
        <span class="s4"># limit, it may be the case that the new endpoint equals the old endpoint,</span>
        <span class="s4"># when the old endpoint is sufficiently close to the limit. We use the</span>
        <span class="s4"># limit itself as the new endpoint in these cases.</span>
        <span class="s1">x</span><span class="s2">[</span><span class="s1">work</span><span class="s2">.</span><span class="s1">limited</span><span class="s2">] = </span><span class="s1">np</span><span class="s2">.</span><span class="s1">where</span><span class="s2">(</span>
            <span class="s1">x</span><span class="s2">[</span><span class="s1">work</span><span class="s2">.</span><span class="s1">limited</span><span class="s2">] == </span><span class="s1">work</span><span class="s2">.</span><span class="s1">xr</span><span class="s2">[</span><span class="s1">work</span><span class="s2">.</span><span class="s1">limited</span><span class="s2">],</span>
            <span class="s1">work</span><span class="s2">.</span><span class="s1">limit</span><span class="s2">[</span><span class="s1">work</span><span class="s2">.</span><span class="s1">limited</span><span class="s2">],</span>
            <span class="s1">x</span><span class="s2">[</span><span class="s1">work</span><span class="s2">.</span><span class="s1">limited</span><span class="s2">],</span>
        <span class="s2">)</span>
        <span class="s0">return </span><span class="s1">x</span>

    <span class="s0">def </span><span class="s1">post_func_eval</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">f</span><span class="s2">, </span><span class="s1">work</span><span class="s2">):</span>
        <span class="s1">work</span><span class="s2">.</span><span class="s1">xl</span><span class="s2">, </span><span class="s1">work</span><span class="s2">.</span><span class="s1">xm</span><span class="s2">, </span><span class="s1">work</span><span class="s2">.</span><span class="s1">xr </span><span class="s2">= </span><span class="s1">work</span><span class="s2">.</span><span class="s1">xm</span><span class="s2">, </span><span class="s1">work</span><span class="s2">.</span><span class="s1">xr</span><span class="s2">, </span><span class="s1">x</span>
        <span class="s1">work</span><span class="s2">.</span><span class="s1">fl</span><span class="s2">, </span><span class="s1">work</span><span class="s2">.</span><span class="s1">fm</span><span class="s2">, </span><span class="s1">work</span><span class="s2">.</span><span class="s1">fr </span><span class="s2">= </span><span class="s1">work</span><span class="s2">.</span><span class="s1">fm</span><span class="s2">, </span><span class="s1">work</span><span class="s2">.</span><span class="s1">fr</span><span class="s2">, </span><span class="s1">f</span>

    <span class="s0">def </span><span class="s1">check_termination</span><span class="s2">(</span><span class="s1">work</span><span class="s2">):</span>
        <span class="s4"># Condition 0: Initial bracket is invalid.</span>
        <span class="s1">stop </span><span class="s2">= (</span><span class="s1">work</span><span class="s2">.</span><span class="s1">status </span><span class="s2">== </span><span class="s1">eim</span><span class="s2">.</span><span class="s1">_EINPUTERR</span><span class="s2">)</span>

        <span class="s4"># Condition 1: A valid bracket has been found.</span>
        <span class="s1">i </span><span class="s2">= (</span>
            <span class="s2">(</span><span class="s1">work</span><span class="s2">.</span><span class="s1">fl </span><span class="s2">&gt;= </span><span class="s1">work</span><span class="s2">.</span><span class="s1">fm</span><span class="s2">) &amp; (</span><span class="s1">work</span><span class="s2">.</span><span class="s1">fr </span><span class="s2">&gt; </span><span class="s1">work</span><span class="s2">.</span><span class="s1">fm</span><span class="s2">)</span>
            <span class="s2">| (</span><span class="s1">work</span><span class="s2">.</span><span class="s1">fl </span><span class="s2">&gt; </span><span class="s1">work</span><span class="s2">.</span><span class="s1">fm</span><span class="s2">) &amp; (</span><span class="s1">work</span><span class="s2">.</span><span class="s1">fr </span><span class="s2">&gt;= </span><span class="s1">work</span><span class="s2">.</span><span class="s1">fm</span><span class="s2">)</span>
        <span class="s2">) &amp; ~</span><span class="s1">stop</span>
        <span class="s1">work</span><span class="s2">.</span><span class="s1">status</span><span class="s2">[</span><span class="s1">i</span><span class="s2">] = </span><span class="s1">eim</span><span class="s2">.</span><span class="s1">_ECONVERGED</span>
        <span class="s1">stop</span><span class="s2">[</span><span class="s1">i</span><span class="s2">] = </span><span class="s0">True</span>

        <span class="s4"># Condition 2: Moving end of bracket reaches limit.</span>
        <span class="s1">i </span><span class="s2">= (</span><span class="s1">work</span><span class="s2">.</span><span class="s1">xr </span><span class="s2">== </span><span class="s1">work</span><span class="s2">.</span><span class="s1">limit</span><span class="s2">) &amp; ~</span><span class="s1">stop</span>
        <span class="s1">work</span><span class="s2">.</span><span class="s1">status</span><span class="s2">[</span><span class="s1">i</span><span class="s2">] = </span><span class="s1">_ELIMITS</span>
        <span class="s1">stop</span><span class="s2">[</span><span class="s1">i</span><span class="s2">] = </span><span class="s0">True</span>

        <span class="s4"># Condition 3: non-finite value encountered</span>
        <span class="s1">i </span><span class="s2">= ~(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">isfinite</span><span class="s2">(</span><span class="s1">work</span><span class="s2">.</span><span class="s1">xr</span><span class="s2">) &amp; </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isfinite</span><span class="s2">(</span><span class="s1">work</span><span class="s2">.</span><span class="s1">fr</span><span class="s2">)) &amp; ~</span><span class="s1">stop</span>
        <span class="s1">work</span><span class="s2">.</span><span class="s1">status</span><span class="s2">[</span><span class="s1">i</span><span class="s2">] = </span><span class="s1">eim</span><span class="s2">.</span><span class="s1">_EVALUEERR</span>
        <span class="s1">stop</span><span class="s2">[</span><span class="s1">i</span><span class="s2">] = </span><span class="s0">True</span>

        <span class="s0">return </span><span class="s1">stop</span>

    <span class="s0">def </span><span class="s1">post_termination_check</span><span class="s2">(</span><span class="s1">work</span><span class="s2">):</span>
        <span class="s0">pass</span>

    <span class="s0">def </span><span class="s1">customize_result</span><span class="s2">(</span><span class="s1">res</span><span class="s2">, </span><span class="s1">shape</span><span class="s2">):</span>
        <span class="s4"># Reorder entries of xl and xr if they were swapped due to f(xl0) &lt; f(xr0).</span>
        <span class="s1">comp </span><span class="s2">= </span><span class="s1">res</span><span class="s2">[</span><span class="s5">'xl'</span><span class="s2">] &gt; </span><span class="s1">res</span><span class="s2">[</span><span class="s5">'xr'</span><span class="s2">]</span>
        <span class="s1">res</span><span class="s2">[</span><span class="s5">'xl'</span><span class="s2">][</span><span class="s1">comp</span><span class="s2">], </span><span class="s1">res</span><span class="s2">[</span><span class="s5">'xr'</span><span class="s2">][</span><span class="s1">comp</span><span class="s2">] = </span><span class="s1">res</span><span class="s2">[</span><span class="s5">'xr'</span><span class="s2">][</span><span class="s1">comp</span><span class="s2">], </span><span class="s1">res</span><span class="s2">[</span><span class="s5">'xl'</span><span class="s2">][</span><span class="s1">comp</span><span class="s2">]</span>
        <span class="s1">res</span><span class="s2">[</span><span class="s5">'fl'</span><span class="s2">][</span><span class="s1">comp</span><span class="s2">], </span><span class="s1">res</span><span class="s2">[</span><span class="s5">'fr'</span><span class="s2">][</span><span class="s1">comp</span><span class="s2">] = </span><span class="s1">res</span><span class="s2">[</span><span class="s5">'fr'</span><span class="s2">][</span><span class="s1">comp</span><span class="s2">], </span><span class="s1">res</span><span class="s2">[</span><span class="s5">'fl'</span><span class="s2">][</span><span class="s1">comp</span><span class="s2">]</span>
        <span class="s0">return </span><span class="s1">shape</span>

    <span class="s0">return </span><span class="s1">eim</span><span class="s2">.</span><span class="s1">_loop</span><span class="s2">(</span><span class="s1">work</span><span class="s2">, </span><span class="s1">callback</span><span class="s2">, </span><span class="s1">shape</span><span class="s2">,</span>
                     <span class="s1">maxiter</span><span class="s2">, </span><span class="s1">func</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">,</span>
                     <span class="s1">pre_func_eval</span><span class="s2">, </span><span class="s1">post_func_eval</span><span class="s2">,</span>
                     <span class="s1">check_termination</span><span class="s2">, </span><span class="s1">post_termination_check</span><span class="s2">,</span>
                     <span class="s1">customize_result</span><span class="s2">, </span><span class="s1">res_work_pairs</span><span class="s2">, </span><span class="s1">xp</span><span class="s2">)</span>
</pre>
</body>
</html>