<html>
<head>
<title>_sputils.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #6aab73;}
.s5 { color: #2aacb8;}
.s6 { color: #7a7e85;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_sputils.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; Utility functions for sparse matrix module 
&quot;&quot;&quot;</span>

<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Any</span><span class="s3">, </span><span class="s1">Literal</span><span class="s3">, </span><span class="s1">Optional</span><span class="s3">, </span><span class="s1">Union</span>
<span class="s2">import </span><span class="s1">operator</span>
<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">from </span><span class="s1">math </span><span class="s2">import </span><span class="s1">prod</span>
<span class="s2">import </span><span class="s1">scipy</span><span class="s3">.</span><span class="s1">sparse </span><span class="s2">as </span><span class="s1">sp</span>
<span class="s2">from </span><span class="s1">scipy</span><span class="s3">.</span><span class="s1">_lib</span><span class="s3">.</span><span class="s1">_util </span><span class="s2">import </span><span class="s1">np_long</span><span class="s3">, </span><span class="s1">np_ulong</span>


<span class="s1">__all__ </span><span class="s3">= [</span><span class="s4">'upcast'</span><span class="s3">, </span><span class="s4">'getdtype'</span><span class="s3">, </span><span class="s4">'getdata'</span><span class="s3">, </span><span class="s4">'isscalarlike'</span><span class="s3">, </span><span class="s4">'isintlike'</span><span class="s3">,</span>
           <span class="s4">'isshape'</span><span class="s3">, </span><span class="s4">'issequence'</span><span class="s3">, </span><span class="s4">'isdense'</span><span class="s3">, </span><span class="s4">'ismatrix'</span><span class="s3">, </span><span class="s4">'get_sum_dtype'</span><span class="s3">]</span>

<span class="s1">supported_dtypes </span><span class="s3">= [</span><span class="s1">np</span><span class="s3">.</span><span class="s1">bool_</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">byte</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ubyte</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">short</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ushort</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">intc</span><span class="s3">,</span>
                    <span class="s1">np</span><span class="s3">.</span><span class="s1">uintc</span><span class="s3">, </span><span class="s1">np_long</span><span class="s3">, </span><span class="s1">np_ulong</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">longlong</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ulonglong</span><span class="s3">,</span>
                    <span class="s1">np</span><span class="s3">.</span><span class="s1">float32</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">longdouble</span><span class="s3">, </span>
                    <span class="s1">np</span><span class="s3">.</span><span class="s1">complex64</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">complex128</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">clongdouble</span><span class="s3">]</span>

<span class="s1">_upcast_memo </span><span class="s3">= {}</span>


<span class="s2">def </span><span class="s1">upcast</span><span class="s3">(*</span><span class="s1">args</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Returns the nearest supported sparse dtype for the 
    combination of one or more types. 
 
    upcast(t0, t1, ..., tn) -&gt; T  where T is a supported dtype 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.sparse._sputils import upcast 
    &gt;&gt;&gt; upcast('int32') 
    &lt;type 'numpy.int32'&gt; 
    &gt;&gt;&gt; upcast('bool') 
    &lt;type 'numpy.bool_'&gt; 
    &gt;&gt;&gt; upcast('int32','float32') 
    &lt;type 'numpy.float64'&gt; 
    &gt;&gt;&gt; upcast('bool',complex,float) 
    &lt;type 'numpy.complex128'&gt; 
 
    &quot;&quot;&quot;</span>

    <span class="s1">t </span><span class="s3">= </span><span class="s1">_upcast_memo</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">hash</span><span class="s3">(</span><span class="s1">args</span><span class="s3">))</span>
    <span class="s2">if </span><span class="s1">t </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">t</span>

    <span class="s1">upcast </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">result_type</span><span class="s3">(*</span><span class="s1">args</span><span class="s3">)</span>

    <span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">supported_dtypes</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">can_cast</span><span class="s3">(</span><span class="s1">upcast</span><span class="s3">, </span><span class="s1">t</span><span class="s3">):</span>
            <span class="s1">_upcast_memo</span><span class="s3">[</span><span class="s1">hash</span><span class="s3">(</span><span class="s1">args</span><span class="s3">)] = </span><span class="s1">t</span>
            <span class="s2">return </span><span class="s1">t</span>

    <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s4">f'no supported conversion for types: </span><span class="s2">{</span><span class="s1">args</span><span class="s2">!r}</span><span class="s4">'</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">upcast_char</span><span class="s3">(*</span><span class="s1">args</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Same as `upcast` but taking dtype.char as input (faster).&quot;&quot;&quot;</span>
    <span class="s1">t </span><span class="s3">= </span><span class="s1">_upcast_memo</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">args</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">t </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">t</span>
    <span class="s1">t </span><span class="s3">= </span><span class="s1">upcast</span><span class="s3">(*</span><span class="s1">map</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">args</span><span class="s3">))</span>
    <span class="s1">_upcast_memo</span><span class="s3">[</span><span class="s1">args</span><span class="s3">] = </span><span class="s1">t</span>
    <span class="s2">return </span><span class="s1">t</span>


<span class="s2">def </span><span class="s1">upcast_scalar</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">scalar</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Determine data type for binary operation between an array of 
    type `dtype` and a scalar. 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s5">0</span><span class="s3">], </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dtype</span><span class="s3">) * </span><span class="s1">scalar</span><span class="s3">).</span><span class="s1">dtype</span>


<span class="s2">def </span><span class="s1">downcast_intp_index</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Down-cast index array to np.intp dtype if it is of a larger dtype. 
 
    Raise an error if the array contains a value that is too large for 
    intp. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">itemsize </span><span class="s3">&gt; </span><span class="s1">np</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">).</span><span class="s1">itemsize</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">size </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">)</span>
        <span class="s1">maxval </span><span class="s3">= </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">max</span><span class="s3">()</span>
        <span class="s1">minval </span><span class="s3">= </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">min</span><span class="s3">()</span>
        <span class="s2">if </span><span class="s1">maxval </span><span class="s3">&gt; </span><span class="s1">np</span><span class="s3">.</span><span class="s1">iinfo</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">).</span><span class="s1">max </span><span class="s2">or </span><span class="s1">minval </span><span class="s3">&lt; </span><span class="s1">np</span><span class="s3">.</span><span class="s1">iinfo</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">).</span><span class="s1">min</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Cannot deal with arrays with indices larger &quot;</span>
                             <span class="s4">&quot;than the machine maximum address size &quot;</span>
                             <span class="s4">&quot;(e.g. 64-bit indices on 32-bit machine).&quot;</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">arr</span>


<span class="s2">def </span><span class="s1">to_native</span><span class="s3">(</span><span class="s1">A</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Ensure that the data type of the NumPy array `A` has native byte order. 
 
    `A` must be a NumPy array.  If the data type of `A` does not have native 
    byte order, a copy of `A` with a native byte order is returned. Otherwise 
    `A` is returned. 
    &quot;&quot;&quot;</span>
    <span class="s1">dt </span><span class="s3">= </span><span class="s1">A</span><span class="s3">.</span><span class="s1">dtype</span>
    <span class="s2">if </span><span class="s1">dt</span><span class="s3">.</span><span class="s1">isnative</span><span class="s3">:</span>
        <span class="s6"># Don't call `asarray()` if A is already native, to avoid unnecessarily</span>
        <span class="s6"># creating a view of the input array.</span>
        <span class="s2">return </span><span class="s1">A</span>
    <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">A</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dt</span><span class="s3">.</span><span class="s1">newbyteorder</span><span class="s3">(</span><span class="s4">'native'</span><span class="s3">))</span>


<span class="s2">def </span><span class="s1">getdtype</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">a</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">default</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Function used to simplify argument processing. If 'dtype' is not 
    specified (is None), returns a.dtype; otherwise returns a np.dtype 
    object created from the specified dtype argument. If 'dtype' and 'a' 
    are both None, construct a data type out of the 'default' parameter. 
    Furthermore, 'dtype' must be in 'allowed' set. 
    &quot;&quot;&quot;</span>
    <span class="s6"># TODO is this really what we want?</span>
    <span class="s2">if </span><span class="s1">dtype </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s1">newdtype </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span>
        <span class="s2">except </span><span class="s1">AttributeError </span><span class="s2">as </span><span class="s1">e</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">default </span><span class="s2">is not None</span><span class="s3">:</span>
                <span class="s1">newdtype </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">(</span><span class="s1">default</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s4">&quot;could not interpret data type&quot;</span><span class="s3">) </span><span class="s2">from </span><span class="s1">e</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">newdtype </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">newdtype </span><span class="s3">== </span><span class="s1">np</span><span class="s3">.</span><span class="s1">object_</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span>
                <span class="s4">&quot;object dtype is not supported by sparse matrices&quot;</span>
            <span class="s3">)</span>

    <span class="s2">return </span><span class="s1">newdtype</span>


<span class="s2">def </span><span class="s1">getdata</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">False</span><span class="s3">) </span><span class="s1">-&gt; np</span><span class="s3">.</span><span class="s1">ndarray</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot; 
    This is a wrapper of `np.array(obj, dtype=dtype, copy=copy)` 
    that will generate a warning if the result is an object array. 
    &quot;&quot;&quot;</span>
    <span class="s1">data </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s1">copy</span><span class="s3">)</span>
    <span class="s6"># Defer to getdtype for checking that the dtype is OK.</span>
    <span class="s6"># This is called for the validation only; we don't need the return value.</span>
    <span class="s1">getdtype</span><span class="s3">(</span><span class="s1">data</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">data</span>


<span class="s2">def </span><span class="s1">get_index_dtype</span><span class="s3">(</span><span class="s1">arrays</span><span class="s3">=(), </span><span class="s1">maxval</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">check_contents</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Based on input (integer) arrays `a`, determine a suitable index data 
    type that can hold the data in the arrays. 
 
    Parameters 
    ---------- 
    arrays : tuple of array_like 
        Input arrays whose types/contents to check 
    maxval : float, optional 
        Maximum value needed 
    check_contents : bool, optional 
        Whether to check the values in the arrays and not just their types. 
        Default: False (check only the types) 
 
    Returns 
    ------- 
    dtype : dtype 
        Suitable index data type (int32 or int64) 
 
    &quot;&quot;&quot;</span>

    <span class="s1">int32min </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">int32</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">iinfo</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">int32</span><span class="s3">).</span><span class="s1">min</span><span class="s3">)</span>
    <span class="s1">int32max </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">int32</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">iinfo</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">int32</span><span class="s3">).</span><span class="s1">max</span><span class="s3">)</span>

    <span class="s6"># not using intc directly due to misinteractions with pythran</span>
    <span class="s1">dtype </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">int32 </span><span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">intc</span><span class="s3">().</span><span class="s1">itemsize </span><span class="s3">== </span><span class="s5">4 </span><span class="s2">else </span><span class="s1">np</span><span class="s3">.</span><span class="s1">int64</span>
    <span class="s2">if </span><span class="s1">maxval </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s1">maxval </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">int64</span><span class="s3">(</span><span class="s1">maxval</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">maxval </span><span class="s3">&gt; </span><span class="s1">int32max</span><span class="s3">:</span>
            <span class="s1">dtype </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">int64</span>

    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">arrays</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndarray</span><span class="s3">):</span>
        <span class="s1">arrays </span><span class="s3">= (</span><span class="s1">arrays</span><span class="s3">,)</span>

    <span class="s2">for </span><span class="s1">arr </span><span class="s2">in </span><span class="s1">arrays</span><span class="s3">:</span>
        <span class="s1">arr </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">)</span>
        <span class="s2">if not </span><span class="s1">np</span><span class="s3">.</span><span class="s1">can_cast</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">int32</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">check_contents</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">size </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
                    <span class="s6"># a bigger type not needed</span>
                    <span class="s2">continue</span>
                <span class="s2">elif </span><span class="s1">np</span><span class="s3">.</span><span class="s1">issubdtype</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">integer</span><span class="s3">):</span>
                    <span class="s1">maxval </span><span class="s3">= </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">max</span><span class="s3">()</span>
                    <span class="s1">minval </span><span class="s3">= </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">min</span><span class="s3">()</span>
                    <span class="s2">if </span><span class="s1">minval </span><span class="s3">&gt;= </span><span class="s1">int32min </span><span class="s2">and </span><span class="s1">maxval </span><span class="s3">&lt;= </span><span class="s1">int32max</span><span class="s3">:</span>
                        <span class="s6"># a bigger type not needed</span>
                        <span class="s2">continue</span>

            <span class="s1">dtype </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">int64</span>
            <span class="s2">break</span>

    <span class="s2">return </span><span class="s1">dtype</span>


<span class="s2">def </span><span class="s1">get_sum_dtype</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">: </span><span class="s1">np</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">) </span><span class="s1">-&gt; np</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot;Mimic numpy's casting for np.sum&quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">kind </span><span class="s3">== </span><span class="s4">'u' </span><span class="s2">and </span><span class="s1">np</span><span class="s3">.</span><span class="s1">can_cast</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">uint</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">uint</span>
    <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">can_cast</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">int_</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">int_</span>
    <span class="s2">return </span><span class="s1">dtype</span>


<span class="s2">def </span><span class="s1">isscalarlike</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot;Is x either a scalar, an array scalar, or a 0-dim array?&quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isscalar</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">isdense</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) </span><span class="s2">and </span><span class="s1">x</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s5">0</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">isintlike</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot;Is x appropriate as an index into a sparse matrix? Returns True 
    if it can be cast safely to a machine int. 
    &quot;&quot;&quot;</span>
    <span class="s6"># Fast-path check to eliminate non-scalar values. operator.index would</span>
    <span class="s6"># catch this case too, but the exception catching is slow.</span>
    <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) != </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s2">return False</span>
    <span class="s2">try</span><span class="s3">:</span>
        <span class="s1">operator</span><span class="s3">.</span><span class="s1">index</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
    <span class="s2">except </span><span class="s3">(</span><span class="s1">TypeError</span><span class="s3">, </span><span class="s1">ValueError</span><span class="s3">):</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s1">loose_int </span><span class="s3">= </span><span class="s1">bool</span><span class="s3">(</span><span class="s1">int</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) == </span><span class="s1">x</span><span class="s3">)</span>
        <span class="s2">except </span><span class="s3">(</span><span class="s1">TypeError</span><span class="s3">, </span><span class="s1">ValueError</span><span class="s3">):</span>
            <span class="s2">return False</span>
        <span class="s2">if </span><span class="s1">loose_int</span><span class="s3">:</span>
            <span class="s1">msg </span><span class="s3">= </span><span class="s4">&quot;Inexact indices into sparse matrices are not allowed&quot;</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">loose_int</span>
    <span class="s2">return True</span>


<span class="s2">def </span><span class="s1">isshape</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">nonneg</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, *, </span><span class="s1">allow_1d</span><span class="s3">=</span><span class="s2">False</span><span class="s3">) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot;Is x a valid tuple of dimensions? 
 
    If nonneg, also checks that the dimensions are non-negative. 
    If allow_1d, shapes of length 1 or 2 are allowed. 
    &quot;&quot;&quot;</span>
    <span class="s1">ndim </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">ndim </span><span class="s3">!= </span><span class="s5">2 </span><span class="s2">and not </span><span class="s3">(</span><span class="s1">allow_1d </span><span class="s2">and </span><span class="s1">ndim </span><span class="s3">== </span><span class="s5">1</span><span class="s3">):</span>
        <span class="s2">return False</span>
    <span class="s2">for </span><span class="s1">d </span><span class="s2">in </span><span class="s1">x</span><span class="s3">:</span>
        <span class="s2">if not </span><span class="s1">isintlike</span><span class="s3">(</span><span class="s1">d</span><span class="s3">):</span>
            <span class="s2">return False</span>
        <span class="s2">if </span><span class="s1">nonneg </span><span class="s2">and </span><span class="s1">d </span><span class="s3">&lt; </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s2">return False</span>
    <span class="s2">return True</span>


<span class="s2">def </span><span class="s1">issequence</span><span class="s3">(</span><span class="s1">t</span><span class="s3">) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
    <span class="s2">return </span><span class="s3">((</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">t</span><span class="s3">, (</span><span class="s1">list</span><span class="s3">, </span><span class="s1">tuple</span><span class="s3">)) </span><span class="s2">and</span>
            <span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">t</span><span class="s3">) == </span><span class="s5">0 </span><span class="s2">or </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isscalar</span><span class="s3">(</span><span class="s1">t</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]))) </span><span class="s2">or</span>
            <span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">t</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndarray</span><span class="s3">) </span><span class="s2">and </span><span class="s3">(</span><span class="s1">t</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s5">1</span><span class="s3">)))</span>


<span class="s2">def </span><span class="s1">ismatrix</span><span class="s3">(</span><span class="s1">t</span><span class="s3">) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
    <span class="s2">return </span><span class="s3">((</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">t</span><span class="s3">, (</span><span class="s1">list</span><span class="s3">, </span><span class="s1">tuple</span><span class="s3">)) </span><span class="s2">and</span>
             <span class="s1">len</span><span class="s3">(</span><span class="s1">t</span><span class="s3">) &gt; </span><span class="s5">0 </span><span class="s2">and </span><span class="s1">issequence</span><span class="s3">(</span><span class="s1">t</span><span class="s3">[</span><span class="s5">0</span><span class="s3">])) </span><span class="s2">or</span>
            <span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">t</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndarray</span><span class="s3">) </span><span class="s2">and </span><span class="s1">t</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s5">2</span><span class="s3">))</span>


<span class="s2">def </span><span class="s1">isdense</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
    <span class="s2">return </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndarray</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">validateaxis</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
    <span class="s2">if </span><span class="s1">axis </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s2">return</span>
    <span class="s1">axis_type </span><span class="s3">= </span><span class="s1">type</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">)</span>

    <span class="s6"># In NumPy, you can pass in tuples for 'axis', but they are</span>
    <span class="s6"># not very useful for sparse matrices given their limited</span>
    <span class="s6"># dimensions, so let's make it explicit that they are not</span>
    <span class="s6"># allowed to be passed in</span>
    <span class="s2">if </span><span class="s1">axis_type </span><span class="s3">== </span><span class="s1">tuple</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s4">&quot;Tuples are not accepted for the 'axis' parameter. &quot;</span>
                        <span class="s4">&quot;Please pass in one of the following: &quot;</span>
                        <span class="s4">&quot;{-2, -1, 0, 1, None}.&quot;</span><span class="s3">)</span>

    <span class="s6"># If not a tuple, check that the provided axis is actually</span>
    <span class="s6"># an integer and raise a TypeError similar to NumPy's</span>
    <span class="s2">if not </span><span class="s1">np</span><span class="s3">.</span><span class="s1">issubdtype</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">(</span><span class="s1">axis_type</span><span class="s3">), </span><span class="s1">np</span><span class="s3">.</span><span class="s1">integer</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s4">f&quot;axis must be an integer, not </span><span class="s2">{</span><span class="s1">axis_type</span><span class="s3">.</span><span class="s1">__name__</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s3">)</span>

    <span class="s2">if not </span><span class="s3">(-</span><span class="s5">2 </span><span class="s3">&lt;= </span><span class="s1">axis </span><span class="s3">&lt;= </span><span class="s5">1</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;axis out of range&quot;</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">check_shape</span><span class="s3">(</span><span class="s1">args</span><span class="s3">, </span><span class="s1">current_shape</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, *, </span><span class="s1">allow_1d</span><span class="s3">=</span><span class="s2">False</span><span class="s3">) </span><span class="s1">-&gt; tuple</span><span class="s3">[</span><span class="s1">int</span><span class="s3">, ...]:</span>
    <span class="s0">&quot;&quot;&quot;Imitate numpy.matrix handling of shape arguments 
 
    Parameters 
    ---------- 
    args : array_like 
        Data structures providing information about the shape of the sparse array. 
    current_shape : tuple, optional 
        The current shape of the sparse array or matrix. 
        If None (default), the current shape will be inferred from args. 
    allow_1d : bool, optional 
        If True, then 1-D or 2-D arrays are accepted. 
        If False (default), then only 2-D arrays are accepted and an error is 
        raised otherwise. 
 
    Returns 
    ------- 
    new_shape: tuple 
        The new shape after validation. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">args</span><span class="s3">) == </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s4">&quot;function missing 1 required positional argument: &quot;</span>
                        <span class="s4">&quot;'shape'&quot;</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">args</span><span class="s3">) == </span><span class="s5">1</span><span class="s3">:</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s1">shape_iter </span><span class="s3">= </span><span class="s1">iter</span><span class="s3">(</span><span class="s1">args</span><span class="s3">[</span><span class="s5">0</span><span class="s3">])</span>
        <span class="s2">except </span><span class="s1">TypeError</span><span class="s3">:</span>
            <span class="s1">new_shape </span><span class="s3">= (</span><span class="s1">operator</span><span class="s3">.</span><span class="s1">index</span><span class="s3">(</span><span class="s1">args</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]), )</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">new_shape </span><span class="s3">= </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">operator</span><span class="s3">.</span><span class="s1">index</span><span class="s3">(</span><span class="s1">arg</span><span class="s3">) </span><span class="s2">for </span><span class="s1">arg </span><span class="s2">in </span><span class="s1">shape_iter</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">new_shape </span><span class="s3">= </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">operator</span><span class="s3">.</span><span class="s1">index</span><span class="s3">(</span><span class="s1">arg</span><span class="s3">) </span><span class="s2">for </span><span class="s1">arg </span><span class="s2">in </span><span class="s1">args</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">current_shape </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">allow_1d</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">new_shape</span><span class="s3">) </span><span class="s2">not in </span><span class="s3">(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s3">):</span>
                <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'shape must be a 1- or 2-tuple of positive '</span>
                                 <span class="s4">'integers'</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">len</span><span class="s3">(</span><span class="s1">new_shape</span><span class="s3">) != </span><span class="s5">2</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'shape must be a 2-tuple of positive integers'</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">any</span><span class="s3">(</span><span class="s1">d </span><span class="s3">&lt; </span><span class="s5">0 </span><span class="s2">for </span><span class="s1">d </span><span class="s2">in </span><span class="s1">new_shape</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;'shape' elements cannot be negative&quot;</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s6"># Check the current size only if needed</span>
        <span class="s1">current_size </span><span class="s3">= </span><span class="s1">prod</span><span class="s3">(</span><span class="s1">current_shape</span><span class="s3">)</span>

        <span class="s6"># Check for negatives</span>
        <span class="s1">negative_indexes </span><span class="s3">= [</span><span class="s1">i </span><span class="s2">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">x </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">new_shape</span><span class="s3">) </span><span class="s2">if </span><span class="s1">x </span><span class="s3">&lt; </span><span class="s5">0</span><span class="s3">]</span>
        <span class="s2">if not </span><span class="s1">negative_indexes</span><span class="s3">:</span>
            <span class="s1">new_size </span><span class="s3">= </span><span class="s1">prod</span><span class="s3">(</span><span class="s1">new_shape</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">new_size </span><span class="s3">!= </span><span class="s1">current_size</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'cannot reshape array of size {} into shape {}'</span>
                                 <span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">current_size</span><span class="s3">, </span><span class="s1">new_shape</span><span class="s3">))</span>
        <span class="s2">elif </span><span class="s1">len</span><span class="s3">(</span><span class="s1">negative_indexes</span><span class="s3">) == </span><span class="s5">1</span><span class="s3">:</span>
            <span class="s1">skip </span><span class="s3">= </span><span class="s1">negative_indexes</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
            <span class="s1">specified </span><span class="s3">= </span><span class="s1">prod</span><span class="s3">(</span><span class="s1">new_shape</span><span class="s3">[:</span><span class="s1">skip</span><span class="s3">] + </span><span class="s1">new_shape</span><span class="s3">[</span><span class="s1">skip</span><span class="s3">+</span><span class="s5">1</span><span class="s3">:])</span>
            <span class="s1">unspecified</span><span class="s3">, </span><span class="s1">remainder </span><span class="s3">= </span><span class="s1">divmod</span><span class="s3">(</span><span class="s1">current_size</span><span class="s3">, </span><span class="s1">specified</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">remainder </span><span class="s3">!= </span><span class="s5">0</span><span class="s3">:</span>
                <span class="s1">err_shape </span><span class="s3">= </span><span class="s1">tuple</span><span class="s3">(</span><span class="s4">'newshape' </span><span class="s2">if </span><span class="s1">x </span><span class="s3">&lt; </span><span class="s5">0 </span><span class="s2">else </span><span class="s1">x </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">new_shape</span><span class="s3">)</span>
                <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'cannot reshape array of size {} into shape {}'</span>
                                 <span class="s4">''</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">current_size</span><span class="s3">, </span><span class="s1">err_shape</span><span class="s3">))</span>
            <span class="s1">new_shape </span><span class="s3">= </span><span class="s1">new_shape</span><span class="s3">[:</span><span class="s1">skip</span><span class="s3">] + (</span><span class="s1">unspecified</span><span class="s3">,) + </span><span class="s1">new_shape</span><span class="s3">[</span><span class="s1">skip</span><span class="s3">+</span><span class="s5">1</span><span class="s3">:]</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'can only specify one unknown dimension'</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">new_shape</span><span class="s3">) != </span><span class="s5">2 </span><span class="s2">and not </span><span class="s3">(</span><span class="s1">allow_1d </span><span class="s2">and </span><span class="s1">len</span><span class="s3">(</span><span class="s1">new_shape</span><span class="s3">) == </span><span class="s5">1</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'matrix shape must be two-dimensional'</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">new_shape</span>


<span class="s2">def </span><span class="s1">check_reshape_kwargs</span><span class="s3">(</span><span class="s1">kwargs</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Unpack keyword arguments for reshape function. 
 
    This is useful because keyword arguments after star arguments are not 
    allowed in Python 2, but star keyword arguments are. This function unpacks 
    'order' and 'copy' from the star keyword arguments (with defaults) and 
    throws an error for any remaining. 
    &quot;&quot;&quot;</span>

    <span class="s1">order </span><span class="s3">= </span><span class="s1">kwargs</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">(</span><span class="s4">'order'</span><span class="s3">, </span><span class="s4">'C'</span><span class="s3">)</span>
    <span class="s1">copy </span><span class="s3">= </span><span class="s1">kwargs</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">(</span><span class="s4">'copy'</span><span class="s3">, </span><span class="s2">False</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">kwargs</span><span class="s3">:  </span><span class="s6"># Some unused kwargs remain</span>
        <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s4">'reshape() got unexpected keywords arguments: {}'</span>
                        <span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s4">', '</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">kwargs</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">())))</span>
    <span class="s2">return </span><span class="s1">order</span><span class="s3">, </span><span class="s1">copy</span>


<span class="s2">def </span><span class="s1">is_pydata_spmatrix</span><span class="s3">(</span><span class="s1">m</span><span class="s3">) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot; 
    Check whether object is pydata/sparse matrix, avoiding importing the module. 
    &quot;&quot;&quot;</span>
    <span class="s1">base_cls </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">sys</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'sparse'</span><span class="s3">), </span><span class="s4">'SparseArray'</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">base_cls </span><span class="s2">is not None and </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">m</span><span class="s3">, </span><span class="s1">base_cls</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">convert_pydata_sparse_to_scipy</span><span class="s3">(</span>
    <span class="s1">arg</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">, </span><span class="s1">target_format</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">Literal</span><span class="s3">[</span><span class="s4">&quot;csc&quot;</span><span class="s3">, </span><span class="s4">&quot;csr&quot;</span><span class="s3">]] = </span><span class="s2">None</span>
<span class="s3">) </span><span class="s1">-&gt; Union</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">, </span><span class="s4">&quot;sp.spmatrix&quot;</span><span class="s3">]:</span>
    <span class="s0">&quot;&quot;&quot; 
    Convert a pydata/sparse array to scipy sparse matrix, 
    pass through anything else. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">is_pydata_spmatrix</span><span class="s3">(</span><span class="s1">arg</span><span class="s3">):</span>
        <span class="s1">arg </span><span class="s3">= </span><span class="s1">arg</span><span class="s3">.</span><span class="s1">to_scipy_sparse</span><span class="s3">()</span>
        <span class="s2">if </span><span class="s1">target_format </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s1">arg </span><span class="s3">= </span><span class="s1">arg</span><span class="s3">.</span><span class="s1">asformat</span><span class="s3">(</span><span class="s1">target_format</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">arg</span><span class="s3">.</span><span class="s1">format </span><span class="s2">not in </span><span class="s3">(</span><span class="s4">&quot;csc&quot;</span><span class="s3">, </span><span class="s4">&quot;csr&quot;</span><span class="s3">):</span>
            <span class="s1">arg </span><span class="s3">= </span><span class="s1">arg</span><span class="s3">.</span><span class="s1">tocsc</span><span class="s3">()</span>
    <span class="s2">return </span><span class="s1">arg</span>


<span class="s6">###############################################################################</span>
<span class="s6"># Wrappers for NumPy types that are deprecated</span>

<span class="s6"># Numpy versions of these functions raise deprecation warnings, the</span>
<span class="s6"># ones below do not.</span>

<span class="s2">def </span><span class="s1">matrix</span><span class="s3">(*</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">):</span>
    <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(*</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">).</span><span class="s1">view</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">matrix</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">asmatrix</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">matrix</span><span class="s3">) </span><span class="s2">and </span><span class="s3">(</span><span class="s1">dtype </span><span class="s2">is None or </span><span class="s1">data</span><span class="s3">.</span><span class="s1">dtype </span><span class="s3">== </span><span class="s1">dtype</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">data</span>
    <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dtype</span><span class="s3">).</span><span class="s1">view</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">matrix</span><span class="s3">)</span>

<span class="s6">###############################################################################</span>


<span class="s2">def </span><span class="s1">_todata</span><span class="s3">(</span><span class="s1">s</span><span class="s3">) </span><span class="s1">-&gt; np</span><span class="s3">.</span><span class="s1">ndarray</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot;Access nonzero values, possibly after summing duplicates. 
 
    Parameters 
    ---------- 
    s : sparse array 
        Input sparse array. 
 
    Returns 
    ------- 
    data: ndarray 
      Nonzero values of the array, with shape (s.nnz,) 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">s</span><span class="s3">, </span><span class="s1">sp</span><span class="s3">.</span><span class="s1">_data</span><span class="s3">.</span><span class="s1">_data_matrix</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">s</span><span class="s3">.</span><span class="s1">_deduped_data</span><span class="s3">()</span>

    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">s</span><span class="s3">, </span><span class="s1">sp</span><span class="s3">.</span><span class="s1">dok_array</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">fromiter</span><span class="s3">(</span><span class="s1">s</span><span class="s3">.</span><span class="s1">values</span><span class="s3">(), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">s</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">count</span><span class="s3">=</span><span class="s1">s</span><span class="s3">.</span><span class="s1">nnz</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">s</span><span class="s3">, </span><span class="s1">sp</span><span class="s3">.</span><span class="s1">lil_array</span><span class="s3">):</span>
        <span class="s1">data </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">s</span><span class="s3">.</span><span class="s1">nnz</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">s</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>
        <span class="s1">sp</span><span class="s3">.</span><span class="s1">_csparsetools</span><span class="s3">.</span><span class="s1">lil_flatten_to_array</span><span class="s3">(</span><span class="s1">s</span><span class="s3">.</span><span class="s1">data</span><span class="s3">, </span><span class="s1">data</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">data</span>

    <span class="s2">return </span><span class="s1">s</span><span class="s3">.</span><span class="s1">tocoo</span><span class="s3">().</span><span class="s1">_deduped_data</span><span class="s3">()</span>
</pre>
</body>
</html>