<html>
<head>
<title>test_masked.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #6aab73;}
.s5 { color: #7a7e85;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_masked.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
This file contains a minimal set of tests for compliance with the extension 
array interface test suite, and should contain no other tests. 
The test suite for the full functionality of the array is located in 
`pandas/tests/arrays/`. 
 
The tests in this file are inherited from the BaseExtensionTests, and only 
minimal tweaks should be applied to get the tests passing (by overwriting a 
parent method). 
 
Additional tests should either be added to one of the BaseExtensionTests 
classes (if they are relevant for the extension interface for all dtypes), or 
be added to the array-specific tests in `pandas/tests/arrays/`. 
 
&quot;&quot;&quot;</span>
<span class="s2">import </span><span class="s1">warnings</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">import </span><span class="s1">pytest</span>

<span class="s2">from </span><span class="s1">pandas</span><span class="s3">.</span><span class="s1">compat </span><span class="s2">import </span><span class="s3">(</span>
    <span class="s1">IS64</span><span class="s3">,</span>
    <span class="s1">is_platform_windows</span><span class="s3">,</span>
<span class="s3">)</span>
<span class="s2">from </span><span class="s1">pandas</span><span class="s3">.</span><span class="s1">compat</span><span class="s3">.</span><span class="s1">numpy </span><span class="s2">import </span><span class="s1">np_version_gt2</span>

<span class="s2">from </span><span class="s1">pandas</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">dtypes</span><span class="s3">.</span><span class="s1">common </span><span class="s2">import </span><span class="s3">(</span>
    <span class="s1">is_float_dtype</span><span class="s3">,</span>
    <span class="s1">is_signed_integer_dtype</span><span class="s3">,</span>
    <span class="s1">is_unsigned_integer_dtype</span><span class="s3">,</span>
<span class="s3">)</span>

<span class="s2">import </span><span class="s1">pandas </span><span class="s2">as </span><span class="s1">pd</span>
<span class="s2">import </span><span class="s1">pandas</span><span class="s3">.</span><span class="s1">_testing </span><span class="s2">as </span><span class="s1">tm</span>
<span class="s2">from </span><span class="s1">pandas</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">arrays</span><span class="s3">.</span><span class="s1">boolean </span><span class="s2">import </span><span class="s1">BooleanDtype</span>
<span class="s2">from </span><span class="s1">pandas</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">arrays</span><span class="s3">.</span><span class="s1">floating </span><span class="s2">import </span><span class="s3">(</span>
    <span class="s1">Float32Dtype</span><span class="s3">,</span>
    <span class="s1">Float64Dtype</span><span class="s3">,</span>
<span class="s3">)</span>
<span class="s2">from </span><span class="s1">pandas</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">arrays</span><span class="s3">.</span><span class="s1">integer </span><span class="s2">import </span><span class="s3">(</span>
    <span class="s1">Int8Dtype</span><span class="s3">,</span>
    <span class="s1">Int16Dtype</span><span class="s3">,</span>
    <span class="s1">Int32Dtype</span><span class="s3">,</span>
    <span class="s1">Int64Dtype</span><span class="s3">,</span>
    <span class="s1">UInt8Dtype</span><span class="s3">,</span>
    <span class="s1">UInt16Dtype</span><span class="s3">,</span>
    <span class="s1">UInt32Dtype</span><span class="s3">,</span>
    <span class="s1">UInt64Dtype</span><span class="s3">,</span>
<span class="s3">)</span>
<span class="s2">from </span><span class="s1">pandas</span><span class="s3">.</span><span class="s1">tests</span><span class="s3">.</span><span class="s1">extension </span><span class="s2">import </span><span class="s1">base</span>

<span class="s1">is_windows_or_32bit </span><span class="s3">= (</span><span class="s1">is_platform_windows</span><span class="s3">() </span><span class="s2">and not </span><span class="s1">np_version_gt2</span><span class="s3">) </span><span class="s2">or not </span><span class="s1">IS64</span>

<span class="s1">pytestmark </span><span class="s3">= [</span>
    <span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">filterwarnings</span><span class="s3">(</span>
        <span class="s4">&quot;ignore:invalid value encountered in divide:RuntimeWarning&quot;</span>
    <span class="s3">),</span>
    <span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">filterwarnings</span><span class="s3">(</span><span class="s4">&quot;ignore:Mean of empty slice:RuntimeWarning&quot;</span><span class="s3">),</span>
    <span class="s5"># overflow only relevant for Floating dtype cases cases</span>
    <span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">filterwarnings</span><span class="s3">(</span><span class="s4">&quot;ignore:overflow encountered in reduce:RuntimeWarning&quot;</span><span class="s3">),</span>
<span class="s3">]</span>


<span class="s2">def </span><span class="s1">make_data</span><span class="s3">():</span>
    <span class="s2">return </span><span class="s1">list</span><span class="s3">(</span><span class="s1">range</span><span class="s3">(</span><span class="s6">1</span><span class="s3">, </span><span class="s6">9</span><span class="s3">)) + [</span><span class="s1">pd</span><span class="s3">.</span><span class="s1">NA</span><span class="s3">] + </span><span class="s1">list</span><span class="s3">(</span><span class="s1">range</span><span class="s3">(</span><span class="s6">10</span><span class="s3">, </span><span class="s6">98</span><span class="s3">)) + [</span><span class="s1">pd</span><span class="s3">.</span><span class="s1">NA</span><span class="s3">] + [</span><span class="s6">99</span><span class="s3">, </span><span class="s6">100</span><span class="s3">]</span>


<span class="s2">def </span><span class="s1">make_float_data</span><span class="s3">():</span>
    <span class="s2">return </span><span class="s3">(</span>
        <span class="s1">list</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s6">0.1</span><span class="s3">, </span><span class="s6">0.9</span><span class="s3">, </span><span class="s6">0.1</span><span class="s3">))</span>
        <span class="s3">+ [</span><span class="s1">pd</span><span class="s3">.</span><span class="s1">NA</span><span class="s3">]</span>
        <span class="s3">+ </span><span class="s1">list</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s6">1</span><span class="s3">, </span><span class="s6">9.8</span><span class="s3">, </span><span class="s6">0.1</span><span class="s3">))</span>
        <span class="s3">+ [</span><span class="s1">pd</span><span class="s3">.</span><span class="s1">NA</span><span class="s3">]</span>
        <span class="s3">+ [</span><span class="s6">9.9</span><span class="s3">, </span><span class="s6">10.0</span><span class="s3">]</span>
    <span class="s3">)</span>


<span class="s2">def </span><span class="s1">make_bool_data</span><span class="s3">():</span>
    <span class="s2">return </span><span class="s3">[</span><span class="s2">True</span><span class="s3">, </span><span class="s2">False</span><span class="s3">] * </span><span class="s6">4 </span><span class="s3">+ [</span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span><span class="s3">] + [</span><span class="s2">True</span><span class="s3">, </span><span class="s2">False</span><span class="s3">] * </span><span class="s6">44 </span><span class="s3">+ [</span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span><span class="s3">] + [</span><span class="s2">True</span><span class="s3">, </span><span class="s2">False</span><span class="s3">]</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">fixture</span><span class="s3">(</span>
    <span class="s1">params</span><span class="s3">=[</span>
        <span class="s1">Int8Dtype</span><span class="s3">,</span>
        <span class="s1">Int16Dtype</span><span class="s3">,</span>
        <span class="s1">Int32Dtype</span><span class="s3">,</span>
        <span class="s1">Int64Dtype</span><span class="s3">,</span>
        <span class="s1">UInt8Dtype</span><span class="s3">,</span>
        <span class="s1">UInt16Dtype</span><span class="s3">,</span>
        <span class="s1">UInt32Dtype</span><span class="s3">,</span>
        <span class="s1">UInt64Dtype</span><span class="s3">,</span>
        <span class="s1">Float32Dtype</span><span class="s3">,</span>
        <span class="s1">Float64Dtype</span><span class="s3">,</span>
        <span class="s1">BooleanDtype</span><span class="s3">,</span>
    <span class="s3">]</span>
<span class="s3">)</span>
<span class="s2">def </span><span class="s1">dtype</span><span class="s3">(</span><span class="s1">request</span><span class="s3">):</span>
    <span class="s2">return </span><span class="s1">request</span><span class="s3">.</span><span class="s1">param</span><span class="s3">()</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">fixture</span>
<span class="s2">def </span><span class="s1">data</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">kind </span><span class="s3">== </span><span class="s4">&quot;f&quot;</span><span class="s3">:</span>
        <span class="s1">data </span><span class="s3">= </span><span class="s1">make_float_data</span><span class="s3">()</span>
    <span class="s2">elif </span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">kind </span><span class="s3">== </span><span class="s4">&quot;b&quot;</span><span class="s3">:</span>
        <span class="s1">data </span><span class="s3">= </span><span class="s1">make_bool_data</span><span class="s3">()</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">data </span><span class="s3">= </span><span class="s1">make_data</span><span class="s3">()</span>
    <span class="s2">return </span><span class="s1">pd</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dtype</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">fixture</span>
<span class="s2">def </span><span class="s1">data_for_twos</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">kind </span><span class="s3">== </span><span class="s4">&quot;b&quot;</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">pd</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s6">100</span><span class="s3">), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dtype</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">pd</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s6">100</span><span class="s3">) * </span><span class="s6">2</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dtype</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">fixture</span>
<span class="s2">def </span><span class="s1">data_missing</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">kind </span><span class="s3">== </span><span class="s4">&quot;f&quot;</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">pd</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s1">pd</span><span class="s3">.</span><span class="s1">NA</span><span class="s3">, </span><span class="s6">0.1</span><span class="s3">], </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dtype</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">kind </span><span class="s3">== </span><span class="s4">&quot;b&quot;</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">pd</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span><span class="s3">, </span><span class="s2">True</span><span class="s3">], </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dtype</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">pd</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s1">pd</span><span class="s3">.</span><span class="s1">NA</span><span class="s3">, </span><span class="s6">1</span><span class="s3">], </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dtype</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">fixture</span>
<span class="s2">def </span><span class="s1">data_for_sorting</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">kind </span><span class="s3">== </span><span class="s4">&quot;f&quot;</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">pd</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s6">0.1</span><span class="s3">, </span><span class="s6">0.2</span><span class="s3">, </span><span class="s6">0.0</span><span class="s3">], </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dtype</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">kind </span><span class="s3">== </span><span class="s4">&quot;b&quot;</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">pd</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s2">True</span><span class="s3">, </span><span class="s2">True</span><span class="s3">, </span><span class="s2">False</span><span class="s3">], </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dtype</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">pd</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s6">1</span><span class="s3">, </span><span class="s6">2</span><span class="s3">, </span><span class="s6">0</span><span class="s3">], </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dtype</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">fixture</span>
<span class="s2">def </span><span class="s1">data_missing_for_sorting</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">kind </span><span class="s3">== </span><span class="s4">&quot;f&quot;</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">pd</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s6">0.1</span><span class="s3">, </span><span class="s1">pd</span><span class="s3">.</span><span class="s1">NA</span><span class="s3">, </span><span class="s6">0.0</span><span class="s3">], </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dtype</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">kind </span><span class="s3">== </span><span class="s4">&quot;b&quot;</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">pd</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s2">True</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span><span class="s3">, </span><span class="s2">False</span><span class="s3">], </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dtype</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">pd</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s6">1</span><span class="s3">, </span><span class="s1">pd</span><span class="s3">.</span><span class="s1">NA</span><span class="s3">, </span><span class="s6">0</span><span class="s3">], </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dtype</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">fixture</span>
<span class="s2">def </span><span class="s1">na_cmp</span><span class="s3">():</span>
    <span class="s5"># we are pd.NA</span>
    <span class="s2">return lambda </span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">: </span><span class="s1">x </span><span class="s2">is </span><span class="s1">pd</span><span class="s3">.</span><span class="s1">NA </span><span class="s2">and </span><span class="s1">y </span><span class="s2">is </span><span class="s1">pd</span><span class="s3">.</span><span class="s1">NA</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">fixture</span>
<span class="s2">def </span><span class="s1">data_for_grouping</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">kind </span><span class="s3">== </span><span class="s4">&quot;f&quot;</span><span class="s3">:</span>
        <span class="s1">b </span><span class="s3">= </span><span class="s6">0.1</span>
        <span class="s1">a </span><span class="s3">= </span><span class="s6">0.0</span>
        <span class="s1">c </span><span class="s3">= </span><span class="s6">0.2</span>
    <span class="s2">elif </span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">kind </span><span class="s3">== </span><span class="s4">&quot;b&quot;</span><span class="s3">:</span>
        <span class="s1">b </span><span class="s3">= </span><span class="s2">True</span>
        <span class="s1">a </span><span class="s3">= </span><span class="s2">False</span>
        <span class="s1">c </span><span class="s3">= </span><span class="s1">b</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">b </span><span class="s3">= </span><span class="s6">1</span>
        <span class="s1">a </span><span class="s3">= </span><span class="s6">0</span>
        <span class="s1">c </span><span class="s3">= </span><span class="s6">2</span>

    <span class="s1">na </span><span class="s3">= </span><span class="s1">pd</span><span class="s3">.</span><span class="s1">NA</span>
    <span class="s2">return </span><span class="s1">pd</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s1">b</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">na</span><span class="s3">, </span><span class="s1">na</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">c</span><span class="s3">], </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dtype</span><span class="s3">)</span>


<span class="s2">class </span><span class="s1">TestMaskedArrays</span><span class="s3">(</span><span class="s1">base</span><span class="s3">.</span><span class="s1">ExtensionTests</span><span class="s3">):</span>
    <span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s4">&quot;na_action&quot;</span><span class="s3">, [</span><span class="s2">None</span><span class="s3">, </span><span class="s4">&quot;ignore&quot;</span><span class="s3">])</span>
    <span class="s2">def </span><span class="s1">test_map</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">data_missing</span><span class="s3">, </span><span class="s1">na_action</span><span class="s3">):</span>
        <span class="s1">result </span><span class="s3">= </span><span class="s1">data_missing</span><span class="s3">.</span><span class="s1">map</span><span class="s3">(</span><span class="s2">lambda </span><span class="s1">x</span><span class="s3">: </span><span class="s1">x</span><span class="s3">, </span><span class="s1">na_action</span><span class="s3">=</span><span class="s1">na_action</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">data_missing</span><span class="s3">.</span><span class="s1">dtype </span><span class="s3">== </span><span class="s1">Float32Dtype</span><span class="s3">():</span>
            <span class="s5"># map roundtrips through objects, which converts to float64</span>
            <span class="s1">expected </span><span class="s3">= </span><span class="s1">data_missing</span><span class="s3">.</span><span class="s1">to_numpy</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">=</span><span class="s4">&quot;float64&quot;</span><span class="s3">, </span><span class="s1">na_value</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">expected </span><span class="s3">= </span><span class="s1">data_missing</span><span class="s3">.</span><span class="s1">to_numpy</span><span class="s3">()</span>
        <span class="s1">tm</span><span class="s3">.</span><span class="s1">assert_numpy_array_equal</span><span class="s3">(</span><span class="s1">result</span><span class="s3">, </span><span class="s1">expected</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_map_na_action_ignore</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">data_missing_for_sorting</span><span class="s3">):</span>
        <span class="s1">zero </span><span class="s3">= </span><span class="s1">data_missing_for_sorting</span><span class="s3">[</span><span class="s6">2</span><span class="s3">]</span>
        <span class="s1">result </span><span class="s3">= </span><span class="s1">data_missing_for_sorting</span><span class="s3">.</span><span class="s1">map</span><span class="s3">(</span><span class="s2">lambda </span><span class="s1">x</span><span class="s3">: </span><span class="s1">zero</span><span class="s3">, </span><span class="s1">na_action</span><span class="s3">=</span><span class="s4">&quot;ignore&quot;</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">data_missing_for_sorting</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">kind </span><span class="s3">== </span><span class="s4">&quot;b&quot;</span><span class="s3">:</span>
            <span class="s1">expected </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s2">False</span><span class="s3">, </span><span class="s1">pd</span><span class="s3">.</span><span class="s1">NA</span><span class="s3">, </span><span class="s2">False</span><span class="s3">], </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">object</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">expected </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s1">zero</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span><span class="s3">, </span><span class="s1">zero</span><span class="s3">])</span>
        <span class="s1">tm</span><span class="s3">.</span><span class="s1">assert_numpy_array_equal</span><span class="s3">(</span><span class="s1">result</span><span class="s3">, </span><span class="s1">expected</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_get_expected_exception</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">op_name</span><span class="s3">, </span><span class="s1">obj</span><span class="s3">, </span><span class="s1">other</span><span class="s3">):</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s1">dtype </span><span class="s3">= </span><span class="s1">tm</span><span class="s3">.</span><span class="s1">get_dtype</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">)</span>
        <span class="s2">except </span><span class="s1">AttributeError</span><span class="s3">:</span>
            <span class="s5"># passed arguments reversed</span>
            <span class="s1">dtype </span><span class="s3">= </span><span class="s1">tm</span><span class="s3">.</span><span class="s1">get_dtype</span><span class="s3">(</span><span class="s1">other</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">kind </span><span class="s3">== </span><span class="s4">&quot;b&quot;</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">op_name</span><span class="s3">.</span><span class="s1">strip</span><span class="s3">(</span><span class="s4">&quot;_&quot;</span><span class="s3">).</span><span class="s1">lstrip</span><span class="s3">(</span><span class="s4">&quot;r&quot;</span><span class="s3">) </span><span class="s2">in </span><span class="s3">[</span><span class="s4">&quot;pow&quot;</span><span class="s3">, </span><span class="s4">&quot;truediv&quot;</span><span class="s3">, </span><span class="s4">&quot;floordiv&quot;</span><span class="s3">]:</span>
                <span class="s5"># match behavior with non-masked bool dtype</span>
                <span class="s2">return </span><span class="s1">NotImplementedError</span>
            <span class="s2">elif </span><span class="s1">op_name </span><span class="s2">in </span><span class="s3">[</span><span class="s4">&quot;__sub__&quot;</span><span class="s3">, </span><span class="s4">&quot;__rsub__&quot;</span><span class="s3">]:</span>
                <span class="s5"># exception message would include &quot;numpy boolean subtract&quot;&quot;</span>
                <span class="s2">return </span><span class="s1">TypeError</span>
            <span class="s2">return None</span>
        <span class="s2">return None</span>

    <span class="s2">def </span><span class="s1">_cast_pointwise_result</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">op_name</span><span class="s3">: </span><span class="s1">str</span><span class="s3">, </span><span class="s1">obj</span><span class="s3">, </span><span class="s1">other</span><span class="s3">, </span><span class="s1">pointwise_result</span><span class="s3">):</span>
        <span class="s1">sdtype </span><span class="s3">= </span><span class="s1">tm</span><span class="s3">.</span><span class="s1">get_dtype</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">)</span>
        <span class="s1">expected </span><span class="s3">= </span><span class="s1">pointwise_result</span>

        <span class="s2">if </span><span class="s1">op_name </span><span class="s2">in </span><span class="s3">(</span><span class="s4">&quot;eq&quot;</span><span class="s3">, </span><span class="s4">&quot;ne&quot;</span><span class="s3">, </span><span class="s4">&quot;le&quot;</span><span class="s3">, </span><span class="s4">&quot;ge&quot;</span><span class="s3">, </span><span class="s4">&quot;lt&quot;</span><span class="s3">, </span><span class="s4">&quot;gt&quot;</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">expected</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s4">&quot;boolean&quot;</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">sdtype</span><span class="s3">.</span><span class="s1">kind </span><span class="s2">in </span><span class="s4">&quot;iu&quot;</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">op_name </span><span class="s2">in </span><span class="s3">(</span><span class="s4">&quot;__rtruediv__&quot;</span><span class="s3">, </span><span class="s4">&quot;__truediv__&quot;</span><span class="s3">, </span><span class="s4">&quot;__div__&quot;</span><span class="s3">):</span>
                <span class="s2">with </span><span class="s1">warnings</span><span class="s3">.</span><span class="s1">catch_warnings</span><span class="s3">():</span>
                    <span class="s1">warnings</span><span class="s3">.</span><span class="s1">filterwarnings</span><span class="s3">(</span>
                        <span class="s4">&quot;ignore&quot;</span><span class="s3">,</span>
                        <span class="s4">&quot;Downcasting object dtype arrays&quot;</span><span class="s3">,</span>
                        <span class="s1">category</span><span class="s3">=</span><span class="s1">FutureWarning</span><span class="s3">,</span>
                    <span class="s3">)</span>
                    <span class="s1">filled </span><span class="s3">= </span><span class="s1">expected</span><span class="s3">.</span><span class="s1">fillna</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span><span class="s3">)</span>
                <span class="s1">expected </span><span class="s3">= </span><span class="s1">filled</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s4">&quot;Float64&quot;</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s5"># combine method result in 'biggest' (int64) dtype</span>
                <span class="s1">expected </span><span class="s3">= </span><span class="s1">expected</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">sdtype</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">sdtype</span><span class="s3">.</span><span class="s1">kind </span><span class="s3">== </span><span class="s4">&quot;b&quot;</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">op_name </span><span class="s2">in </span><span class="s3">(</span>
                <span class="s4">&quot;__floordiv__&quot;</span><span class="s3">,</span>
                <span class="s4">&quot;__rfloordiv__&quot;</span><span class="s3">,</span>
                <span class="s4">&quot;__pow__&quot;</span><span class="s3">,</span>
                <span class="s4">&quot;__rpow__&quot;</span><span class="s3">,</span>
                <span class="s4">&quot;__mod__&quot;</span><span class="s3">,</span>
                <span class="s4">&quot;__rmod__&quot;</span><span class="s3">,</span>
            <span class="s3">):</span>
                <span class="s5"># combine keeps boolean type</span>
                <span class="s1">expected </span><span class="s3">= </span><span class="s1">expected</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s4">&quot;Int8&quot;</span><span class="s3">)</span>

            <span class="s2">elif </span><span class="s1">op_name </span><span class="s2">in </span><span class="s3">(</span><span class="s4">&quot;__truediv__&quot;</span><span class="s3">, </span><span class="s4">&quot;__rtruediv__&quot;</span><span class="s3">):</span>
                <span class="s5"># combine with bools does not generate the correct result</span>
                <span class="s5">#  (numpy behaviour for div is to regard the bools as numeric)</span>
                <span class="s1">op </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">get_op_from_name</span><span class="s3">(</span><span class="s1">op_name</span><span class="s3">)</span>
                <span class="s1">expected </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_combine</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">float</span><span class="s3">), </span><span class="s1">other</span><span class="s3">, </span><span class="s1">op</span><span class="s3">)</span>
                <span class="s1">expected </span><span class="s3">= </span><span class="s1">expected</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s4">&quot;Float64&quot;</span><span class="s3">)</span>

            <span class="s2">if </span><span class="s1">op_name </span><span class="s3">== </span><span class="s4">&quot;__rpow__&quot;</span><span class="s3">:</span>
                <span class="s5"># for rpow, combine does not propagate NaN</span>
                <span class="s1">result </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">op_name</span><span class="s3">)(</span><span class="s1">other</span><span class="s3">)</span>
                <span class="s1">expected</span><span class="s3">[</span><span class="s1">result</span><span class="s3">.</span><span class="s1">isna</span><span class="s3">()] = </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s5"># combine method result in 'biggest' (float64) dtype</span>
            <span class="s1">expected </span><span class="s3">= </span><span class="s1">expected</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">sdtype</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">expected</span>

    <span class="s2">def </span><span class="s1">test_divmod_series_array</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">data_for_twos</span><span class="s3">, </span><span class="s1">request</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">data</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">kind </span><span class="s3">== </span><span class="s4">&quot;b&quot;</span><span class="s3">:</span>
            <span class="s1">mark </span><span class="s3">= </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">xfail</span><span class="s3">(</span>
                <span class="s1">reason</span><span class="s3">=</span><span class="s4">&quot;Inconsistency between floordiv and divmod; we raise for &quot;</span>
                <span class="s4">&quot;floordiv but not for divmod. This matches what we do for &quot;</span>
                <span class="s4">&quot;non-masked bool dtype.&quot;</span>
            <span class="s3">)</span>
            <span class="s1">request</span><span class="s3">.</span><span class="s1">applymarker</span><span class="s3">(</span><span class="s1">mark</span><span class="s3">)</span>
        <span class="s1">super</span><span class="s3">().</span><span class="s1">test_divmod_series_array</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">data_for_twos</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_combine_le</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">data_repeated</span><span class="s3">):</span>
        <span class="s5"># TODO: patching self is a bad pattern here</span>
        <span class="s1">orig_data1</span><span class="s3">, </span><span class="s1">orig_data2 </span><span class="s3">= </span><span class="s1">data_repeated</span><span class="s3">(</span><span class="s6">2</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">orig_data1</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">kind </span><span class="s3">== </span><span class="s4">&quot;b&quot;</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_combine_le_expected_dtype </span><span class="s3">= </span><span class="s4">&quot;boolean&quot;</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s5"># TODO: can we make this boolean?</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_combine_le_expected_dtype </span><span class="s3">= </span><span class="s1">object</span>
        <span class="s1">super</span><span class="s3">().</span><span class="s1">test_combine_le</span><span class="s3">(</span><span class="s1">data_repeated</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_supports_reduction</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">ser</span><span class="s3">: </span><span class="s1">pd</span><span class="s3">.</span><span class="s1">Series</span><span class="s3">, </span><span class="s1">op_name</span><span class="s3">: </span><span class="s1">str</span><span class="s3">) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">op_name </span><span class="s2">in </span><span class="s3">[</span><span class="s4">&quot;any&quot;</span><span class="s3">, </span><span class="s4">&quot;all&quot;</span><span class="s3">] </span><span class="s2">and </span><span class="s1">ser</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">kind </span><span class="s3">!= </span><span class="s4">&quot;b&quot;</span><span class="s3">:</span>
            <span class="s1">pytest</span><span class="s3">.</span><span class="s1">skip</span><span class="s3">(</span><span class="s1">reason</span><span class="s3">=</span><span class="s4">&quot;Tested in tests/reductions/test_reductions.py&quot;</span><span class="s3">)</span>
        <span class="s2">return True</span>

    <span class="s2">def </span><span class="s1">check_reduce</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">ser</span><span class="s3">: </span><span class="s1">pd</span><span class="s3">.</span><span class="s1">Series</span><span class="s3">, </span><span class="s1">op_name</span><span class="s3">: </span><span class="s1">str</span><span class="s3">, </span><span class="s1">skipna</span><span class="s3">: </span><span class="s1">bool</span><span class="s3">):</span>
        <span class="s5"># overwrite to ensure pd.NA is tested instead of np.nan</span>
        <span class="s5"># https://github.com/pandas-dev/pandas/issues/30958</span>

        <span class="s1">cmp_dtype </span><span class="s3">= </span><span class="s4">&quot;int64&quot;</span>
        <span class="s2">if </span><span class="s1">ser</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">kind </span><span class="s3">== </span><span class="s4">&quot;f&quot;</span><span class="s3">:</span>
            <span class="s5"># Item &quot;dtype[Any]&quot; of &quot;Union[dtype[Any], ExtensionDtype]&quot; has</span>
            <span class="s5"># no attribute &quot;numpy_dtype&quot;</span>
            <span class="s1">cmp_dtype </span><span class="s3">= </span><span class="s1">ser</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">numpy_dtype  </span><span class="s5"># type: ignore[union-attr]</span>
        <span class="s2">elif </span><span class="s1">ser</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">kind </span><span class="s3">== </span><span class="s4">&quot;b&quot;</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">op_name </span><span class="s2">in </span><span class="s3">[</span><span class="s4">&quot;min&quot;</span><span class="s3">, </span><span class="s4">&quot;max&quot;</span><span class="s3">]:</span>
                <span class="s1">cmp_dtype </span><span class="s3">= </span><span class="s4">&quot;bool&quot;</span>

        <span class="s5"># TODO: prod with integer dtypes does *not* match the result we would</span>
        <span class="s5">#  get if we used object for cmp_dtype. In that cae the object result</span>
        <span class="s5">#  is a large integer while the non-object case overflows and returns 0</span>
        <span class="s1">alt </span><span class="s3">= </span><span class="s1">ser</span><span class="s3">.</span><span class="s1">dropna</span><span class="s3">().</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">cmp_dtype</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">op_name </span><span class="s3">== </span><span class="s4">&quot;count&quot;</span><span class="s3">:</span>
            <span class="s1">result </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">ser</span><span class="s3">, </span><span class="s1">op_name</span><span class="s3">)()</span>
            <span class="s1">expected </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">alt</span><span class="s3">, </span><span class="s1">op_name</span><span class="s3">)()</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">result </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">ser</span><span class="s3">, </span><span class="s1">op_name</span><span class="s3">)(</span><span class="s1">skipna</span><span class="s3">=</span><span class="s1">skipna</span><span class="s3">)</span>
            <span class="s1">expected </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">alt</span><span class="s3">, </span><span class="s1">op_name</span><span class="s3">)(</span><span class="s1">skipna</span><span class="s3">=</span><span class="s1">skipna</span><span class="s3">)</span>
            <span class="s2">if not </span><span class="s1">skipna </span><span class="s2">and </span><span class="s1">ser</span><span class="s3">.</span><span class="s1">isna</span><span class="s3">().</span><span class="s1">any</span><span class="s3">() </span><span class="s2">and </span><span class="s1">op_name </span><span class="s2">not in </span><span class="s3">[</span><span class="s4">&quot;any&quot;</span><span class="s3">, </span><span class="s4">&quot;all&quot;</span><span class="s3">]:</span>
                <span class="s1">expected </span><span class="s3">= </span><span class="s1">pd</span><span class="s3">.</span><span class="s1">NA</span>
        <span class="s1">tm</span><span class="s3">.</span><span class="s1">assert_almost_equal</span><span class="s3">(</span><span class="s1">result</span><span class="s3">, </span><span class="s1">expected</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_get_expected_reduction_dtype</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">, </span><span class="s1">op_name</span><span class="s3">: </span><span class="s1">str</span><span class="s3">, </span><span class="s1">skipna</span><span class="s3">: </span><span class="s1">bool</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">is_float_dtype</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">):</span>
            <span class="s1">cmp_dtype </span><span class="s3">= </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">name</span>
        <span class="s2">elif </span><span class="s1">op_name </span><span class="s2">in </span><span class="s3">[</span><span class="s4">&quot;mean&quot;</span><span class="s3">, </span><span class="s4">&quot;median&quot;</span><span class="s3">, </span><span class="s4">&quot;var&quot;</span><span class="s3">, </span><span class="s4">&quot;std&quot;</span><span class="s3">, </span><span class="s4">&quot;skew&quot;</span><span class="s3">]:</span>
            <span class="s1">cmp_dtype </span><span class="s3">= </span><span class="s4">&quot;Float64&quot;</span>
        <span class="s2">elif </span><span class="s1">op_name </span><span class="s2">in </span><span class="s3">[</span><span class="s4">&quot;max&quot;</span><span class="s3">, </span><span class="s4">&quot;min&quot;</span><span class="s3">]:</span>
            <span class="s1">cmp_dtype </span><span class="s3">= </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">name</span>
        <span class="s2">elif </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">dtype </span><span class="s2">in </span><span class="s3">[</span><span class="s4">&quot;Int64&quot;</span><span class="s3">, </span><span class="s4">&quot;UInt64&quot;</span><span class="s3">]:</span>
            <span class="s1">cmp_dtype </span><span class="s3">= </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">name</span>
        <span class="s2">elif </span><span class="s1">is_signed_integer_dtype</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">):</span>
            <span class="s5"># TODO: Why does Window Numpy 2.0 dtype depend on skipna?</span>
            <span class="s1">cmp_dtype </span><span class="s3">= (</span>
                <span class="s4">&quot;Int32&quot;</span>
                <span class="s2">if </span><span class="s3">(</span><span class="s1">is_platform_windows</span><span class="s3">() </span><span class="s2">and </span><span class="s3">(</span><span class="s2">not </span><span class="s1">np_version_gt2 </span><span class="s2">or not </span><span class="s1">skipna</span><span class="s3">))</span>
                <span class="s2">or not </span><span class="s1">IS64</span>
                <span class="s2">else </span><span class="s4">&quot;Int64&quot;</span>
            <span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">is_unsigned_integer_dtype</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">):</span>
            <span class="s1">cmp_dtype </span><span class="s3">= (</span>
                <span class="s4">&quot;UInt32&quot;</span>
                <span class="s2">if </span><span class="s3">(</span><span class="s1">is_platform_windows</span><span class="s3">() </span><span class="s2">and </span><span class="s3">(</span><span class="s2">not </span><span class="s1">np_version_gt2 </span><span class="s2">or not </span><span class="s1">skipna</span><span class="s3">))</span>
                <span class="s2">or not </span><span class="s1">IS64</span>
                <span class="s2">else </span><span class="s4">&quot;UInt64&quot;</span>
            <span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">kind </span><span class="s3">== </span><span class="s4">&quot;b&quot;</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">op_name </span><span class="s2">in </span><span class="s3">[</span><span class="s4">&quot;mean&quot;</span><span class="s3">, </span><span class="s4">&quot;median&quot;</span><span class="s3">, </span><span class="s4">&quot;var&quot;</span><span class="s3">, </span><span class="s4">&quot;std&quot;</span><span class="s3">, </span><span class="s4">&quot;skew&quot;</span><span class="s3">]:</span>
                <span class="s1">cmp_dtype </span><span class="s3">= </span><span class="s4">&quot;Float64&quot;</span>
            <span class="s2">elif </span><span class="s1">op_name </span><span class="s2">in </span><span class="s3">[</span><span class="s4">&quot;min&quot;</span><span class="s3">, </span><span class="s4">&quot;max&quot;</span><span class="s3">]:</span>
                <span class="s1">cmp_dtype </span><span class="s3">= </span><span class="s4">&quot;boolean&quot;</span>
            <span class="s2">elif </span><span class="s1">op_name </span><span class="s2">in </span><span class="s3">[</span><span class="s4">&quot;sum&quot;</span><span class="s3">, </span><span class="s4">&quot;prod&quot;</span><span class="s3">]:</span>
                <span class="s1">cmp_dtype </span><span class="s3">= (</span>
                    <span class="s4">&quot;Int32&quot;</span>
                    <span class="s2">if </span><span class="s3">(</span><span class="s1">is_platform_windows</span><span class="s3">() </span><span class="s2">and </span><span class="s3">(</span><span class="s2">not </span><span class="s1">np_version_gt2 </span><span class="s2">or not </span><span class="s1">skipna</span><span class="s3">))</span>
                    <span class="s2">or not </span><span class="s1">IS64</span>
                    <span class="s2">else </span><span class="s4">&quot;Int64&quot;</span>
                <span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s4">&quot;not supposed to reach this&quot;</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s4">&quot;not supposed to reach this&quot;</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">cmp_dtype</span>

    <span class="s2">def </span><span class="s1">_supports_accumulation</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">ser</span><span class="s3">: </span><span class="s1">pd</span><span class="s3">.</span><span class="s1">Series</span><span class="s3">, </span><span class="s1">op_name</span><span class="s3">: </span><span class="s1">str</span><span class="s3">) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
        <span class="s2">return True</span>

    <span class="s2">def </span><span class="s1">check_accumulate</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">ser</span><span class="s3">: </span><span class="s1">pd</span><span class="s3">.</span><span class="s1">Series</span><span class="s3">, </span><span class="s1">op_name</span><span class="s3">: </span><span class="s1">str</span><span class="s3">, </span><span class="s1">skipna</span><span class="s3">: </span><span class="s1">bool</span><span class="s3">):</span>
        <span class="s5"># overwrite to ensure pd.NA is tested instead of np.nan</span>
        <span class="s5"># https://github.com/pandas-dev/pandas/issues/30958</span>
        <span class="s1">length </span><span class="s3">= </span><span class="s6">64</span>
        <span class="s2">if </span><span class="s1">is_windows_or_32bit</span><span class="s3">:</span>
            <span class="s5"># Item &quot;ExtensionDtype&quot; of &quot;Union[dtype[Any], ExtensionDtype]&quot; has</span>
            <span class="s5"># no attribute &quot;itemsize&quot;</span>
            <span class="s2">if not </span><span class="s1">ser</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">itemsize </span><span class="s3">== </span><span class="s6">8</span><span class="s3">:  </span><span class="s5"># type: ignore[union-attr]</span>
                <span class="s1">length </span><span class="s3">= </span><span class="s6">32</span>

        <span class="s2">if </span><span class="s1">ser</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">name</span><span class="s3">.</span><span class="s1">startswith</span><span class="s3">(</span><span class="s4">&quot;U&quot;</span><span class="s3">):</span>
            <span class="s1">expected_dtype </span><span class="s3">= </span><span class="s4">f&quot;UInt</span><span class="s2">{</span><span class="s1">length</span><span class="s2">}</span><span class="s4">&quot;</span>
        <span class="s2">elif </span><span class="s1">ser</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">name</span><span class="s3">.</span><span class="s1">startswith</span><span class="s3">(</span><span class="s4">&quot;I&quot;</span><span class="s3">):</span>
            <span class="s1">expected_dtype </span><span class="s3">= </span><span class="s4">f&quot;Int</span><span class="s2">{</span><span class="s1">length</span><span class="s2">}</span><span class="s4">&quot;</span>
        <span class="s2">elif </span><span class="s1">ser</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">name</span><span class="s3">.</span><span class="s1">startswith</span><span class="s3">(</span><span class="s4">&quot;F&quot;</span><span class="s3">):</span>
            <span class="s5"># Incompatible types in assignment (expression has type</span>
            <span class="s5"># &quot;Union[dtype[Any], ExtensionDtype]&quot;, variable has type &quot;str&quot;)</span>
            <span class="s1">expected_dtype </span><span class="s3">= </span><span class="s1">ser</span><span class="s3">.</span><span class="s1">dtype  </span><span class="s5"># type: ignore[assignment]</span>
        <span class="s2">elif </span><span class="s1">ser</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">kind </span><span class="s3">== </span><span class="s4">&quot;b&quot;</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">op_name </span><span class="s2">in </span><span class="s3">(</span><span class="s4">&quot;cummin&quot;</span><span class="s3">, </span><span class="s4">&quot;cummax&quot;</span><span class="s3">):</span>
                <span class="s1">expected_dtype </span><span class="s3">= </span><span class="s4">&quot;boolean&quot;</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">expected_dtype </span><span class="s3">= </span><span class="s4">f&quot;Int</span><span class="s2">{</span><span class="s1">length</span><span class="s2">}</span><span class="s4">&quot;</span>

        <span class="s2">if </span><span class="s1">expected_dtype </span><span class="s3">== </span><span class="s4">&quot;Float32&quot; </span><span class="s2">and </span><span class="s1">op_name </span><span class="s3">== </span><span class="s4">&quot;cumprod&quot; </span><span class="s2">and </span><span class="s1">skipna</span><span class="s3">:</span>
            <span class="s5"># TODO: xfail?</span>
            <span class="s1">pytest</span><span class="s3">.</span><span class="s1">skip</span><span class="s3">(</span>
                <span class="s4">f&quot;Float32 precision lead to large differences with op </span><span class="s2">{</span><span class="s1">op_name</span><span class="s2">} </span><span class="s4">&quot;</span>
                <span class="s4">f&quot;and skipna=</span><span class="s2">{</span><span class="s1">skipna</span><span class="s2">}</span><span class="s4">&quot;</span>
            <span class="s3">)</span>

        <span class="s2">if </span><span class="s1">op_name </span><span class="s3">== </span><span class="s4">&quot;cumsum&quot;</span><span class="s3">:</span>
            <span class="s1">result </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">ser</span><span class="s3">, </span><span class="s1">op_name</span><span class="s3">)(</span><span class="s1">skipna</span><span class="s3">=</span><span class="s1">skipna</span><span class="s3">)</span>
            <span class="s1">expected </span><span class="s3">= </span><span class="s1">pd</span><span class="s3">.</span><span class="s1">Series</span><span class="s3">(</span>
                <span class="s1">pd</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span>
                    <span class="s1">getattr</span><span class="s3">(</span><span class="s1">ser</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s4">&quot;float64&quot;</span><span class="s3">), </span><span class="s1">op_name</span><span class="s3">)(</span><span class="s1">skipna</span><span class="s3">=</span><span class="s1">skipna</span><span class="s3">),</span>
                    <span class="s1">dtype</span><span class="s3">=</span><span class="s1">expected_dtype</span><span class="s3">,</span>
                <span class="s3">)</span>
            <span class="s3">)</span>
            <span class="s1">tm</span><span class="s3">.</span><span class="s1">assert_series_equal</span><span class="s3">(</span><span class="s1">result</span><span class="s3">, </span><span class="s1">expected</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">op_name </span><span class="s2">in </span><span class="s3">[</span><span class="s4">&quot;cummax&quot;</span><span class="s3">, </span><span class="s4">&quot;cummin&quot;</span><span class="s3">]:</span>
            <span class="s1">result </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">ser</span><span class="s3">, </span><span class="s1">op_name</span><span class="s3">)(</span><span class="s1">skipna</span><span class="s3">=</span><span class="s1">skipna</span><span class="s3">)</span>
            <span class="s1">expected </span><span class="s3">= </span><span class="s1">pd</span><span class="s3">.</span><span class="s1">Series</span><span class="s3">(</span>
                <span class="s1">pd</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span>
                    <span class="s1">getattr</span><span class="s3">(</span><span class="s1">ser</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s4">&quot;float64&quot;</span><span class="s3">), </span><span class="s1">op_name</span><span class="s3">)(</span><span class="s1">skipna</span><span class="s3">=</span><span class="s1">skipna</span><span class="s3">),</span>
                    <span class="s1">dtype</span><span class="s3">=</span><span class="s1">ser</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">,</span>
                <span class="s3">)</span>
            <span class="s3">)</span>
            <span class="s1">tm</span><span class="s3">.</span><span class="s1">assert_series_equal</span><span class="s3">(</span><span class="s1">result</span><span class="s3">, </span><span class="s1">expected</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">op_name </span><span class="s3">== </span><span class="s4">&quot;cumprod&quot;</span><span class="s3">:</span>
            <span class="s1">result </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">ser</span><span class="s3">[:</span><span class="s6">12</span><span class="s3">], </span><span class="s1">op_name</span><span class="s3">)(</span><span class="s1">skipna</span><span class="s3">=</span><span class="s1">skipna</span><span class="s3">)</span>
            <span class="s1">expected </span><span class="s3">= </span><span class="s1">pd</span><span class="s3">.</span><span class="s1">Series</span><span class="s3">(</span>
                <span class="s1">pd</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span>
                    <span class="s1">getattr</span><span class="s3">(</span><span class="s1">ser</span><span class="s3">[:</span><span class="s6">12</span><span class="s3">].</span><span class="s1">astype</span><span class="s3">(</span><span class="s4">&quot;float64&quot;</span><span class="s3">), </span><span class="s1">op_name</span><span class="s3">)(</span><span class="s1">skipna</span><span class="s3">=</span><span class="s1">skipna</span><span class="s3">),</span>
                    <span class="s1">dtype</span><span class="s3">=</span><span class="s1">expected_dtype</span><span class="s3">,</span>
                <span class="s3">)</span>
            <span class="s3">)</span>
            <span class="s1">tm</span><span class="s3">.</span><span class="s1">assert_series_equal</span><span class="s3">(</span><span class="s1">result</span><span class="s3">, </span><span class="s1">expected</span><span class="s3">)</span>

        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">NotImplementedError</span><span class="s3">(</span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">op_name</span><span class="s2">} </span><span class="s4">not supported&quot;</span><span class="s3">)</span>


<span class="s2">class </span><span class="s1">Test2DCompat</span><span class="s3">(</span><span class="s1">base</span><span class="s3">.</span><span class="s1">Dim2CompatTests</span><span class="s3">):</span>
    <span class="s2">pass</span>
</pre>
</body>
</html>