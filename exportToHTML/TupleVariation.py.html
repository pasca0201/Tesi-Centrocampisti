<html>
<head>
<title>TupleVariation.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #7a7e85;}
.s4 { color: #2aacb8;}
.s5 { color: #6aab73;}
.s6 { color: #5f826b; font-style: italic;}
.s7 { color: #a5c261;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
TupleVariation.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">fontTools</span><span class="s2">.</span><span class="s1">misc</span><span class="s2">.</span><span class="s1">fixedTools </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">fixedToFloat </span><span class="s0">as </span><span class="s1">fi2fl</span><span class="s2">,</span>
    <span class="s1">floatToFixed </span><span class="s0">as </span><span class="s1">fl2fi</span><span class="s2">,</span>
    <span class="s1">floatToFixedToStr </span><span class="s0">as </span><span class="s1">fl2str</span><span class="s2">,</span>
    <span class="s1">strToFixedToFloat </span><span class="s0">as </span><span class="s1">str2fl</span><span class="s2">,</span>
    <span class="s1">otRound</span><span class="s2">,</span>
<span class="s2">)</span>
<span class="s0">from </span><span class="s1">fontTools</span><span class="s2">.</span><span class="s1">misc</span><span class="s2">.</span><span class="s1">textTools </span><span class="s0">import </span><span class="s1">safeEval</span>
<span class="s0">import </span><span class="s1">array</span>
<span class="s0">from </span><span class="s1">collections </span><span class="s0">import </span><span class="s1">Counter</span><span class="s2">, </span><span class="s1">defaultdict</span>
<span class="s0">import </span><span class="s1">io</span>
<span class="s0">import </span><span class="s1">logging</span>
<span class="s0">import </span><span class="s1">struct</span>
<span class="s0">import </span><span class="s1">sys</span>


<span class="s3"># https://www.microsoft.com/typography/otspec/otvarcommonformats.htm</span>

<span class="s1">EMBEDDED_PEAK_TUPLE </span><span class="s2">= </span><span class="s4">0x8000</span>
<span class="s1">INTERMEDIATE_REGION </span><span class="s2">= </span><span class="s4">0x4000</span>
<span class="s1">PRIVATE_POINT_NUMBERS </span><span class="s2">= </span><span class="s4">0x2000</span>

<span class="s1">DELTAS_ARE_ZERO </span><span class="s2">= </span><span class="s4">0x80</span>
<span class="s1">DELTAS_ARE_WORDS </span><span class="s2">= </span><span class="s4">0x40</span>
<span class="s1">DELTAS_ARE_LONGS </span><span class="s2">= </span><span class="s4">0xC0</span>
<span class="s1">DELTAS_SIZE_MASK </span><span class="s2">= </span><span class="s4">0xC0</span>
<span class="s1">DELTA_RUN_COUNT_MASK </span><span class="s2">= </span><span class="s4">0x3F</span>

<span class="s1">POINTS_ARE_WORDS </span><span class="s2">= </span><span class="s4">0x80</span>
<span class="s1">POINT_RUN_COUNT_MASK </span><span class="s2">= </span><span class="s4">0x7F</span>

<span class="s1">TUPLES_SHARE_POINT_NUMBERS </span><span class="s2">= </span><span class="s4">0x8000</span>
<span class="s1">TUPLE_COUNT_MASK </span><span class="s2">= </span><span class="s4">0x0FFF</span>
<span class="s1">TUPLE_INDEX_MASK </span><span class="s2">= </span><span class="s4">0x0FFF</span>

<span class="s1">log </span><span class="s2">= </span><span class="s1">logging</span><span class="s2">.</span><span class="s1">getLogger</span><span class="s2">(</span><span class="s1">__name__</span><span class="s2">)</span>


<span class="s0">class </span><span class="s1">TupleVariation</span><span class="s2">(</span><span class="s1">object</span><span class="s2">):</span>
    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">axes</span><span class="s2">, </span><span class="s1">coordinates</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">axes </span><span class="s2">= </span><span class="s1">axes</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">coordinates </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">coordinates</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">__repr__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">axes </span><span class="s2">= </span><span class="s5">&quot;,&quot;</span><span class="s2">.</span><span class="s1">join</span><span class="s2">(</span>
            <span class="s1">sorted</span><span class="s2">([</span><span class="s5">&quot;%s=%s&quot; </span><span class="s2">% (</span><span class="s1">name</span><span class="s2">, </span><span class="s1">value</span><span class="s2">) </span><span class="s0">for </span><span class="s2">(</span><span class="s1">name</span><span class="s2">, </span><span class="s1">value</span><span class="s2">) </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">axes</span><span class="s2">.</span><span class="s1">items</span><span class="s2">()])</span>
        <span class="s2">)</span>
        <span class="s0">return </span><span class="s5">&quot;&lt;TupleVariation %s %s&gt;&quot; </span><span class="s2">% (</span><span class="s1">axes</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">coordinates</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">__eq__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">coordinates </span><span class="s2">== </span><span class="s1">other</span><span class="s2">.</span><span class="s1">coordinates </span><span class="s0">and </span><span class="s1">self</span><span class="s2">.</span><span class="s1">axes </span><span class="s2">== </span><span class="s1">other</span><span class="s2">.</span><span class="s1">axes</span>

    <span class="s0">def </span><span class="s1">getUsedPoints</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3"># Empty set means &quot;all points used&quot;.</span>
        <span class="s0">if None not in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">coordinates</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">frozenset</span><span class="s2">()</span>
        <span class="s1">used </span><span class="s2">= </span><span class="s1">frozenset</span><span class="s2">([</span><span class="s1">i </span><span class="s0">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">p </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">coordinates</span><span class="s2">) </span><span class="s0">if </span><span class="s1">p </span><span class="s0">is not None</span><span class="s2">])</span>
        <span class="s3"># Return None if no points used.</span>
        <span class="s0">return </span><span class="s1">used </span><span class="s0">if </span><span class="s1">used </span><span class="s0">else None</span>

    <span class="s0">def </span><span class="s1">hasImpact</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s6">&quot;&quot;&quot;Returns True if this TupleVariation has any visible impact. 
 
        If the result is False, the TupleVariation can be omitted from the font 
        without making any visible difference. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">any</span><span class="s2">(</span><span class="s1">c </span><span class="s0">is not None for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">coordinates</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">toXML</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">writer</span><span class="s2">, </span><span class="s1">axisTags</span><span class="s2">):</span>
        <span class="s1">writer</span><span class="s2">.</span><span class="s1">begintag</span><span class="s2">(</span><span class="s5">&quot;tuple&quot;</span><span class="s2">)</span>
        <span class="s1">writer</span><span class="s2">.</span><span class="s1">newline</span><span class="s2">()</span>
        <span class="s0">for </span><span class="s1">axis </span><span class="s0">in </span><span class="s1">axisTags</span><span class="s2">:</span>
            <span class="s1">value </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">axes</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">value </span><span class="s0">is not None</span><span class="s2">:</span>
                <span class="s1">minValue</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">maxValue </span><span class="s2">= </span><span class="s1">value</span>
                <span class="s1">defaultMinValue </span><span class="s2">= </span><span class="s1">min</span><span class="s2">(</span><span class="s1">value</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">)  </span><span class="s3"># -0.3 --&gt; -0.3; 0.7 --&gt; 0.0</span>
                <span class="s1">defaultMaxValue </span><span class="s2">= </span><span class="s1">max</span><span class="s2">(</span><span class="s1">value</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">)  </span><span class="s3"># -0.3 --&gt;  0.0; 0.7 --&gt; 0.7</span>
                <span class="s0">if </span><span class="s1">minValue </span><span class="s2">== </span><span class="s1">defaultMinValue </span><span class="s0">and </span><span class="s1">maxValue </span><span class="s2">== </span><span class="s1">defaultMaxValue</span><span class="s2">:</span>
                    <span class="s1">writer</span><span class="s2">.</span><span class="s1">simpletag</span><span class="s2">(</span><span class="s5">&quot;coord&quot;</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s1">axis</span><span class="s2">, </span><span class="s1">value</span><span class="s2">=</span><span class="s1">fl2str</span><span class="s2">(</span><span class="s1">value</span><span class="s2">, </span><span class="s4">14</span><span class="s2">))</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s1">attrs </span><span class="s2">= [</span>
                        <span class="s2">(</span><span class="s5">&quot;axis&quot;</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">),</span>
                        <span class="s2">(</span><span class="s5">&quot;min&quot;</span><span class="s2">, </span><span class="s1">fl2str</span><span class="s2">(</span><span class="s1">minValue</span><span class="s2">, </span><span class="s4">14</span><span class="s2">)),</span>
                        <span class="s2">(</span><span class="s5">&quot;value&quot;</span><span class="s2">, </span><span class="s1">fl2str</span><span class="s2">(</span><span class="s1">value</span><span class="s2">, </span><span class="s4">14</span><span class="s2">)),</span>
                        <span class="s2">(</span><span class="s5">&quot;max&quot;</span><span class="s2">, </span><span class="s1">fl2str</span><span class="s2">(</span><span class="s1">maxValue</span><span class="s2">, </span><span class="s4">14</span><span class="s2">)),</span>
                    <span class="s2">]</span>
                    <span class="s1">writer</span><span class="s2">.</span><span class="s1">simpletag</span><span class="s2">(</span><span class="s5">&quot;coord&quot;</span><span class="s2">, </span><span class="s1">attrs</span><span class="s2">)</span>
                <span class="s1">writer</span><span class="s2">.</span><span class="s1">newline</span><span class="s2">()</span>
        <span class="s1">wrote_any_deltas </span><span class="s2">= </span><span class="s0">False</span>
        <span class="s0">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">delta </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">coordinates</span><span class="s2">):</span>
            <span class="s0">if </span><span class="s1">type</span><span class="s2">(</span><span class="s1">delta</span><span class="s2">) == </span><span class="s1">tuple </span><span class="s0">and </span><span class="s1">len</span><span class="s2">(</span><span class="s1">delta</span><span class="s2">) == </span><span class="s4">2</span><span class="s2">:</span>
                <span class="s1">writer</span><span class="s2">.</span><span class="s1">simpletag</span><span class="s2">(</span><span class="s5">&quot;delta&quot;</span><span class="s2">, </span><span class="s1">pt</span><span class="s2">=</span><span class="s1">i</span><span class="s2">, </span><span class="s1">x</span><span class="s2">=</span><span class="s1">delta</span><span class="s2">[</span><span class="s4">0</span><span class="s2">], </span><span class="s1">y</span><span class="s2">=</span><span class="s1">delta</span><span class="s2">[</span><span class="s4">1</span><span class="s2">])</span>
                <span class="s1">writer</span><span class="s2">.</span><span class="s1">newline</span><span class="s2">()</span>
                <span class="s1">wrote_any_deltas </span><span class="s2">= </span><span class="s0">True</span>
            <span class="s0">elif </span><span class="s1">type</span><span class="s2">(</span><span class="s1">delta</span><span class="s2">) == </span><span class="s1">int</span><span class="s2">:</span>
                <span class="s1">writer</span><span class="s2">.</span><span class="s1">simpletag</span><span class="s2">(</span><span class="s5">&quot;delta&quot;</span><span class="s2">, </span><span class="s1">cvt</span><span class="s2">=</span><span class="s1">i</span><span class="s2">, </span><span class="s1">value</span><span class="s2">=</span><span class="s1">delta</span><span class="s2">)</span>
                <span class="s1">writer</span><span class="s2">.</span><span class="s1">newline</span><span class="s2">()</span>
                <span class="s1">wrote_any_deltas </span><span class="s2">= </span><span class="s0">True</span>
            <span class="s0">elif </span><span class="s1">delta </span><span class="s0">is not None</span><span class="s2">:</span>
                <span class="s1">log</span><span class="s2">.</span><span class="s1">error</span><span class="s2">(</span><span class="s5">&quot;bad delta format&quot;</span><span class="s2">)</span>
                <span class="s1">writer</span><span class="s2">.</span><span class="s1">comment</span><span class="s2">(</span><span class="s5">&quot;bad delta #%d&quot; </span><span class="s2">% </span><span class="s1">i</span><span class="s2">)</span>
                <span class="s1">writer</span><span class="s2">.</span><span class="s1">newline</span><span class="s2">()</span>
                <span class="s1">wrote_any_deltas </span><span class="s2">= </span><span class="s0">True</span>
        <span class="s0">if not </span><span class="s1">wrote_any_deltas</span><span class="s2">:</span>
            <span class="s1">writer</span><span class="s2">.</span><span class="s1">comment</span><span class="s2">(</span><span class="s5">&quot;no deltas&quot;</span><span class="s2">)</span>
            <span class="s1">writer</span><span class="s2">.</span><span class="s1">newline</span><span class="s2">()</span>
        <span class="s1">writer</span><span class="s2">.</span><span class="s1">endtag</span><span class="s2">(</span><span class="s5">&quot;tuple&quot;</span><span class="s2">)</span>
        <span class="s1">writer</span><span class="s2">.</span><span class="s1">newline</span><span class="s2">()</span>

    <span class="s0">def </span><span class="s1">fromXML</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">attrs</span><span class="s2">, </span><span class="s1">_content</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">name </span><span class="s2">== </span><span class="s5">&quot;coord&quot;</span><span class="s2">:</span>
            <span class="s1">axis </span><span class="s2">= </span><span class="s1">attrs</span><span class="s2">[</span><span class="s5">&quot;axis&quot;</span><span class="s2">]</span>
            <span class="s1">value </span><span class="s2">= </span><span class="s1">str2fl</span><span class="s2">(</span><span class="s1">attrs</span><span class="s2">[</span><span class="s5">&quot;value&quot;</span><span class="s2">], </span><span class="s4">14</span><span class="s2">)</span>
            <span class="s1">defaultMinValue </span><span class="s2">= </span><span class="s1">min</span><span class="s2">(</span><span class="s1">value</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">)  </span><span class="s3"># -0.3 --&gt; -0.3; 0.7 --&gt; 0.0</span>
            <span class="s1">defaultMaxValue </span><span class="s2">= </span><span class="s1">max</span><span class="s2">(</span><span class="s1">value</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">)  </span><span class="s3"># -0.3 --&gt;  0.0; 0.7 --&gt; 0.7</span>
            <span class="s1">minValue </span><span class="s2">= </span><span class="s1">str2fl</span><span class="s2">(</span><span class="s1">attrs</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s5">&quot;min&quot;</span><span class="s2">, </span><span class="s1">defaultMinValue</span><span class="s2">), </span><span class="s4">14</span><span class="s2">)</span>
            <span class="s1">maxValue </span><span class="s2">= </span><span class="s1">str2fl</span><span class="s2">(</span><span class="s1">attrs</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s5">&quot;max&quot;</span><span class="s2">, </span><span class="s1">defaultMaxValue</span><span class="s2">), </span><span class="s4">14</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">axes</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">] = (</span><span class="s1">minValue</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">maxValue</span><span class="s2">)</span>
        <span class="s0">elif </span><span class="s1">name </span><span class="s2">== </span><span class="s5">&quot;delta&quot;</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s5">&quot;pt&quot; </span><span class="s0">in </span><span class="s1">attrs</span><span class="s2">:</span>
                <span class="s1">point </span><span class="s2">= </span><span class="s1">safeEval</span><span class="s2">(</span><span class="s1">attrs</span><span class="s2">[</span><span class="s5">&quot;pt&quot;</span><span class="s2">])</span>
                <span class="s1">x </span><span class="s2">= </span><span class="s1">safeEval</span><span class="s2">(</span><span class="s1">attrs</span><span class="s2">[</span><span class="s5">&quot;x&quot;</span><span class="s2">])</span>
                <span class="s1">y </span><span class="s2">= </span><span class="s1">safeEval</span><span class="s2">(</span><span class="s1">attrs</span><span class="s2">[</span><span class="s5">&quot;y&quot;</span><span class="s2">])</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">coordinates</span><span class="s2">[</span><span class="s1">point</span><span class="s2">] = (</span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">)</span>
            <span class="s0">elif </span><span class="s5">&quot;cvt&quot; </span><span class="s0">in </span><span class="s1">attrs</span><span class="s2">:</span>
                <span class="s1">cvt </span><span class="s2">= </span><span class="s1">safeEval</span><span class="s2">(</span><span class="s1">attrs</span><span class="s2">[</span><span class="s5">&quot;cvt&quot;</span><span class="s2">])</span>
                <span class="s1">value </span><span class="s2">= </span><span class="s1">safeEval</span><span class="s2">(</span><span class="s1">attrs</span><span class="s2">[</span><span class="s5">&quot;value&quot;</span><span class="s2">])</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">coordinates</span><span class="s2">[</span><span class="s1">cvt</span><span class="s2">] = </span><span class="s1">value</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">log</span><span class="s2">.</span><span class="s1">warning</span><span class="s2">(</span><span class="s5">&quot;bad delta format: %s&quot; </span><span class="s2">% </span><span class="s5">&quot;, &quot;</span><span class="s2">.</span><span class="s1">join</span><span class="s2">(</span><span class="s1">sorted</span><span class="s2">(</span><span class="s1">attrs</span><span class="s2">.</span><span class="s1">keys</span><span class="s2">())))</span>

    <span class="s0">def </span><span class="s1">compile</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">axisTags</span><span class="s2">, </span><span class="s1">sharedCoordIndices</span><span class="s2">={}, </span><span class="s1">pointData</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
        <span class="s0">assert </span><span class="s1">set</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">axes</span><span class="s2">.</span><span class="s1">keys</span><span class="s2">()) &lt;= </span><span class="s1">set</span><span class="s2">(</span><span class="s1">axisTags</span><span class="s2">), (</span>
            <span class="s5">&quot;Unknown axis tag found.&quot;</span><span class="s2">,</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">axes</span><span class="s2">.</span><span class="s1">keys</span><span class="s2">(),</span>
            <span class="s1">axisTags</span><span class="s2">,</span>
        <span class="s2">)</span>

        <span class="s1">tupleData </span><span class="s2">= []</span>
        <span class="s1">auxData </span><span class="s2">= []</span>

        <span class="s0">if </span><span class="s1">pointData </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s1">usedPoints </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">getUsedPoints</span><span class="s2">()</span>
            <span class="s0">if </span><span class="s1">usedPoints </span><span class="s0">is None</span><span class="s2">:  </span><span class="s3"># Nothing to encode</span>
                <span class="s0">return </span><span class="s7">b&quot;&quot;</span><span class="s2">, </span><span class="s7">b&quot;&quot;</span>
            <span class="s1">pointData </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">compilePoints</span><span class="s2">(</span><span class="s1">usedPoints</span><span class="s2">)</span>

        <span class="s1">coord </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">compileCoord</span><span class="s2">(</span><span class="s1">axisTags</span><span class="s2">)</span>
        <span class="s1">flags </span><span class="s2">= </span><span class="s1">sharedCoordIndices</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">coord</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">flags </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s1">flags </span><span class="s2">= </span><span class="s1">EMBEDDED_PEAK_TUPLE</span>
            <span class="s1">tupleData</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">coord</span><span class="s2">)</span>

        <span class="s1">intermediateCoord </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">compileIntermediateCoord</span><span class="s2">(</span><span class="s1">axisTags</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">intermediateCoord </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s1">flags </span><span class="s2">|= </span><span class="s1">INTERMEDIATE_REGION</span>
            <span class="s1">tupleData</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">intermediateCoord</span><span class="s2">)</span>

        <span class="s3"># pointData of b'' implies &quot;use shared points&quot;.</span>
        <span class="s0">if </span><span class="s1">pointData</span><span class="s2">:</span>
            <span class="s1">flags </span><span class="s2">|= </span><span class="s1">PRIVATE_POINT_NUMBERS</span>
            <span class="s1">auxData</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">pointData</span><span class="s2">)</span>

        <span class="s1">auxData</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">compileDeltas</span><span class="s2">())</span>
        <span class="s1">auxData </span><span class="s2">= </span><span class="s7">b&quot;&quot;</span><span class="s2">.</span><span class="s1">join</span><span class="s2">(</span><span class="s1">auxData</span><span class="s2">)</span>

        <span class="s1">tupleData</span><span class="s2">.</span><span class="s1">insert</span><span class="s2">(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">struct</span><span class="s2">.</span><span class="s1">pack</span><span class="s2">(</span><span class="s5">&quot;&gt;HH&quot;</span><span class="s2">, </span><span class="s1">len</span><span class="s2">(</span><span class="s1">auxData</span><span class="s2">), </span><span class="s1">flags</span><span class="s2">))</span>
        <span class="s0">return </span><span class="s7">b&quot;&quot;</span><span class="s2">.</span><span class="s1">join</span><span class="s2">(</span><span class="s1">tupleData</span><span class="s2">), </span><span class="s1">auxData</span>

    <span class="s0">def </span><span class="s1">compileCoord</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">axisTags</span><span class="s2">):</span>
        <span class="s1">result </span><span class="s2">= []</span>
        <span class="s1">axes </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">axes</span>
        <span class="s0">for </span><span class="s1">axis </span><span class="s0">in </span><span class="s1">axisTags</span><span class="s2">:</span>
            <span class="s1">triple </span><span class="s2">= </span><span class="s1">axes</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">triple </span><span class="s0">is None</span><span class="s2">:</span>
                <span class="s1">result</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s7">b&quot;</span><span class="s0">\0\0</span><span class="s7">&quot;</span><span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">result</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">struct</span><span class="s2">.</span><span class="s1">pack</span><span class="s2">(</span><span class="s5">&quot;&gt;h&quot;</span><span class="s2">, </span><span class="s1">fl2fi</span><span class="s2">(</span><span class="s1">triple</span><span class="s2">[</span><span class="s4">1</span><span class="s2">], </span><span class="s4">14</span><span class="s2">)))</span>
        <span class="s0">return </span><span class="s7">b&quot;&quot;</span><span class="s2">.</span><span class="s1">join</span><span class="s2">(</span><span class="s1">result</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">compileIntermediateCoord</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">axisTags</span><span class="s2">):</span>
        <span class="s1">needed </span><span class="s2">= </span><span class="s0">False</span>
        <span class="s0">for </span><span class="s1">axis </span><span class="s0">in </span><span class="s1">axisTags</span><span class="s2">:</span>
            <span class="s1">minValue</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">maxValue </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">axes</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">, (</span><span class="s4">0.0</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">))</span>
            <span class="s1">defaultMinValue </span><span class="s2">= </span><span class="s1">min</span><span class="s2">(</span><span class="s1">value</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">)  </span><span class="s3"># -0.3 --&gt; -0.3; 0.7 --&gt; 0.0</span>
            <span class="s1">defaultMaxValue </span><span class="s2">= </span><span class="s1">max</span><span class="s2">(</span><span class="s1">value</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">)  </span><span class="s3"># -0.3 --&gt;  0.0; 0.7 --&gt; 0.7</span>
            <span class="s0">if </span><span class="s2">(</span><span class="s1">minValue </span><span class="s2">!= </span><span class="s1">defaultMinValue</span><span class="s2">) </span><span class="s0">or </span><span class="s2">(</span><span class="s1">maxValue </span><span class="s2">!= </span><span class="s1">defaultMaxValue</span><span class="s2">):</span>
                <span class="s1">needed </span><span class="s2">= </span><span class="s0">True</span>
                <span class="s0">break</span>
        <span class="s0">if not </span><span class="s1">needed</span><span class="s2">:</span>
            <span class="s0">return None</span>
        <span class="s1">minCoords </span><span class="s2">= []</span>
        <span class="s1">maxCoords </span><span class="s2">= []</span>
        <span class="s0">for </span><span class="s1">axis </span><span class="s0">in </span><span class="s1">axisTags</span><span class="s2">:</span>
            <span class="s1">minValue</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">maxValue </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">axes</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">, (</span><span class="s4">0.0</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">))</span>
            <span class="s1">minCoords</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">struct</span><span class="s2">.</span><span class="s1">pack</span><span class="s2">(</span><span class="s5">&quot;&gt;h&quot;</span><span class="s2">, </span><span class="s1">fl2fi</span><span class="s2">(</span><span class="s1">minValue</span><span class="s2">, </span><span class="s4">14</span><span class="s2">)))</span>
            <span class="s1">maxCoords</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">struct</span><span class="s2">.</span><span class="s1">pack</span><span class="s2">(</span><span class="s5">&quot;&gt;h&quot;</span><span class="s2">, </span><span class="s1">fl2fi</span><span class="s2">(</span><span class="s1">maxValue</span><span class="s2">, </span><span class="s4">14</span><span class="s2">)))</span>
        <span class="s0">return </span><span class="s7">b&quot;&quot;</span><span class="s2">.</span><span class="s1">join</span><span class="s2">(</span><span class="s1">minCoords </span><span class="s2">+ </span><span class="s1">maxCoords</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">staticmethod</span>
    <span class="s0">def </span><span class="s1">decompileCoord_</span><span class="s2">(</span><span class="s1">axisTags</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">offset</span><span class="s2">):</span>
        <span class="s1">coord </span><span class="s2">= {}</span>
        <span class="s1">pos </span><span class="s2">= </span><span class="s1">offset</span>
        <span class="s0">for </span><span class="s1">axis </span><span class="s0">in </span><span class="s1">axisTags</span><span class="s2">:</span>
            <span class="s1">coord</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">] = </span><span class="s1">fi2fl</span><span class="s2">(</span><span class="s1">struct</span><span class="s2">.</span><span class="s1">unpack</span><span class="s2">(</span><span class="s5">&quot;&gt;h&quot;</span><span class="s2">, </span><span class="s1">data</span><span class="s2">[</span><span class="s1">pos </span><span class="s2">: </span><span class="s1">pos </span><span class="s2">+ </span><span class="s4">2</span><span class="s2">])[</span><span class="s4">0</span><span class="s2">], </span><span class="s4">14</span><span class="s2">)</span>
            <span class="s1">pos </span><span class="s2">+= </span><span class="s4">2</span>
        <span class="s0">return </span><span class="s1">coord</span><span class="s2">, </span><span class="s1">pos</span>

    <span class="s2">@</span><span class="s1">staticmethod</span>
    <span class="s0">def </span><span class="s1">compilePoints</span><span class="s2">(</span><span class="s1">points</span><span class="s2">):</span>
        <span class="s3"># If the set consists of all points in the glyph, it gets encoded with</span>
        <span class="s3"># a special encoding: a single zero byte.</span>
        <span class="s3">#</span>
        <span class="s3"># To use this optimization, points passed in must be empty set.</span>
        <span class="s3"># The following two lines are not strictly necessary as the main code</span>
        <span class="s3"># below would emit the same. But this is most common and faster.</span>
        <span class="s0">if not </span><span class="s1">points</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s7">b&quot;</span><span class="s0">\0</span><span class="s7">&quot;</span>

        <span class="s3"># In the 'gvar' table, the packing of point numbers is a little surprising.</span>
        <span class="s3"># It consists of multiple runs, each being a delta-encoded list of integers.</span>
        <span class="s3"># For example, the point set {17, 18, 19, 20, 21, 22, 23} gets encoded as</span>
        <span class="s3"># [6, 17, 1, 1, 1, 1, 1, 1]. The first value (6) is the run length minus 1.</span>
        <span class="s3"># There are two types of runs, with values being either 8 or 16 bit unsigned</span>
        <span class="s3"># integers.</span>
        <span class="s1">points </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">points</span><span class="s2">)</span>
        <span class="s1">points</span><span class="s2">.</span><span class="s1">sort</span><span class="s2">()</span>
        <span class="s1">numPoints </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">points</span><span class="s2">)</span>

        <span class="s1">result </span><span class="s2">= </span><span class="s1">bytearray</span><span class="s2">()</span>
        <span class="s3"># The binary representation starts with the total number of points in the set,</span>
        <span class="s3"># encoded into one or two bytes depending on the value.</span>
        <span class="s0">if </span><span class="s1">numPoints </span><span class="s2">&lt; </span><span class="s4">0x80</span><span class="s2">:</span>
            <span class="s1">result</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">numPoints</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">result</span><span class="s2">.</span><span class="s1">append</span><span class="s2">((</span><span class="s1">numPoints </span><span class="s2">&gt;&gt; </span><span class="s4">8</span><span class="s2">) | </span><span class="s4">0x80</span><span class="s2">)</span>
            <span class="s1">result</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">numPoints </span><span class="s2">&amp; </span><span class="s4">0xFF</span><span class="s2">)</span>

        <span class="s1">MAX_RUN_LENGTH </span><span class="s2">= </span><span class="s4">127</span>
        <span class="s1">pos </span><span class="s2">= </span><span class="s4">0</span>
        <span class="s1">lastValue </span><span class="s2">= </span><span class="s4">0</span>
        <span class="s0">while </span><span class="s1">pos </span><span class="s2">&lt; </span><span class="s1">numPoints</span><span class="s2">:</span>
            <span class="s1">runLength </span><span class="s2">= </span><span class="s4">0</span>

            <span class="s1">headerPos </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">result</span><span class="s2">)</span>
            <span class="s1">result</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s4">0</span><span class="s2">)</span>

            <span class="s1">useByteEncoding </span><span class="s2">= </span><span class="s0">None</span>
            <span class="s0">while </span><span class="s1">pos </span><span class="s2">&lt; </span><span class="s1">numPoints </span><span class="s0">and </span><span class="s1">runLength </span><span class="s2">&lt;= </span><span class="s1">MAX_RUN_LENGTH</span><span class="s2">:</span>
                <span class="s1">curValue </span><span class="s2">= </span><span class="s1">points</span><span class="s2">[</span><span class="s1">pos</span><span class="s2">]</span>
                <span class="s1">delta </span><span class="s2">= </span><span class="s1">curValue </span><span class="s2">- </span><span class="s1">lastValue</span>
                <span class="s0">if </span><span class="s1">useByteEncoding </span><span class="s0">is None</span><span class="s2">:</span>
                    <span class="s1">useByteEncoding </span><span class="s2">= </span><span class="s4">0 </span><span class="s2">&lt;= </span><span class="s1">delta </span><span class="s2">&lt;= </span><span class="s4">0xFF</span>
                <span class="s0">if </span><span class="s1">useByteEncoding </span><span class="s0">and </span><span class="s2">(</span><span class="s1">delta </span><span class="s2">&gt; </span><span class="s4">0xFF </span><span class="s0">or </span><span class="s1">delta </span><span class="s2">&lt; </span><span class="s4">0</span><span class="s2">):</span>
                    <span class="s3"># we need to start a new run (which will not use byte encoding)</span>
                    <span class="s0">break</span>
                <span class="s3"># TODO This never switches back to a byte-encoding from a short-encoding.</span>
                <span class="s3"># That's suboptimal.</span>
                <span class="s0">if </span><span class="s1">useByteEncoding</span><span class="s2">:</span>
                    <span class="s1">result</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">delta</span><span class="s2">)</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s1">result</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">delta </span><span class="s2">&gt;&gt; </span><span class="s4">8</span><span class="s2">)</span>
                    <span class="s1">result</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">delta </span><span class="s2">&amp; </span><span class="s4">0xFF</span><span class="s2">)</span>
                <span class="s1">lastValue </span><span class="s2">= </span><span class="s1">curValue</span>
                <span class="s1">pos </span><span class="s2">+= </span><span class="s4">1</span>
                <span class="s1">runLength </span><span class="s2">+= </span><span class="s4">1</span>
            <span class="s0">if </span><span class="s1">useByteEncoding</span><span class="s2">:</span>
                <span class="s1">result</span><span class="s2">[</span><span class="s1">headerPos</span><span class="s2">] = </span><span class="s1">runLength </span><span class="s2">- </span><span class="s4">1</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">result</span><span class="s2">[</span><span class="s1">headerPos</span><span class="s2">] = (</span><span class="s1">runLength </span><span class="s2">- </span><span class="s4">1</span><span class="s2">) | </span><span class="s1">POINTS_ARE_WORDS</span>

        <span class="s0">return </span><span class="s1">result</span>

    <span class="s2">@</span><span class="s1">staticmethod</span>
    <span class="s0">def </span><span class="s1">decompilePoints_</span><span class="s2">(</span><span class="s1">numPoints</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">offset</span><span class="s2">, </span><span class="s1">tableTag</span><span class="s2">):</span>
        <span class="s6">&quot;&quot;&quot;(numPoints, data, offset, tableTag) --&gt; ([point1, point2, ...], newOffset)&quot;&quot;&quot;</span>
        <span class="s0">assert </span><span class="s1">tableTag </span><span class="s0">in </span><span class="s2">(</span><span class="s5">&quot;cvar&quot;</span><span class="s2">, </span><span class="s5">&quot;gvar&quot;</span><span class="s2">)</span>
        <span class="s1">pos </span><span class="s2">= </span><span class="s1">offset</span>
        <span class="s1">numPointsInData </span><span class="s2">= </span><span class="s1">data</span><span class="s2">[</span><span class="s1">pos</span><span class="s2">]</span>
        <span class="s1">pos </span><span class="s2">+= </span><span class="s4">1</span>
        <span class="s0">if </span><span class="s2">(</span><span class="s1">numPointsInData </span><span class="s2">&amp; </span><span class="s1">POINTS_ARE_WORDS</span><span class="s2">) != </span><span class="s4">0</span><span class="s2">:</span>
            <span class="s1">numPointsInData </span><span class="s2">= (</span><span class="s1">numPointsInData </span><span class="s2">&amp; </span><span class="s1">POINT_RUN_COUNT_MASK</span><span class="s2">) &lt;&lt; </span><span class="s4">8 </span><span class="s2">| </span><span class="s1">data</span><span class="s2">[</span><span class="s1">pos</span><span class="s2">]</span>
            <span class="s1">pos </span><span class="s2">+= </span><span class="s4">1</span>
        <span class="s0">if </span><span class="s1">numPointsInData </span><span class="s2">== </span><span class="s4">0</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s2">(</span><span class="s1">range</span><span class="s2">(</span><span class="s1">numPoints</span><span class="s2">), </span><span class="s1">pos</span><span class="s2">)</span>

        <span class="s1">result </span><span class="s2">= []</span>
        <span class="s0">while </span><span class="s1">len</span><span class="s2">(</span><span class="s1">result</span><span class="s2">) &lt; </span><span class="s1">numPointsInData</span><span class="s2">:</span>
            <span class="s1">runHeader </span><span class="s2">= </span><span class="s1">data</span><span class="s2">[</span><span class="s1">pos</span><span class="s2">]</span>
            <span class="s1">pos </span><span class="s2">+= </span><span class="s4">1</span>
            <span class="s1">numPointsInRun </span><span class="s2">= (</span><span class="s1">runHeader </span><span class="s2">&amp; </span><span class="s1">POINT_RUN_COUNT_MASK</span><span class="s2">) + </span><span class="s4">1</span>
            <span class="s1">point </span><span class="s2">= </span><span class="s4">0</span>
            <span class="s0">if </span><span class="s2">(</span><span class="s1">runHeader </span><span class="s2">&amp; </span><span class="s1">POINTS_ARE_WORDS</span><span class="s2">) != </span><span class="s4">0</span><span class="s2">:</span>
                <span class="s1">points </span><span class="s2">= </span><span class="s1">array</span><span class="s2">.</span><span class="s1">array</span><span class="s2">(</span><span class="s5">&quot;H&quot;</span><span class="s2">)</span>
                <span class="s1">pointsSize </span><span class="s2">= </span><span class="s1">numPointsInRun </span><span class="s2">* </span><span class="s4">2</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">points </span><span class="s2">= </span><span class="s1">array</span><span class="s2">.</span><span class="s1">array</span><span class="s2">(</span><span class="s5">&quot;B&quot;</span><span class="s2">)</span>
                <span class="s1">pointsSize </span><span class="s2">= </span><span class="s1">numPointsInRun</span>
            <span class="s1">points</span><span class="s2">.</span><span class="s1">frombytes</span><span class="s2">(</span><span class="s1">data</span><span class="s2">[</span><span class="s1">pos </span><span class="s2">: </span><span class="s1">pos </span><span class="s2">+ </span><span class="s1">pointsSize</span><span class="s2">])</span>
            <span class="s0">if </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">byteorder </span><span class="s2">!= </span><span class="s5">&quot;big&quot;</span><span class="s2">:</span>
                <span class="s1">points</span><span class="s2">.</span><span class="s1">byteswap</span><span class="s2">()</span>

            <span class="s0">assert </span><span class="s1">len</span><span class="s2">(</span><span class="s1">points</span><span class="s2">) == </span><span class="s1">numPointsInRun</span>
            <span class="s1">pos </span><span class="s2">+= </span><span class="s1">pointsSize</span>

            <span class="s1">result</span><span class="s2">.</span><span class="s1">extend</span><span class="s2">(</span><span class="s1">points</span><span class="s2">)</span>

        <span class="s3"># Convert relative to absolute</span>
        <span class="s1">absolute </span><span class="s2">= []</span>
        <span class="s1">current </span><span class="s2">= </span><span class="s4">0</span>
        <span class="s0">for </span><span class="s1">delta </span><span class="s0">in </span><span class="s1">result</span><span class="s2">:</span>
            <span class="s1">current </span><span class="s2">+= </span><span class="s1">delta</span>
            <span class="s1">absolute</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">current</span><span class="s2">)</span>
        <span class="s1">result </span><span class="s2">= </span><span class="s1">absolute</span>
        <span class="s0">del </span><span class="s1">absolute</span>

        <span class="s1">badPoints </span><span class="s2">= {</span><span class="s1">str</span><span class="s2">(</span><span class="s1">p</span><span class="s2">) </span><span class="s0">for </span><span class="s1">p </span><span class="s0">in </span><span class="s1">result </span><span class="s0">if </span><span class="s1">p </span><span class="s2">&lt; </span><span class="s4">0 </span><span class="s0">or </span><span class="s1">p </span><span class="s2">&gt;= </span><span class="s1">numPoints</span><span class="s2">}</span>
        <span class="s0">if </span><span class="s1">badPoints</span><span class="s2">:</span>
            <span class="s1">log</span><span class="s2">.</span><span class="s1">warning</span><span class="s2">(</span>
                <span class="s5">&quot;point %s out of range in '%s' table&quot;</span>
                <span class="s2">% (</span><span class="s5">&quot;,&quot;</span><span class="s2">.</span><span class="s1">join</span><span class="s2">(</span><span class="s1">sorted</span><span class="s2">(</span><span class="s1">badPoints</span><span class="s2">)), </span><span class="s1">tableTag</span><span class="s2">)</span>
            <span class="s2">)</span>
        <span class="s0">return </span><span class="s2">(</span><span class="s1">result</span><span class="s2">, </span><span class="s1">pos</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">compileDeltas</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">deltaX </span><span class="s2">= []</span>
        <span class="s1">deltaY </span><span class="s2">= []</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">getCoordWidth</span><span class="s2">() == </span><span class="s4">2</span><span class="s2">:</span>
            <span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">coordinates</span><span class="s2">:</span>
                <span class="s0">if </span><span class="s1">c </span><span class="s0">is None</span><span class="s2">:</span>
                    <span class="s0">continue</span>
                <span class="s1">deltaX</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">c</span><span class="s2">[</span><span class="s4">0</span><span class="s2">])</span>
                <span class="s1">deltaY</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">c</span><span class="s2">[</span><span class="s4">1</span><span class="s2">])</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">coordinates</span><span class="s2">:</span>
                <span class="s0">if </span><span class="s1">c </span><span class="s0">is None</span><span class="s2">:</span>
                    <span class="s0">continue</span>
                <span class="s1">deltaX</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">c</span><span class="s2">)</span>
        <span class="s1">bytearr </span><span class="s2">= </span><span class="s1">bytearray</span><span class="s2">()</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">compileDeltaValues_</span><span class="s2">(</span><span class="s1">deltaX</span><span class="s2">, </span><span class="s1">bytearr</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">compileDeltaValues_</span><span class="s2">(</span><span class="s1">deltaY</span><span class="s2">, </span><span class="s1">bytearr</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">bytearr</span>

    <span class="s2">@</span><span class="s1">staticmethod</span>
    <span class="s0">def </span><span class="s1">compileDeltaValues_</span><span class="s2">(</span><span class="s1">deltas</span><span class="s2">, </span><span class="s1">bytearr</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
        <span class="s5">&quot;&quot;&quot;[value1, value2, value3, ...] --&gt; bytearray 
 
        Emits a sequence of runs. Each run starts with a 
        byte-sized header whose 6 least significant bits 
        (header &amp; 0x3F) indicate how many values are encoded 
        in this run. The stored length is the actual length 
        minus one; run lengths are thus in the range [1..64]. 
        If the header byte has its most significant bit (0x80) 
        set, all values in this run are zero, and no data 
        follows. Otherwise, the header byte is followed by 
        ((header &amp; 0x3F) + 1) signed values.  If (header &amp; 
        0x40) is clear, the delta values are stored as signed 
        bytes; if (header &amp; 0x40) is set, the delta values are 
        signed 16-bit integers. 
        &quot;&quot;&quot;  </span><span class="s3"># Explaining the format because the 'gvar' spec is hard to understand.</span>
        <span class="s0">if </span><span class="s1">bytearr </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s1">bytearr </span><span class="s2">= </span><span class="s1">bytearray</span><span class="s2">()</span>
        <span class="s1">pos </span><span class="s2">= </span><span class="s4">0</span>
        <span class="s1">numDeltas </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">deltas</span><span class="s2">)</span>
        <span class="s0">while </span><span class="s1">pos </span><span class="s2">&lt; </span><span class="s1">numDeltas</span><span class="s2">:</span>
            <span class="s1">value </span><span class="s2">= </span><span class="s1">deltas</span><span class="s2">[</span><span class="s1">pos</span><span class="s2">]</span>
            <span class="s0">if </span><span class="s1">value </span><span class="s2">== </span><span class="s4">0</span><span class="s2">:</span>
                <span class="s1">pos </span><span class="s2">= </span><span class="s1">TupleVariation</span><span class="s2">.</span><span class="s1">encodeDeltaRunAsZeroes_</span><span class="s2">(</span><span class="s1">deltas</span><span class="s2">, </span><span class="s1">pos</span><span class="s2">, </span><span class="s1">bytearr</span><span class="s2">)</span>
            <span class="s0">elif </span><span class="s2">-</span><span class="s4">128 </span><span class="s2">&lt;= </span><span class="s1">value </span><span class="s2">&lt;= </span><span class="s4">127</span><span class="s2">:</span>
                <span class="s1">pos </span><span class="s2">= </span><span class="s1">TupleVariation</span><span class="s2">.</span><span class="s1">encodeDeltaRunAsBytes_</span><span class="s2">(</span><span class="s1">deltas</span><span class="s2">, </span><span class="s1">pos</span><span class="s2">, </span><span class="s1">bytearr</span><span class="s2">)</span>
            <span class="s0">elif </span><span class="s2">-</span><span class="s4">32768 </span><span class="s2">&lt;= </span><span class="s1">value </span><span class="s2">&lt;= </span><span class="s4">32767</span><span class="s2">:</span>
                <span class="s1">pos </span><span class="s2">= </span><span class="s1">TupleVariation</span><span class="s2">.</span><span class="s1">encodeDeltaRunAsWords_</span><span class="s2">(</span><span class="s1">deltas</span><span class="s2">, </span><span class="s1">pos</span><span class="s2">, </span><span class="s1">bytearr</span><span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">pos </span><span class="s2">= </span><span class="s1">TupleVariation</span><span class="s2">.</span><span class="s1">encodeDeltaRunAsLongs_</span><span class="s2">(</span><span class="s1">deltas</span><span class="s2">, </span><span class="s1">pos</span><span class="s2">, </span><span class="s1">bytearr</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">bytearr</span>

    <span class="s2">@</span><span class="s1">staticmethod</span>
    <span class="s0">def </span><span class="s1">encodeDeltaRunAsZeroes_</span><span class="s2">(</span><span class="s1">deltas</span><span class="s2">, </span><span class="s1">offset</span><span class="s2">, </span><span class="s1">bytearr</span><span class="s2">):</span>
        <span class="s1">pos </span><span class="s2">= </span><span class="s1">offset</span>
        <span class="s1">numDeltas </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">deltas</span><span class="s2">)</span>
        <span class="s0">while </span><span class="s1">pos </span><span class="s2">&lt; </span><span class="s1">numDeltas </span><span class="s0">and </span><span class="s1">deltas</span><span class="s2">[</span><span class="s1">pos</span><span class="s2">] == </span><span class="s4">0</span><span class="s2">:</span>
            <span class="s1">pos </span><span class="s2">+= </span><span class="s4">1</span>
        <span class="s1">runLength </span><span class="s2">= </span><span class="s1">pos </span><span class="s2">- </span><span class="s1">offset</span>
        <span class="s0">while </span><span class="s1">runLength </span><span class="s2">&gt;= </span><span class="s4">64</span><span class="s2">:</span>
            <span class="s1">bytearr</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">DELTAS_ARE_ZERO </span><span class="s2">| </span><span class="s4">63</span><span class="s2">)</span>
            <span class="s1">runLength </span><span class="s2">-= </span><span class="s4">64</span>
        <span class="s0">if </span><span class="s1">runLength</span><span class="s2">:</span>
            <span class="s1">bytearr</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">DELTAS_ARE_ZERO </span><span class="s2">| (</span><span class="s1">runLength </span><span class="s2">- </span><span class="s4">1</span><span class="s2">))</span>
        <span class="s0">return </span><span class="s1">pos</span>

    <span class="s2">@</span><span class="s1">staticmethod</span>
    <span class="s0">def </span><span class="s1">encodeDeltaRunAsBytes_</span><span class="s2">(</span><span class="s1">deltas</span><span class="s2">, </span><span class="s1">offset</span><span class="s2">, </span><span class="s1">bytearr</span><span class="s2">):</span>
        <span class="s1">pos </span><span class="s2">= </span><span class="s1">offset</span>
        <span class="s1">numDeltas </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">deltas</span><span class="s2">)</span>
        <span class="s0">while </span><span class="s1">pos </span><span class="s2">&lt; </span><span class="s1">numDeltas</span><span class="s2">:</span>
            <span class="s1">value </span><span class="s2">= </span><span class="s1">deltas</span><span class="s2">[</span><span class="s1">pos</span><span class="s2">]</span>
            <span class="s0">if not </span><span class="s2">(-</span><span class="s4">128 </span><span class="s2">&lt;= </span><span class="s1">value </span><span class="s2">&lt;= </span><span class="s4">127</span><span class="s2">):</span>
                <span class="s0">break</span>
            <span class="s3"># Within a byte-encoded run of deltas, a single zero</span>
            <span class="s3"># is best stored literally as 0x00 value. However,</span>
            <span class="s3"># if are two or more zeroes in a sequence, it is</span>
            <span class="s3"># better to start a new run. For example, the sequence</span>
            <span class="s3"># of deltas [15, 15, 0, 15, 15] becomes 6 bytes</span>
            <span class="s3"># (04 0F 0F 00 0F 0F) when storing the zero value</span>
            <span class="s3"># literally, but 7 bytes (01 0F 0F 80 01 0F 0F)</span>
            <span class="s3"># when starting a new run.</span>
            <span class="s0">if </span><span class="s1">value </span><span class="s2">== </span><span class="s4">0 </span><span class="s0">and </span><span class="s1">pos </span><span class="s2">+ </span><span class="s4">1 </span><span class="s2">&lt; </span><span class="s1">numDeltas </span><span class="s0">and </span><span class="s1">deltas</span><span class="s2">[</span><span class="s1">pos </span><span class="s2">+ </span><span class="s4">1</span><span class="s2">] == </span><span class="s4">0</span><span class="s2">:</span>
                <span class="s0">break</span>
            <span class="s1">pos </span><span class="s2">+= </span><span class="s4">1</span>
        <span class="s1">runLength </span><span class="s2">= </span><span class="s1">pos </span><span class="s2">- </span><span class="s1">offset</span>
        <span class="s0">while </span><span class="s1">runLength </span><span class="s2">&gt;= </span><span class="s4">64</span><span class="s2">:</span>
            <span class="s1">bytearr</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s4">63</span><span class="s2">)</span>
            <span class="s1">bytearr</span><span class="s2">.</span><span class="s1">extend</span><span class="s2">(</span><span class="s1">array</span><span class="s2">.</span><span class="s1">array</span><span class="s2">(</span><span class="s5">&quot;b&quot;</span><span class="s2">, </span><span class="s1">deltas</span><span class="s2">[</span><span class="s1">offset </span><span class="s2">: </span><span class="s1">offset </span><span class="s2">+ </span><span class="s4">64</span><span class="s2">]))</span>
            <span class="s1">offset </span><span class="s2">+= </span><span class="s4">64</span>
            <span class="s1">runLength </span><span class="s2">-= </span><span class="s4">64</span>
        <span class="s0">if </span><span class="s1">runLength</span><span class="s2">:</span>
            <span class="s1">bytearr</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">runLength </span><span class="s2">- </span><span class="s4">1</span><span class="s2">)</span>
            <span class="s1">bytearr</span><span class="s2">.</span><span class="s1">extend</span><span class="s2">(</span><span class="s1">array</span><span class="s2">.</span><span class="s1">array</span><span class="s2">(</span><span class="s5">&quot;b&quot;</span><span class="s2">, </span><span class="s1">deltas</span><span class="s2">[</span><span class="s1">offset</span><span class="s2">:</span><span class="s1">pos</span><span class="s2">]))</span>
        <span class="s0">return </span><span class="s1">pos</span>

    <span class="s2">@</span><span class="s1">staticmethod</span>
    <span class="s0">def </span><span class="s1">encodeDeltaRunAsWords_</span><span class="s2">(</span><span class="s1">deltas</span><span class="s2">, </span><span class="s1">offset</span><span class="s2">, </span><span class="s1">bytearr</span><span class="s2">):</span>
        <span class="s1">pos </span><span class="s2">= </span><span class="s1">offset</span>
        <span class="s1">numDeltas </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">deltas</span><span class="s2">)</span>
        <span class="s0">while </span><span class="s1">pos </span><span class="s2">&lt; </span><span class="s1">numDeltas</span><span class="s2">:</span>
            <span class="s1">value </span><span class="s2">= </span><span class="s1">deltas</span><span class="s2">[</span><span class="s1">pos</span><span class="s2">]</span>

            <span class="s3"># Within a word-encoded run of deltas, it is easiest</span>
            <span class="s3"># to start a new run (with a different encoding)</span>
            <span class="s3"># whenever we encounter a zero value. For example,</span>
            <span class="s3"># the sequence [0x6666, 0, 0x7777] needs 7 bytes when</span>
            <span class="s3"># storing the zero literally (42 66 66 00 00 77 77),</span>
            <span class="s3"># and equally 7 bytes when starting a new run</span>
            <span class="s3"># (40 66 66 80 40 77 77).</span>
            <span class="s0">if </span><span class="s1">value </span><span class="s2">== </span><span class="s4">0</span><span class="s2">:</span>
                <span class="s0">break</span>

            <span class="s3"># Within a word-encoded run of deltas, a single value</span>
            <span class="s3"># in the range (-128..127) should be encoded literally</span>
            <span class="s3"># because it is more compact. For example, the sequence</span>
            <span class="s3"># [0x6666, 2, 0x7777] becomes 7 bytes when storing</span>
            <span class="s3"># the value literally (42 66 66 00 02 77 77), but 8 bytes</span>
            <span class="s3"># when starting a new run (40 66 66 00 02 40 77 77).</span>
            <span class="s0">if </span><span class="s2">(</span>
                <span class="s2">(-</span><span class="s4">128 </span><span class="s2">&lt;= </span><span class="s1">value </span><span class="s2">&lt;= </span><span class="s4">127</span><span class="s2">)</span>
                <span class="s0">and </span><span class="s1">pos </span><span class="s2">+ </span><span class="s4">1 </span><span class="s2">&lt; </span><span class="s1">numDeltas</span>
                <span class="s0">and </span><span class="s2">(-</span><span class="s4">128 </span><span class="s2">&lt;= </span><span class="s1">deltas</span><span class="s2">[</span><span class="s1">pos </span><span class="s2">+ </span><span class="s4">1</span><span class="s2">] &lt;= </span><span class="s4">127</span><span class="s2">)</span>
            <span class="s2">):</span>
                <span class="s0">break</span>

            <span class="s0">if not </span><span class="s2">(-</span><span class="s4">32768 </span><span class="s2">&lt;= </span><span class="s1">value </span><span class="s2">&lt;= </span><span class="s4">32767</span><span class="s2">):</span>
                <span class="s0">break</span>

            <span class="s1">pos </span><span class="s2">+= </span><span class="s4">1</span>
        <span class="s1">runLength </span><span class="s2">= </span><span class="s1">pos </span><span class="s2">- </span><span class="s1">offset</span>
        <span class="s0">while </span><span class="s1">runLength </span><span class="s2">&gt;= </span><span class="s4">64</span><span class="s2">:</span>
            <span class="s1">bytearr</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">DELTAS_ARE_WORDS </span><span class="s2">| </span><span class="s4">63</span><span class="s2">)</span>
            <span class="s1">a </span><span class="s2">= </span><span class="s1">array</span><span class="s2">.</span><span class="s1">array</span><span class="s2">(</span><span class="s5">&quot;h&quot;</span><span class="s2">, </span><span class="s1">deltas</span><span class="s2">[</span><span class="s1">offset </span><span class="s2">: </span><span class="s1">offset </span><span class="s2">+ </span><span class="s4">64</span><span class="s2">])</span>
            <span class="s0">if </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">byteorder </span><span class="s2">!= </span><span class="s5">&quot;big&quot;</span><span class="s2">:</span>
                <span class="s1">a</span><span class="s2">.</span><span class="s1">byteswap</span><span class="s2">()</span>
            <span class="s1">bytearr</span><span class="s2">.</span><span class="s1">extend</span><span class="s2">(</span><span class="s1">a</span><span class="s2">)</span>
            <span class="s1">offset </span><span class="s2">+= </span><span class="s4">64</span>
            <span class="s1">runLength </span><span class="s2">-= </span><span class="s4">64</span>
        <span class="s0">if </span><span class="s1">runLength</span><span class="s2">:</span>
            <span class="s1">bytearr</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">DELTAS_ARE_WORDS </span><span class="s2">| (</span><span class="s1">runLength </span><span class="s2">- </span><span class="s4">1</span><span class="s2">))</span>
            <span class="s1">a </span><span class="s2">= </span><span class="s1">array</span><span class="s2">.</span><span class="s1">array</span><span class="s2">(</span><span class="s5">&quot;h&quot;</span><span class="s2">, </span><span class="s1">deltas</span><span class="s2">[</span><span class="s1">offset</span><span class="s2">:</span><span class="s1">pos</span><span class="s2">])</span>
            <span class="s0">if </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">byteorder </span><span class="s2">!= </span><span class="s5">&quot;big&quot;</span><span class="s2">:</span>
                <span class="s1">a</span><span class="s2">.</span><span class="s1">byteswap</span><span class="s2">()</span>
            <span class="s1">bytearr</span><span class="s2">.</span><span class="s1">extend</span><span class="s2">(</span><span class="s1">a</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">pos</span>

    <span class="s2">@</span><span class="s1">staticmethod</span>
    <span class="s0">def </span><span class="s1">encodeDeltaRunAsLongs_</span><span class="s2">(</span><span class="s1">deltas</span><span class="s2">, </span><span class="s1">offset</span><span class="s2">, </span><span class="s1">bytearr</span><span class="s2">):</span>
        <span class="s1">pos </span><span class="s2">= </span><span class="s1">offset</span>
        <span class="s1">numDeltas </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">deltas</span><span class="s2">)</span>
        <span class="s0">while </span><span class="s1">pos </span><span class="s2">&lt; </span><span class="s1">numDeltas</span><span class="s2">:</span>
            <span class="s1">value </span><span class="s2">= </span><span class="s1">deltas</span><span class="s2">[</span><span class="s1">pos</span><span class="s2">]</span>
            <span class="s0">if </span><span class="s2">-</span><span class="s4">32768 </span><span class="s2">&lt;= </span><span class="s1">value </span><span class="s2">&lt;= </span><span class="s4">32767</span><span class="s2">:</span>
                <span class="s0">break</span>
            <span class="s1">pos </span><span class="s2">+= </span><span class="s4">1</span>
        <span class="s1">runLength </span><span class="s2">= </span><span class="s1">pos </span><span class="s2">- </span><span class="s1">offset</span>
        <span class="s0">while </span><span class="s1">runLength </span><span class="s2">&gt;= </span><span class="s4">64</span><span class="s2">:</span>
            <span class="s1">bytearr</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">DELTAS_ARE_LONGS </span><span class="s2">| </span><span class="s4">63</span><span class="s2">)</span>
            <span class="s1">a </span><span class="s2">= </span><span class="s1">array</span><span class="s2">.</span><span class="s1">array</span><span class="s2">(</span><span class="s5">&quot;i&quot;</span><span class="s2">, </span><span class="s1">deltas</span><span class="s2">[</span><span class="s1">offset </span><span class="s2">: </span><span class="s1">offset </span><span class="s2">+ </span><span class="s4">64</span><span class="s2">])</span>
            <span class="s0">if </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">byteorder </span><span class="s2">!= </span><span class="s5">&quot;big&quot;</span><span class="s2">:</span>
                <span class="s1">a</span><span class="s2">.</span><span class="s1">byteswap</span><span class="s2">()</span>
            <span class="s1">bytearr</span><span class="s2">.</span><span class="s1">extend</span><span class="s2">(</span><span class="s1">a</span><span class="s2">)</span>
            <span class="s1">offset </span><span class="s2">+= </span><span class="s4">64</span>
            <span class="s1">runLength </span><span class="s2">-= </span><span class="s4">64</span>
        <span class="s0">if </span><span class="s1">runLength</span><span class="s2">:</span>
            <span class="s1">bytearr</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">DELTAS_ARE_LONGS </span><span class="s2">| (</span><span class="s1">runLength </span><span class="s2">- </span><span class="s4">1</span><span class="s2">))</span>
            <span class="s1">a </span><span class="s2">= </span><span class="s1">array</span><span class="s2">.</span><span class="s1">array</span><span class="s2">(</span><span class="s5">&quot;i&quot;</span><span class="s2">, </span><span class="s1">deltas</span><span class="s2">[</span><span class="s1">offset</span><span class="s2">:</span><span class="s1">pos</span><span class="s2">])</span>
            <span class="s0">if </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">byteorder </span><span class="s2">!= </span><span class="s5">&quot;big&quot;</span><span class="s2">:</span>
                <span class="s1">a</span><span class="s2">.</span><span class="s1">byteswap</span><span class="s2">()</span>
            <span class="s1">bytearr</span><span class="s2">.</span><span class="s1">extend</span><span class="s2">(</span><span class="s1">a</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">pos</span>

    <span class="s2">@</span><span class="s1">staticmethod</span>
    <span class="s0">def </span><span class="s1">decompileDeltas_</span><span class="s2">(</span><span class="s1">numDeltas</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">offset</span><span class="s2">=</span><span class="s4">0</span><span class="s2">):</span>
        <span class="s6">&quot;&quot;&quot;(numDeltas, data, offset) --&gt; ([delta, delta, ...], newOffset)&quot;&quot;&quot;</span>
        <span class="s1">result </span><span class="s2">= []</span>
        <span class="s1">pos </span><span class="s2">= </span><span class="s1">offset</span>
        <span class="s0">while </span><span class="s1">len</span><span class="s2">(</span><span class="s1">result</span><span class="s2">) &lt; </span><span class="s1">numDeltas </span><span class="s0">if </span><span class="s1">numDeltas </span><span class="s0">is not None else </span><span class="s1">pos </span><span class="s2">&lt; </span><span class="s1">len</span><span class="s2">(</span><span class="s1">data</span><span class="s2">):</span>
            <span class="s1">runHeader </span><span class="s2">= </span><span class="s1">data</span><span class="s2">[</span><span class="s1">pos</span><span class="s2">]</span>
            <span class="s1">pos </span><span class="s2">+= </span><span class="s4">1</span>
            <span class="s1">numDeltasInRun </span><span class="s2">= (</span><span class="s1">runHeader </span><span class="s2">&amp; </span><span class="s1">DELTA_RUN_COUNT_MASK</span><span class="s2">) + </span><span class="s4">1</span>
            <span class="s0">if </span><span class="s2">(</span><span class="s1">runHeader </span><span class="s2">&amp; </span><span class="s1">DELTAS_SIZE_MASK</span><span class="s2">) == </span><span class="s1">DELTAS_ARE_ZERO</span><span class="s2">:</span>
                <span class="s1">result</span><span class="s2">.</span><span class="s1">extend</span><span class="s2">([</span><span class="s4">0</span><span class="s2">] * </span><span class="s1">numDeltasInRun</span><span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s0">if </span><span class="s2">(</span><span class="s1">runHeader </span><span class="s2">&amp; </span><span class="s1">DELTAS_SIZE_MASK</span><span class="s2">) == </span><span class="s1">DELTAS_ARE_LONGS</span><span class="s2">:</span>
                    <span class="s1">deltas </span><span class="s2">= </span><span class="s1">array</span><span class="s2">.</span><span class="s1">array</span><span class="s2">(</span><span class="s5">&quot;i&quot;</span><span class="s2">)</span>
                    <span class="s1">deltasSize </span><span class="s2">= </span><span class="s1">numDeltasInRun </span><span class="s2">* </span><span class="s4">4</span>
                <span class="s0">elif </span><span class="s2">(</span><span class="s1">runHeader </span><span class="s2">&amp; </span><span class="s1">DELTAS_SIZE_MASK</span><span class="s2">) == </span><span class="s1">DELTAS_ARE_WORDS</span><span class="s2">:</span>
                    <span class="s1">deltas </span><span class="s2">= </span><span class="s1">array</span><span class="s2">.</span><span class="s1">array</span><span class="s2">(</span><span class="s5">&quot;h&quot;</span><span class="s2">)</span>
                    <span class="s1">deltasSize </span><span class="s2">= </span><span class="s1">numDeltasInRun </span><span class="s2">* </span><span class="s4">2</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s1">deltas </span><span class="s2">= </span><span class="s1">array</span><span class="s2">.</span><span class="s1">array</span><span class="s2">(</span><span class="s5">&quot;b&quot;</span><span class="s2">)</span>
                    <span class="s1">deltasSize </span><span class="s2">= </span><span class="s1">numDeltasInRun</span>
                <span class="s1">deltas</span><span class="s2">.</span><span class="s1">frombytes</span><span class="s2">(</span><span class="s1">data</span><span class="s2">[</span><span class="s1">pos </span><span class="s2">: </span><span class="s1">pos </span><span class="s2">+ </span><span class="s1">deltasSize</span><span class="s2">])</span>
                <span class="s0">if </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">byteorder </span><span class="s2">!= </span><span class="s5">&quot;big&quot;</span><span class="s2">:</span>
                    <span class="s1">deltas</span><span class="s2">.</span><span class="s1">byteswap</span><span class="s2">()</span>
                <span class="s0">assert </span><span class="s1">len</span><span class="s2">(</span><span class="s1">deltas</span><span class="s2">) == </span><span class="s1">numDeltasInRun</span><span class="s2">, (</span><span class="s1">len</span><span class="s2">(</span><span class="s1">deltas</span><span class="s2">), </span><span class="s1">numDeltasInRun</span><span class="s2">)</span>
                <span class="s1">pos </span><span class="s2">+= </span><span class="s1">deltasSize</span>
                <span class="s1">result</span><span class="s2">.</span><span class="s1">extend</span><span class="s2">(</span><span class="s1">deltas</span><span class="s2">)</span>
        <span class="s0">assert </span><span class="s1">numDeltas </span><span class="s0">is None or </span><span class="s1">len</span><span class="s2">(</span><span class="s1">result</span><span class="s2">) == </span><span class="s1">numDeltas</span>
        <span class="s0">return </span><span class="s2">(</span><span class="s1">result</span><span class="s2">, </span><span class="s1">pos</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">staticmethod</span>
    <span class="s0">def </span><span class="s1">getTupleSize_</span><span class="s2">(</span><span class="s1">flags</span><span class="s2">, </span><span class="s1">axisCount</span><span class="s2">):</span>
        <span class="s1">size </span><span class="s2">= </span><span class="s4">4</span>
        <span class="s0">if </span><span class="s2">(</span><span class="s1">flags </span><span class="s2">&amp; </span><span class="s1">EMBEDDED_PEAK_TUPLE</span><span class="s2">) != </span><span class="s4">0</span><span class="s2">:</span>
            <span class="s1">size </span><span class="s2">+= </span><span class="s1">axisCount </span><span class="s2">* </span><span class="s4">2</span>
        <span class="s0">if </span><span class="s2">(</span><span class="s1">flags </span><span class="s2">&amp; </span><span class="s1">INTERMEDIATE_REGION</span><span class="s2">) != </span><span class="s4">0</span><span class="s2">:</span>
            <span class="s1">size </span><span class="s2">+= </span><span class="s1">axisCount </span><span class="s2">* </span><span class="s4">4</span>
        <span class="s0">return </span><span class="s1">size</span>

    <span class="s0">def </span><span class="s1">getCoordWidth</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s6">&quot;&quot;&quot;Return 2 if coordinates are (x, y) as in gvar, 1 if single values 
        as in cvar, or 0 if empty. 
        &quot;&quot;&quot;</span>
        <span class="s1">firstDelta </span><span class="s2">= </span><span class="s1">next</span><span class="s2">((</span><span class="s1">c </span><span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">coordinates </span><span class="s0">if </span><span class="s1">c </span><span class="s0">is not None</span><span class="s2">), </span><span class="s0">None</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">firstDelta </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s4">0  </span><span class="s3"># empty or has no impact</span>
        <span class="s0">if </span><span class="s1">type</span><span class="s2">(</span><span class="s1">firstDelta</span><span class="s2">) </span><span class="s0">in </span><span class="s2">(</span><span class="s1">int</span><span class="s2">, </span><span class="s1">float</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s4">1</span>
        <span class="s0">if </span><span class="s1">type</span><span class="s2">(</span><span class="s1">firstDelta</span><span class="s2">) </span><span class="s0">is </span><span class="s1">tuple </span><span class="s0">and </span><span class="s1">len</span><span class="s2">(</span><span class="s1">firstDelta</span><span class="s2">) == </span><span class="s4">2</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s4">2</span>
        <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span>
            <span class="s5">&quot;invalid type of delta; expected (int or float) number, or &quot;</span>
            <span class="s5">&quot;Tuple[number, number]: %r&quot; </span><span class="s2">% </span><span class="s1">firstDelta</span>
        <span class="s2">)</span>

    <span class="s0">def </span><span class="s1">scaleDeltas</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">scalar</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">scalar </span><span class="s2">== </span><span class="s4">1.0</span><span class="s2">:</span>
            <span class="s0">return  </span><span class="s3"># no change</span>
        <span class="s1">coordWidth </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">getCoordWidth</span><span class="s2">()</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">coordinates </span><span class="s2">= [</span>
            <span class="s2">(</span>
                <span class="s0">None</span>
                <span class="s0">if </span><span class="s1">d </span><span class="s0">is None</span>
                <span class="s0">else </span><span class="s1">d </span><span class="s2">* </span><span class="s1">scalar </span><span class="s0">if </span><span class="s1">coordWidth </span><span class="s2">== </span><span class="s4">1 </span><span class="s0">else </span><span class="s2">(</span><span class="s1">d</span><span class="s2">[</span><span class="s4">0</span><span class="s2">] * </span><span class="s1">scalar</span><span class="s2">, </span><span class="s1">d</span><span class="s2">[</span><span class="s4">1</span><span class="s2">] * </span><span class="s1">scalar</span><span class="s2">)</span>
            <span class="s2">)</span>
            <span class="s0">for </span><span class="s1">d </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">coordinates</span>
        <span class="s2">]</span>

    <span class="s0">def </span><span class="s1">roundDeltas</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">coordWidth </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">getCoordWidth</span><span class="s2">()</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">coordinates </span><span class="s2">= [</span>
            <span class="s2">(</span>
                <span class="s0">None</span>
                <span class="s0">if </span><span class="s1">d </span><span class="s0">is None</span>
                <span class="s0">else </span><span class="s1">otRound</span><span class="s2">(</span><span class="s1">d</span><span class="s2">) </span><span class="s0">if </span><span class="s1">coordWidth </span><span class="s2">== </span><span class="s4">1 </span><span class="s0">else </span><span class="s2">(</span><span class="s1">otRound</span><span class="s2">(</span><span class="s1">d</span><span class="s2">[</span><span class="s4">0</span><span class="s2">]), </span><span class="s1">otRound</span><span class="s2">(</span><span class="s1">d</span><span class="s2">[</span><span class="s4">1</span><span class="s2">]))</span>
            <span class="s2">)</span>
            <span class="s0">for </span><span class="s1">d </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">coordinates</span>
        <span class="s2">]</span>

    <span class="s0">def </span><span class="s1">calcInferredDeltas</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">origCoords</span><span class="s2">, </span><span class="s1">endPts</span><span class="s2">):</span>
        <span class="s0">from </span><span class="s1">fontTools</span><span class="s2">.</span><span class="s1">varLib</span><span class="s2">.</span><span class="s1">iup </span><span class="s0">import </span><span class="s1">iup_delta</span>

        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">getCoordWidth</span><span class="s2">() == </span><span class="s4">1</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s5">&quot;Only 'gvar' TupleVariation can have inferred deltas&quot;</span><span class="s2">)</span>
        <span class="s0">if None in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">coordinates</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">coordinates</span><span class="s2">) != </span><span class="s1">len</span><span class="s2">(</span><span class="s1">origCoords</span><span class="s2">):</span>
                <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
                    <span class="s5">&quot;Expected len(origCoords) == %d; found %d&quot;</span>
                    <span class="s2">% (</span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">coordinates</span><span class="s2">), </span><span class="s1">len</span><span class="s2">(</span><span class="s1">origCoords</span><span class="s2">))</span>
                <span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">coordinates </span><span class="s2">= </span><span class="s1">iup_delta</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">coordinates</span><span class="s2">, </span><span class="s1">origCoords</span><span class="s2">, </span><span class="s1">endPts</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">optimize</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">origCoords</span><span class="s2">, </span><span class="s1">endPts</span><span class="s2">, </span><span class="s1">tolerance</span><span class="s2">=</span><span class="s4">0.5</span><span class="s2">, </span><span class="s1">isComposite</span><span class="s2">=</span><span class="s0">False</span><span class="s2">):</span>
        <span class="s0">from </span><span class="s1">fontTools</span><span class="s2">.</span><span class="s1">varLib</span><span class="s2">.</span><span class="s1">iup </span><span class="s0">import </span><span class="s1">iup_delta_optimize</span>

        <span class="s0">if None in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">coordinates</span><span class="s2">:</span>
            <span class="s0">return  </span><span class="s3"># already optimized</span>

        <span class="s1">deltaOpt </span><span class="s2">= </span><span class="s1">iup_delta_optimize</span><span class="s2">(</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">coordinates</span><span class="s2">, </span><span class="s1">origCoords</span><span class="s2">, </span><span class="s1">endPts</span><span class="s2">, </span><span class="s1">tolerance</span><span class="s2">=</span><span class="s1">tolerance</span>
        <span class="s2">)</span>
        <span class="s0">if None in </span><span class="s1">deltaOpt</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">isComposite </span><span class="s0">and </span><span class="s1">all</span><span class="s2">(</span><span class="s1">d </span><span class="s0">is None for </span><span class="s1">d </span><span class="s0">in </span><span class="s1">deltaOpt</span><span class="s2">):</span>
                <span class="s3"># Fix for macOS composites</span>
                <span class="s3"># https://github.com/fonttools/fonttools/issues/1381</span>
                <span class="s1">deltaOpt </span><span class="s2">= [(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">)] + [</span><span class="s0">None</span><span class="s2">] * (</span><span class="s1">len</span><span class="s2">(</span><span class="s1">deltaOpt</span><span class="s2">) - </span><span class="s4">1</span><span class="s2">)</span>
            <span class="s3"># Use &quot;optimized&quot; version only if smaller...</span>
            <span class="s1">varOpt </span><span class="s2">= </span><span class="s1">TupleVariation</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">axes</span><span class="s2">, </span><span class="s1">deltaOpt</span><span class="s2">)</span>

            <span class="s3"># Shouldn't matter that this is different from fvar...?</span>
            <span class="s1">axisTags </span><span class="s2">= </span><span class="s1">sorted</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">axes</span><span class="s2">.</span><span class="s1">keys</span><span class="s2">())</span>
            <span class="s1">tupleData</span><span class="s2">, </span><span class="s1">auxData </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">compile</span><span class="s2">(</span><span class="s1">axisTags</span><span class="s2">)</span>
            <span class="s1">unoptimizedLength </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">tupleData</span><span class="s2">) + </span><span class="s1">len</span><span class="s2">(</span><span class="s1">auxData</span><span class="s2">)</span>
            <span class="s1">tupleData</span><span class="s2">, </span><span class="s1">auxData </span><span class="s2">= </span><span class="s1">varOpt</span><span class="s2">.</span><span class="s1">compile</span><span class="s2">(</span><span class="s1">axisTags</span><span class="s2">)</span>
            <span class="s1">optimizedLength </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">tupleData</span><span class="s2">) + </span><span class="s1">len</span><span class="s2">(</span><span class="s1">auxData</span><span class="s2">)</span>

            <span class="s0">if </span><span class="s1">optimizedLength </span><span class="s2">&lt; </span><span class="s1">unoptimizedLength</span><span class="s2">:</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">coordinates </span><span class="s2">= </span><span class="s1">varOpt</span><span class="s2">.</span><span class="s1">coordinates</span>

    <span class="s0">def </span><span class="s1">__imul__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">scalar</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">scaleDeltas</span><span class="s2">(</span><span class="s1">scalar</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">self</span>

    <span class="s0">def </span><span class="s1">__iadd__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">):</span>
        <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">other</span><span class="s2">, </span><span class="s1">TupleVariation</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">NotImplemented</span>
        <span class="s1">deltas1 </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">coordinates</span>
        <span class="s1">length </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">deltas1</span><span class="s2">)</span>
        <span class="s1">deltas2 </span><span class="s2">= </span><span class="s1">other</span><span class="s2">.</span><span class="s1">coordinates</span>
        <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">deltas2</span><span class="s2">) != </span><span class="s1">length</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s5">&quot;cannot sum TupleVariation deltas with different lengths&quot;</span><span class="s2">)</span>
        <span class="s3"># 'None' values have different meanings in gvar vs cvar TupleVariations:</span>
        <span class="s3"># within the gvar, when deltas are not provided explicitly for some points,</span>
        <span class="s3"># they need to be inferred; whereas for the 'cvar' table, if deltas are not</span>
        <span class="s3"># provided for some CVT values, then no adjustments are made (i.e. None == 0).</span>
        <span class="s3"># Thus, we cannot sum deltas for gvar TupleVariations if they contain</span>
        <span class="s3"># inferred inferred deltas (the latter need to be computed first using</span>
        <span class="s3"># 'calcInferredDeltas' method), but we can treat 'None' values in cvar</span>
        <span class="s3"># deltas as if they are zeros.</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">getCoordWidth</span><span class="s2">() == </span><span class="s4">2</span><span class="s2">:</span>
            <span class="s0">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">d2 </span><span class="s0">in </span><span class="s1">zip</span><span class="s2">(</span><span class="s1">range</span><span class="s2">(</span><span class="s1">length</span><span class="s2">), </span><span class="s1">deltas2</span><span class="s2">):</span>
                <span class="s1">d1 </span><span class="s2">= </span><span class="s1">deltas1</span><span class="s2">[</span><span class="s1">i</span><span class="s2">]</span>
                <span class="s0">try</span><span class="s2">:</span>
                    <span class="s1">deltas1</span><span class="s2">[</span><span class="s1">i</span><span class="s2">] = (</span><span class="s1">d1</span><span class="s2">[</span><span class="s4">0</span><span class="s2">] + </span><span class="s1">d2</span><span class="s2">[</span><span class="s4">0</span><span class="s2">], </span><span class="s1">d1</span><span class="s2">[</span><span class="s4">1</span><span class="s2">] + </span><span class="s1">d2</span><span class="s2">[</span><span class="s4">1</span><span class="s2">])</span>
                <span class="s0">except </span><span class="s1">TypeError</span><span class="s2">:</span>
                    <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s5">&quot;cannot sum gvar deltas with inferred points&quot;</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">d2 </span><span class="s0">in </span><span class="s1">zip</span><span class="s2">(</span><span class="s1">range</span><span class="s2">(</span><span class="s1">length</span><span class="s2">), </span><span class="s1">deltas2</span><span class="s2">):</span>
                <span class="s1">d1 </span><span class="s2">= </span><span class="s1">deltas1</span><span class="s2">[</span><span class="s1">i</span><span class="s2">]</span>
                <span class="s0">if </span><span class="s1">d1 </span><span class="s0">is not None and </span><span class="s1">d2 </span><span class="s0">is not None</span><span class="s2">:</span>
                    <span class="s1">deltas1</span><span class="s2">[</span><span class="s1">i</span><span class="s2">] = </span><span class="s1">d1 </span><span class="s2">+ </span><span class="s1">d2</span>
                <span class="s0">elif </span><span class="s1">d1 </span><span class="s0">is None and </span><span class="s1">d2 </span><span class="s0">is not None</span><span class="s2">:</span>
                    <span class="s1">deltas1</span><span class="s2">[</span><span class="s1">i</span><span class="s2">] = </span><span class="s1">d2</span>
                <span class="s3"># elif d2 is None do nothing</span>
        <span class="s0">return </span><span class="s1">self</span>


<span class="s0">def </span><span class="s1">decompileSharedTuples</span><span class="s2">(</span><span class="s1">axisTags</span><span class="s2">, </span><span class="s1">sharedTupleCount</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">offset</span><span class="s2">):</span>
    <span class="s1">result </span><span class="s2">= []</span>
    <span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">sharedTupleCount</span><span class="s2">):</span>
        <span class="s1">t</span><span class="s2">, </span><span class="s1">offset </span><span class="s2">= </span><span class="s1">TupleVariation</span><span class="s2">.</span><span class="s1">decompileCoord_</span><span class="s2">(</span><span class="s1">axisTags</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">offset</span><span class="s2">)</span>
        <span class="s1">result</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">t</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">result</span>


<span class="s0">def </span><span class="s1">compileSharedTuples</span><span class="s2">(</span>
    <span class="s1">axisTags</span><span class="s2">, </span><span class="s1">variations</span><span class="s2">, </span><span class="s1">MAX_NUM_SHARED_COORDS</span><span class="s2">=</span><span class="s1">TUPLE_INDEX_MASK </span><span class="s2">+ </span><span class="s4">1</span>
<span class="s2">):</span>
    <span class="s1">coordCount </span><span class="s2">= </span><span class="s1">Counter</span><span class="s2">()</span>
    <span class="s0">for </span><span class="s1">var </span><span class="s0">in </span><span class="s1">variations</span><span class="s2">:</span>
        <span class="s1">coord </span><span class="s2">= </span><span class="s1">var</span><span class="s2">.</span><span class="s1">compileCoord</span><span class="s2">(</span><span class="s1">axisTags</span><span class="s2">)</span>
        <span class="s1">coordCount</span><span class="s2">[</span><span class="s1">coord</span><span class="s2">] += </span><span class="s4">1</span>
    <span class="s3"># In python &lt; 3.7, most_common() ordering is non-deterministic</span>
    <span class="s3"># so apply a sort to make sure the ordering is consistent.</span>
    <span class="s1">sharedCoords </span><span class="s2">= </span><span class="s1">sorted</span><span class="s2">(</span>
        <span class="s1">coordCount</span><span class="s2">.</span><span class="s1">most_common</span><span class="s2">(</span><span class="s1">MAX_NUM_SHARED_COORDS</span><span class="s2">),</span>
        <span class="s1">key</span><span class="s2">=</span><span class="s0">lambda </span><span class="s1">item</span><span class="s2">: (-</span><span class="s1">item</span><span class="s2">[</span><span class="s4">1</span><span class="s2">], </span><span class="s1">item</span><span class="s2">[</span><span class="s4">0</span><span class="s2">]),</span>
    <span class="s2">)</span>
    <span class="s0">return </span><span class="s2">[</span><span class="s1">c</span><span class="s2">[</span><span class="s4">0</span><span class="s2">] </span><span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">sharedCoords </span><span class="s0">if </span><span class="s1">c</span><span class="s2">[</span><span class="s4">1</span><span class="s2">] &gt; </span><span class="s4">1</span><span class="s2">]</span>


<span class="s0">def </span><span class="s1">compileTupleVariationStore</span><span class="s2">(</span>
    <span class="s1">variations</span><span class="s2">, </span><span class="s1">pointCount</span><span class="s2">, </span><span class="s1">axisTags</span><span class="s2">, </span><span class="s1">sharedTupleIndices</span><span class="s2">, </span><span class="s1">useSharedPoints</span><span class="s2">=</span><span class="s0">True</span>
<span class="s2">):</span>
    <span class="s3"># pointCount is actually unused. Keeping for API compat.</span>
    <span class="s0">del </span><span class="s1">pointCount</span>
    <span class="s1">newVariations </span><span class="s2">= []</span>
    <span class="s1">pointDatas </span><span class="s2">= []</span>
    <span class="s3"># Compile all points and figure out sharing if desired</span>
    <span class="s1">sharedPoints </span><span class="s2">= </span><span class="s0">None</span>

    <span class="s3"># Collect, count, and compile point-sets for all variation sets</span>
    <span class="s1">pointSetCount </span><span class="s2">= </span><span class="s1">defaultdict</span><span class="s2">(</span><span class="s1">int</span><span class="s2">)</span>
    <span class="s0">for </span><span class="s1">v </span><span class="s0">in </span><span class="s1">variations</span><span class="s2">:</span>
        <span class="s1">points </span><span class="s2">= </span><span class="s1">v</span><span class="s2">.</span><span class="s1">getUsedPoints</span><span class="s2">()</span>
        <span class="s0">if </span><span class="s1">points </span><span class="s0">is None</span><span class="s2">:  </span><span class="s3"># Empty variations</span>
            <span class="s0">continue</span>
        <span class="s1">pointSetCount</span><span class="s2">[</span><span class="s1">points</span><span class="s2">] += </span><span class="s4">1</span>
        <span class="s1">newVariations</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">v</span><span class="s2">)</span>
        <span class="s1">pointDatas</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">points</span><span class="s2">)</span>
    <span class="s1">variations </span><span class="s2">= </span><span class="s1">newVariations</span>
    <span class="s0">del </span><span class="s1">newVariations</span>

    <span class="s0">if not </span><span class="s1">variations</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s2">(</span><span class="s4">0</span><span class="s2">, </span><span class="s7">b&quot;&quot;</span><span class="s2">, </span><span class="s7">b&quot;&quot;</span><span class="s2">)</span>

    <span class="s1">n </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">variations</span><span class="s2">[</span><span class="s4">0</span><span class="s2">].</span><span class="s1">coordinates</span><span class="s2">)</span>
    <span class="s0">assert </span><span class="s1">all</span><span class="s2">(</span>
        <span class="s1">len</span><span class="s2">(</span><span class="s1">v</span><span class="s2">.</span><span class="s1">coordinates</span><span class="s2">) == </span><span class="s1">n </span><span class="s0">for </span><span class="s1">v </span><span class="s0">in </span><span class="s1">variations</span>
    <span class="s2">), </span><span class="s5">&quot;Variation sets have different sizes&quot;</span>

    <span class="s1">compiledPoints </span><span class="s2">= {</span>
        <span class="s1">pointSet</span><span class="s2">: </span><span class="s1">TupleVariation</span><span class="s2">.</span><span class="s1">compilePoints</span><span class="s2">(</span><span class="s1">pointSet</span><span class="s2">) </span><span class="s0">for </span><span class="s1">pointSet </span><span class="s0">in </span><span class="s1">pointSetCount</span>
    <span class="s2">}</span>

    <span class="s1">tupleVariationCount </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">variations</span><span class="s2">)</span>
    <span class="s1">tuples </span><span class="s2">= []</span>
    <span class="s1">data </span><span class="s2">= []</span>

    <span class="s0">if </span><span class="s1">useSharedPoints</span><span class="s2">:</span>
        <span class="s3"># Find point-set which saves most bytes.</span>
        <span class="s0">def </span><span class="s1">key</span><span class="s2">(</span><span class="s1">pn</span><span class="s2">):</span>
            <span class="s1">pointSet </span><span class="s2">= </span><span class="s1">pn</span><span class="s2">[</span><span class="s4">0</span><span class="s2">]</span>
            <span class="s1">count </span><span class="s2">= </span><span class="s1">pn</span><span class="s2">[</span><span class="s4">1</span><span class="s2">]</span>
            <span class="s0">return </span><span class="s1">len</span><span class="s2">(</span><span class="s1">compiledPoints</span><span class="s2">[</span><span class="s1">pointSet</span><span class="s2">]) * (</span><span class="s1">count </span><span class="s2">- </span><span class="s4">1</span><span class="s2">)</span>

        <span class="s1">sharedPoints </span><span class="s2">= </span><span class="s1">max</span><span class="s2">(</span><span class="s1">pointSetCount</span><span class="s2">.</span><span class="s1">items</span><span class="s2">(), </span><span class="s1">key</span><span class="s2">=</span><span class="s1">key</span><span class="s2">)[</span><span class="s4">0</span><span class="s2">]</span>

        <span class="s1">data</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">compiledPoints</span><span class="s2">[</span><span class="s1">sharedPoints</span><span class="s2">])</span>
        <span class="s1">tupleVariationCount </span><span class="s2">|= </span><span class="s1">TUPLES_SHARE_POINT_NUMBERS</span>

    <span class="s3"># b'' implies &quot;use shared points&quot;</span>
    <span class="s1">pointDatas </span><span class="s2">= [</span>
        <span class="s1">compiledPoints</span><span class="s2">[</span><span class="s1">points</span><span class="s2">] </span><span class="s0">if </span><span class="s1">points </span><span class="s2">!= </span><span class="s1">sharedPoints </span><span class="s0">else </span><span class="s7">b&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">points </span><span class="s0">in </span><span class="s1">pointDatas</span>
    <span class="s2">]</span>

    <span class="s0">for </span><span class="s1">v</span><span class="s2">, </span><span class="s1">p </span><span class="s0">in </span><span class="s1">zip</span><span class="s2">(</span><span class="s1">variations</span><span class="s2">, </span><span class="s1">pointDatas</span><span class="s2">):</span>
        <span class="s1">thisTuple</span><span class="s2">, </span><span class="s1">thisData </span><span class="s2">= </span><span class="s1">v</span><span class="s2">.</span><span class="s1">compile</span><span class="s2">(</span><span class="s1">axisTags</span><span class="s2">, </span><span class="s1">sharedTupleIndices</span><span class="s2">, </span><span class="s1">pointData</span><span class="s2">=</span><span class="s1">p</span><span class="s2">)</span>

        <span class="s1">tuples</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">thisTuple</span><span class="s2">)</span>
        <span class="s1">data</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">thisData</span><span class="s2">)</span>

    <span class="s1">tuples </span><span class="s2">= </span><span class="s7">b&quot;&quot;</span><span class="s2">.</span><span class="s1">join</span><span class="s2">(</span><span class="s1">tuples</span><span class="s2">)</span>
    <span class="s1">data </span><span class="s2">= </span><span class="s7">b&quot;&quot;</span><span class="s2">.</span><span class="s1">join</span><span class="s2">(</span><span class="s1">data</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">tupleVariationCount</span><span class="s2">, </span><span class="s1">tuples</span><span class="s2">, </span><span class="s1">data</span>


<span class="s0">def </span><span class="s1">decompileTupleVariationStore</span><span class="s2">(</span>
    <span class="s1">tableTag</span><span class="s2">,</span>
    <span class="s1">axisTags</span><span class="s2">,</span>
    <span class="s1">tupleVariationCount</span><span class="s2">,</span>
    <span class="s1">pointCount</span><span class="s2">,</span>
    <span class="s1">sharedTuples</span><span class="s2">,</span>
    <span class="s1">data</span><span class="s2">,</span>
    <span class="s1">pos</span><span class="s2">,</span>
    <span class="s1">dataPos</span><span class="s2">,</span>
<span class="s2">):</span>
    <span class="s1">numAxes </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">axisTags</span><span class="s2">)</span>
    <span class="s1">result </span><span class="s2">= []</span>
    <span class="s0">if </span><span class="s2">(</span><span class="s1">tupleVariationCount </span><span class="s2">&amp; </span><span class="s1">TUPLES_SHARE_POINT_NUMBERS</span><span class="s2">) != </span><span class="s4">0</span><span class="s2">:</span>
        <span class="s1">sharedPoints</span><span class="s2">, </span><span class="s1">dataPos </span><span class="s2">= </span><span class="s1">TupleVariation</span><span class="s2">.</span><span class="s1">decompilePoints_</span><span class="s2">(</span>
            <span class="s1">pointCount</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">dataPos</span><span class="s2">, </span><span class="s1">tableTag</span>
        <span class="s2">)</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">sharedPoints </span><span class="s2">= []</span>
    <span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">tupleVariationCount </span><span class="s2">&amp; </span><span class="s1">TUPLE_COUNT_MASK</span><span class="s2">):</span>
        <span class="s1">dataSize</span><span class="s2">, </span><span class="s1">flags </span><span class="s2">= </span><span class="s1">struct</span><span class="s2">.</span><span class="s1">unpack</span><span class="s2">(</span><span class="s5">&quot;&gt;HH&quot;</span><span class="s2">, </span><span class="s1">data</span><span class="s2">[</span><span class="s1">pos </span><span class="s2">: </span><span class="s1">pos </span><span class="s2">+ </span><span class="s4">4</span><span class="s2">])</span>
        <span class="s1">tupleSize </span><span class="s2">= </span><span class="s1">TupleVariation</span><span class="s2">.</span><span class="s1">getTupleSize_</span><span class="s2">(</span><span class="s1">flags</span><span class="s2">, </span><span class="s1">numAxes</span><span class="s2">)</span>
        <span class="s1">tupleData </span><span class="s2">= </span><span class="s1">data</span><span class="s2">[</span><span class="s1">pos </span><span class="s2">: </span><span class="s1">pos </span><span class="s2">+ </span><span class="s1">tupleSize</span><span class="s2">]</span>
        <span class="s1">pointDeltaData </span><span class="s2">= </span><span class="s1">data</span><span class="s2">[</span><span class="s1">dataPos </span><span class="s2">: </span><span class="s1">dataPos </span><span class="s2">+ </span><span class="s1">dataSize</span><span class="s2">]</span>
        <span class="s1">result</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span>
            <span class="s1">decompileTupleVariation_</span><span class="s2">(</span>
                <span class="s1">pointCount</span><span class="s2">,</span>
                <span class="s1">sharedTuples</span><span class="s2">,</span>
                <span class="s1">sharedPoints</span><span class="s2">,</span>
                <span class="s1">tableTag</span><span class="s2">,</span>
                <span class="s1">axisTags</span><span class="s2">,</span>
                <span class="s1">tupleData</span><span class="s2">,</span>
                <span class="s1">pointDeltaData</span><span class="s2">,</span>
            <span class="s2">)</span>
        <span class="s2">)</span>
        <span class="s1">pos </span><span class="s2">+= </span><span class="s1">tupleSize</span>
        <span class="s1">dataPos </span><span class="s2">+= </span><span class="s1">dataSize</span>
    <span class="s0">return </span><span class="s1">result</span>


<span class="s0">def </span><span class="s1">decompileTupleVariation_</span><span class="s2">(</span>
    <span class="s1">pointCount</span><span class="s2">, </span><span class="s1">sharedTuples</span><span class="s2">, </span><span class="s1">sharedPoints</span><span class="s2">, </span><span class="s1">tableTag</span><span class="s2">, </span><span class="s1">axisTags</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">tupleData</span>
<span class="s2">):</span>
    <span class="s0">assert </span><span class="s1">tableTag </span><span class="s0">in </span><span class="s2">(</span><span class="s5">&quot;cvar&quot;</span><span class="s2">, </span><span class="s5">&quot;gvar&quot;</span><span class="s2">), </span><span class="s1">tableTag</span>
    <span class="s1">flags </span><span class="s2">= </span><span class="s1">struct</span><span class="s2">.</span><span class="s1">unpack</span><span class="s2">(</span><span class="s5">&quot;&gt;H&quot;</span><span class="s2">, </span><span class="s1">data</span><span class="s2">[</span><span class="s4">2</span><span class="s2">:</span><span class="s4">4</span><span class="s2">])[</span><span class="s4">0</span><span class="s2">]</span>
    <span class="s1">pos </span><span class="s2">= </span><span class="s4">4</span>
    <span class="s0">if </span><span class="s2">(</span><span class="s1">flags </span><span class="s2">&amp; </span><span class="s1">EMBEDDED_PEAK_TUPLE</span><span class="s2">) == </span><span class="s4">0</span><span class="s2">:</span>
        <span class="s1">peak </span><span class="s2">= </span><span class="s1">sharedTuples</span><span class="s2">[</span><span class="s1">flags </span><span class="s2">&amp; </span><span class="s1">TUPLE_INDEX_MASK</span><span class="s2">]</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">peak</span><span class="s2">, </span><span class="s1">pos </span><span class="s2">= </span><span class="s1">TupleVariation</span><span class="s2">.</span><span class="s1">decompileCoord_</span><span class="s2">(</span><span class="s1">axisTags</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">pos</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s2">(</span><span class="s1">flags </span><span class="s2">&amp; </span><span class="s1">INTERMEDIATE_REGION</span><span class="s2">) != </span><span class="s4">0</span><span class="s2">:</span>
        <span class="s1">start</span><span class="s2">, </span><span class="s1">pos </span><span class="s2">= </span><span class="s1">TupleVariation</span><span class="s2">.</span><span class="s1">decompileCoord_</span><span class="s2">(</span><span class="s1">axisTags</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">pos</span><span class="s2">)</span>
        <span class="s1">end</span><span class="s2">, </span><span class="s1">pos </span><span class="s2">= </span><span class="s1">TupleVariation</span><span class="s2">.</span><span class="s1">decompileCoord_</span><span class="s2">(</span><span class="s1">axisTags</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">pos</span><span class="s2">)</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">start</span><span class="s2">, </span><span class="s1">end </span><span class="s2">= </span><span class="s1">inferRegion_</span><span class="s2">(</span><span class="s1">peak</span><span class="s2">)</span>
    <span class="s1">axes </span><span class="s2">= {}</span>
    <span class="s0">for </span><span class="s1">axis </span><span class="s0">in </span><span class="s1">axisTags</span><span class="s2">:</span>
        <span class="s1">region </span><span class="s2">= </span><span class="s1">start</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">], </span><span class="s1">peak</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">], </span><span class="s1">end</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">]</span>
        <span class="s0">if </span><span class="s1">region </span><span class="s2">!= (</span><span class="s4">0.0</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">):</span>
            <span class="s1">axes</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">] = </span><span class="s1">region</span>
    <span class="s1">pos </span><span class="s2">= </span><span class="s4">0</span>
    <span class="s0">if </span><span class="s2">(</span><span class="s1">flags </span><span class="s2">&amp; </span><span class="s1">PRIVATE_POINT_NUMBERS</span><span class="s2">) != </span><span class="s4">0</span><span class="s2">:</span>
        <span class="s1">points</span><span class="s2">, </span><span class="s1">pos </span><span class="s2">= </span><span class="s1">TupleVariation</span><span class="s2">.</span><span class="s1">decompilePoints_</span><span class="s2">(</span>
            <span class="s1">pointCount</span><span class="s2">, </span><span class="s1">tupleData</span><span class="s2">, </span><span class="s1">pos</span><span class="s2">, </span><span class="s1">tableTag</span>
        <span class="s2">)</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">points </span><span class="s2">= </span><span class="s1">sharedPoints</span>

    <span class="s1">deltas </span><span class="s2">= [</span><span class="s0">None</span><span class="s2">] * </span><span class="s1">pointCount</span>

    <span class="s0">if </span><span class="s1">tableTag </span><span class="s2">== </span><span class="s5">&quot;cvar&quot;</span><span class="s2">:</span>
        <span class="s1">deltas_cvt</span><span class="s2">, </span><span class="s1">pos </span><span class="s2">= </span><span class="s1">TupleVariation</span><span class="s2">.</span><span class="s1">decompileDeltas_</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">points</span><span class="s2">), </span><span class="s1">tupleData</span><span class="s2">, </span><span class="s1">pos</span><span class="s2">)</span>
        <span class="s0">for </span><span class="s1">p</span><span class="s2">, </span><span class="s1">delta </span><span class="s0">in </span><span class="s1">zip</span><span class="s2">(</span><span class="s1">points</span><span class="s2">, </span><span class="s1">deltas_cvt</span><span class="s2">):</span>
            <span class="s0">if </span><span class="s4">0 </span><span class="s2">&lt;= </span><span class="s1">p </span><span class="s2">&lt; </span><span class="s1">pointCount</span><span class="s2">:</span>
                <span class="s1">deltas</span><span class="s2">[</span><span class="s1">p</span><span class="s2">] = </span><span class="s1">delta</span>

    <span class="s0">elif </span><span class="s1">tableTag </span><span class="s2">== </span><span class="s5">&quot;gvar&quot;</span><span class="s2">:</span>
        <span class="s1">deltas_x</span><span class="s2">, </span><span class="s1">pos </span><span class="s2">= </span><span class="s1">TupleVariation</span><span class="s2">.</span><span class="s1">decompileDeltas_</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">points</span><span class="s2">), </span><span class="s1">tupleData</span><span class="s2">, </span><span class="s1">pos</span><span class="s2">)</span>
        <span class="s1">deltas_y</span><span class="s2">, </span><span class="s1">pos </span><span class="s2">= </span><span class="s1">TupleVariation</span><span class="s2">.</span><span class="s1">decompileDeltas_</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">points</span><span class="s2">), </span><span class="s1">tupleData</span><span class="s2">, </span><span class="s1">pos</span><span class="s2">)</span>
        <span class="s0">for </span><span class="s1">p</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y </span><span class="s0">in </span><span class="s1">zip</span><span class="s2">(</span><span class="s1">points</span><span class="s2">, </span><span class="s1">deltas_x</span><span class="s2">, </span><span class="s1">deltas_y</span><span class="s2">):</span>
            <span class="s0">if </span><span class="s4">0 </span><span class="s2">&lt;= </span><span class="s1">p </span><span class="s2">&lt; </span><span class="s1">pointCount</span><span class="s2">:</span>
                <span class="s1">deltas</span><span class="s2">[</span><span class="s1">p</span><span class="s2">] = (</span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">)</span>

    <span class="s0">return </span><span class="s1">TupleVariation</span><span class="s2">(</span><span class="s1">axes</span><span class="s2">, </span><span class="s1">deltas</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">inferRegion_</span><span class="s2">(</span><span class="s1">peak</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot;Infer start and end for a (non-intermediate) region 
 
    This helper function computes the applicability region for 
    variation tuples whose INTERMEDIATE_REGION flag is not set in the 
    TupleVariationHeader structure.  Variation tuples apply only to 
    certain regions of the variation space; outside that region, the 
    tuple has no effect.  To make the binary encoding more compact, 
    TupleVariationHeaders can omit the intermediateStartTuple and 
    intermediateEndTuple fields. 
    &quot;&quot;&quot;</span>
    <span class="s1">start</span><span class="s2">, </span><span class="s1">end </span><span class="s2">= {}, {}</span>
    <span class="s0">for </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">value </span><span class="s0">in </span><span class="s1">peak</span><span class="s2">.</span><span class="s1">items</span><span class="s2">():</span>
        <span class="s1">start</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">] = </span><span class="s1">min</span><span class="s2">(</span><span class="s1">value</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">)  </span><span class="s3"># -0.3 --&gt; -0.3; 0.7 --&gt; 0.0</span>
        <span class="s1">end</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">] = </span><span class="s1">max</span><span class="s2">(</span><span class="s1">value</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">)  </span><span class="s3"># -0.3 --&gt;  0.0; 0.7 --&gt; 0.7</span>
    <span class="s0">return </span><span class="s2">(</span><span class="s1">start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">)</span>
</pre>
</body>
</html>