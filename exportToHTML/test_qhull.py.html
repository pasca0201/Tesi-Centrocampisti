<html>
<head>
<title>test_qhull.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #2aacb8;}
.s4 { color: #7a7e85;}
.s5 { color: #6aab73;}
.s6 { color: #5f826b; font-style: italic;}
.s7 { color: #a5c261;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_qhull.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">os</span>
<span class="s0">import </span><span class="s1">copy</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">from </span><span class="s1">numpy</span><span class="s2">.</span><span class="s1">testing </span><span class="s0">import </span><span class="s2">(</span><span class="s1">assert_equal</span><span class="s2">, </span><span class="s1">assert_almost_equal</span><span class="s2">,</span>
                           <span class="s1">assert_</span><span class="s2">, </span><span class="s1">assert_allclose</span><span class="s2">, </span><span class="s1">assert_array_equal</span><span class="s2">)</span>
<span class="s0">import </span><span class="s1">pytest</span>
<span class="s0">from </span><span class="s1">pytest </span><span class="s0">import </span><span class="s1">raises </span><span class="s0">as </span><span class="s1">assert_raises</span>

<span class="s0">import </span><span class="s1">scipy</span><span class="s2">.</span><span class="s1">spatial</span><span class="s2">.</span><span class="s1">_qhull </span><span class="s0">as </span><span class="s1">qhull</span>
<span class="s0">from </span><span class="s1">scipy</span><span class="s2">.</span><span class="s1">spatial </span><span class="s0">import </span><span class="s1">cKDTree </span><span class="s0">as </span><span class="s1">KDTree</span>
<span class="s0">from </span><span class="s1">scipy</span><span class="s2">.</span><span class="s1">spatial </span><span class="s0">import </span><span class="s1">Voronoi</span>

<span class="s0">import </span><span class="s1">itertools</span>

<span class="s0">def </span><span class="s1">sorted_tuple</span><span class="s2">(</span><span class="s1">x</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">sorted</span><span class="s2">(</span><span class="s1">x</span><span class="s2">))</span>


<span class="s0">def </span><span class="s1">assert_unordered_tuple_list_equal</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">tpl</span><span class="s2">=</span><span class="s1">tuple</span><span class="s2">):</span>
    <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">):</span>
        <span class="s1">a </span><span class="s2">= </span><span class="s1">a</span><span class="s2">.</span><span class="s1">tolist</span><span class="s2">()</span>
    <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">b</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">):</span>
        <span class="s1">b </span><span class="s2">= </span><span class="s1">b</span><span class="s2">.</span><span class="s1">tolist</span><span class="s2">()</span>
    <span class="s1">a </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">map</span><span class="s2">(</span><span class="s1">tpl</span><span class="s2">, </span><span class="s1">a</span><span class="s2">))</span>
    <span class="s1">a</span><span class="s2">.</span><span class="s1">sort</span><span class="s2">()</span>
    <span class="s1">b </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">map</span><span class="s2">(</span><span class="s1">tpl</span><span class="s2">, </span><span class="s1">b</span><span class="s2">))</span>
    <span class="s1">b</span><span class="s2">.</span><span class="s1">sort</span><span class="s2">()</span>
    <span class="s1">assert_equal</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">)</span>


<span class="s1">np</span><span class="s2">.</span><span class="s1">random</span><span class="s2">.</span><span class="s1">seed</span><span class="s2">(</span><span class="s3">1234</span><span class="s2">)</span>

<span class="s1">points </span><span class="s2">= [(</span><span class="s3">0</span><span class="s2">,</span><span class="s3">0</span><span class="s2">), (</span><span class="s3">0</span><span class="s2">,</span><span class="s3">1</span><span class="s2">), (</span><span class="s3">1</span><span class="s2">,</span><span class="s3">0</span><span class="s2">), (</span><span class="s3">1</span><span class="s2">,</span><span class="s3">1</span><span class="s2">), (</span><span class="s3">0.5</span><span class="s2">, </span><span class="s3">0.5</span><span class="s2">), (</span><span class="s3">0.5</span><span class="s2">, </span><span class="s3">1.5</span><span class="s2">)]</span>

<span class="s1">pathological_data_1 </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span>
    <span class="s2">[-</span><span class="s3">3.14</span><span class="s2">,-</span><span class="s3">3.14</span><span class="s2">], [-</span><span class="s3">3.14</span><span class="s2">,-</span><span class="s3">2.36</span><span class="s2">], [-</span><span class="s3">3.14</span><span class="s2">,-</span><span class="s3">1.57</span><span class="s2">], [-</span><span class="s3">3.14</span><span class="s2">,-</span><span class="s3">0.79</span><span class="s2">],</span>
    <span class="s2">[-</span><span class="s3">3.14</span><span class="s2">,</span><span class="s3">0.0</span><span class="s2">], [-</span><span class="s3">3.14</span><span class="s2">,</span><span class="s3">0.79</span><span class="s2">], [-</span><span class="s3">3.14</span><span class="s2">,</span><span class="s3">1.57</span><span class="s2">], [-</span><span class="s3">3.14</span><span class="s2">,</span><span class="s3">2.36</span><span class="s2">],</span>
    <span class="s2">[-</span><span class="s3">3.14</span><span class="s2">,</span><span class="s3">3.14</span><span class="s2">], [-</span><span class="s3">2.36</span><span class="s2">,-</span><span class="s3">3.14</span><span class="s2">], [-</span><span class="s3">2.36</span><span class="s2">,-</span><span class="s3">2.36</span><span class="s2">], [-</span><span class="s3">2.36</span><span class="s2">,-</span><span class="s3">1.57</span><span class="s2">],</span>
    <span class="s2">[-</span><span class="s3">2.36</span><span class="s2">,-</span><span class="s3">0.79</span><span class="s2">], [-</span><span class="s3">2.36</span><span class="s2">,</span><span class="s3">0.0</span><span class="s2">], [-</span><span class="s3">2.36</span><span class="s2">,</span><span class="s3">0.79</span><span class="s2">], [-</span><span class="s3">2.36</span><span class="s2">,</span><span class="s3">1.57</span><span class="s2">],</span>
    <span class="s2">[-</span><span class="s3">2.36</span><span class="s2">,</span><span class="s3">2.36</span><span class="s2">], [-</span><span class="s3">2.36</span><span class="s2">,</span><span class="s3">3.14</span><span class="s2">], [-</span><span class="s3">1.57</span><span class="s2">,-</span><span class="s3">0.79</span><span class="s2">], [-</span><span class="s3">1.57</span><span class="s2">,</span><span class="s3">0.79</span><span class="s2">],</span>
    <span class="s2">[-</span><span class="s3">1.57</span><span class="s2">,-</span><span class="s3">1.57</span><span class="s2">], [-</span><span class="s3">1.57</span><span class="s2">,</span><span class="s3">0.0</span><span class="s2">], [-</span><span class="s3">1.57</span><span class="s2">,</span><span class="s3">1.57</span><span class="s2">], [-</span><span class="s3">1.57</span><span class="s2">,-</span><span class="s3">3.14</span><span class="s2">],</span>
    <span class="s2">[-</span><span class="s3">1.57</span><span class="s2">,-</span><span class="s3">2.36</span><span class="s2">], [-</span><span class="s3">1.57</span><span class="s2">,</span><span class="s3">2.36</span><span class="s2">], [-</span><span class="s3">1.57</span><span class="s2">,</span><span class="s3">3.14</span><span class="s2">], [-</span><span class="s3">0.79</span><span class="s2">,-</span><span class="s3">1.57</span><span class="s2">],</span>
    <span class="s2">[-</span><span class="s3">0.79</span><span class="s2">,</span><span class="s3">1.57</span><span class="s2">], [-</span><span class="s3">0.79</span><span class="s2">,-</span><span class="s3">3.14</span><span class="s2">], [-</span><span class="s3">0.79</span><span class="s2">,-</span><span class="s3">2.36</span><span class="s2">], [-</span><span class="s3">0.79</span><span class="s2">,-</span><span class="s3">0.79</span><span class="s2">],</span>
    <span class="s2">[-</span><span class="s3">0.79</span><span class="s2">,</span><span class="s3">0.0</span><span class="s2">], [-</span><span class="s3">0.79</span><span class="s2">,</span><span class="s3">0.79</span><span class="s2">], [-</span><span class="s3">0.79</span><span class="s2">,</span><span class="s3">2.36</span><span class="s2">], [-</span><span class="s3">0.79</span><span class="s2">,</span><span class="s3">3.14</span><span class="s2">],</span>
    <span class="s2">[</span><span class="s3">0.0</span><span class="s2">,-</span><span class="s3">3.14</span><span class="s2">], [</span><span class="s3">0.0</span><span class="s2">,-</span><span class="s3">2.36</span><span class="s2">], [</span><span class="s3">0.0</span><span class="s2">,-</span><span class="s3">1.57</span><span class="s2">], [</span><span class="s3">0.0</span><span class="s2">,-</span><span class="s3">0.79</span><span class="s2">], [</span><span class="s3">0.0</span><span class="s2">,</span><span class="s3">0.0</span><span class="s2">],</span>
    <span class="s2">[</span><span class="s3">0.0</span><span class="s2">,</span><span class="s3">0.79</span><span class="s2">], [</span><span class="s3">0.0</span><span class="s2">,</span><span class="s3">1.57</span><span class="s2">], [</span><span class="s3">0.0</span><span class="s2">,</span><span class="s3">2.36</span><span class="s2">], [</span><span class="s3">0.0</span><span class="s2">,</span><span class="s3">3.14</span><span class="s2">], [</span><span class="s3">0.79</span><span class="s2">,-</span><span class="s3">3.14</span><span class="s2">],</span>
    <span class="s2">[</span><span class="s3">0.79</span><span class="s2">,-</span><span class="s3">2.36</span><span class="s2">], [</span><span class="s3">0.79</span><span class="s2">,-</span><span class="s3">0.79</span><span class="s2">], [</span><span class="s3">0.79</span><span class="s2">,</span><span class="s3">0.0</span><span class="s2">], [</span><span class="s3">0.79</span><span class="s2">,</span><span class="s3">0.79</span><span class="s2">],</span>
    <span class="s2">[</span><span class="s3">0.79</span><span class="s2">,</span><span class="s3">2.36</span><span class="s2">], [</span><span class="s3">0.79</span><span class="s2">,</span><span class="s3">3.14</span><span class="s2">], [</span><span class="s3">0.79</span><span class="s2">,-</span><span class="s3">1.57</span><span class="s2">], [</span><span class="s3">0.79</span><span class="s2">,</span><span class="s3">1.57</span><span class="s2">],</span>
    <span class="s2">[</span><span class="s3">1.57</span><span class="s2">,-</span><span class="s3">3.14</span><span class="s2">], [</span><span class="s3">1.57</span><span class="s2">,-</span><span class="s3">2.36</span><span class="s2">], [</span><span class="s3">1.57</span><span class="s2">,</span><span class="s3">2.36</span><span class="s2">], [</span><span class="s3">1.57</span><span class="s2">,</span><span class="s3">3.14</span><span class="s2">],</span>
    <span class="s2">[</span><span class="s3">1.57</span><span class="s2">,-</span><span class="s3">1.57</span><span class="s2">], [</span><span class="s3">1.57</span><span class="s2">,</span><span class="s3">0.0</span><span class="s2">], [</span><span class="s3">1.57</span><span class="s2">,</span><span class="s3">1.57</span><span class="s2">], [</span><span class="s3">1.57</span><span class="s2">,-</span><span class="s3">0.79</span><span class="s2">],</span>
    <span class="s2">[</span><span class="s3">1.57</span><span class="s2">,</span><span class="s3">0.79</span><span class="s2">], [</span><span class="s3">2.36</span><span class="s2">,-</span><span class="s3">3.14</span><span class="s2">], [</span><span class="s3">2.36</span><span class="s2">,-</span><span class="s3">2.36</span><span class="s2">], [</span><span class="s3">2.36</span><span class="s2">,-</span><span class="s3">1.57</span><span class="s2">],</span>
    <span class="s2">[</span><span class="s3">2.36</span><span class="s2">,-</span><span class="s3">0.79</span><span class="s2">], [</span><span class="s3">2.36</span><span class="s2">,</span><span class="s3">0.0</span><span class="s2">], [</span><span class="s3">2.36</span><span class="s2">,</span><span class="s3">0.79</span><span class="s2">], [</span><span class="s3">2.36</span><span class="s2">,</span><span class="s3">1.57</span><span class="s2">],</span>
    <span class="s2">[</span><span class="s3">2.36</span><span class="s2">,</span><span class="s3">2.36</span><span class="s2">], [</span><span class="s3">2.36</span><span class="s2">,</span><span class="s3">3.14</span><span class="s2">], [</span><span class="s3">3.14</span><span class="s2">,-</span><span class="s3">3.14</span><span class="s2">], [</span><span class="s3">3.14</span><span class="s2">,-</span><span class="s3">2.36</span><span class="s2">],</span>
    <span class="s2">[</span><span class="s3">3.14</span><span class="s2">,-</span><span class="s3">1.57</span><span class="s2">], [</span><span class="s3">3.14</span><span class="s2">,-</span><span class="s3">0.79</span><span class="s2">], [</span><span class="s3">3.14</span><span class="s2">,</span><span class="s3">0.0</span><span class="s2">], [</span><span class="s3">3.14</span><span class="s2">,</span><span class="s3">0.79</span><span class="s2">],</span>
    <span class="s2">[</span><span class="s3">3.14</span><span class="s2">,</span><span class="s3">1.57</span><span class="s2">], [</span><span class="s3">3.14</span><span class="s2">,</span><span class="s3">2.36</span><span class="s2">], [</span><span class="s3">3.14</span><span class="s2">,</span><span class="s3">3.14</span><span class="s2">],</span>
<span class="s2">])</span>

<span class="s1">pathological_data_2 </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span>
    <span class="s2">[-</span><span class="s3">1</span><span class="s2">, -</span><span class="s3">1</span><span class="s2">], [-</span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">], [-</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">],</span>
    <span class="s2">[</span><span class="s3">0</span><span class="s2">, -</span><span class="s3">1</span><span class="s2">], [</span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">], [</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">],</span>
    <span class="s2">[</span><span class="s3">1</span><span class="s2">, -</span><span class="s3">1 </span><span class="s2">- </span><span class="s1">np</span><span class="s2">.</span><span class="s1">finfo</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">).</span><span class="s1">eps</span><span class="s2">], [</span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">], [</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">],</span>
<span class="s2">])</span>

<span class="s1">bug_2850_chunks </span><span class="s2">= [</span><span class="s1">np</span><span class="s2">.</span><span class="s1">random</span><span class="s2">.</span><span class="s1">rand</span><span class="s2">(</span><span class="s3">10</span><span class="s2">, </span><span class="s3">2</span><span class="s2">),</span>
                   <span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([[</span><span class="s3">0</span><span class="s2">,</span><span class="s3">0</span><span class="s2">], [</span><span class="s3">0</span><span class="s2">,</span><span class="s3">1</span><span class="s2">], [</span><span class="s3">1</span><span class="s2">,</span><span class="s3">0</span><span class="s2">], [</span><span class="s3">1</span><span class="s2">,</span><span class="s3">1</span><span class="s2">]])  </span><span class="s4"># add corners</span>
                   <span class="s2">]</span>

<span class="s4"># same with some additional chunks</span>
<span class="s1">bug_2850_chunks_2 </span><span class="s2">= (</span><span class="s1">bug_2850_chunks </span><span class="s2">+</span>
                     <span class="s2">[</span><span class="s1">np</span><span class="s2">.</span><span class="s1">random</span><span class="s2">.</span><span class="s1">rand</span><span class="s2">(</span><span class="s3">10</span><span class="s2">, </span><span class="s3">2</span><span class="s2">),</span>
                      <span class="s3">0.25 </span><span class="s2">+ </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([[</span><span class="s3">0</span><span class="s2">,</span><span class="s3">0</span><span class="s2">], [</span><span class="s3">0</span><span class="s2">,</span><span class="s3">1</span><span class="s2">], [</span><span class="s3">1</span><span class="s2">,</span><span class="s3">0</span><span class="s2">], [</span><span class="s3">1</span><span class="s2">,</span><span class="s3">1</span><span class="s2">]])])</span>

<span class="s1">DATASETS </span><span class="s2">= {</span>
    <span class="s5">'some-points'</span><span class="s2">: </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">points</span><span class="s2">),</span>
    <span class="s5">'random-2d'</span><span class="s2">: </span><span class="s1">np</span><span class="s2">.</span><span class="s1">random</span><span class="s2">.</span><span class="s1">rand</span><span class="s2">(</span><span class="s3">30</span><span class="s2">, </span><span class="s3">2</span><span class="s2">),</span>
    <span class="s5">'random-3d'</span><span class="s2">: </span><span class="s1">np</span><span class="s2">.</span><span class="s1">random</span><span class="s2">.</span><span class="s1">rand</span><span class="s2">(</span><span class="s3">30</span><span class="s2">, </span><span class="s3">3</span><span class="s2">),</span>
    <span class="s5">'random-4d'</span><span class="s2">: </span><span class="s1">np</span><span class="s2">.</span><span class="s1">random</span><span class="s2">.</span><span class="s1">rand</span><span class="s2">(</span><span class="s3">30</span><span class="s2">, </span><span class="s3">4</span><span class="s2">),</span>
    <span class="s5">'random-5d'</span><span class="s2">: </span><span class="s1">np</span><span class="s2">.</span><span class="s1">random</span><span class="s2">.</span><span class="s1">rand</span><span class="s2">(</span><span class="s3">30</span><span class="s2">, </span><span class="s3">5</span><span class="s2">),</span>
    <span class="s5">'random-6d'</span><span class="s2">: </span><span class="s1">np</span><span class="s2">.</span><span class="s1">random</span><span class="s2">.</span><span class="s1">rand</span><span class="s2">(</span><span class="s3">10</span><span class="s2">, </span><span class="s3">6</span><span class="s2">),</span>
    <span class="s5">'random-7d'</span><span class="s2">: </span><span class="s1">np</span><span class="s2">.</span><span class="s1">random</span><span class="s2">.</span><span class="s1">rand</span><span class="s2">(</span><span class="s3">10</span><span class="s2">, </span><span class="s3">7</span><span class="s2">),</span>
    <span class="s5">'random-8d'</span><span class="s2">: </span><span class="s1">np</span><span class="s2">.</span><span class="s1">random</span><span class="s2">.</span><span class="s1">rand</span><span class="s2">(</span><span class="s3">10</span><span class="s2">, </span><span class="s3">8</span><span class="s2">),</span>
    <span class="s5">'pathological-1'</span><span class="s2">: </span><span class="s1">pathological_data_1</span><span class="s2">,</span>
    <span class="s5">'pathological-2'</span><span class="s2">: </span><span class="s1">pathological_data_2</span>
<span class="s2">}</span>

<span class="s1">INCREMENTAL_DATASETS </span><span class="s2">= {</span>
    <span class="s5">'bug-2850'</span><span class="s2">: (</span><span class="s1">bug_2850_chunks</span><span class="s2">, </span><span class="s0">None</span><span class="s2">),</span>
    <span class="s5">'bug-2850-2'</span><span class="s2">: (</span><span class="s1">bug_2850_chunks_2</span><span class="s2">, </span><span class="s0">None</span><span class="s2">),</span>
<span class="s2">}</span>


<span class="s0">def </span><span class="s1">_add_inc_data</span><span class="s2">(</span><span class="s1">name</span><span class="s2">, </span><span class="s1">chunksize</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Generate incremental datasets from basic data sets 
    &quot;&quot;&quot;</span>
    <span class="s1">points </span><span class="s2">= </span><span class="s1">DATASETS</span><span class="s2">[</span><span class="s1">name</span><span class="s2">]</span>
    <span class="s1">ndim </span><span class="s2">= </span><span class="s1">points</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s3">1</span><span class="s2">]</span>

    <span class="s1">opts </span><span class="s2">= </span><span class="s0">None</span>
    <span class="s1">nmin </span><span class="s2">= </span><span class="s1">ndim </span><span class="s2">+ </span><span class="s3">2</span>

    <span class="s0">if </span><span class="s1">name </span><span class="s2">== </span><span class="s5">'some-points'</span><span class="s2">:</span>
        <span class="s4"># since Qz is not allowed, use QJ</span>
        <span class="s1">opts </span><span class="s2">= </span><span class="s5">'QJ Pp'</span>
    <span class="s0">elif </span><span class="s1">name </span><span class="s2">== </span><span class="s5">'pathological-1'</span><span class="s2">:</span>
        <span class="s4"># include enough points so that we get different x-coordinates</span>
        <span class="s1">nmin </span><span class="s2">= </span><span class="s3">12</span>

    <span class="s1">chunks </span><span class="s2">= [</span><span class="s1">points</span><span class="s2">[:</span><span class="s1">nmin</span><span class="s2">]]</span>
    <span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">nmin</span><span class="s2">, </span><span class="s1">len</span><span class="s2">(</span><span class="s1">points</span><span class="s2">), </span><span class="s1">chunksize</span><span class="s2">):</span>
        <span class="s1">chunks</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">points</span><span class="s2">[</span><span class="s1">j</span><span class="s2">:</span><span class="s1">j</span><span class="s2">+</span><span class="s1">chunksize</span><span class="s2">])</span>

    <span class="s1">new_name </span><span class="s2">= </span><span class="s5">&quot;%s-chunk-%d&quot; </span><span class="s2">% (</span><span class="s1">name</span><span class="s2">, </span><span class="s1">chunksize</span><span class="s2">)</span>
    <span class="s0">assert </span><span class="s1">new_name </span><span class="s0">not in </span><span class="s1">INCREMENTAL_DATASETS</span>
    <span class="s1">INCREMENTAL_DATASETS</span><span class="s2">[</span><span class="s1">new_name</span><span class="s2">] = (</span><span class="s1">chunks</span><span class="s2">, </span><span class="s1">opts</span><span class="s2">)</span>


<span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">DATASETS</span><span class="s2">:</span>
    <span class="s0">for </span><span class="s1">chunksize </span><span class="s0">in </span><span class="s3">1</span><span class="s2">, </span><span class="s3">4</span><span class="s2">, </span><span class="s3">16</span><span class="s2">:</span>
        <span class="s1">_add_inc_data</span><span class="s2">(</span><span class="s1">name</span><span class="s2">, </span><span class="s1">chunksize</span><span class="s2">)</span>


<span class="s0">class </span><span class="s1">Test_Qhull</span><span class="s2">:</span>
    <span class="s0">def </span><span class="s1">test_swapping</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s4"># Check that Qhull state swapping works</span>

        <span class="s1">x </span><span class="s2">= </span><span class="s1">qhull</span><span class="s2">.</span><span class="s1">_Qhull</span><span class="s2">(</span><span class="s7">b'v'</span><span class="s2">,</span>
                         <span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([[</span><span class="s3">0</span><span class="s2">,</span><span class="s3">0</span><span class="s2">],[</span><span class="s3">0</span><span class="s2">,</span><span class="s3">1</span><span class="s2">],[</span><span class="s3">1</span><span class="s2">,</span><span class="s3">0</span><span class="s2">],[</span><span class="s3">1</span><span class="s2">,</span><span class="s3">1.</span><span class="s2">],[</span><span class="s3">0.5</span><span class="s2">,</span><span class="s3">0.5</span><span class="s2">]]),</span>
                         <span class="s7">b'Qz'</span><span class="s2">)</span>
        <span class="s1">xd </span><span class="s2">= </span><span class="s1">copy</span><span class="s2">.</span><span class="s1">deepcopy</span><span class="s2">(</span><span class="s1">x</span><span class="s2">.</span><span class="s1">get_voronoi_diagram</span><span class="s2">())</span>

        <span class="s1">y </span><span class="s2">= </span><span class="s1">qhull</span><span class="s2">.</span><span class="s1">_Qhull</span><span class="s2">(</span><span class="s7">b'v'</span><span class="s2">,</span>
                         <span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([[</span><span class="s3">0</span><span class="s2">,</span><span class="s3">0</span><span class="s2">],[</span><span class="s3">0</span><span class="s2">,</span><span class="s3">1</span><span class="s2">],[</span><span class="s3">1</span><span class="s2">,</span><span class="s3">0</span><span class="s2">],[</span><span class="s3">1</span><span class="s2">,</span><span class="s3">2.</span><span class="s2">]]),</span>
                         <span class="s7">b'Qz'</span><span class="s2">)</span>
        <span class="s1">yd </span><span class="s2">= </span><span class="s1">copy</span><span class="s2">.</span><span class="s1">deepcopy</span><span class="s2">(</span><span class="s1">y</span><span class="s2">.</span><span class="s1">get_voronoi_diagram</span><span class="s2">())</span>

        <span class="s1">xd2 </span><span class="s2">= </span><span class="s1">copy</span><span class="s2">.</span><span class="s1">deepcopy</span><span class="s2">(</span><span class="s1">x</span><span class="s2">.</span><span class="s1">get_voronoi_diagram</span><span class="s2">())</span>
        <span class="s1">x</span><span class="s2">.</span><span class="s1">close</span><span class="s2">()</span>
        <span class="s1">yd2 </span><span class="s2">= </span><span class="s1">copy</span><span class="s2">.</span><span class="s1">deepcopy</span><span class="s2">(</span><span class="s1">y</span><span class="s2">.</span><span class="s1">get_voronoi_diagram</span><span class="s2">())</span>
        <span class="s1">y</span><span class="s2">.</span><span class="s1">close</span><span class="s2">()</span>

        <span class="s1">assert_raises</span><span class="s2">(</span><span class="s1">RuntimeError</span><span class="s2">, </span><span class="s1">x</span><span class="s2">.</span><span class="s1">get_voronoi_diagram</span><span class="s2">)</span>
        <span class="s1">assert_raises</span><span class="s2">(</span><span class="s1">RuntimeError</span><span class="s2">, </span><span class="s1">y</span><span class="s2">.</span><span class="s1">get_voronoi_diagram</span><span class="s2">)</span>

        <span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">xd</span><span class="s2">[</span><span class="s3">0</span><span class="s2">], </span><span class="s1">xd2</span><span class="s2">[</span><span class="s3">0</span><span class="s2">])</span>
        <span class="s1">assert_unordered_tuple_list_equal</span><span class="s2">(</span><span class="s1">xd</span><span class="s2">[</span><span class="s3">1</span><span class="s2">], </span><span class="s1">xd2</span><span class="s2">[</span><span class="s3">1</span><span class="s2">], </span><span class="s1">tpl</span><span class="s2">=</span><span class="s1">sorted_tuple</span><span class="s2">)</span>
        <span class="s1">assert_unordered_tuple_list_equal</span><span class="s2">(</span><span class="s1">xd</span><span class="s2">[</span><span class="s3">2</span><span class="s2">], </span><span class="s1">xd2</span><span class="s2">[</span><span class="s3">2</span><span class="s2">], </span><span class="s1">tpl</span><span class="s2">=</span><span class="s1">sorted_tuple</span><span class="s2">)</span>
        <span class="s1">assert_unordered_tuple_list_equal</span><span class="s2">(</span><span class="s1">xd</span><span class="s2">[</span><span class="s3">3</span><span class="s2">], </span><span class="s1">xd2</span><span class="s2">[</span><span class="s3">3</span><span class="s2">], </span><span class="s1">tpl</span><span class="s2">=</span><span class="s1">sorted_tuple</span><span class="s2">)</span>
        <span class="s1">assert_array_equal</span><span class="s2">(</span><span class="s1">xd</span><span class="s2">[</span><span class="s3">4</span><span class="s2">], </span><span class="s1">xd2</span><span class="s2">[</span><span class="s3">4</span><span class="s2">])</span>

        <span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">yd</span><span class="s2">[</span><span class="s3">0</span><span class="s2">], </span><span class="s1">yd2</span><span class="s2">[</span><span class="s3">0</span><span class="s2">])</span>
        <span class="s1">assert_unordered_tuple_list_equal</span><span class="s2">(</span><span class="s1">yd</span><span class="s2">[</span><span class="s3">1</span><span class="s2">], </span><span class="s1">yd2</span><span class="s2">[</span><span class="s3">1</span><span class="s2">], </span><span class="s1">tpl</span><span class="s2">=</span><span class="s1">sorted_tuple</span><span class="s2">)</span>
        <span class="s1">assert_unordered_tuple_list_equal</span><span class="s2">(</span><span class="s1">yd</span><span class="s2">[</span><span class="s3">2</span><span class="s2">], </span><span class="s1">yd2</span><span class="s2">[</span><span class="s3">2</span><span class="s2">], </span><span class="s1">tpl</span><span class="s2">=</span><span class="s1">sorted_tuple</span><span class="s2">)</span>
        <span class="s1">assert_unordered_tuple_list_equal</span><span class="s2">(</span><span class="s1">yd</span><span class="s2">[</span><span class="s3">3</span><span class="s2">], </span><span class="s1">yd2</span><span class="s2">[</span><span class="s3">3</span><span class="s2">], </span><span class="s1">tpl</span><span class="s2">=</span><span class="s1">sorted_tuple</span><span class="s2">)</span>
        <span class="s1">assert_array_equal</span><span class="s2">(</span><span class="s1">yd</span><span class="s2">[</span><span class="s3">4</span><span class="s2">], </span><span class="s1">yd2</span><span class="s2">[</span><span class="s3">4</span><span class="s2">])</span>

        <span class="s1">x</span><span class="s2">.</span><span class="s1">close</span><span class="s2">()</span>
        <span class="s1">assert_raises</span><span class="s2">(</span><span class="s1">RuntimeError</span><span class="s2">, </span><span class="s1">x</span><span class="s2">.</span><span class="s1">get_voronoi_diagram</span><span class="s2">)</span>
        <span class="s1">y</span><span class="s2">.</span><span class="s1">close</span><span class="s2">()</span>
        <span class="s1">assert_raises</span><span class="s2">(</span><span class="s1">RuntimeError</span><span class="s2">, </span><span class="s1">y</span><span class="s2">.</span><span class="s1">get_voronoi_diagram</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">test_issue_8051</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">points </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">(</span>
            <span class="s2">[[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">], [</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">], [</span><span class="s3">0</span><span class="s2">, </span><span class="s3">2</span><span class="s2">], [</span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">], [</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">], [</span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">],[</span><span class="s3">2</span><span class="s2">, </span><span class="s3">0</span><span class="s2">], [</span><span class="s3">2</span><span class="s2">, </span><span class="s3">1</span><span class="s2">], [</span><span class="s3">2</span><span class="s2">, </span><span class="s3">2</span><span class="s2">]]</span>
        <span class="s2">)</span>
        <span class="s1">Voronoi</span><span class="s2">(</span><span class="s1">points</span><span class="s2">)</span>


<span class="s0">class </span><span class="s1">TestUtilities</span><span class="s2">:</span>
    <span class="s6">&quot;&quot;&quot; 
    Check that utility functions work. 
 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">test_find_simplex</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s4"># Simple check that simplex finding works</span>
        <span class="s1">points </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([(</span><span class="s3">0</span><span class="s2">,</span><span class="s3">0</span><span class="s2">), (</span><span class="s3">0</span><span class="s2">,</span><span class="s3">1</span><span class="s2">), (</span><span class="s3">1</span><span class="s2">,</span><span class="s3">1</span><span class="s2">), (</span><span class="s3">1</span><span class="s2">,</span><span class="s3">0</span><span class="s2">)], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">)</span>
        <span class="s1">tri </span><span class="s2">= </span><span class="s1">qhull</span><span class="s2">.</span><span class="s1">Delaunay</span><span class="s2">(</span><span class="s1">points</span><span class="s2">)</span>

        <span class="s4"># +---+</span>
        <span class="s4"># |\ 0|</span>
        <span class="s4"># | \ |</span>
        <span class="s4"># |1 \|</span>
        <span class="s4"># +---+</span>

        <span class="s1">assert_equal</span><span class="s2">(</span><span class="s1">tri</span><span class="s2">.</span><span class="s1">simplices</span><span class="s2">, [[</span><span class="s3">1</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">2</span><span class="s2">], [</span><span class="s3">3</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">]])</span>

        <span class="s0">for </span><span class="s1">p </span><span class="s0">in </span><span class="s2">[(</span><span class="s3">0.25</span><span class="s2">, </span><span class="s3">0.25</span><span class="s2">, </span><span class="s3">1</span><span class="s2">),</span>
                  <span class="s2">(</span><span class="s3">0.75</span><span class="s2">, </span><span class="s3">0.75</span><span class="s2">, </span><span class="s3">0</span><span class="s2">),</span>
                  <span class="s2">(</span><span class="s3">0.3</span><span class="s2">, </span><span class="s3">0.2</span><span class="s2">, </span><span class="s3">1</span><span class="s2">)]:</span>
            <span class="s1">i </span><span class="s2">= </span><span class="s1">tri</span><span class="s2">.</span><span class="s1">find_simplex</span><span class="s2">(</span><span class="s1">p</span><span class="s2">[:</span><span class="s3">2</span><span class="s2">])</span>
            <span class="s1">assert_equal</span><span class="s2">(</span><span class="s1">i</span><span class="s2">, </span><span class="s1">p</span><span class="s2">[</span><span class="s3">2</span><span class="s2">], </span><span class="s1">err_msg</span><span class="s2">=</span><span class="s5">f'</span><span class="s0">{</span><span class="s1">p</span><span class="s0">!r}</span><span class="s5">'</span><span class="s2">)</span>
            <span class="s1">j </span><span class="s2">= </span><span class="s1">qhull</span><span class="s2">.</span><span class="s1">tsearch</span><span class="s2">(</span><span class="s1">tri</span><span class="s2">, </span><span class="s1">p</span><span class="s2">[:</span><span class="s3">2</span><span class="s2">])</span>
            <span class="s1">assert_equal</span><span class="s2">(</span><span class="s1">i</span><span class="s2">, </span><span class="s1">j</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">test_plane_distance</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s4"># Compare plane distance from hyperplane equations obtained from Qhull</span>
        <span class="s4"># to manually computed plane equations</span>
        <span class="s1">x </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([(</span><span class="s3">0</span><span class="s2">,</span><span class="s3">0</span><span class="s2">), (</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">), (</span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">), (</span><span class="s3">0.99189033</span><span class="s2">, </span><span class="s3">0.37674127</span><span class="s2">),</span>
                      <span class="s2">(</span><span class="s3">0.99440079</span><span class="s2">, </span><span class="s3">0.45182168</span><span class="s2">)], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">)</span>
        <span class="s1">p </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s3">0.99966555</span><span class="s2">, </span><span class="s3">0.15685619</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">)</span>

        <span class="s1">tri </span><span class="s2">= </span><span class="s1">qhull</span><span class="s2">.</span><span class="s1">Delaunay</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)</span>

        <span class="s1">z </span><span class="s2">= </span><span class="s1">tri</span><span class="s2">.</span><span class="s1">lift_points</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)</span>
        <span class="s1">pz </span><span class="s2">= </span><span class="s1">tri</span><span class="s2">.</span><span class="s1">lift_points</span><span class="s2">(</span><span class="s1">p</span><span class="s2">)</span>

        <span class="s1">dist </span><span class="s2">= </span><span class="s1">tri</span><span class="s2">.</span><span class="s1">plane_distance</span><span class="s2">(</span><span class="s1">p</span><span class="s2">)</span>

        <span class="s0">for </span><span class="s1">j</span><span class="s2">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">tri</span><span class="s2">.</span><span class="s1">simplices</span><span class="s2">):</span>
            <span class="s1">x1 </span><span class="s2">= </span><span class="s1">z</span><span class="s2">[</span><span class="s1">v</span><span class="s2">[</span><span class="s3">0</span><span class="s2">]]</span>
            <span class="s1">x2 </span><span class="s2">= </span><span class="s1">z</span><span class="s2">[</span><span class="s1">v</span><span class="s2">[</span><span class="s3">1</span><span class="s2">]]</span>
            <span class="s1">x3 </span><span class="s2">= </span><span class="s1">z</span><span class="s2">[</span><span class="s1">v</span><span class="s2">[</span><span class="s3">2</span><span class="s2">]]</span>

            <span class="s1">n </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">cross</span><span class="s2">(</span><span class="s1">x1 </span><span class="s2">- </span><span class="s1">x3</span><span class="s2">, </span><span class="s1">x2 </span><span class="s2">- </span><span class="s1">x3</span><span class="s2">)</span>
            <span class="s1">n </span><span class="s2">/= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sqrt</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">dot</span><span class="s2">(</span><span class="s1">n</span><span class="s2">, </span><span class="s1">n</span><span class="s2">))</span>
            <span class="s1">n </span><span class="s2">*= -</span><span class="s1">np</span><span class="s2">.</span><span class="s1">sign</span><span class="s2">(</span><span class="s1">n</span><span class="s2">[</span><span class="s3">2</span><span class="s2">])</span>

            <span class="s1">d </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">dot</span><span class="s2">(</span><span class="s1">n</span><span class="s2">, </span><span class="s1">pz </span><span class="s2">- </span><span class="s1">x3</span><span class="s2">)</span>

            <span class="s1">assert_almost_equal</span><span class="s2">(</span><span class="s1">dist</span><span class="s2">[</span><span class="s1">j</span><span class="s2">], </span><span class="s1">d</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">test_convex_hull</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s4"># Simple check that the convex hull seems to works</span>
        <span class="s1">points </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([(</span><span class="s3">0</span><span class="s2">,</span><span class="s3">0</span><span class="s2">), (</span><span class="s3">0</span><span class="s2">,</span><span class="s3">1</span><span class="s2">), (</span><span class="s3">1</span><span class="s2">,</span><span class="s3">1</span><span class="s2">), (</span><span class="s3">1</span><span class="s2">,</span><span class="s3">0</span><span class="s2">)], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">)</span>
        <span class="s1">tri </span><span class="s2">= </span><span class="s1">qhull</span><span class="s2">.</span><span class="s1">Delaunay</span><span class="s2">(</span><span class="s1">points</span><span class="s2">)</span>

        <span class="s4"># +---+</span>
        <span class="s4"># |\ 0|</span>
        <span class="s4"># | \ |</span>
        <span class="s4"># |1 \|</span>
        <span class="s4"># +---+</span>

        <span class="s1">assert_equal</span><span class="s2">(</span><span class="s1">tri</span><span class="s2">.</span><span class="s1">convex_hull</span><span class="s2">, [[</span><span class="s3">3</span><span class="s2">, </span><span class="s3">2</span><span class="s2">], [</span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">], [</span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">], [</span><span class="s3">3</span><span class="s2">, </span><span class="s3">0</span><span class="s2">]])</span>

    <span class="s0">def </span><span class="s1">test_volume_area</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s4">#Basic check that we get back the correct volume and area for a cube</span>
        <span class="s1">points </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([(</span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">), (</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">), (</span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">), (</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">),</span>
                           <span class="s2">(</span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">), (</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">), (</span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">), (</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">)])</span>
        <span class="s1">hull </span><span class="s2">= </span><span class="s1">qhull</span><span class="s2">.</span><span class="s1">ConvexHull</span><span class="s2">(</span><span class="s1">points</span><span class="s2">)</span>

        <span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">hull</span><span class="s2">.</span><span class="s1">volume</span><span class="s2">, </span><span class="s3">1.</span><span class="s2">, </span><span class="s1">rtol</span><span class="s2">=</span><span class="s3">1e-14</span><span class="s2">,</span>
                        <span class="s1">err_msg</span><span class="s2">=</span><span class="s5">&quot;Volume of cube is incorrect&quot;</span><span class="s2">)</span>
        <span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">hull</span><span class="s2">.</span><span class="s1">area</span><span class="s2">, </span><span class="s3">6.</span><span class="s2">, </span><span class="s1">rtol</span><span class="s2">=</span><span class="s3">1e-14</span><span class="s2">,</span>
                        <span class="s1">err_msg</span><span class="s2">=</span><span class="s5">&quot;Area of cube is incorrect&quot;</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">test_random_volume_area</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s4">#Test that the results for a random 10-point convex are</span>
        <span class="s4">#coherent with the output of qconvex Qt s FA</span>
        <span class="s1">points </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([(</span><span class="s3">0.362568364506</span><span class="s2">, </span><span class="s3">0.472712355305</span><span class="s2">, </span><span class="s3">0.347003084477</span><span class="s2">),</span>
                           <span class="s2">(</span><span class="s3">0.733731893414</span><span class="s2">, </span><span class="s3">0.634480295684</span><span class="s2">, </span><span class="s3">0.950513180209</span><span class="s2">),</span>
                           <span class="s2">(</span><span class="s3">0.511239955611</span><span class="s2">, </span><span class="s3">0.876839441267</span><span class="s2">, </span><span class="s3">0.418047827863</span><span class="s2">),</span>
                           <span class="s2">(</span><span class="s3">0.0765906233393</span><span class="s2">, </span><span class="s3">0.527373281342</span><span class="s2">, </span><span class="s3">0.6509863541</span><span class="s2">),</span>
                           <span class="s2">(</span><span class="s3">0.146694972056</span><span class="s2">, </span><span class="s3">0.596725793348</span><span class="s2">, </span><span class="s3">0.894860986685</span><span class="s2">),</span>
                           <span class="s2">(</span><span class="s3">0.513808585741</span><span class="s2">, </span><span class="s3">0.069576205858</span><span class="s2">, </span><span class="s3">0.530890338876</span><span class="s2">),</span>
                           <span class="s2">(</span><span class="s3">0.512343805118</span><span class="s2">, </span><span class="s3">0.663537132612</span><span class="s2">, </span><span class="s3">0.037689295973</span><span class="s2">),</span>
                           <span class="s2">(</span><span class="s3">0.47282965018</span><span class="s2">, </span><span class="s3">0.462176697655</span><span class="s2">, </span><span class="s3">0.14061843691</span><span class="s2">),</span>
                           <span class="s2">(</span><span class="s3">0.240584597123</span><span class="s2">, </span><span class="s3">0.778660020591</span><span class="s2">, </span><span class="s3">0.722913476339</span><span class="s2">),</span>
                           <span class="s2">(</span><span class="s3">0.951271745935</span><span class="s2">, </span><span class="s3">0.967000673944</span><span class="s2">, </span><span class="s3">0.890661319684</span><span class="s2">)])</span>

        <span class="s1">hull </span><span class="s2">= </span><span class="s1">qhull</span><span class="s2">.</span><span class="s1">ConvexHull</span><span class="s2">(</span><span class="s1">points</span><span class="s2">)</span>
        <span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">hull</span><span class="s2">.</span><span class="s1">volume</span><span class="s2">, </span><span class="s3">0.14562013</span><span class="s2">, </span><span class="s1">rtol</span><span class="s2">=</span><span class="s3">1e-07</span><span class="s2">,</span>
                        <span class="s1">err_msg</span><span class="s2">=</span><span class="s5">&quot;Volume of random polyhedron is incorrect&quot;</span><span class="s2">)</span>
        <span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">hull</span><span class="s2">.</span><span class="s1">area</span><span class="s2">, </span><span class="s3">1.6670425</span><span class="s2">, </span><span class="s1">rtol</span><span class="s2">=</span><span class="s3">1e-07</span><span class="s2">,</span>
                        <span class="s1">err_msg</span><span class="s2">=</span><span class="s5">&quot;Area of random polyhedron is incorrect&quot;</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">test_incremental_volume_area_random_input</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s6">&quot;&quot;&quot;Test that incremental mode gives the same volume/area as 
        non-incremental mode and incremental mode with restart&quot;&quot;&quot;</span>
        <span class="s1">nr_points </span><span class="s2">= </span><span class="s3">20</span>
        <span class="s1">dim </span><span class="s2">= </span><span class="s3">3</span>
        <span class="s1">points </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">random</span><span class="s2">.</span><span class="s1">random</span><span class="s2">((</span><span class="s1">nr_points</span><span class="s2">, </span><span class="s1">dim</span><span class="s2">))</span>
        <span class="s1">inc_hull </span><span class="s2">= </span><span class="s1">qhull</span><span class="s2">.</span><span class="s1">ConvexHull</span><span class="s2">(</span><span class="s1">points</span><span class="s2">[:</span><span class="s1">dim</span><span class="s2">+</span><span class="s3">1</span><span class="s2">, :], </span><span class="s1">incremental</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
        <span class="s1">inc_restart_hull </span><span class="s2">= </span><span class="s1">qhull</span><span class="s2">.</span><span class="s1">ConvexHull</span><span class="s2">(</span><span class="s1">points</span><span class="s2">[:</span><span class="s1">dim</span><span class="s2">+</span><span class="s3">1</span><span class="s2">, :], </span><span class="s1">incremental</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">dim</span><span class="s2">+</span><span class="s3">1</span><span class="s2">, </span><span class="s1">nr_points</span><span class="s2">):</span>
            <span class="s1">hull </span><span class="s2">= </span><span class="s1">qhull</span><span class="s2">.</span><span class="s1">ConvexHull</span><span class="s2">(</span><span class="s1">points</span><span class="s2">[:</span><span class="s1">i</span><span class="s2">+</span><span class="s3">1</span><span class="s2">, :])</span>
            <span class="s1">inc_hull</span><span class="s2">.</span><span class="s1">add_points</span><span class="s2">(</span><span class="s1">points</span><span class="s2">[</span><span class="s1">i</span><span class="s2">:</span><span class="s1">i</span><span class="s2">+</span><span class="s3">1</span><span class="s2">, :])</span>
            <span class="s1">inc_restart_hull</span><span class="s2">.</span><span class="s1">add_points</span><span class="s2">(</span><span class="s1">points</span><span class="s2">[</span><span class="s1">i</span><span class="s2">:</span><span class="s1">i</span><span class="s2">+</span><span class="s3">1</span><span class="s2">, :], </span><span class="s1">restart</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
            <span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">hull</span><span class="s2">.</span><span class="s1">volume</span><span class="s2">, </span><span class="s1">inc_hull</span><span class="s2">.</span><span class="s1">volume</span><span class="s2">, </span><span class="s1">rtol</span><span class="s2">=</span><span class="s3">1e-7</span><span class="s2">)</span>
            <span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">hull</span><span class="s2">.</span><span class="s1">volume</span><span class="s2">, </span><span class="s1">inc_restart_hull</span><span class="s2">.</span><span class="s1">volume</span><span class="s2">, </span><span class="s1">rtol</span><span class="s2">=</span><span class="s3">1e-7</span><span class="s2">)</span>
            <span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">hull</span><span class="s2">.</span><span class="s1">area</span><span class="s2">, </span><span class="s1">inc_hull</span><span class="s2">.</span><span class="s1">area</span><span class="s2">, </span><span class="s1">rtol</span><span class="s2">=</span><span class="s3">1e-7</span><span class="s2">)</span>
            <span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">hull</span><span class="s2">.</span><span class="s1">area</span><span class="s2">, </span><span class="s1">inc_restart_hull</span><span class="s2">.</span><span class="s1">area</span><span class="s2">, </span><span class="s1">rtol</span><span class="s2">=</span><span class="s3">1e-7</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_check_barycentric_transforms</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">tri</span><span class="s2">, </span><span class="s1">err_msg</span><span class="s2">=</span><span class="s5">&quot;&quot;</span><span class="s2">,</span>
                                      <span class="s1">unit_cube</span><span class="s2">=</span><span class="s0">False</span><span class="s2">,</span>
                                      <span class="s1">unit_cube_tol</span><span class="s2">=</span><span class="s3">0</span><span class="s2">):</span>
        <span class="s6">&quot;&quot;&quot;Check that a triangulation has reasonable barycentric transforms&quot;&quot;&quot;</span>
        <span class="s1">vertices </span><span class="s2">= </span><span class="s1">tri</span><span class="s2">.</span><span class="s1">points</span><span class="s2">[</span><span class="s1">tri</span><span class="s2">.</span><span class="s1">simplices</span><span class="s2">]</span>
        <span class="s1">sc </span><span class="s2">= </span><span class="s3">1</span><span class="s2">/(</span><span class="s1">tri</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">+ </span><span class="s3">1.0</span><span class="s2">)</span>
        <span class="s1">centroids </span><span class="s2">= </span><span class="s1">vertices</span><span class="s2">.</span><span class="s1">sum</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">=</span><span class="s3">1</span><span class="s2">) * </span><span class="s1">sc</span>

        <span class="s4"># Either: (i) the simplex has a `nan` barycentric transform,</span>
        <span class="s4"># or, (ii) the centroid is in the simplex</span>

        <span class="s0">def </span><span class="s1">barycentric_transform</span><span class="s2">(</span><span class="s1">tr</span><span class="s2">, </span><span class="s1">x</span><span class="s2">):</span>
            <span class="s1">r </span><span class="s2">= </span><span class="s1">tr</span><span class="s2">[:,-</span><span class="s3">1</span><span class="s2">,:]</span>
            <span class="s1">Tinv </span><span class="s2">= </span><span class="s1">tr</span><span class="s2">[:,:-</span><span class="s3">1</span><span class="s2">,:]</span>
            <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">einsum</span><span class="s2">(</span><span class="s5">'ijk,ik-&gt;ij'</span><span class="s2">, </span><span class="s1">Tinv</span><span class="s2">, </span><span class="s1">x </span><span class="s2">- </span><span class="s1">r</span><span class="s2">)</span>

        <span class="s1">eps </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">finfo</span><span class="s2">(</span><span class="s1">float</span><span class="s2">).</span><span class="s1">eps</span>

        <span class="s1">c </span><span class="s2">= </span><span class="s1">barycentric_transform</span><span class="s2">(</span><span class="s1">tri</span><span class="s2">.</span><span class="s1">transform</span><span class="s2">, </span><span class="s1">centroids</span><span class="s2">)</span>
        <span class="s0">with </span><span class="s1">np</span><span class="s2">.</span><span class="s1">errstate</span><span class="s2">(</span><span class="s1">invalid</span><span class="s2">=</span><span class="s5">&quot;ignore&quot;</span><span class="s2">):</span>
            <span class="s1">ok </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isnan</span><span class="s2">(</span><span class="s1">c</span><span class="s2">).</span><span class="s1">all</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">=</span><span class="s3">1</span><span class="s2">) | (</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">c </span><span class="s2">- </span><span class="s1">sc</span><span class="s2">)/</span><span class="s1">sc </span><span class="s2">&lt; </span><span class="s3">0.1</span><span class="s2">).</span><span class="s1">all</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">=</span><span class="s3">1</span><span class="s2">)</span>

        <span class="s1">assert_</span><span class="s2">(</span><span class="s1">ok</span><span class="s2">.</span><span class="s1">all</span><span class="s2">(), </span><span class="s5">f&quot;</span><span class="s0">{</span><span class="s1">err_msg</span><span class="s0">} {</span><span class="s1">np</span><span class="s2">.</span><span class="s1">nonzero</span><span class="s2">(~</span><span class="s1">ok</span><span class="s2">)</span><span class="s0">}</span><span class="s5">&quot;</span><span class="s2">)</span>

        <span class="s4"># Invalid simplices must be (nearly) zero volume</span>
        <span class="s1">q </span><span class="s2">= </span><span class="s1">vertices</span><span class="s2">[:,:-</span><span class="s3">1</span><span class="s2">,:] - </span><span class="s1">vertices</span><span class="s2">[:,-</span><span class="s3">1</span><span class="s2">,</span><span class="s0">None</span><span class="s2">,:]</span>
        <span class="s1">volume </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">det</span><span class="s2">(</span><span class="s1">q</span><span class="s2">[</span><span class="s1">k</span><span class="s2">,:,:])</span>
                           <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">tri</span><span class="s2">.</span><span class="s1">nsimplex</span><span class="s2">)])</span>
        <span class="s1">ok </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isfinite</span><span class="s2">(</span><span class="s1">tri</span><span class="s2">.</span><span class="s1">transform</span><span class="s2">[:,</span><span class="s3">0</span><span class="s2">,</span><span class="s3">0</span><span class="s2">]) | (</span><span class="s1">volume </span><span class="s2">&lt; </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sqrt</span><span class="s2">(</span><span class="s1">eps</span><span class="s2">))</span>
        <span class="s1">assert_</span><span class="s2">(</span><span class="s1">ok</span><span class="s2">.</span><span class="s1">all</span><span class="s2">(), </span><span class="s5">f&quot;</span><span class="s0">{</span><span class="s1">err_msg</span><span class="s0">} {</span><span class="s1">np</span><span class="s2">.</span><span class="s1">nonzero</span><span class="s2">(~</span><span class="s1">ok</span><span class="s2">)</span><span class="s0">}</span><span class="s5">&quot;</span><span class="s2">)</span>

        <span class="s4"># Also, find_simplex for the centroid should end up in some</span>
        <span class="s4"># simplex for the non-degenerate cases</span>
        <span class="s1">j </span><span class="s2">= </span><span class="s1">tri</span><span class="s2">.</span><span class="s1">find_simplex</span><span class="s2">(</span><span class="s1">centroids</span><span class="s2">)</span>
        <span class="s1">ok </span><span class="s2">= (</span><span class="s1">j </span><span class="s2">!= -</span><span class="s3">1</span><span class="s2">) | </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isnan</span><span class="s2">(</span><span class="s1">tri</span><span class="s2">.</span><span class="s1">transform</span><span class="s2">[:,</span><span class="s3">0</span><span class="s2">,</span><span class="s3">0</span><span class="s2">])</span>
        <span class="s1">assert_</span><span class="s2">(</span><span class="s1">ok</span><span class="s2">.</span><span class="s1">all</span><span class="s2">(), </span><span class="s5">f&quot;</span><span class="s0">{</span><span class="s1">err_msg</span><span class="s0">} {</span><span class="s1">np</span><span class="s2">.</span><span class="s1">nonzero</span><span class="s2">(~</span><span class="s1">ok</span><span class="s2">)</span><span class="s0">}</span><span class="s5">&quot;</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">unit_cube</span><span class="s2">:</span>
            <span class="s4"># If in unit cube, no interior point should be marked out of hull</span>
            <span class="s1">at_boundary </span><span class="s2">= (</span><span class="s1">centroids </span><span class="s2">&lt;= </span><span class="s1">unit_cube_tol</span><span class="s2">).</span><span class="s1">any</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">=</span><span class="s3">1</span><span class="s2">)</span>
            <span class="s1">at_boundary </span><span class="s2">|= (</span><span class="s1">centroids </span><span class="s2">&gt;= </span><span class="s3">1 </span><span class="s2">- </span><span class="s1">unit_cube_tol</span><span class="s2">).</span><span class="s1">any</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">=</span><span class="s3">1</span><span class="s2">)</span>

            <span class="s1">ok </span><span class="s2">= (</span><span class="s1">j </span><span class="s2">!= -</span><span class="s3">1</span><span class="s2">) | </span><span class="s1">at_boundary</span>
            <span class="s1">assert_</span><span class="s2">(</span><span class="s1">ok</span><span class="s2">.</span><span class="s1">all</span><span class="s2">(), </span><span class="s5">f&quot;</span><span class="s0">{</span><span class="s1">err_msg</span><span class="s0">} {</span><span class="s1">np</span><span class="s2">.</span><span class="s1">nonzero</span><span class="s2">(~</span><span class="s1">ok</span><span class="s2">)</span><span class="s0">}</span><span class="s5">&quot;</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">fail_slow</span><span class="s2">(</span><span class="s3">5</span><span class="s2">)</span>
    <span class="s0">def </span><span class="s1">test_degenerate_barycentric_transforms</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s4"># The triangulation should not produce invalid barycentric</span>
        <span class="s4"># transforms that stump the simplex finding</span>
        <span class="s1">data </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">load</span><span class="s2">(</span><span class="s1">os</span><span class="s2">.</span><span class="s1">path</span><span class="s2">.</span><span class="s1">join</span><span class="s2">(</span><span class="s1">os</span><span class="s2">.</span><span class="s1">path</span><span class="s2">.</span><span class="s1">dirname</span><span class="s2">(</span><span class="s1">__file__</span><span class="s2">), </span><span class="s5">'data'</span><span class="s2">,</span>
                                    <span class="s5">'degenerate_pointset.npz'</span><span class="s2">))</span>
        <span class="s1">points </span><span class="s2">= </span><span class="s1">data</span><span class="s2">[</span><span class="s5">'c'</span><span class="s2">]</span>
        <span class="s1">data</span><span class="s2">.</span><span class="s1">close</span><span class="s2">()</span>

        <span class="s1">tri </span><span class="s2">= </span><span class="s1">qhull</span><span class="s2">.</span><span class="s1">Delaunay</span><span class="s2">(</span><span class="s1">points</span><span class="s2">)</span>

        <span class="s4"># Check that there are not too many invalid simplices</span>
        <span class="s1">bad_count </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isnan</span><span class="s2">(</span><span class="s1">tri</span><span class="s2">.</span><span class="s1">transform</span><span class="s2">[:,</span><span class="s3">0</span><span class="s2">,</span><span class="s3">0</span><span class="s2">]).</span><span class="s1">sum</span><span class="s2">()</span>
        <span class="s1">assert_</span><span class="s2">(</span><span class="s1">bad_count </span><span class="s2">&lt; </span><span class="s3">23</span><span class="s2">, </span><span class="s1">bad_count</span><span class="s2">)</span>

        <span class="s4"># Check the transforms</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_check_barycentric_transforms</span><span class="s2">(</span><span class="s1">tri</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">slow</span>
    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">fail_slow</span><span class="s2">(</span><span class="s3">10</span><span class="s2">)</span>
    <span class="s4"># OK per https://github.com/scipy/scipy/pull/20487#discussion_r1572684869</span>
    <span class="s0">def </span><span class="s1">test_more_barycentric_transforms</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s4"># Triangulate some &quot;nasty&quot; grids</span>

        <span class="s1">eps </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">finfo</span><span class="s2">(</span><span class="s1">float</span><span class="s2">).</span><span class="s1">eps</span>

        <span class="s1">npoints </span><span class="s2">= {</span><span class="s3">2</span><span class="s2">: </span><span class="s3">70</span><span class="s2">, </span><span class="s3">3</span><span class="s2">: </span><span class="s3">11</span><span class="s2">, </span><span class="s3">4</span><span class="s2">: </span><span class="s3">5</span><span class="s2">, </span><span class="s3">5</span><span class="s2">: </span><span class="s3">3</span><span class="s2">}</span>

        <span class="s0">for </span><span class="s1">ndim </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s3">2</span><span class="s2">, </span><span class="s3">6</span><span class="s2">):</span>
            <span class="s4"># Generate an uniform grid in n-d unit cube</span>
            <span class="s1">x </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linspace</span><span class="s2">(</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s1">npoints</span><span class="s2">[</span><span class="s1">ndim</span><span class="s2">])</span>
            <span class="s1">grid </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">c_</span><span class="s2">[</span>
                <span class="s1">list</span><span class="s2">(</span><span class="s1">map</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">ravel</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">broadcast_arrays</span><span class="s2">(*</span><span class="s1">np</span><span class="s2">.</span><span class="s1">ix_</span><span class="s2">(*([</span><span class="s1">x</span><span class="s2">]*</span><span class="s1">ndim</span><span class="s2">)))))</span>
            <span class="s2">].</span><span class="s1">T</span>

            <span class="s1">err_msg </span><span class="s2">= </span><span class="s5">&quot;ndim=%d&quot; </span><span class="s2">% </span><span class="s1">ndim</span>

            <span class="s4"># Check using regular grid</span>
            <span class="s1">tri </span><span class="s2">= </span><span class="s1">qhull</span><span class="s2">.</span><span class="s1">Delaunay</span><span class="s2">(</span><span class="s1">grid</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_check_barycentric_transforms</span><span class="s2">(</span><span class="s1">tri</span><span class="s2">, </span><span class="s1">err_msg</span><span class="s2">=</span><span class="s1">err_msg</span><span class="s2">,</span>
                                               <span class="s1">unit_cube</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>

            <span class="s4"># Check with eps-perturbations</span>
            <span class="s1">np</span><span class="s2">.</span><span class="s1">random</span><span class="s2">.</span><span class="s1">seed</span><span class="s2">(</span><span class="s3">1234</span><span class="s2">)</span>
            <span class="s1">m </span><span class="s2">= (</span><span class="s1">np</span><span class="s2">.</span><span class="s1">random</span><span class="s2">.</span><span class="s1">rand</span><span class="s2">(</span><span class="s1">grid</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s3">0</span><span class="s2">]) &lt; </span><span class="s3">0.2</span><span class="s2">)</span>
            <span class="s1">grid</span><span class="s2">[</span><span class="s1">m</span><span class="s2">,:] += </span><span class="s3">2</span><span class="s2">*</span><span class="s1">eps</span><span class="s2">*(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">random</span><span class="s2">.</span><span class="s1">rand</span><span class="s2">(*</span><span class="s1">grid</span><span class="s2">[</span><span class="s1">m</span><span class="s2">,:].</span><span class="s1">shape</span><span class="s2">) - </span><span class="s3">0.5</span><span class="s2">)</span>

            <span class="s1">tri </span><span class="s2">= </span><span class="s1">qhull</span><span class="s2">.</span><span class="s1">Delaunay</span><span class="s2">(</span><span class="s1">grid</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_check_barycentric_transforms</span><span class="s2">(</span><span class="s1">tri</span><span class="s2">, </span><span class="s1">err_msg</span><span class="s2">=</span><span class="s1">err_msg</span><span class="s2">,</span>
                                               <span class="s1">unit_cube</span><span class="s2">=</span><span class="s0">True</span><span class="s2">,</span>
                                               <span class="s1">unit_cube_tol</span><span class="s2">=</span><span class="s3">2</span><span class="s2">*</span><span class="s1">eps</span><span class="s2">)</span>

            <span class="s4"># Check with duplicated data</span>
            <span class="s1">tri </span><span class="s2">= </span><span class="s1">qhull</span><span class="s2">.</span><span class="s1">Delaunay</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">r_</span><span class="s2">[</span><span class="s1">grid</span><span class="s2">, </span><span class="s1">grid</span><span class="s2">])</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_check_barycentric_transforms</span><span class="s2">(</span><span class="s1">tri</span><span class="s2">, </span><span class="s1">err_msg</span><span class="s2">=</span><span class="s1">err_msg</span><span class="s2">,</span>
                                               <span class="s1">unit_cube</span><span class="s2">=</span><span class="s0">True</span><span class="s2">,</span>
                                               <span class="s1">unit_cube_tol</span><span class="s2">=</span><span class="s3">2</span><span class="s2">*</span><span class="s1">eps</span><span class="s2">)</span>


<span class="s0">class </span><span class="s1">TestVertexNeighborVertices</span><span class="s2">:</span>
    <span class="s0">def </span><span class="s1">_check</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">tri</span><span class="s2">):</span>
        <span class="s1">expected </span><span class="s2">= [</span><span class="s1">set</span><span class="s2">() </span><span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">tri</span><span class="s2">.</span><span class="s1">points</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s3">0</span><span class="s2">])]</span>
        <span class="s0">for </span><span class="s1">s </span><span class="s0">in </span><span class="s1">tri</span><span class="s2">.</span><span class="s1">simplices</span><span class="s2">:</span>
            <span class="s0">for </span><span class="s1">a </span><span class="s0">in </span><span class="s1">s</span><span class="s2">:</span>
                <span class="s0">for </span><span class="s1">b </span><span class="s0">in </span><span class="s1">s</span><span class="s2">:</span>
                    <span class="s0">if </span><span class="s1">a </span><span class="s2">!= </span><span class="s1">b</span><span class="s2">:</span>
                        <span class="s1">expected</span><span class="s2">[</span><span class="s1">a</span><span class="s2">].</span><span class="s1">add</span><span class="s2">(</span><span class="s1">b</span><span class="s2">)</span>

        <span class="s1">indptr</span><span class="s2">, </span><span class="s1">indices </span><span class="s2">= </span><span class="s1">tri</span><span class="s2">.</span><span class="s1">vertex_neighbor_vertices</span>

        <span class="s1">got </span><span class="s2">= [</span><span class="s1">set</span><span class="s2">(</span><span class="s1">map</span><span class="s2">(</span><span class="s1">int</span><span class="s2">, </span><span class="s1">indices</span><span class="s2">[</span><span class="s1">indptr</span><span class="s2">[</span><span class="s1">j</span><span class="s2">]:</span><span class="s1">indptr</span><span class="s2">[</span><span class="s1">j</span><span class="s2">+</span><span class="s3">1</span><span class="s2">]]))</span>
               <span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">tri</span><span class="s2">.</span><span class="s1">points</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s3">0</span><span class="s2">])]</span>

        <span class="s1">assert_equal</span><span class="s2">(</span><span class="s1">got</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">err_msg</span><span class="s2">=</span><span class="s5">f&quot;</span><span class="s0">{</span><span class="s1">got</span><span class="s0">!r} </span><span class="s5">!= </span><span class="s0">{</span><span class="s1">expected</span><span class="s0">!r}</span><span class="s5">&quot;</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">test_triangle</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">points </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([(</span><span class="s3">0</span><span class="s2">,</span><span class="s3">0</span><span class="s2">), (</span><span class="s3">0</span><span class="s2">,</span><span class="s3">1</span><span class="s2">), (</span><span class="s3">1</span><span class="s2">,</span><span class="s3">0</span><span class="s2">)], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">)</span>
        <span class="s1">tri </span><span class="s2">= </span><span class="s1">qhull</span><span class="s2">.</span><span class="s1">Delaunay</span><span class="s2">(</span><span class="s1">points</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_check</span><span class="s2">(</span><span class="s1">tri</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">test_rectangle</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">points </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([(</span><span class="s3">0</span><span class="s2">,</span><span class="s3">0</span><span class="s2">), (</span><span class="s3">0</span><span class="s2">,</span><span class="s3">1</span><span class="s2">), (</span><span class="s3">1</span><span class="s2">,</span><span class="s3">1</span><span class="s2">), (</span><span class="s3">1</span><span class="s2">,</span><span class="s3">0</span><span class="s2">)], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">)</span>
        <span class="s1">tri </span><span class="s2">= </span><span class="s1">qhull</span><span class="s2">.</span><span class="s1">Delaunay</span><span class="s2">(</span><span class="s1">points</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_check</span><span class="s2">(</span><span class="s1">tri</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">test_complicated</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">points </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([(</span><span class="s3">0</span><span class="s2">,</span><span class="s3">0</span><span class="s2">), (</span><span class="s3">0</span><span class="s2">,</span><span class="s3">1</span><span class="s2">), (</span><span class="s3">1</span><span class="s2">,</span><span class="s3">1</span><span class="s2">), (</span><span class="s3">1</span><span class="s2">,</span><span class="s3">0</span><span class="s2">),</span>
                           <span class="s2">(</span><span class="s3">0.5</span><span class="s2">, </span><span class="s3">0.5</span><span class="s2">), (</span><span class="s3">0.9</span><span class="s2">, </span><span class="s3">0.5</span><span class="s2">)], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">)</span>
        <span class="s1">tri </span><span class="s2">= </span><span class="s1">qhull</span><span class="s2">.</span><span class="s1">Delaunay</span><span class="s2">(</span><span class="s1">points</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_check</span><span class="s2">(</span><span class="s1">tri</span><span class="s2">)</span>


<span class="s0">class </span><span class="s1">TestDelaunay</span><span class="s2">:</span>
    <span class="s6">&quot;&quot;&quot; 
    Check that triangulation works. 
 
    &quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">test_masked_array_fails</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">masked_array </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ma</span><span class="s2">.</span><span class="s1">masked_all</span><span class="s2">(</span><span class="s3">1</span><span class="s2">)</span>
        <span class="s1">assert_raises</span><span class="s2">(</span><span class="s1">ValueError</span><span class="s2">, </span><span class="s1">qhull</span><span class="s2">.</span><span class="s1">Delaunay</span><span class="s2">, </span><span class="s1">masked_array</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">test_array_with_nans_fails</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">points_with_nan </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([(</span><span class="s3">0</span><span class="s2">,</span><span class="s3">0</span><span class="s2">), (</span><span class="s3">0</span><span class="s2">,</span><span class="s3">1</span><span class="s2">), (</span><span class="s3">1</span><span class="s2">,</span><span class="s3">1</span><span class="s2">), (</span><span class="s3">1</span><span class="s2">,</span><span class="s1">np</span><span class="s2">.</span><span class="s1">nan</span><span class="s2">)], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">)</span>
        <span class="s1">assert_raises</span><span class="s2">(</span><span class="s1">ValueError</span><span class="s2">, </span><span class="s1">qhull</span><span class="s2">.</span><span class="s1">Delaunay</span><span class="s2">, </span><span class="s1">points_with_nan</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">test_nd_simplex</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s4"># simple smoke test: triangulate a n-dimensional simplex</span>
        <span class="s0">for </span><span class="s1">nd </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s3">2</span><span class="s2">, </span><span class="s3">8</span><span class="s2">):</span>
            <span class="s1">points </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">((</span><span class="s1">nd</span><span class="s2">+</span><span class="s3">1</span><span class="s2">, </span><span class="s1">nd</span><span class="s2">))</span>
            <span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">nd</span><span class="s2">):</span>
                <span class="s1">points</span><span class="s2">[</span><span class="s1">j</span><span class="s2">,</span><span class="s1">j</span><span class="s2">] = </span><span class="s3">1.0</span>
            <span class="s1">points</span><span class="s2">[-</span><span class="s3">1</span><span class="s2">,:] = </span><span class="s3">1.0</span>

            <span class="s1">tri </span><span class="s2">= </span><span class="s1">qhull</span><span class="s2">.</span><span class="s1">Delaunay</span><span class="s2">(</span><span class="s1">points</span><span class="s2">)</span>

            <span class="s1">tri</span><span class="s2">.</span><span class="s1">simplices</span><span class="s2">.</span><span class="s1">sort</span><span class="s2">()</span>

            <span class="s1">assert_equal</span><span class="s2">(</span><span class="s1">tri</span><span class="s2">.</span><span class="s1">simplices</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(</span><span class="s1">nd</span><span class="s2">+</span><span class="s3">1</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">int</span><span class="s2">)[</span><span class="s0">None</span><span class="s2">, :])</span>
            <span class="s1">assert_equal</span><span class="s2">(</span><span class="s1">tri</span><span class="s2">.</span><span class="s1">neighbors</span><span class="s2">, -</span><span class="s3">1 </span><span class="s2">+ </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">((</span><span class="s1">nd</span><span class="s2">+</span><span class="s3">1</span><span class="s2">), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">int</span><span class="s2">)[</span><span class="s0">None</span><span class="s2">,:])</span>

    <span class="s0">def </span><span class="s1">test_2d_square</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s4"># simple smoke test: 2d square</span>
        <span class="s1">points </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([(</span><span class="s3">0</span><span class="s2">,</span><span class="s3">0</span><span class="s2">), (</span><span class="s3">0</span><span class="s2">,</span><span class="s3">1</span><span class="s2">), (</span><span class="s3">1</span><span class="s2">,</span><span class="s3">1</span><span class="s2">), (</span><span class="s3">1</span><span class="s2">,</span><span class="s3">0</span><span class="s2">)], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">)</span>
        <span class="s1">tri </span><span class="s2">= </span><span class="s1">qhull</span><span class="s2">.</span><span class="s1">Delaunay</span><span class="s2">(</span><span class="s1">points</span><span class="s2">)</span>

        <span class="s1">assert_equal</span><span class="s2">(</span><span class="s1">tri</span><span class="s2">.</span><span class="s1">simplices</span><span class="s2">, [[</span><span class="s3">1</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">2</span><span class="s2">], [</span><span class="s3">3</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">]])</span>
        <span class="s1">assert_equal</span><span class="s2">(</span><span class="s1">tri</span><span class="s2">.</span><span class="s1">neighbors</span><span class="s2">, [[-</span><span class="s3">1</span><span class="s2">, -</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">], [-</span><span class="s3">1</span><span class="s2">, -</span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">]])</span>

    <span class="s0">def </span><span class="s1">test_duplicate_points</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">x </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">)</span>
        <span class="s1">y </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">)</span>

        <span class="s1">xp </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">r_</span><span class="s2">[</span><span class="s1">x</span><span class="s2">, </span><span class="s1">x</span><span class="s2">]</span>
        <span class="s1">yp </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">r_</span><span class="s2">[</span><span class="s1">y</span><span class="s2">, </span><span class="s1">y</span><span class="s2">]</span>

        <span class="s4"># shouldn't fail on duplicate points</span>
        <span class="s1">qhull</span><span class="s2">.</span><span class="s1">Delaunay</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">c_</span><span class="s2">[</span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">])</span>
        <span class="s1">qhull</span><span class="s2">.</span><span class="s1">Delaunay</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">c_</span><span class="s2">[</span><span class="s1">xp</span><span class="s2">, </span><span class="s1">yp</span><span class="s2">])</span>

    <span class="s0">def </span><span class="s1">test_pathological</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s4"># both should succeed</span>
        <span class="s1">points </span><span class="s2">= </span><span class="s1">DATASETS</span><span class="s2">[</span><span class="s5">'pathological-1'</span><span class="s2">]</span>
        <span class="s1">tri </span><span class="s2">= </span><span class="s1">qhull</span><span class="s2">.</span><span class="s1">Delaunay</span><span class="s2">(</span><span class="s1">points</span><span class="s2">)</span>
        <span class="s1">assert_equal</span><span class="s2">(</span><span class="s1">tri</span><span class="s2">.</span><span class="s1">points</span><span class="s2">[</span><span class="s1">tri</span><span class="s2">.</span><span class="s1">simplices</span><span class="s2">].</span><span class="s1">max</span><span class="s2">(), </span><span class="s1">points</span><span class="s2">.</span><span class="s1">max</span><span class="s2">())</span>
        <span class="s1">assert_equal</span><span class="s2">(</span><span class="s1">tri</span><span class="s2">.</span><span class="s1">points</span><span class="s2">[</span><span class="s1">tri</span><span class="s2">.</span><span class="s1">simplices</span><span class="s2">].</span><span class="s1">min</span><span class="s2">(), </span><span class="s1">points</span><span class="s2">.</span><span class="s1">min</span><span class="s2">())</span>

        <span class="s1">points </span><span class="s2">= </span><span class="s1">DATASETS</span><span class="s2">[</span><span class="s5">'pathological-2'</span><span class="s2">]</span>
        <span class="s1">tri </span><span class="s2">= </span><span class="s1">qhull</span><span class="s2">.</span><span class="s1">Delaunay</span><span class="s2">(</span><span class="s1">points</span><span class="s2">)</span>
        <span class="s1">assert_equal</span><span class="s2">(</span><span class="s1">tri</span><span class="s2">.</span><span class="s1">points</span><span class="s2">[</span><span class="s1">tri</span><span class="s2">.</span><span class="s1">simplices</span><span class="s2">].</span><span class="s1">max</span><span class="s2">(), </span><span class="s1">points</span><span class="s2">.</span><span class="s1">max</span><span class="s2">())</span>
        <span class="s1">assert_equal</span><span class="s2">(</span><span class="s1">tri</span><span class="s2">.</span><span class="s1">points</span><span class="s2">[</span><span class="s1">tri</span><span class="s2">.</span><span class="s1">simplices</span><span class="s2">].</span><span class="s1">min</span><span class="s2">(), </span><span class="s1">points</span><span class="s2">.</span><span class="s1">min</span><span class="s2">())</span>

    <span class="s0">def </span><span class="s1">test_joggle</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s4"># Check that the option QJ indeed guarantees that all input points</span>
        <span class="s4"># occur as vertices of the triangulation</span>

        <span class="s1">points </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">random</span><span class="s2">.</span><span class="s1">rand</span><span class="s2">(</span><span class="s3">10</span><span class="s2">, </span><span class="s3">2</span><span class="s2">)</span>
        <span class="s1">points </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">r_</span><span class="s2">[</span><span class="s1">points</span><span class="s2">, </span><span class="s1">points</span><span class="s2">]  </span><span class="s4"># duplicate input data</span>

        <span class="s1">tri </span><span class="s2">= </span><span class="s1">qhull</span><span class="s2">.</span><span class="s1">Delaunay</span><span class="s2">(</span><span class="s1">points</span><span class="s2">, </span><span class="s1">qhull_options</span><span class="s2">=</span><span class="s5">&quot;QJ Qbb Pp&quot;</span><span class="s2">)</span>
        <span class="s1">assert_array_equal</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">unique</span><span class="s2">(</span><span class="s1">tri</span><span class="s2">.</span><span class="s1">simplices</span><span class="s2">.</span><span class="s1">ravel</span><span class="s2">()),</span>
                           <span class="s1">np</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">points</span><span class="s2">)))</span>

    <span class="s0">def </span><span class="s1">test_coplanar</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s4"># Check that the coplanar point output option indeed works</span>
        <span class="s1">points </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">random</span><span class="s2">.</span><span class="s1">rand</span><span class="s2">(</span><span class="s3">10</span><span class="s2">, </span><span class="s3">2</span><span class="s2">)</span>
        <span class="s1">points </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">r_</span><span class="s2">[</span><span class="s1">points</span><span class="s2">, </span><span class="s1">points</span><span class="s2">]  </span><span class="s4"># duplicate input data</span>

        <span class="s1">tri </span><span class="s2">= </span><span class="s1">qhull</span><span class="s2">.</span><span class="s1">Delaunay</span><span class="s2">(</span><span class="s1">points</span><span class="s2">)</span>

        <span class="s1">assert_</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">unique</span><span class="s2">(</span><span class="s1">tri</span><span class="s2">.</span><span class="s1">simplices</span><span class="s2">.</span><span class="s1">ravel</span><span class="s2">())) == </span><span class="s1">len</span><span class="s2">(</span><span class="s1">points</span><span class="s2">)//</span><span class="s3">2</span><span class="s2">)</span>
        <span class="s1">assert_</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">tri</span><span class="s2">.</span><span class="s1">coplanar</span><span class="s2">) == </span><span class="s1">len</span><span class="s2">(</span><span class="s1">points</span><span class="s2">)//</span><span class="s3">2</span><span class="s2">)</span>

        <span class="s1">assert_</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">unique</span><span class="s2">(</span><span class="s1">tri</span><span class="s2">.</span><span class="s1">coplanar</span><span class="s2">[:,</span><span class="s3">2</span><span class="s2">])) == </span><span class="s1">len</span><span class="s2">(</span><span class="s1">points</span><span class="s2">)//</span><span class="s3">2</span><span class="s2">)</span>

        <span class="s1">assert_</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">all</span><span class="s2">(</span><span class="s1">tri</span><span class="s2">.</span><span class="s1">vertex_to_simplex </span><span class="s2">&gt;= </span><span class="s3">0</span><span class="s2">))</span>

    <span class="s0">def </span><span class="s1">test_furthest_site</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">points </span><span class="s2">= [(</span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">), (</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">), (</span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">), (</span><span class="s3">0.5</span><span class="s2">, </span><span class="s3">0.5</span><span class="s2">), (</span><span class="s3">1.1</span><span class="s2">, </span><span class="s3">1.1</span><span class="s2">)]</span>
        <span class="s1">tri </span><span class="s2">= </span><span class="s1">qhull</span><span class="s2">.</span><span class="s1">Delaunay</span><span class="s2">(</span><span class="s1">points</span><span class="s2">, </span><span class="s1">furthest_site</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>

        <span class="s1">expected </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([(</span><span class="s3">1</span><span class="s2">, </span><span class="s3">4</span><span class="s2">, </span><span class="s3">0</span><span class="s2">), (</span><span class="s3">4</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">0</span><span class="s2">)])  </span><span class="s4"># from Qhull</span>
        <span class="s1">assert_array_equal</span><span class="s2">(</span><span class="s1">tri</span><span class="s2">.</span><span class="s1">simplices</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">parametrize</span><span class="s2">(</span><span class="s5">&quot;name&quot;</span><span class="s2">, </span><span class="s1">sorted</span><span class="s2">(</span><span class="s1">INCREMENTAL_DATASETS</span><span class="s2">))</span>
    <span class="s0">def </span><span class="s1">test_incremental</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">):</span>
        <span class="s4"># Test incremental construction of the triangulation</span>

        <span class="s1">chunks</span><span class="s2">, </span><span class="s1">opts </span><span class="s2">= </span><span class="s1">INCREMENTAL_DATASETS</span><span class="s2">[</span><span class="s1">name</span><span class="s2">]</span>
        <span class="s1">points </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">concatenate</span><span class="s2">(</span><span class="s1">chunks</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s3">0</span><span class="s2">)</span>

        <span class="s1">obj </span><span class="s2">= </span><span class="s1">qhull</span><span class="s2">.</span><span class="s1">Delaunay</span><span class="s2">(</span><span class="s1">chunks</span><span class="s2">[</span><span class="s3">0</span><span class="s2">], </span><span class="s1">incremental</span><span class="s2">=</span><span class="s0">True</span><span class="s2">,</span>
                             <span class="s1">qhull_options</span><span class="s2">=</span><span class="s1">opts</span><span class="s2">)</span>
        <span class="s0">for </span><span class="s1">chunk </span><span class="s0">in </span><span class="s1">chunks</span><span class="s2">[</span><span class="s3">1</span><span class="s2">:]:</span>
            <span class="s1">obj</span><span class="s2">.</span><span class="s1">add_points</span><span class="s2">(</span><span class="s1">chunk</span><span class="s2">)</span>

        <span class="s1">obj2 </span><span class="s2">= </span><span class="s1">qhull</span><span class="s2">.</span><span class="s1">Delaunay</span><span class="s2">(</span><span class="s1">points</span><span class="s2">)</span>

        <span class="s1">obj3 </span><span class="s2">= </span><span class="s1">qhull</span><span class="s2">.</span><span class="s1">Delaunay</span><span class="s2">(</span><span class="s1">chunks</span><span class="s2">[</span><span class="s3">0</span><span class="s2">], </span><span class="s1">incremental</span><span class="s2">=</span><span class="s0">True</span><span class="s2">,</span>
                              <span class="s1">qhull_options</span><span class="s2">=</span><span class="s1">opts</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">chunks</span><span class="s2">) &gt; </span><span class="s3">1</span><span class="s2">:</span>
            <span class="s1">obj3</span><span class="s2">.</span><span class="s1">add_points</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">concatenate</span><span class="s2">(</span><span class="s1">chunks</span><span class="s2">[</span><span class="s3">1</span><span class="s2">:], </span><span class="s1">axis</span><span class="s2">=</span><span class="s3">0</span><span class="s2">),</span>
                            <span class="s1">restart</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>

        <span class="s4"># Check that the incremental mode agrees with upfront mode</span>
        <span class="s0">if </span><span class="s1">name</span><span class="s2">.</span><span class="s1">startswith</span><span class="s2">(</span><span class="s5">'pathological'</span><span class="s2">):</span>
            <span class="s4"># XXX: These produce valid but different triangulations.</span>
            <span class="s4">#      They look OK when plotted, but how to check them?</span>

            <span class="s1">assert_array_equal</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">unique</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">.</span><span class="s1">simplices</span><span class="s2">.</span><span class="s1">ravel</span><span class="s2">()),</span>
                               <span class="s1">np</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(</span><span class="s1">points</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s3">0</span><span class="s2">]))</span>
            <span class="s1">assert_array_equal</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">unique</span><span class="s2">(</span><span class="s1">obj2</span><span class="s2">.</span><span class="s1">simplices</span><span class="s2">.</span><span class="s1">ravel</span><span class="s2">()),</span>
                               <span class="s1">np</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(</span><span class="s1">points</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s3">0</span><span class="s2">]))</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">assert_unordered_tuple_list_equal</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">.</span><span class="s1">simplices</span><span class="s2">, </span><span class="s1">obj2</span><span class="s2">.</span><span class="s1">simplices</span><span class="s2">,</span>
                                              <span class="s1">tpl</span><span class="s2">=</span><span class="s1">sorted_tuple</span><span class="s2">)</span>

        <span class="s1">assert_unordered_tuple_list_equal</span><span class="s2">(</span><span class="s1">obj2</span><span class="s2">.</span><span class="s1">simplices</span><span class="s2">, </span><span class="s1">obj3</span><span class="s2">.</span><span class="s1">simplices</span><span class="s2">,</span>
                                          <span class="s1">tpl</span><span class="s2">=</span><span class="s1">sorted_tuple</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">assert_hulls_equal</span><span class="s2">(</span><span class="s1">points</span><span class="s2">, </span><span class="s1">facets_1</span><span class="s2">, </span><span class="s1">facets_2</span><span class="s2">):</span>
    <span class="s4"># Check that two convex hulls constructed from the same point set</span>
    <span class="s4"># are equal</span>

    <span class="s1">facets_1 </span><span class="s2">= </span><span class="s1">set</span><span class="s2">(</span><span class="s1">map</span><span class="s2">(</span><span class="s1">sorted_tuple</span><span class="s2">, </span><span class="s1">facets_1</span><span class="s2">))</span>
    <span class="s1">facets_2 </span><span class="s2">= </span><span class="s1">set</span><span class="s2">(</span><span class="s1">map</span><span class="s2">(</span><span class="s1">sorted_tuple</span><span class="s2">, </span><span class="s1">facets_2</span><span class="s2">))</span>

    <span class="s0">if </span><span class="s1">facets_1 </span><span class="s2">!= </span><span class="s1">facets_2 </span><span class="s0">and </span><span class="s1">points</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s3">1</span><span class="s2">] == </span><span class="s3">2</span><span class="s2">:</span>
        <span class="s4"># The direct check fails for the pathological cases</span>
        <span class="s4"># --- then the convex hull from Delaunay differs (due</span>
        <span class="s4"># to rounding error etc.) from the hull computed</span>
        <span class="s4"># otherwise, by the question whether (tricoplanar)</span>
        <span class="s4"># points that lie almost exactly on the hull are</span>
        <span class="s4"># included as vertices of the hull or not.</span>
        <span class="s4">#</span>
        <span class="s4"># So we check the result, and accept it if the Delaunay</span>
        <span class="s4"># hull line segments are a subset of the usual hull.</span>

        <span class="s1">eps </span><span class="s2">= </span><span class="s3">1000 </span><span class="s2">* </span><span class="s1">np</span><span class="s2">.</span><span class="s1">finfo</span><span class="s2">(</span><span class="s1">float</span><span class="s2">).</span><span class="s1">eps</span>

        <span class="s0">for </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b </span><span class="s0">in </span><span class="s1">facets_1</span><span class="s2">:</span>
            <span class="s0">for </span><span class="s1">ap</span><span class="s2">, </span><span class="s1">bp </span><span class="s0">in </span><span class="s1">facets_2</span><span class="s2">:</span>
                <span class="s1">t </span><span class="s2">= </span><span class="s1">points</span><span class="s2">[</span><span class="s1">bp</span><span class="s2">] - </span><span class="s1">points</span><span class="s2">[</span><span class="s1">ap</span><span class="s2">]</span>
                <span class="s1">t </span><span class="s2">/= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">norm</span><span class="s2">(</span><span class="s1">t</span><span class="s2">)       </span><span class="s4"># tangent</span>
                <span class="s1">n </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([-</span><span class="s1">t</span><span class="s2">[</span><span class="s3">1</span><span class="s2">], </span><span class="s1">t</span><span class="s2">[</span><span class="s3">0</span><span class="s2">]])  </span><span class="s4"># normal</span>

                <span class="s4"># check that the two line segments are parallel</span>
                <span class="s4"># to the same line</span>
                <span class="s1">c1 </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">dot</span><span class="s2">(</span><span class="s1">n</span><span class="s2">, </span><span class="s1">points</span><span class="s2">[</span><span class="s1">b</span><span class="s2">] - </span><span class="s1">points</span><span class="s2">[</span><span class="s1">ap</span><span class="s2">])</span>
                <span class="s1">c2 </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">dot</span><span class="s2">(</span><span class="s1">n</span><span class="s2">, </span><span class="s1">points</span><span class="s2">[</span><span class="s1">a</span><span class="s2">] - </span><span class="s1">points</span><span class="s2">[</span><span class="s1">ap</span><span class="s2">])</span>
                <span class="s0">if not </span><span class="s1">np</span><span class="s2">.</span><span class="s1">allclose</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">dot</span><span class="s2">(</span><span class="s1">c1</span><span class="s2">, </span><span class="s1">n</span><span class="s2">), </span><span class="s3">0</span><span class="s2">):</span>
                    <span class="s0">continue</span>
                <span class="s0">if not </span><span class="s1">np</span><span class="s2">.</span><span class="s1">allclose</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">dot</span><span class="s2">(</span><span class="s1">c2</span><span class="s2">, </span><span class="s1">n</span><span class="s2">), </span><span class="s3">0</span><span class="s2">):</span>
                    <span class="s0">continue</span>

                <span class="s4"># Check that the segment (a, b) is contained in (ap, bp)</span>
                <span class="s1">c1 </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">dot</span><span class="s2">(</span><span class="s1">t</span><span class="s2">, </span><span class="s1">points</span><span class="s2">[</span><span class="s1">a</span><span class="s2">] - </span><span class="s1">points</span><span class="s2">[</span><span class="s1">ap</span><span class="s2">])</span>
                <span class="s1">c2 </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">dot</span><span class="s2">(</span><span class="s1">t</span><span class="s2">, </span><span class="s1">points</span><span class="s2">[</span><span class="s1">b</span><span class="s2">] - </span><span class="s1">points</span><span class="s2">[</span><span class="s1">ap</span><span class="s2">])</span>
                <span class="s1">c3 </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">dot</span><span class="s2">(</span><span class="s1">t</span><span class="s2">, </span><span class="s1">points</span><span class="s2">[</span><span class="s1">bp</span><span class="s2">] - </span><span class="s1">points</span><span class="s2">[</span><span class="s1">ap</span><span class="s2">])</span>
                <span class="s0">if </span><span class="s1">c1 </span><span class="s2">&lt; -</span><span class="s1">eps </span><span class="s0">or </span><span class="s1">c1 </span><span class="s2">&gt; </span><span class="s1">c3 </span><span class="s2">+ </span><span class="s1">eps</span><span class="s2">:</span>
                    <span class="s0">continue</span>
                <span class="s0">if </span><span class="s1">c2 </span><span class="s2">&lt; -</span><span class="s1">eps </span><span class="s0">or </span><span class="s1">c2 </span><span class="s2">&gt; </span><span class="s1">c3 </span><span class="s2">+ </span><span class="s1">eps</span><span class="s2">:</span>
                    <span class="s0">continue</span>

                <span class="s4"># OK:</span>
                <span class="s0">break</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s0">raise </span><span class="s1">AssertionError</span><span class="s2">(</span><span class="s5">&quot;comparison fails&quot;</span><span class="s2">)</span>

        <span class="s4"># it was OK</span>
        <span class="s0">return</span>

    <span class="s1">assert_equal</span><span class="s2">(</span><span class="s1">facets_1</span><span class="s2">, </span><span class="s1">facets_2</span><span class="s2">)</span>


<span class="s0">class </span><span class="s1">TestConvexHull</span><span class="s2">:</span>
    <span class="s0">def </span><span class="s1">test_masked_array_fails</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">masked_array </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ma</span><span class="s2">.</span><span class="s1">masked_all</span><span class="s2">(</span><span class="s3">1</span><span class="s2">)</span>
        <span class="s1">assert_raises</span><span class="s2">(</span><span class="s1">ValueError</span><span class="s2">, </span><span class="s1">qhull</span><span class="s2">.</span><span class="s1">ConvexHull</span><span class="s2">, </span><span class="s1">masked_array</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">test_array_with_nans_fails</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">points_with_nan </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([(</span><span class="s3">0</span><span class="s2">,</span><span class="s3">0</span><span class="s2">), (</span><span class="s3">1</span><span class="s2">,</span><span class="s3">1</span><span class="s2">), (</span><span class="s3">2</span><span class="s2">,</span><span class="s1">np</span><span class="s2">.</span><span class="s1">nan</span><span class="s2">)], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">)</span>
        <span class="s1">assert_raises</span><span class="s2">(</span><span class="s1">ValueError</span><span class="s2">, </span><span class="s1">qhull</span><span class="s2">.</span><span class="s1">ConvexHull</span><span class="s2">, </span><span class="s1">points_with_nan</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">parametrize</span><span class="s2">(</span><span class="s5">&quot;name&quot;</span><span class="s2">, </span><span class="s1">sorted</span><span class="s2">(</span><span class="s1">DATASETS</span><span class="s2">))</span>
    <span class="s0">def </span><span class="s1">test_hull_consistency_tri</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">):</span>
        <span class="s4"># Check that a convex hull returned by qhull in ndim</span>
        <span class="s4"># and the hull constructed from ndim delaunay agree</span>
        <span class="s1">points </span><span class="s2">= </span><span class="s1">DATASETS</span><span class="s2">[</span><span class="s1">name</span><span class="s2">]</span>

        <span class="s1">tri </span><span class="s2">= </span><span class="s1">qhull</span><span class="s2">.</span><span class="s1">Delaunay</span><span class="s2">(</span><span class="s1">points</span><span class="s2">)</span>
        <span class="s1">hull </span><span class="s2">= </span><span class="s1">qhull</span><span class="s2">.</span><span class="s1">ConvexHull</span><span class="s2">(</span><span class="s1">points</span><span class="s2">)</span>

        <span class="s1">assert_hulls_equal</span><span class="s2">(</span><span class="s1">points</span><span class="s2">, </span><span class="s1">tri</span><span class="s2">.</span><span class="s1">convex_hull</span><span class="s2">, </span><span class="s1">hull</span><span class="s2">.</span><span class="s1">simplices</span><span class="s2">)</span>

        <span class="s4"># Check that the hull extremes are as expected</span>
        <span class="s0">if </span><span class="s1">points</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s3">1</span><span class="s2">] == </span><span class="s3">2</span><span class="s2">:</span>
            <span class="s1">assert_equal</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">unique</span><span class="s2">(</span><span class="s1">hull</span><span class="s2">.</span><span class="s1">simplices</span><span class="s2">), </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sort</span><span class="s2">(</span><span class="s1">hull</span><span class="s2">.</span><span class="s1">vertices</span><span class="s2">))</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">assert_equal</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">unique</span><span class="s2">(</span><span class="s1">hull</span><span class="s2">.</span><span class="s1">simplices</span><span class="s2">), </span><span class="s1">hull</span><span class="s2">.</span><span class="s1">vertices</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">parametrize</span><span class="s2">(</span><span class="s5">&quot;name&quot;</span><span class="s2">, </span><span class="s1">sorted</span><span class="s2">(</span><span class="s1">INCREMENTAL_DATASETS</span><span class="s2">))</span>
    <span class="s0">def </span><span class="s1">test_incremental</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">):</span>
        <span class="s4"># Test incremental construction of the convex hull</span>
        <span class="s1">chunks</span><span class="s2">, </span><span class="s1">_ </span><span class="s2">= </span><span class="s1">INCREMENTAL_DATASETS</span><span class="s2">[</span><span class="s1">name</span><span class="s2">]</span>
        <span class="s1">points </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">concatenate</span><span class="s2">(</span><span class="s1">chunks</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s3">0</span><span class="s2">)</span>

        <span class="s1">obj </span><span class="s2">= </span><span class="s1">qhull</span><span class="s2">.</span><span class="s1">ConvexHull</span><span class="s2">(</span><span class="s1">chunks</span><span class="s2">[</span><span class="s3">0</span><span class="s2">], </span><span class="s1">incremental</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
        <span class="s0">for </span><span class="s1">chunk </span><span class="s0">in </span><span class="s1">chunks</span><span class="s2">[</span><span class="s3">1</span><span class="s2">:]:</span>
            <span class="s1">obj</span><span class="s2">.</span><span class="s1">add_points</span><span class="s2">(</span><span class="s1">chunk</span><span class="s2">)</span>

        <span class="s1">obj2 </span><span class="s2">= </span><span class="s1">qhull</span><span class="s2">.</span><span class="s1">ConvexHull</span><span class="s2">(</span><span class="s1">points</span><span class="s2">)</span>

        <span class="s1">obj3 </span><span class="s2">= </span><span class="s1">qhull</span><span class="s2">.</span><span class="s1">ConvexHull</span><span class="s2">(</span><span class="s1">chunks</span><span class="s2">[</span><span class="s3">0</span><span class="s2">], </span><span class="s1">incremental</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">chunks</span><span class="s2">) &gt; </span><span class="s3">1</span><span class="s2">:</span>
            <span class="s1">obj3</span><span class="s2">.</span><span class="s1">add_points</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">concatenate</span><span class="s2">(</span><span class="s1">chunks</span><span class="s2">[</span><span class="s3">1</span><span class="s2">:], </span><span class="s1">axis</span><span class="s2">=</span><span class="s3">0</span><span class="s2">),</span>
                            <span class="s1">restart</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>

        <span class="s4"># Check that the incremental mode agrees with upfront mode</span>
        <span class="s1">assert_hulls_equal</span><span class="s2">(</span><span class="s1">points</span><span class="s2">, </span><span class="s1">obj</span><span class="s2">.</span><span class="s1">simplices</span><span class="s2">, </span><span class="s1">obj2</span><span class="s2">.</span><span class="s1">simplices</span><span class="s2">)</span>
        <span class="s1">assert_hulls_equal</span><span class="s2">(</span><span class="s1">points</span><span class="s2">, </span><span class="s1">obj</span><span class="s2">.</span><span class="s1">simplices</span><span class="s2">, </span><span class="s1">obj3</span><span class="s2">.</span><span class="s1">simplices</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">test_vertices_2d</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s4"># The vertices should be in counterclockwise order in 2-D</span>
        <span class="s1">np</span><span class="s2">.</span><span class="s1">random</span><span class="s2">.</span><span class="s1">seed</span><span class="s2">(</span><span class="s3">1234</span><span class="s2">)</span>
        <span class="s1">points </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">random</span><span class="s2">.</span><span class="s1">rand</span><span class="s2">(</span><span class="s3">30</span><span class="s2">, </span><span class="s3">2</span><span class="s2">)</span>

        <span class="s1">hull </span><span class="s2">= </span><span class="s1">qhull</span><span class="s2">.</span><span class="s1">ConvexHull</span><span class="s2">(</span><span class="s1">points</span><span class="s2">)</span>
        <span class="s1">assert_equal</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">unique</span><span class="s2">(</span><span class="s1">hull</span><span class="s2">.</span><span class="s1">simplices</span><span class="s2">), </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sort</span><span class="s2">(</span><span class="s1">hull</span><span class="s2">.</span><span class="s1">vertices</span><span class="s2">))</span>

        <span class="s4"># Check counterclockwiseness</span>
        <span class="s1">x</span><span class="s2">, </span><span class="s1">y </span><span class="s2">= </span><span class="s1">hull</span><span class="s2">.</span><span class="s1">points</span><span class="s2">[</span><span class="s1">hull</span><span class="s2">.</span><span class="s1">vertices</span><span class="s2">].</span><span class="s1">T</span>
        <span class="s1">angle </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">arctan2</span><span class="s2">(</span><span class="s1">y </span><span class="s2">- </span><span class="s1">y</span><span class="s2">.</span><span class="s1">mean</span><span class="s2">(), </span><span class="s1">x </span><span class="s2">- </span><span class="s1">x</span><span class="s2">.</span><span class="s1">mean</span><span class="s2">())</span>
        <span class="s1">assert_</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">all</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">diff</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">unwrap</span><span class="s2">(</span><span class="s1">angle</span><span class="s2">)) &gt; </span><span class="s3">0</span><span class="s2">))</span>

    <span class="s0">def </span><span class="s1">test_volume_area</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s4"># Basic check that we get back the correct volume and area for a cube</span>
        <span class="s1">points </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([(</span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">), (</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">), (</span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">), (</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">),</span>
                           <span class="s2">(</span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">), (</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">), (</span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">), (</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">)])</span>
        <span class="s1">tri </span><span class="s2">= </span><span class="s1">qhull</span><span class="s2">.</span><span class="s1">ConvexHull</span><span class="s2">(</span><span class="s1">points</span><span class="s2">)</span>

        <span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">tri</span><span class="s2">.</span><span class="s1">volume</span><span class="s2">, </span><span class="s3">1.</span><span class="s2">, </span><span class="s1">rtol</span><span class="s2">=</span><span class="s3">1e-14</span><span class="s2">)</span>
        <span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">tri</span><span class="s2">.</span><span class="s1">area</span><span class="s2">, </span><span class="s3">6.</span><span class="s2">, </span><span class="s1">rtol</span><span class="s2">=</span><span class="s3">1e-14</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">parametrize</span><span class="s2">(</span><span class="s5">&quot;incremental&quot;</span><span class="s2">, [</span><span class="s0">False</span><span class="s2">, </span><span class="s0">True</span><span class="s2">])</span>
    <span class="s0">def </span><span class="s1">test_good2d</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">incremental</span><span class="s2">):</span>
        <span class="s4"># Make sure the QGn option gives the correct value of &quot;good&quot;.</span>
        <span class="s1">points </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([[</span><span class="s3">0.2</span><span class="s2">, </span><span class="s3">0.2</span><span class="s2">],</span>
                           <span class="s2">[</span><span class="s3">0.2</span><span class="s2">, </span><span class="s3">0.4</span><span class="s2">],</span>
                           <span class="s2">[</span><span class="s3">0.4</span><span class="s2">, </span><span class="s3">0.4</span><span class="s2">],</span>
                           <span class="s2">[</span><span class="s3">0.4</span><span class="s2">, </span><span class="s3">0.2</span><span class="s2">],</span>
                           <span class="s2">[</span><span class="s3">0.3</span><span class="s2">, </span><span class="s3">0.6</span><span class="s2">]])</span>
        <span class="s1">hull </span><span class="s2">= </span><span class="s1">qhull</span><span class="s2">.</span><span class="s1">ConvexHull</span><span class="s2">(</span><span class="s1">points</span><span class="s2">=</span><span class="s1">points</span><span class="s2">,</span>
                                <span class="s1">incremental</span><span class="s2">=</span><span class="s1">incremental</span><span class="s2">,</span>
                                <span class="s1">qhull_options</span><span class="s2">=</span><span class="s5">'QG4'</span><span class="s2">)</span>
        <span class="s1">expected </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s0">False</span><span class="s2">, </span><span class="s0">True</span><span class="s2">, </span><span class="s0">False</span><span class="s2">, </span><span class="s0">False</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">bool</span><span class="s2">)</span>
        <span class="s1">actual </span><span class="s2">= </span><span class="s1">hull</span><span class="s2">.</span><span class="s1">good</span>
        <span class="s1">assert_equal</span><span class="s2">(</span><span class="s1">actual</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">parametrize</span><span class="s2">(</span><span class="s5">&quot;visibility&quot;</span><span class="s2">, [</span>
                              <span class="s5">&quot;QG4&quot;</span><span class="s2">,  </span><span class="s4"># visible=True</span>
                              <span class="s5">&quot;QG-4&quot;</span><span class="s2">,  </span><span class="s4"># visible=False</span>
                              <span class="s2">])</span>
    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">parametrize</span><span class="s2">(</span><span class="s5">&quot;new_gen, expected&quot;</span><span class="s2">, [</span>
        <span class="s4"># add generator that places QG4 inside hull</span>
        <span class="s4"># so all facets are invisible</span>
        <span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([[</span><span class="s3">0.3</span><span class="s2">, </span><span class="s3">0.7</span><span class="s2">]]),</span>
         <span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s0">False</span><span class="s2">, </span><span class="s0">False</span><span class="s2">, </span><span class="s0">False</span><span class="s2">, </span><span class="s0">False</span><span class="s2">, </span><span class="s0">False</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">bool</span><span class="s2">)),</span>
        <span class="s4"># adding a generator on the opposite side of the square</span>
        <span class="s4"># should preserve the single visible facet &amp; add one invisible</span>
        <span class="s4"># facet</span>
        <span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([[</span><span class="s3">0.3</span><span class="s2">, -</span><span class="s3">0.7</span><span class="s2">]]),</span>
         <span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s0">False</span><span class="s2">, </span><span class="s0">True</span><span class="s2">, </span><span class="s0">False</span><span class="s2">, </span><span class="s0">False</span><span class="s2">, </span><span class="s0">False</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">bool</span><span class="s2">)),</span>
        <span class="s4"># split the visible facet on top of the square into two</span>
        <span class="s4"># visible facets, with visibility at the end of the array</span>
        <span class="s4"># because add_points concatenates</span>
        <span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([[</span><span class="s3">0.3</span><span class="s2">, </span><span class="s3">0.41</span><span class="s2">]]),</span>
         <span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s0">False</span><span class="s2">, </span><span class="s0">False</span><span class="s2">, </span><span class="s0">False</span><span class="s2">, </span><span class="s0">True</span><span class="s2">, </span><span class="s0">True</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">bool</span><span class="s2">)),</span>
        <span class="s4"># with our current Qhull options, coplanarity will not count</span>
        <span class="s4"># for visibility; this case shifts one visible &amp; one invisible</span>
        <span class="s4"># facet &amp; adds a coplanar facet</span>
        <span class="s4"># simplex at index position 2 is the shifted visible facet</span>
        <span class="s4"># the final simplex is the coplanar facet</span>
        <span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([[</span><span class="s3">0.5</span><span class="s2">, </span><span class="s3">0.6</span><span class="s2">], [</span><span class="s3">0.6</span><span class="s2">, </span><span class="s3">0.6</span><span class="s2">]]),</span>
         <span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s0">False</span><span class="s2">, </span><span class="s0">False</span><span class="s2">, </span><span class="s0">True</span><span class="s2">, </span><span class="s0">False</span><span class="s2">, </span><span class="s0">False</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">bool</span><span class="s2">)),</span>
        <span class="s4"># place the new generator such that it envelops the query</span>
        <span class="s4"># point within the convex hull, but only just barely within</span>
        <span class="s4"># the double precision limit</span>
        <span class="s4"># NOTE: testing exact degeneracy is less predictable than this</span>
        <span class="s4"># scenario, perhaps because of the default Qt option we have</span>
        <span class="s4"># enabled for Qhull to handle precision matters</span>
        <span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([[</span><span class="s3">0.3</span><span class="s2">, </span><span class="s3">0.6 </span><span class="s2">+ </span><span class="s3">1e-16</span><span class="s2">]]),</span>
         <span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s0">False</span><span class="s2">, </span><span class="s0">False</span><span class="s2">, </span><span class="s0">False</span><span class="s2">, </span><span class="s0">False</span><span class="s2">, </span><span class="s0">False</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">bool</span><span class="s2">)),</span>
        <span class="s2">])</span>
    <span class="s0">def </span><span class="s1">test_good2d_incremental_changes</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">new_gen</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">,</span>
                                        <span class="s1">visibility</span><span class="s2">):</span>
        <span class="s4"># use the usual square convex hull</span>
        <span class="s4"># generators from test_good2d</span>
        <span class="s1">points </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([[</span><span class="s3">0.2</span><span class="s2">, </span><span class="s3">0.2</span><span class="s2">],</span>
                           <span class="s2">[</span><span class="s3">0.2</span><span class="s2">, </span><span class="s3">0.4</span><span class="s2">],</span>
                           <span class="s2">[</span><span class="s3">0.4</span><span class="s2">, </span><span class="s3">0.4</span><span class="s2">],</span>
                           <span class="s2">[</span><span class="s3">0.4</span><span class="s2">, </span><span class="s3">0.2</span><span class="s2">],</span>
                           <span class="s2">[</span><span class="s3">0.3</span><span class="s2">, </span><span class="s3">0.6</span><span class="s2">]])</span>
        <span class="s1">hull </span><span class="s2">= </span><span class="s1">qhull</span><span class="s2">.</span><span class="s1">ConvexHull</span><span class="s2">(</span><span class="s1">points</span><span class="s2">=</span><span class="s1">points</span><span class="s2">,</span>
                                <span class="s1">incremental</span><span class="s2">=</span><span class="s0">True</span><span class="s2">,</span>
                                <span class="s1">qhull_options</span><span class="s2">=</span><span class="s1">visibility</span><span class="s2">)</span>
        <span class="s1">hull</span><span class="s2">.</span><span class="s1">add_points</span><span class="s2">(</span><span class="s1">new_gen</span><span class="s2">)</span>
        <span class="s1">actual </span><span class="s2">= </span><span class="s1">hull</span><span class="s2">.</span><span class="s1">good</span>
        <span class="s0">if </span><span class="s5">'-' </span><span class="s0">in </span><span class="s1">visibility</span><span class="s2">:</span>
            <span class="s1">expected </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">invert</span><span class="s2">(</span><span class="s1">expected</span><span class="s2">)</span>
        <span class="s1">assert_equal</span><span class="s2">(</span><span class="s1">actual</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">parametrize</span><span class="s2">(</span><span class="s5">&quot;incremental&quot;</span><span class="s2">, [</span><span class="s0">False</span><span class="s2">, </span><span class="s0">True</span><span class="s2">])</span>
    <span class="s0">def </span><span class="s1">test_good2d_no_option</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">incremental</span><span class="s2">):</span>
        <span class="s4"># handle case where good attribute doesn't exist</span>
        <span class="s4"># because Qgn or Qg-n wasn't specified</span>
        <span class="s1">points </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([[</span><span class="s3">0.2</span><span class="s2">, </span><span class="s3">0.2</span><span class="s2">],</span>
                           <span class="s2">[</span><span class="s3">0.2</span><span class="s2">, </span><span class="s3">0.4</span><span class="s2">],</span>
                           <span class="s2">[</span><span class="s3">0.4</span><span class="s2">, </span><span class="s3">0.4</span><span class="s2">],</span>
                           <span class="s2">[</span><span class="s3">0.4</span><span class="s2">, </span><span class="s3">0.2</span><span class="s2">],</span>
                           <span class="s2">[</span><span class="s3">0.3</span><span class="s2">, </span><span class="s3">0.6</span><span class="s2">]])</span>
        <span class="s1">hull </span><span class="s2">= </span><span class="s1">qhull</span><span class="s2">.</span><span class="s1">ConvexHull</span><span class="s2">(</span><span class="s1">points</span><span class="s2">=</span><span class="s1">points</span><span class="s2">,</span>
                                <span class="s1">incremental</span><span class="s2">=</span><span class="s1">incremental</span><span class="s2">)</span>
        <span class="s1">actual </span><span class="s2">= </span><span class="s1">hull</span><span class="s2">.</span><span class="s1">good</span>
        <span class="s0">assert </span><span class="s1">actual </span><span class="s0">is None</span>
        <span class="s4"># preserve None after incremental addition</span>
        <span class="s0">if </span><span class="s1">incremental</span><span class="s2">:</span>
            <span class="s1">hull</span><span class="s2">.</span><span class="s1">add_points</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">((</span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">)))</span>
            <span class="s1">actual </span><span class="s2">= </span><span class="s1">hull</span><span class="s2">.</span><span class="s1">good</span>
            <span class="s0">assert </span><span class="s1">actual </span><span class="s0">is None</span>

    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">parametrize</span><span class="s2">(</span><span class="s5">&quot;incremental&quot;</span><span class="s2">, [</span><span class="s0">False</span><span class="s2">, </span><span class="s0">True</span><span class="s2">])</span>
    <span class="s0">def </span><span class="s1">test_good2d_inside</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">incremental</span><span class="s2">):</span>
        <span class="s4"># Make sure the QGn option gives the correct value of &quot;good&quot;.</span>
        <span class="s4"># When point n is inside the convex hull of the rest, good is</span>
        <span class="s4"># all False.</span>
        <span class="s1">points </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([[</span><span class="s3">0.2</span><span class="s2">, </span><span class="s3">0.2</span><span class="s2">],</span>
                           <span class="s2">[</span><span class="s3">0.2</span><span class="s2">, </span><span class="s3">0.4</span><span class="s2">],</span>
                           <span class="s2">[</span><span class="s3">0.4</span><span class="s2">, </span><span class="s3">0.4</span><span class="s2">],</span>
                           <span class="s2">[</span><span class="s3">0.4</span><span class="s2">, </span><span class="s3">0.2</span><span class="s2">],</span>
                           <span class="s2">[</span><span class="s3">0.3</span><span class="s2">, </span><span class="s3">0.3</span><span class="s2">]])</span>
        <span class="s1">hull </span><span class="s2">= </span><span class="s1">qhull</span><span class="s2">.</span><span class="s1">ConvexHull</span><span class="s2">(</span><span class="s1">points</span><span class="s2">=</span><span class="s1">points</span><span class="s2">,</span>
                                <span class="s1">incremental</span><span class="s2">=</span><span class="s1">incremental</span><span class="s2">,</span>
                                <span class="s1">qhull_options</span><span class="s2">=</span><span class="s5">'QG4'</span><span class="s2">)</span>
        <span class="s1">expected </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s0">False</span><span class="s2">, </span><span class="s0">False</span><span class="s2">, </span><span class="s0">False</span><span class="s2">, </span><span class="s0">False</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">bool</span><span class="s2">)</span>
        <span class="s1">actual </span><span class="s2">= </span><span class="s1">hull</span><span class="s2">.</span><span class="s1">good</span>
        <span class="s1">assert_equal</span><span class="s2">(</span><span class="s1">actual</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">parametrize</span><span class="s2">(</span><span class="s5">&quot;incremental&quot;</span><span class="s2">, [</span><span class="s0">False</span><span class="s2">, </span><span class="s0">True</span><span class="s2">])</span>
    <span class="s0">def </span><span class="s1">test_good3d</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">incremental</span><span class="s2">):</span>
        <span class="s4"># Make sure the QGn option gives the correct value of &quot;good&quot;</span>
        <span class="s4"># for a 3d figure</span>
        <span class="s1">points </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([[</span><span class="s3">0.0</span><span class="s2">, </span><span class="s3">0.0</span><span class="s2">, </span><span class="s3">0.0</span><span class="s2">],</span>
                           <span class="s2">[</span><span class="s3">0.90029516</span><span class="s2">, -</span><span class="s3">0.39187448</span><span class="s2">, </span><span class="s3">0.18948093</span><span class="s2">],</span>
                           <span class="s2">[</span><span class="s3">0.48676420</span><span class="s2">, -</span><span class="s3">0.72627633</span><span class="s2">, </span><span class="s3">0.48536925</span><span class="s2">],</span>
                           <span class="s2">[</span><span class="s3">0.57651530</span><span class="s2">, -</span><span class="s3">0.81179274</span><span class="s2">, -</span><span class="s3">0.09285832</span><span class="s2">],</span>
                           <span class="s2">[</span><span class="s3">0.67846893</span><span class="s2">, -</span><span class="s3">0.71119562</span><span class="s2">, </span><span class="s3">0.18406710</span><span class="s2">]])</span>
        <span class="s1">hull </span><span class="s2">= </span><span class="s1">qhull</span><span class="s2">.</span><span class="s1">ConvexHull</span><span class="s2">(</span><span class="s1">points</span><span class="s2">=</span><span class="s1">points</span><span class="s2">,</span>
                                <span class="s1">incremental</span><span class="s2">=</span><span class="s1">incremental</span><span class="s2">,</span>
                                <span class="s1">qhull_options</span><span class="s2">=</span><span class="s5">'QG0'</span><span class="s2">)</span>
        <span class="s1">expected </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s0">True</span><span class="s2">, </span><span class="s0">False</span><span class="s2">, </span><span class="s0">False</span><span class="s2">, </span><span class="s0">False</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">bool</span><span class="s2">)</span>
        <span class="s1">assert_equal</span><span class="s2">(</span><span class="s1">hull</span><span class="s2">.</span><span class="s1">good</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">)</span>

<span class="s0">class </span><span class="s1">TestVoronoi</span><span class="s2">:</span>

    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">parametrize</span><span class="s2">(</span><span class="s5">&quot;qhull_opts, extra_pts&quot;</span><span class="s2">, [</span>
        <span class="s4"># option Qz (default for SciPy) will add</span>
        <span class="s4"># an extra point at infinity</span>
        <span class="s2">(</span><span class="s5">&quot;Qbb Qc Qz&quot;</span><span class="s2">, </span><span class="s3">1</span><span class="s2">),</span>
        <span class="s2">(</span><span class="s5">&quot;Qbb Qc&quot;</span><span class="s2">, </span><span class="s3">0</span><span class="s2">),</span>
    <span class="s2">])</span>
    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">parametrize</span><span class="s2">(</span><span class="s5">&quot;n_pts&quot;</span><span class="s2">, [</span><span class="s3">50</span><span class="s2">, </span><span class="s3">100</span><span class="s2">])</span>
    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">parametrize</span><span class="s2">(</span><span class="s5">&quot;ndim&quot;</span><span class="s2">, [</span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s2">])</span>
    <span class="s0">def </span><span class="s1">test_point_region_structure</span><span class="s2">(</span><span class="s1">self</span><span class="s2">,</span>
                                    <span class="s1">qhull_opts</span><span class="s2">,</span>
                                    <span class="s1">n_pts</span><span class="s2">,</span>
                                    <span class="s1">extra_pts</span><span class="s2">,</span>
                                    <span class="s1">ndim</span><span class="s2">):</span>
        <span class="s4"># see gh-16773</span>
        <span class="s1">rng </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">random</span><span class="s2">.</span><span class="s1">default_rng</span><span class="s2">(</span><span class="s3">7790</span><span class="s2">)</span>
        <span class="s1">points </span><span class="s2">= </span><span class="s1">rng</span><span class="s2">.</span><span class="s1">random</span><span class="s2">((</span><span class="s1">n_pts</span><span class="s2">, </span><span class="s1">ndim</span><span class="s2">))</span>
        <span class="s1">vor </span><span class="s2">= </span><span class="s1">Voronoi</span><span class="s2">(</span><span class="s1">points</span><span class="s2">, </span><span class="s1">qhull_options</span><span class="s2">=</span><span class="s1">qhull_opts</span><span class="s2">)</span>
        <span class="s1">pt_region </span><span class="s2">= </span><span class="s1">vor</span><span class="s2">.</span><span class="s1">point_region</span>
        <span class="s0">assert </span><span class="s1">pt_region</span><span class="s2">.</span><span class="s1">max</span><span class="s2">() == </span><span class="s1">n_pts </span><span class="s2">- </span><span class="s3">1 </span><span class="s2">+ </span><span class="s1">extra_pts</span>
        <span class="s0">assert </span><span class="s1">pt_region</span><span class="s2">.</span><span class="s1">size </span><span class="s2">== </span><span class="s1">len</span><span class="s2">(</span><span class="s1">vor</span><span class="s2">.</span><span class="s1">regions</span><span class="s2">) - </span><span class="s1">extra_pts</span>
        <span class="s0">assert </span><span class="s1">len</span><span class="s2">(</span><span class="s1">vor</span><span class="s2">.</span><span class="s1">regions</span><span class="s2">) == </span><span class="s1">n_pts </span><span class="s2">+ </span><span class="s1">extra_pts</span>
        <span class="s0">assert </span><span class="s1">vor</span><span class="s2">.</span><span class="s1">points</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s3">0</span><span class="s2">] == </span><span class="s1">n_pts</span>
        <span class="s4"># if there is an empty sublist in the Voronoi</span>
        <span class="s4"># regions data structure, it should never be</span>
        <span class="s4"># indexed because it corresponds to an internally</span>
        <span class="s4"># added point at infinity and is not a member of the</span>
        <span class="s4"># generators (input points)</span>
        <span class="s0">if </span><span class="s1">extra_pts</span><span class="s2">:</span>
            <span class="s1">sublens </span><span class="s2">= [</span><span class="s1">len</span><span class="s2">(</span><span class="s1">x</span><span class="s2">) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">vor</span><span class="s2">.</span><span class="s1">regions</span><span class="s2">]</span>
            <span class="s4"># only one point at infinity (empty region)</span>
            <span class="s4"># is allowed</span>
            <span class="s0">assert </span><span class="s1">sublens</span><span class="s2">.</span><span class="s1">count</span><span class="s2">(</span><span class="s3">0</span><span class="s2">) == </span><span class="s3">1</span>
            <span class="s0">assert </span><span class="s1">sublens</span><span class="s2">.</span><span class="s1">index</span><span class="s2">(</span><span class="s3">0</span><span class="s2">) </span><span class="s0">not in </span><span class="s1">pt_region</span>

    <span class="s0">def </span><span class="s1">test_masked_array_fails</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">masked_array </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ma</span><span class="s2">.</span><span class="s1">masked_all</span><span class="s2">(</span><span class="s3">1</span><span class="s2">)</span>
        <span class="s1">assert_raises</span><span class="s2">(</span><span class="s1">ValueError</span><span class="s2">, </span><span class="s1">qhull</span><span class="s2">.</span><span class="s1">Voronoi</span><span class="s2">, </span><span class="s1">masked_array</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">test_simple</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s4"># Simple case with known Voronoi diagram</span>
        <span class="s1">points </span><span class="s2">= [(</span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">), (</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">), (</span><span class="s3">0</span><span class="s2">, </span><span class="s3">2</span><span class="s2">),</span>
                  <span class="s2">(</span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">), (</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">), (</span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">),</span>
                  <span class="s2">(</span><span class="s3">2</span><span class="s2">, </span><span class="s3">0</span><span class="s2">), (</span><span class="s3">2</span><span class="s2">, </span><span class="s3">1</span><span class="s2">), (</span><span class="s3">2</span><span class="s2">, </span><span class="s3">2</span><span class="s2">)]</span>

        <span class="s4"># qhull v o Fv Qbb Qc Qz &lt; dat</span>
        <span class="s1">output </span><span class="s2">= </span><span class="s5">&quot;&quot;&quot; 
        2 
        5 10 1 
        -10.101 -10.101 
           0.5    0.5 
           0.5    1.5 
           1.5    0.5 
           1.5    1.5 
        2 0 1 
        3 2 0 1 
        2 0 2 
        3 3 0 1 
        4 1 2 4 3 
        3 4 0 2 
        2 0 3 
        3 4 0 3 
        2 0 4 
        0 
        12 
        4 0 3 0 1 
        4 0 1 0 1 
        4 1 4 1 2 
        4 1 2 0 2 
        4 2 5 0 2 
        4 3 4 1 3 
        4 3 6 0 3 
        4 4 5 2 4 
        4 4 7 3 4 
        4 5 8 0 4 
        4 6 7 0 3 
        4 7 8 0 4 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_compare_qvoronoi</span><span class="s2">(</span><span class="s1">points</span><span class="s2">, </span><span class="s1">output</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_compare_qvoronoi</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">points</span><span class="s2">, </span><span class="s1">output</span><span class="s2">, **</span><span class="s1">kw</span><span class="s2">):</span>
        <span class="s6">&quot;&quot;&quot;Compare to output from 'qvoronoi o Fv &lt; data' to Voronoi()&quot;&quot;&quot;</span>

        <span class="s4"># Parse output</span>
        <span class="s1">output </span><span class="s2">= [</span><span class="s1">list</span><span class="s2">(</span><span class="s1">map</span><span class="s2">(</span><span class="s1">float</span><span class="s2">, </span><span class="s1">x</span><span class="s2">.</span><span class="s1">split</span><span class="s2">())) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">output</span><span class="s2">.</span><span class="s1">strip</span><span class="s2">().</span><span class="s1">splitlines</span><span class="s2">()]</span>
        <span class="s1">nvertex </span><span class="s2">= </span><span class="s1">int</span><span class="s2">(</span><span class="s1">output</span><span class="s2">[</span><span class="s3">1</span><span class="s2">][</span><span class="s3">0</span><span class="s2">])</span>
        <span class="s1">vertices </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">map</span><span class="s2">(</span><span class="s1">tuple</span><span class="s2">, </span><span class="s1">output</span><span class="s2">[</span><span class="s3">3</span><span class="s2">:</span><span class="s3">2</span><span class="s2">+</span><span class="s1">nvertex</span><span class="s2">]))  </span><span class="s4"># exclude inf</span>
        <span class="s1">nregion </span><span class="s2">= </span><span class="s1">int</span><span class="s2">(</span><span class="s1">output</span><span class="s2">[</span><span class="s3">1</span><span class="s2">][</span><span class="s3">1</span><span class="s2">])</span>
        <span class="s1">regions </span><span class="s2">= [[</span><span class="s1">int</span><span class="s2">(</span><span class="s1">y</span><span class="s2">)-</span><span class="s3">1 </span><span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">x</span><span class="s2">[</span><span class="s3">1</span><span class="s2">:]]</span>
                   <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">output</span><span class="s2">[</span><span class="s3">2</span><span class="s2">+</span><span class="s1">nvertex</span><span class="s2">:</span><span class="s3">2</span><span class="s2">+</span><span class="s1">nvertex</span><span class="s2">+</span><span class="s1">nregion</span><span class="s2">]]</span>
        <span class="s1">ridge_points </span><span class="s2">= [[</span><span class="s1">int</span><span class="s2">(</span><span class="s1">y</span><span class="s2">) </span><span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">x</span><span class="s2">[</span><span class="s3">1</span><span class="s2">:</span><span class="s3">3</span><span class="s2">]]</span>
                        <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">output</span><span class="s2">[</span><span class="s3">3</span><span class="s2">+</span><span class="s1">nvertex</span><span class="s2">+</span><span class="s1">nregion</span><span class="s2">:]]</span>
        <span class="s1">ridge_vertices </span><span class="s2">= [[</span><span class="s1">int</span><span class="s2">(</span><span class="s1">y</span><span class="s2">)-</span><span class="s3">1 </span><span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">x</span><span class="s2">[</span><span class="s3">3</span><span class="s2">:]]</span>
                          <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">output</span><span class="s2">[</span><span class="s3">3</span><span class="s2">+</span><span class="s1">nvertex</span><span class="s2">+</span><span class="s1">nregion</span><span class="s2">:]]</span>

        <span class="s4"># Compare results</span>
        <span class="s1">vor </span><span class="s2">= </span><span class="s1">qhull</span><span class="s2">.</span><span class="s1">Voronoi</span><span class="s2">(</span><span class="s1">points</span><span class="s2">, **</span><span class="s1">kw</span><span class="s2">)</span>

        <span class="s0">def </span><span class="s1">sorttuple</span><span class="s2">(</span><span class="s1">x</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">sorted</span><span class="s2">(</span><span class="s1">x</span><span class="s2">))</span>

        <span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">vor</span><span class="s2">.</span><span class="s1">vertices</span><span class="s2">, </span><span class="s1">vertices</span><span class="s2">)</span>
        <span class="s1">assert_equal</span><span class="s2">(</span><span class="s1">set</span><span class="s2">(</span><span class="s1">map</span><span class="s2">(</span><span class="s1">tuple</span><span class="s2">, </span><span class="s1">vor</span><span class="s2">.</span><span class="s1">regions</span><span class="s2">)),</span>
                     <span class="s1">set</span><span class="s2">(</span><span class="s1">map</span><span class="s2">(</span><span class="s1">tuple</span><span class="s2">, </span><span class="s1">regions</span><span class="s2">)))</span>

        <span class="s1">p1 </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">zip</span><span class="s2">(</span><span class="s1">list</span><span class="s2">(</span><span class="s1">map</span><span class="s2">(</span><span class="s1">sorttuple</span><span class="s2">, </span><span class="s1">ridge_points</span><span class="s2">)),</span>
                      <span class="s1">list</span><span class="s2">(</span><span class="s1">map</span><span class="s2">(</span><span class="s1">sorttuple</span><span class="s2">, </span><span class="s1">ridge_vertices</span><span class="s2">))))</span>
        <span class="s1">p2 </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">zip</span><span class="s2">(</span><span class="s1">list</span><span class="s2">(</span><span class="s1">map</span><span class="s2">(</span><span class="s1">sorttuple</span><span class="s2">, </span><span class="s1">vor</span><span class="s2">.</span><span class="s1">ridge_points</span><span class="s2">.</span><span class="s1">tolist</span><span class="s2">())),</span>
                      <span class="s1">list</span><span class="s2">(</span><span class="s1">map</span><span class="s2">(</span><span class="s1">sorttuple</span><span class="s2">, </span><span class="s1">vor</span><span class="s2">.</span><span class="s1">ridge_vertices</span><span class="s2">))))</span>
        <span class="s1">p1</span><span class="s2">.</span><span class="s1">sort</span><span class="s2">()</span>
        <span class="s1">p2</span><span class="s2">.</span><span class="s1">sort</span><span class="s2">()</span>

        <span class="s1">assert_equal</span><span class="s2">(</span><span class="s1">p1</span><span class="s2">, </span><span class="s1">p2</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">parametrize</span><span class="s2">(</span><span class="s5">&quot;name&quot;</span><span class="s2">, </span><span class="s1">sorted</span><span class="s2">(</span><span class="s1">DATASETS</span><span class="s2">))</span>
    <span class="s0">def </span><span class="s1">test_ridges</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">):</span>
        <span class="s4"># Check that the ridges computed by Voronoi indeed separate</span>
        <span class="s4"># the regions of nearest neighborhood, by comparing the result</span>
        <span class="s4"># to KDTree.</span>

        <span class="s1">points </span><span class="s2">= </span><span class="s1">DATASETS</span><span class="s2">[</span><span class="s1">name</span><span class="s2">]</span>

        <span class="s1">tree </span><span class="s2">= </span><span class="s1">KDTree</span><span class="s2">(</span><span class="s1">points</span><span class="s2">)</span>
        <span class="s1">vor </span><span class="s2">= </span><span class="s1">qhull</span><span class="s2">.</span><span class="s1">Voronoi</span><span class="s2">(</span><span class="s1">points</span><span class="s2">)</span>

        <span class="s0">for </span><span class="s1">p</span><span class="s2">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">vor</span><span class="s2">.</span><span class="s1">ridge_dict</span><span class="s2">.</span><span class="s1">items</span><span class="s2">():</span>
            <span class="s4"># consider only finite ridges</span>
            <span class="s0">if not </span><span class="s1">np</span><span class="s2">.</span><span class="s1">all</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">v</span><span class="s2">) &gt;= </span><span class="s3">0</span><span class="s2">):</span>
                <span class="s0">continue</span>

            <span class="s1">ridge_midpoint </span><span class="s2">= </span><span class="s1">vor</span><span class="s2">.</span><span class="s1">vertices</span><span class="s2">[</span><span class="s1">v</span><span class="s2">].</span><span class="s1">mean</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">=</span><span class="s3">0</span><span class="s2">)</span>
            <span class="s1">d </span><span class="s2">= </span><span class="s3">1e-6 </span><span class="s2">* (</span><span class="s1">points</span><span class="s2">[</span><span class="s1">p</span><span class="s2">[</span><span class="s3">0</span><span class="s2">]] - </span><span class="s1">ridge_midpoint</span><span class="s2">)</span>

            <span class="s1">dist</span><span class="s2">, </span><span class="s1">k </span><span class="s2">= </span><span class="s1">tree</span><span class="s2">.</span><span class="s1">query</span><span class="s2">(</span><span class="s1">ridge_midpoint </span><span class="s2">+ </span><span class="s1">d</span><span class="s2">, </span><span class="s1">k</span><span class="s2">=</span><span class="s3">1</span><span class="s2">)</span>
            <span class="s1">assert_equal</span><span class="s2">(</span><span class="s1">k</span><span class="s2">, </span><span class="s1">p</span><span class="s2">[</span><span class="s3">0</span><span class="s2">])</span>

            <span class="s1">dist</span><span class="s2">, </span><span class="s1">k </span><span class="s2">= </span><span class="s1">tree</span><span class="s2">.</span><span class="s1">query</span><span class="s2">(</span><span class="s1">ridge_midpoint </span><span class="s2">- </span><span class="s1">d</span><span class="s2">, </span><span class="s1">k</span><span class="s2">=</span><span class="s3">1</span><span class="s2">)</span>
            <span class="s1">assert_equal</span><span class="s2">(</span><span class="s1">k</span><span class="s2">, </span><span class="s1">p</span><span class="s2">[</span><span class="s3">1</span><span class="s2">])</span>

    <span class="s0">def </span><span class="s1">test_furthest_site</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">points </span><span class="s2">= [(</span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">), (</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">), (</span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">), (</span><span class="s3">0.5</span><span class="s2">, </span><span class="s3">0.5</span><span class="s2">), (</span><span class="s3">1.1</span><span class="s2">, </span><span class="s3">1.1</span><span class="s2">)]</span>

        <span class="s4"># qhull v o Fv Qbb Qc Qu &lt; dat</span>
        <span class="s1">output </span><span class="s2">= </span><span class="s5">&quot;&quot;&quot; 
        2 
        3 5 1 
        -10.101 -10.101 
        0.6000000000000001    0.5 
           0.5 0.6000000000000001 
        3 0 2 1 
        2 0 1 
        2 0 2 
        0 
        3 0 2 1 
        5 
        4 0 2 0 2 
        4 0 4 1 2 
        4 0 1 0 1 
        4 1 4 0 1 
        4 2 4 0 2 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_compare_qvoronoi</span><span class="s2">(</span><span class="s1">points</span><span class="s2">, </span><span class="s1">output</span><span class="s2">, </span><span class="s1">furthest_site</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">test_furthest_site_flag</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">points </span><span class="s2">= [(</span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">), (</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">), (</span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">), (</span><span class="s3">0.5</span><span class="s2">, </span><span class="s3">0.5</span><span class="s2">), (</span><span class="s3">1.1</span><span class="s2">, </span><span class="s3">1.1</span><span class="s2">)]</span>

        <span class="s1">vor </span><span class="s2">= </span><span class="s1">Voronoi</span><span class="s2">(</span><span class="s1">points</span><span class="s2">)</span>
        <span class="s1">assert_equal</span><span class="s2">(</span><span class="s1">vor</span><span class="s2">.</span><span class="s1">furthest_site</span><span class="s2">,</span><span class="s0">False</span><span class="s2">)</span>
        <span class="s1">vor </span><span class="s2">= </span><span class="s1">Voronoi</span><span class="s2">(</span><span class="s1">points</span><span class="s2">,</span><span class="s1">furthest_site</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
        <span class="s1">assert_equal</span><span class="s2">(</span><span class="s1">vor</span><span class="s2">.</span><span class="s1">furthest_site</span><span class="s2">,</span><span class="s0">True</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">fail_slow</span><span class="s2">(</span><span class="s3">5</span><span class="s2">)</span>
    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">parametrize</span><span class="s2">(</span><span class="s5">&quot;name&quot;</span><span class="s2">, </span><span class="s1">sorted</span><span class="s2">(</span><span class="s1">INCREMENTAL_DATASETS</span><span class="s2">))</span>
    <span class="s0">def </span><span class="s1">test_incremental</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">):</span>
        <span class="s4"># Test incremental construction of the triangulation</span>

        <span class="s0">if </span><span class="s1">INCREMENTAL_DATASETS</span><span class="s2">[</span><span class="s1">name</span><span class="s2">][</span><span class="s3">0</span><span class="s2">][</span><span class="s3">0</span><span class="s2">].</span><span class="s1">shape</span><span class="s2">[</span><span class="s3">1</span><span class="s2">] &gt; </span><span class="s3">3</span><span class="s2">:</span>
            <span class="s4"># too slow (testing of the result --- qhull is still fast)</span>
            <span class="s0">return</span>

        <span class="s1">chunks</span><span class="s2">, </span><span class="s1">opts </span><span class="s2">= </span><span class="s1">INCREMENTAL_DATASETS</span><span class="s2">[</span><span class="s1">name</span><span class="s2">]</span>
        <span class="s1">points </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">concatenate</span><span class="s2">(</span><span class="s1">chunks</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s3">0</span><span class="s2">)</span>

        <span class="s1">obj </span><span class="s2">= </span><span class="s1">qhull</span><span class="s2">.</span><span class="s1">Voronoi</span><span class="s2">(</span><span class="s1">chunks</span><span class="s2">[</span><span class="s3">0</span><span class="s2">], </span><span class="s1">incremental</span><span class="s2">=</span><span class="s0">True</span><span class="s2">,</span>
                             <span class="s1">qhull_options</span><span class="s2">=</span><span class="s1">opts</span><span class="s2">)</span>
        <span class="s0">for </span><span class="s1">chunk </span><span class="s0">in </span><span class="s1">chunks</span><span class="s2">[</span><span class="s3">1</span><span class="s2">:]:</span>
            <span class="s1">obj</span><span class="s2">.</span><span class="s1">add_points</span><span class="s2">(</span><span class="s1">chunk</span><span class="s2">)</span>

        <span class="s1">obj2 </span><span class="s2">= </span><span class="s1">qhull</span><span class="s2">.</span><span class="s1">Voronoi</span><span class="s2">(</span><span class="s1">points</span><span class="s2">)</span>

        <span class="s1">obj3 </span><span class="s2">= </span><span class="s1">qhull</span><span class="s2">.</span><span class="s1">Voronoi</span><span class="s2">(</span><span class="s1">chunks</span><span class="s2">[</span><span class="s3">0</span><span class="s2">], </span><span class="s1">incremental</span><span class="s2">=</span><span class="s0">True</span><span class="s2">,</span>
                             <span class="s1">qhull_options</span><span class="s2">=</span><span class="s1">opts</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">chunks</span><span class="s2">) &gt; </span><span class="s3">1</span><span class="s2">:</span>
            <span class="s1">obj3</span><span class="s2">.</span><span class="s1">add_points</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">concatenate</span><span class="s2">(</span><span class="s1">chunks</span><span class="s2">[</span><span class="s3">1</span><span class="s2">:], </span><span class="s1">axis</span><span class="s2">=</span><span class="s3">0</span><span class="s2">),</span>
                            <span class="s1">restart</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>

        <span class="s4"># -- Check that the incremental mode agrees with upfront mode</span>
        <span class="s1">assert_equal</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">.</span><span class="s1">point_region</span><span class="s2">), </span><span class="s1">len</span><span class="s2">(</span><span class="s1">obj2</span><span class="s2">.</span><span class="s1">point_region</span><span class="s2">))</span>
        <span class="s1">assert_equal</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">.</span><span class="s1">point_region</span><span class="s2">), </span><span class="s1">len</span><span class="s2">(</span><span class="s1">obj3</span><span class="s2">.</span><span class="s1">point_region</span><span class="s2">))</span>

        <span class="s4"># The vertices may be in different order or duplicated in</span>
        <span class="s4"># the incremental map</span>
        <span class="s0">for </span><span class="s1">objx </span><span class="s0">in </span><span class="s1">obj</span><span class="s2">, </span><span class="s1">obj3</span><span class="s2">:</span>
            <span class="s1">vertex_map </span><span class="s2">= {-</span><span class="s3">1</span><span class="s2">: -</span><span class="s3">1</span><span class="s2">}</span>
            <span class="s0">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">objx</span><span class="s2">.</span><span class="s1">vertices</span><span class="s2">):</span>
                <span class="s0">for </span><span class="s1">j</span><span class="s2">, </span><span class="s1">v2 </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">obj2</span><span class="s2">.</span><span class="s1">vertices</span><span class="s2">):</span>
                    <span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">allclose</span><span class="s2">(</span><span class="s1">v</span><span class="s2">, </span><span class="s1">v2</span><span class="s2">):</span>
                        <span class="s1">vertex_map</span><span class="s2">[</span><span class="s1">i</span><span class="s2">] = </span><span class="s1">j</span>

            <span class="s0">def </span><span class="s1">remap</span><span class="s2">(</span><span class="s1">x</span><span class="s2">):</span>
                <span class="s0">if </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s5">'__len__'</span><span class="s2">):</span>
                    <span class="s0">return </span><span class="s1">tuple</span><span class="s2">({</span><span class="s1">remap</span><span class="s2">(</span><span class="s1">y</span><span class="s2">) </span><span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">x</span><span class="s2">})</span>
                <span class="s0">try</span><span class="s2">:</span>
                    <span class="s0">return </span><span class="s1">vertex_map</span><span class="s2">[</span><span class="s1">x</span><span class="s2">]</span>
                <span class="s0">except </span><span class="s1">KeyError </span><span class="s0">as </span><span class="s1">e</span><span class="s2">:</span>
                    <span class="s1">message </span><span class="s2">= (</span><span class="s5">f&quot;incremental result has spurious vertex &quot;</span>
                               <span class="s5">f&quot;at </span><span class="s0">{</span><span class="s1">objx</span><span class="s2">.</span><span class="s1">vertices</span><span class="s2">[</span><span class="s1">x</span><span class="s2">]</span><span class="s0">!r}</span><span class="s5">&quot;</span><span class="s2">)</span>
                    <span class="s0">raise </span><span class="s1">AssertionError</span><span class="s2">(</span><span class="s1">message</span><span class="s2">) </span><span class="s0">from </span><span class="s1">e</span>

            <span class="s0">def </span><span class="s1">simplified</span><span class="s2">(</span><span class="s1">x</span><span class="s2">):</span>
                <span class="s1">items </span><span class="s2">= </span><span class="s1">set</span><span class="s2">(</span><span class="s1">map</span><span class="s2">(</span><span class="s1">sorted_tuple</span><span class="s2">, </span><span class="s1">x</span><span class="s2">))</span>
                <span class="s0">if </span><span class="s2">() </span><span class="s0">in </span><span class="s1">items</span><span class="s2">:</span>
                    <span class="s1">items</span><span class="s2">.</span><span class="s1">remove</span><span class="s2">(())</span>
                <span class="s1">items </span><span class="s2">= [</span><span class="s1">x </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">items </span><span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">x</span><span class="s2">) &gt; </span><span class="s3">1</span><span class="s2">]</span>
                <span class="s1">items</span><span class="s2">.</span><span class="s1">sort</span><span class="s2">()</span>
                <span class="s0">return </span><span class="s1">items</span>

            <span class="s1">assert_equal</span><span class="s2">(</span>
                <span class="s1">simplified</span><span class="s2">(</span><span class="s1">remap</span><span class="s2">(</span><span class="s1">objx</span><span class="s2">.</span><span class="s1">regions</span><span class="s2">)),</span>
                <span class="s1">simplified</span><span class="s2">(</span><span class="s1">obj2</span><span class="s2">.</span><span class="s1">regions</span><span class="s2">)</span>
                <span class="s2">)</span>
            <span class="s1">assert_equal</span><span class="s2">(</span>
                <span class="s1">simplified</span><span class="s2">(</span><span class="s1">remap</span><span class="s2">(</span><span class="s1">objx</span><span class="s2">.</span><span class="s1">ridge_vertices</span><span class="s2">)),</span>
                <span class="s1">simplified</span><span class="s2">(</span><span class="s1">obj2</span><span class="s2">.</span><span class="s1">ridge_vertices</span><span class="s2">)</span>
                <span class="s2">)</span>

            <span class="s4"># XXX: compare ridge_points --- not clear exactly how to do this</span>


<span class="s0">class </span><span class="s1">Test_HalfspaceIntersection</span><span class="s2">:</span>
    <span class="s0">def </span><span class="s1">assert_unordered_allclose</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">arr1</span><span class="s2">, </span><span class="s1">arr2</span><span class="s2">, </span><span class="s1">rtol</span><span class="s2">=</span><span class="s3">1e-7</span><span class="s2">):</span>
        <span class="s6">&quot;&quot;&quot;Check that every line in arr1 is only once in arr2&quot;&quot;&quot;</span>
        <span class="s1">assert_equal</span><span class="s2">(</span><span class="s1">arr1</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">arr2</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">)</span>

        <span class="s1">truths </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">((</span><span class="s1">arr1</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s3">0</span><span class="s2">],), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">bool</span><span class="s2">)</span>
        <span class="s0">for </span><span class="s1">l1 </span><span class="s0">in </span><span class="s1">arr1</span><span class="s2">:</span>
            <span class="s1">indexes </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">nonzero</span><span class="s2">((</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">arr2 </span><span class="s2">- </span><span class="s1">l1</span><span class="s2">) &lt; </span><span class="s1">rtol</span><span class="s2">).</span><span class="s1">all</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">=</span><span class="s3">1</span><span class="s2">))[</span><span class="s3">0</span><span class="s2">]</span>
            <span class="s1">assert_equal</span><span class="s2">(</span><span class="s1">indexes</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">, (</span><span class="s3">1</span><span class="s2">,))</span>
            <span class="s1">truths</span><span class="s2">[</span><span class="s1">indexes</span><span class="s2">[</span><span class="s3">0</span><span class="s2">]] = </span><span class="s0">True</span>
        <span class="s1">assert_</span><span class="s2">(</span><span class="s1">truths</span><span class="s2">.</span><span class="s1">all</span><span class="s2">())</span>

    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">parametrize</span><span class="s2">(</span><span class="s5">&quot;dt&quot;</span><span class="s2">, [</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">, </span><span class="s1">int</span><span class="s2">])</span>
    <span class="s0">def </span><span class="s1">test_cube_halfspace_intersection</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">dt</span><span class="s2">):</span>
        <span class="s1">halfspaces </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([[-</span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">],</span>
                               <span class="s2">[</span><span class="s3">0</span><span class="s2">, -</span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">],</span>
                               <span class="s2">[</span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, -</span><span class="s3">2</span><span class="s2">],</span>
                               <span class="s2">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, -</span><span class="s3">2</span><span class="s2">]], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dt</span><span class="s2">)</span>
        <span class="s1">feasible_point </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dt</span><span class="s2">)</span>

        <span class="s1">points </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([[</span><span class="s3">0.0</span><span class="s2">, </span><span class="s3">0.0</span><span class="s2">], [</span><span class="s3">2.0</span><span class="s2">, </span><span class="s3">0.0</span><span class="s2">], [</span><span class="s3">0.0</span><span class="s2">, </span><span class="s3">2.0</span><span class="s2">], [</span><span class="s3">2.0</span><span class="s2">, </span><span class="s3">2.0</span><span class="s2">]])</span>

        <span class="s1">hull </span><span class="s2">= </span><span class="s1">qhull</span><span class="s2">.</span><span class="s1">HalfspaceIntersection</span><span class="s2">(</span><span class="s1">halfspaces</span><span class="s2">, </span><span class="s1">feasible_point</span><span class="s2">)</span>

        <span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">hull</span><span class="s2">.</span><span class="s1">intersections</span><span class="s2">, </span><span class="s1">points</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">test_self_dual_polytope_intersection</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">fname </span><span class="s2">= </span><span class="s1">os</span><span class="s2">.</span><span class="s1">path</span><span class="s2">.</span><span class="s1">join</span><span class="s2">(</span><span class="s1">os</span><span class="s2">.</span><span class="s1">path</span><span class="s2">.</span><span class="s1">dirname</span><span class="s2">(</span><span class="s1">__file__</span><span class="s2">), </span><span class="s5">'data'</span><span class="s2">,</span>
                             <span class="s5">'selfdual-4d-polytope.txt'</span><span class="s2">)</span>
        <span class="s1">ineqs </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">genfromtxt</span><span class="s2">(</span><span class="s1">fname</span><span class="s2">)</span>
        <span class="s1">halfspaces </span><span class="s2">= -</span><span class="s1">np</span><span class="s2">.</span><span class="s1">hstack</span><span class="s2">((</span><span class="s1">ineqs</span><span class="s2">[:, </span><span class="s3">1</span><span class="s2">:], </span><span class="s1">ineqs</span><span class="s2">[:, :</span><span class="s3">1</span><span class="s2">]))</span>

        <span class="s1">feas_point </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s3">0.</span><span class="s2">, </span><span class="s3">0.</span><span class="s2">, </span><span class="s3">0.</span><span class="s2">, </span><span class="s3">0.</span><span class="s2">])</span>
        <span class="s1">hs </span><span class="s2">= </span><span class="s1">qhull</span><span class="s2">.</span><span class="s1">HalfspaceIntersection</span><span class="s2">(</span><span class="s1">halfspaces</span><span class="s2">, </span><span class="s1">feas_point</span><span class="s2">)</span>

        <span class="s1">assert_equal</span><span class="s2">(</span><span class="s1">hs</span><span class="s2">.</span><span class="s1">intersections</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">, (</span><span class="s3">24</span><span class="s2">, </span><span class="s3">4</span><span class="s2">))</span>

        <span class="s1">assert_almost_equal</span><span class="s2">(</span><span class="s1">hs</span><span class="s2">.</span><span class="s1">dual_volume</span><span class="s2">, </span><span class="s3">32.0</span><span class="s2">)</span>
        <span class="s1">assert_equal</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">hs</span><span class="s2">.</span><span class="s1">dual_facets</span><span class="s2">), </span><span class="s3">24</span><span class="s2">)</span>
        <span class="s0">for </span><span class="s1">facet </span><span class="s0">in </span><span class="s1">hs</span><span class="s2">.</span><span class="s1">dual_facets</span><span class="s2">:</span>
            <span class="s1">assert_equal</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">facet</span><span class="s2">), </span><span class="s3">6</span><span class="s2">)</span>

        <span class="s1">dists </span><span class="s2">= </span><span class="s1">halfspaces</span><span class="s2">[:, -</span><span class="s3">1</span><span class="s2">] + </span><span class="s1">halfspaces</span><span class="s2">[:, :-</span><span class="s3">1</span><span class="s2">].</span><span class="s1">dot</span><span class="s2">(</span><span class="s1">feas_point</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_unordered_allclose</span><span class="s2">((</span><span class="s1">halfspaces</span><span class="s2">[:, :-</span><span class="s3">1</span><span class="s2">].</span><span class="s1">T</span><span class="s2">/</span><span class="s1">dists</span><span class="s2">).</span><span class="s1">T</span><span class="s2">, </span><span class="s1">hs</span><span class="s2">.</span><span class="s1">dual_points</span><span class="s2">)</span>

        <span class="s1">points </span><span class="s2">= </span><span class="s1">itertools</span><span class="s2">.</span><span class="s1">permutations</span><span class="s2">([</span><span class="s3">0.</span><span class="s2">, </span><span class="s3">0.</span><span class="s2">, </span><span class="s3">0.5</span><span class="s2">, -</span><span class="s3">0.5</span><span class="s2">])</span>
        <span class="s0">for </span><span class="s1">point </span><span class="s0">in </span><span class="s1">points</span><span class="s2">:</span>
            <span class="s1">assert_equal</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">sum</span><span class="s2">((</span><span class="s1">hs</span><span class="s2">.</span><span class="s1">intersections </span><span class="s2">== </span><span class="s1">point</span><span class="s2">).</span><span class="s1">all</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">=</span><span class="s3">1</span><span class="s2">)), </span><span class="s3">1</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">test_wrong_feasible_point</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">halfspaces </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([[-</span><span class="s3">1.0</span><span class="s2">, </span><span class="s3">0.0</span><span class="s2">, </span><span class="s3">0.0</span><span class="s2">],</span>
                               <span class="s2">[</span><span class="s3">0.0</span><span class="s2">, -</span><span class="s3">1.0</span><span class="s2">, </span><span class="s3">0.0</span><span class="s2">],</span>
                               <span class="s2">[</span><span class="s3">1.0</span><span class="s2">, </span><span class="s3">0.0</span><span class="s2">, -</span><span class="s3">1.0</span><span class="s2">],</span>
                               <span class="s2">[</span><span class="s3">0.0</span><span class="s2">, </span><span class="s3">1.0</span><span class="s2">, -</span><span class="s3">1.0</span><span class="s2">]])</span>
        <span class="s1">feasible_point </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s3">0.5</span><span class="s2">, </span><span class="s3">0.5</span><span class="s2">, </span><span class="s3">0.5</span><span class="s2">])</span>
        <span class="s4">#Feasible point is (ndim,) instead of (ndim-1,)</span>
        <span class="s1">assert_raises</span><span class="s2">(</span><span class="s1">ValueError</span><span class="s2">,</span>
                      <span class="s1">qhull</span><span class="s2">.</span><span class="s1">HalfspaceIntersection</span><span class="s2">, </span><span class="s1">halfspaces</span><span class="s2">, </span><span class="s1">feasible_point</span><span class="s2">)</span>
        <span class="s1">feasible_point </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([[</span><span class="s3">0.5</span><span class="s2">], [</span><span class="s3">0.5</span><span class="s2">]])</span>
        <span class="s4">#Feasible point is (ndim-1, 1) instead of (ndim-1,)</span>
        <span class="s1">assert_raises</span><span class="s2">(</span><span class="s1">ValueError</span><span class="s2">,</span>
                      <span class="s1">qhull</span><span class="s2">.</span><span class="s1">HalfspaceIntersection</span><span class="s2">, </span><span class="s1">halfspaces</span><span class="s2">, </span><span class="s1">feasible_point</span><span class="s2">)</span>
        <span class="s1">feasible_point </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([[</span><span class="s3">0.5</span><span class="s2">, </span><span class="s3">0.5</span><span class="s2">]])</span>
        <span class="s4">#Feasible point is (1, ndim-1) instead of (ndim-1,)</span>
        <span class="s1">assert_raises</span><span class="s2">(</span><span class="s1">ValueError</span><span class="s2">,</span>
                      <span class="s1">qhull</span><span class="s2">.</span><span class="s1">HalfspaceIntersection</span><span class="s2">, </span><span class="s1">halfspaces</span><span class="s2">, </span><span class="s1">feasible_point</span><span class="s2">)</span>

        <span class="s1">feasible_point </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([-</span><span class="s3">0.5</span><span class="s2">, -</span><span class="s3">0.5</span><span class="s2">])</span>
        <span class="s4">#Feasible point is outside feasible region</span>
        <span class="s1">assert_raises</span><span class="s2">(</span><span class="s1">qhull</span><span class="s2">.</span><span class="s1">QhullError</span><span class="s2">,</span>
                      <span class="s1">qhull</span><span class="s2">.</span><span class="s1">HalfspaceIntersection</span><span class="s2">, </span><span class="s1">halfspaces</span><span class="s2">, </span><span class="s1">feasible_point</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">test_incremental</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s4">#Cube</span>
        <span class="s1">halfspaces </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([[</span><span class="s3">0.</span><span class="s2">, </span><span class="s3">0.</span><span class="s2">, -</span><span class="s3">1.</span><span class="s2">, -</span><span class="s3">0.5</span><span class="s2">],</span>
                               <span class="s2">[</span><span class="s3">0.</span><span class="s2">, -</span><span class="s3">1.</span><span class="s2">, </span><span class="s3">0.</span><span class="s2">, -</span><span class="s3">0.5</span><span class="s2">],</span>
                               <span class="s2">[-</span><span class="s3">1.</span><span class="s2">, </span><span class="s3">0.</span><span class="s2">, </span><span class="s3">0.</span><span class="s2">, -</span><span class="s3">0.5</span><span class="s2">],</span>
                               <span class="s2">[</span><span class="s3">1.</span><span class="s2">, </span><span class="s3">0.</span><span class="s2">, </span><span class="s3">0.</span><span class="s2">, -</span><span class="s3">0.5</span><span class="s2">],</span>
                               <span class="s2">[</span><span class="s3">0.</span><span class="s2">, </span><span class="s3">1.</span><span class="s2">, </span><span class="s3">0.</span><span class="s2">, -</span><span class="s3">0.5</span><span class="s2">],</span>
                               <span class="s2">[</span><span class="s3">0.</span><span class="s2">, </span><span class="s3">0.</span><span class="s2">, </span><span class="s3">1.</span><span class="s2">, -</span><span class="s3">0.5</span><span class="s2">]])</span>
        <span class="s4">#Cut each summit</span>
        <span class="s1">extra_normals </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([[</span><span class="s3">1.</span><span class="s2">, </span><span class="s3">1.</span><span class="s2">, </span><span class="s3">1.</span><span class="s2">],</span>
                                  <span class="s2">[</span><span class="s3">1.</span><span class="s2">, </span><span class="s3">1.</span><span class="s2">, -</span><span class="s3">1.</span><span class="s2">],</span>
                                  <span class="s2">[</span><span class="s3">1.</span><span class="s2">, -</span><span class="s3">1.</span><span class="s2">, </span><span class="s3">1.</span><span class="s2">],</span>
                                  <span class="s2">[</span><span class="s3">1</span><span class="s2">, -</span><span class="s3">1.</span><span class="s2">, -</span><span class="s3">1.</span><span class="s2">]])</span>
        <span class="s1">offsets </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([[-</span><span class="s3">1.</span><span class="s2">]]*</span><span class="s3">8</span><span class="s2">)</span>
        <span class="s1">extra_halfspaces </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">hstack</span><span class="s2">((</span><span class="s1">np</span><span class="s2">.</span><span class="s1">vstack</span><span class="s2">((</span><span class="s1">extra_normals</span><span class="s2">, -</span><span class="s1">extra_normals</span><span class="s2">)),</span>
                                      <span class="s1">offsets</span><span class="s2">))</span>

        <span class="s1">feas_point </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s3">0.</span><span class="s2">, </span><span class="s3">0.</span><span class="s2">, </span><span class="s3">0.</span><span class="s2">])</span>

        <span class="s1">inc_hs </span><span class="s2">= </span><span class="s1">qhull</span><span class="s2">.</span><span class="s1">HalfspaceIntersection</span><span class="s2">(</span><span class="s1">halfspaces</span><span class="s2">, </span><span class="s1">feas_point</span><span class="s2">, </span><span class="s1">incremental</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>

        <span class="s1">inc_res_hs </span><span class="s2">= </span><span class="s1">qhull</span><span class="s2">.</span><span class="s1">HalfspaceIntersection</span><span class="s2">(</span><span class="s1">halfspaces</span><span class="s2">, </span><span class="s1">feas_point</span><span class="s2">,</span>
                                                 <span class="s1">incremental</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>

        <span class="s0">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">ehs </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">extra_halfspaces</span><span class="s2">):</span>
            <span class="s1">inc_hs</span><span class="s2">.</span><span class="s1">add_halfspaces</span><span class="s2">(</span><span class="s1">ehs</span><span class="s2">[</span><span class="s1">np</span><span class="s2">.</span><span class="s1">newaxis</span><span class="s2">, :])</span>

            <span class="s1">inc_res_hs</span><span class="s2">.</span><span class="s1">add_halfspaces</span><span class="s2">(</span><span class="s1">ehs</span><span class="s2">[</span><span class="s1">np</span><span class="s2">.</span><span class="s1">newaxis</span><span class="s2">, :], </span><span class="s1">restart</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>

            <span class="s1">total </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">vstack</span><span class="s2">((</span><span class="s1">halfspaces</span><span class="s2">, </span><span class="s1">extra_halfspaces</span><span class="s2">[:</span><span class="s1">i</span><span class="s2">+</span><span class="s3">1</span><span class="s2">, :]))</span>

            <span class="s1">hs </span><span class="s2">= </span><span class="s1">qhull</span><span class="s2">.</span><span class="s1">HalfspaceIntersection</span><span class="s2">(</span><span class="s1">total</span><span class="s2">, </span><span class="s1">feas_point</span><span class="s2">)</span>

            <span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">inc_hs</span><span class="s2">.</span><span class="s1">halfspaces</span><span class="s2">, </span><span class="s1">inc_res_hs</span><span class="s2">.</span><span class="s1">halfspaces</span><span class="s2">)</span>
            <span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">inc_hs</span><span class="s2">.</span><span class="s1">halfspaces</span><span class="s2">, </span><span class="s1">hs</span><span class="s2">.</span><span class="s1">halfspaces</span><span class="s2">)</span>

            <span class="s4">#Direct computation and restart should have points in same order</span>
            <span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">hs</span><span class="s2">.</span><span class="s1">intersections</span><span class="s2">, </span><span class="s1">inc_res_hs</span><span class="s2">.</span><span class="s1">intersections</span><span class="s2">)</span>
            <span class="s4">#Incremental will have points in different order than direct computation</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">assert_unordered_allclose</span><span class="s2">(</span><span class="s1">inc_hs</span><span class="s2">.</span><span class="s1">intersections</span><span class="s2">, </span><span class="s1">hs</span><span class="s2">.</span><span class="s1">intersections</span><span class="s2">)</span>

        <span class="s1">inc_hs</span><span class="s2">.</span><span class="s1">close</span><span class="s2">()</span>

    <span class="s0">def </span><span class="s1">test_cube</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s4"># Halfspaces of the cube:</span>
        <span class="s1">halfspaces </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([[-</span><span class="s3">1.</span><span class="s2">, </span><span class="s3">0.</span><span class="s2">, </span><span class="s3">0.</span><span class="s2">, </span><span class="s3">0.</span><span class="s2">],  </span><span class="s4"># x &gt;= 0</span>
                               <span class="s2">[</span><span class="s3">1.</span><span class="s2">, </span><span class="s3">0.</span><span class="s2">, </span><span class="s3">0.</span><span class="s2">, -</span><span class="s3">1.</span><span class="s2">],  </span><span class="s4"># x &lt;= 1</span>
                               <span class="s2">[</span><span class="s3">0.</span><span class="s2">, -</span><span class="s3">1.</span><span class="s2">, </span><span class="s3">0.</span><span class="s2">, </span><span class="s3">0.</span><span class="s2">],  </span><span class="s4"># y &gt;= 0</span>
                               <span class="s2">[</span><span class="s3">0.</span><span class="s2">, </span><span class="s3">1.</span><span class="s2">, </span><span class="s3">0.</span><span class="s2">, -</span><span class="s3">1.</span><span class="s2">],  </span><span class="s4"># y &lt;= 1</span>
                               <span class="s2">[</span><span class="s3">0.</span><span class="s2">, </span><span class="s3">0.</span><span class="s2">, -</span><span class="s3">1.</span><span class="s2">, </span><span class="s3">0.</span><span class="s2">],  </span><span class="s4"># z &gt;= 0</span>
                               <span class="s2">[</span><span class="s3">0.</span><span class="s2">, </span><span class="s3">0.</span><span class="s2">, </span><span class="s3">1.</span><span class="s2">, -</span><span class="s3">1.</span><span class="s2">]])  </span><span class="s4"># z &lt;= 1</span>
        <span class="s1">point </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s3">0.5</span><span class="s2">, </span><span class="s3">0.5</span><span class="s2">, </span><span class="s3">0.5</span><span class="s2">])</span>

        <span class="s1">hs </span><span class="s2">= </span><span class="s1">qhull</span><span class="s2">.</span><span class="s1">HalfspaceIntersection</span><span class="s2">(</span><span class="s1">halfspaces</span><span class="s2">, </span><span class="s1">point</span><span class="s2">)</span>

        <span class="s4"># qhalf H0.5,0.5,0.5 o &lt; input.txt</span>
        <span class="s1">qhalf_points </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span>
            <span class="s2">[-</span><span class="s3">2</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">],</span>
            <span class="s2">[</span><span class="s3">2</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">],</span>
            <span class="s2">[</span><span class="s3">0</span><span class="s2">, -</span><span class="s3">2</span><span class="s2">, </span><span class="s3">0</span><span class="s2">],</span>
            <span class="s2">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">0</span><span class="s2">],</span>
            <span class="s2">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, -</span><span class="s3">2</span><span class="s2">],</span>
            <span class="s2">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">2</span><span class="s2">]])</span>
        <span class="s1">qhalf_facets </span><span class="s2">= [</span>
            <span class="s2">[</span><span class="s3">2</span><span class="s2">, </span><span class="s3">4</span><span class="s2">, </span><span class="s3">0</span><span class="s2">],</span>
            <span class="s2">[</span><span class="s3">4</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">1</span><span class="s2">],</span>
            <span class="s2">[</span><span class="s3">5</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">0</span><span class="s2">],</span>
            <span class="s2">[</span><span class="s3">2</span><span class="s2">, </span><span class="s3">5</span><span class="s2">, </span><span class="s3">1</span><span class="s2">],</span>
            <span class="s2">[</span><span class="s3">3</span><span class="s2">, </span><span class="s3">4</span><span class="s2">, </span><span class="s3">1</span><span class="s2">],</span>
            <span class="s2">[</span><span class="s3">4</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">0</span><span class="s2">],</span>
            <span class="s2">[</span><span class="s3">5</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">1</span><span class="s2">],</span>
            <span class="s2">[</span><span class="s3">3</span><span class="s2">, </span><span class="s3">5</span><span class="s2">, </span><span class="s3">0</span><span class="s2">]]</span>

        <span class="s0">assert </span><span class="s1">len</span><span class="s2">(</span><span class="s1">qhalf_facets</span><span class="s2">) == </span><span class="s1">len</span><span class="s2">(</span><span class="s1">hs</span><span class="s2">.</span><span class="s1">dual_facets</span><span class="s2">)</span>
        <span class="s0">for </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b </span><span class="s0">in </span><span class="s1">zip</span><span class="s2">(</span><span class="s1">qhalf_facets</span><span class="s2">, </span><span class="s1">hs</span><span class="s2">.</span><span class="s1">dual_facets</span><span class="s2">):</span>
            <span class="s0">assert </span><span class="s1">set</span><span class="s2">(</span><span class="s1">a</span><span class="s2">) == </span><span class="s1">set</span><span class="s2">(</span><span class="s1">b</span><span class="s2">)  </span><span class="s4"># facet orientation can differ</span>

        <span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">hs</span><span class="s2">.</span><span class="s1">dual_points</span><span class="s2">, </span><span class="s1">qhalf_points</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">parametrize</span><span class="s2">(</span><span class="s5">&quot;diagram_type&quot;</span><span class="s2">, [</span><span class="s1">Voronoi</span><span class="s2">, </span><span class="s1">qhull</span><span class="s2">.</span><span class="s1">Delaunay</span><span class="s2">])</span>
<span class="s0">def </span><span class="s1">test_gh_20623</span><span class="s2">(</span><span class="s1">diagram_type</span><span class="s2">):</span>
    <span class="s1">rng </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">random</span><span class="s2">.</span><span class="s1">default_rng</span><span class="s2">(</span><span class="s3">123</span><span class="s2">)</span>
    <span class="s1">invalid_data </span><span class="s2">= </span><span class="s1">rng</span><span class="s2">.</span><span class="s1">random</span><span class="s2">((</span><span class="s3">4</span><span class="s2">, </span><span class="s3">10</span><span class="s2">, </span><span class="s3">3</span><span class="s2">))</span>
    <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">ValueError</span><span class="s2">, </span><span class="s1">match</span><span class="s2">=</span><span class="s5">&quot;dimensions&quot;</span><span class="s2">):</span>
        <span class="s1">diagram_type</span><span class="s2">(</span><span class="s1">invalid_data</span><span class="s2">)</span>
</pre>
</body>
</html>