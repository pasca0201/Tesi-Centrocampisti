<html>
<head>
<title>_fit.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #5f826b; font-style: italic;}
.s4 { color: #2aacb8;}
.s5 { color: #6aab73;}
.s6 { color: #7a7e85;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_fit.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">warnings</span>
<span class="s0">from </span><span class="s1">collections </span><span class="s0">import </span><span class="s1">namedtuple</span>
<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">from </span><span class="s1">scipy </span><span class="s0">import </span><span class="s1">optimize</span><span class="s2">, </span><span class="s1">stats</span>
<span class="s0">from </span><span class="s1">scipy</span><span class="s2">.</span><span class="s1">_lib</span><span class="s2">.</span><span class="s1">_util </span><span class="s0">import </span><span class="s1">check_random_state</span>


<span class="s0">def </span><span class="s1">_combine_bounds</span><span class="s2">(</span><span class="s1">name</span><span class="s2">, </span><span class="s1">user_bounds</span><span class="s2">, </span><span class="s1">shape_domain</span><span class="s2">, </span><span class="s1">integral</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot;Intersection of user-defined bounds and distribution PDF/PMF domain&quot;&quot;&quot;</span>

    <span class="s1">user_bounds </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">atleast_1d</span><span class="s2">(</span><span class="s1">user_bounds</span><span class="s2">)</span>

    <span class="s0">if </span><span class="s1">user_bounds</span><span class="s2">[</span><span class="s4">0</span><span class="s2">] &gt; </span><span class="s1">user_bounds</span><span class="s2">[</span><span class="s4">1</span><span class="s2">]:</span>
        <span class="s1">message </span><span class="s2">= (</span><span class="s5">f&quot;There are no values for `</span><span class="s0">{</span><span class="s1">name</span><span class="s0">}</span><span class="s5">` on the interval &quot;</span>
                   <span class="s5">f&quot;</span><span class="s0">{</span><span class="s1">list</span><span class="s2">(</span><span class="s1">user_bounds</span><span class="s2">)</span><span class="s0">}</span><span class="s5">.&quot;</span><span class="s2">)</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s1">message</span><span class="s2">)</span>

    <span class="s1">bounds </span><span class="s2">= (</span><span class="s1">max</span><span class="s2">(</span><span class="s1">user_bounds</span><span class="s2">[</span><span class="s4">0</span><span class="s2">], </span><span class="s1">shape_domain</span><span class="s2">[</span><span class="s4">0</span><span class="s2">]),</span>
              <span class="s1">min</span><span class="s2">(</span><span class="s1">user_bounds</span><span class="s2">[</span><span class="s4">1</span><span class="s2">], </span><span class="s1">shape_domain</span><span class="s2">[</span><span class="s4">1</span><span class="s2">]))</span>

    <span class="s0">if </span><span class="s1">integral </span><span class="s0">and </span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">ceil</span><span class="s2">(</span><span class="s1">bounds</span><span class="s2">[</span><span class="s4">0</span><span class="s2">]) &gt; </span><span class="s1">np</span><span class="s2">.</span><span class="s1">floor</span><span class="s2">(</span><span class="s1">bounds</span><span class="s2">[</span><span class="s4">1</span><span class="s2">])):</span>
        <span class="s1">message </span><span class="s2">= (</span><span class="s5">f&quot;There are no integer values for `</span><span class="s0">{</span><span class="s1">name</span><span class="s0">}</span><span class="s5">` on the interval &quot;</span>
                   <span class="s5">f&quot;defined by the user-provided bounds and the domain &quot;</span>
                   <span class="s5">&quot;of the distribution.&quot;</span><span class="s2">)</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s1">message</span><span class="s2">)</span>
    <span class="s0">elif not </span><span class="s1">integral </span><span class="s0">and </span><span class="s2">(</span><span class="s1">bounds</span><span class="s2">[</span><span class="s4">0</span><span class="s2">] &gt; </span><span class="s1">bounds</span><span class="s2">[</span><span class="s4">1</span><span class="s2">]):</span>
        <span class="s1">message </span><span class="s2">= (</span><span class="s5">f&quot;There are no values for `</span><span class="s0">{</span><span class="s1">name</span><span class="s0">}</span><span class="s5">` on the interval &quot;</span>
                   <span class="s5">f&quot;defined by the user-provided bounds and the domain &quot;</span>
                   <span class="s5">&quot;of the distribution.&quot;</span><span class="s2">)</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s1">message</span><span class="s2">)</span>

    <span class="s0">if not </span><span class="s1">np</span><span class="s2">.</span><span class="s1">all</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">isfinite</span><span class="s2">(</span><span class="s1">bounds</span><span class="s2">)):</span>
        <span class="s1">message </span><span class="s2">= (</span><span class="s5">f&quot;The intersection of user-provided bounds for `</span><span class="s0">{</span><span class="s1">name</span><span class="s0">}</span><span class="s5">` &quot;</span>
                   <span class="s5">f&quot;and the domain of the distribution is not finite. Please &quot;</span>
                   <span class="s5">f&quot;provide finite bounds for shape `</span><span class="s0">{</span><span class="s1">name</span><span class="s0">}</span><span class="s5">` in `bounds`.&quot;</span><span class="s2">)</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s1">message</span><span class="s2">)</span>

    <span class="s0">return </span><span class="s1">bounds</span>


<span class="s0">class </span><span class="s1">FitResult</span><span class="s2">:</span>
    <span class="s3">r&quot;&quot;&quot;Result of fitting a discrete or continuous distribution to data 
 
    Attributes 
    ---------- 
    params : namedtuple 
        A namedtuple containing the maximum likelihood estimates of the 
        shape parameters, location, and (if applicable) scale of the 
        distribution. 
    success : bool or None 
        Whether the optimizer considered the optimization to terminate 
        successfully or not. 
    message : str or None 
        Any status message provided by the optimizer. 
 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">dist</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">discrete</span><span class="s2">, </span><span class="s1">res</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_dist </span><span class="s2">= </span><span class="s1">dist</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_data </span><span class="s2">= </span><span class="s1">data</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">discrete </span><span class="s2">= </span><span class="s1">discrete</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">pxf </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">dist</span><span class="s2">, </span><span class="s5">&quot;pmf&quot;</span><span class="s2">, </span><span class="s0">None</span><span class="s2">) </span><span class="s0">or </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">dist</span><span class="s2">, </span><span class="s5">&quot;pdf&quot;</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>

        <span class="s1">shape_names </span><span class="s2">= [] </span><span class="s0">if </span><span class="s1">dist</span><span class="s2">.</span><span class="s1">shapes </span><span class="s0">is None else </span><span class="s1">dist</span><span class="s2">.</span><span class="s1">shapes</span><span class="s2">.</span><span class="s1">split</span><span class="s2">(</span><span class="s5">&quot;, &quot;</span><span class="s2">)</span>
        <span class="s0">if not </span><span class="s1">discrete</span><span class="s2">:</span>
            <span class="s1">FitParams </span><span class="s2">= </span><span class="s1">namedtuple</span><span class="s2">(</span><span class="s5">'FitParams'</span><span class="s2">, </span><span class="s1">shape_names </span><span class="s2">+ [</span><span class="s5">'loc'</span><span class="s2">, </span><span class="s5">'scale'</span><span class="s2">])</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">FitParams </span><span class="s2">= </span><span class="s1">namedtuple</span><span class="s2">(</span><span class="s5">'FitParams'</span><span class="s2">, </span><span class="s1">shape_names </span><span class="s2">+ [</span><span class="s5">'loc'</span><span class="s2">])</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">params </span><span class="s2">= </span><span class="s1">FitParams</span><span class="s2">(*</span><span class="s1">res</span><span class="s2">.</span><span class="s1">x</span><span class="s2">)</span>

        <span class="s6"># Optimizer can report success even when nllf is infinite</span>
        <span class="s0">if </span><span class="s1">res</span><span class="s2">.</span><span class="s1">success </span><span class="s0">and not </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isfinite</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">nllf</span><span class="s2">()):</span>
            <span class="s1">res</span><span class="s2">.</span><span class="s1">success </span><span class="s2">= </span><span class="s0">False</span>
            <span class="s1">res</span><span class="s2">.</span><span class="s1">message </span><span class="s2">= (</span><span class="s5">&quot;Optimization converged to parameter values that &quot;</span>
                           <span class="s5">&quot;are inconsistent with the data.&quot;</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">success </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">res</span><span class="s2">, </span><span class="s5">&quot;success&quot;</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">message </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">res</span><span class="s2">, </span><span class="s5">&quot;message&quot;</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">__repr__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">keys </span><span class="s2">= [</span><span class="s5">&quot;params&quot;</span><span class="s2">, </span><span class="s5">&quot;success&quot;</span><span class="s2">, </span><span class="s5">&quot;message&quot;</span><span class="s2">]</span>
        <span class="s1">m </span><span class="s2">= </span><span class="s1">max</span><span class="s2">(</span><span class="s1">map</span><span class="s2">(</span><span class="s1">len</span><span class="s2">, </span><span class="s1">keys</span><span class="s2">)) + </span><span class="s4">1</span>
        <span class="s0">return </span><span class="s5">'</span><span class="s0">\n</span><span class="s5">'</span><span class="s2">.</span><span class="s1">join</span><span class="s2">([</span><span class="s1">key</span><span class="s2">.</span><span class="s1">rjust</span><span class="s2">(</span><span class="s1">m</span><span class="s2">) + </span><span class="s5">': ' </span><span class="s2">+ </span><span class="s1">repr</span><span class="s2">(</span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">key</span><span class="s2">))</span>
                          <span class="s0">for </span><span class="s1">key </span><span class="s0">in </span><span class="s1">keys </span><span class="s0">if </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">key</span><span class="s2">) </span><span class="s0">is not None</span><span class="s2">])</span>

    <span class="s0">def </span><span class="s1">nllf</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">params</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">data</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;Negative log-likelihood function 
 
        Evaluates the negative of the log-likelihood function of the provided 
        data at the provided parameters. 
 
        Parameters 
        ---------- 
        params : tuple, optional 
            The shape parameters, location, and (if applicable) scale of the 
            distribution as a single tuple. Default is the maximum likelihood 
            estimates (``self.params``). 
        data : array_like, optional 
            The data for which the log-likelihood function is to be evaluated. 
            Default is the data to which the distribution was fit. 
 
        Returns 
        ------- 
        nllf : float 
            The negative of the log-likelihood function. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">params </span><span class="s2">= </span><span class="s1">params </span><span class="s0">if </span><span class="s1">params </span><span class="s0">is not None else </span><span class="s1">self</span><span class="s2">.</span><span class="s1">params</span>
        <span class="s1">data </span><span class="s2">= </span><span class="s1">data </span><span class="s0">if </span><span class="s1">data </span><span class="s0">is not None else </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_dist</span><span class="s2">.</span><span class="s1">nnlf</span><span class="s2">(</span><span class="s1">theta</span><span class="s2">=</span><span class="s1">params</span><span class="s2">, </span><span class="s1">x</span><span class="s2">=</span><span class="s1">data</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">plot</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">ax</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, *, </span><span class="s1">plot_type</span><span class="s2">=</span><span class="s5">&quot;hist&quot;</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;Visually compare the data against the fitted distribution. 
 
        Available only if `matplotlib` is installed. 
 
        Parameters 
        ---------- 
        ax : `matplotlib.axes.Axes` 
            Axes object to draw the plot onto, otherwise uses the current Axes. 
        plot_type : {&quot;hist&quot;, &quot;qq&quot;, &quot;pp&quot;, &quot;cdf&quot;} 
            Type of plot to draw. Options include: 
 
            - &quot;hist&quot;: Superposes the PDF/PMF of the fitted distribution 
              over a normalized histogram of the data. 
            - &quot;qq&quot;: Scatter plot of theoretical quantiles against the 
              empirical quantiles. Specifically, the x-coordinates are the 
              values of the fitted distribution PPF evaluated at the 
              percentiles ``(np.arange(1, n) - 0.5)/n``, where ``n`` is the 
              number of data points, and the y-coordinates are the sorted 
              data points. 
            - &quot;pp&quot;: Scatter plot of theoretical percentiles against the 
              observed percentiles. Specifically, the x-coordinates are the 
              percentiles ``(np.arange(1, n) - 0.5)/n``, where ``n`` is 
              the number of data points, and the y-coordinates are the values 
              of the fitted distribution CDF evaluated at the sorted 
              data points. 
            - &quot;cdf&quot;: Superposes the CDF of the fitted distribution over the 
              empirical CDF. Specifically, the x-coordinates of the empirical 
              CDF are the sorted data points, and the y-coordinates are the 
              percentiles ``(np.arange(1, n) - 0.5)/n``, where ``n`` is 
              the number of data points. 
 
        Returns 
        ------- 
        ax : `matplotlib.axes.Axes` 
            The matplotlib Axes object on which the plot was drawn. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; import numpy as np 
        &gt;&gt;&gt; from scipy import stats 
        &gt;&gt;&gt; import matplotlib.pyplot as plt  # matplotlib must be installed 
        &gt;&gt;&gt; rng = np.random.default_rng() 
        &gt;&gt;&gt; data = stats.nbinom(5, 0.5).rvs(size=1000, random_state=rng) 
        &gt;&gt;&gt; bounds = [(0, 30), (0, 1)] 
        &gt;&gt;&gt; res = stats.fit(stats.nbinom, data, bounds) 
        &gt;&gt;&gt; ax = res.plot()  # save matplotlib Axes object 
 
        The `matplotlib.axes.Axes` object can be used to customize the plot. 
        See `matplotlib.axes.Axes` documentation for details. 
 
        &gt;&gt;&gt; ax.set_xlabel('number of trials')  # customize axis label 
        &gt;&gt;&gt; ax.get_children()[0].set_linewidth(5)  # customize line widths 
        &gt;&gt;&gt; ax.legend() 
        &gt;&gt;&gt; plt.show() 
        &quot;&quot;&quot;</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s0">import </span><span class="s1">matplotlib  </span><span class="s6"># noqa: F401</span>
        <span class="s0">except </span><span class="s1">ModuleNotFoundError </span><span class="s0">as </span><span class="s1">exc</span><span class="s2">:</span>
            <span class="s1">message </span><span class="s2">= </span><span class="s5">&quot;matplotlib must be installed to use method `plot`.&quot;</span>
            <span class="s0">raise </span><span class="s1">ModuleNotFoundError</span><span class="s2">(</span><span class="s1">message</span><span class="s2">) </span><span class="s0">from </span><span class="s1">exc</span>

        <span class="s1">plots </span><span class="s2">= {</span><span class="s5">'histogram'</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_hist_plot</span><span class="s2">, </span><span class="s5">'qq'</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_qq_plot</span><span class="s2">,</span>
                 <span class="s5">'pp'</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_pp_plot</span><span class="s2">, </span><span class="s5">'cdf'</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_cdf_plot</span><span class="s2">,</span>
                 <span class="s5">'hist'</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_hist_plot</span><span class="s2">}</span>
        <span class="s0">if </span><span class="s1">plot_type</span><span class="s2">.</span><span class="s1">lower</span><span class="s2">() </span><span class="s0">not in </span><span class="s1">plots</span><span class="s2">:</span>
            <span class="s1">message </span><span class="s2">= </span><span class="s5">f&quot;`plot_type` must be one of </span><span class="s0">{</span><span class="s1">set</span><span class="s2">(</span><span class="s1">plots</span><span class="s2">.</span><span class="s1">keys</span><span class="s2">())</span><span class="s0">}</span><span class="s5">&quot;</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s1">message</span><span class="s2">)</span>
        <span class="s1">plot </span><span class="s2">= </span><span class="s1">plots</span><span class="s2">[</span><span class="s1">plot_type</span><span class="s2">.</span><span class="s1">lower</span><span class="s2">()]</span>

        <span class="s0">if </span><span class="s1">ax </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s0">import </span><span class="s1">matplotlib</span><span class="s2">.</span><span class="s1">pyplot </span><span class="s0">as </span><span class="s1">plt</span>
            <span class="s1">ax </span><span class="s2">= </span><span class="s1">plt</span><span class="s2">.</span><span class="s1">gca</span><span class="s2">()</span>

        <span class="s1">fit_params </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">atleast_1d</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">params</span><span class="s2">)</span>

        <span class="s0">return </span><span class="s1">plot</span><span class="s2">(</span><span class="s1">ax</span><span class="s2">=</span><span class="s1">ax</span><span class="s2">, </span><span class="s1">fit_params</span><span class="s2">=</span><span class="s1">fit_params</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_hist_plot</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">ax</span><span class="s2">, </span><span class="s1">fit_params</span><span class="s2">):</span>
        <span class="s0">from </span><span class="s1">matplotlib</span><span class="s2">.</span><span class="s1">ticker </span><span class="s0">import </span><span class="s1">MaxNLocator</span>

        <span class="s1">support </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_dist</span><span class="s2">.</span><span class="s1">support</span><span class="s2">(*</span><span class="s1">fit_params</span><span class="s2">)</span>
        <span class="s1">lb </span><span class="s2">= </span><span class="s1">support</span><span class="s2">[</span><span class="s4">0</span><span class="s2">] </span><span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isfinite</span><span class="s2">(</span><span class="s1">support</span><span class="s2">[</span><span class="s4">0</span><span class="s2">]) </span><span class="s0">else </span><span class="s1">min</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">)</span>
        <span class="s1">ub </span><span class="s2">= </span><span class="s1">support</span><span class="s2">[</span><span class="s4">1</span><span class="s2">] </span><span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isfinite</span><span class="s2">(</span><span class="s1">support</span><span class="s2">[</span><span class="s4">1</span><span class="s2">]) </span><span class="s0">else </span><span class="s1">max</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">)</span>
        <span class="s1">pxf </span><span class="s2">= </span><span class="s5">&quot;PMF&quot; </span><span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">discrete </span><span class="s0">else </span><span class="s5">&quot;PDF&quot;</span>

        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">discrete</span><span class="s2">:</span>
            <span class="s1">x </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(</span><span class="s1">lb</span><span class="s2">, </span><span class="s1">ub </span><span class="s2">+ </span><span class="s4">2</span><span class="s2">)</span>
            <span class="s1">y </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">pxf</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, *</span><span class="s1">fit_params</span><span class="s2">)</span>
            <span class="s1">ax</span><span class="s2">.</span><span class="s1">vlines</span><span class="s2">(</span><span class="s1">x</span><span class="s2">[:-</span><span class="s4">1</span><span class="s2">], </span><span class="s4">0</span><span class="s2">, </span><span class="s1">y</span><span class="s2">[:-</span><span class="s4">1</span><span class="s2">], </span><span class="s1">label</span><span class="s2">=</span><span class="s5">'Fitted Distribution PMF'</span><span class="s2">,</span>
                      <span class="s1">color</span><span class="s2">=</span><span class="s5">'C0'</span><span class="s2">)</span>
            <span class="s1">options </span><span class="s2">= </span><span class="s1">dict</span><span class="s2">(</span><span class="s1">density</span><span class="s2">=</span><span class="s0">True</span><span class="s2">, </span><span class="s1">bins</span><span class="s2">=</span><span class="s1">x</span><span class="s2">, </span><span class="s1">align</span><span class="s2">=</span><span class="s5">'left'</span><span class="s2">, </span><span class="s1">color</span><span class="s2">=</span><span class="s5">'C1'</span><span class="s2">)</span>
            <span class="s1">ax</span><span class="s2">.</span><span class="s1">xaxis</span><span class="s2">.</span><span class="s1">set_major_locator</span><span class="s2">(</span><span class="s1">MaxNLocator</span><span class="s2">(</span><span class="s1">integer</span><span class="s2">=</span><span class="s0">True</span><span class="s2">))</span>
            <span class="s1">ax</span><span class="s2">.</span><span class="s1">set_xlabel</span><span class="s2">(</span><span class="s5">'k'</span><span class="s2">)</span>
            <span class="s1">ax</span><span class="s2">.</span><span class="s1">set_ylabel</span><span class="s2">(</span><span class="s5">'PMF'</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">x </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linspace</span><span class="s2">(</span><span class="s1">lb</span><span class="s2">, </span><span class="s1">ub</span><span class="s2">, </span><span class="s4">200</span><span class="s2">)</span>
            <span class="s1">y </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">pxf</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, *</span><span class="s1">fit_params</span><span class="s2">)</span>
            <span class="s1">ax</span><span class="s2">.</span><span class="s1">plot</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s5">'--'</span><span class="s2">, </span><span class="s1">label</span><span class="s2">=</span><span class="s5">'Fitted Distribution PDF'</span><span class="s2">, </span><span class="s1">color</span><span class="s2">=</span><span class="s5">'C0'</span><span class="s2">)</span>
            <span class="s1">options </span><span class="s2">= </span><span class="s1">dict</span><span class="s2">(</span><span class="s1">density</span><span class="s2">=</span><span class="s0">True</span><span class="s2">, </span><span class="s1">bins</span><span class="s2">=</span><span class="s4">50</span><span class="s2">, </span><span class="s1">align</span><span class="s2">=</span><span class="s5">'mid'</span><span class="s2">, </span><span class="s1">color</span><span class="s2">=</span><span class="s5">'C1'</span><span class="s2">)</span>
            <span class="s1">ax</span><span class="s2">.</span><span class="s1">set_xlabel</span><span class="s2">(</span><span class="s5">'x'</span><span class="s2">)</span>
            <span class="s1">ax</span><span class="s2">.</span><span class="s1">set_ylabel</span><span class="s2">(</span><span class="s5">'PDF'</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">) &gt; </span><span class="s4">50 </span><span class="s0">or </span><span class="s1">self</span><span class="s2">.</span><span class="s1">discrete</span><span class="s2">:</span>
            <span class="s1">ax</span><span class="s2">.</span><span class="s1">hist</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">, </span><span class="s1">label</span><span class="s2">=</span><span class="s5">&quot;Histogram of Data&quot;</span><span class="s2">, **</span><span class="s1">options</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">ax</span><span class="s2">.</span><span class="s1">plot</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros_like</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">), </span><span class="s5">&quot;*&quot;</span><span class="s2">,</span>
                    <span class="s1">label</span><span class="s2">=</span><span class="s5">'Data'</span><span class="s2">, </span><span class="s1">color</span><span class="s2">=</span><span class="s5">'C1'</span><span class="s2">)</span>

        <span class="s1">ax</span><span class="s2">.</span><span class="s1">set_title</span><span class="s2">(</span><span class="s5">rf&quot;Fitted $\tt </span><span class="s0">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_dist</span><span class="s2">.</span><span class="s1">name</span><span class="s0">}</span><span class="s5">$ </span><span class="s0">{</span><span class="s1">pxf</span><span class="s0">} </span><span class="s5">and Histogram&quot;</span><span class="s2">)</span>
        <span class="s1">ax</span><span class="s2">.</span><span class="s1">legend</span><span class="s2">(*</span><span class="s1">ax</span><span class="s2">.</span><span class="s1">get_legend_handles_labels</span><span class="s2">())</span>
        <span class="s0">return </span><span class="s1">ax</span>

    <span class="s0">def </span><span class="s1">_qp_plot</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">ax</span><span class="s2">, </span><span class="s1">fit_params</span><span class="s2">, </span><span class="s1">qq</span><span class="s2">):</span>
        <span class="s1">data </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sort</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">)</span>
        <span class="s1">ps </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_plotting_positions</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">))</span>

        <span class="s0">if </span><span class="s1">qq</span><span class="s2">:</span>
            <span class="s1">qp </span><span class="s2">= </span><span class="s5">&quot;Quantiles&quot;</span>
            <span class="s1">plot_type </span><span class="s2">= </span><span class="s5">'Q-Q'</span>
            <span class="s1">x </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_dist</span><span class="s2">.</span><span class="s1">ppf</span><span class="s2">(</span><span class="s1">ps</span><span class="s2">, *</span><span class="s1">fit_params</span><span class="s2">)</span>
            <span class="s1">y </span><span class="s2">= </span><span class="s1">data</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">qp </span><span class="s2">= </span><span class="s5">&quot;Percentiles&quot;</span>
            <span class="s1">plot_type </span><span class="s2">= </span><span class="s5">'P-P'</span>
            <span class="s1">x </span><span class="s2">= </span><span class="s1">ps</span>
            <span class="s1">y </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_dist</span><span class="s2">.</span><span class="s1">cdf</span><span class="s2">(</span><span class="s1">data</span><span class="s2">, *</span><span class="s1">fit_params</span><span class="s2">)</span>

        <span class="s1">ax</span><span class="s2">.</span><span class="s1">plot</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s5">'.'</span><span class="s2">, </span><span class="s1">label</span><span class="s2">=</span><span class="s5">f'Fitted Distribution </span><span class="s0">{</span><span class="s1">plot_type</span><span class="s0">}</span><span class="s5">'</span><span class="s2">,</span>
                <span class="s1">color</span><span class="s2">=</span><span class="s5">'C0'</span><span class="s2">, </span><span class="s1">zorder</span><span class="s2">=</span><span class="s4">1</span><span class="s2">)</span>
        <span class="s1">xlim </span><span class="s2">= </span><span class="s1">ax</span><span class="s2">.</span><span class="s1">get_xlim</span><span class="s2">()</span>
        <span class="s1">ylim </span><span class="s2">= </span><span class="s1">ax</span><span class="s2">.</span><span class="s1">get_ylim</span><span class="s2">()</span>
        <span class="s1">lim </span><span class="s2">= [</span><span class="s1">min</span><span class="s2">(</span><span class="s1">xlim</span><span class="s2">[</span><span class="s4">0</span><span class="s2">], </span><span class="s1">ylim</span><span class="s2">[</span><span class="s4">0</span><span class="s2">]), </span><span class="s1">max</span><span class="s2">(</span><span class="s1">xlim</span><span class="s2">[</span><span class="s4">1</span><span class="s2">], </span><span class="s1">ylim</span><span class="s2">[</span><span class="s4">1</span><span class="s2">])]</span>
        <span class="s0">if not </span><span class="s1">qq</span><span class="s2">:</span>
            <span class="s1">lim </span><span class="s2">= </span><span class="s1">max</span><span class="s2">(</span><span class="s1">lim</span><span class="s2">[</span><span class="s4">0</span><span class="s2">], </span><span class="s4">0</span><span class="s2">), </span><span class="s1">min</span><span class="s2">(</span><span class="s1">lim</span><span class="s2">[</span><span class="s4">1</span><span class="s2">], </span><span class="s4">1</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">discrete </span><span class="s0">and </span><span class="s1">qq</span><span class="s2">:</span>
            <span class="s1">q_min</span><span class="s2">, </span><span class="s1">q_max </span><span class="s2">= </span><span class="s1">int</span><span class="s2">(</span><span class="s1">lim</span><span class="s2">[</span><span class="s4">0</span><span class="s2">]), </span><span class="s1">int</span><span class="s2">(</span><span class="s1">lim</span><span class="s2">[</span><span class="s4">1</span><span class="s2">]+</span><span class="s4">1</span><span class="s2">)</span>
            <span class="s1">q_ideal </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(</span><span class="s1">q_min</span><span class="s2">, </span><span class="s1">q_max</span><span class="s2">)</span>
            <span class="s6"># q_ideal = np.unique(self._dist.ppf(ps, *fit_params))</span>
            <span class="s1">ax</span><span class="s2">.</span><span class="s1">plot</span><span class="s2">(</span><span class="s1">q_ideal</span><span class="s2">, </span><span class="s1">q_ideal</span><span class="s2">, </span><span class="s5">'o'</span><span class="s2">, </span><span class="s1">label</span><span class="s2">=</span><span class="s5">'Reference'</span><span class="s2">, </span><span class="s1">color</span><span class="s2">=</span><span class="s5">'k'</span><span class="s2">,</span>
                    <span class="s1">alpha</span><span class="s2">=</span><span class="s4">0.25</span><span class="s2">, </span><span class="s1">markerfacecolor</span><span class="s2">=</span><span class="s5">'none'</span><span class="s2">, </span><span class="s1">clip_on</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
        <span class="s0">elif </span><span class="s1">self</span><span class="s2">.</span><span class="s1">discrete </span><span class="s0">and not </span><span class="s1">qq</span><span class="s2">:</span>
            <span class="s6"># The intent of this is to match the plot that would be produced</span>
            <span class="s6"># if x were continuous on [0, 1] and y were cdf(ppf(x)).</span>
            <span class="s6"># It can be approximated by letting x = np.linspace(0, 1, 1000),</span>
            <span class="s6"># but this might not look great when zooming in. The vertical</span>
            <span class="s6"># portions are included to indicate where the transition occurs</span>
            <span class="s6"># where the data completely obscures the horizontal portions.</span>
            <span class="s1">p_min</span><span class="s2">, </span><span class="s1">p_max </span><span class="s2">= </span><span class="s1">lim</span>
            <span class="s1">a</span><span class="s2">, </span><span class="s1">b </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_dist</span><span class="s2">.</span><span class="s1">support</span><span class="s2">(*</span><span class="s1">fit_params</span><span class="s2">)</span>
            <span class="s1">p_min </span><span class="s2">= </span><span class="s1">max</span><span class="s2">(</span><span class="s1">p_min</span><span class="s2">, </span><span class="s4">0 </span><span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isfinite</span><span class="s2">(</span><span class="s1">a</span><span class="s2">) </span><span class="s0">else </span><span class="s4">1e-3</span><span class="s2">)</span>
            <span class="s1">p_max </span><span class="s2">= </span><span class="s1">min</span><span class="s2">(</span><span class="s1">p_max</span><span class="s2">, </span><span class="s4">1 </span><span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isfinite</span><span class="s2">(</span><span class="s1">b</span><span class="s2">) </span><span class="s0">else </span><span class="s4">1</span><span class="s2">-</span><span class="s4">1e-3</span><span class="s2">)</span>
            <span class="s1">q_min</span><span class="s2">, </span><span class="s1">q_max </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_dist</span><span class="s2">.</span><span class="s1">ppf</span><span class="s2">([</span><span class="s1">p_min</span><span class="s2">, </span><span class="s1">p_max</span><span class="s2">], *</span><span class="s1">fit_params</span><span class="s2">)</span>
            <span class="s1">qs </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(</span><span class="s1">q_min</span><span class="s2">-</span><span class="s4">1</span><span class="s2">, </span><span class="s1">q_max</span><span class="s2">+</span><span class="s4">1</span><span class="s2">)</span>
            <span class="s1">ps </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_dist</span><span class="s2">.</span><span class="s1">cdf</span><span class="s2">(</span><span class="s1">qs</span><span class="s2">, *</span><span class="s1">fit_params</span><span class="s2">)</span>
            <span class="s1">ax</span><span class="s2">.</span><span class="s1">step</span><span class="s2">(</span><span class="s1">ps</span><span class="s2">, </span><span class="s1">ps</span><span class="s2">, </span><span class="s5">'-'</span><span class="s2">, </span><span class="s1">label</span><span class="s2">=</span><span class="s5">'Reference'</span><span class="s2">, </span><span class="s1">color</span><span class="s2">=</span><span class="s5">'k'</span><span class="s2">, </span><span class="s1">alpha</span><span class="s2">=</span><span class="s4">0.25</span><span class="s2">,</span>
                    <span class="s1">clip_on</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">ax</span><span class="s2">.</span><span class="s1">plot</span><span class="s2">(</span><span class="s1">lim</span><span class="s2">, </span><span class="s1">lim</span><span class="s2">, </span><span class="s5">'-'</span><span class="s2">, </span><span class="s1">label</span><span class="s2">=</span><span class="s5">'Reference'</span><span class="s2">, </span><span class="s1">color</span><span class="s2">=</span><span class="s5">'k'</span><span class="s2">, </span><span class="s1">alpha</span><span class="s2">=</span><span class="s4">0.25</span><span class="s2">,</span>
                    <span class="s1">clip_on</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>

        <span class="s1">ax</span><span class="s2">.</span><span class="s1">set_xlim</span><span class="s2">(</span><span class="s1">lim</span><span class="s2">)</span>
        <span class="s1">ax</span><span class="s2">.</span><span class="s1">set_ylim</span><span class="s2">(</span><span class="s1">lim</span><span class="s2">)</span>
        <span class="s1">ax</span><span class="s2">.</span><span class="s1">set_xlabel</span><span class="s2">(</span><span class="s5">rf&quot;Fitted $\tt </span><span class="s0">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_dist</span><span class="s2">.</span><span class="s1">name</span><span class="s0">}</span><span class="s5">$ Theoretical </span><span class="s0">{</span><span class="s1">qp</span><span class="s0">}</span><span class="s5">&quot;</span><span class="s2">)</span>
        <span class="s1">ax</span><span class="s2">.</span><span class="s1">set_ylabel</span><span class="s2">(</span><span class="s5">f&quot;Data </span><span class="s0">{</span><span class="s1">qp</span><span class="s0">}</span><span class="s5">&quot;</span><span class="s2">)</span>
        <span class="s1">ax</span><span class="s2">.</span><span class="s1">set_title</span><span class="s2">(</span><span class="s5">rf&quot;Fitted $\tt </span><span class="s0">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_dist</span><span class="s2">.</span><span class="s1">name</span><span class="s0">}</span><span class="s5">$ </span><span class="s0">{</span><span class="s1">plot_type</span><span class="s0">} </span><span class="s5">Plot&quot;</span><span class="s2">)</span>
        <span class="s1">ax</span><span class="s2">.</span><span class="s1">legend</span><span class="s2">(*</span><span class="s1">ax</span><span class="s2">.</span><span class="s1">get_legend_handles_labels</span><span class="s2">())</span>
        <span class="s1">ax</span><span class="s2">.</span><span class="s1">set_aspect</span><span class="s2">(</span><span class="s5">'equal'</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">ax</span>

    <span class="s0">def </span><span class="s1">_qq_plot</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_qp_plot</span><span class="s2">(</span><span class="s1">qq</span><span class="s2">=</span><span class="s0">True</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_pp_plot</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_qp_plot</span><span class="s2">(</span><span class="s1">qq</span><span class="s2">=</span><span class="s0">False</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_plotting_positions</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">a</span><span class="s2">=</span><span class="s4">.5</span><span class="s2">):</span>
        <span class="s6"># See https://en.wikipedia.org/wiki/Q%E2%80%93Q_plot#Plotting_positions</span>
        <span class="s1">k </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">n</span><span class="s2">+</span><span class="s4">1</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s2">(</span><span class="s1">k</span><span class="s2">-</span><span class="s1">a</span><span class="s2">) / (</span><span class="s1">n </span><span class="s2">+ </span><span class="s4">1 </span><span class="s2">- </span><span class="s4">2</span><span class="s2">*</span><span class="s1">a</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_cdf_plot</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">ax</span><span class="s2">, </span><span class="s1">fit_params</span><span class="s2">):</span>
        <span class="s1">data </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sort</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">)</span>
        <span class="s1">ecdf </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_plotting_positions</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">))</span>
        <span class="s1">ls </span><span class="s2">= </span><span class="s5">'--' </span><span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">unique</span><span class="s2">(</span><span class="s1">data</span><span class="s2">)) &lt; </span><span class="s4">30 </span><span class="s0">else </span><span class="s5">'.'</span>
        <span class="s1">xlabel </span><span class="s2">= </span><span class="s5">'k' </span><span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">discrete </span><span class="s0">else </span><span class="s5">'x'</span>
        <span class="s1">ax</span><span class="s2">.</span><span class="s1">step</span><span class="s2">(</span><span class="s1">data</span><span class="s2">, </span><span class="s1">ecdf</span><span class="s2">, </span><span class="s1">ls</span><span class="s2">, </span><span class="s1">label</span><span class="s2">=</span><span class="s5">'Empirical CDF'</span><span class="s2">, </span><span class="s1">color</span><span class="s2">=</span><span class="s5">'C1'</span><span class="s2">, </span><span class="s1">zorder</span><span class="s2">=</span><span class="s4">0</span><span class="s2">)</span>

        <span class="s1">xlim </span><span class="s2">= </span><span class="s1">ax</span><span class="s2">.</span><span class="s1">get_xlim</span><span class="s2">()</span>
        <span class="s1">q </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linspace</span><span class="s2">(*</span><span class="s1">xlim</span><span class="s2">, </span><span class="s4">300</span><span class="s2">)</span>
        <span class="s1">tcdf </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_dist</span><span class="s2">.</span><span class="s1">cdf</span><span class="s2">(</span><span class="s1">q</span><span class="s2">, *</span><span class="s1">fit_params</span><span class="s2">)</span>

        <span class="s1">ax</span><span class="s2">.</span><span class="s1">plot</span><span class="s2">(</span><span class="s1">q</span><span class="s2">, </span><span class="s1">tcdf</span><span class="s2">, </span><span class="s1">label</span><span class="s2">=</span><span class="s5">'Fitted Distribution CDF'</span><span class="s2">, </span><span class="s1">color</span><span class="s2">=</span><span class="s5">'C0'</span><span class="s2">, </span><span class="s1">zorder</span><span class="s2">=</span><span class="s4">1</span><span class="s2">)</span>
        <span class="s1">ax</span><span class="s2">.</span><span class="s1">set_xlim</span><span class="s2">(</span><span class="s1">xlim</span><span class="s2">)</span>
        <span class="s1">ax</span><span class="s2">.</span><span class="s1">set_ylim</span><span class="s2">(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">)</span>
        <span class="s1">ax</span><span class="s2">.</span><span class="s1">set_xlabel</span><span class="s2">(</span><span class="s1">xlabel</span><span class="s2">)</span>
        <span class="s1">ax</span><span class="s2">.</span><span class="s1">set_ylabel</span><span class="s2">(</span><span class="s5">&quot;CDF&quot;</span><span class="s2">)</span>
        <span class="s1">ax</span><span class="s2">.</span><span class="s1">set_title</span><span class="s2">(</span><span class="s5">rf&quot;Fitted $\tt </span><span class="s0">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_dist</span><span class="s2">.</span><span class="s1">name</span><span class="s0">}</span><span class="s5">$ and Empirical CDF&quot;</span><span class="s2">)</span>
        <span class="s1">handles</span><span class="s2">, </span><span class="s1">labels </span><span class="s2">= </span><span class="s1">ax</span><span class="s2">.</span><span class="s1">get_legend_handles_labels</span><span class="s2">()</span>
        <span class="s1">ax</span><span class="s2">.</span><span class="s1">legend</span><span class="s2">(</span><span class="s1">handles</span><span class="s2">[::-</span><span class="s4">1</span><span class="s2">], </span><span class="s1">labels</span><span class="s2">[::-</span><span class="s4">1</span><span class="s2">])</span>
        <span class="s0">return </span><span class="s1">ax</span>


<span class="s0">def </span><span class="s1">fit</span><span class="s2">(</span><span class="s1">dist</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">bounds</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, *, </span><span class="s1">guess</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">method</span><span class="s2">=</span><span class="s5">'mle'</span><span class="s2">,</span>
        <span class="s1">optimizer</span><span class="s2">=</span><span class="s1">optimize</span><span class="s2">.</span><span class="s1">differential_evolution</span><span class="s2">):</span>
    <span class="s3">r&quot;&quot;&quot;Fit a discrete or continuous distribution to data 
 
    Given a distribution, data, and bounds on the parameters of the 
    distribution, return maximum likelihood estimates of the parameters. 
 
    Parameters 
    ---------- 
    dist : `scipy.stats.rv_continuous` or `scipy.stats.rv_discrete` 
        The object representing the distribution to be fit to the data. 
    data : 1D array_like 
        The data to which the distribution is to be fit. If the data contain 
        any of ``np.nan``, ``np.inf``, or -``np.inf``, the fit method will 
        raise a ``ValueError``. 
    bounds : dict or sequence of tuples, optional 
        If a dictionary, each key is the name of a parameter of the 
        distribution, and the corresponding value is a tuple containing the 
        lower and upper bound on that parameter.  If the distribution is 
        defined only for a finite range of values of that parameter, no entry 
        for that parameter is required; e.g., some distributions have 
        parameters which must be on the interval [0, 1]. Bounds for parameters 
        location (``loc``) and scale (``scale``) are optional; by default, 
        they are fixed to 0 and 1, respectively. 
 
        If a sequence, element *i* is a tuple containing the lower and upper 
        bound on the *i*\ th parameter of the distribution. In this case, 
        bounds for *all* distribution shape parameters must be provided. 
        Optionally, bounds for location and scale may follow the 
        distribution shape parameters. 
 
        If a shape is to be held fixed (e.g. if it is known), the 
        lower and upper bounds may be equal. If a user-provided lower or upper 
        bound is beyond a bound of the domain for which the distribution is 
        defined, the bound of the distribution's domain will replace the 
        user-provided value. Similarly, parameters which must be integral 
        will be constrained to integral values within the user-provided bounds. 
    guess : dict or array_like, optional 
        If a dictionary, each key is the name of a parameter of the 
        distribution, and the corresponding value is a guess for the value 
        of the parameter. 
 
        If a sequence, element *i* is a guess for the *i*\ th parameter of the 
        distribution. In this case, guesses for *all* distribution shape 
        parameters must be provided. 
 
        If `guess` is not provided, guesses for the decision variables will 
        not be passed to the optimizer. If `guess` is provided, guesses for 
        any missing parameters will be set at the mean of the lower and 
        upper bounds. Guesses for parameters which must be integral will be 
        rounded to integral values, and guesses that lie outside the 
        intersection of the user-provided bounds and the domain of the 
        distribution will be clipped. 
    method : {'mle', 'mse'} 
        With ``method=&quot;mle&quot;`` (default), the fit is computed by minimizing 
        the negative log-likelihood function. A large, finite penalty 
        (rather than infinite negative log-likelihood) is applied for 
        observations beyond the support of the distribution. 
        With ``method=&quot;mse&quot;``, the fit is computed by minimizing 
        the negative log-product spacing function. The same penalty is applied 
        for observations beyond the support. We follow the approach of [1]_, 
        which is generalized for samples with repeated observations. 
    optimizer : callable, optional 
        `optimizer` is a callable that accepts the following positional 
        argument. 
 
        fun : callable 
            The objective function to be optimized. `fun` accepts one argument 
            ``x``, candidate shape parameters of the distribution, and returns 
            the objective function value given ``x``, `dist`, and the provided 
            `data`. 
            The job of `optimizer` is to find values of the decision variables 
            that minimizes `fun`. 
 
        `optimizer` must also accept the following keyword argument. 
 
        bounds : sequence of tuples 
            The bounds on values of the decision variables; each element will 
            be a tuple containing the lower and upper bound on a decision 
            variable. 
 
        If `guess` is provided, `optimizer` must also accept the following 
        keyword argument. 
 
        x0 : array_like 
            The guesses for each decision variable. 
 
        If the distribution has any shape parameters that must be integral or 
        if the distribution is discrete and the location parameter is not 
        fixed, `optimizer` must also accept the following keyword argument. 
 
        integrality : array_like of bools 
            For each decision variable, True if the decision variable 
            must be constrained to integer values and False if the decision 
            variable is continuous. 
 
        `optimizer` must return an object, such as an instance of 
        `scipy.optimize.OptimizeResult`, which holds the optimal values of 
        the decision variables in an attribute ``x``. If attributes 
        ``fun``, ``status``, or ``message`` are provided, they will be 
        included in the result object returned by `fit`. 
 
    Returns 
    ------- 
    result : `~scipy.stats._result_classes.FitResult` 
        An object with the following fields. 
 
        params : namedtuple 
            A namedtuple containing the maximum likelihood estimates of the 
            shape parameters, location, and (if applicable) scale of the 
            distribution. 
        success : bool or None 
            Whether the optimizer considered the optimization to terminate 
            successfully or not. 
        message : str or None 
            Any status message provided by the optimizer. 
 
        The object has the following method: 
 
        nllf(params=None, data=None) 
            By default, the negative log-likehood function at the fitted 
            `params` for the given `data`. Accepts a tuple containing 
            alternative shapes, location, and scale of the distribution and 
            an array of alternative data. 
 
        plot(ax=None) 
            Superposes the PDF/PMF of the fitted distribution over a normalized 
            histogram of the data. 
 
    See Also 
    -------- 
    rv_continuous,  rv_discrete 
 
    Notes 
    ----- 
    Optimization is more likely to converge to the maximum likelihood estimate 
    when the user provides tight bounds containing the maximum likelihood 
    estimate. For example, when fitting a binomial distribution to data, the 
    number of experiments underlying each sample may be known, in which case 
    the corresponding shape parameter ``n`` can be fixed. 
 
    References 
    ---------- 
    .. [1] Shao, Yongzhao, and Marjorie G. Hahn. &quot;Maximum product of spacings 
           method: a unified formulation with illustration of strong 
           consistency.&quot; Illinois Journal of Mathematics 43.3 (1999): 489-499. 
 
    Examples 
    -------- 
    Suppose we wish to fit a distribution to the following data. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import stats 
    &gt;&gt;&gt; rng = np.random.default_rng() 
    &gt;&gt;&gt; dist = stats.nbinom 
    &gt;&gt;&gt; shapes = (5, 0.5) 
    &gt;&gt;&gt; data = dist.rvs(*shapes, size=1000, random_state=rng) 
 
    Suppose we do not know how the data were generated, but we suspect that 
    it follows a negative binomial distribution with parameters *n* and *p*\. 
    (See `scipy.stats.nbinom`.) We believe that the parameter *n* was fewer 
    than 30, and we know that the parameter *p* must lie on the interval 
    [0, 1]. We record this information in a variable `bounds` and pass 
    this information to `fit`. 
 
    &gt;&gt;&gt; bounds = [(0, 30), (0, 1)] 
    &gt;&gt;&gt; res = stats.fit(dist, data, bounds) 
 
    `fit` searches within the user-specified `bounds` for the 
    values that best match the data (in the sense of maximum likelihood 
    estimation). In this case, it found shape values similar to those 
    from which the data were actually generated. 
 
    &gt;&gt;&gt; res.params 
    FitParams(n=5.0, p=0.5028157644634368, loc=0.0)  # may vary 
 
    We can visualize the results by superposing the probability mass function 
    of the distribution (with the shapes fit to the data) over a normalized 
    histogram of the data. 
 
    &gt;&gt;&gt; import matplotlib.pyplot as plt  # matplotlib must be installed to plot 
    &gt;&gt;&gt; res.plot() 
    &gt;&gt;&gt; plt.show() 
 
    Note that the estimate for *n* was exactly integral; this is because 
    the domain of the `nbinom` PMF includes only integral *n*, and the `nbinom` 
    object &quot;knows&quot; that. `nbinom` also knows that the shape *p* must be a 
    value between 0 and 1. In such a case - when the domain of the distribution 
    with respect to a parameter is finite - we are not required to specify 
    bounds for the parameter. 
 
    &gt;&gt;&gt; bounds = {'n': (0, 30)}  # omit parameter p using a `dict` 
    &gt;&gt;&gt; res2 = stats.fit(dist, data, bounds) 
    &gt;&gt;&gt; res2.params 
    FitParams(n=5.0, p=0.5016492009232932, loc=0.0)  # may vary 
 
    If we wish to force the distribution to be fit with *n* fixed at 6, we can 
    set both the lower and upper bounds on *n* to 6. Note, however, that the 
    value of the objective function being optimized is typically worse (higher) 
    in this case. 
 
    &gt;&gt;&gt; bounds = {'n': (6, 6)}  # fix parameter `n` 
    &gt;&gt;&gt; res3 = stats.fit(dist, data, bounds) 
    &gt;&gt;&gt; res3.params 
    FitParams(n=6.0, p=0.5486556076755706, loc=0.0)  # may vary 
    &gt;&gt;&gt; res3.nllf() &gt; res.nllf() 
    True  # may vary 
 
    Note that the numerical results of the previous examples are typical, but 
    they may vary because the default optimizer used by `fit`, 
    `scipy.optimize.differential_evolution`, is stochastic. However, we can 
    customize the settings used by the optimizer to ensure reproducibility - 
    or even use a different optimizer entirely - using the `optimizer` 
    parameter. 
 
    &gt;&gt;&gt; from scipy.optimize import differential_evolution 
    &gt;&gt;&gt; rng = np.random.default_rng(767585560716548) 
    &gt;&gt;&gt; def optimizer(fun, bounds, *, integrality): 
    ...     return differential_evolution(fun, bounds, strategy='best2bin', 
    ...                                   seed=rng, integrality=integrality) 
    &gt;&gt;&gt; bounds = [(0, 30), (0, 1)] 
    &gt;&gt;&gt; res4 = stats.fit(dist, data, bounds, optimizer=optimizer) 
    &gt;&gt;&gt; res4.params 
    FitParams(n=5.0, p=0.5015183149259951, loc=0.0) 
 
    &quot;&quot;&quot;</span>
    <span class="s6"># --- Input Validation / Standardization --- #</span>
    <span class="s1">user_bounds </span><span class="s2">= </span><span class="s1">bounds</span>
    <span class="s1">user_guess </span><span class="s2">= </span><span class="s1">guess</span>

    <span class="s6"># distribution input validation and information collection</span>
    <span class="s0">if </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">dist</span><span class="s2">, </span><span class="s5">&quot;pdf&quot;</span><span class="s2">):  </span><span class="s6"># can't use isinstance for types</span>
        <span class="s1">default_bounds </span><span class="s2">= {</span><span class="s5">'loc'</span><span class="s2">: (</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">), </span><span class="s5">'scale'</span><span class="s2">: (</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">)}</span>
        <span class="s1">discrete </span><span class="s2">= </span><span class="s0">False</span>
    <span class="s0">elif </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">dist</span><span class="s2">, </span><span class="s5">&quot;pmf&quot;</span><span class="s2">):</span>
        <span class="s1">default_bounds </span><span class="s2">= {</span><span class="s5">'loc'</span><span class="s2">: (</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">)}</span>
        <span class="s1">discrete </span><span class="s2">= </span><span class="s0">True</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">message </span><span class="s2">= (</span><span class="s5">&quot;`dist` must be an instance of `rv_continuous` &quot;</span>
                   <span class="s5">&quot;or `rv_discrete.`&quot;</span><span class="s2">)</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s1">message</span><span class="s2">)</span>

    <span class="s0">try</span><span class="s2">:</span>
        <span class="s1">param_info </span><span class="s2">= </span><span class="s1">dist</span><span class="s2">.</span><span class="s1">_param_info</span><span class="s2">()</span>
    <span class="s0">except </span><span class="s1">AttributeError </span><span class="s0">as </span><span class="s1">e</span><span class="s2">:</span>
        <span class="s1">message </span><span class="s2">= (</span><span class="s5">f&quot;Distribution `</span><span class="s0">{</span><span class="s1">dist</span><span class="s2">.</span><span class="s1">name</span><span class="s0">}</span><span class="s5">` is not yet supported by &quot;</span>
                   <span class="s5">&quot;`scipy.stats.fit` because shape information has &quot;</span>
                   <span class="s5">&quot;not been defined.&quot;</span><span class="s2">)</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s1">message</span><span class="s2">) </span><span class="s0">from </span><span class="s1">e</span>

    <span class="s6"># data input validation</span>
    <span class="s1">data </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">data</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">data</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">!= </span><span class="s4">1</span><span class="s2">:</span>
        <span class="s1">message </span><span class="s2">= </span><span class="s5">&quot;`data` must be exactly one-dimensional.&quot;</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s1">message</span><span class="s2">)</span>
    <span class="s0">if not </span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">issubdtype</span><span class="s2">(</span><span class="s1">data</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">number</span><span class="s2">)</span>
            <span class="s0">and </span><span class="s1">np</span><span class="s2">.</span><span class="s1">all</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">isfinite</span><span class="s2">(</span><span class="s1">data</span><span class="s2">))):</span>
        <span class="s1">message </span><span class="s2">= </span><span class="s5">&quot;All elements of `data` must be finite numbers.&quot;</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s1">message</span><span class="s2">)</span>

    <span class="s6"># bounds input validation and information collection</span>
    <span class="s1">n_params </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">param_info</span><span class="s2">)</span>
    <span class="s1">n_shapes </span><span class="s2">= </span><span class="s1">n_params </span><span class="s2">- (</span><span class="s4">1 </span><span class="s0">if </span><span class="s1">discrete </span><span class="s0">else </span><span class="s4">2</span><span class="s2">)</span>
    <span class="s1">param_list </span><span class="s2">= [</span><span class="s1">param</span><span class="s2">.</span><span class="s1">name </span><span class="s0">for </span><span class="s1">param </span><span class="s0">in </span><span class="s1">param_info</span><span class="s2">]</span>
    <span class="s1">param_names </span><span class="s2">= </span><span class="s5">&quot;, &quot;</span><span class="s2">.</span><span class="s1">join</span><span class="s2">(</span><span class="s1">param_list</span><span class="s2">)</span>
    <span class="s1">shape_names </span><span class="s2">= </span><span class="s5">&quot;, &quot;</span><span class="s2">.</span><span class="s1">join</span><span class="s2">(</span><span class="s1">param_list</span><span class="s2">[:</span><span class="s1">n_shapes</span><span class="s2">])</span>

    <span class="s0">if </span><span class="s1">user_bounds </span><span class="s0">is None</span><span class="s2">:</span>
        <span class="s1">user_bounds </span><span class="s2">= {}</span>

    <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">user_bounds</span><span class="s2">, </span><span class="s1">dict</span><span class="s2">):</span>
        <span class="s1">default_bounds</span><span class="s2">.</span><span class="s1">update</span><span class="s2">(</span><span class="s1">user_bounds</span><span class="s2">)</span>
        <span class="s1">user_bounds </span><span class="s2">= </span><span class="s1">default_bounds</span>
        <span class="s1">user_bounds_array </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">((</span><span class="s1">n_params</span><span class="s2">, </span><span class="s4">2</span><span class="s2">))</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">n_params</span><span class="s2">):</span>
            <span class="s1">param_name </span><span class="s2">= </span><span class="s1">param_info</span><span class="s2">[</span><span class="s1">i</span><span class="s2">].</span><span class="s1">name</span>
            <span class="s1">user_bound </span><span class="s2">= </span><span class="s1">user_bounds</span><span class="s2">.</span><span class="s1">pop</span><span class="s2">(</span><span class="s1">param_name</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">user_bound </span><span class="s0">is None</span><span class="s2">:</span>
                <span class="s1">user_bound </span><span class="s2">= </span><span class="s1">param_info</span><span class="s2">[</span><span class="s1">i</span><span class="s2">].</span><span class="s1">domain</span>
            <span class="s1">user_bounds_array</span><span class="s2">[</span><span class="s1">i</span><span class="s2">] = </span><span class="s1">user_bound</span>
        <span class="s0">if </span><span class="s1">user_bounds</span><span class="s2">:</span>
            <span class="s1">message </span><span class="s2">= (</span><span class="s5">&quot;Bounds provided for the following unrecognized &quot;</span>
                       <span class="s5">f&quot;parameters will be ignored: </span><span class="s0">{</span><span class="s1">set</span><span class="s2">(</span><span class="s1">user_bounds</span><span class="s2">)</span><span class="s0">}</span><span class="s5">&quot;</span><span class="s2">)</span>
            <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span><span class="s1">message</span><span class="s2">, </span><span class="s1">RuntimeWarning</span><span class="s2">, </span><span class="s1">stacklevel</span><span class="s2">=</span><span class="s4">2</span><span class="s2">)</span>

    <span class="s0">else</span><span class="s2">:</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s1">user_bounds </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">user_bounds</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">float</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">user_bounds</span><span class="s2">.</span><span class="s1">size </span><span class="s2">== </span><span class="s4">0</span><span class="s2">:</span>
                <span class="s1">user_bounds </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">((</span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s2">))</span>
        <span class="s0">except </span><span class="s1">ValueError </span><span class="s0">as </span><span class="s1">e</span><span class="s2">:</span>
            <span class="s1">message </span><span class="s2">= (</span><span class="s5">&quot;Each element of a `bounds` sequence must be a tuple &quot;</span>
                       <span class="s5">&quot;containing two elements: the lower and upper bound of &quot;</span>
                       <span class="s5">&quot;a distribution parameter.&quot;</span><span class="s2">)</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s1">message</span><span class="s2">) </span><span class="s0">from </span><span class="s1">e</span>
        <span class="s0">if </span><span class="s2">(</span><span class="s1">user_bounds</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">!= </span><span class="s4">2 </span><span class="s0">or </span><span class="s1">user_bounds</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s4">1</span><span class="s2">] != </span><span class="s4">2</span><span class="s2">):</span>
            <span class="s1">message </span><span class="s2">= (</span><span class="s5">&quot;Each element of `bounds` must be a tuple specifying &quot;</span>
                       <span class="s5">&quot;the lower and upper bounds of a shape parameter&quot;</span><span class="s2">)</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s1">message</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">user_bounds</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s4">0</span><span class="s2">] &lt; </span><span class="s1">n_shapes</span><span class="s2">:</span>
            <span class="s1">message </span><span class="s2">= (</span><span class="s5">f&quot;A `bounds` sequence must contain at least </span><span class="s0">{</span><span class="s1">n_shapes</span><span class="s0">} </span><span class="s5">&quot;</span>
                       <span class="s5">&quot;elements: tuples specifying the lower and upper &quot;</span>
                       <span class="s5">f&quot;bounds of all shape parameters </span><span class="s0">{</span><span class="s1">shape_names</span><span class="s0">}</span><span class="s5">.&quot;</span><span class="s2">)</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s1">message</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">user_bounds</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s4">0</span><span class="s2">] &gt; </span><span class="s1">n_params</span><span class="s2">:</span>
            <span class="s1">message </span><span class="s2">= (</span><span class="s5">&quot;A `bounds` sequence may not contain more than &quot;</span>
                       <span class="s5">f&quot;</span><span class="s0">{</span><span class="s1">n_params</span><span class="s0">} </span><span class="s5">elements: tuples specifying the lower and &quot;</span>
                       <span class="s5">&quot;upper bounds of distribution parameters &quot;</span>
                       <span class="s5">f&quot;</span><span class="s0">{</span><span class="s1">param_names</span><span class="s0">}</span><span class="s5">.&quot;</span><span class="s2">)</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s1">message</span><span class="s2">)</span>

        <span class="s1">user_bounds_array </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">((</span><span class="s1">n_params</span><span class="s2">, </span><span class="s4">2</span><span class="s2">))</span>
        <span class="s1">user_bounds_array</span><span class="s2">[</span><span class="s1">n_shapes</span><span class="s2">:] = </span><span class="s1">list</span><span class="s2">(</span><span class="s1">default_bounds</span><span class="s2">.</span><span class="s1">values</span><span class="s2">())</span>
        <span class="s1">user_bounds_array</span><span class="s2">[:</span><span class="s1">len</span><span class="s2">(</span><span class="s1">user_bounds</span><span class="s2">)] = </span><span class="s1">user_bounds</span>

    <span class="s1">user_bounds </span><span class="s2">= </span><span class="s1">user_bounds_array</span>
    <span class="s1">validated_bounds </span><span class="s2">= []</span>
    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">n_params</span><span class="s2">):</span>
        <span class="s1">name </span><span class="s2">= </span><span class="s1">param_info</span><span class="s2">[</span><span class="s1">i</span><span class="s2">].</span><span class="s1">name</span>
        <span class="s1">user_bound </span><span class="s2">= </span><span class="s1">user_bounds_array</span><span class="s2">[</span><span class="s1">i</span><span class="s2">]</span>
        <span class="s1">param_domain </span><span class="s2">= </span><span class="s1">param_info</span><span class="s2">[</span><span class="s1">i</span><span class="s2">].</span><span class="s1">domain</span>
        <span class="s1">integral </span><span class="s2">= </span><span class="s1">param_info</span><span class="s2">[</span><span class="s1">i</span><span class="s2">].</span><span class="s1">integrality</span>
        <span class="s1">combined </span><span class="s2">= </span><span class="s1">_combine_bounds</span><span class="s2">(</span><span class="s1">name</span><span class="s2">, </span><span class="s1">user_bound</span><span class="s2">, </span><span class="s1">param_domain</span><span class="s2">, </span><span class="s1">integral</span><span class="s2">)</span>
        <span class="s1">validated_bounds</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">combined</span><span class="s2">)</span>

    <span class="s1">bounds </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">validated_bounds</span><span class="s2">)</span>
    <span class="s1">integrality </span><span class="s2">= [</span><span class="s1">param</span><span class="s2">.</span><span class="s1">integrality </span><span class="s0">for </span><span class="s1">param </span><span class="s0">in </span><span class="s1">param_info</span><span class="s2">]</span>

    <span class="s6"># guess input validation</span>

    <span class="s0">if </span><span class="s1">user_guess </span><span class="s0">is None</span><span class="s2">:</span>
        <span class="s1">guess_array </span><span class="s2">= </span><span class="s0">None</span>
    <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">user_guess</span><span class="s2">, </span><span class="s1">dict</span><span class="s2">):</span>
        <span class="s1">default_guess </span><span class="s2">= {</span><span class="s1">param</span><span class="s2">.</span><span class="s1">name</span><span class="s2">: </span><span class="s1">np</span><span class="s2">.</span><span class="s1">mean</span><span class="s2">(</span><span class="s1">bound</span><span class="s2">)</span>
                         <span class="s0">for </span><span class="s1">param</span><span class="s2">, </span><span class="s1">bound </span><span class="s0">in </span><span class="s1">zip</span><span class="s2">(</span><span class="s1">param_info</span><span class="s2">, </span><span class="s1">bounds</span><span class="s2">)}</span>
        <span class="s1">unrecognized </span><span class="s2">= </span><span class="s1">set</span><span class="s2">(</span><span class="s1">user_guess</span><span class="s2">) - </span><span class="s1">set</span><span class="s2">(</span><span class="s1">default_guess</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">unrecognized</span><span class="s2">:</span>
            <span class="s1">message </span><span class="s2">= (</span><span class="s5">&quot;Guesses provided for the following unrecognized &quot;</span>
                       <span class="s5">f&quot;parameters will be ignored: </span><span class="s0">{</span><span class="s1">unrecognized</span><span class="s0">}</span><span class="s5">&quot;</span><span class="s2">)</span>
            <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span><span class="s1">message</span><span class="s2">, </span><span class="s1">RuntimeWarning</span><span class="s2">, </span><span class="s1">stacklevel</span><span class="s2">=</span><span class="s4">2</span><span class="s2">)</span>
        <span class="s1">default_guess</span><span class="s2">.</span><span class="s1">update</span><span class="s2">(</span><span class="s1">user_guess</span><span class="s2">)</span>

        <span class="s1">message </span><span class="s2">= (</span><span class="s5">&quot;Each element of `guess` must be a scalar &quot;</span>
                   <span class="s5">&quot;guess for a distribution parameter.&quot;</span><span class="s2">)</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s1">guess_array </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">([</span><span class="s1">default_guess</span><span class="s2">[</span><span class="s1">param</span><span class="s2">.</span><span class="s1">name</span><span class="s2">]</span>
                                      <span class="s0">for </span><span class="s1">param </span><span class="s0">in </span><span class="s1">param_info</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">float</span><span class="s2">)</span>
        <span class="s0">except </span><span class="s1">ValueError </span><span class="s0">as </span><span class="s1">e</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s1">message</span><span class="s2">) </span><span class="s0">from </span><span class="s1">e</span>

    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">message </span><span class="s2">= (</span><span class="s5">&quot;Each element of `guess` must be a scalar &quot;</span>
                   <span class="s5">&quot;guess for a distribution parameter.&quot;</span><span class="s2">)</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s1">user_guess </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">user_guess</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">float</span><span class="s2">)</span>
        <span class="s0">except </span><span class="s1">ValueError </span><span class="s0">as </span><span class="s1">e</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s1">message</span><span class="s2">) </span><span class="s0">from </span><span class="s1">e</span>
        <span class="s0">if </span><span class="s1">user_guess</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">!= </span><span class="s4">1</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s1">message</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">user_guess</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s4">0</span><span class="s2">] &lt; </span><span class="s1">n_shapes</span><span class="s2">:</span>
            <span class="s1">message </span><span class="s2">= (</span><span class="s5">f&quot;A `guess` sequence must contain at least </span><span class="s0">{</span><span class="s1">n_shapes</span><span class="s0">} </span><span class="s5">&quot;</span>
                       <span class="s5">&quot;elements: scalar guesses for the distribution shape &quot;</span>
                       <span class="s5">f&quot;parameters </span><span class="s0">{</span><span class="s1">shape_names</span><span class="s0">}</span><span class="s5">.&quot;</span><span class="s2">)</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s1">message</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">user_guess</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s4">0</span><span class="s2">] &gt; </span><span class="s1">n_params</span><span class="s2">:</span>
            <span class="s1">message </span><span class="s2">= (</span><span class="s5">&quot;A `guess` sequence may not contain more than &quot;</span>
                       <span class="s5">f&quot;</span><span class="s0">{</span><span class="s1">n_params</span><span class="s0">} </span><span class="s5">elements: scalar guesses for the &quot;</span>
                       <span class="s5">f&quot;distribution parameters </span><span class="s0">{</span><span class="s1">param_names</span><span class="s0">}</span><span class="s5">.&quot;</span><span class="s2">)</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s1">message</span><span class="s2">)</span>

        <span class="s1">guess_array </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">mean</span><span class="s2">(</span><span class="s1">bounds</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s4">1</span><span class="s2">)</span>
        <span class="s1">guess_array</span><span class="s2">[:</span><span class="s1">len</span><span class="s2">(</span><span class="s1">user_guess</span><span class="s2">)] = </span><span class="s1">user_guess</span>

    <span class="s0">if </span><span class="s1">guess_array </span><span class="s0">is not None</span><span class="s2">:</span>
        <span class="s1">guess_rounded </span><span class="s2">= </span><span class="s1">guess_array</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>

        <span class="s1">guess_rounded</span><span class="s2">[</span><span class="s1">integrality</span><span class="s2">] = </span><span class="s1">np</span><span class="s2">.</span><span class="s1">round</span><span class="s2">(</span><span class="s1">guess_rounded</span><span class="s2">[</span><span class="s1">integrality</span><span class="s2">])</span>
        <span class="s1">rounded </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">where</span><span class="s2">(</span><span class="s1">guess_rounded </span><span class="s2">!= </span><span class="s1">guess_array</span><span class="s2">)[</span><span class="s4">0</span><span class="s2">]</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">rounded</span><span class="s2">:</span>
            <span class="s1">message </span><span class="s2">= (</span><span class="s5">f&quot;Guess for parameter `</span><span class="s0">{</span><span class="s1">param_info</span><span class="s2">[</span><span class="s1">i</span><span class="s2">].</span><span class="s1">name</span><span class="s0">}</span><span class="s5">` &quot;</span>
                       <span class="s5">f&quot;rounded from </span><span class="s0">{</span><span class="s1">guess_array</span><span class="s2">[</span><span class="s1">i</span><span class="s2">]</span><span class="s0">} </span><span class="s5">to </span><span class="s0">{</span><span class="s1">guess_rounded</span><span class="s2">[</span><span class="s1">i</span><span class="s2">]</span><span class="s0">}</span><span class="s5">.&quot;</span><span class="s2">)</span>
            <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span><span class="s1">message</span><span class="s2">, </span><span class="s1">RuntimeWarning</span><span class="s2">, </span><span class="s1">stacklevel</span><span class="s2">=</span><span class="s4">2</span><span class="s2">)</span>

        <span class="s1">guess_clipped </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">clip</span><span class="s2">(</span><span class="s1">guess_rounded</span><span class="s2">, </span><span class="s1">bounds</span><span class="s2">[:, </span><span class="s4">0</span><span class="s2">], </span><span class="s1">bounds</span><span class="s2">[:, </span><span class="s4">1</span><span class="s2">])</span>
        <span class="s1">clipped </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">where</span><span class="s2">(</span><span class="s1">guess_clipped </span><span class="s2">!= </span><span class="s1">guess_rounded</span><span class="s2">)[</span><span class="s4">0</span><span class="s2">]</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">clipped</span><span class="s2">:</span>
            <span class="s1">message </span><span class="s2">= (</span><span class="s5">f&quot;Guess for parameter `</span><span class="s0">{</span><span class="s1">param_info</span><span class="s2">[</span><span class="s1">i</span><span class="s2">].</span><span class="s1">name</span><span class="s0">}</span><span class="s5">` &quot;</span>
                       <span class="s5">f&quot;clipped from </span><span class="s0">{</span><span class="s1">guess_rounded</span><span class="s2">[</span><span class="s1">i</span><span class="s2">]</span><span class="s0">} </span><span class="s5">to &quot;</span>
                       <span class="s5">f&quot;</span><span class="s0">{</span><span class="s1">guess_clipped</span><span class="s2">[</span><span class="s1">i</span><span class="s2">]</span><span class="s0">}</span><span class="s5">.&quot;</span><span class="s2">)</span>
            <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span><span class="s1">message</span><span class="s2">, </span><span class="s1">RuntimeWarning</span><span class="s2">, </span><span class="s1">stacklevel</span><span class="s2">=</span><span class="s4">2</span><span class="s2">)</span>

        <span class="s1">guess </span><span class="s2">= </span><span class="s1">guess_clipped</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">guess </span><span class="s2">= </span><span class="s0">None</span>

    <span class="s6"># --- Fitting --- #</span>
    <span class="s0">def </span><span class="s1">nllf</span><span class="s2">(</span><span class="s1">free_params</span><span class="s2">, </span><span class="s1">data</span><span class="s2">=</span><span class="s1">data</span><span class="s2">):  </span><span class="s6"># bind data NOW</span>
        <span class="s0">with </span><span class="s1">np</span><span class="s2">.</span><span class="s1">errstate</span><span class="s2">(</span><span class="s1">invalid</span><span class="s2">=</span><span class="s5">'ignore'</span><span class="s2">, </span><span class="s1">divide</span><span class="s2">=</span><span class="s5">'ignore'</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">dist</span><span class="s2">.</span><span class="s1">_penalized_nnlf</span><span class="s2">(</span><span class="s1">free_params</span><span class="s2">, </span><span class="s1">data</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">nlpsf</span><span class="s2">(</span><span class="s1">free_params</span><span class="s2">, </span><span class="s1">data</span><span class="s2">=</span><span class="s1">data</span><span class="s2">):  </span><span class="s6"># bind data NOW</span>
        <span class="s0">with </span><span class="s1">np</span><span class="s2">.</span><span class="s1">errstate</span><span class="s2">(</span><span class="s1">invalid</span><span class="s2">=</span><span class="s5">'ignore'</span><span class="s2">, </span><span class="s1">divide</span><span class="s2">=</span><span class="s5">'ignore'</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">dist</span><span class="s2">.</span><span class="s1">_penalized_nlpsf</span><span class="s2">(</span><span class="s1">free_params</span><span class="s2">, </span><span class="s1">data</span><span class="s2">)</span>

    <span class="s1">methods </span><span class="s2">= {</span><span class="s5">'mle'</span><span class="s2">: </span><span class="s1">nllf</span><span class="s2">, </span><span class="s5">'mse'</span><span class="s2">: </span><span class="s1">nlpsf</span><span class="s2">}</span>
    <span class="s1">objective </span><span class="s2">= </span><span class="s1">methods</span><span class="s2">[</span><span class="s1">method</span><span class="s2">.</span><span class="s1">lower</span><span class="s2">()]</span>

    <span class="s0">with </span><span class="s1">np</span><span class="s2">.</span><span class="s1">errstate</span><span class="s2">(</span><span class="s1">invalid</span><span class="s2">=</span><span class="s5">'ignore'</span><span class="s2">, </span><span class="s1">divide</span><span class="s2">=</span><span class="s5">'ignore'</span><span class="s2">):</span>
        <span class="s1">kwds </span><span class="s2">= {}</span>
        <span class="s0">if </span><span class="s1">bounds </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s1">kwds</span><span class="s2">[</span><span class="s5">'bounds'</span><span class="s2">] = </span><span class="s1">bounds</span>
        <span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">any</span><span class="s2">(</span><span class="s1">integrality</span><span class="s2">):</span>
            <span class="s1">kwds</span><span class="s2">[</span><span class="s5">'integrality'</span><span class="s2">] = </span><span class="s1">integrality</span>
        <span class="s0">if </span><span class="s1">guess </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s1">kwds</span><span class="s2">[</span><span class="s5">'x0'</span><span class="s2">] = </span><span class="s1">guess</span>
        <span class="s1">res </span><span class="s2">= </span><span class="s1">optimizer</span><span class="s2">(</span><span class="s1">objective</span><span class="s2">, **</span><span class="s1">kwds</span><span class="s2">)</span>

    <span class="s0">return </span><span class="s1">FitResult</span><span class="s2">(</span><span class="s1">dist</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">discrete</span><span class="s2">, </span><span class="s1">res</span><span class="s2">)</span>


<span class="s1">GoodnessOfFitResult </span><span class="s2">= </span><span class="s1">namedtuple</span><span class="s2">(</span><span class="s5">'GoodnessOfFitResult'</span><span class="s2">,</span>
                                 <span class="s2">(</span><span class="s5">'fit_result'</span><span class="s2">, </span><span class="s5">'statistic'</span><span class="s2">, </span><span class="s5">'pvalue'</span><span class="s2">,</span>
                                  <span class="s5">'null_distribution'</span><span class="s2">))</span>


<span class="s0">def </span><span class="s1">goodness_of_fit</span><span class="s2">(</span><span class="s1">dist</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, *, </span><span class="s1">known_params</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">fit_params</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
                    <span class="s1">guessed_params</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">statistic</span><span class="s2">=</span><span class="s5">'ad'</span><span class="s2">, </span><span class="s1">n_mc_samples</span><span class="s2">=</span><span class="s4">9999</span><span class="s2">,</span>
                    <span class="s1">random_state</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
    <span class="s3">r&quot;&quot;&quot; 
    Perform a goodness of fit test comparing data to a distribution family. 
 
    Given a distribution family and data, perform a test of the null hypothesis 
    that the data were drawn from a distribution in that family. Any known 
    parameters of the distribution may be specified. Remaining parameters of 
    the distribution will be fit to the data, and the p-value of the test 
    is computed accordingly. Several statistics for comparing the distribution 
    to data are available. 
 
    Parameters 
    ---------- 
    dist : `scipy.stats.rv_continuous` 
        The object representing the distribution family under the null 
        hypothesis. 
    data : 1D array_like 
        Finite, uncensored data to be tested. 
    known_params : dict, optional 
        A dictionary containing name-value pairs of known distribution 
        parameters. Monte Carlo samples are randomly drawn from the 
        null-hypothesized distribution with these values of the parameters. 
        Before the statistic is evaluated for each Monte Carlo sample, only 
        remaining unknown parameters of the null-hypothesized distribution 
        family are fit to the samples; the known parameters are held fixed. 
        If all parameters of the distribution family are known, then the step 
        of fitting the distribution family to each sample is omitted. 
    fit_params : dict, optional 
        A dictionary containing name-value pairs of distribution parameters 
        that have already been fit to the data, e.g. using `scipy.stats.fit` 
        or the ``fit`` method of `dist`. Monte Carlo samples are drawn from the 
        null-hypothesized distribution with these specified values of the 
        parameter. On those Monte Carlo samples, however, these and all other 
        unknown parameters of the null-hypothesized distribution family are 
        fit before the statistic is evaluated. 
    guessed_params : dict, optional 
        A dictionary containing name-value pairs of distribution parameters 
        which have been guessed. These parameters are always considered as 
        free parameters and are fit both to the provided `data` as well as 
        to the Monte Carlo samples drawn from the null-hypothesized 
        distribution. The purpose of these `guessed_params` is to be used as 
        initial values for the numerical fitting procedure. 
    statistic : {&quot;ad&quot;, &quot;ks&quot;, &quot;cvm&quot;, &quot;filliben&quot;} or callable, optional 
        The statistic used to compare data to a distribution after fitting 
        unknown parameters of the distribution family to the data. The 
        Anderson-Darling (&quot;ad&quot;) [1]_, Kolmogorov-Smirnov (&quot;ks&quot;) [1]_, 
        Cramer-von Mises (&quot;cvm&quot;) [1]_, and Filliben (&quot;filliben&quot;) [7]_ 
        statistics are available.  Alternatively, a callable with signature 
        ``(dist, data, axis)`` may be supplied to compute the statistic. Here 
        ``dist`` is a frozen distribution object (potentially with array 
        parameters), ``data`` is an array of Monte Carlo samples (of 
        compatible shape), and ``axis`` is the axis of ``data`` along which 
        the statistic must be computed. 
    n_mc_samples : int, default: 9999 
        The number of Monte Carlo samples drawn from the null hypothesized 
        distribution to form the null distribution of the statistic. The 
        sample size of each is the same as the given `data`. 
    random_state : {None, int, `numpy.random.Generator`, 
                    `numpy.random.RandomState`}, optional 
 
        Pseudorandom number generator state used to generate the Monte Carlo 
        samples. 
 
        If `random_state` is ``None`` (default), the 
        `numpy.random.RandomState` singleton is used. 
        If `random_state` is an int, a new ``RandomState`` instance is used, 
        seeded with `random_state`. 
        If `random_state` is already a ``Generator`` or ``RandomState`` 
        instance, then the provided instance is used. 
 
    Returns 
    ------- 
    res : GoodnessOfFitResult 
        An object with the following attributes. 
 
        fit_result : `~scipy.stats._result_classes.FitResult` 
            An object representing the fit of the provided `dist` to `data`. 
            This  object includes the values of distribution family parameters 
            that fully define the null-hypothesized distribution, that is, 
            the distribution from which Monte Carlo samples are drawn. 
        statistic : float 
            The value of the statistic comparing provided `data` to the 
            null-hypothesized distribution. 
        pvalue : float 
            The proportion of elements in the null distribution with 
            statistic values at least as extreme as the statistic value of the 
            provided `data`. 
        null_distribution : ndarray 
            The value of the statistic for each Monte Carlo sample 
            drawn from the null-hypothesized distribution. 
 
    Notes 
    ----- 
    This is a generalized Monte Carlo goodness-of-fit procedure, special cases 
    of which correspond with various Anderson-Darling tests, Lilliefors' test, 
    etc. The test is described in [2]_, [3]_, and [4]_ as a parametric 
    bootstrap test. This is a Monte Carlo test in which parameters that 
    specify the distribution from which samples are drawn have been estimated 
    from the data. We describe the test using &quot;Monte Carlo&quot; rather than 
    &quot;parametric bootstrap&quot; throughout to avoid confusion with the more familiar 
    nonparametric bootstrap, and describe how the test is performed below. 
 
    *Traditional goodness of fit tests* 
 
    Traditionally, critical values corresponding with a fixed set of 
    significance levels are pre-calculated using Monte Carlo methods. Users 
    perform the test by calculating the value of the test statistic only for 
    their observed `data` and comparing this value to tabulated critical 
    values. This practice is not very flexible, as tables are not available for 
    all distributions and combinations of known and unknown parameter values. 
    Also, results can be inaccurate when critical values are interpolated from 
    limited tabulated data to correspond with the user's sample size and 
    fitted parameter values. To overcome these shortcomings, this function 
    allows the user to perform the Monte Carlo trials adapted to their 
    particular data. 
 
    *Algorithmic overview* 
 
    In brief, this routine executes the following steps: 
 
      1. Fit unknown parameters to the given `data`, thereby forming the 
         &quot;null-hypothesized&quot; distribution, and compute the statistic of 
         this pair of data and distribution. 
      2. Draw random samples from this null-hypothesized distribution. 
      3. Fit the unknown parameters to each random sample. 
      4. Calculate the statistic between each sample and the distribution that 
         has been fit to the sample. 
      5. Compare the value of the statistic corresponding with `data` from (1) 
         against the values of the statistic corresponding with the random 
         samples from (4). The p-value is the proportion of samples with a 
         statistic value greater than or equal to the statistic of the observed 
         data. 
 
    In more detail, the steps are as follows. 
 
    First, any unknown parameters of the distribution family specified by 
    `dist` are fit to the provided `data` using maximum likelihood estimation. 
    (One exception is the normal distribution with unknown location and scale: 
    we use the bias-corrected standard deviation ``np.std(data, ddof=1)`` for 
    the scale as recommended in [1]_.) 
    These values of the parameters specify a particular member of the 
    distribution family referred to as the &quot;null-hypothesized distribution&quot;, 
    that is, the distribution from which the data were sampled under the null 
    hypothesis. The `statistic`, which compares data to a distribution, is 
    computed between `data` and the null-hypothesized distribution. 
 
    Next, many (specifically `n_mc_samples`) new samples, each containing the 
    same number of observations as `data`, are drawn from the 
    null-hypothesized distribution. All unknown parameters of the distribution 
    family `dist` are fit to *each resample*, and the `statistic` is computed 
    between each sample and its corresponding fitted distribution. These 
    values of the statistic form the Monte Carlo null distribution (not to be 
    confused with the &quot;null-hypothesized distribution&quot; above). 
 
    The p-value of the test is the proportion of statistic values in the Monte 
    Carlo null distribution that are at least as extreme as the statistic value 
    of the provided `data`. More precisely, the p-value is given by 
 
    .. math:: 
 
        p = \frac{b + 1} 
                 {m + 1} 
 
    where :math:`b` is the number of statistic values in the Monte Carlo null 
    distribution that are greater than or equal to the statistic value 
    calculated for `data`, and :math:`m` is the number of elements in the 
    Monte Carlo null distribution (`n_mc_samples`). The addition of :math:`1` 
    to the numerator and denominator can be thought of as including the 
    value of the statistic corresponding with `data` in the null distribution, 
    but a more formal explanation is given in [5]_. 
 
    *Limitations* 
 
    The test can be very slow for some distribution families because unknown 
    parameters of the distribution family must be fit to each of the Monte 
    Carlo samples, and for most distributions in SciPy, distribution fitting 
    performed via numerical optimization. 
 
    *Anti-Pattern* 
 
    For this reason, it may be tempting 
    to treat parameters of the distribution pre-fit to `data` (by the user) 
    as though they were `known_params`, as specification of all parameters of 
    the distribution precludes the need to fit the distribution to each Monte 
    Carlo sample. (This is essentially how the original Kilmogorov-Smirnov 
    test is performed.) Although such a test can provide evidence against the 
    null hypothesis, the test is conservative in the sense that small p-values 
    will tend to (greatly) *overestimate* the probability of making a type I 
    error (that is, rejecting the null hypothesis although it is true), and the 
    power of the test is low (that is, it is less likely to reject the null 
    hypothesis even when the null hypothesis is false). 
    This is because the Monte Carlo samples are less likely to agree with the 
    null-hypothesized distribution as well as `data`. This tends to increase 
    the values of the statistic recorded in the null distribution, so that a 
    larger number of them exceed the value of statistic for `data`, thereby 
    inflating the p-value. 
 
    References 
    ---------- 
    .. [1] M. A. Stephens (1974). &quot;EDF Statistics for Goodness of Fit and 
           Some Comparisons.&quot; Journal of the American Statistical Association, 
           Vol. 69, pp. 730-737. 
    .. [2] W. Stute, W. G. Manteiga, and M. P. Quindimil (1993). 
           &quot;Bootstrap based goodness-of-fit-tests.&quot; Metrika 40.1: 243-256. 
    .. [3] C. Genest, &amp; B Rémillard. (2008). &quot;Validity of the parametric 
           bootstrap for goodness-of-fit testing in semiparametric models.&quot; 
           Annales de l'IHP Probabilités et statistiques. Vol. 44. No. 6. 
    .. [4] I. Kojadinovic and J. Yan (2012). &quot;Goodness-of-fit testing based on 
           a weighted bootstrap: A fast large-sample alternative to the 
           parametric bootstrap.&quot; Canadian Journal of Statistics 40.3: 480-500. 
    .. [5] B. Phipson and G. K. Smyth (2010). &quot;Permutation P-values Should 
           Never Be Zero: Calculating Exact P-values When Permutations Are 
           Randomly Drawn.&quot; Statistical Applications in Genetics and Molecular 
           Biology 9.1. 
    .. [6] H. W. Lilliefors (1967). &quot;On the Kolmogorov-Smirnov test for 
           normality with mean and variance unknown.&quot; Journal of the American 
           statistical Association 62.318: 399-402. 
    .. [7] Filliben, James J. &quot;The probability plot correlation coefficient 
           test for normality.&quot; Technometrics 17.1 (1975): 111-117. 
 
    Examples 
    -------- 
    A well-known test of the null hypothesis that data were drawn from a 
    given distribution is the Kolmogorov-Smirnov (KS) test, available in SciPy 
    as `scipy.stats.ks_1samp`. Suppose we wish to test whether the following 
    data: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import stats 
    &gt;&gt;&gt; rng = np.random.default_rng() 
    &gt;&gt;&gt; x = stats.uniform.rvs(size=75, random_state=rng) 
 
    were sampled from a normal distribution. To perform a KS test, the 
    empirical distribution function of the observed data will be compared 
    against the (theoretical) cumulative distribution function of a normal 
    distribution. Of course, to do this, the normal distribution under the null 
    hypothesis must be fully specified. This is commonly done by first fitting 
    the ``loc`` and ``scale`` parameters of the distribution to the observed 
    data, then performing the test. 
 
    &gt;&gt;&gt; loc, scale = np.mean(x), np.std(x, ddof=1) 
    &gt;&gt;&gt; cdf = stats.norm(loc, scale).cdf 
    &gt;&gt;&gt; stats.ks_1samp(x, cdf) 
    KstestResult(statistic=0.1119257570456813, 
                 pvalue=0.2827756409939257, 
                 statistic_location=0.7751845155861765, 
                 statistic_sign=-1) 
 
    An advantage of the KS-test is that the p-value - the probability of 
    obtaining a value of the test statistic under the null hypothesis as 
    extreme as the value obtained from the observed data - can be calculated 
    exactly and efficiently. `goodness_of_fit` can only approximate these 
    results. 
 
    &gt;&gt;&gt; known_params = {'loc': loc, 'scale': scale} 
    &gt;&gt;&gt; res = stats.goodness_of_fit(stats.norm, x, known_params=known_params, 
    ...                             statistic='ks', random_state=rng) 
    &gt;&gt;&gt; res.statistic, res.pvalue 
    (0.1119257570456813, 0.2788) 
 
    The statistic matches exactly, but the p-value is estimated by forming 
    a &quot;Monte Carlo null distribution&quot;, that is, by explicitly drawing random 
    samples from `scipy.stats.norm` with the provided parameters and 
    calculating the stastic for each. The fraction of these statistic values 
    at least as extreme as ``res.statistic`` approximates the exact p-value 
    calculated by `scipy.stats.ks_1samp`. 
 
    However, in many cases, we would prefer to test only that the data were 
    sampled from one of *any* member of the normal distribution family, not 
    specifically from the normal distribution with the location and scale 
    fitted to the observed sample. In this case, Lilliefors [6]_ argued that 
    the KS test is far too conservative (that is, the p-value overstates 
    the actual probability of rejecting a true null hypothesis) and thus lacks 
    power - the ability to reject the null hypothesis when the null hypothesis 
    is actually false. 
    Indeed, our p-value above is approximately 0.28, which is far too large 
    to reject the null hypothesis at any common significance level. 
 
    Consider why this might be. Note that in the KS test above, the statistic 
    always compares data against the CDF of a normal distribution fitted to the 
    *observed data*. This tends to reduce the value of the statistic for the 
    observed data, but it is &quot;unfair&quot; when computing the statistic for other 
    samples, such as those we randomly draw to form the Monte Carlo null 
    distribution. It is easy to correct for this: whenever we compute the KS 
    statistic of a sample, we use the CDF of a normal distribution fitted 
    to *that sample*. The null distribution in this case has not been 
    calculated exactly and is tyically approximated using Monte Carlo methods 
    as described above. This is where `goodness_of_fit` excels. 
 
    &gt;&gt;&gt; res = stats.goodness_of_fit(stats.norm, x, statistic='ks', 
    ...                             random_state=rng) 
    &gt;&gt;&gt; res.statistic, res.pvalue 
    (0.1119257570456813, 0.0196) 
 
    Indeed, this p-value is much smaller, and small enough to (correctly) 
    reject the null hypothesis at common significance levels, including 5% and 
    2.5%. 
 
    However, the KS statistic is not very sensitive to all deviations from 
    normality. The original advantage of the KS statistic was the ability 
    to compute the null distribution theoretically, but a more sensitive 
    statistic - resulting in a higher test power - can be used now that we can 
    approximate the null distribution 
    computationally. The Anderson-Darling statistic [1]_ tends to be more 
    sensitive, and critical values of the this statistic have been tabulated 
    for various significance levels and sample sizes using Monte Carlo methods. 
 
    &gt;&gt;&gt; res = stats.anderson(x, 'norm') 
    &gt;&gt;&gt; print(res.statistic) 
    1.2139573337497467 
    &gt;&gt;&gt; print(res.critical_values) 
    [0.549 0.625 0.75  0.875 1.041] 
    &gt;&gt;&gt; print(res.significance_level) 
    [15.  10.   5.   2.5  1. ] 
 
    Here, the observed value of the statistic exceeds the critical value 
    corresponding with a 1% significance level. This tells us that the p-value 
    of the observed data is less than 1%, but what is it? We could interpolate 
    from these (already-interpolated) values, but `goodness_of_fit` can 
    estimate it directly. 
 
    &gt;&gt;&gt; res = stats.goodness_of_fit(stats.norm, x, statistic='ad', 
    ...                             random_state=rng) 
    &gt;&gt;&gt; res.statistic, res.pvalue 
    (1.2139573337497467, 0.0034) 
 
    A further advantage is that use of `goodness_of_fit` is not limited to 
    a particular set of distributions or conditions on which parameters 
    are known versus which must be estimated from data. Instead, 
    `goodness_of_fit` can estimate p-values relatively quickly for any 
    distribution with a sufficiently fast and reliable ``fit`` method. For 
    instance, here we perform a goodness of fit test using the Cramer-von Mises 
    statistic against the Rayleigh distribution with known location and unknown 
    scale. 
 
    &gt;&gt;&gt; rng = np.random.default_rng() 
    &gt;&gt;&gt; x = stats.chi(df=2.2, loc=0, scale=2).rvs(size=1000, random_state=rng) 
    &gt;&gt;&gt; res = stats.goodness_of_fit(stats.rayleigh, x, statistic='cvm', 
    ...                             known_params={'loc': 0}, random_state=rng) 
 
    This executes fairly quickly, but to check the reliability of the ``fit`` 
    method, we should inspect the fit result. 
 
    &gt;&gt;&gt; res.fit_result  # location is as specified, and scale is reasonable 
      params: FitParams(loc=0.0, scale=2.1026719844231243) 
     success: True 
     message: 'The fit was performed successfully.' 
    &gt;&gt;&gt; import matplotlib.pyplot as plt  # matplotlib must be installed to plot 
    &gt;&gt;&gt; res.fit_result.plot() 
    &gt;&gt;&gt; plt.show() 
 
    If the distribution is not fit to the observed data as well as possible, 
    the test may not control the type I error rate, that is, the chance of 
    rejecting the null hypothesis even when it is true. 
 
    We should also look for extreme outliers in the null distribution that 
    may be caused by unreliable fitting. These do not necessarily invalidate 
    the result, but they tend to reduce the test's power. 
 
    &gt;&gt;&gt; _, ax = plt.subplots() 
    &gt;&gt;&gt; ax.hist(np.log10(res.null_distribution)) 
    &gt;&gt;&gt; ax.set_xlabel(&quot;log10 of CVM statistic under the null hypothesis&quot;) 
    &gt;&gt;&gt; ax.set_ylabel(&quot;Frequency&quot;) 
    &gt;&gt;&gt; ax.set_title(&quot;Histogram of the Monte Carlo null distribution&quot;) 
    &gt;&gt;&gt; plt.show() 
 
    This plot seems reassuring. 
 
    If ``fit`` method is working reliably, and if the distribution of the test 
    statistic is not particularly sensitive to the values of the fitted 
    parameters, then the p-value provided by `goodness_of_fit` is expected to 
    be a good approximation. 
 
    &gt;&gt;&gt; res.statistic, res.pvalue 
    (0.2231991510248692, 0.0525) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">args </span><span class="s2">= </span><span class="s1">_gof_iv</span><span class="s2">(</span><span class="s1">dist</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">known_params</span><span class="s2">, </span><span class="s1">fit_params</span><span class="s2">, </span><span class="s1">guessed_params</span><span class="s2">,</span>
                   <span class="s1">statistic</span><span class="s2">, </span><span class="s1">n_mc_samples</span><span class="s2">, </span><span class="s1">random_state</span><span class="s2">)</span>
    <span class="s2">(</span><span class="s1">dist</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">fixed_nhd_params</span><span class="s2">, </span><span class="s1">fixed_rfd_params</span><span class="s2">, </span><span class="s1">guessed_nhd_params</span><span class="s2">,</span>
     <span class="s1">guessed_rfd_params</span><span class="s2">, </span><span class="s1">statistic</span><span class="s2">, </span><span class="s1">n_mc_samples_int</span><span class="s2">, </span><span class="s1">random_state</span><span class="s2">) = </span><span class="s1">args</span>

    <span class="s6"># Fit null hypothesis distribution to data</span>
    <span class="s1">nhd_fit_fun </span><span class="s2">= </span><span class="s1">_get_fit_fun</span><span class="s2">(</span><span class="s1">dist</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">guessed_nhd_params</span><span class="s2">,</span>
                               <span class="s1">fixed_nhd_params</span><span class="s2">)</span>
    <span class="s1">nhd_vals </span><span class="s2">= </span><span class="s1">nhd_fit_fun</span><span class="s2">(</span><span class="s1">data</span><span class="s2">)</span>
    <span class="s1">nhd_dist </span><span class="s2">= </span><span class="s1">dist</span><span class="s2">(*</span><span class="s1">nhd_vals</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">rvs</span><span class="s2">(</span><span class="s1">size</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">nhd_dist</span><span class="s2">.</span><span class="s1">rvs</span><span class="s2">(</span><span class="s1">size</span><span class="s2">=</span><span class="s1">size</span><span class="s2">, </span><span class="s1">random_state</span><span class="s2">=</span><span class="s1">random_state</span><span class="s2">)</span>

    <span class="s6"># Define statistic</span>
    <span class="s1">fit_fun </span><span class="s2">= </span><span class="s1">_get_fit_fun</span><span class="s2">(</span><span class="s1">dist</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">guessed_rfd_params</span><span class="s2">, </span><span class="s1">fixed_rfd_params</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">callable</span><span class="s2">(</span><span class="s1">statistic</span><span class="s2">):</span>
        <span class="s1">compare_fun </span><span class="s2">= </span><span class="s1">statistic</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">compare_fun </span><span class="s2">= </span><span class="s1">_compare_dict</span><span class="s2">[</span><span class="s1">statistic</span><span class="s2">]</span>
    <span class="s1">alternative </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">compare_fun</span><span class="s2">, </span><span class="s5">'alternative'</span><span class="s2">, </span><span class="s5">'greater'</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">statistic_fun</span><span class="s2">(</span><span class="s1">data</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">):</span>
        <span class="s6"># Make things simple by always working along the last axis.</span>
        <span class="s1">data </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">moveaxis</span><span class="s2">(</span><span class="s1">data</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, -</span><span class="s4">1</span><span class="s2">)</span>
        <span class="s1">rfd_vals </span><span class="s2">= </span><span class="s1">fit_fun</span><span class="s2">(</span><span class="s1">data</span><span class="s2">)</span>
        <span class="s1">rfd_dist </span><span class="s2">= </span><span class="s1">dist</span><span class="s2">(*</span><span class="s1">rfd_vals</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">compare_fun</span><span class="s2">(</span><span class="s1">rfd_dist</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=-</span><span class="s4">1</span><span class="s2">)</span>

    <span class="s1">res </span><span class="s2">= </span><span class="s1">stats</span><span class="s2">.</span><span class="s1">monte_carlo_test</span><span class="s2">(</span><span class="s1">data</span><span class="s2">, </span><span class="s1">rvs</span><span class="s2">, </span><span class="s1">statistic_fun</span><span class="s2">, </span><span class="s1">vectorized</span><span class="s2">=</span><span class="s0">True</span><span class="s2">,</span>
                                 <span class="s1">n_resamples</span><span class="s2">=</span><span class="s1">n_mc_samples</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=-</span><span class="s4">1</span><span class="s2">,</span>
                                 <span class="s1">alternative</span><span class="s2">=</span><span class="s1">alternative</span><span class="s2">)</span>
    <span class="s1">opt_res </span><span class="s2">= </span><span class="s1">optimize</span><span class="s2">.</span><span class="s1">OptimizeResult</span><span class="s2">()</span>
    <span class="s1">opt_res</span><span class="s2">.</span><span class="s1">success </span><span class="s2">= </span><span class="s0">True</span>
    <span class="s1">opt_res</span><span class="s2">.</span><span class="s1">message </span><span class="s2">= </span><span class="s5">&quot;The fit was performed successfully.&quot;</span>
    <span class="s1">opt_res</span><span class="s2">.</span><span class="s1">x </span><span class="s2">= </span><span class="s1">nhd_vals</span>
    <span class="s6"># Only continuous distributions for now, hence discrete=False</span>
    <span class="s6"># There's no fundamental limitation; it's just that we're not using</span>
    <span class="s6"># stats.fit, discrete distributions don't have `fit` method, and</span>
    <span class="s6"># we haven't written any vectorized fit functions for a discrete</span>
    <span class="s6"># distribution yet.</span>
    <span class="s0">return </span><span class="s1">GoodnessOfFitResult</span><span class="s2">(</span><span class="s1">FitResult</span><span class="s2">(</span><span class="s1">dist</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s0">False</span><span class="s2">, </span><span class="s1">opt_res</span><span class="s2">),</span>
                               <span class="s1">res</span><span class="s2">.</span><span class="s1">statistic</span><span class="s2">, </span><span class="s1">res</span><span class="s2">.</span><span class="s1">pvalue</span><span class="s2">,</span>
                               <span class="s1">res</span><span class="s2">.</span><span class="s1">null_distribution</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">_get_fit_fun</span><span class="s2">(</span><span class="s1">dist</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">guessed_params</span><span class="s2">, </span><span class="s1">fixed_params</span><span class="s2">):</span>

    <span class="s1">shape_names </span><span class="s2">= [] </span><span class="s0">if </span><span class="s1">dist</span><span class="s2">.</span><span class="s1">shapes </span><span class="s0">is None else </span><span class="s1">dist</span><span class="s2">.</span><span class="s1">shapes</span><span class="s2">.</span><span class="s1">split</span><span class="s2">(</span><span class="s5">&quot;, &quot;</span><span class="s2">)</span>
    <span class="s1">param_names </span><span class="s2">= </span><span class="s1">shape_names </span><span class="s2">+ [</span><span class="s5">'loc'</span><span class="s2">, </span><span class="s5">'scale'</span><span class="s2">]</span>
    <span class="s1">fparam_names </span><span class="s2">= [</span><span class="s5">'f'</span><span class="s2">+</span><span class="s1">name </span><span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">param_names</span><span class="s2">]</span>
    <span class="s1">all_fixed </span><span class="s2">= </span><span class="s0">not </span><span class="s1">set</span><span class="s2">(</span><span class="s1">fparam_names</span><span class="s2">).</span><span class="s1">difference</span><span class="s2">(</span><span class="s1">fixed_params</span><span class="s2">)</span>
    <span class="s1">guessed_shapes </span><span class="s2">= [</span><span class="s1">guessed_params</span><span class="s2">.</span><span class="s1">pop</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>
                      <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">shape_names </span><span class="s0">if </span><span class="s1">x </span><span class="s0">in </span><span class="s1">guessed_params</span><span class="s2">]</span>

    <span class="s0">if </span><span class="s1">all_fixed</span><span class="s2">:</span>
        <span class="s0">def </span><span class="s1">fit_fun</span><span class="s2">(</span><span class="s1">data</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s2">[</span><span class="s1">fixed_params</span><span class="s2">[</span><span class="s1">name</span><span class="s2">] </span><span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">fparam_names</span><span class="s2">]</span>
    <span class="s6"># Define statistic, including fitting distribution to data</span>
    <span class="s0">elif </span><span class="s1">dist </span><span class="s0">in </span><span class="s1">_fit_funs</span><span class="s2">:</span>
        <span class="s0">def </span><span class="s1">fit_fun</span><span class="s2">(</span><span class="s1">data</span><span class="s2">):</span>
            <span class="s1">params </span><span class="s2">= </span><span class="s1">_fit_funs</span><span class="s2">[</span><span class="s1">dist</span><span class="s2">](</span><span class="s1">data</span><span class="s2">, **</span><span class="s1">fixed_params</span><span class="s2">)</span>
            <span class="s1">params </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">broadcast_arrays</span><span class="s2">(*</span><span class="s1">params</span><span class="s2">))</span>
            <span class="s0">if </span><span class="s1">params</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">&gt; </span><span class="s4">1</span><span class="s2">:</span>
                <span class="s1">params </span><span class="s2">= </span><span class="s1">params</span><span class="s2">[..., </span><span class="s1">np</span><span class="s2">.</span><span class="s1">newaxis</span><span class="s2">]</span>
            <span class="s0">return </span><span class="s1">params</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s0">def </span><span class="s1">fit_fun_1d</span><span class="s2">(</span><span class="s1">data</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">dist</span><span class="s2">.</span><span class="s1">fit</span><span class="s2">(</span><span class="s1">data</span><span class="s2">, *</span><span class="s1">guessed_shapes</span><span class="s2">, **</span><span class="s1">guessed_params</span><span class="s2">,</span>
                            <span class="s2">**</span><span class="s1">fixed_params</span><span class="s2">)</span>

        <span class="s0">def </span><span class="s1">fit_fun</span><span class="s2">(</span><span class="s1">data</span><span class="s2">):</span>
            <span class="s1">params </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">apply_along_axis</span><span class="s2">(</span><span class="s1">fit_fun_1d</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=-</span><span class="s4">1</span><span class="s2">, </span><span class="s1">arr</span><span class="s2">=</span><span class="s1">data</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">params</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">&gt; </span><span class="s4">1</span><span class="s2">:</span>
                <span class="s1">params </span><span class="s2">= </span><span class="s1">params</span><span class="s2">.</span><span class="s1">T</span><span class="s2">[..., </span><span class="s1">np</span><span class="s2">.</span><span class="s1">newaxis</span><span class="s2">]</span>
            <span class="s0">return </span><span class="s1">params</span>

    <span class="s0">return </span><span class="s1">fit_fun</span>


<span class="s6"># Vectorized fitting functions. These are to accept ND `data` in which each</span>
<span class="s6"># row (slice along last axis) is a sample to fit and scalar fixed parameters.</span>
<span class="s6"># They return a tuple of shape parameter arrays, each of shape data.shape[:-1].</span>
<span class="s0">def </span><span class="s1">_fit_norm</span><span class="s2">(</span><span class="s1">data</span><span class="s2">, </span><span class="s1">floc</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">fscale</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
    <span class="s1">loc </span><span class="s2">= </span><span class="s1">floc</span>
    <span class="s1">scale </span><span class="s2">= </span><span class="s1">fscale</span>
    <span class="s0">if </span><span class="s1">loc </span><span class="s0">is None and </span><span class="s1">scale </span><span class="s0">is None</span><span class="s2">:</span>
        <span class="s1">loc </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">mean</span><span class="s2">(</span><span class="s1">data</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=-</span><span class="s4">1</span><span class="s2">)</span>
        <span class="s1">scale </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">std</span><span class="s2">(</span><span class="s1">data</span><span class="s2">, </span><span class="s1">ddof</span><span class="s2">=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=-</span><span class="s4">1</span><span class="s2">)</span>
    <span class="s0">elif </span><span class="s1">loc </span><span class="s0">is None</span><span class="s2">:</span>
        <span class="s1">loc </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">mean</span><span class="s2">(</span><span class="s1">data</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=-</span><span class="s4">1</span><span class="s2">)</span>
    <span class="s0">elif </span><span class="s1">scale </span><span class="s0">is None</span><span class="s2">:</span>
        <span class="s1">scale </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sqrt</span><span class="s2">(((</span><span class="s1">data </span><span class="s2">- </span><span class="s1">loc</span><span class="s2">)**</span><span class="s4">2</span><span class="s2">).</span><span class="s1">mean</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">=-</span><span class="s4">1</span><span class="s2">))</span>
    <span class="s0">return </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">scale</span>


<span class="s1">_fit_funs </span><span class="s2">= {</span><span class="s1">stats</span><span class="s2">.</span><span class="s1">norm</span><span class="s2">: </span><span class="s1">_fit_norm</span><span class="s2">}  </span><span class="s6"># type: ignore[attr-defined]</span>


<span class="s6"># Vectorized goodness of fit statistic functions. These accept a frozen</span>
<span class="s6"># distribution object and `data` in which each row (slice along last axis) is</span>
<span class="s6"># a sample.</span>


<span class="s0">def </span><span class="s1">_anderson_darling</span><span class="s2">(</span><span class="s1">dist</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">):</span>
    <span class="s1">x </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sort</span><span class="s2">(</span><span class="s1">data</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=-</span><span class="s4">1</span><span class="s2">)</span>
    <span class="s1">n </span><span class="s2">= </span><span class="s1">data</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[-</span><span class="s4">1</span><span class="s2">]</span>
    <span class="s1">i </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">n</span><span class="s2">+</span><span class="s4">1</span><span class="s2">)</span>
    <span class="s1">Si </span><span class="s2">= (</span><span class="s4">2</span><span class="s2">*</span><span class="s1">i </span><span class="s2">- </span><span class="s4">1</span><span class="s2">)/</span><span class="s1">n </span><span class="s2">* (</span><span class="s1">dist</span><span class="s2">.</span><span class="s1">logcdf</span><span class="s2">(</span><span class="s1">x</span><span class="s2">) + </span><span class="s1">dist</span><span class="s2">.</span><span class="s1">logsf</span><span class="s2">(</span><span class="s1">x</span><span class="s2">[..., ::-</span><span class="s4">1</span><span class="s2">]))</span>
    <span class="s1">S </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sum</span><span class="s2">(</span><span class="s1">Si</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=-</span><span class="s4">1</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s2">-</span><span class="s1">n </span><span class="s2">- </span><span class="s1">S</span>


<span class="s0">def </span><span class="s1">_compute_dplus</span><span class="s2">(</span><span class="s1">cdfvals</span><span class="s2">):  </span><span class="s6"># adapted from _stats_py before gh-17062</span>
    <span class="s1">n </span><span class="s2">= </span><span class="s1">cdfvals</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[-</span><span class="s4">1</span><span class="s2">]</span>
    <span class="s0">return </span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(</span><span class="s4">1.0</span><span class="s2">, </span><span class="s1">n </span><span class="s2">+ </span><span class="s4">1</span><span class="s2">) / </span><span class="s1">n </span><span class="s2">- </span><span class="s1">cdfvals</span><span class="s2">).</span><span class="s1">max</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">=-</span><span class="s4">1</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">_compute_dminus</span><span class="s2">(</span><span class="s1">cdfvals</span><span class="s2">):</span>
    <span class="s1">n </span><span class="s2">= </span><span class="s1">cdfvals</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[-</span><span class="s4">1</span><span class="s2">]</span>
    <span class="s0">return </span><span class="s2">(</span><span class="s1">cdfvals </span><span class="s2">- </span><span class="s1">np</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(</span><span class="s4">0.0</span><span class="s2">, </span><span class="s1">n</span><span class="s2">)/</span><span class="s1">n</span><span class="s2">).</span><span class="s1">max</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">=-</span><span class="s4">1</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">_kolmogorov_smirnov</span><span class="s2">(</span><span class="s1">dist</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">):</span>
    <span class="s1">x </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sort</span><span class="s2">(</span><span class="s1">data</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=-</span><span class="s4">1</span><span class="s2">)</span>
    <span class="s1">cdfvals </span><span class="s2">= </span><span class="s1">dist</span><span class="s2">.</span><span class="s1">cdf</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)</span>
    <span class="s1">Dplus </span><span class="s2">= </span><span class="s1">_compute_dplus</span><span class="s2">(</span><span class="s1">cdfvals</span><span class="s2">)  </span><span class="s6"># always works along last axis</span>
    <span class="s1">Dminus </span><span class="s2">= </span><span class="s1">_compute_dminus</span><span class="s2">(</span><span class="s1">cdfvals</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">maximum</span><span class="s2">(</span><span class="s1">Dplus</span><span class="s2">, </span><span class="s1">Dminus</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">_corr</span><span class="s2">(</span><span class="s1">X</span><span class="s2">, </span><span class="s1">M</span><span class="s2">):</span>
    <span class="s6"># Correlation coefficient r, simplified and vectorized as we need it.</span>
    <span class="s6"># See [7] Equation (2). Lemma 1/2 are only for distributions symmetric</span>
    <span class="s6"># about 0.</span>
    <span class="s1">Xm </span><span class="s2">= </span><span class="s1">X</span><span class="s2">.</span><span class="s1">mean</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">=-</span><span class="s4">1</span><span class="s2">, </span><span class="s1">keepdims</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
    <span class="s1">Mm </span><span class="s2">= </span><span class="s1">M</span><span class="s2">.</span><span class="s1">mean</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">=-</span><span class="s4">1</span><span class="s2">, </span><span class="s1">keepdims</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
    <span class="s1">num </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sum</span><span class="s2">((</span><span class="s1">X </span><span class="s2">- </span><span class="s1">Xm</span><span class="s2">) * (</span><span class="s1">M </span><span class="s2">- </span><span class="s1">Mm</span><span class="s2">), </span><span class="s1">axis</span><span class="s2">=-</span><span class="s4">1</span><span class="s2">)</span>
    <span class="s1">den </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sqrt</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">sum</span><span class="s2">((</span><span class="s1">X </span><span class="s2">- </span><span class="s1">Xm</span><span class="s2">)**</span><span class="s4">2</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=-</span><span class="s4">1</span><span class="s2">) * </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sum</span><span class="s2">((</span><span class="s1">M </span><span class="s2">- </span><span class="s1">Mm</span><span class="s2">)**</span><span class="s4">2</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=-</span><span class="s4">1</span><span class="s2">))</span>
    <span class="s0">return </span><span class="s1">num</span><span class="s2">/</span><span class="s1">den</span>


<span class="s0">def </span><span class="s1">_filliben</span><span class="s2">(</span><span class="s1">dist</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">):</span>
    <span class="s6"># [7] Section 8 # 1</span>
    <span class="s1">X </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sort</span><span class="s2">(</span><span class="s1">data</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=-</span><span class="s4">1</span><span class="s2">)</span>

    <span class="s6"># [7] Section 8 # 2</span>
    <span class="s1">n </span><span class="s2">= </span><span class="s1">data</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[-</span><span class="s4">1</span><span class="s2">]</span>
    <span class="s1">k </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">n</span><span class="s2">+</span><span class="s4">1</span><span class="s2">)</span>
    <span class="s6"># Filliben used an approximation for the uniform distribution order</span>
    <span class="s6"># statistic medians.</span>
    <span class="s6"># m = (k - .3175)/(n + 0.365)</span>
    <span class="s6"># m[-1] = 0.5**(1/n)</span>
    <span class="s6"># m[0] = 1 - m[-1]</span>
    <span class="s6"># We can just as easily use the (theoretically) exact values. See e.g.</span>
    <span class="s6"># https://en.wikipedia.org/wiki/Order_statistic</span>
    <span class="s6"># &quot;Order statistics sampled from a uniform distribution&quot;</span>
    <span class="s1">m </span><span class="s2">= </span><span class="s1">stats</span><span class="s2">.</span><span class="s1">beta</span><span class="s2">(</span><span class="s1">k</span><span class="s2">, </span><span class="s1">n </span><span class="s2">+ </span><span class="s4">1 </span><span class="s2">- </span><span class="s1">k</span><span class="s2">).</span><span class="s1">median</span><span class="s2">()</span>

    <span class="s6"># [7] Section 8 # 3</span>
    <span class="s1">M </span><span class="s2">= </span><span class="s1">dist</span><span class="s2">.</span><span class="s1">ppf</span><span class="s2">(</span><span class="s1">m</span><span class="s2">)</span>

    <span class="s6"># [7] Section 8 # 4</span>
    <span class="s0">return </span><span class="s1">_corr</span><span class="s2">(</span><span class="s1">X</span><span class="s2">, </span><span class="s1">M</span><span class="s2">)</span>
<span class="s1">_filliben</span><span class="s2">.</span><span class="s1">alternative </span><span class="s2">= </span><span class="s5">'less'  </span><span class="s6"># type: ignore[attr-defined]</span>


<span class="s0">def </span><span class="s1">_cramer_von_mises</span><span class="s2">(</span><span class="s1">dist</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">):</span>
    <span class="s1">x </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sort</span><span class="s2">(</span><span class="s1">data</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=-</span><span class="s4">1</span><span class="s2">)</span>
    <span class="s1">n </span><span class="s2">= </span><span class="s1">data</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[-</span><span class="s4">1</span><span class="s2">]</span>
    <span class="s1">cdfvals </span><span class="s2">= </span><span class="s1">dist</span><span class="s2">.</span><span class="s1">cdf</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)</span>
    <span class="s1">u </span><span class="s2">= (</span><span class="s4">2</span><span class="s2">*</span><span class="s1">np</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">n</span><span class="s2">+</span><span class="s4">1</span><span class="s2">) - </span><span class="s4">1</span><span class="s2">)/(</span><span class="s4">2</span><span class="s2">*</span><span class="s1">n</span><span class="s2">)</span>
    <span class="s1">w </span><span class="s2">= </span><span class="s4">1 </span><span class="s2">/ (</span><span class="s4">12</span><span class="s2">*</span><span class="s1">n</span><span class="s2">) + </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sum</span><span class="s2">((</span><span class="s1">u </span><span class="s2">- </span><span class="s1">cdfvals</span><span class="s2">)**</span><span class="s4">2</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=-</span><span class="s4">1</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">w</span>


<span class="s1">_compare_dict </span><span class="s2">= {</span><span class="s5">&quot;ad&quot;</span><span class="s2">: </span><span class="s1">_anderson_darling</span><span class="s2">, </span><span class="s5">&quot;ks&quot;</span><span class="s2">: </span><span class="s1">_kolmogorov_smirnov</span><span class="s2">,</span>
                 <span class="s5">&quot;cvm&quot;</span><span class="s2">: </span><span class="s1">_cramer_von_mises</span><span class="s2">, </span><span class="s5">&quot;filliben&quot;</span><span class="s2">: </span><span class="s1">_filliben</span><span class="s2">}</span>


<span class="s0">def </span><span class="s1">_gof_iv</span><span class="s2">(</span><span class="s1">dist</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">known_params</span><span class="s2">, </span><span class="s1">fit_params</span><span class="s2">, </span><span class="s1">guessed_params</span><span class="s2">, </span><span class="s1">statistic</span><span class="s2">,</span>
            <span class="s1">n_mc_samples</span><span class="s2">, </span><span class="s1">random_state</span><span class="s2">):</span>

    <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">dist</span><span class="s2">, </span><span class="s1">stats</span><span class="s2">.</span><span class="s1">rv_continuous</span><span class="s2">):</span>
        <span class="s1">message </span><span class="s2">= (</span><span class="s5">&quot;`dist` must be a (non-frozen) instance of &quot;</span>
                   <span class="s5">&quot;`stats.rv_continuous`.&quot;</span><span class="s2">)</span>
        <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s1">message</span><span class="s2">)</span>

    <span class="s1">data </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">data</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">float</span><span class="s2">)</span>
    <span class="s0">if not </span><span class="s1">data</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s4">1</span><span class="s2">:</span>
        <span class="s1">message </span><span class="s2">= </span><span class="s5">&quot;`data` must be a one-dimensional array of numbers.&quot;</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s1">message</span><span class="s2">)</span>

    <span class="s6"># Leave validation of these key/value pairs to the `fit` method,</span>
    <span class="s6"># but collect these into dictionaries that will be used</span>
    <span class="s1">known_params </span><span class="s2">= </span><span class="s1">known_params </span><span class="s0">or </span><span class="s1">dict</span><span class="s2">()</span>
    <span class="s1">fit_params </span><span class="s2">= </span><span class="s1">fit_params </span><span class="s0">or </span><span class="s1">dict</span><span class="s2">()</span>
    <span class="s1">guessed_params </span><span class="s2">= </span><span class="s1">guessed_params </span><span class="s0">or </span><span class="s1">dict</span><span class="s2">()</span>

    <span class="s1">known_params_f </span><span class="s2">= {(</span><span class="s5">&quot;f&quot;</span><span class="s2">+</span><span class="s1">key</span><span class="s2">): </span><span class="s1">val </span><span class="s0">for </span><span class="s1">key</span><span class="s2">, </span><span class="s1">val </span><span class="s0">in </span><span class="s1">known_params</span><span class="s2">.</span><span class="s1">items</span><span class="s2">()}</span>
    <span class="s1">fit_params_f </span><span class="s2">= {(</span><span class="s5">&quot;f&quot;</span><span class="s2">+</span><span class="s1">key</span><span class="s2">): </span><span class="s1">val </span><span class="s0">for </span><span class="s1">key</span><span class="s2">, </span><span class="s1">val </span><span class="s0">in </span><span class="s1">fit_params</span><span class="s2">.</span><span class="s1">items</span><span class="s2">()}</span>

    <span class="s6"># These are the values of parameters of the null distribution family</span>
    <span class="s6"># with which resamples are drawn</span>
    <span class="s1">fixed_nhd_params </span><span class="s2">= </span><span class="s1">known_params_f</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>
    <span class="s1">fixed_nhd_params</span><span class="s2">.</span><span class="s1">update</span><span class="s2">(</span><span class="s1">fit_params_f</span><span class="s2">)</span>

    <span class="s6"># These are fixed when fitting the distribution family to resamples</span>
    <span class="s1">fixed_rfd_params </span><span class="s2">= </span><span class="s1">known_params_f</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>

    <span class="s6"># These are used as guesses when fitting the distribution family to</span>
    <span class="s6"># the original data</span>
    <span class="s1">guessed_nhd_params </span><span class="s2">= </span><span class="s1">guessed_params</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>

    <span class="s6"># These are used as guesses when fitting the distribution family to</span>
    <span class="s6"># resamples</span>
    <span class="s1">guessed_rfd_params </span><span class="s2">= </span><span class="s1">fit_params</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>
    <span class="s1">guessed_rfd_params</span><span class="s2">.</span><span class="s1">update</span><span class="s2">(</span><span class="s1">guessed_params</span><span class="s2">)</span>

    <span class="s0">if not </span><span class="s1">callable</span><span class="s2">(</span><span class="s1">statistic</span><span class="s2">):</span>
        <span class="s1">statistic </span><span class="s2">= </span><span class="s1">statistic</span><span class="s2">.</span><span class="s1">lower</span><span class="s2">()</span>
        <span class="s1">statistics </span><span class="s2">= {</span><span class="s5">'ad'</span><span class="s2">, </span><span class="s5">'ks'</span><span class="s2">, </span><span class="s5">'cvm'</span><span class="s2">, </span><span class="s5">'filliben'</span><span class="s2">}</span>
        <span class="s0">if </span><span class="s1">statistic </span><span class="s0">not in </span><span class="s1">statistics</span><span class="s2">:</span>
            <span class="s1">message </span><span class="s2">= </span><span class="s5">f&quot;`statistic` must be one of </span><span class="s0">{</span><span class="s1">statistics</span><span class="s0">}</span><span class="s5">.&quot;</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s1">message</span><span class="s2">)</span>

    <span class="s1">n_mc_samples_int </span><span class="s2">= </span><span class="s1">int</span><span class="s2">(</span><span class="s1">n_mc_samples</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">n_mc_samples_int </span><span class="s2">!= </span><span class="s1">n_mc_samples</span><span class="s2">:</span>
        <span class="s1">message </span><span class="s2">= </span><span class="s5">&quot;`n_mc_samples` must be an integer.&quot;</span>
        <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s1">message</span><span class="s2">)</span>

    <span class="s1">random_state </span><span class="s2">= </span><span class="s1">check_random_state</span><span class="s2">(</span><span class="s1">random_state</span><span class="s2">)</span>

    <span class="s0">return </span><span class="s2">(</span><span class="s1">dist</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">fixed_nhd_params</span><span class="s2">, </span><span class="s1">fixed_rfd_params</span><span class="s2">, </span><span class="s1">guessed_nhd_params</span><span class="s2">,</span>
            <span class="s1">guessed_rfd_params</span><span class="s2">, </span><span class="s1">statistic</span><span class="s2">, </span><span class="s1">n_mc_samples_int</span><span class="s2">, </span><span class="s1">random_state</span><span class="s2">)</span>
</pre>
</body>
</html>