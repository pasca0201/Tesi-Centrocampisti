<html>
<head>
<title>test_hdbscan.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #2aacb8;}
.s5 { color: #6aab73;}
.s6 { color: #7a7e85;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_hdbscan.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Tests for HDBSCAN clustering algorithm 
Based on the DBSCAN test code 
&quot;&quot;&quot;</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">import </span><span class="s1">pytest</span>
<span class="s2">from </span><span class="s1">scipy </span><span class="s2">import </span><span class="s1">stats</span>
<span class="s2">from </span><span class="s1">scipy</span><span class="s3">.</span><span class="s1">spatial </span><span class="s2">import </span><span class="s1">distance</span>

<span class="s2">from </span><span class="s1">sklearn</span><span class="s3">.</span><span class="s1">cluster </span><span class="s2">import </span><span class="s1">HDBSCAN</span>
<span class="s2">from </span><span class="s1">sklearn</span><span class="s3">.</span><span class="s1">cluster</span><span class="s3">.</span><span class="s1">_hdbscan</span><span class="s3">.</span><span class="s1">_tree </span><span class="s2">import </span><span class="s3">(</span>
    <span class="s1">CONDENSED_dtype</span><span class="s3">,</span>
    <span class="s1">_condense_tree</span><span class="s3">,</span>
    <span class="s1">_do_labelling</span><span class="s3">,</span>
<span class="s3">)</span>
<span class="s2">from </span><span class="s1">sklearn</span><span class="s3">.</span><span class="s1">cluster</span><span class="s3">.</span><span class="s1">_hdbscan</span><span class="s3">.</span><span class="s1">hdbscan </span><span class="s2">import </span><span class="s1">_OUTLIER_ENCODING</span>
<span class="s2">from </span><span class="s1">sklearn</span><span class="s3">.</span><span class="s1">datasets </span><span class="s2">import </span><span class="s1">make_blobs</span>
<span class="s2">from </span><span class="s1">sklearn</span><span class="s3">.</span><span class="s1">metrics </span><span class="s2">import </span><span class="s1">fowlkes_mallows_score</span>
<span class="s2">from </span><span class="s1">sklearn</span><span class="s3">.</span><span class="s1">metrics</span><span class="s3">.</span><span class="s1">pairwise </span><span class="s2">import </span><span class="s1">_VALID_METRICS</span><span class="s3">, </span><span class="s1">euclidean_distances</span>
<span class="s2">from </span><span class="s1">sklearn</span><span class="s3">.</span><span class="s1">neighbors </span><span class="s2">import </span><span class="s1">BallTree</span><span class="s3">, </span><span class="s1">KDTree</span>
<span class="s2">from </span><span class="s1">sklearn</span><span class="s3">.</span><span class="s1">preprocessing </span><span class="s2">import </span><span class="s1">StandardScaler</span>
<span class="s2">from </span><span class="s1">sklearn</span><span class="s3">.</span><span class="s1">utils </span><span class="s2">import </span><span class="s1">shuffle</span>
<span class="s2">from </span><span class="s1">sklearn</span><span class="s3">.</span><span class="s1">utils</span><span class="s3">.</span><span class="s1">_testing </span><span class="s2">import </span><span class="s1">assert_allclose</span><span class="s3">, </span><span class="s1">assert_array_equal</span>
<span class="s2">from </span><span class="s1">sklearn</span><span class="s3">.</span><span class="s1">utils</span><span class="s3">.</span><span class="s1">fixes </span><span class="s2">import </span><span class="s1">CSC_CONTAINERS</span><span class="s3">, </span><span class="s1">CSR_CONTAINERS</span>

<span class="s1">X</span><span class="s3">, </span><span class="s1">y </span><span class="s3">= </span><span class="s1">make_blobs</span><span class="s3">(</span><span class="s1">n_samples</span><span class="s3">=</span><span class="s4">200</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s4">10</span><span class="s3">)</span>
<span class="s1">X</span><span class="s3">, </span><span class="s1">y </span><span class="s3">= </span><span class="s1">shuffle</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s4">7</span><span class="s3">)</span>
<span class="s1">X </span><span class="s3">= </span><span class="s1">StandardScaler</span><span class="s3">().</span><span class="s1">fit_transform</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>

<span class="s1">ALGORITHMS </span><span class="s3">= [</span>
    <span class="s5">&quot;kd_tree&quot;</span><span class="s3">,</span>
    <span class="s5">&quot;ball_tree&quot;</span><span class="s3">,</span>
    <span class="s5">&quot;brute&quot;</span><span class="s3">,</span>
    <span class="s5">&quot;auto&quot;</span><span class="s3">,</span>
<span class="s3">]</span>

<span class="s1">OUTLIER_SET </span><span class="s3">= {-</span><span class="s4">1</span><span class="s3">} | {</span><span class="s1">out</span><span class="s3">[</span><span class="s5">&quot;label&quot;</span><span class="s3">] </span><span class="s2">for </span><span class="s1">_</span><span class="s3">, </span><span class="s1">out </span><span class="s2">in </span><span class="s1">_OUTLIER_ENCODING</span><span class="s3">.</span><span class="s1">items</span><span class="s3">()}</span>


<span class="s2">def </span><span class="s1">check_label_quality</span><span class="s3">(</span><span class="s1">labels</span><span class="s3">, </span><span class="s1">threshold</span><span class="s3">=</span><span class="s4">0.99</span><span class="s3">):</span>
    <span class="s1">n_clusters </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">set</span><span class="s3">(</span><span class="s1">labels</span><span class="s3">) - </span><span class="s1">OUTLIER_SET</span><span class="s3">)</span>
    <span class="s2">assert </span><span class="s1">n_clusters </span><span class="s3">== </span><span class="s4">3</span>
    <span class="s2">assert </span><span class="s1">fowlkes_mallows_score</span><span class="s3">(</span><span class="s1">labels</span><span class="s3">, </span><span class="s1">y</span><span class="s3">) &gt; </span><span class="s1">threshold</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s5">&quot;outlier_type&quot;</span><span class="s3">, </span><span class="s1">_OUTLIER_ENCODING</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">test_outlier_data</span><span class="s3">(</span><span class="s1">outlier_type</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Tests if np.inf and np.nan data are each treated as special outliers. 
    &quot;&quot;&quot;</span>
    <span class="s1">outlier </span><span class="s3">= {</span>
        <span class="s5">&quot;infinite&quot;</span><span class="s3">: </span><span class="s1">np</span><span class="s3">.</span><span class="s1">inf</span><span class="s3">,</span>
        <span class="s5">&quot;missing&quot;</span><span class="s3">: </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span><span class="s3">,</span>
    <span class="s3">}[</span><span class="s1">outlier_type</span><span class="s3">]</span>
    <span class="s1">prob_check </span><span class="s3">= {</span>
        <span class="s5">&quot;infinite&quot;</span><span class="s3">: </span><span class="s2">lambda </span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">: </span><span class="s1">x </span><span class="s3">== </span><span class="s1">y</span><span class="s3">,</span>
        <span class="s5">&quot;missing&quot;</span><span class="s3">: </span><span class="s2">lambda </span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">: </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isnan</span><span class="s3">(</span><span class="s1">x</span><span class="s3">),</span>
    <span class="s3">}[</span><span class="s1">outlier_type</span><span class="s3">]</span>
    <span class="s1">label </span><span class="s3">= </span><span class="s1">_OUTLIER_ENCODING</span><span class="s3">[</span><span class="s1">outlier_type</span><span class="s3">][</span><span class="s5">&quot;label&quot;</span><span class="s3">]</span>
    <span class="s1">prob </span><span class="s3">= </span><span class="s1">_OUTLIER_ENCODING</span><span class="s3">[</span><span class="s1">outlier_type</span><span class="s3">][</span><span class="s5">&quot;prob&quot;</span><span class="s3">]</span>

    <span class="s1">X_outlier </span><span class="s3">= </span><span class="s1">X</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>
    <span class="s1">X_outlier</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] = [</span><span class="s1">outlier</span><span class="s3">, </span><span class="s4">1</span><span class="s3">]</span>
    <span class="s1">X_outlier</span><span class="s3">[</span><span class="s4">5</span><span class="s3">] = [</span><span class="s1">outlier</span><span class="s3">, </span><span class="s1">outlier</span><span class="s3">]</span>
    <span class="s1">model </span><span class="s3">= </span><span class="s1">HDBSCAN</span><span class="s3">().</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X_outlier</span><span class="s3">)</span>

    <span class="s3">(</span><span class="s1">missing_labels_idx</span><span class="s3">,) = (</span><span class="s1">model</span><span class="s3">.</span><span class="s1">labels_ </span><span class="s3">== </span><span class="s1">label</span><span class="s3">).</span><span class="s1">nonzero</span><span class="s3">()</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">missing_labels_idx</span><span class="s3">, [</span><span class="s4">0</span><span class="s3">, </span><span class="s4">5</span><span class="s3">])</span>

    <span class="s3">(</span><span class="s1">missing_probs_idx</span><span class="s3">,) = (</span><span class="s1">prob_check</span><span class="s3">(</span><span class="s1">model</span><span class="s3">.</span><span class="s1">probabilities_</span><span class="s3">, </span><span class="s1">prob</span><span class="s3">)).</span><span class="s1">nonzero</span><span class="s3">()</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">missing_probs_idx</span><span class="s3">, [</span><span class="s4">0</span><span class="s3">, </span><span class="s4">5</span><span class="s3">])</span>

    <span class="s1">clean_indices </span><span class="s3">= </span><span class="s1">list</span><span class="s3">(</span><span class="s1">range</span><span class="s3">(</span><span class="s4">1</span><span class="s3">, </span><span class="s4">5</span><span class="s3">)) + </span><span class="s1">list</span><span class="s3">(</span><span class="s1">range</span><span class="s3">(</span><span class="s4">6</span><span class="s3">, </span><span class="s4">200</span><span class="s3">))</span>
    <span class="s1">clean_model </span><span class="s3">= </span><span class="s1">HDBSCAN</span><span class="s3">().</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X_outlier</span><span class="s3">[</span><span class="s1">clean_indices</span><span class="s3">])</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">clean_model</span><span class="s3">.</span><span class="s1">labels_</span><span class="s3">, </span><span class="s1">model</span><span class="s3">.</span><span class="s1">labels_</span><span class="s3">[</span><span class="s1">clean_indices</span><span class="s3">])</span>


<span class="s2">def </span><span class="s1">test_hdbscan_distance_matrix</span><span class="s3">():</span>
    <span class="s0">&quot;&quot;&quot; 
    Tests that HDBSCAN works with precomputed distance matrices, and throws the 
    appropriate errors when needed. 
    &quot;&quot;&quot;</span>
    <span class="s1">D </span><span class="s3">= </span><span class="s1">euclidean_distances</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
    <span class="s1">D_original </span><span class="s3">= </span><span class="s1">D</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>
    <span class="s1">labels </span><span class="s3">= </span><span class="s1">HDBSCAN</span><span class="s3">(</span><span class="s1">metric</span><span class="s3">=</span><span class="s5">&quot;precomputed&quot;</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">True</span><span class="s3">).</span><span class="s1">fit_predict</span><span class="s3">(</span><span class="s1">D</span><span class="s3">)</span>

    <span class="s1">assert_allclose</span><span class="s3">(</span><span class="s1">D</span><span class="s3">, </span><span class="s1">D_original</span><span class="s3">)</span>
    <span class="s1">check_label_quality</span><span class="s3">(</span><span class="s1">labels</span><span class="s3">)</span>

    <span class="s1">msg </span><span class="s3">= </span><span class="s5">r&quot;The precomputed distance matrix.*has shape&quot;</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s1">msg</span><span class="s3">):</span>
        <span class="s1">HDBSCAN</span><span class="s3">(</span><span class="s1">metric</span><span class="s3">=</span><span class="s5">&quot;precomputed&quot;</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">True</span><span class="s3">).</span><span class="s1">fit_predict</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>

    <span class="s1">msg </span><span class="s3">= </span><span class="s5">r&quot;The precomputed distance matrix.*values&quot;</span>
    <span class="s6"># Ensure the matrix is not symmetric</span>
    <span class="s1">D</span><span class="s3">[</span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">] = </span><span class="s4">10</span>
    <span class="s1">D</span><span class="s3">[</span><span class="s4">1</span><span class="s3">, </span><span class="s4">0</span><span class="s3">] = </span><span class="s4">1</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s1">msg</span><span class="s3">):</span>
        <span class="s1">HDBSCAN</span><span class="s3">(</span><span class="s1">metric</span><span class="s3">=</span><span class="s5">&quot;precomputed&quot;</span><span class="s3">).</span><span class="s1">fit_predict</span><span class="s3">(</span><span class="s1">D</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s5">&quot;sparse_constructor&quot;</span><span class="s3">, [*</span><span class="s1">CSR_CONTAINERS</span><span class="s3">, *</span><span class="s1">CSC_CONTAINERS</span><span class="s3">])</span>
<span class="s2">def </span><span class="s1">test_hdbscan_sparse_distance_matrix</span><span class="s3">(</span><span class="s1">sparse_constructor</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Tests that HDBSCAN works with sparse distance matrices. 
    &quot;&quot;&quot;</span>
    <span class="s1">D </span><span class="s3">= </span><span class="s1">distance</span><span class="s3">.</span><span class="s1">squareform</span><span class="s3">(</span><span class="s1">distance</span><span class="s3">.</span><span class="s1">pdist</span><span class="s3">(</span><span class="s1">X</span><span class="s3">))</span>
    <span class="s1">D </span><span class="s3">/= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">max</span><span class="s3">(</span><span class="s1">D</span><span class="s3">)</span>

    <span class="s1">threshold </span><span class="s3">= </span><span class="s1">stats</span><span class="s3">.</span><span class="s1">scoreatpercentile</span><span class="s3">(</span><span class="s1">D</span><span class="s3">.</span><span class="s1">flatten</span><span class="s3">(), </span><span class="s4">50</span><span class="s3">)</span>

    <span class="s1">D</span><span class="s3">[</span><span class="s1">D </span><span class="s3">&gt;= </span><span class="s1">threshold</span><span class="s3">] = </span><span class="s4">0.0</span>
    <span class="s1">D </span><span class="s3">= </span><span class="s1">sparse_constructor</span><span class="s3">(</span><span class="s1">D</span><span class="s3">)</span>
    <span class="s1">D</span><span class="s3">.</span><span class="s1">eliminate_zeros</span><span class="s3">()</span>

    <span class="s1">labels </span><span class="s3">= </span><span class="s1">HDBSCAN</span><span class="s3">(</span><span class="s1">metric</span><span class="s3">=</span><span class="s5">&quot;precomputed&quot;</span><span class="s3">).</span><span class="s1">fit_predict</span><span class="s3">(</span><span class="s1">D</span><span class="s3">)</span>
    <span class="s1">check_label_quality</span><span class="s3">(</span><span class="s1">labels</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_hdbscan_feature_array</span><span class="s3">():</span>
    <span class="s0">&quot;&quot;&quot; 
    Tests that HDBSCAN works with feature array, including an arbitrary 
    goodness of fit check. Note that the check is a simple heuristic. 
    &quot;&quot;&quot;</span>
    <span class="s1">labels </span><span class="s3">= </span><span class="s1">HDBSCAN</span><span class="s3">().</span><span class="s1">fit_predict</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>

    <span class="s6"># Check that clustering is arbitrarily good</span>
    <span class="s6"># This is a heuristic to guard against regression</span>
    <span class="s1">check_label_quality</span><span class="s3">(</span><span class="s1">labels</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s5">&quot;algo&quot;</span><span class="s3">, </span><span class="s1">ALGORITHMS</span><span class="s3">)</span>
<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s5">&quot;metric&quot;</span><span class="s3">, </span><span class="s1">_VALID_METRICS</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">test_hdbscan_algorithms</span><span class="s3">(</span><span class="s1">algo</span><span class="s3">, </span><span class="s1">metric</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Tests that HDBSCAN works with the expected combinations of algorithms and 
    metrics, or raises the expected errors. 
    &quot;&quot;&quot;</span>
    <span class="s1">labels </span><span class="s3">= </span><span class="s1">HDBSCAN</span><span class="s3">(</span><span class="s1">algorithm</span><span class="s3">=</span><span class="s1">algo</span><span class="s3">).</span><span class="s1">fit_predict</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
    <span class="s1">check_label_quality</span><span class="s3">(</span><span class="s1">labels</span><span class="s3">)</span>

    <span class="s6"># Validation for brute is handled by `pairwise_distances`</span>
    <span class="s2">if </span><span class="s1">algo </span><span class="s2">in </span><span class="s3">(</span><span class="s5">&quot;brute&quot;</span><span class="s3">, </span><span class="s5">&quot;auto&quot;</span><span class="s3">):</span>
        <span class="s2">return</span>

    <span class="s1">ALGOS_TREES </span><span class="s3">= {</span>
        <span class="s5">&quot;kd_tree&quot;</span><span class="s3">: </span><span class="s1">KDTree</span><span class="s3">,</span>
        <span class="s5">&quot;ball_tree&quot;</span><span class="s3">: </span><span class="s1">BallTree</span><span class="s3">,</span>
    <span class="s3">}</span>
    <span class="s1">metric_params </span><span class="s3">= {</span>
        <span class="s5">&quot;mahalanobis&quot;</span><span class="s3">: {</span><span class="s5">&quot;V&quot;</span><span class="s3">: </span><span class="s1">np</span><span class="s3">.</span><span class="s1">eye</span><span class="s3">(</span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s4">1</span><span class="s3">])},</span>
        <span class="s5">&quot;seuclidean&quot;</span><span class="s3">: {</span><span class="s5">&quot;V&quot;</span><span class="s3">: </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s4">1</span><span class="s3">])},</span>
        <span class="s5">&quot;minkowski&quot;</span><span class="s3">: {</span><span class="s5">&quot;p&quot;</span><span class="s3">: </span><span class="s4">2</span><span class="s3">},</span>
        <span class="s5">&quot;wminkowski&quot;</span><span class="s3">: {</span><span class="s5">&quot;p&quot;</span><span class="s3">: </span><span class="s4">2</span><span class="s3">, </span><span class="s5">&quot;w&quot;</span><span class="s3">: </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s4">1</span><span class="s3">])},</span>
    <span class="s3">}.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">metric</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>

    <span class="s1">hdb </span><span class="s3">= </span><span class="s1">HDBSCAN</span><span class="s3">(</span>
        <span class="s1">algorithm</span><span class="s3">=</span><span class="s1">algo</span><span class="s3">,</span>
        <span class="s1">metric</span><span class="s3">=</span><span class="s1">metric</span><span class="s3">,</span>
        <span class="s1">metric_params</span><span class="s3">=</span><span class="s1">metric_params</span><span class="s3">,</span>
    <span class="s3">)</span>

    <span class="s2">if </span><span class="s1">metric </span><span class="s2">not in </span><span class="s1">ALGOS_TREES</span><span class="s3">[</span><span class="s1">algo</span><span class="s3">].</span><span class="s1">valid_metrics</span><span class="s3">:</span>
        <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">):</span>
            <span class="s1">hdb</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">metric </span><span class="s3">== </span><span class="s5">&quot;wminkowski&quot;</span><span class="s3">:</span>
        <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">warns</span><span class="s3">(</span><span class="s1">FutureWarning</span><span class="s3">):</span>
            <span class="s1">hdb</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">hdb</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_dbscan_clustering</span><span class="s3">():</span>
    <span class="s0">&quot;&quot;&quot; 
    Tests that HDBSCAN can generate a sufficiently accurate dbscan clustering. 
    This test is more of a sanity check than a rigorous evaluation. 
    &quot;&quot;&quot;</span>
    <span class="s1">clusterer </span><span class="s3">= </span><span class="s1">HDBSCAN</span><span class="s3">().</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
    <span class="s1">labels </span><span class="s3">= </span><span class="s1">clusterer</span><span class="s3">.</span><span class="s1">dbscan_clustering</span><span class="s3">(</span><span class="s4">0.3</span><span class="s3">)</span>

    <span class="s6"># We use a looser threshold due to dbscan producing a more constrained</span>
    <span class="s6"># clustering representation</span>
    <span class="s1">check_label_quality</span><span class="s3">(</span><span class="s1">labels</span><span class="s3">, </span><span class="s1">threshold</span><span class="s3">=</span><span class="s4">0.92</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s5">&quot;cut_distance&quot;</span><span class="s3">, (</span><span class="s4">0.1</span><span class="s3">, </span><span class="s4">0.5</span><span class="s3">, </span><span class="s4">1</span><span class="s3">))</span>
<span class="s2">def </span><span class="s1">test_dbscan_clustering_outlier_data</span><span class="s3">(</span><span class="s1">cut_distance</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Tests if np.inf and np.nan data are each treated as special outliers. 
    &quot;&quot;&quot;</span>
    <span class="s1">missing_label </span><span class="s3">= </span><span class="s1">_OUTLIER_ENCODING</span><span class="s3">[</span><span class="s5">&quot;missing&quot;</span><span class="s3">][</span><span class="s5">&quot;label&quot;</span><span class="s3">]</span>
    <span class="s1">infinite_label </span><span class="s3">= </span><span class="s1">_OUTLIER_ENCODING</span><span class="s3">[</span><span class="s5">&quot;infinite&quot;</span><span class="s3">][</span><span class="s5">&quot;label&quot;</span><span class="s3">]</span>

    <span class="s1">X_outlier </span><span class="s3">= </span><span class="s1">X</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>
    <span class="s1">X_outlier</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] = [</span><span class="s1">np</span><span class="s3">.</span><span class="s1">inf</span><span class="s3">, </span><span class="s4">1</span><span class="s3">]</span>
    <span class="s1">X_outlier</span><span class="s3">[</span><span class="s4">2</span><span class="s3">] = [</span><span class="s4">1</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span><span class="s3">]</span>
    <span class="s1">X_outlier</span><span class="s3">[</span><span class="s4">5</span><span class="s3">] = [</span><span class="s1">np</span><span class="s3">.</span><span class="s1">inf</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span><span class="s3">]</span>
    <span class="s1">model </span><span class="s3">= </span><span class="s1">HDBSCAN</span><span class="s3">().</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X_outlier</span><span class="s3">)</span>
    <span class="s1">labels </span><span class="s3">= </span><span class="s1">model</span><span class="s3">.</span><span class="s1">dbscan_clustering</span><span class="s3">(</span><span class="s1">cut_distance</span><span class="s3">=</span><span class="s1">cut_distance</span><span class="s3">)</span>

    <span class="s1">missing_labels_idx </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">flatnonzero</span><span class="s3">(</span><span class="s1">labels </span><span class="s3">== </span><span class="s1">missing_label</span><span class="s3">)</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">missing_labels_idx</span><span class="s3">, [</span><span class="s4">2</span><span class="s3">, </span><span class="s4">5</span><span class="s3">])</span>

    <span class="s1">infinite_labels_idx </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">flatnonzero</span><span class="s3">(</span><span class="s1">labels </span><span class="s3">== </span><span class="s1">infinite_label</span><span class="s3">)</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">infinite_labels_idx</span><span class="s3">, [</span><span class="s4">0</span><span class="s3">])</span>

    <span class="s1">clean_idx </span><span class="s3">= </span><span class="s1">list</span><span class="s3">(</span><span class="s1">set</span><span class="s3">(</span><span class="s1">range</span><span class="s3">(</span><span class="s4">200</span><span class="s3">)) - </span><span class="s1">set</span><span class="s3">(</span><span class="s1">missing_labels_idx </span><span class="s3">+ </span><span class="s1">infinite_labels_idx</span><span class="s3">))</span>
    <span class="s1">clean_model </span><span class="s3">= </span><span class="s1">HDBSCAN</span><span class="s3">().</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X_outlier</span><span class="s3">[</span><span class="s1">clean_idx</span><span class="s3">])</span>
    <span class="s1">clean_labels </span><span class="s3">= </span><span class="s1">clean_model</span><span class="s3">.</span><span class="s1">dbscan_clustering</span><span class="s3">(</span><span class="s1">cut_distance</span><span class="s3">=</span><span class="s1">cut_distance</span><span class="s3">)</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">clean_labels</span><span class="s3">, </span><span class="s1">labels</span><span class="s3">[</span><span class="s1">clean_idx</span><span class="s3">])</span>


<span class="s2">def </span><span class="s1">test_hdbscan_best_balltree_metric</span><span class="s3">():</span>
    <span class="s0">&quot;&quot;&quot; 
    Tests that HDBSCAN using `BallTree` works. 
    &quot;&quot;&quot;</span>
    <span class="s1">labels </span><span class="s3">= </span><span class="s1">HDBSCAN</span><span class="s3">(</span>
        <span class="s1">metric</span><span class="s3">=</span><span class="s5">&quot;seuclidean&quot;</span><span class="s3">, </span><span class="s1">metric_params</span><span class="s3">={</span><span class="s5">&quot;V&quot;</span><span class="s3">: </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s4">1</span><span class="s3">])}</span>
    <span class="s3">).</span><span class="s1">fit_predict</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
    <span class="s1">check_label_quality</span><span class="s3">(</span><span class="s1">labels</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_hdbscan_no_clusters</span><span class="s3">():</span>
    <span class="s0">&quot;&quot;&quot; 
    Tests that HDBSCAN correctly does not generate a valid cluster when the 
    `min_cluster_size` is too large for the data. 
    &quot;&quot;&quot;</span>
    <span class="s1">labels </span><span class="s3">= </span><span class="s1">HDBSCAN</span><span class="s3">(</span><span class="s1">min_cluster_size</span><span class="s3">=</span><span class="s1">len</span><span class="s3">(</span><span class="s1">X</span><span class="s3">) - </span><span class="s4">1</span><span class="s3">).</span><span class="s1">fit_predict</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
    <span class="s2">assert </span><span class="s1">set</span><span class="s3">(</span><span class="s1">labels</span><span class="s3">).</span><span class="s1">issubset</span><span class="s3">(</span><span class="s1">OUTLIER_SET</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_hdbscan_min_cluster_size</span><span class="s3">():</span>
    <span class="s0">&quot;&quot;&quot; 
    Test that the smallest non-noise cluster has at least `min_cluster_size` 
    many points 
    &quot;&quot;&quot;</span>
    <span class="s2">for </span><span class="s1">min_cluster_size </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s4">2</span><span class="s3">, </span><span class="s1">len</span><span class="s3">(</span><span class="s1">X</span><span class="s3">), </span><span class="s4">1</span><span class="s3">):</span>
        <span class="s1">labels </span><span class="s3">= </span><span class="s1">HDBSCAN</span><span class="s3">(</span><span class="s1">min_cluster_size</span><span class="s3">=</span><span class="s1">min_cluster_size</span><span class="s3">).</span><span class="s1">fit_predict</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
        <span class="s1">true_labels </span><span class="s3">= [</span><span class="s1">label </span><span class="s2">for </span><span class="s1">label </span><span class="s2">in </span><span class="s1">labels </span><span class="s2">if </span><span class="s1">label </span><span class="s3">!= -</span><span class="s4">1</span><span class="s3">]</span>
        <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">true_labels</span><span class="s3">) != </span><span class="s4">0</span><span class="s3">:</span>
            <span class="s2">assert </span><span class="s1">np</span><span class="s3">.</span><span class="s1">min</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">bincount</span><span class="s3">(</span><span class="s1">true_labels</span><span class="s3">)) &gt;= </span><span class="s1">min_cluster_size</span>


<span class="s2">def </span><span class="s1">test_hdbscan_callable_metric</span><span class="s3">():</span>
    <span class="s0">&quot;&quot;&quot; 
    Tests that HDBSCAN works when passed a callable metric. 
    &quot;&quot;&quot;</span>
    <span class="s1">metric </span><span class="s3">= </span><span class="s1">distance</span><span class="s3">.</span><span class="s1">euclidean</span>
    <span class="s1">labels </span><span class="s3">= </span><span class="s1">HDBSCAN</span><span class="s3">(</span><span class="s1">metric</span><span class="s3">=</span><span class="s1">metric</span><span class="s3">).</span><span class="s1">fit_predict</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
    <span class="s1">check_label_quality</span><span class="s3">(</span><span class="s1">labels</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s5">&quot;tree&quot;</span><span class="s3">, [</span><span class="s5">&quot;kd_tree&quot;</span><span class="s3">, </span><span class="s5">&quot;ball_tree&quot;</span><span class="s3">])</span>
<span class="s2">def </span><span class="s1">test_hdbscan_precomputed_non_brute</span><span class="s3">(</span><span class="s1">tree</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Tests that HDBSCAN correctly raises an error when passing precomputed data 
    while requesting a tree-based algorithm. 
    &quot;&quot;&quot;</span>
    <span class="s1">hdb </span><span class="s3">= </span><span class="s1">HDBSCAN</span><span class="s3">(</span><span class="s1">metric</span><span class="s3">=</span><span class="s5">&quot;precomputed&quot;</span><span class="s3">, </span><span class="s1">algorithm</span><span class="s3">=</span><span class="s1">tree</span><span class="s3">)</span>
    <span class="s1">msg </span><span class="s3">= </span><span class="s5">&quot;precomputed is not a valid metric for&quot;</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s1">msg</span><span class="s3">):</span>
        <span class="s1">hdb</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s5">&quot;csr_container&quot;</span><span class="s3">, </span><span class="s1">CSR_CONTAINERS</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">test_hdbscan_sparse</span><span class="s3">(</span><span class="s1">csr_container</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Tests that HDBSCAN works correctly when passing sparse feature data. 
    Evaluates correctness by comparing against the same data passed as a dense 
    array. 
    &quot;&quot;&quot;</span>

    <span class="s1">dense_labels </span><span class="s3">= </span><span class="s1">HDBSCAN</span><span class="s3">().</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">).</span><span class="s1">labels_</span>
    <span class="s1">check_label_quality</span><span class="s3">(</span><span class="s1">dense_labels</span><span class="s3">)</span>

    <span class="s1">_X_sparse </span><span class="s3">= </span><span class="s1">csr_container</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
    <span class="s1">X_sparse </span><span class="s3">= </span><span class="s1">_X_sparse</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>
    <span class="s1">sparse_labels </span><span class="s3">= </span><span class="s1">HDBSCAN</span><span class="s3">().</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X_sparse</span><span class="s3">).</span><span class="s1">labels_</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">dense_labels</span><span class="s3">, </span><span class="s1">sparse_labels</span><span class="s3">)</span>

    <span class="s6"># Compare that the sparse and dense non-precomputed routines return the same labels</span>
    <span class="s6"># where the 0th observation contains the outlier.</span>
    <span class="s2">for </span><span class="s1">outlier_val</span><span class="s3">, </span><span class="s1">outlier_type </span><span class="s2">in </span><span class="s3">((</span><span class="s1">np</span><span class="s3">.</span><span class="s1">inf</span><span class="s3">, </span><span class="s5">&quot;infinite&quot;</span><span class="s3">), (</span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span><span class="s3">, </span><span class="s5">&quot;missing&quot;</span><span class="s3">)):</span>
        <span class="s1">X_dense </span><span class="s3">= </span><span class="s1">X</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>
        <span class="s1">X_dense</span><span class="s3">[</span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s3">] = </span><span class="s1">outlier_val</span>
        <span class="s1">dense_labels </span><span class="s3">= </span><span class="s1">HDBSCAN</span><span class="s3">().</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X_dense</span><span class="s3">).</span><span class="s1">labels_</span>
        <span class="s1">check_label_quality</span><span class="s3">(</span><span class="s1">dense_labels</span><span class="s3">)</span>
        <span class="s2">assert </span><span class="s1">dense_labels</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] == </span><span class="s1">_OUTLIER_ENCODING</span><span class="s3">[</span><span class="s1">outlier_type</span><span class="s3">][</span><span class="s5">&quot;label&quot;</span><span class="s3">]</span>

        <span class="s1">X_sparse </span><span class="s3">= </span><span class="s1">_X_sparse</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>
        <span class="s1">X_sparse</span><span class="s3">[</span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s3">] = </span><span class="s1">outlier_val</span>
        <span class="s1">sparse_labels </span><span class="s3">= </span><span class="s1">HDBSCAN</span><span class="s3">().</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X_sparse</span><span class="s3">).</span><span class="s1">labels_</span>
        <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">dense_labels</span><span class="s3">, </span><span class="s1">sparse_labels</span><span class="s3">)</span>

    <span class="s1">msg </span><span class="s3">= </span><span class="s5">&quot;Sparse data matrices only support algorithm `brute`.&quot;</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s1">msg</span><span class="s3">):</span>
        <span class="s1">HDBSCAN</span><span class="s3">(</span><span class="s1">metric</span><span class="s3">=</span><span class="s5">&quot;euclidean&quot;</span><span class="s3">, </span><span class="s1">algorithm</span><span class="s3">=</span><span class="s5">&quot;ball_tree&quot;</span><span class="s3">).</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X_sparse</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s5">&quot;algorithm&quot;</span><span class="s3">, </span><span class="s1">ALGORITHMS</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">test_hdbscan_centers</span><span class="s3">(</span><span class="s1">algorithm</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Tests that HDBSCAN centers are calculated and stored properly, and are 
    accurate to the data. 
    &quot;&quot;&quot;</span>
    <span class="s1">centers </span><span class="s3">= [(</span><span class="s4">0.0</span><span class="s3">, </span><span class="s4">0.0</span><span class="s3">), (</span><span class="s4">3.0</span><span class="s3">, </span><span class="s4">3.0</span><span class="s3">)]</span>
    <span class="s1">H</span><span class="s3">, </span><span class="s1">_ </span><span class="s3">= </span><span class="s1">make_blobs</span><span class="s3">(</span><span class="s1">n_samples</span><span class="s3">=</span><span class="s4">2000</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s4">0</span><span class="s3">, </span><span class="s1">centers</span><span class="s3">=</span><span class="s1">centers</span><span class="s3">, </span><span class="s1">cluster_std</span><span class="s3">=</span><span class="s4">0.5</span><span class="s3">)</span>
    <span class="s1">hdb </span><span class="s3">= </span><span class="s1">HDBSCAN</span><span class="s3">(</span><span class="s1">store_centers</span><span class="s3">=</span><span class="s5">&quot;both&quot;</span><span class="s3">).</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">H</span><span class="s3">)</span>

    <span class="s2">for </span><span class="s1">center</span><span class="s3">, </span><span class="s1">centroid</span><span class="s3">, </span><span class="s1">medoid </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">centers</span><span class="s3">, </span><span class="s1">hdb</span><span class="s3">.</span><span class="s1">centroids_</span><span class="s3">, </span><span class="s1">hdb</span><span class="s3">.</span><span class="s1">medoids_</span><span class="s3">):</span>
        <span class="s1">assert_allclose</span><span class="s3">(</span><span class="s1">center</span><span class="s3">, </span><span class="s1">centroid</span><span class="s3">, </span><span class="s1">rtol</span><span class="s3">=</span><span class="s4">1</span><span class="s3">, </span><span class="s1">atol</span><span class="s3">=</span><span class="s4">0.05</span><span class="s3">)</span>
        <span class="s1">assert_allclose</span><span class="s3">(</span><span class="s1">center</span><span class="s3">, </span><span class="s1">medoid</span><span class="s3">, </span><span class="s1">rtol</span><span class="s3">=</span><span class="s4">1</span><span class="s3">, </span><span class="s1">atol</span><span class="s3">=</span><span class="s4">0.05</span><span class="s3">)</span>

    <span class="s6"># Ensure that nothing is done for noise</span>
    <span class="s1">hdb </span><span class="s3">= </span><span class="s1">HDBSCAN</span><span class="s3">(</span>
        <span class="s1">algorithm</span><span class="s3">=</span><span class="s1">algorithm</span><span class="s3">, </span><span class="s1">store_centers</span><span class="s3">=</span><span class="s5">&quot;both&quot;</span><span class="s3">, </span><span class="s1">min_cluster_size</span><span class="s3">=</span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]</span>
    <span class="s3">).</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
    <span class="s2">assert </span><span class="s1">hdb</span><span class="s3">.</span><span class="s1">centroids_</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] == </span><span class="s4">0</span>
    <span class="s2">assert </span><span class="s1">hdb</span><span class="s3">.</span><span class="s1">medoids_</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] == </span><span class="s4">0</span>


<span class="s2">def </span><span class="s1">test_hdbscan_allow_single_cluster_with_epsilon</span><span class="s3">():</span>
    <span class="s0">&quot;&quot;&quot; 
    Tests that HDBSCAN single-cluster selection with epsilon works correctly. 
    &quot;&quot;&quot;</span>
    <span class="s1">rng </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">RandomState</span><span class="s3">(</span><span class="s4">0</span><span class="s3">)</span>
    <span class="s1">no_structure </span><span class="s3">= </span><span class="s1">rng</span><span class="s3">.</span><span class="s1">rand</span><span class="s3">(</span><span class="s4">150</span><span class="s3">, </span><span class="s4">2</span><span class="s3">)</span>
    <span class="s6"># without epsilon we should see many noise points as children of root.</span>
    <span class="s1">labels </span><span class="s3">= </span><span class="s1">HDBSCAN</span><span class="s3">(</span>
        <span class="s1">min_cluster_size</span><span class="s3">=</span><span class="s4">5</span><span class="s3">,</span>
        <span class="s1">cluster_selection_epsilon</span><span class="s3">=</span><span class="s4">0.0</span><span class="s3">,</span>
        <span class="s1">cluster_selection_method</span><span class="s3">=</span><span class="s5">&quot;eom&quot;</span><span class="s3">,</span>
        <span class="s1">allow_single_cluster</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
    <span class="s3">).</span><span class="s1">fit_predict</span><span class="s3">(</span><span class="s1">no_structure</span><span class="s3">)</span>
    <span class="s1">unique_labels</span><span class="s3">, </span><span class="s1">counts </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">unique</span><span class="s3">(</span><span class="s1">labels</span><span class="s3">, </span><span class="s1">return_counts</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
    <span class="s2">assert </span><span class="s1">len</span><span class="s3">(</span><span class="s1">unique_labels</span><span class="s3">) == </span><span class="s4">2</span>

    <span class="s6"># Arbitrary heuristic. Would prefer something more precise.</span>
    <span class="s2">assert </span><span class="s1">counts</span><span class="s3">[</span><span class="s1">unique_labels </span><span class="s3">== -</span><span class="s4">1</span><span class="s3">] &gt; </span><span class="s4">30</span>

    <span class="s6"># for this random seed an epsilon of 0.18 will produce exactly 2 noise</span>
    <span class="s6"># points at that cut in single linkage.</span>
    <span class="s1">labels </span><span class="s3">= </span><span class="s1">HDBSCAN</span><span class="s3">(</span>
        <span class="s1">min_cluster_size</span><span class="s3">=</span><span class="s4">5</span><span class="s3">,</span>
        <span class="s1">cluster_selection_epsilon</span><span class="s3">=</span><span class="s4">0.18</span><span class="s3">,</span>
        <span class="s1">cluster_selection_method</span><span class="s3">=</span><span class="s5">&quot;eom&quot;</span><span class="s3">,</span>
        <span class="s1">allow_single_cluster</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
        <span class="s1">algorithm</span><span class="s3">=</span><span class="s5">&quot;kd_tree&quot;</span><span class="s3">,</span>
    <span class="s3">).</span><span class="s1">fit_predict</span><span class="s3">(</span><span class="s1">no_structure</span><span class="s3">)</span>
    <span class="s1">unique_labels</span><span class="s3">, </span><span class="s1">counts </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">unique</span><span class="s3">(</span><span class="s1">labels</span><span class="s3">, </span><span class="s1">return_counts</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
    <span class="s2">assert </span><span class="s1">len</span><span class="s3">(</span><span class="s1">unique_labels</span><span class="s3">) == </span><span class="s4">2</span>
    <span class="s2">assert </span><span class="s1">counts</span><span class="s3">[</span><span class="s1">unique_labels </span><span class="s3">== -</span><span class="s4">1</span><span class="s3">] == </span><span class="s4">2</span>


<span class="s2">def </span><span class="s1">test_hdbscan_better_than_dbscan</span><span class="s3">():</span>
    <span class="s0">&quot;&quot;&quot; 
    Validate that HDBSCAN can properly cluster this difficult synthetic 
    dataset. Note that DBSCAN fails on this (see HDBSCAN plotting 
    example) 
    &quot;&quot;&quot;</span>
    <span class="s1">centers </span><span class="s3">= [[-</span><span class="s4">0.85</span><span class="s3">, -</span><span class="s4">0.85</span><span class="s3">], [-</span><span class="s4">0.85</span><span class="s3">, </span><span class="s4">0.85</span><span class="s3">], [</span><span class="s4">3</span><span class="s3">, </span><span class="s4">3</span><span class="s3">], [</span><span class="s4">3</span><span class="s3">, -</span><span class="s4">3</span><span class="s3">]]</span>
    <span class="s1">X</span><span class="s3">, </span><span class="s1">y </span><span class="s3">= </span><span class="s1">make_blobs</span><span class="s3">(</span>
        <span class="s1">n_samples</span><span class="s3">=</span><span class="s4">750</span><span class="s3">,</span>
        <span class="s1">centers</span><span class="s3">=</span><span class="s1">centers</span><span class="s3">,</span>
        <span class="s1">cluster_std</span><span class="s3">=[</span><span class="s4">0.2</span><span class="s3">, </span><span class="s4">0.35</span><span class="s3">, </span><span class="s4">1.35</span><span class="s3">, </span><span class="s4">1.35</span><span class="s3">],</span>
        <span class="s1">random_state</span><span class="s3">=</span><span class="s4">0</span><span class="s3">,</span>
    <span class="s3">)</span>
    <span class="s1">labels </span><span class="s3">= </span><span class="s1">HDBSCAN</span><span class="s3">().</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">).</span><span class="s1">labels_</span>

    <span class="s1">n_clusters </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">set</span><span class="s3">(</span><span class="s1">labels</span><span class="s3">)) - </span><span class="s1">int</span><span class="s3">(-</span><span class="s4">1 </span><span class="s2">in </span><span class="s1">labels</span><span class="s3">)</span>
    <span class="s2">assert </span><span class="s1">n_clusters </span><span class="s3">== </span><span class="s4">4</span>
    <span class="s1">fowlkes_mallows_score</span><span class="s3">(</span><span class="s1">labels</span><span class="s3">, </span><span class="s1">y</span><span class="s3">) &gt; </span><span class="s4">0.99</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span>
    <span class="s5">&quot;kwargs, X&quot;</span><span class="s3">,</span>
    <span class="s3">[</span>
        <span class="s3">({</span><span class="s5">&quot;metric&quot;</span><span class="s3">: </span><span class="s5">&quot;precomputed&quot;</span><span class="s3">}, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([[</span><span class="s4">1</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">inf</span><span class="s3">], [</span><span class="s1">np</span><span class="s3">.</span><span class="s1">inf</span><span class="s3">, </span><span class="s4">1</span><span class="s3">]])),</span>
        <span class="s3">({</span><span class="s5">&quot;metric&quot;</span><span class="s3">: </span><span class="s5">&quot;precomputed&quot;</span><span class="s3">}, [[</span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">], [</span><span class="s4">2</span><span class="s3">, </span><span class="s4">1</span><span class="s3">]]),</span>
        <span class="s3">({}, [[</span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">], [</span><span class="s4">3</span><span class="s3">, </span><span class="s4">4</span><span class="s3">]]),</span>
    <span class="s3">],</span>
<span class="s3">)</span>
<span class="s2">def </span><span class="s1">test_hdbscan_usable_inputs</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">kwargs</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Tests that HDBSCAN works correctly for array-likes and precomputed inputs 
    with non-finite points. 
    &quot;&quot;&quot;</span>
    <span class="s1">HDBSCAN</span><span class="s3">(</span><span class="s1">min_samples</span><span class="s3">=</span><span class="s4">1</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">).</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s5">&quot;csr_container&quot;</span><span class="s3">, </span><span class="s1">CSR_CONTAINERS</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">test_hdbscan_sparse_distances_too_few_nonzero</span><span class="s3">(</span><span class="s1">csr_container</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Tests that HDBSCAN raises the correct error when there are too few 
    non-zero distances. 
    &quot;&quot;&quot;</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">csr_container</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">((</span><span class="s4">10</span><span class="s3">, </span><span class="s4">10</span><span class="s3">)))</span>

    <span class="s1">msg </span><span class="s3">= </span><span class="s5">&quot;There exists points with fewer than&quot;</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s1">msg</span><span class="s3">):</span>
        <span class="s1">HDBSCAN</span><span class="s3">(</span><span class="s1">metric</span><span class="s3">=</span><span class="s5">&quot;precomputed&quot;</span><span class="s3">).</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s5">&quot;csr_container&quot;</span><span class="s3">, </span><span class="s1">CSR_CONTAINERS</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">test_hdbscan_sparse_distances_disconnected_graph</span><span class="s3">(</span><span class="s1">csr_container</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Tests that HDBSCAN raises the correct error when the distance matrix 
    has multiple connected components. 
    &quot;&quot;&quot;</span>
    <span class="s6"># Create symmetric sparse matrix with 2 connected components</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">((</span><span class="s4">20</span><span class="s3">, </span><span class="s4">20</span><span class="s3">))</span>
    <span class="s1">X</span><span class="s3">[:</span><span class="s4">5</span><span class="s3">, :</span><span class="s4">5</span><span class="s3">] = </span><span class="s4">1</span>
    <span class="s1">X</span><span class="s3">[</span><span class="s4">5</span><span class="s3">:, </span><span class="s4">15</span><span class="s3">:] = </span><span class="s4">1</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">X </span><span class="s3">+ </span><span class="s1">X</span><span class="s3">.</span><span class="s1">T</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">csr_container</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
    <span class="s1">msg </span><span class="s3">= </span><span class="s5">&quot;HDBSCAN cannot be perfomed on a disconnected graph&quot;</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s1">msg</span><span class="s3">):</span>
        <span class="s1">HDBSCAN</span><span class="s3">(</span><span class="s1">metric</span><span class="s3">=</span><span class="s5">&quot;precomputed&quot;</span><span class="s3">).</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_hdbscan_tree_invalid_metric</span><span class="s3">():</span>
    <span class="s0">&quot;&quot;&quot; 
    Tests that HDBSCAN correctly raises an error for invalid metric choices. 
    &quot;&quot;&quot;</span>
    <span class="s1">metric_callable </span><span class="s3">= </span><span class="s2">lambda </span><span class="s1">x</span><span class="s3">: </span><span class="s1">x</span>
    <span class="s1">msg </span><span class="s3">= (</span>
        <span class="s5">&quot;.* is not a valid metric for a .*-based algorithm</span><span class="s2">\\</span><span class="s5">. Please select a different&quot;</span>
        <span class="s5">&quot; metric</span><span class="s2">\\</span><span class="s5">.&quot;</span>
    <span class="s3">)</span>

    <span class="s6"># Callables are not supported for either</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s1">msg</span><span class="s3">):</span>
        <span class="s1">HDBSCAN</span><span class="s3">(</span><span class="s1">algorithm</span><span class="s3">=</span><span class="s5">&quot;kd_tree&quot;</span><span class="s3">, </span><span class="s1">metric</span><span class="s3">=</span><span class="s1">metric_callable</span><span class="s3">).</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s1">msg</span><span class="s3">):</span>
        <span class="s1">HDBSCAN</span><span class="s3">(</span><span class="s1">algorithm</span><span class="s3">=</span><span class="s5">&quot;ball_tree&quot;</span><span class="s3">, </span><span class="s1">metric</span><span class="s3">=</span><span class="s1">metric_callable</span><span class="s3">).</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>

    <span class="s6"># The set of valid metrics for KDTree at the time of writing this test is a</span>
    <span class="s6"># strict subset of those supported in BallTree</span>
    <span class="s1">metrics_not_kd </span><span class="s3">= </span><span class="s1">list</span><span class="s3">(</span><span class="s1">set</span><span class="s3">(</span><span class="s1">BallTree</span><span class="s3">.</span><span class="s1">valid_metrics</span><span class="s3">) - </span><span class="s1">set</span><span class="s3">(</span><span class="s1">KDTree</span><span class="s3">.</span><span class="s1">valid_metrics</span><span class="s3">))</span>
    <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">metrics_not_kd</span><span class="s3">) &gt; </span><span class="s4">0</span><span class="s3">:</span>
        <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s1">msg</span><span class="s3">):</span>
            <span class="s1">HDBSCAN</span><span class="s3">(</span><span class="s1">algorithm</span><span class="s3">=</span><span class="s5">&quot;kd_tree&quot;</span><span class="s3">, </span><span class="s1">metric</span><span class="s3">=</span><span class="s1">metrics_not_kd</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]).</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_hdbscan_too_many_min_samples</span><span class="s3">():</span>
    <span class="s0">&quot;&quot;&quot; 
    Tests that HDBSCAN correctly raises an error when setting `min_samples` 
    larger than the number of samples. 
    &quot;&quot;&quot;</span>
    <span class="s1">hdb </span><span class="s3">= </span><span class="s1">HDBSCAN</span><span class="s3">(</span><span class="s1">min_samples</span><span class="s3">=</span><span class="s1">len</span><span class="s3">(</span><span class="s1">X</span><span class="s3">) + </span><span class="s4">1</span><span class="s3">)</span>
    <span class="s1">msg </span><span class="s3">= </span><span class="s5">r&quot;min_samples (.*) must be at most&quot;</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s1">msg</span><span class="s3">):</span>
        <span class="s1">hdb</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_hdbscan_precomputed_dense_nan</span><span class="s3">():</span>
    <span class="s0">&quot;&quot;&quot; 
    Tests that HDBSCAN correctly raises an error when providing precomputed 
    distances with `np.nan` values. 
    &quot;&quot;&quot;</span>
    <span class="s1">X_nan </span><span class="s3">= </span><span class="s1">X</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>
    <span class="s1">X_nan</span><span class="s3">[</span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s3">] = </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span>
    <span class="s1">msg </span><span class="s3">= </span><span class="s5">&quot;np.nan values found in precomputed-dense&quot;</span>
    <span class="s1">hdb </span><span class="s3">= </span><span class="s1">HDBSCAN</span><span class="s3">(</span><span class="s1">metric</span><span class="s3">=</span><span class="s5">&quot;precomputed&quot;</span><span class="s3">)</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s1">msg</span><span class="s3">):</span>
        <span class="s1">hdb</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X_nan</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s5">&quot;allow_single_cluster&quot;</span><span class="s3">, [</span><span class="s2">True</span><span class="s3">, </span><span class="s2">False</span><span class="s3">])</span>
<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s5">&quot;epsilon&quot;</span><span class="s3">, [</span><span class="s4">0</span><span class="s3">, </span><span class="s4">0.1</span><span class="s3">])</span>
<span class="s2">def </span><span class="s1">test_labelling_distinct</span><span class="s3">(</span><span class="s1">global_random_seed</span><span class="s3">, </span><span class="s1">allow_single_cluster</span><span class="s3">, </span><span class="s1">epsilon</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Tests that the `_do_labelling` helper function correctly assigns labels. 
    &quot;&quot;&quot;</span>
    <span class="s1">n_samples </span><span class="s3">= </span><span class="s4">48</span>
    <span class="s1">X</span><span class="s3">, </span><span class="s1">y </span><span class="s3">= </span><span class="s1">make_blobs</span><span class="s3">(</span>
        <span class="s1">n_samples</span><span class="s3">,</span>
        <span class="s1">random_state</span><span class="s3">=</span><span class="s1">global_random_seed</span><span class="s3">,</span>
        <span class="s6"># Ensure the clusters are distinct with no overlap</span>
        <span class="s1">centers</span><span class="s3">=[</span>
            <span class="s3">[</span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s3">],</span>
            <span class="s3">[</span><span class="s4">10</span><span class="s3">, </span><span class="s4">0</span><span class="s3">],</span>
            <span class="s3">[</span><span class="s4">0</span><span class="s3">, </span><span class="s4">10</span><span class="s3">],</span>
        <span class="s3">],</span>
    <span class="s3">)</span>

    <span class="s1">est </span><span class="s3">= </span><span class="s1">HDBSCAN</span><span class="s3">().</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
    <span class="s1">condensed_tree </span><span class="s3">= </span><span class="s1">_condense_tree</span><span class="s3">(</span>
        <span class="s1">est</span><span class="s3">.</span><span class="s1">_single_linkage_tree_</span><span class="s3">, </span><span class="s1">min_cluster_size</span><span class="s3">=</span><span class="s1">est</span><span class="s3">.</span><span class="s1">min_cluster_size</span>
    <span class="s3">)</span>
    <span class="s1">clusters </span><span class="s3">= {</span><span class="s1">n_samples </span><span class="s3">+ </span><span class="s4">2</span><span class="s3">, </span><span class="s1">n_samples </span><span class="s3">+ </span><span class="s4">3</span><span class="s3">, </span><span class="s1">n_samples </span><span class="s3">+ </span><span class="s4">4</span><span class="s3">}</span>
    <span class="s1">cluster_label_map </span><span class="s3">= {</span><span class="s1">n_samples </span><span class="s3">+ </span><span class="s4">2</span><span class="s3">: </span><span class="s4">0</span><span class="s3">, </span><span class="s1">n_samples </span><span class="s3">+ </span><span class="s4">3</span><span class="s3">: </span><span class="s4">1</span><span class="s3">, </span><span class="s1">n_samples </span><span class="s3">+ </span><span class="s4">4</span><span class="s3">: </span><span class="s4">2</span><span class="s3">}</span>
    <span class="s1">labels </span><span class="s3">= </span><span class="s1">_do_labelling</span><span class="s3">(</span>
        <span class="s1">condensed_tree</span><span class="s3">=</span><span class="s1">condensed_tree</span><span class="s3">,</span>
        <span class="s1">clusters</span><span class="s3">=</span><span class="s1">clusters</span><span class="s3">,</span>
        <span class="s1">cluster_label_map</span><span class="s3">=</span><span class="s1">cluster_label_map</span><span class="s3">,</span>
        <span class="s1">allow_single_cluster</span><span class="s3">=</span><span class="s1">allow_single_cluster</span><span class="s3">,</span>
        <span class="s1">cluster_selection_epsilon</span><span class="s3">=</span><span class="s1">epsilon</span><span class="s3">,</span>
    <span class="s3">)</span>

    <span class="s1">first_with_label </span><span class="s3">= {</span><span class="s1">_y</span><span class="s3">: </span><span class="s1">np</span><span class="s3">.</span><span class="s1">where</span><span class="s3">(</span><span class="s1">y </span><span class="s3">== </span><span class="s1">_y</span><span class="s3">)[</span><span class="s4">0</span><span class="s3">][</span><span class="s4">0</span><span class="s3">] </span><span class="s2">for </span><span class="s1">_y </span><span class="s2">in </span><span class="s1">list</span><span class="s3">(</span><span class="s1">set</span><span class="s3">(</span><span class="s1">y</span><span class="s3">))}</span>
    <span class="s1">y_to_labels </span><span class="s3">= {</span><span class="s1">_y</span><span class="s3">: </span><span class="s1">labels</span><span class="s3">[</span><span class="s1">first_with_label</span><span class="s3">[</span><span class="s1">_y</span><span class="s3">]] </span><span class="s2">for </span><span class="s1">_y </span><span class="s2">in </span><span class="s1">list</span><span class="s3">(</span><span class="s1">set</span><span class="s3">(</span><span class="s1">y</span><span class="s3">))}</span>
    <span class="s1">aligned_target </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">vectorize</span><span class="s3">(</span><span class="s1">y_to_labels</span><span class="s3">.</span><span class="s1">get</span><span class="s3">)(</span><span class="s1">y</span><span class="s3">)</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">labels</span><span class="s3">, </span><span class="s1">aligned_target</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_labelling_thresholding</span><span class="s3">():</span>
    <span class="s0">&quot;&quot;&quot; 
    Tests that the `_do_labelling` helper function correctly thresholds the 
    incoming lambda values given various `cluster_selection_epsilon` values. 
    &quot;&quot;&quot;</span>
    <span class="s1">n_samples </span><span class="s3">= </span><span class="s4">5</span>
    <span class="s1">MAX_LAMBDA </span><span class="s3">= </span><span class="s4">1.5</span>
    <span class="s1">condensed_tree </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span>
        <span class="s3">[</span>
            <span class="s3">(</span><span class="s4">5</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s1">MAX_LAMBDA</span><span class="s3">, </span><span class="s4">1</span><span class="s3">),</span>
            <span class="s3">(</span><span class="s4">5</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">0.1</span><span class="s3">, </span><span class="s4">1</span><span class="s3">),</span>
            <span class="s3">(</span><span class="s4">5</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s1">MAX_LAMBDA</span><span class="s3">, </span><span class="s4">1</span><span class="s3">),</span>
            <span class="s3">(</span><span class="s4">5</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s4">0.2</span><span class="s3">, </span><span class="s4">1</span><span class="s3">),</span>
            <span class="s3">(</span><span class="s4">5</span><span class="s3">, </span><span class="s4">4</span><span class="s3">, </span><span class="s4">0.3</span><span class="s3">, </span><span class="s4">1</span><span class="s3">),</span>
        <span class="s3">],</span>
        <span class="s1">dtype</span><span class="s3">=</span><span class="s1">CONDENSED_dtype</span><span class="s3">,</span>
    <span class="s3">)</span>
    <span class="s1">labels </span><span class="s3">= </span><span class="s1">_do_labelling</span><span class="s3">(</span>
        <span class="s1">condensed_tree</span><span class="s3">=</span><span class="s1">condensed_tree</span><span class="s3">,</span>
        <span class="s1">clusters</span><span class="s3">={</span><span class="s1">n_samples</span><span class="s3">},</span>
        <span class="s1">cluster_label_map</span><span class="s3">={</span><span class="s1">n_samples</span><span class="s3">: </span><span class="s4">0</span><span class="s3">, </span><span class="s1">n_samples </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">: </span><span class="s4">1</span><span class="s3">},</span>
        <span class="s1">allow_single_cluster</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
        <span class="s1">cluster_selection_epsilon</span><span class="s3">=</span><span class="s4">1</span><span class="s3">,</span>
    <span class="s3">)</span>
    <span class="s1">num_noise </span><span class="s3">= </span><span class="s1">condensed_tree</span><span class="s3">[</span><span class="s5">&quot;value&quot;</span><span class="s3">] &lt; </span><span class="s4">1</span>
    <span class="s2">assert </span><span class="s1">sum</span><span class="s3">(</span><span class="s1">num_noise</span><span class="s3">) == </span><span class="s1">sum</span><span class="s3">(</span><span class="s1">labels </span><span class="s3">== -</span><span class="s4">1</span><span class="s3">)</span>

    <span class="s1">labels </span><span class="s3">= </span><span class="s1">_do_labelling</span><span class="s3">(</span>
        <span class="s1">condensed_tree</span><span class="s3">=</span><span class="s1">condensed_tree</span><span class="s3">,</span>
        <span class="s1">clusters</span><span class="s3">={</span><span class="s1">n_samples</span><span class="s3">},</span>
        <span class="s1">cluster_label_map</span><span class="s3">={</span><span class="s1">n_samples</span><span class="s3">: </span><span class="s4">0</span><span class="s3">, </span><span class="s1">n_samples </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">: </span><span class="s4">1</span><span class="s3">},</span>
        <span class="s1">allow_single_cluster</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
        <span class="s1">cluster_selection_epsilon</span><span class="s3">=</span><span class="s4">0</span><span class="s3">,</span>
    <span class="s3">)</span>
    <span class="s6"># The threshold should be calculated per-sample based on the largest</span>
    <span class="s6"># lambda of any simbling node. In this case, all points are siblings</span>
    <span class="s6"># and the largest value is exactly MAX_LAMBDA.</span>
    <span class="s1">num_noise </span><span class="s3">= </span><span class="s1">condensed_tree</span><span class="s3">[</span><span class="s5">&quot;value&quot;</span><span class="s3">] &lt; </span><span class="s1">MAX_LAMBDA</span>
    <span class="s2">assert </span><span class="s1">sum</span><span class="s3">(</span><span class="s1">num_noise</span><span class="s3">) == </span><span class="s1">sum</span><span class="s3">(</span><span class="s1">labels </span><span class="s3">== -</span><span class="s4">1</span><span class="s3">)</span>


<span class="s6"># TODO(1.6): Remove</span>
<span class="s2">def </span><span class="s1">test_hdbscan_warning_on_deprecated_algorithm_name</span><span class="s3">():</span>
    <span class="s6"># Test that warning message is shown when algorithm='kdtree'</span>
    <span class="s1">msg </span><span class="s3">= (</span>
        <span class="s5">&quot;`algorithm='kdtree'`has been deprecated in 1.4 and will be renamed&quot;</span>
        <span class="s5">&quot; to'kd_tree'`in 1.6. To keep the past behaviour, set `algorithm='kd_tree'`.&quot;</span>
    <span class="s3">)</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">warns</span><span class="s3">(</span><span class="s1">FutureWarning</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s1">msg</span><span class="s3">):</span>
        <span class="s1">HDBSCAN</span><span class="s3">(</span><span class="s1">algorithm</span><span class="s3">=</span><span class="s5">&quot;kdtree&quot;</span><span class="s3">).</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>

    <span class="s6"># Test that warning message is shown when algorithm='balltree'</span>
    <span class="s1">msg </span><span class="s3">= (</span>
        <span class="s5">&quot;`algorithm='balltree'`has been deprecated in 1.4 and will be renamed&quot;</span>
        <span class="s5">&quot; to'ball_tree'`in 1.6. To keep the past behaviour, set&quot;</span>
        <span class="s5">&quot; `algorithm='ball_tree'`.&quot;</span>
    <span class="s3">)</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">warns</span><span class="s3">(</span><span class="s1">FutureWarning</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s1">msg</span><span class="s3">):</span>
        <span class="s1">HDBSCAN</span><span class="s3">(</span><span class="s1">algorithm</span><span class="s3">=</span><span class="s5">&quot;balltree&quot;</span><span class="s3">).</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s5">&quot;store_centers&quot;</span><span class="s3">, [</span><span class="s5">&quot;centroid&quot;</span><span class="s3">, </span><span class="s5">&quot;medoid&quot;</span><span class="s3">])</span>
<span class="s2">def </span><span class="s1">test_hdbscan_error_precomputed_and_store_centers</span><span class="s3">(</span><span class="s1">store_centers</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Check that we raise an error if the centers are requested together with 
    a precomputed input matrix. 
 
    Non-regression test for: 
    https://github.com/scikit-learn/scikit-learn/issues/27893 
    &quot;&quot;&quot;</span>
    <span class="s1">rng </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">RandomState</span><span class="s3">(</span><span class="s4">0</span><span class="s3">)</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">rng</span><span class="s3">.</span><span class="s1">random</span><span class="s3">((</span><span class="s4">100</span><span class="s3">, </span><span class="s4">2</span><span class="s3">))</span>
    <span class="s1">X_dist </span><span class="s3">= </span><span class="s1">euclidean_distances</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
    <span class="s1">err_msg </span><span class="s3">= </span><span class="s5">&quot;Cannot store centers when using a precomputed distance matrix.&quot;</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s1">err_msg</span><span class="s3">):</span>
        <span class="s1">HDBSCAN</span><span class="s3">(</span><span class="s1">metric</span><span class="s3">=</span><span class="s5">&quot;precomputed&quot;</span><span class="s3">, </span><span class="s1">store_centers</span><span class="s3">=</span><span class="s1">store_centers</span><span class="s3">).</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X_dist</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s5">&quot;valid_algo&quot;</span><span class="s3">, [</span><span class="s5">&quot;auto&quot;</span><span class="s3">, </span><span class="s5">&quot;brute&quot;</span><span class="s3">])</span>
<span class="s2">def </span><span class="s1">test_hdbscan_cosine_metric_valid_algorithm</span><span class="s3">(</span><span class="s1">valid_algo</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Test that HDBSCAN works with the &quot;cosine&quot; metric when the algorithm is set 
    to &quot;brute&quot; or &quot;auto&quot;. 
 
    Non-regression test for issue #28631 
    &quot;&quot;&quot;</span>
    <span class="s1">HDBSCAN</span><span class="s3">(</span><span class="s1">metric</span><span class="s3">=</span><span class="s5">&quot;cosine&quot;</span><span class="s3">, </span><span class="s1">algorithm</span><span class="s3">=</span><span class="s1">valid_algo</span><span class="s3">).</span><span class="s1">fit_predict</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s5">&quot;invalid_algo&quot;</span><span class="s3">, [</span><span class="s5">&quot;kd_tree&quot;</span><span class="s3">, </span><span class="s5">&quot;ball_tree&quot;</span><span class="s3">])</span>
<span class="s2">def </span><span class="s1">test_hdbscan_cosine_metric_invalid_algorithm</span><span class="s3">(</span><span class="s1">invalid_algo</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Test that HDBSCAN raises an informative error is raised when an unsupported 
    algorithm is used with the &quot;cosine&quot; metric. 
    &quot;&quot;&quot;</span>
    <span class="s1">hdbscan </span><span class="s3">= </span><span class="s1">HDBSCAN</span><span class="s3">(</span><span class="s1">metric</span><span class="s3">=</span><span class="s5">&quot;cosine&quot;</span><span class="s3">, </span><span class="s1">algorithm</span><span class="s3">=</span><span class="s1">invalid_algo</span><span class="s3">)</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s5">&quot;cosine is not a valid metric&quot;</span><span class="s3">):</span>
        <span class="s1">hdbscan</span><span class="s3">.</span><span class="s1">fit_predict</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
</pre>
</body>
</html>