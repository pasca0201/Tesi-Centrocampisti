<html>
<head>
<title>_dist_metrics.pyx.tp</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_dist_metrics.pyx.tp</font>
</center></td></tr></table>
<pre><span class="s0">{{py:</span>

<span class="s0">implementation_specific_values = [</span>
    <span class="s0"># Values are the following ones:</span>
    <span class="s0">#</span>
    <span class="s0"># name_suffix, INPUT_DTYPE_t, INPUT_DTYPE</span>
    <span class="s0">('64', 'float64_t', 'np.float64'),</span>
    <span class="s0">('32', 'float32_t', 'np.float32')</span>
<span class="s0">]</span>

<span class="s0">}}</span>
<span class="s0"># By Jake Vanderplas (2013) &lt;jakevdp@cs.washington.edu&gt;</span>
<span class="s0"># written for the scikit-learn project</span>
<span class="s0"># License: BSD</span>

<span class="s0">import numpy as np</span>
<span class="s0">cimport numpy as cnp</span>

<span class="s0">cnp.import_array()  # required in order to use C-API</span>

<span class="s0">from libc.math cimport fabs, sqrt, exp, pow, cos, sin, asin</span>

<span class="s0">from scipy.sparse import csr_matrix, issparse</span>
<span class="s0">from ..utils._typedefs cimport float64_t, float32_t, int32_t, intp_t</span>
<span class="s0">from ..utils import check_array</span>
<span class="s0">from ..utils.fixes import parse_version, sp_base_version</span>

<span class="s0">cdef inline double fmax(double a, double b) noexcept nogil:</span>
    <span class="s0">return max(a, b)</span>


<span class="s0">######################################################################</span>
<span class="s0"># newObj function</span>
<span class="s0">#  this is a helper function for pickling</span>
<span class="s0">def newObj(obj):</span>
    <span class="s0">return obj.__new__(obj)</span>


<span class="s0">BOOL_METRICS = [</span>
    <span class="s0">&quot;hamming&quot;,</span>
    <span class="s0">&quot;jaccard&quot;,</span>
    <span class="s0">&quot;dice&quot;,</span>
    <span class="s0">&quot;rogerstanimoto&quot;,</span>
    <span class="s0">&quot;russellrao&quot;,</span>
    <span class="s0">&quot;sokalmichener&quot;,</span>
    <span class="s0">&quot;sokalsneath&quot;,</span>
<span class="s0">]</span>
<span class="s0">if sp_base_version &lt; parse_version(&quot;1.11&quot;):</span>
    <span class="s0"># Deprecated in SciPy 1.9 and removed in SciPy 1.11</span>
    <span class="s0">BOOL_METRICS += [&quot;kulsinski&quot;]</span>
<span class="s0">if sp_base_version &lt; parse_version(&quot;1.9&quot;):</span>
    <span class="s0"># Deprecated in SciPy 1.0 and removed in SciPy 1.9</span>
    <span class="s0">BOOL_METRICS += [&quot;matching&quot;]</span>

<span class="s0">def get_valid_metric_ids(L):</span>
    <span class="s0">&quot;&quot;&quot;Given an iterable of metric class names or class identifiers,</span>
    <span class="s0">return a list of metric IDs which map to those classes.</span>

    <span class="s0">Example:</span>
    <span class="s0">&gt;&gt;&gt; L = get_valid_metric_ids([EuclideanDistance, 'ManhattanDistance'])</span>
    <span class="s0">&gt;&gt;&gt; sorted(L)</span>
    <span class="s0">['cityblock', 'euclidean', 'l1', 'l2', 'manhattan']</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">return [key for (key, val) in METRIC_MAPPING64.items()</span>
            <span class="s0">if (val.__name__ in L) or (val in L)]</span>

<span class="s0">cdef class DistanceMetric:</span>
    <span class="s0">&quot;&quot;&quot;Uniform interface for fast distance metric functions.</span>

    <span class="s0">The `DistanceMetric` class provides a convenient way to compute pairwise distances</span>
    <span class="s0">between samples. It supports various distance metrics, such as Euclidean distance,</span>
    <span class="s0">Manhattan distance, and more.</span>

    <span class="s0">The `pairwise` method can be used to compute pairwise distances between samples in</span>
    <span class="s0">the input arrays. It returns a distance matrix representing the distances between</span>
    <span class="s0">all pairs of samples.</span>

    <span class="s0">The :meth:`get_metric` method allows you to retrieve a specific metric using its</span>
    <span class="s0">string identifier.</span>

    <span class="s0">Examples</span>
    <span class="s0">--------</span>
    <span class="s0">&gt;&gt;&gt; from sklearn.metrics import DistanceMetric</span>
    <span class="s0">&gt;&gt;&gt; dist = DistanceMetric.get_metric('euclidean')</span>
    <span class="s0">&gt;&gt;&gt; X = [[1, 2], [3, 4], [5, 6]]</span>
    <span class="s0">&gt;&gt;&gt; Y = [[7, 8], [9, 10]]</span>
    <span class="s0">&gt;&gt;&gt; dist.pairwise(X,Y)</span>
    <span class="s0">array([[7.81..., 10.63...]</span>
           <span class="s0">[5.65...,  8.48...]</span>
           <span class="s0">[1.41...,  4.24...]])</span>

    <span class="s0">Available Metrics</span>

    <span class="s0">The following lists the string metric identifiers and the associated</span>
    <span class="s0">distance metric classes:</span>

    <span class="s0">**Metrics intended for real-valued vector spaces:**</span>

    <span class="s0">==============  ====================  ========  ===============================</span>
    <span class="s0">identifier      class name            args      distance function</span>
    <span class="s0">--------------  --------------------  --------  -------------------------------</span>
    <span class="s0">&quot;euclidean&quot;     EuclideanDistance     -         ``sqrt(sum((x - y)^2))``</span>
    <span class="s0">&quot;manhattan&quot;     ManhattanDistance     -         ``sum(|x - y|)``</span>
    <span class="s0">&quot;chebyshev&quot;     ChebyshevDistance     -         ``max(|x - y|)``</span>
    <span class="s0">&quot;minkowski&quot;     MinkowskiDistance     p, w      ``sum(w * |x - y|^p)^(1/p)``</span>
    <span class="s0">&quot;seuclidean&quot;    SEuclideanDistance    V         ``sqrt(sum((x - y)^2 / V))``</span>
    <span class="s0">&quot;mahalanobis&quot;   MahalanobisDistance   V or VI   ``sqrt((x - y)' V^-1 (x - y))``</span>
    <span class="s0">==============  ====================  ========  ===============================</span>

    <span class="s0">**Metrics intended for two-dimensional vector spaces:**  Note that the haversine</span>
    <span class="s0">distance metric requires data in the form of [latitude, longitude] and both</span>
    <span class="s0">inputs and outputs are in units of radians.</span>

    <span class="s0">============  ==================  ===============================================================</span>
    <span class="s0">identifier    class name          distance function</span>
    <span class="s0">------------  ------------------  ---------------------------------------------------------------</span>
    <span class="s0">&quot;haversine&quot;   HaversineDistance   ``2 arcsin(sqrt(sin^2(0.5*dx) + cos(x1)cos(x2)sin^2(0.5*dy)))``</span>
    <span class="s0">============  ==================  ===============================================================</span>


    <span class="s0">**Metrics intended for integer-valued vector spaces:**  Though intended</span>
    <span class="s0">for integer-valued vectors, these are also valid metrics in the case of</span>
    <span class="s0">real-valued vectors.</span>

    <span class="s0">=============  ====================  ========================================</span>
    <span class="s0">identifier     class name            distance function</span>
    <span class="s0">-------------  --------------------  ----------------------------------------</span>
    <span class="s0">&quot;hamming&quot;      HammingDistance       ``N_unequal(x, y) / N_tot``</span>
    <span class="s0">&quot;canberra&quot;     CanberraDistance      ``sum(|x - y| / (|x| + |y|))``</span>
    <span class="s0">&quot;braycurtis&quot;   BrayCurtisDistance    ``sum(|x - y|) / (sum(|x|) + sum(|y|))``</span>
    <span class="s0">=============  ====================  ========================================</span>

    <span class="s0">**Metrics intended for boolean-valued vector spaces:**  Any nonzero entry</span>
    <span class="s0">is evaluated to &quot;True&quot;.  In the listings below, the following</span>
    <span class="s0">abbreviations are used:</span>

     <span class="s0">- N  : number of dimensions</span>
     <span class="s0">- NTT : number of dims in which both values are True</span>
     <span class="s0">- NTF : number of dims in which the first value is True, second is False</span>
     <span class="s0">- NFT : number of dims in which the first value is False, second is True</span>
     <span class="s0">- NFF : number of dims in which both values are False</span>
     <span class="s0">- NNEQ : number of non-equal dimensions, NNEQ = NTF + NFT</span>
     <span class="s0">- NNZ : number of nonzero dimensions, NNZ = NTF + NFT + NTT</span>

    <span class="s0">=================  =======================  ===============================</span>
    <span class="s0">identifier         class name               distance function</span>
    <span class="s0">-----------------  -----------------------  -------------------------------</span>
    <span class="s0">&quot;jaccard&quot;          JaccardDistance          NNEQ / NNZ</span>
    <span class="s0">&quot;matching&quot;         MatchingDistance         NNEQ / N</span>
    <span class="s0">&quot;dice&quot;             DiceDistance             NNEQ / (NTT + NNZ)</span>
    <span class="s0">&quot;kulsinski&quot;        KulsinskiDistance        (NNEQ + N - NTT) / (NNEQ + N)</span>
    <span class="s0">&quot;rogerstanimoto&quot;   RogersTanimotoDistance   2 * NNEQ / (N + NNEQ)</span>
    <span class="s0">&quot;russellrao&quot;       RussellRaoDistance       (N - NTT) / N</span>
    <span class="s0">&quot;sokalmichener&quot;    SokalMichenerDistance    2 * NNEQ / (N + NNEQ)</span>
    <span class="s0">&quot;sokalsneath&quot;      SokalSneathDistance      NNEQ / (NNEQ + 0.5 * NTT)</span>
    <span class="s0">=================  =======================  ===============================</span>

    <span class="s0">**User-defined distance:**</span>

    <span class="s0">===========    ===============    =======</span>
    <span class="s0">identifier     class name         args</span>
    <span class="s0">-----------    ---------------    -------</span>
    <span class="s0">&quot;pyfunc&quot;       PyFuncDistance     func</span>
    <span class="s0">===========    ===============    =======</span>

    <span class="s0">Here ``func`` is a function which takes two one-dimensional numpy</span>
    <span class="s0">arrays, and returns a distance.  Note that in order to be used within</span>
    <span class="s0">the BallTree, the distance must be a true metric:</span>
    <span class="s0">i.e. it must satisfy the following properties</span>

    <span class="s0">1) Non-negativity: d(x, y) &gt;= 0</span>
    <span class="s0">2) Identity: d(x, y) = 0 if and only if x == y</span>
    <span class="s0">3) Symmetry: d(x, y) = d(y, x)</span>
    <span class="s0">4) Triangle Inequality: d(x, y) + d(y, z) &gt;= d(x, z)</span>

    <span class="s0">Because of the Python object overhead involved in calling the python</span>
    <span class="s0">function, this will be fairly slow, but it will have the same</span>
    <span class="s0">scaling as other distances.</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">@classmethod</span>
    <span class="s0">def get_metric(cls, metric, dtype=np.float64, **kwargs):</span>
        <span class="s0">&quot;&quot;&quot;Get the given distance metric from the string identifier.</span>

        <span class="s0">See the docstring of DistanceMetric for a list of available metrics.</span>

        <span class="s0">Parameters</span>
        <span class="s0">----------</span>
        <span class="s0">metric : str or class name</span>
            <span class="s0">The string identifier or class name of the desired distance metric.</span>
            <span class="s0">See the documentation of the `DistanceMetric` class for a list of</span>
            <span class="s0">available metrics.</span>

        <span class="s0">dtype : {np.float32, np.float64}, default=np.float64</span>
            <span class="s0">The data type of the input on which the metric will be applied.</span>
            <span class="s0">This affects the precision of the computed distances.</span>
            <span class="s0">By default, it is set to `np.float64`.</span>

        <span class="s0">**kwargs</span>
            <span class="s0">Additional keyword arguments that will be passed to the requested metric.</span>
            <span class="s0">These arguments can be used to customize the behavior of the specific</span>
            <span class="s0">metric.</span>

        <span class="s0">Returns</span>
        <span class="s0">-------</span>
        <span class="s0">metric_obj : instance of the requested metric</span>
            <span class="s0">An instance of the requested distance metric class.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">if dtype == np.float32:</span>
            <span class="s0">specialized_class = DistanceMetric32</span>
        <span class="s0">elif dtype == np.float64:</span>
            <span class="s0">specialized_class = DistanceMetric64</span>
        <span class="s0">else:</span>
            <span class="s0">raise ValueError(</span>
                <span class="s0">f&quot;Unexpected dtype {dtype} provided. Please select a dtype from&quot;</span>
                <span class="s0">&quot; {np.float32, np.float64}&quot;</span>
            <span class="s0">)</span>

        <span class="s0">return specialized_class.get_metric(metric, **kwargs)</span>

<span class="s0">{{for name_suffix, INPUT_DTYPE_t, INPUT_DTYPE in implementation_specific_values}}</span>

<span class="s0">######################################################################</span>
<span class="s0"># metric mappings</span>
<span class="s0">#  These map from metric id strings to class names</span>
<span class="s0">METRIC_MAPPING{{name_suffix}} = {</span>
    <span class="s0">'euclidean': EuclideanDistance{{name_suffix}},</span>
    <span class="s0">'l2': EuclideanDistance{{name_suffix}},</span>
    <span class="s0">'minkowski': MinkowskiDistance{{name_suffix}},</span>
    <span class="s0">'p': MinkowskiDistance{{name_suffix}},</span>
    <span class="s0">'manhattan': ManhattanDistance{{name_suffix}},</span>
    <span class="s0">'cityblock': ManhattanDistance{{name_suffix}},</span>
    <span class="s0">'l1': ManhattanDistance{{name_suffix}},</span>
    <span class="s0">'chebyshev': ChebyshevDistance{{name_suffix}},</span>
    <span class="s0">'infinity': ChebyshevDistance{{name_suffix}},</span>
    <span class="s0">'seuclidean': SEuclideanDistance{{name_suffix}},</span>
    <span class="s0">'mahalanobis': MahalanobisDistance{{name_suffix}},</span>
    <span class="s0">'hamming': HammingDistance{{name_suffix}},</span>
    <span class="s0">'canberra': CanberraDistance{{name_suffix}},</span>
    <span class="s0">'braycurtis': BrayCurtisDistance{{name_suffix}},</span>
    <span class="s0">'matching': MatchingDistance{{name_suffix}},</span>
    <span class="s0">'jaccard': JaccardDistance{{name_suffix}},</span>
    <span class="s0">'dice': DiceDistance{{name_suffix}},</span>
    <span class="s0">'kulsinski': KulsinskiDistance{{name_suffix}},</span>
    <span class="s0">'rogerstanimoto': RogersTanimotoDistance{{name_suffix}},</span>
    <span class="s0">'russellrao': RussellRaoDistance{{name_suffix}},</span>
    <span class="s0">'sokalmichener': SokalMichenerDistance{{name_suffix}},</span>
    <span class="s0">'sokalsneath': SokalSneathDistance{{name_suffix}},</span>
    <span class="s0">'haversine': HaversineDistance{{name_suffix}},</span>
    <span class="s0">'pyfunc': PyFuncDistance{{name_suffix}},</span>
<span class="s0">}</span>

<span class="s0">cdef inline object _buffer_to_ndarray{{name_suffix}}(const {{INPUT_DTYPE_t}}* x, intp_t n):</span>
    <span class="s0"># Wrap a memory buffer with an ndarray. Warning: this is not robust.</span>
    <span class="s0"># In particular, if x is deallocated before the returned array goes</span>
    <span class="s0"># out of scope, this could cause memory errors.  Since there is not</span>
    <span class="s0"># a possibility of this for our use-case, this should be safe.</span>

    <span class="s0"># Note: this Segfaults unless np.import_array() is called above</span>
    <span class="s0"># TODO: remove the explicit cast to cnp.intp_t* when cython min version &gt;= 3.0</span>
    <span class="s0">return cnp.PyArray_SimpleNewFromData(1, &lt;cnp.intp_t*&gt;&amp;n, cnp.NPY_FLOAT64, &lt;void*&gt;x)</span>


<span class="s0">cdef {{INPUT_DTYPE_t}} INF{{name_suffix}} = np.inf</span>


<span class="s0">######################################################################</span>
<span class="s0"># Distance Metric Classes</span>
<span class="s0">cdef class DistanceMetric{{name_suffix}}(DistanceMetric):</span>
    <span class="s0">&quot;&quot;&quot;DistanceMetric class</span>

    <span class="s0">This class provides a uniform interface to fast distance metric</span>
    <span class="s0">functions.  The various metrics can be accessed via the :meth:`get_metric`</span>
    <span class="s0">class method and the metric string identifier (see below).</span>

    <span class="s0">Examples</span>
    <span class="s0">--------</span>
    <span class="s0">&gt;&gt;&gt; from sklearn.metrics import DistanceMetric</span>
    <span class="s0">&gt;&gt;&gt; dist = DistanceMetric.get_metric('euclidean')</span>
    <span class="s0">&gt;&gt;&gt; X = [[0, 1, 2],</span>
             <span class="s0">[3, 4, 5]]</span>
    <span class="s0">&gt;&gt;&gt; dist.pairwise(X)</span>
    <span class="s0">array([[ 0.        ,  5.19615242],</span>
           <span class="s0">[ 5.19615242,  0.        ]])</span>

    <span class="s0">Available Metrics</span>

    <span class="s0">The following lists the string metric identifiers and the associated</span>
    <span class="s0">distance metric classes:</span>

    <span class="s0">**Metrics intended for real-valued vector spaces:**</span>

    <span class="s0">==============  ====================  ========  ===============================</span>
    <span class="s0">identifier      class name            args      distance function</span>
    <span class="s0">--------------  --------------------  --------  -------------------------------</span>
    <span class="s0">&quot;euclidean&quot;     EuclideanDistance     -         ``sqrt(sum((x - y)^2))``</span>
    <span class="s0">&quot;manhattan&quot;     ManhattanDistance     -         ``sum(|x - y|)``</span>
    <span class="s0">&quot;chebyshev&quot;     ChebyshevDistance     -         ``max(|x - y|)``</span>
    <span class="s0">&quot;minkowski&quot;     MinkowskiDistance     p, w      ``sum(w * |x - y|^p)^(1/p)``</span>
    <span class="s0">&quot;seuclidean&quot;    SEuclideanDistance    V         ``sqrt(sum((x - y)^2 / V))``</span>
    <span class="s0">&quot;mahalanobis&quot;   MahalanobisDistance   V or VI   ``sqrt((x - y)' V^-1 (x - y))``</span>
    <span class="s0">==============  ====================  ========  ===============================</span>

    <span class="s0">**Metrics intended for two-dimensional vector spaces:**  Note that the haversine</span>
    <span class="s0">distance metric requires data in the form of [latitude, longitude] and both</span>
    <span class="s0">inputs and outputs are in units of radians.</span>

    <span class="s0">============  ==================  ===============================================================</span>
    <span class="s0">identifier    class name          distance function</span>
    <span class="s0">------------  ------------------  ---------------------------------------------------------------</span>
    <span class="s0">&quot;haversine&quot;   HaversineDistance   ``2 arcsin(sqrt(sin^2(0.5*dx) + cos(x1)cos(x2)sin^2(0.5*dy)))``</span>
    <span class="s0">============  ==================  ===============================================================</span>


    <span class="s0">**Metrics intended for integer-valued vector spaces:**  Though intended</span>
    <span class="s0">for integer-valued vectors, these are also valid metrics in the case of</span>
    <span class="s0">real-valued vectors.</span>

    <span class="s0">=============  ====================  ========================================</span>
    <span class="s0">identifier     class name            distance function</span>
    <span class="s0">-------------  --------------------  ----------------------------------------</span>
    <span class="s0">&quot;hamming&quot;      HammingDistance       ``N_unequal(x, y) / N_tot``</span>
    <span class="s0">&quot;canberra&quot;     CanberraDistance      ``sum(|x - y| / (|x| + |y|))``</span>
    <span class="s0">&quot;braycurtis&quot;   BrayCurtisDistance    ``sum(|x - y|) / (sum(|x|) + sum(|y|))``</span>
    <span class="s0">=============  ====================  ========================================</span>

    <span class="s0">**Metrics intended for boolean-valued vector spaces:**  Any nonzero entry</span>
    <span class="s0">is evaluated to &quot;True&quot;.  In the listings below, the following</span>
    <span class="s0">abbreviations are used:</span>

     <span class="s0">- N  : number of dimensions</span>
     <span class="s0">- NTT : number of dims in which both values are True</span>
     <span class="s0">- NTF : number of dims in which the first value is True, second is False</span>
     <span class="s0">- NFT : number of dims in which the first value is False, second is True</span>
     <span class="s0">- NFF : number of dims in which both values are False</span>
     <span class="s0">- NNEQ : number of non-equal dimensions, NNEQ = NTF + NFT</span>
     <span class="s0">- NNZ : number of nonzero dimensions, NNZ = NTF + NFT + NTT</span>

    <span class="s0">=================  =======================  ===============================</span>
    <span class="s0">identifier         class name               distance function</span>
    <span class="s0">-----------------  -----------------------  -------------------------------</span>
    <span class="s0">&quot;jaccard&quot;          JaccardDistance          NNEQ / NNZ</span>
    <span class="s0">&quot;matching&quot;         MatchingDistance         NNEQ / N</span>
    <span class="s0">&quot;dice&quot;             DiceDistance             NNEQ / (NTT + NNZ)</span>
    <span class="s0">&quot;kulsinski&quot;        KulsinskiDistance        (NNEQ + N - NTT) / (NNEQ + N)</span>
    <span class="s0">&quot;rogerstanimoto&quot;   RogersTanimotoDistance   2 * NNEQ / (N + NNEQ)</span>
    <span class="s0">&quot;russellrao&quot;       RussellRaoDistance       (N - NTT) / N</span>
    <span class="s0">&quot;sokalmichener&quot;    SokalMichenerDistance    2 * NNEQ / (N + NNEQ)</span>
    <span class="s0">&quot;sokalsneath&quot;      SokalSneathDistance      NNEQ / (NNEQ + 0.5 * NTT)</span>
    <span class="s0">=================  =======================  ===============================</span>

    <span class="s0">**User-defined distance:**</span>

    <span class="s0">===========    ===============    =======</span>
    <span class="s0">identifier     class name         args</span>
    <span class="s0">-----------    ---------------    -------</span>
    <span class="s0">&quot;pyfunc&quot;       PyFuncDistance     func</span>
    <span class="s0">===========    ===============    =======</span>

    <span class="s0">Here ``func`` is a function which takes two one-dimensional numpy</span>
    <span class="s0">arrays, and returns a distance.  Note that in order to be used within</span>
    <span class="s0">the BallTree, the distance must be a true metric:</span>
    <span class="s0">i.e. it must satisfy the following properties</span>

    <span class="s0">1) Non-negativity: d(x, y) &gt;= 0</span>
    <span class="s0">2) Identity: d(x, y) = 0 if and only if x == y</span>
    <span class="s0">3) Symmetry: d(x, y) = d(y, x)</span>
    <span class="s0">4) Triangle Inequality: d(x, y) + d(y, z) &gt;= d(x, z)</span>

    <span class="s0">Because of the Python object overhead involved in calling the python</span>
    <span class="s0">function, this will be fairly slow, but it will have the same</span>
    <span class="s0">scaling as other distances.</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">def __cinit__(self):</span>
        <span class="s0">self.p = 2</span>
        <span class="s0">self.vec = np.zeros(1, dtype=np.float64, order='C')</span>
        <span class="s0">self.mat = np.zeros((1, 1), dtype=np.float64, order='C')</span>
        <span class="s0">self.size = 1</span>

    <span class="s0">def __reduce__(self):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">reduce method used for pickling</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">return (newObj, (self.__class__,), self.__getstate__())</span>

    <span class="s0">def __getstate__(self):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">get state for pickling</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">if self.__class__.__name__ == &quot;PyFuncDistance{{name_suffix}}&quot;:</span>
            <span class="s0">return (float(self.p), np.asarray(self.vec), np.asarray(self.mat), self.func, self.kwargs)</span>
        <span class="s0">return (float(self.p), np.asarray(self.vec), np.asarray(self.mat))</span>

    <span class="s0">def __setstate__(self, state):</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">set state for pickling</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">self.p = state[0]</span>
        <span class="s0">self.vec = state[1]</span>
        <span class="s0">self.mat = state[2]</span>
        <span class="s0">if self.__class__.__name__ == &quot;PyFuncDistance{{name_suffix}}&quot;:</span>
            <span class="s0">self.func = state[3]</span>
            <span class="s0">self.kwargs = state[4]</span>
        <span class="s0">self.size = self.vec.shape[0]</span>

    <span class="s0">@classmethod</span>
    <span class="s0">def get_metric(cls, metric, **kwargs):</span>
        <span class="s0">&quot;&quot;&quot;Get the given distance metric from the string identifier.</span>

        <span class="s0">See the docstring of DistanceMetric for a list of available metrics.</span>

        <span class="s0">Parameters</span>
        <span class="s0">----------</span>
        <span class="s0">metric : str or class name</span>
            <span class="s0">The distance metric to use</span>
        <span class="s0">**kwargs</span>
            <span class="s0">additional arguments will be passed to the requested metric</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">if isinstance(metric, DistanceMetric{{name_suffix}}):</span>
            <span class="s0">return metric</span>

        <span class="s0">if callable(metric):</span>
            <span class="s0">return PyFuncDistance{{name_suffix}}(metric, **kwargs)</span>

        <span class="s0"># Map the metric string ID to the metric class</span>
        <span class="s0">if isinstance(metric, type) and issubclass(metric, DistanceMetric{{name_suffix}}):</span>
            <span class="s0">pass</span>
        <span class="s0">else:</span>
            <span class="s0">try:</span>
                <span class="s0">metric = METRIC_MAPPING{{name_suffix}}[metric]</span>
            <span class="s0">except:</span>
                <span class="s0">raise ValueError(&quot;Unrecognized metric '%s'&quot; % metric)</span>

        <span class="s0"># In Minkowski special cases, return more efficient methods</span>
        <span class="s0">if metric is MinkowskiDistance{{name_suffix}}:</span>
            <span class="s0">p = kwargs.pop('p', 2)</span>
            <span class="s0">w = kwargs.pop('w', None)</span>
            <span class="s0">if p == 1 and w is None:</span>
                <span class="s0">return ManhattanDistance{{name_suffix}}(**kwargs)</span>
            <span class="s0">elif p == 2 and w is None:</span>
                <span class="s0">return EuclideanDistance{{name_suffix}}(**kwargs)</span>
            <span class="s0">elif np.isinf(p) and w is None:</span>
                <span class="s0">return ChebyshevDistance{{name_suffix}}(**kwargs)</span>
            <span class="s0">else:</span>
                <span class="s0">return MinkowskiDistance{{name_suffix}}(p, w, **kwargs)</span>
        <span class="s0">else:</span>
            <span class="s0">return metric(**kwargs)</span>

    <span class="s0">def __init__(self):</span>
        <span class="s0">if self.__class__ is DistanceMetric{{name_suffix}}:</span>
            <span class="s0">raise NotImplementedError(&quot;DistanceMetric{{name_suffix}} is an abstract class&quot;)</span>

    <span class="s0">def _validate_data(self, X):</span>
        <span class="s0">&quot;&quot;&quot;Validate the input data.</span>

        <span class="s0">This should be overridden in a base class if a specific input format</span>
        <span class="s0">is required.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">return</span>

    <span class="s0">cdef {{INPUT_DTYPE_t}} dist(</span>
        <span class="s0">self,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x1,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x2,</span>
        <span class="s0">intp_t size,</span>
    <span class="s0">) except -1 nogil:</span>
        <span class="s0">&quot;&quot;&quot;Compute the distance between vectors x1 and x2</span>

        <span class="s0">This should be overridden in a base class.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">return -999</span>

    <span class="s0">cdef {{INPUT_DTYPE_t}} rdist(</span>
        <span class="s0">self,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x1,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x2,</span>
        <span class="s0">intp_t size,</span>
    <span class="s0">) except -1 nogil:</span>
        <span class="s0">&quot;&quot;&quot;Compute the rank-preserving surrogate distance between vectors x1 and x2.</span>

        <span class="s0">This can optionally be overridden in a base class.</span>

        <span class="s0">The rank-preserving surrogate distance is any measure that yields the same</span>
        <span class="s0">rank as the distance, but is more efficient to compute. For example, the</span>
        <span class="s0">rank-preserving surrogate distance of the Euclidean metric is the</span>
        <span class="s0">squared-euclidean distance.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">return self.dist(x1, x2, size)</span>

    <span class="s0">cdef int pdist(</span>
        <span class="s0">self,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}[:, ::1] X,</span>
        <span class="s0">{{INPUT_DTYPE_t}}[:, ::1] D,</span>
    <span class="s0">) except -1:</span>
        <span class="s0">&quot;&quot;&quot;Compute the pairwise distances between points in X&quot;&quot;&quot;</span>
        <span class="s0">cdef intp_t i1, i2</span>
        <span class="s0">for i1 in range(X.shape[0]):</span>
            <span class="s0">for i2 in range(i1, X.shape[0]):</span>
                <span class="s0">D[i1, i2] = self.dist(&amp;X[i1, 0], &amp;X[i2, 0], X.shape[1])</span>
                <span class="s0">D[i2, i1] = D[i1, i2]</span>
        <span class="s0">return 0</span>


    <span class="s0">cdef int cdist(</span>
        <span class="s0">self,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}[:, ::1] X,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}[:, ::1] Y,</span>
        <span class="s0">{{INPUT_DTYPE_t}}[:, ::1] D,</span>
    <span class="s0">) except -1:</span>
        <span class="s0">&quot;&quot;&quot;Compute the cross-pairwise distances between arrays X and Y&quot;&quot;&quot;</span>
        <span class="s0">cdef intp_t i1, i2</span>
        <span class="s0">if X.shape[1] != Y.shape[1]:</span>
            <span class="s0">raise ValueError('X and Y must have the same second dimension')</span>
        <span class="s0">for i1 in range(X.shape[0]):</span>
            <span class="s0">for i2 in range(Y.shape[0]):</span>
                <span class="s0">D[i1, i2] = self.dist(&amp;X[i1, 0], &amp;Y[i2, 0], X.shape[1])</span>
        <span class="s0">return 0</span>

    <span class="s0">cdef {{INPUT_DTYPE_t}} dist_csr(</span>
        <span class="s0">self,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x1_data,</span>
        <span class="s0">const int32_t* x1_indices,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x2_data,</span>
        <span class="s0">const int32_t* x2_indices,</span>
        <span class="s0">const int32_t x1_start,</span>
        <span class="s0">const int32_t x1_end,</span>
        <span class="s0">const int32_t x2_start,</span>
        <span class="s0">const int32_t x2_end,</span>
        <span class="s0">const intp_t size,</span>
    <span class="s0">) except -1 nogil:</span>
        <span class="s0">&quot;&quot;&quot;Compute the distance between vectors x1 and x2 represented</span>
        <span class="s0">under the CSR format.</span>

        <span class="s0">This must be overridden in a subclass.</span>

        <span class="s0">Notes</span>
        <span class="s0">-----</span>
        <span class="s0">0. The implementation of this method in subclasses must be robust to the</span>
        <span class="s0">presence of explicit zeros in the CSR representation.</span>

        <span class="s0">1. The `data` arrays are passed using pointers to be able to support an</span>
        <span class="s0">alternative representation of the CSR data structure for supporting</span>
        <span class="s0">fused sparse-dense datasets pairs with minimum overhead.</span>

        <span class="s0">See the explanations in `SparseDenseDatasetsPair.__init__`.</span>

        <span class="s0">2. An alternative signature would be:</span>

            <span class="s0">cdef {{INPUT_DTYPE_t}} dist_csr(</span>
                <span class="s0">self,</span>
                <span class="s0">const {{INPUT_DTYPE_t}}* x1_data,</span>
                <span class="s0">const int32_t* x1_indices,</span>
                <span class="s0">const {{INPUT_DTYPE_t}}* x2_data,</span>
                <span class="s0">const int32_t* x2_indices,</span>
            <span class="s0">) except -1 nogil:</span>

        <span class="s0">Where callers would use slicing on the original CSR data and indices</span>
        <span class="s0">memoryviews:</span>

            <span class="s0">x1_start = X1_csr.indices_ptr[i]</span>
            <span class="s0">x1_end   = X1_csr.indices_ptr[i+1]</span>
            <span class="s0">x2_start = X2_csr.indices_ptr[j]</span>
            <span class="s0">x2_end   = X2_csr.indices_ptr[j+1]</span>

            <span class="s0">self.dist_csr(</span>
                <span class="s0">&amp;x1_data[x1_start],</span>
                <span class="s0">x1_indices[x1_start:x1_end],</span>
                <span class="s0">&amp;x2_data[x2_start],</span>
                <span class="s0">x2_indices[x2_start:x2_end],</span>
            <span class="s0">)</span>

        <span class="s0">Yet, slicing on memoryview slows down execution as it takes the GIL.</span>
        <span class="s0">See: https://github.com/scikit-learn/scikit-learn/issues/17299</span>

        <span class="s0">Hence, to avoid slicing the data and indices arrays of the sparse</span>
        <span class="s0">matrices containing respectively x1 and x2 (namely x{1,2}_{data,indices})</span>
        <span class="s0">are passed as well as their indices pointers (namely x{1,2}_{start,end}).</span>

        <span class="s0">3. For reference about the CSR format, see section 3.4 of</span>
        <span class="s0">Saad, Y. (2003), Iterative Methods for Sparse Linear Systems, SIAM.</span>
        <span class="s0">https://www-users.cse.umn.edu/~saad/IterMethBook_2ndEd.pdf</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">return -999</span>

    <span class="s0">cdef {{INPUT_DTYPE_t}} rdist_csr(</span>
        <span class="s0">self,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x1_data,</span>
        <span class="s0">const int32_t* x1_indices,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x2_data,</span>
        <span class="s0">const int32_t* x2_indices,</span>
        <span class="s0">const int32_t x1_start,</span>
        <span class="s0">const int32_t x1_end,</span>
        <span class="s0">const int32_t x2_start,</span>
        <span class="s0">const int32_t x2_end,</span>
        <span class="s0">const intp_t size,</span>
    <span class="s0">) except -1 nogil:</span>
        <span class="s0">&quot;&quot;&quot;Distance between rows of CSR matrices x1 and x2.</span>

        <span class="s0">This can optionally be overridden in a subclass.</span>

        <span class="s0">The rank-preserving surrogate distance is any measure that yields the same</span>
        <span class="s0">rank as the distance, but is more efficient to compute. For example, the</span>
        <span class="s0">rank-preserving surrogate distance of the Euclidean metric is the</span>
        <span class="s0">squared-euclidean distance.</span>

        <span class="s0">Notes</span>
        <span class="s0">-----</span>
        <span class="s0">The implementation of this method in subclasses must be robust to the</span>
        <span class="s0">presence of explicit zeros in the CSR representation.</span>

        <span class="s0">More information about the motives for this method signature is given</span>
        <span class="s0">in the docstring of dist_csr.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">return self.dist_csr(</span>
            <span class="s0">x1_data,</span>
            <span class="s0">x1_indices,</span>
            <span class="s0">x2_data,</span>
            <span class="s0">x2_indices,</span>
            <span class="s0">x1_start,</span>
            <span class="s0">x1_end,</span>
            <span class="s0">x2_start,</span>
            <span class="s0">x2_end,</span>
            <span class="s0">size,</span>
        <span class="s0">)</span>

    <span class="s0">cdef int pdist_csr(</span>
        <span class="s0">self,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x1_data,</span>
        <span class="s0">const int32_t[::1] x1_indices,</span>
        <span class="s0">const int32_t[::1] x1_indptr,</span>
        <span class="s0">const intp_t size,</span>
        <span class="s0">{{INPUT_DTYPE_t}}[:, ::1] D,</span>
    <span class="s0">) except -1 nogil:</span>
        <span class="s0">&quot;&quot;&quot;Pairwise distances between rows in CSR matrix X.</span>

        <span class="s0">Note that this implementation is twice faster than cdist_csr(X, X)</span>
        <span class="s0">because it leverages the symmetry of the problem.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">cdef:</span>
            <span class="s0">intp_t i1, i2</span>
            <span class="s0">intp_t n_x1 = x1_indptr.shape[0] - 1</span>
            <span class="s0">intp_t x1_start, x1_end, x2_start, x2_end</span>

        <span class="s0">for i1 in range(n_x1):</span>
            <span class="s0">x1_start = x1_indptr[i1]</span>
            <span class="s0">x1_end = x1_indptr[i1 + 1]</span>
            <span class="s0">for i2 in range(i1, n_x1):</span>
                <span class="s0">x2_start = x1_indptr[i2]</span>
                <span class="s0">x2_end = x1_indptr[i2 + 1]</span>
                <span class="s0">D[i1, i2] = D[i2, i1] = self.dist_csr(</span>
                    <span class="s0">x1_data,</span>
                    <span class="s0">&amp;x1_indices[0],</span>
                    <span class="s0">x1_data,</span>
                    <span class="s0">&amp;x1_indices[0],</span>
                    <span class="s0">x1_start,</span>
                    <span class="s0">x1_end,</span>
                    <span class="s0">x2_start,</span>
                    <span class="s0">x2_end,</span>
                    <span class="s0">size,</span>
                <span class="s0">)</span>
        <span class="s0">return 0</span>

    <span class="s0">cdef int cdist_csr(</span>
        <span class="s0">self,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x1_data,</span>
        <span class="s0">const int32_t[::1] x1_indices,</span>
        <span class="s0">const int32_t[::1] x1_indptr,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x2_data,</span>
        <span class="s0">const int32_t[::1] x2_indices,</span>
        <span class="s0">const int32_t[::1] x2_indptr,</span>
        <span class="s0">const intp_t size,</span>
        <span class="s0">{{INPUT_DTYPE_t}}[:, ::1] D,</span>
    <span class="s0">) except -1 nogil:</span>
        <span class="s0">&quot;&quot;&quot;Compute the cross-pairwise distances between arrays X and Y</span>
        <span class="s0">represented in the CSR format.&quot;&quot;&quot;</span>
        <span class="s0">cdef:</span>
            <span class="s0">intp_t i1, i2</span>
            <span class="s0">intp_t n_x1 = x1_indptr.shape[0] - 1</span>
            <span class="s0">intp_t n_x2 = x2_indptr.shape[0] - 1</span>
            <span class="s0">intp_t x1_start, x1_end, x2_start, x2_end</span>

        <span class="s0">for i1 in range(n_x1):</span>
            <span class="s0">x1_start = x1_indptr[i1]</span>
            <span class="s0">x1_end = x1_indptr[i1 + 1]</span>
            <span class="s0">for i2 in range(n_x2):</span>
                <span class="s0">x2_start = x2_indptr[i2]</span>
                <span class="s0">x2_end = x2_indptr[i2 + 1]</span>

                <span class="s0">D[i1, i2] = self.dist_csr(</span>
                    <span class="s0">x1_data,</span>
                    <span class="s0">&amp;x1_indices[0],</span>
                    <span class="s0">x2_data,</span>
                    <span class="s0">&amp;x2_indices[0],</span>
                    <span class="s0">x1_start,</span>
                    <span class="s0">x1_end,</span>
                    <span class="s0">x2_start,</span>
                    <span class="s0">x2_end,</span>
                    <span class="s0">size,</span>
                <span class="s0">)</span>
        <span class="s0">return 0</span>

    <span class="s0">cdef {{INPUT_DTYPE_t}} _rdist_to_dist(self, {{INPUT_DTYPE_t}} rdist) except -1 nogil:</span>
        <span class="s0">&quot;&quot;&quot;Convert the rank-preserving surrogate distance to the distance&quot;&quot;&quot;</span>
        <span class="s0">return rdist</span>

    <span class="s0">cdef {{INPUT_DTYPE_t}} _dist_to_rdist(self, {{INPUT_DTYPE_t}} dist) except -1 nogil:</span>
        <span class="s0">&quot;&quot;&quot;Convert the distance to the rank-preserving surrogate distance&quot;&quot;&quot;</span>
        <span class="s0">return dist</span>

    <span class="s0">def rdist_to_dist(self, rdist):</span>
        <span class="s0">&quot;&quot;&quot;Convert the rank-preserving surrogate distance to the distance.</span>

        <span class="s0">The surrogate distance is any measure that yields the same rank as the</span>
        <span class="s0">distance, but is more efficient to compute. For example, the</span>
        <span class="s0">rank-preserving surrogate distance of the Euclidean metric is the</span>
        <span class="s0">squared-euclidean distance.</span>

        <span class="s0">Parameters</span>
        <span class="s0">----------</span>
        <span class="s0">rdist : double</span>
            <span class="s0">Surrogate distance.</span>

        <span class="s0">Returns</span>
        <span class="s0">-------</span>
        <span class="s0">double</span>
            <span class="s0">True distance.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">return rdist</span>

    <span class="s0">def dist_to_rdist(self, dist):</span>
        <span class="s0">&quot;&quot;&quot;Convert the true distance to the rank-preserving surrogate distance.</span>

        <span class="s0">The surrogate distance is any measure that yields the same rank as the</span>
        <span class="s0">distance, but is more efficient to compute. For example, the</span>
        <span class="s0">rank-preserving surrogate distance of the Euclidean metric is the</span>
        <span class="s0">squared-euclidean distance.</span>

        <span class="s0">Parameters</span>
        <span class="s0">----------</span>
        <span class="s0">dist : double</span>
            <span class="s0">True distance.</span>

        <span class="s0">Returns</span>
        <span class="s0">-------</span>
        <span class="s0">double</span>
            <span class="s0">Surrogate distance.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">return dist</span>

    <span class="s0">def _pairwise_dense_dense(self, X, Y):</span>
        <span class="s0">cdef const {{INPUT_DTYPE_t}}[:, ::1] Xarr</span>
        <span class="s0">cdef const {{INPUT_DTYPE_t}}[:, ::1] Yarr</span>
        <span class="s0">cdef {{INPUT_DTYPE_t}}[:, ::1] Darr</span>

        <span class="s0">Xarr = np.asarray(X, dtype={{INPUT_DTYPE}}, order='C')</span>
        <span class="s0">self._validate_data(Xarr)</span>
        <span class="s0">if X is Y:</span>
            <span class="s0">Darr = np.empty((Xarr.shape[0], Xarr.shape[0]), dtype={{INPUT_DTYPE}}, order='C')</span>
            <span class="s0">self.pdist(Xarr, Darr)</span>
        <span class="s0">else:</span>
            <span class="s0">Yarr = np.asarray(Y, dtype={{INPUT_DTYPE}}, order='C')</span>
            <span class="s0">self._validate_data(Yarr)</span>
            <span class="s0">Darr = np.empty((Xarr.shape[0], Yarr.shape[0]), dtype={{INPUT_DTYPE}}, order='C')</span>
            <span class="s0">self.cdist(Xarr, Yarr, Darr)</span>
        <span class="s0">return np.asarray(Darr)</span>

    <span class="s0">def _pairwise_sparse_sparse(self, X: csr_matrix , Y: csr_matrix):</span>
        <span class="s0">cdef:</span>
            <span class="s0">intp_t n_X, n_features</span>
            <span class="s0">const {{INPUT_DTYPE_t}}[::1] X_data</span>
            <span class="s0">const int32_t[::1] X_indices</span>
            <span class="s0">const int32_t[::1] X_indptr</span>

            <span class="s0">intp_t n_Y</span>
            <span class="s0">const {{INPUT_DTYPE_t}}[::1] Y_data</span>
            <span class="s0">const int32_t[::1] Y_indices</span>
            <span class="s0">const int32_t[::1] Y_indptr</span>

            <span class="s0">{{INPUT_DTYPE_t}}[:, ::1] Darr</span>

        <span class="s0">X_csr = X.tocsr()</span>
        <span class="s0">n_X, n_features = X_csr.shape</span>
        <span class="s0">X_data = np.asarray(X_csr.data, dtype={{INPUT_DTYPE}})</span>
        <span class="s0">X_indices = np.asarray(X_csr.indices, dtype=np.int32)</span>
        <span class="s0">X_indptr = np.asarray(X_csr.indptr, dtype=np.int32)</span>
        <span class="s0">if X is Y:</span>
            <span class="s0">Darr = np.empty((n_X, n_X), dtype={{INPUT_DTYPE}}, order='C')</span>
            <span class="s0">self.pdist_csr(</span>
                <span class="s0">x1_data=&amp;X_data[0],</span>
                <span class="s0">x1_indices=X_indices,</span>
                <span class="s0">x1_indptr=X_indptr,</span>
                <span class="s0">size=n_features,</span>
                <span class="s0">D=Darr,</span>
            <span class="s0">)</span>
        <span class="s0">else:</span>
            <span class="s0">Y_csr = Y.tocsr()</span>
            <span class="s0">n_Y, _ = Y_csr.shape</span>
            <span class="s0">Y_data = np.asarray(Y_csr.data, dtype={{INPUT_DTYPE}})</span>
            <span class="s0">Y_indices = np.asarray(Y_csr.indices, dtype=np.int32)</span>
            <span class="s0">Y_indptr = np.asarray(Y_csr.indptr, dtype=np.int32)</span>

            <span class="s0">Darr = np.empty((n_X, n_Y), dtype={{INPUT_DTYPE}}, order='C')</span>
            <span class="s0">self.cdist_csr(</span>
                <span class="s0">x1_data=&amp;X_data[0],</span>
                <span class="s0">x1_indices=X_indices,</span>
                <span class="s0">x1_indptr=X_indptr,</span>
                <span class="s0">x2_data=&amp;Y_data[0],</span>
                <span class="s0">x2_indices=Y_indices,</span>
                <span class="s0">x2_indptr=Y_indptr,</span>
                <span class="s0">size=n_features,</span>
                <span class="s0">D=Darr,</span>
            <span class="s0">)</span>
        <span class="s0">return np.asarray(Darr)</span>

    <span class="s0">def _pairwise_sparse_dense(self, X: csr_matrix, Y):</span>
        <span class="s0">cdef:</span>
            <span class="s0">intp_t n_X = X.shape[0]</span>
            <span class="s0">intp_t n_features = X.shape[1]</span>
            <span class="s0">const {{INPUT_DTYPE_t}}[::1] X_data = np.asarray(</span>
                <span class="s0">X.data, dtype={{INPUT_DTYPE}},</span>
            <span class="s0">)</span>
            <span class="s0">const int32_t[::1] X_indices = np.asarray(</span>
                <span class="s0">X.indices, dtype=np.int32,</span>
            <span class="s0">)</span>
            <span class="s0">const int32_t[::1] X_indptr = np.asarray(</span>
                <span class="s0">X.indptr, dtype=np.int32,</span>
            <span class="s0">)</span>

            <span class="s0">const {{INPUT_DTYPE_t}}[:, ::1] Y_data = np.asarray(</span>
                <span class="s0">Y, dtype={{INPUT_DTYPE}}, order=&quot;C&quot;,</span>
            <span class="s0">)</span>
            <span class="s0">intp_t n_Y = Y_data.shape[0]</span>
            <span class="s0">const int32_t[::1] Y_indices = (</span>
                <span class="s0">np.arange(n_features, dtype=np.int32)</span>
            <span class="s0">)</span>

            <span class="s0">{{INPUT_DTYPE_t}}[:, ::1] Darr = np.empty((n_X, n_Y), dtype={{INPUT_DTYPE}}, order='C')</span>

            <span class="s0">intp_t i1, i2</span>
            <span class="s0">intp_t x1_start, x1_end</span>
            <span class="s0">{{INPUT_DTYPE_t}} * x2_data</span>

        <span class="s0">with nogil:</span>
            <span class="s0"># Use the exact same adaptation for CSR than in SparseDenseDatasetsPair</span>
            <span class="s0"># for supporting the sparse-dense case with minimal overhead.</span>
            <span class="s0"># Note: at this point this method is only a convenience method</span>
            <span class="s0"># used in the tests via the DistanceMetric.pairwise method.</span>
            <span class="s0"># Therefore, there is no need to attempt parallelization of those</span>
            <span class="s0"># nested for-loops.</span>
            <span class="s0"># Efficient parallel computation of pairwise distances can be</span>
            <span class="s0"># achieved via the PairwiseDistances class instead. The latter</span>
            <span class="s0"># internally calls into vector-wise distance computation from</span>
            <span class="s0"># the DistanceMetric subclass while benefiting from the generic</span>
            <span class="s0"># Cython/OpenMP parallelization template for the generic pairwise</span>
            <span class="s0"># distance + reduction computational pattern.</span>
            <span class="s0">for i1 in range(n_X):</span>
                <span class="s0">x1_start = X_indptr[i1]</span>
                <span class="s0">x1_end = X_indptr[i1 + 1]</span>
                <span class="s0">for i2 in range(n_Y):</span>
                    <span class="s0">x2_data = &amp;Y_data[0, 0] + i2 * n_features</span>

                    <span class="s0">Darr[i1, i2] = self.dist_csr(</span>
                        <span class="s0">x1_data=&amp;X_data[0],</span>
                        <span class="s0">x1_indices=&amp;X_indices[0],</span>
                        <span class="s0">x2_data=x2_data,</span>
                        <span class="s0">x2_indices=&amp;Y_indices[0],</span>
                        <span class="s0">x1_start=x1_start,</span>
                        <span class="s0">x1_end=x1_end,</span>
                        <span class="s0">x2_start=0,</span>
                        <span class="s0">x2_end=n_features,</span>
                        <span class="s0">size=n_features,</span>
                    <span class="s0">)</span>

        <span class="s0">return np.asarray(Darr)</span>

    <span class="s0">def _pairwise_dense_sparse(self, X, Y: csr_matrix):</span>
        <span class="s0"># We could have implemented this method using _pairwise_dense_sparse by</span>
        <span class="s0"># swapping argument and by transposing the results, but this would</span>
        <span class="s0"># have come with an extra copy to ensure C-contiguity of the result.</span>
        <span class="s0">cdef:</span>
            <span class="s0">intp_t n_X = X.shape[0]</span>
            <span class="s0">intp_t n_features = X.shape[1]</span>

            <span class="s0">const {{INPUT_DTYPE_t}}[:, ::1] X_data = np.asarray(</span>
                <span class="s0">X, dtype={{INPUT_DTYPE}}, order=&quot;C&quot;,</span>
            <span class="s0">)</span>
            <span class="s0">const int32_t[::1] X_indices = np.arange(</span>
                <span class="s0">n_features, dtype=np.int32,</span>
            <span class="s0">)</span>

            <span class="s0">intp_t n_Y = Y.shape[0]</span>
            <span class="s0">const {{INPUT_DTYPE_t}}[::1] Y_data = np.asarray(</span>
                <span class="s0">Y.data, dtype={{INPUT_DTYPE}},</span>
            <span class="s0">)</span>
            <span class="s0">const int32_t[::1] Y_indices = np.asarray(</span>
                <span class="s0">Y.indices, dtype=np.int32,</span>
            <span class="s0">)</span>
            <span class="s0">const int32_t[::1] Y_indptr = np.asarray(</span>
                <span class="s0">Y.indptr, dtype=np.int32,</span>
            <span class="s0">)</span>

            <span class="s0">{{INPUT_DTYPE_t}}[:, ::1] Darr = np.empty((n_X, n_Y), dtype={{INPUT_DTYPE}}, order='C')</span>

            <span class="s0">intp_t i1, i2</span>
            <span class="s0">{{INPUT_DTYPE_t}} * x1_data</span>

            <span class="s0">intp_t x2_start, x2_end</span>

        <span class="s0">with nogil:</span>
            <span class="s0"># Use the exact same adaptation for CSR than in SparseDenseDatasetsPair</span>
            <span class="s0"># for supporting the dense-sparse case with minimal overhead.</span>
            <span class="s0"># Note: at this point this method is only a convenience method</span>
            <span class="s0"># used in the tests via the DistanceMetric.pairwise method.</span>
            <span class="s0"># Therefore, there is no need to attempt parallelization of those</span>
            <span class="s0"># nested for-loops.</span>
            <span class="s0"># Efficient parallel computation of pairwise distances can be</span>
            <span class="s0"># achieved via the PairwiseDistances class instead. The latter</span>
            <span class="s0"># internally calls into vector-wise distance computation from</span>
            <span class="s0"># the DistanceMetric subclass while benefiting from the generic</span>
            <span class="s0"># Cython/OpenMP parallelization template for the generic pairwise</span>
            <span class="s0"># distance + reduction computational pattern.</span>
            <span class="s0">for i1 in range(n_X):</span>
                <span class="s0">x1_data = &amp;X_data[0, 0] + i1 * n_features</span>
                <span class="s0">for i2 in range(n_Y):</span>
                    <span class="s0">x2_start = Y_indptr[i2]</span>
                    <span class="s0">x2_end = Y_indptr[i2 + 1]</span>

                    <span class="s0">Darr[i1, i2] = self.dist_csr(</span>
                        <span class="s0">x1_data=x1_data,</span>
                        <span class="s0">x1_indices=&amp;X_indices[0],</span>
                        <span class="s0">x2_data=&amp;Y_data[0],</span>
                        <span class="s0">x2_indices=&amp;Y_indices[0],</span>
                        <span class="s0">x1_start=0,</span>
                        <span class="s0">x1_end=n_features,</span>
                        <span class="s0">x2_start=x2_start,</span>
                        <span class="s0">x2_end=x2_end,</span>
                        <span class="s0">size=n_features,</span>
                    <span class="s0">)</span>

        <span class="s0">return np.asarray(Darr)</span>


    <span class="s0">def pairwise(self, X, Y=None):</span>
        <span class="s0">&quot;&quot;&quot;Compute the pairwise distances between X and Y</span>

        <span class="s0">This is a convenience routine for the sake of testing.  For many</span>
        <span class="s0">metrics, the utilities in scipy.spatial.distance.cdist and</span>
        <span class="s0">scipy.spatial.distance.pdist will be faster.</span>

        <span class="s0">Parameters</span>
        <span class="s0">----------</span>
        <span class="s0">X : ndarray or CSR matrix of shape (n_samples_X, n_features)</span>
            <span class="s0">Input data.</span>
        <span class="s0">Y : ndarray or CSR matrix of shape (n_samples_Y, n_features)</span>
            <span class="s0">Input data.</span>
            <span class="s0">If not specified, then Y=X.</span>

        <span class="s0">Returns</span>
        <span class="s0">-------</span>
        <span class="s0">dist : ndarray of shape  (n_samples_X, n_samples_Y)</span>
            <span class="s0">The distance matrix of pairwise distances between points in X and Y.</span>
        <span class="s0">&quot;&quot;&quot;</span>
        <span class="s0">X = check_array(X, accept_sparse=['csr'])</span>

        <span class="s0">if Y is None:</span>
            <span class="s0">Y = X</span>
        <span class="s0">else:</span>
            <span class="s0">Y = check_array(Y, accept_sparse=['csr'])</span>

        <span class="s0">X_is_sparse = issparse(X)</span>
        <span class="s0">Y_is_sparse = issparse(Y)</span>

        <span class="s0">if not X_is_sparse and not Y_is_sparse:</span>
            <span class="s0">return self._pairwise_dense_dense(X, Y)</span>

        <span class="s0">if X_is_sparse and Y_is_sparse:</span>
            <span class="s0">return self._pairwise_sparse_sparse(X, Y)</span>

        <span class="s0">if X_is_sparse and not Y_is_sparse:</span>
            <span class="s0">return self._pairwise_sparse_dense(X, Y)</span>

        <span class="s0">return self._pairwise_dense_sparse(X, Y)</span>

<span class="s0">#------------------------------------------------------------</span>
<span class="s0"># Euclidean Distance</span>
<span class="s0">#  d = sqrt(sum(x_i^2 - y_i^2))</span>
<span class="s0">cdef class EuclideanDistance{{name_suffix}}(DistanceMetric{{name_suffix}}):</span>
    <span class="s0">r&quot;&quot;&quot;Euclidean Distance metric</span>

    <span class="s0">.. math::</span>
       <span class="s0">D(x, y) = \sqrt{ \sum_i (x_i - y_i) ^ 2 }</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">def __init__(self):</span>
        <span class="s0">self.p = 2</span>

    <span class="s0">cdef inline {{INPUT_DTYPE_t}} dist(self,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x1,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x2,</span>
        <span class="s0">intp_t size,</span>
    <span class="s0">) except -1 nogil:</span>
        <span class="s0">return euclidean_dist{{name_suffix}}(x1, x2, size)</span>

    <span class="s0">cdef inline {{INPUT_DTYPE_t}} rdist(self,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x1,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x2,</span>
        <span class="s0">intp_t size,</span>
    <span class="s0">) except -1 nogil:</span>
        <span class="s0">return euclidean_rdist{{name_suffix}}(x1, x2, size)</span>

    <span class="s0">cdef inline {{INPUT_DTYPE_t}} _rdist_to_dist(self, {{INPUT_DTYPE_t}} rdist) except -1 nogil:</span>
        <span class="s0">return sqrt(rdist)</span>

    <span class="s0">cdef inline {{INPUT_DTYPE_t}} _dist_to_rdist(self, {{INPUT_DTYPE_t}} dist) except -1 nogil:</span>
        <span class="s0">return dist * dist</span>

    <span class="s0">def rdist_to_dist(self, rdist):</span>
        <span class="s0">return np.sqrt(rdist)</span>

    <span class="s0">def dist_to_rdist(self, dist):</span>
        <span class="s0">return dist ** 2</span>

    <span class="s0">cdef inline {{INPUT_DTYPE_t}} rdist_csr(</span>
        <span class="s0">self,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x1_data,</span>
        <span class="s0">const int32_t* x1_indices,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x2_data,</span>
        <span class="s0">const int32_t* x2_indices,</span>
        <span class="s0">const int32_t x1_start,</span>
        <span class="s0">const int32_t x1_end,</span>
        <span class="s0">const int32_t x2_start,</span>
        <span class="s0">const int32_t x2_end,</span>
        <span class="s0">const intp_t size,</span>
    <span class="s0">) except -1 nogil:</span>

        <span class="s0">cdef:</span>
            <span class="s0">intp_t ix1, ix2</span>
            <span class="s0">intp_t i1 = x1_start</span>
            <span class="s0">intp_t i2 = x2_start</span>

            <span class="s0">float64_t d = 0.0</span>
            <span class="s0">float64_t unsquared = 0</span>

        <span class="s0">while i1 &lt; x1_end and i2 &lt; x2_end:</span>
            <span class="s0">ix1 = x1_indices[i1]</span>
            <span class="s0">ix2 = x2_indices[i2]</span>

            <span class="s0">if ix1 == ix2:</span>
                <span class="s0">unsquared = x1_data[i1] - x2_data[i2]</span>
                <span class="s0">d = d + (unsquared * unsquared)</span>
                <span class="s0">i1 = i1 + 1</span>
                <span class="s0">i2 = i2 + 1</span>
            <span class="s0">elif ix1 &lt; ix2:</span>
                <span class="s0">unsquared = x1_data[i1]</span>
                <span class="s0">d = d + (unsquared * unsquared)</span>
                <span class="s0">i1 = i1 + 1</span>
            <span class="s0">else:</span>
                <span class="s0">unsquared = x2_data[i2]</span>
                <span class="s0">d = d + (unsquared * unsquared)</span>
                <span class="s0">i2 = i2 + 1</span>

        <span class="s0">if i1 == x1_end:</span>
            <span class="s0">while i2 &lt; x2_end:</span>
                <span class="s0">unsquared = x2_data[i2]</span>
                <span class="s0">d = d + (unsquared * unsquared)</span>
                <span class="s0">i2 = i2 + 1</span>
        <span class="s0">else:</span>
            <span class="s0">while i1 &lt; x1_end:</span>
                <span class="s0">unsquared = x1_data[i1]</span>
                <span class="s0">d = d + (unsquared * unsquared)</span>
                <span class="s0">i1 = i1 + 1</span>

        <span class="s0">return d</span>

    <span class="s0">cdef inline {{INPUT_DTYPE_t}} dist_csr(</span>
        <span class="s0">self,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x1_data,</span>
        <span class="s0">const int32_t* x1_indices,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x2_data,</span>
        <span class="s0">const int32_t* x2_indices,</span>
        <span class="s0">const int32_t x1_start,</span>
        <span class="s0">const int32_t x1_end,</span>
        <span class="s0">const int32_t x2_start,</span>
        <span class="s0">const int32_t x2_end,</span>
        <span class="s0">const intp_t size,</span>
    <span class="s0">) except -1 nogil:</span>
        <span class="s0">return sqrt(</span>
            <span class="s0">self.rdist_csr(</span>
            <span class="s0">x1_data,</span>
            <span class="s0">x1_indices,</span>
            <span class="s0">x2_data,</span>
            <span class="s0">x2_indices,</span>
            <span class="s0">x1_start,</span>
            <span class="s0">x1_end,</span>
            <span class="s0">x2_start,</span>
            <span class="s0">x2_end,</span>
            <span class="s0">size,</span>
        <span class="s0">))</span>

<span class="s0">#------------------------------------------------------------</span>
<span class="s0"># SEuclidean Distance</span>
<span class="s0">#  d = sqrt(sum((x_i - y_i2)^2 / v_i))</span>
<span class="s0">cdef class SEuclideanDistance{{name_suffix}}(DistanceMetric{{name_suffix}}):</span>
    <span class="s0">r&quot;&quot;&quot;Standardized Euclidean Distance metric</span>

    <span class="s0">.. math::</span>
       <span class="s0">D(x, y) = \sqrt{ \sum_i \frac{ (x_i - y_i) ^ 2}{V_i} }</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">def __init__(self, V):</span>
        <span class="s0">self.vec = np.asarray(V, dtype=np.float64)</span>
        <span class="s0">self.size = self.vec.shape[0]</span>
        <span class="s0">self.p = 2</span>

    <span class="s0">def _validate_data(self, X):</span>
        <span class="s0">if X.shape[1] != self.size:</span>
            <span class="s0">raise ValueError('SEuclidean dist: size of V does not match')</span>

    <span class="s0">cdef inline {{INPUT_DTYPE_t}} rdist(</span>
        <span class="s0">self,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x1,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x2,</span>
        <span class="s0">intp_t size,</span>
    <span class="s0">) except -1 nogil:</span>
        <span class="s0">cdef float64_t tmp, d=0</span>
        <span class="s0">cdef intp_t j</span>
        <span class="s0">for j in range(size):</span>
            <span class="s0">tmp = x1[j] - x2[j]</span>
            <span class="s0">d += (tmp * tmp / self.vec[j])</span>
        <span class="s0">return d</span>

    <span class="s0">cdef inline {{INPUT_DTYPE_t}} dist(</span>
        <span class="s0">self,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x1,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x2,</span>
        <span class="s0">intp_t size,</span>
    <span class="s0">) except -1 nogil:</span>
        <span class="s0">return sqrt(self.rdist(x1, x2, size))</span>

    <span class="s0">cdef inline {{INPUT_DTYPE_t}} _rdist_to_dist(self, {{INPUT_DTYPE_t}} rdist) except -1 nogil:</span>
        <span class="s0">return sqrt(rdist)</span>

    <span class="s0">cdef inline {{INPUT_DTYPE_t}} _dist_to_rdist(self, {{INPUT_DTYPE_t}} dist) except -1 nogil:</span>
        <span class="s0">return dist * dist</span>

    <span class="s0">def rdist_to_dist(self, rdist):</span>
        <span class="s0">return np.sqrt(rdist)</span>

    <span class="s0">def dist_to_rdist(self, dist):</span>
        <span class="s0">return dist ** 2</span>

    <span class="s0">cdef inline {{INPUT_DTYPE_t}} rdist_csr(</span>
        <span class="s0">self,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x1_data,</span>
        <span class="s0">const int32_t* x1_indices,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x2_data,</span>
        <span class="s0">const int32_t* x2_indices,</span>
        <span class="s0">const int32_t x1_start,</span>
        <span class="s0">const int32_t x1_end,</span>
        <span class="s0">const int32_t x2_start,</span>
        <span class="s0">const int32_t x2_end,</span>
        <span class="s0">const intp_t size,</span>
    <span class="s0">) except -1 nogil:</span>

        <span class="s0">cdef:</span>
            <span class="s0">intp_t ix1, ix2</span>
            <span class="s0">intp_t i1 = x1_start</span>
            <span class="s0">intp_t i2 = x2_start</span>

            <span class="s0">float64_t d = 0.0</span>
            <span class="s0">float64_t unsquared = 0</span>

        <span class="s0">while i1 &lt; x1_end and i2 &lt; x2_end:</span>
            <span class="s0">ix1 = x1_indices[i1]</span>
            <span class="s0">ix2 = x2_indices[i2]</span>

            <span class="s0">if ix1 == ix2:</span>
                <span class="s0">unsquared = x1_data[i1] - x2_data[i2]</span>
                <span class="s0">d = d + (unsquared * unsquared) / self.vec[ix1]</span>
                <span class="s0">i1 = i1 + 1</span>
                <span class="s0">i2 = i2 + 1</span>
            <span class="s0">elif ix1 &lt; ix2:</span>
                <span class="s0">unsquared = x1_data[i1]</span>
                <span class="s0">d = d + (unsquared * unsquared) / self.vec[ix1]</span>
                <span class="s0">i1 = i1 + 1</span>
            <span class="s0">else:</span>
                <span class="s0">unsquared = x2_data[i2]</span>
                <span class="s0">d = d + (unsquared * unsquared) / self.vec[ix2]</span>
                <span class="s0">i2 = i2 + 1</span>

        <span class="s0">if i1 == x1_end:</span>
            <span class="s0">while i2 &lt; x2_end:</span>
                <span class="s0">ix2 = x2_indices[i2]</span>
                <span class="s0">unsquared = x2_data[i2]</span>
                <span class="s0">d = d + (unsquared * unsquared) / self.vec[ix2]</span>
                <span class="s0">i2 = i2 + 1</span>
        <span class="s0">else:</span>
            <span class="s0">while i1 &lt; x1_end:</span>
                <span class="s0">ix1 = x1_indices[i1]</span>
                <span class="s0">unsquared = x1_data[i1]</span>
                <span class="s0">d = d + (unsquared * unsquared) / self.vec[ix1]</span>
                <span class="s0">i1 = i1 + 1</span>
        <span class="s0">return d</span>

    <span class="s0">cdef inline {{INPUT_DTYPE_t}} dist_csr(</span>
        <span class="s0">self,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x1_data,</span>
        <span class="s0">const int32_t* x1_indices,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x2_data,</span>
        <span class="s0">const int32_t* x2_indices,</span>
        <span class="s0">const int32_t x1_start,</span>
        <span class="s0">const int32_t x1_end,</span>
        <span class="s0">const int32_t x2_start,</span>
        <span class="s0">const int32_t x2_end,</span>
        <span class="s0">const intp_t size,</span>
    <span class="s0">) except -1 nogil:</span>
        <span class="s0">return sqrt(</span>
            <span class="s0">self.rdist_csr(</span>
            <span class="s0">x1_data,</span>
            <span class="s0">x1_indices,</span>
            <span class="s0">x2_data,</span>
            <span class="s0">x2_indices,</span>
            <span class="s0">x1_start,</span>
            <span class="s0">x1_end,</span>
            <span class="s0">x2_start,</span>
            <span class="s0">x2_end,</span>
            <span class="s0">size,</span>
        <span class="s0">))</span>

<span class="s0">#------------------------------------------------------------</span>
<span class="s0"># Manhattan Distance</span>
<span class="s0">#  d = sum(abs(x_i - y_i))</span>
<span class="s0">cdef class ManhattanDistance{{name_suffix}}(DistanceMetric{{name_suffix}}):</span>
    <span class="s0">r&quot;&quot;&quot;Manhattan/City-block Distance metric</span>

    <span class="s0">.. math::</span>
       <span class="s0">D(x, y) = \sum_i |x_i - y_i|</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">def __init__(self):</span>
        <span class="s0">self.p = 1</span>

    <span class="s0">cdef inline {{INPUT_DTYPE_t}} dist(</span>
        <span class="s0">self,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x1,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x2,</span>
        <span class="s0">intp_t size,</span>
    <span class="s0">) except -1 nogil:</span>
        <span class="s0">cdef float64_t d = 0</span>
        <span class="s0">cdef intp_t j</span>
        <span class="s0">for j in range(size):</span>
            <span class="s0">d += fabs(x1[j] - x2[j])</span>
        <span class="s0">return d</span>

    <span class="s0">cdef inline {{INPUT_DTYPE_t}} dist_csr(</span>
        <span class="s0">self,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x1_data,</span>
        <span class="s0">const int32_t* x1_indices,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x2_data,</span>
        <span class="s0">const int32_t* x2_indices,</span>
        <span class="s0">const int32_t x1_start,</span>
        <span class="s0">const int32_t x1_end,</span>
        <span class="s0">const int32_t x2_start,</span>
        <span class="s0">const int32_t x2_end,</span>
        <span class="s0">const intp_t size,</span>
    <span class="s0">) except -1 nogil:</span>

        <span class="s0">cdef:</span>
            <span class="s0">intp_t ix1, ix2</span>
            <span class="s0">intp_t i1 = x1_start</span>
            <span class="s0">intp_t i2 = x2_start</span>

            <span class="s0">{{INPUT_DTYPE_t}} d = 0.0</span>

        <span class="s0">while i1 &lt; x1_end and i2 &lt; x2_end:</span>
            <span class="s0">ix1 = x1_indices[i1]</span>
            <span class="s0">ix2 = x2_indices[i2]</span>

            <span class="s0">if ix1 == ix2:</span>
                <span class="s0">d = d + fabs(x1_data[i1] - x2_data[i2])</span>
                <span class="s0">i1 = i1 + 1</span>
                <span class="s0">i2 = i2 + 1</span>
            <span class="s0">elif ix1 &lt; ix2:</span>
                <span class="s0">d = d + fabs(x1_data[i1])</span>
                <span class="s0">i1 = i1 + 1</span>
            <span class="s0">else:</span>
                <span class="s0">d = d + fabs(x2_data[i2])</span>
                <span class="s0">i2 = i2 + 1</span>

        <span class="s0">if i1 == x1_end:</span>
            <span class="s0">while i2 &lt; x2_end:</span>
                <span class="s0">d = d + fabs(x2_data[i2])</span>
                <span class="s0">i2 = i2 + 1</span>
        <span class="s0">else:</span>
            <span class="s0">while i1 &lt; x1_end:</span>
                <span class="s0">d = d + fabs(x1_data[i1])</span>
                <span class="s0">i1 = i1 + 1</span>

        <span class="s0">return d</span>


<span class="s0">#------------------------------------------------------------</span>
<span class="s0"># Chebyshev Distance</span>
<span class="s0">#  d = max_i(abs(x_i - y_i))</span>
<span class="s0">cdef class ChebyshevDistance{{name_suffix}}(DistanceMetric{{name_suffix}}):</span>
    <span class="s0">&quot;&quot;&quot;Chebyshev/Infinity Distance</span>

    <span class="s0">.. math::</span>
       <span class="s0">D(x, y) = max_i (|x_i - y_i|)</span>

    <span class="s0">Examples</span>
    <span class="s0">--------</span>
    <span class="s0">&gt;&gt;&gt; from sklearn.metrics.dist_metrics import DistanceMetric</span>
    <span class="s0">&gt;&gt;&gt; dist = DistanceMetric.get_metric('chebyshev')</span>
    <span class="s0">&gt;&gt;&gt; X = [[0, 1, 2],</span>
    <span class="s0">...      [3, 4, 5]]</span>
    <span class="s0">&gt;&gt;&gt; Y = [[-1, 0, 1],</span>
    <span class="s0">...      [3, 4, 5]]</span>
    <span class="s0">&gt;&gt;&gt; dist.pairwise(X, Y)</span>
    <span class="s0">array([[1.732..., 5.196...],</span>
           <span class="s0">[6.928..., 0....   ]])</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">def __init__(self):</span>
        <span class="s0">self.p = INF{{name_suffix}}</span>

    <span class="s0">cdef inline {{INPUT_DTYPE_t}} dist(</span>
        <span class="s0">self,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x1,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x2,</span>
        <span class="s0">intp_t size,</span>
    <span class="s0">) except -1 nogil:</span>
        <span class="s0">cdef float64_t d = 0</span>
        <span class="s0">cdef intp_t j</span>
        <span class="s0">for j in range(size):</span>
            <span class="s0">d = fmax(d, fabs(x1[j] - x2[j]))</span>
        <span class="s0">return d</span>


    <span class="s0">cdef inline {{INPUT_DTYPE_t}} dist_csr(</span>
        <span class="s0">self,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x1_data,</span>
        <span class="s0">const int32_t* x1_indices,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x2_data,</span>
        <span class="s0">const int32_t* x2_indices,</span>
        <span class="s0">const int32_t x1_start,</span>
        <span class="s0">const int32_t x1_end,</span>
        <span class="s0">const int32_t x2_start,</span>
        <span class="s0">const int32_t x2_end,</span>
        <span class="s0">const intp_t size,</span>
    <span class="s0">) except -1 nogil:</span>

        <span class="s0">cdef:</span>
            <span class="s0">intp_t ix1, ix2</span>
            <span class="s0">intp_t i1 = x1_start</span>
            <span class="s0">intp_t i2 = x2_start</span>

            <span class="s0">float64_t d = 0.0</span>

        <span class="s0">while i1 &lt; x1_end and i2 &lt; x2_end:</span>
            <span class="s0">ix1 = x1_indices[i1]</span>
            <span class="s0">ix2 = x2_indices[i2]</span>

            <span class="s0">if ix1 == ix2:</span>
                <span class="s0">d = fmax(d, fabs(x1_data[i1] - x2_data[i2]))</span>
                <span class="s0">i1 = i1 + 1</span>
                <span class="s0">i2 = i2 + 1</span>
            <span class="s0">elif ix1 &lt; ix2:</span>
                <span class="s0">d = fmax(d, fabs(x1_data[i1]))</span>
                <span class="s0">i1 = i1 + 1</span>
            <span class="s0">else:</span>
                <span class="s0">d = fmax(d, fabs(x2_data[i2]))</span>
                <span class="s0">i2 = i2 + 1</span>

        <span class="s0">if i1 == x1_end:</span>
            <span class="s0">while i2 &lt; x2_end:</span>
                <span class="s0">d = fmax(d, fabs(x2_data[i2]))</span>
                <span class="s0">i2 = i2 + 1</span>
        <span class="s0">else:</span>
            <span class="s0">while i1 &lt; x1_end:</span>
                <span class="s0">d = fmax(d, fabs(x1_data[i1]))</span>
                <span class="s0">i1 = i1 + 1</span>

        <span class="s0">return d</span>


<span class="s0">#------------------------------------------------------------</span>
<span class="s0"># Minkowski Distance</span>
<span class="s0">cdef class MinkowskiDistance{{name_suffix}}(DistanceMetric{{name_suffix}}):</span>
    <span class="s0">r&quot;&quot;&quot;Minkowski Distance</span>

    <span class="s0">.. math::</span>
        <span class="s0">D(x, y) = {||u-v||}_p</span>

    <span class="s0">when w is None.</span>

    <span class="s0">Here is the more general expanded expression for the weighted case:</span>

    <span class="s0">.. math::</span>
        <span class="s0">D(x, y) = [\sum_i w_i *|x_i - y_i|^p] ^ (1/p)</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">p : float</span>
        <span class="s0">The order of the p-norm of the difference (see above).</span>

        <span class="s0">.. versionchanged:: 1.4.0</span>
            <span class="s0">Minkowski distance allows `p` to be `0&lt;p&lt;1`.</span>


    <span class="s0">w : (N,) array-like (optional)</span>
        <span class="s0">The weight vector.</span>

    <span class="s0">Minkowski Distance requires p &gt; 0 and finite.</span>
    <span class="s0">When :math:`p \in (0,1)`, it isn't a true metric but is permissible when</span>
    <span class="s0">the triangular inequality isn't necessary.</span>
    <span class="s0">For p = infinity, use ChebyshevDistance.</span>
    <span class="s0">Note that for p=1, ManhattanDistance is more efficient, and for</span>
    <span class="s0">p=2, EuclideanDistance is more efficient.</span>

    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">def __init__(self, p, w=None):</span>
        <span class="s0">if p &lt;= 0:</span>
            <span class="s0">raise ValueError(&quot;p must be greater than 0&quot;)</span>
        <span class="s0">elif np.isinf(p):</span>
            <span class="s0">raise ValueError(&quot;MinkowskiDistance requires finite p. &quot;</span>
                             <span class="s0">&quot;For p=inf, use ChebyshevDistance.&quot;)</span>

        <span class="s0">self.p = p</span>
        <span class="s0">if w is not None:</span>
            <span class="s0">w_array = check_array(</span>
                <span class="s0">w, ensure_2d=False, dtype=np.float64, input_name=&quot;w&quot;</span>
            <span class="s0">)</span>
            <span class="s0">if (w_array &lt; 0).any():</span>
                <span class="s0">raise ValueError(&quot;w cannot contain negative weights&quot;)</span>
            <span class="s0">self.vec = w_array</span>
            <span class="s0">self.size = self.vec.shape[0]</span>
        <span class="s0">else:</span>
            <span class="s0">self.vec = np.asarray([], dtype=np.float64)</span>
            <span class="s0">self.size = 0</span>

    <span class="s0">def _validate_data(self, X):</span>
        <span class="s0">if self.size &gt; 0 and X.shape[1] != self.size:</span>
            <span class="s0">raise ValueError(&quot;MinkowskiDistance: the size of w must match &quot;</span>
                             <span class="s0">f&quot;the number of features ({X.shape[1]}). &quot;</span>
                             <span class="s0">f&quot;Currently len(w)={self.size}.&quot;)</span>

    <span class="s0">cdef inline {{INPUT_DTYPE_t}} rdist(</span>
        <span class="s0">self,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x1,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x2,</span>
        <span class="s0">intp_t size,</span>
    <span class="s0">) except -1 nogil:</span>
        <span class="s0">cdef float64_t d=0</span>
        <span class="s0">cdef intp_t j</span>
        <span class="s0">cdef bint has_w = self.size &gt; 0</span>
        <span class="s0">if has_w:</span>
            <span class="s0">for j in range(size):</span>
                <span class="s0">d += (self.vec[j] * pow(fabs(x1[j] - x2[j]), self.p))</span>
        <span class="s0">else:</span>
            <span class="s0">for j in range(size):</span>
                <span class="s0">d += (pow(fabs(x1[j] - x2[j]), self.p))</span>
        <span class="s0">return d</span>

    <span class="s0">cdef inline {{INPUT_DTYPE_t}} dist(</span>
        <span class="s0">self,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x1,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x2,</span>
        <span class="s0">intp_t size,</span>
    <span class="s0">) except -1 nogil:</span>
        <span class="s0">return pow(self.rdist(x1, x2, size), 1. / self.p)</span>

    <span class="s0">cdef inline {{INPUT_DTYPE_t}} _rdist_to_dist(self, {{INPUT_DTYPE_t}} rdist) except -1 nogil:</span>
        <span class="s0">return pow(rdist, 1. / self.p)</span>

    <span class="s0">cdef inline {{INPUT_DTYPE_t}} _dist_to_rdist(self, {{INPUT_DTYPE_t}} dist) except -1 nogil:</span>
        <span class="s0">return pow(dist, self.p)</span>

    <span class="s0">def rdist_to_dist(self, rdist):</span>
        <span class="s0">return rdist ** (1. / self.p)</span>

    <span class="s0">def dist_to_rdist(self, dist):</span>
        <span class="s0">return dist ** self.p</span>

    <span class="s0">cdef inline {{INPUT_DTYPE_t}} rdist_csr(</span>
        <span class="s0">self,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x1_data,</span>
        <span class="s0">const int32_t* x1_indices,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x2_data,</span>
        <span class="s0">const int32_t* x2_indices,</span>
        <span class="s0">const int32_t x1_start,</span>
        <span class="s0">const int32_t x1_end,</span>
        <span class="s0">const int32_t x2_start,</span>
        <span class="s0">const int32_t x2_end,</span>
        <span class="s0">const intp_t size,</span>
    <span class="s0">) except -1 nogil:</span>

        <span class="s0">cdef:</span>
            <span class="s0">intp_t ix1, ix2</span>
            <span class="s0">intp_t i1 = x1_start</span>
            <span class="s0">intp_t i2 = x2_start</span>

            <span class="s0">float64_t d = 0.0</span>
            <span class="s0">bint has_w = self.size &gt; 0</span>

        <span class="s0">if has_w:</span>
            <span class="s0">while i1 &lt; x1_end and i2 &lt; x2_end:</span>
                <span class="s0">ix1 = x1_indices[i1]</span>
                <span class="s0">ix2 = x2_indices[i2]</span>

                <span class="s0">if ix1 == ix2:</span>
                    <span class="s0">d = d + (self.vec[ix1] * pow(fabs(</span>
                        <span class="s0">x1_data[i1] - x2_data[i2]</span>
                    <span class="s0">), self.p))</span>
                    <span class="s0">i1 = i1 + 1</span>
                    <span class="s0">i2 = i2 + 1</span>
                <span class="s0">elif ix1 &lt; ix2:</span>
                    <span class="s0">d = d + (self.vec[ix1] * pow(fabs(x1_data[i1]), self.p))</span>
                    <span class="s0">i1 = i1 + 1</span>
                <span class="s0">else:</span>
                    <span class="s0">d = d + (self.vec[ix2] * pow(fabs(x2_data[i2]), self.p))</span>
                    <span class="s0">i2 = i2 + 1</span>

            <span class="s0">if i1 == x1_end:</span>
                <span class="s0">while i2 &lt; x2_end:</span>
                    <span class="s0">ix2 = x2_indices[i2]</span>
                    <span class="s0">d = d + (self.vec[ix2] * pow(fabs(x2_data[i2]), self.p))</span>
                    <span class="s0">i2 = i2 + 1</span>
            <span class="s0">else:</span>
                <span class="s0">while i1 &lt; x1_end:</span>
                    <span class="s0">ix1 = x1_indices[i1]</span>
                    <span class="s0">d = d + (self.vec[ix1] * pow(fabs(x1_data[i1]), self.p))</span>
                    <span class="s0">i1 = i1 + 1</span>

            <span class="s0">return d</span>
        <span class="s0">else:</span>
            <span class="s0">while i1 &lt; x1_end and i2 &lt; x2_end:</span>
                <span class="s0">ix1 = x1_indices[i1]</span>
                <span class="s0">ix2 = x2_indices[i2]</span>

                <span class="s0">if ix1 == ix2:</span>
                    <span class="s0">d = d + (pow(fabs(</span>
                        <span class="s0">x1_data[i1] - x2_data[i2]</span>
                    <span class="s0">), self.p))</span>
                    <span class="s0">i1 = i1 + 1</span>
                    <span class="s0">i2 = i2 + 1</span>
                <span class="s0">elif ix1 &lt; ix2:</span>
                    <span class="s0">d = d + (pow(fabs(x1_data[i1]), self.p))</span>
                    <span class="s0">i1 = i1 + 1</span>
                <span class="s0">else:</span>
                    <span class="s0">d = d + (pow(fabs(x2_data[i2]), self.p))</span>
                    <span class="s0">i2 = i2 + 1</span>

            <span class="s0">if i1 == x1_end:</span>
                <span class="s0">while i2 &lt; x2_end:</span>
                    <span class="s0">d = d + (pow(fabs(x2_data[i2]), self.p))</span>
                    <span class="s0">i2 = i2 + 1</span>
            <span class="s0">else:</span>
                <span class="s0">while i1 &lt; x1_end:</span>
                    <span class="s0">d = d + (pow(fabs(x1_data[i1]), self.p))</span>
                    <span class="s0">i1 = i1 + 1</span>

            <span class="s0">return d</span>

    <span class="s0">cdef inline {{INPUT_DTYPE_t}} dist_csr(</span>
        <span class="s0">self,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x1_data,</span>
        <span class="s0">const int32_t* x1_indices,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x2_data,</span>
        <span class="s0">const int32_t* x2_indices,</span>
        <span class="s0">const int32_t x1_start,</span>
        <span class="s0">const int32_t x1_end,</span>
        <span class="s0">const int32_t x2_start,</span>
        <span class="s0">const int32_t x2_end,</span>
        <span class="s0">const intp_t size,</span>
    <span class="s0">) except -1 nogil:</span>
        <span class="s0">return pow(</span>
            <span class="s0">self.rdist_csr(</span>
                <span class="s0">x1_data,</span>
                <span class="s0">x1_indices,</span>
                <span class="s0">x2_data,</span>
                <span class="s0">x2_indices,</span>
                <span class="s0">x1_start,</span>
                <span class="s0">x1_end,</span>
                <span class="s0">x2_start,</span>
                <span class="s0">x2_end,</span>
                <span class="s0">size,</span>
            <span class="s0">),</span>
            <span class="s0">1 / self.p</span>
        <span class="s0">)</span>

<span class="s0">#------------------------------------------------------------</span>
<span class="s0"># Mahalanobis Distance</span>
<span class="s0">#  d = sqrt( (x - y)^T V^-1 (x - y) )</span>
<span class="s0">cdef class MahalanobisDistance{{name_suffix}}(DistanceMetric{{name_suffix}}):</span>
    <span class="s0">&quot;&quot;&quot;Mahalanobis Distance</span>

    <span class="s0">.. math::</span>
       <span class="s0">D(x, y) = \sqrt{ (x - y)^T V^{-1} (x - y) }</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">V : array-like</span>
        <span class="s0">Symmetric positive-definite covariance matrix.</span>
        <span class="s0">The inverse of this matrix will be explicitly computed.</span>
    <span class="s0">VI : array-like</span>
        <span class="s0">optionally specify the inverse directly.  If VI is passed,</span>
        <span class="s0">then V is not referenced.</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef float64_t[::1] buffer</span>

    <span class="s0">def __init__(self, V=None, VI=None):</span>
        <span class="s0">if VI is None:</span>
            <span class="s0">if V is None:</span>
                <span class="s0">raise ValueError(&quot;Must provide either V or VI &quot;</span>
                                 <span class="s0">&quot;for Mahalanobis distance&quot;)</span>
            <span class="s0">VI = np.linalg.inv(V)</span>
        <span class="s0">if VI.ndim != 2 or VI.shape[0] != VI.shape[1]:</span>
            <span class="s0">raise ValueError(&quot;V/VI must be square&quot;)</span>

        <span class="s0">self.mat = np.asarray(VI, dtype=np.float64, order='C')</span>

        <span class="s0">self.size = self.mat.shape[0]</span>

        <span class="s0"># We need to create a buffer to store the vectors' coordinates' differences</span>
        <span class="s0">self.buffer = np.zeros(self.size, dtype=np.float64)</span>

    <span class="s0">def __setstate__(self, state):</span>
        <span class="s0">super().__setstate__(state)</span>
        <span class="s0">self.size = self.mat.shape[0]</span>
        <span class="s0">self.buffer = np.zeros(self.size, dtype=np.float64)</span>

    <span class="s0">def _validate_data(self, X):</span>
        <span class="s0">if X.shape[1] != self.size:</span>
            <span class="s0">raise ValueError('Mahalanobis dist: size of V does not match')</span>

    <span class="s0">cdef inline {{INPUT_DTYPE_t}} rdist(</span>
        <span class="s0">self,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x1,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x2,</span>
        <span class="s0">intp_t size,</span>
    <span class="s0">) except -1 nogil:</span>
        <span class="s0">cdef float64_t tmp, d = 0</span>
        <span class="s0">cdef intp_t i, j</span>

        <span class="s0"># compute (x1 - x2).T * VI * (x1 - x2)</span>
        <span class="s0">for i in range(size):</span>
            <span class="s0">self.buffer[i] = x1[i] - x2[i]</span>

        <span class="s0">for i in range(size):</span>
            <span class="s0">tmp = 0</span>
            <span class="s0">for j in range(size):</span>
                <span class="s0">tmp += self.mat[i, j] * self.buffer[j]</span>
            <span class="s0">d += tmp * self.buffer[i]</span>
        <span class="s0">return d</span>

    <span class="s0">cdef inline {{INPUT_DTYPE_t}} dist(</span>
        <span class="s0">self,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x1,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x2,</span>
        <span class="s0">intp_t size,</span>
    <span class="s0">) except -1 nogil:</span>
        <span class="s0">return sqrt(self.rdist(x1, x2, size))</span>

    <span class="s0">cdef inline {{INPUT_DTYPE_t}} _rdist_to_dist(self, {{INPUT_DTYPE_t}} rdist) except -1 nogil:</span>
        <span class="s0">return sqrt(rdist)</span>

    <span class="s0">cdef inline {{INPUT_DTYPE_t}} _dist_to_rdist(self, {{INPUT_DTYPE_t}} dist) except -1 nogil:</span>
        <span class="s0">return dist * dist</span>

    <span class="s0">def rdist_to_dist(self, rdist):</span>
        <span class="s0">return np.sqrt(rdist)</span>

    <span class="s0">def dist_to_rdist(self, dist):</span>
        <span class="s0">return dist ** 2</span>

    <span class="s0">cdef inline {{INPUT_DTYPE_t}} rdist_csr(</span>
        <span class="s0">self,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x1_data,</span>
        <span class="s0">const int32_t* x1_indices,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x2_data,</span>
        <span class="s0">const int32_t* x2_indices,</span>
        <span class="s0">const int32_t x1_start,</span>
        <span class="s0">const int32_t x1_end,</span>
        <span class="s0">const int32_t x2_start,</span>
        <span class="s0">const int32_t x2_end,</span>
        <span class="s0">const intp_t size,</span>
    <span class="s0">) except -1 nogil:</span>

        <span class="s0">cdef:</span>
            <span class="s0">intp_t ix1, ix2</span>
            <span class="s0">intp_t i1 = x1_start</span>
            <span class="s0">intp_t i2 = x2_start</span>

            <span class="s0">float64_t tmp, d = 0.0</span>

        <span class="s0">while i1 &lt; x1_end and i2 &lt; x2_end:</span>
            <span class="s0">ix1 = x1_indices[i1]</span>
            <span class="s0">ix2 = x2_indices[i2]</span>

            <span class="s0">if ix1 == ix2:</span>
                <span class="s0">self.buffer[ix1] = x1_data[i1] - x2_data[i2]</span>
                <span class="s0">i1 = i1 + 1</span>
                <span class="s0">i2 = i2 + 1</span>
            <span class="s0">elif ix1 &lt; ix2:</span>
                <span class="s0">self.buffer[ix1] = x1_data[i1]</span>
                <span class="s0">i1 = i1 + 1</span>
            <span class="s0">else:</span>
                <span class="s0">self.buffer[ix2] = - x2_data[i2]</span>
                <span class="s0">i2 = i2 + 1</span>

        <span class="s0">if i1 == x1_end:</span>
            <span class="s0">while i2 &lt; x2_end:</span>
                <span class="s0">ix2 = x2_indices[i2]</span>
                <span class="s0">self.buffer[ix2] = - x2_data[i2]</span>
                <span class="s0">i2 = i2 + 1</span>
        <span class="s0">else:</span>
            <span class="s0">while i1 &lt; x1_end:</span>
                <span class="s0">ix1 = x1_indices[i1]</span>
                <span class="s0">self.buffer[ix1] = x1_data[i1]</span>
                <span class="s0">i1 = i1 + 1</span>

        <span class="s0">for i in range(size):</span>
            <span class="s0">tmp = 0</span>
            <span class="s0">for j in range(size):</span>
                <span class="s0">tmp += self.mat[i, j] * self.buffer[j]</span>
            <span class="s0">d += tmp * self.buffer[i]</span>

        <span class="s0">return d</span>

    <span class="s0">cdef inline {{INPUT_DTYPE_t}} dist_csr(</span>
        <span class="s0">self,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x1_data,</span>
        <span class="s0">const int32_t* x1_indices,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x2_data,</span>
        <span class="s0">const int32_t* x2_indices,</span>
        <span class="s0">const int32_t x1_start,</span>
        <span class="s0">const int32_t x1_end,</span>
        <span class="s0">const int32_t x2_start,</span>
        <span class="s0">const int32_t x2_end,</span>
        <span class="s0">const intp_t size,</span>
    <span class="s0">) except -1 nogil:</span>
        <span class="s0">return sqrt(</span>
            <span class="s0">self.rdist_csr(</span>
            <span class="s0">x1_data,</span>
            <span class="s0">x1_indices,</span>
            <span class="s0">x2_data,</span>
            <span class="s0">x2_indices,</span>
            <span class="s0">x1_start,</span>
            <span class="s0">x1_end,</span>
            <span class="s0">x2_start,</span>
            <span class="s0">x2_end,</span>
            <span class="s0">size,</span>
        <span class="s0">))</span>

<span class="s0">#------------------------------------------------------------</span>
<span class="s0"># Hamming Distance</span>
<span class="s0">#  d = N_unequal(x, y) / N_tot</span>
<span class="s0">cdef class HammingDistance{{name_suffix}}(DistanceMetric{{name_suffix}}):</span>
    <span class="s0">r&quot;&quot;&quot;Hamming Distance</span>

    <span class="s0">Hamming distance is meant for discrete-valued vectors, though it is</span>
    <span class="s0">a valid metric for real-valued vectors.</span>

    <span class="s0">.. math::</span>
       <span class="s0">D(x, y) = \frac{1}{N} \sum_i \delta_{x_i, y_i}</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef inline {{INPUT_DTYPE_t}} dist(</span>
        <span class="s0">self,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x1,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x2,</span>
        <span class="s0">intp_t size,</span>
    <span class="s0">) except -1 nogil:</span>
        <span class="s0">cdef int n_unequal = 0</span>
        <span class="s0">cdef intp_t j</span>
        <span class="s0">for j in range(size):</span>
            <span class="s0">if x1[j] != x2[j]:</span>
                <span class="s0">n_unequal += 1</span>
        <span class="s0">return float(n_unequal) / size</span>


    <span class="s0">cdef inline {{INPUT_DTYPE_t}} dist_csr(</span>
        <span class="s0">self,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x1_data,</span>
        <span class="s0">const int32_t* x1_indices,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x2_data,</span>
        <span class="s0">const int32_t* x2_indices,</span>
        <span class="s0">const int32_t x1_start,</span>
        <span class="s0">const int32_t x1_end,</span>
        <span class="s0">const int32_t x2_start,</span>
        <span class="s0">const int32_t x2_end,</span>
        <span class="s0">const intp_t size,</span>
    <span class="s0">) except -1 nogil:</span>

        <span class="s0">cdef:</span>
            <span class="s0">intp_t ix1, ix2</span>
            <span class="s0">intp_t i1 = x1_start</span>
            <span class="s0">intp_t i2 = x2_start</span>

            <span class="s0">float64_t d = 0.0</span>

        <span class="s0">while i1 &lt; x1_end and i2 &lt; x2_end:</span>
            <span class="s0">ix1 = x1_indices[i1]</span>
            <span class="s0">ix2 = x2_indices[i2]</span>

            <span class="s0">if ix1 == ix2:</span>
                <span class="s0">d += (x1_data[i1] != x2_data[i2])</span>
                <span class="s0">i1 = i1 + 1</span>
                <span class="s0">i2 = i2 + 1</span>
            <span class="s0">elif ix1 &lt; ix2:</span>
                <span class="s0">d += (x1_data[i1] != 0)</span>
                <span class="s0">i1 = i1 + 1</span>
            <span class="s0">else:</span>
                <span class="s0">d += (x2_data[i2] != 0)</span>
                <span class="s0">i2 = i2 + 1</span>

        <span class="s0">if i1 == x1_end:</span>
            <span class="s0">while i2 &lt; x2_end:</span>
                <span class="s0">d += (x2_data[i2] != 0)</span>
                <span class="s0">i2 = i2 + 1</span>
        <span class="s0">else:</span>
            <span class="s0">while i1 &lt; x1_end:</span>
                <span class="s0">d += (x1_data[i1] != 0)</span>
                <span class="s0">i1 = i1 + 1</span>

        <span class="s0">d /= size</span>

        <span class="s0">return d</span>


<span class="s0">#------------------------------------------------------------</span>
<span class="s0"># Canberra Distance</span>
<span class="s0">#  D(x, y) = sum[ abs(x_i - y_i) / (abs(x_i) + abs(y_i)) ]</span>
<span class="s0">cdef class CanberraDistance{{name_suffix}}(DistanceMetric{{name_suffix}}):</span>
    <span class="s0">r&quot;&quot;&quot;Canberra Distance</span>

    <span class="s0">Canberra distance is meant for discrete-valued vectors, though it is</span>
    <span class="s0">a valid metric for real-valued vectors.</span>

    <span class="s0">.. math::</span>
       <span class="s0">D(x, y) = \sum_i \frac{|x_i - y_i|}{|x_i| + |y_i|}</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef inline {{INPUT_DTYPE_t}} dist(</span>
        <span class="s0">self,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x1,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x2,</span>
        <span class="s0">intp_t size,</span>
    <span class="s0">) except -1 nogil:</span>
        <span class="s0">cdef float64_t denom, d = 0</span>
        <span class="s0">cdef intp_t j</span>
        <span class="s0">for j in range(size):</span>
            <span class="s0">denom = fabs(x1[j]) + fabs(x2[j])</span>
            <span class="s0">if denom &gt; 0:</span>
                <span class="s0">d += fabs(x1[j] - x2[j]) / denom</span>
        <span class="s0">return d</span>

    <span class="s0">cdef inline {{INPUT_DTYPE_t}} dist_csr(</span>
        <span class="s0">self,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x1_data,</span>
        <span class="s0">const int32_t* x1_indices,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x2_data,</span>
        <span class="s0">const int32_t* x2_indices,</span>
        <span class="s0">const int32_t x1_start,</span>
        <span class="s0">const int32_t x1_end,</span>
        <span class="s0">const int32_t x2_start,</span>
        <span class="s0">const int32_t x2_end,</span>
        <span class="s0">const intp_t size,</span>
    <span class="s0">) except -1 nogil:</span>

        <span class="s0">cdef:</span>
            <span class="s0">intp_t ix1, ix2</span>
            <span class="s0">intp_t i1 = x1_start</span>
            <span class="s0">intp_t i2 = x2_start</span>

            <span class="s0">float64_t d = 0.0</span>

        <span class="s0">while i1 &lt; x1_end and i2 &lt; x2_end:</span>
            <span class="s0">ix1 = x1_indices[i1]</span>
            <span class="s0">ix2 = x2_indices[i2]</span>

            <span class="s0">if ix1 == ix2:</span>
                <span class="s0">d += (</span>
                        <span class="s0">fabs(x1_data[i1] - x2_data[i2]) /</span>
                        <span class="s0">(fabs(x1_data[i1]) + fabs(x2_data[i2]))</span>
                <span class="s0">)</span>
                <span class="s0">i1 = i1 + 1</span>
                <span class="s0">i2 = i2 + 1</span>
            <span class="s0">elif ix1 &lt; ix2:</span>
                <span class="s0">d += 1.</span>
                <span class="s0">i1 = i1 + 1</span>
            <span class="s0">else:</span>
                <span class="s0">d += 1.</span>
                <span class="s0">i2 = i2 + 1</span>

        <span class="s0">if i1 == x1_end:</span>
            <span class="s0">while i2 &lt; x2_end:</span>
                <span class="s0">d += 1.</span>
                <span class="s0">i2 = i2 + 1</span>
        <span class="s0">else:</span>
            <span class="s0">while i1 &lt; x1_end:</span>
                <span class="s0">d += 1.</span>
                <span class="s0">i1 = i1 + 1</span>

        <span class="s0">return d</span>

<span class="s0">#------------------------------------------------------------</span>
<span class="s0"># Bray-Curtis Distance</span>
<span class="s0">#  D(x, y) = sum[abs(x_i - y_i)] / sum[abs(x_i) + abs(y_i)]</span>
<span class="s0">cdef class BrayCurtisDistance{{name_suffix}}(DistanceMetric{{name_suffix}}):</span>
    <span class="s0">r&quot;&quot;&quot;Bray-Curtis Distance</span>

    <span class="s0">Bray-Curtis distance is meant for discrete-valued vectors, though it is</span>
    <span class="s0">a valid metric for real-valued vectors.</span>

    <span class="s0">.. math::</span>
       <span class="s0">D(x, y) = \frac{\sum_i |x_i - y_i|}{\sum_i(|x_i| + |y_i|)}</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef inline {{INPUT_DTYPE_t}} dist(</span>
        <span class="s0">self,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x1,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x2,</span>
        <span class="s0">intp_t size,</span>
    <span class="s0">) except -1 nogil:</span>
        <span class="s0">cdef float64_t num = 0, denom = 0</span>
        <span class="s0">cdef intp_t j</span>
        <span class="s0">for j in range(size):</span>
            <span class="s0">num += fabs(x1[j] - x2[j])</span>
            <span class="s0">denom += fabs(x1[j]) + fabs(x2[j])</span>
        <span class="s0">if denom &gt; 0:</span>
            <span class="s0">return num / denom</span>
        <span class="s0">else:</span>
            <span class="s0">return 0.0</span>

    <span class="s0">cdef inline {{INPUT_DTYPE_t}} dist_csr(</span>
        <span class="s0">self,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x1_data,</span>
        <span class="s0">const int32_t* x1_indices,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x2_data,</span>
        <span class="s0">const int32_t* x2_indices,</span>
        <span class="s0">const int32_t x1_start,</span>
        <span class="s0">const int32_t x1_end,</span>
        <span class="s0">const int32_t x2_start,</span>
        <span class="s0">const int32_t x2_end,</span>
        <span class="s0">const intp_t size,</span>
    <span class="s0">) except -1 nogil:</span>

        <span class="s0">cdef:</span>
            <span class="s0">intp_t ix1, ix2</span>
            <span class="s0">intp_t i1 = x1_start</span>
            <span class="s0">intp_t i2 = x2_start</span>

            <span class="s0">float64_t num = 0.0</span>
            <span class="s0">float64_t denom = 0.0</span>

        <span class="s0">while i1 &lt; x1_end and i2 &lt; x2_end:</span>
            <span class="s0">ix1 = x1_indices[i1]</span>
            <span class="s0">ix2 = x2_indices[i2]</span>

            <span class="s0">if ix1 == ix2:</span>
                <span class="s0">num += fabs(x1_data[i1] - x2_data[i2])</span>
                <span class="s0">denom += fabs(x1_data[i1]) + fabs(x2_data[i2])</span>
                <span class="s0">i1 = i1 + 1</span>
                <span class="s0">i2 = i2 + 1</span>
            <span class="s0">elif ix1 &lt; ix2:</span>
                <span class="s0">num += fabs(x1_data[i1])</span>
                <span class="s0">denom += fabs(x1_data[i1])</span>
                <span class="s0">i1 = i1 + 1</span>
            <span class="s0">else:</span>
                <span class="s0">num += fabs(x2_data[i2])</span>
                <span class="s0">denom += fabs(x2_data[i2])</span>
                <span class="s0">i2 = i2 + 1</span>

        <span class="s0">if i1 == x1_end:</span>
            <span class="s0">while i2 &lt; x2_end:</span>
                <span class="s0">num += fabs(x1_data[i1])</span>
                <span class="s0">denom += fabs(x1_data[i1])</span>
                <span class="s0">i2 = i2 + 1</span>
        <span class="s0">else:</span>
            <span class="s0">while i1 &lt; x1_end:</span>
                <span class="s0">num += fabs(x2_data[i2])</span>
                <span class="s0">denom += fabs(x2_data[i2])</span>
                <span class="s0">i1 = i1 + 1</span>

        <span class="s0">return num / denom</span>

<span class="s0">#------------------------------------------------------------</span>
<span class="s0"># Jaccard Distance (boolean)</span>
<span class="s0">#  D(x, y) = N_unequal(x, y) / N_nonzero(x, y)</span>
<span class="s0">cdef class JaccardDistance{{name_suffix}}(DistanceMetric{{name_suffix}}):</span>
    <span class="s0">r&quot;&quot;&quot;Jaccard Distance</span>

    <span class="s0">Jaccard Distance is a dissimilarity measure for boolean-valued</span>
    <span class="s0">vectors. All nonzero entries will be treated as True, zero entries will</span>
    <span class="s0">be treated as False.</span>

        <span class="s0">D(x, y) = (N_TF + N_FT) / (N_TT + N_TF + N_FT)</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef inline {{INPUT_DTYPE_t}} dist(</span>
        <span class="s0">self,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x1,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x2,</span>
        <span class="s0">intp_t size,</span>
    <span class="s0">) except -1 nogil:</span>
        <span class="s0">cdef int tf1, tf2, n_eq = 0, nnz = 0</span>
        <span class="s0">cdef intp_t j</span>
        <span class="s0">for j in range(size):</span>
            <span class="s0">tf1 = x1[j] != 0</span>
            <span class="s0">tf2 = x2[j] != 0</span>
            <span class="s0">nnz += (tf1 or tf2)</span>
            <span class="s0">n_eq += (tf1 and tf2)</span>
        <span class="s0"># Based on https://github.com/scipy/scipy/pull/7373</span>
        <span class="s0"># When comparing two all-zero vectors, scipy&gt;=1.2.0 jaccard metric</span>
        <span class="s0"># was changed to return 0, instead of nan.</span>
        <span class="s0">if nnz == 0:</span>
            <span class="s0">return 0</span>
        <span class="s0">return (nnz - n_eq) * 1.0 / nnz</span>

    <span class="s0">cdef inline {{INPUT_DTYPE_t}} dist_csr(</span>
        <span class="s0">self,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x1_data,</span>
        <span class="s0">const int32_t* x1_indices,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x2_data,</span>
        <span class="s0">const int32_t* x2_indices,</span>
        <span class="s0">const int32_t x1_start,</span>
        <span class="s0">const int32_t x1_end,</span>
        <span class="s0">const int32_t x2_start,</span>
        <span class="s0">const int32_t x2_end,</span>
        <span class="s0">const intp_t size,</span>
    <span class="s0">) except -1 nogil:</span>

        <span class="s0">cdef:</span>
            <span class="s0">intp_t ix1, ix2</span>
            <span class="s0">intp_t i1 = x1_start</span>
            <span class="s0">intp_t i2 = x2_start</span>

            <span class="s0">intp_t tf1, tf2, n_tt = 0, nnz = 0</span>

        <span class="s0">while i1 &lt; x1_end and i2 &lt; x2_end:</span>
            <span class="s0">ix1 = x1_indices[i1]</span>
            <span class="s0">ix2 = x2_indices[i2]</span>

            <span class="s0">tf1 = x1_data[i1] != 0</span>
            <span class="s0">tf2 = x2_data[i2] != 0</span>

            <span class="s0">if ix1 == ix2:</span>
                <span class="s0">nnz += (tf1 or tf2)</span>
                <span class="s0">n_tt += (tf1 and tf2)</span>
                <span class="s0">i1 = i1 + 1</span>
                <span class="s0">i2 = i2 + 1</span>
            <span class="s0">elif ix1 &lt; ix2:</span>
                <span class="s0">nnz += tf1</span>
                <span class="s0">i1 = i1 + 1</span>
            <span class="s0">else:</span>
                <span class="s0">nnz += tf2</span>
                <span class="s0">i2 = i2 + 1</span>

        <span class="s0">if i1 == x1_end:</span>
            <span class="s0">while i2 &lt; x2_end:</span>
                <span class="s0">tf2 = x2_data[i2] != 0</span>
                <span class="s0">nnz += tf2</span>
                <span class="s0">i2 = i2 + 1</span>
        <span class="s0">else:</span>
            <span class="s0">while i1 &lt; x1_end:</span>
                <span class="s0">tf1 = x1_data[i1] != 0</span>
                <span class="s0">nnz += tf1</span>
                <span class="s0">i1 = i1 + 1</span>

        <span class="s0"># Based on https://github.com/scipy/scipy/pull/7373</span>
        <span class="s0"># When comparing two all-zero vectors, scipy&gt;=1.2.0 jaccard metric</span>
        <span class="s0"># was changed to return 0, instead of nan.</span>
        <span class="s0">if nnz == 0:</span>
            <span class="s0">return 0</span>
        <span class="s0">return (nnz - n_tt) * 1.0 / nnz</span>

<span class="s0">#------------------------------------------------------------</span>
<span class="s0"># Matching Distance (boolean)</span>
<span class="s0">#  D(x, y) = n_neq / n</span>
<span class="s0">cdef class MatchingDistance{{name_suffix}}(DistanceMetric{{name_suffix}}):</span>
    <span class="s0">r&quot;&quot;&quot;Matching Distance</span>

    <span class="s0">Matching Distance is a dissimilarity measure for boolean-valued</span>
    <span class="s0">vectors. All nonzero entries will be treated as True, zero entries will</span>
    <span class="s0">be treated as False.</span>

        <span class="s0">D(x, y) = (N_TF + N_FT) / N</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef inline {{INPUT_DTYPE_t}} dist(</span>
        <span class="s0">self,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x1,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x2,</span>
        <span class="s0">intp_t size,</span>
    <span class="s0">) except -1 nogil:</span>
        <span class="s0">cdef int tf1, tf2, n_neq = 0</span>
        <span class="s0">cdef intp_t j</span>
        <span class="s0">for j in range(size):</span>
            <span class="s0">tf1 = x1[j] != 0</span>
            <span class="s0">tf2 = x2[j] != 0</span>
            <span class="s0">n_neq += (tf1 != tf2)</span>
        <span class="s0">return n_neq * 1. / size</span>

    <span class="s0">cdef inline {{INPUT_DTYPE_t}} dist_csr(</span>
        <span class="s0">self,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x1_data,</span>
        <span class="s0">const int32_t* x1_indices,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x2_data,</span>
        <span class="s0">const int32_t* x2_indices,</span>
        <span class="s0">const int32_t x1_start,</span>
        <span class="s0">const int32_t x1_end,</span>
        <span class="s0">const int32_t x2_start,</span>
        <span class="s0">const int32_t x2_end,</span>
        <span class="s0">const intp_t size,</span>
    <span class="s0">) except -1 nogil:</span>

        <span class="s0">cdef:</span>
            <span class="s0">intp_t ix1, ix2</span>
            <span class="s0">intp_t i1 = x1_start</span>
            <span class="s0">intp_t i2 = x2_start</span>

            <span class="s0">intp_t tf1, tf2, n_neq = 0</span>

        <span class="s0">while i1 &lt; x1_end and i2 &lt; x2_end:</span>
            <span class="s0">ix1 = x1_indices[i1]</span>
            <span class="s0">ix2 = x2_indices[i2]</span>

            <span class="s0">if ix1 == ix2:</span>
                <span class="s0">tf1 = x1_data[i1] != 0</span>
                <span class="s0">tf2 = x2_data[i2] != 0</span>
                <span class="s0">n_neq += (tf1 != tf2)</span>
                <span class="s0">i1 = i1 + 1</span>
                <span class="s0">i2 = i2 + 1</span>
            <span class="s0">elif ix1 &lt; ix2:</span>
                <span class="s0">n_neq += (x1_data[i1] != 0)</span>
                <span class="s0">i1 = i1 + 1</span>
            <span class="s0">else:</span>
                <span class="s0">n_neq += (x2_data[i2] != 0)</span>
                <span class="s0">i2 = i2 + 1</span>

        <span class="s0">if i1 == x1_end:</span>
            <span class="s0">while i2 &lt; x2_end:</span>
                <span class="s0">n_neq += (x2_data[i2] != 0)</span>
                <span class="s0">i2 = i2 + 1</span>
        <span class="s0">else:</span>
            <span class="s0">while i1 &lt; x1_end:</span>
                <span class="s0">n_neq += (x1_data[i1] != 0)</span>
                <span class="s0">i1 = i1 + 1</span>

        <span class="s0">return n_neq * 1.0 / size</span>

<span class="s0">#------------------------------------------------------------</span>
<span class="s0"># Dice Distance (boolean)</span>
<span class="s0">#  D(x, y) = n_neq / (2 * ntt + n_neq)</span>
<span class="s0">cdef class DiceDistance{{name_suffix}}(DistanceMetric{{name_suffix}}):</span>
    <span class="s0">r&quot;&quot;&quot;Dice Distance</span>

    <span class="s0">Dice Distance is a dissimilarity measure for boolean-valued</span>
    <span class="s0">vectors. All nonzero entries will be treated as True, zero entries will</span>
    <span class="s0">be treated as False.</span>

        <span class="s0">D(x, y) = (N_TF + N_FT) / (2 * N_TT + N_TF + N_FT)</span>

    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef inline {{INPUT_DTYPE_t}} dist(</span>
        <span class="s0">self,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x1,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x2,</span>
        <span class="s0">intp_t size,</span>
    <span class="s0">) except -1 nogil:</span>
        <span class="s0">cdef int tf1, tf2, n_neq = 0, n_tt = 0</span>
        <span class="s0">cdef intp_t j</span>
        <span class="s0">for j in range(size):</span>
            <span class="s0">tf1 = x1[j] != 0</span>
            <span class="s0">tf2 = x2[j] != 0</span>
            <span class="s0">n_tt += (tf1 and tf2)</span>
            <span class="s0">n_neq += (tf1 != tf2)</span>
        <span class="s0">return n_neq / (2.0 * n_tt + n_neq)</span>

    <span class="s0">cdef inline {{INPUT_DTYPE_t}} dist_csr(</span>
        <span class="s0">self,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x1_data,</span>
        <span class="s0">const int32_t* x1_indices,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x2_data,</span>
        <span class="s0">const int32_t* x2_indices,</span>
        <span class="s0">const int32_t x1_start,</span>
        <span class="s0">const int32_t x1_end,</span>
        <span class="s0">const int32_t x2_start,</span>
        <span class="s0">const int32_t x2_end,</span>
        <span class="s0">const intp_t size,</span>
    <span class="s0">) except -1 nogil:</span>

        <span class="s0">cdef:</span>
            <span class="s0">intp_t ix1, ix2</span>
            <span class="s0">intp_t i1 = x1_start</span>
            <span class="s0">intp_t i2 = x2_start</span>

            <span class="s0">intp_t tf1, tf2, n_tt = 0, n_neq = 0</span>

        <span class="s0">while i1 &lt; x1_end and i2 &lt; x2_end:</span>
            <span class="s0">ix1 = x1_indices[i1]</span>
            <span class="s0">ix2 = x2_indices[i2]</span>

            <span class="s0">tf1 = x1_data[i1] != 0</span>
            <span class="s0">tf2 = x2_data[i2] != 0</span>

            <span class="s0">if ix1 == ix2:</span>
                <span class="s0">n_tt += (tf1 and tf2)</span>
                <span class="s0">n_neq += (tf1 != tf2)</span>
                <span class="s0">i1 = i1 + 1</span>
                <span class="s0">i2 = i2 + 1</span>
            <span class="s0">elif ix1 &lt; ix2:</span>
                <span class="s0">n_neq += tf1</span>
                <span class="s0">i1 = i1 + 1</span>
            <span class="s0">else:</span>
                <span class="s0">n_neq += tf2</span>
                <span class="s0">i2 = i2 + 1</span>

        <span class="s0">if i1 == x1_end:</span>
            <span class="s0">while i2 &lt; x2_end:</span>
                <span class="s0">tf2 = x2_data[i2] != 0</span>
                <span class="s0">n_neq += tf2</span>
                <span class="s0">i2 = i2 + 1</span>
        <span class="s0">else:</span>
            <span class="s0">while i1 &lt; x1_end:</span>
                <span class="s0">tf1 = x1_data[i1] != 0</span>
                <span class="s0">n_neq += tf1</span>
                <span class="s0">i1 = i1 + 1</span>

        <span class="s0">return n_neq / (2.0 * n_tt + n_neq)</span>


<span class="s0">#------------------------------------------------------------</span>
<span class="s0"># Kulsinski Distance (boolean)</span>
<span class="s0">#  D(x, y) = (ntf + nft - ntt + n) / (n_neq + n)</span>
<span class="s0">cdef class KulsinskiDistance{{name_suffix}}(DistanceMetric{{name_suffix}}):</span>
    <span class="s0">r&quot;&quot;&quot;Kulsinski Distance</span>

    <span class="s0">Kulsinski Distance is a dissimilarity measure for boolean-valued</span>
    <span class="s0">vectors. All nonzero entries will be treated as True, zero entries will</span>
    <span class="s0">be treated as False.</span>

        <span class="s0">D(x, y) = 1 - N_TT / (N + N_TF + N_FT)</span>

    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef inline {{INPUT_DTYPE_t}} dist(</span>
        <span class="s0">self,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x1,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x2,</span>
        <span class="s0">intp_t size,</span>
    <span class="s0">) except -1 nogil:</span>
        <span class="s0">cdef int tf1, tf2, n_tt = 0, n_neq = 0</span>
        <span class="s0">cdef intp_t j</span>
        <span class="s0">for j in range(size):</span>
            <span class="s0">tf1 = x1[j] != 0</span>
            <span class="s0">tf2 = x2[j] != 0</span>
            <span class="s0">n_neq += (tf1 != tf2)</span>
            <span class="s0">n_tt += (tf1 and tf2)</span>
        <span class="s0">return (n_neq - n_tt + size) * 1.0 / (n_neq + size)</span>

    <span class="s0">cdef inline {{INPUT_DTYPE_t}} dist_csr(</span>
        <span class="s0">self,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x1_data,</span>
        <span class="s0">const int32_t* x1_indices,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x2_data,</span>
        <span class="s0">const int32_t* x2_indices,</span>
        <span class="s0">const int32_t x1_start,</span>
        <span class="s0">const int32_t x1_end,</span>
        <span class="s0">const int32_t x2_start,</span>
        <span class="s0">const int32_t x2_end,</span>
        <span class="s0">const intp_t size,</span>
    <span class="s0">) except -1 nogil:</span>

        <span class="s0">cdef:</span>
            <span class="s0">intp_t ix1, ix2</span>
            <span class="s0">intp_t i1 = x1_start</span>
            <span class="s0">intp_t i2 = x2_start</span>

            <span class="s0">intp_t tf1, tf2, n_tt = 0, n_neq = 0</span>

        <span class="s0">while i1 &lt; x1_end and i2 &lt; x2_end:</span>
            <span class="s0">ix1 = x1_indices[i1]</span>
            <span class="s0">ix2 = x2_indices[i2]</span>

            <span class="s0">tf1 = x1_data[i1] != 0</span>
            <span class="s0">tf2 = x2_data[i2] != 0</span>

            <span class="s0">if ix1 == ix2:</span>
                <span class="s0">n_tt += (tf1 and tf2)</span>
                <span class="s0">n_neq += (tf1 != tf2)</span>
                <span class="s0">i1 = i1 + 1</span>
                <span class="s0">i2 = i2 + 1</span>
            <span class="s0">elif ix1 &lt; ix2:</span>
                <span class="s0">n_neq += tf1</span>
                <span class="s0">i1 = i1 + 1</span>
            <span class="s0">else:</span>
                <span class="s0">n_neq += tf2</span>
                <span class="s0">i2 = i2 + 1</span>

        <span class="s0">if i1 == x1_end:</span>
            <span class="s0">while i2 &lt; x2_end:</span>
                <span class="s0">tf2 = x2_data[i2] != 0</span>
                <span class="s0">n_neq += tf2</span>
                <span class="s0">i2 = i2 + 1</span>
        <span class="s0">else:</span>
            <span class="s0">while i1 &lt; x1_end:</span>
                <span class="s0">tf1 = x1_data[i1] != 0</span>
                <span class="s0">n_neq += tf1</span>
                <span class="s0">i1 = i1 + 1</span>

        <span class="s0">return (n_neq - n_tt + size) * 1.0 / (n_neq + size)</span>

<span class="s0">#------------------------------------------------------------</span>
<span class="s0"># Rogers-Tanimoto Distance (boolean)</span>
<span class="s0">#  D(x, y) = 2 * n_neq / (n + n_neq)</span>
<span class="s0">cdef class RogersTanimotoDistance{{name_suffix}}(DistanceMetric{{name_suffix}}):</span>
    <span class="s0">r&quot;&quot;&quot;Rogers-Tanimoto Distance</span>

    <span class="s0">Rogers-Tanimoto Distance is a dissimilarity measure for boolean-valued</span>
    <span class="s0">vectors. All nonzero entries will be treated as True, zero entries will</span>
    <span class="s0">be treated as False.</span>

        <span class="s0">D(x, y) = 2 (N_TF + N_FT) / (N + N_TF + N_FT)</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef inline {{INPUT_DTYPE_t}} dist(</span>
        <span class="s0">self,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x1,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x2,</span>
        <span class="s0">intp_t size,</span>
    <span class="s0">) except -1 nogil:</span>
        <span class="s0">cdef int tf1, tf2, n_neq = 0</span>
        <span class="s0">cdef intp_t j</span>
        <span class="s0">for j in range(size):</span>
            <span class="s0">tf1 = x1[j] != 0</span>
            <span class="s0">tf2 = x2[j] != 0</span>
            <span class="s0">n_neq += (tf1 != tf2)</span>
        <span class="s0">return (2.0 * n_neq) / (size + n_neq)</span>

    <span class="s0">cdef inline {{INPUT_DTYPE_t}} dist_csr(</span>
        <span class="s0">self,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x1_data,</span>
        <span class="s0">const int32_t* x1_indices,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x2_data,</span>
        <span class="s0">const int32_t* x2_indices,</span>
        <span class="s0">const int32_t x1_start,</span>
        <span class="s0">const int32_t x1_end,</span>
        <span class="s0">const int32_t x2_start,</span>
        <span class="s0">const int32_t x2_end,</span>
        <span class="s0">const intp_t size,</span>
    <span class="s0">) except -1 nogil:</span>

        <span class="s0">cdef:</span>
            <span class="s0">intp_t ix1, ix2</span>
            <span class="s0">intp_t i1 = x1_start</span>
            <span class="s0">intp_t i2 = x2_start</span>

            <span class="s0">intp_t tf1, tf2, n_neq = 0</span>

        <span class="s0">while i1 &lt; x1_end and i2 &lt; x2_end:</span>
            <span class="s0">ix1 = x1_indices[i1]</span>
            <span class="s0">ix2 = x2_indices[i2]</span>

            <span class="s0">tf1 = x1_data[i1] != 0</span>
            <span class="s0">tf2 = x2_data[i2] != 0</span>

            <span class="s0">if ix1 == ix2:</span>
                <span class="s0">n_neq += (tf1 != tf2)</span>
                <span class="s0">i1 = i1 + 1</span>
                <span class="s0">i2 = i2 + 1</span>
            <span class="s0">elif ix1 &lt; ix2:</span>
                <span class="s0">n_neq += tf1</span>
                <span class="s0">i1 = i1 + 1</span>
            <span class="s0">else:</span>
                <span class="s0">n_neq += tf2</span>
                <span class="s0">i2 = i2 + 1</span>

        <span class="s0">if i1 == x1_end:</span>
            <span class="s0">while i2 &lt; x2_end:</span>
                <span class="s0">tf2 = x2_data[i2] != 0</span>
                <span class="s0">n_neq += tf2</span>
                <span class="s0">i2 = i2 + 1</span>
        <span class="s0">else:</span>
            <span class="s0">while i1 &lt; x1_end:</span>
                <span class="s0">tf1 = x1_data[i1] != 0</span>
                <span class="s0">n_neq += tf1</span>
                <span class="s0">i1 = i1 + 1</span>

        <span class="s0">return (2.0 * n_neq) / (size + n_neq)</span>

<span class="s0">#------------------------------------------------------------</span>
<span class="s0"># Russell-Rao Distance (boolean)</span>
<span class="s0">#  D(x, y) = (n - ntt) / n</span>
<span class="s0">cdef class RussellRaoDistance{{name_suffix}}(DistanceMetric{{name_suffix}}):</span>
    <span class="s0">r&quot;&quot;&quot;Russell-Rao Distance</span>

    <span class="s0">Russell-Rao Distance is a dissimilarity measure for boolean-valued</span>
    <span class="s0">vectors. All nonzero entries will be treated as True, zero entries will</span>
    <span class="s0">be treated as False.</span>

        <span class="s0">D(x, y) = (N - N_TT) / N</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef inline {{INPUT_DTYPE_t}} dist(</span>
        <span class="s0">self,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x1,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x2,</span>
        <span class="s0">intp_t size,</span>
    <span class="s0">) except -1 nogil:</span>
        <span class="s0">cdef int tf1, tf2, n_tt = 0</span>
        <span class="s0">cdef intp_t j</span>
        <span class="s0">for j in range(size):</span>
            <span class="s0">tf1 = x1[j] != 0</span>
            <span class="s0">tf2 = x2[j] != 0</span>
            <span class="s0">n_tt += (tf1 and tf2)</span>
        <span class="s0">return (size - n_tt) * 1. / size</span>

    <span class="s0">cdef inline {{INPUT_DTYPE_t}} dist_csr(</span>
        <span class="s0">self,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x1_data,</span>
        <span class="s0">const int32_t* x1_indices,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x2_data,</span>
        <span class="s0">const int32_t* x2_indices,</span>
        <span class="s0">const int32_t x1_start,</span>
        <span class="s0">const int32_t x1_end,</span>
        <span class="s0">const int32_t x2_start,</span>
        <span class="s0">const int32_t x2_end,</span>
        <span class="s0">const intp_t size,</span>
    <span class="s0">) except -1 nogil:</span>

        <span class="s0">cdef:</span>
            <span class="s0">intp_t ix1, ix2</span>
            <span class="s0">intp_t i1 = x1_start</span>
            <span class="s0">intp_t i2 = x2_start</span>

            <span class="s0">intp_t tf1, tf2, n_tt = 0</span>

        <span class="s0">while i1 &lt; x1_end and i2 &lt; x2_end:</span>
            <span class="s0">ix1 = x1_indices[i1]</span>
            <span class="s0">ix2 = x2_indices[i2]</span>

            <span class="s0">tf1 = x1_data[i1] != 0</span>
            <span class="s0">tf2 = x2_data[i2] != 0</span>

            <span class="s0">if ix1 == ix2:</span>
                <span class="s0">n_tt += (tf1 and tf2)</span>
                <span class="s0">i1 = i1 + 1</span>
                <span class="s0">i2 = i2 + 1</span>
            <span class="s0">elif ix1 &lt; ix2:</span>
                <span class="s0">i1 = i1 + 1</span>
            <span class="s0">else:</span>
                <span class="s0">i2 = i2 + 1</span>

        <span class="s0"># We don't need to go through all the longest</span>
        <span class="s0"># vector because tf1 or tf2 will be false</span>
        <span class="s0"># and thus n_tt won't be increased.</span>

        <span class="s0">return (size - n_tt) * 1. / size</span>



<span class="s0">#------------------------------------------------------------</span>
<span class="s0"># Sokal-Michener Distance (boolean)</span>
<span class="s0">#  D(x, y) = 2 * n_neq / (n + n_neq)</span>
<span class="s0">cdef class SokalMichenerDistance{{name_suffix}}(DistanceMetric{{name_suffix}}):</span>
    <span class="s0">r&quot;&quot;&quot;Sokal-Michener Distance</span>

    <span class="s0">Sokal-Michener Distance is a dissimilarity measure for boolean-valued</span>
    <span class="s0">vectors. All nonzero entries will be treated as True, zero entries will</span>
    <span class="s0">be treated as False.</span>

        <span class="s0">D(x, y) = 2 (N_TF + N_FT) / (N + N_TF + N_FT)</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef inline {{INPUT_DTYPE_t}} dist(</span>
        <span class="s0">self,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x1,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x2,</span>
        <span class="s0">intp_t size,</span>
    <span class="s0">) except -1 nogil:</span>
        <span class="s0">cdef int tf1, tf2, n_neq = 0</span>
        <span class="s0">cdef intp_t j</span>
        <span class="s0">for j in range(size):</span>
            <span class="s0">tf1 = x1[j] != 0</span>
            <span class="s0">tf2 = x2[j] != 0</span>
            <span class="s0">n_neq += (tf1 != tf2)</span>
        <span class="s0">return (2.0 * n_neq) / (size + n_neq)</span>

    <span class="s0">cdef inline {{INPUT_DTYPE_t}} dist_csr(</span>
        <span class="s0">self,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x1_data,</span>
        <span class="s0">const int32_t* x1_indices,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x2_data,</span>
        <span class="s0">const int32_t* x2_indices,</span>
        <span class="s0">const int32_t x1_start,</span>
        <span class="s0">const int32_t x1_end,</span>
        <span class="s0">const int32_t x2_start,</span>
        <span class="s0">const int32_t x2_end,</span>
        <span class="s0">const intp_t size,</span>
    <span class="s0">) except -1 nogil:</span>

        <span class="s0">cdef:</span>
            <span class="s0">intp_t ix1, ix2</span>
            <span class="s0">intp_t i1 = x1_start</span>
            <span class="s0">intp_t i2 = x2_start</span>

            <span class="s0">intp_t tf1, tf2, n_neq = 0</span>

        <span class="s0">while i1 &lt; x1_end and i2 &lt; x2_end:</span>
            <span class="s0">ix1 = x1_indices[i1]</span>
            <span class="s0">ix2 = x2_indices[i2]</span>

            <span class="s0">tf1 = x1_data[i1] != 0</span>
            <span class="s0">tf2 = x2_data[i2] != 0</span>

            <span class="s0">if ix1 == ix2:</span>
                <span class="s0">n_neq += (tf1 != tf2)</span>
                <span class="s0">i1 = i1 + 1</span>
                <span class="s0">i2 = i2 + 1</span>
            <span class="s0">elif ix1 &lt; ix2:</span>
                <span class="s0">n_neq += tf1</span>
                <span class="s0">i1 = i1 + 1</span>
            <span class="s0">else:</span>
                <span class="s0">n_neq += tf2</span>
                <span class="s0">i2 = i2 + 1</span>

        <span class="s0">if i1 == x1_end:</span>
            <span class="s0">while i2 &lt; x2_end:</span>
                <span class="s0">tf2 = x2_data[i2] != 0</span>
                <span class="s0">n_neq += tf2</span>
                <span class="s0">i2 = i2 + 1</span>
        <span class="s0">else:</span>
            <span class="s0">while i1 &lt; x1_end:</span>
                <span class="s0">tf1 = x1_data[i1] != 0</span>
                <span class="s0">n_neq += tf1</span>
                <span class="s0">i1 = i1 + 1</span>

        <span class="s0">return (2.0 * n_neq) / (size + n_neq)</span>

<span class="s0">#------------------------------------------------------------</span>
<span class="s0"># Sokal-Sneath Distance (boolean)</span>
<span class="s0">#  D(x, y) = n_neq / (0.5 * n_tt + n_neq)</span>
<span class="s0">cdef class SokalSneathDistance{{name_suffix}}(DistanceMetric{{name_suffix}}):</span>
    <span class="s0">r&quot;&quot;&quot;Sokal-Sneath Distance</span>

    <span class="s0">Sokal-Sneath Distance is a dissimilarity measure for boolean-valued</span>
    <span class="s0">vectors. All nonzero entries will be treated as True, zero entries will</span>
    <span class="s0">be treated as False.</span>

        <span class="s0">D(x, y) = (N_TF + N_FT) / (N_TT / 2 + N_FT + N_TF)</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">cdef inline {{INPUT_DTYPE_t}} dist(</span>
        <span class="s0">self,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x1,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x2,</span>
        <span class="s0">intp_t size,</span>
    <span class="s0">) except -1 nogil:</span>
        <span class="s0">cdef int tf1, tf2, n_tt = 0, n_neq = 0</span>
        <span class="s0">cdef intp_t j</span>
        <span class="s0">for j in range(size):</span>
            <span class="s0">tf1 = x1[j] != 0</span>
            <span class="s0">tf2 = x2[j] != 0</span>
            <span class="s0">n_neq += (tf1 != tf2)</span>
            <span class="s0">n_tt += (tf1 and tf2)</span>
        <span class="s0">return n_neq / (0.5 * n_tt + n_neq)</span>

    <span class="s0">cdef inline {{INPUT_DTYPE_t}} dist_csr(</span>
        <span class="s0">self,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x1_data,</span>
        <span class="s0">const int32_t* x1_indices,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x2_data,</span>
        <span class="s0">const int32_t* x2_indices,</span>
        <span class="s0">const int32_t x1_start,</span>
        <span class="s0">const int32_t x1_end,</span>
        <span class="s0">const int32_t x2_start,</span>
        <span class="s0">const int32_t x2_end,</span>
        <span class="s0">const intp_t size,</span>
    <span class="s0">) except -1 nogil:</span>

        <span class="s0">cdef:</span>
            <span class="s0">intp_t ix1, ix2</span>
            <span class="s0">intp_t i1 = x1_start</span>
            <span class="s0">intp_t i2 = x2_start</span>

            <span class="s0">intp_t tf1, tf2, n_tt = 0, n_neq = 0</span>

        <span class="s0">while i1 &lt; x1_end and i2 &lt; x2_end:</span>
            <span class="s0">ix1 = x1_indices[i1]</span>
            <span class="s0">ix2 = x2_indices[i2]</span>

            <span class="s0">tf1 = x1_data[i1] != 0</span>
            <span class="s0">tf2 = x2_data[i2] != 0</span>

            <span class="s0">if ix1 == ix2:</span>
                <span class="s0">n_tt += (tf1 and tf2)</span>
                <span class="s0">n_neq += (tf1 != tf2)</span>
                <span class="s0">i1 = i1 + 1</span>
                <span class="s0">i2 = i2 + 1</span>
            <span class="s0">elif ix1 &lt; ix2:</span>
                <span class="s0">n_neq += tf1</span>
                <span class="s0">i1 = i1 + 1</span>
            <span class="s0">else:</span>
                <span class="s0">n_neq += tf2</span>
                <span class="s0">i2 = i2 + 1</span>

        <span class="s0">if i1 == x1_end:</span>
            <span class="s0">while i2 &lt; x2_end:</span>
                <span class="s0">tf2 = x2_data[i2] != 0</span>
                <span class="s0">n_neq += tf2</span>
                <span class="s0">i2 = i2 + 1</span>
        <span class="s0">else:</span>
            <span class="s0">while i1 &lt; x1_end:</span>
                <span class="s0">tf1 = x1_data[i1] != 0</span>
                <span class="s0">n_neq += tf1</span>
                <span class="s0">i1 = i1 + 1</span>

        <span class="s0">return n_neq / (0.5 * n_tt + n_neq)</span>


<span class="s0">#------------------------------------------------------------</span>
<span class="s0"># Haversine Distance (2 dimensional)</span>
<span class="s0">#  D(x, y) = 2 arcsin{sqrt[sin^2 ((x1 - y1) / 2)</span>
<span class="s0">#                          + cos(x1) cos(y1) sin^2 ((x2 - y2) / 2)]}</span>
<span class="s0">cdef class HaversineDistance{{name_suffix}}(DistanceMetric{{name_suffix}}):</span>
    <span class="s0">&quot;&quot;&quot;Haversine (Spherical) Distance</span>

    <span class="s0">The Haversine distance is the angular distance between two points on</span>
    <span class="s0">the surface of a sphere.  The first distance of each point is assumed</span>
    <span class="s0">to be the latitude, the second is the longitude, given in radians.</span>
    <span class="s0">The dimension of the points must be 2:</span>

    <span class="s0">D(x, y) = 2 arcsin[sqrt{sin^2((x1 - y1) / 2) + cos(x1)cos(y1)sin^2((x2 - y2) / 2)}]</span>

    <span class="s0">&quot;&quot;&quot;</span>

    <span class="s0">def _validate_data(self, X):</span>
        <span class="s0">if X.shape[1] != 2:</span>
            <span class="s0">raise ValueError(&quot;Haversine distance only valid &quot;</span>
                             <span class="s0">&quot;in 2 dimensions&quot;)</span>

    <span class="s0">cdef inline {{INPUT_DTYPE_t}} rdist(self,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x1,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x2,</span>
        <span class="s0">intp_t size,</span>
    <span class="s0">) except -1 nogil:</span>
        <span class="s0">cdef float64_t sin_0 = sin(0.5 * ((x1[0]) - (x2[0])))</span>
        <span class="s0">cdef float64_t sin_1 = sin(0.5 * ((x1[1]) - (x2[1])))</span>
        <span class="s0">return (sin_0 * sin_0 + cos(x1[0]) * cos(x2[0]) * sin_1 * sin_1)</span>

    <span class="s0">cdef inline {{INPUT_DTYPE_t}} dist(self,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x1,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x2,</span>
        <span class="s0">intp_t size,</span>
    <span class="s0">) except -1 nogil:</span>
        <span class="s0">return 2 * asin(sqrt(self.rdist(x1, x2, size)))</span>

    <span class="s0">cdef inline {{INPUT_DTYPE_t}} _rdist_to_dist(self, {{INPUT_DTYPE_t}} rdist) except -1 nogil:</span>
        <span class="s0">return 2 * asin(sqrt(rdist))</span>

    <span class="s0">cdef inline {{INPUT_DTYPE_t}} _dist_to_rdist(self, {{INPUT_DTYPE_t}} dist) except -1 nogil:</span>
        <span class="s0">cdef float64_t tmp = sin(0.5 *  dist)</span>
        <span class="s0">return tmp * tmp</span>

    <span class="s0">def rdist_to_dist(self, rdist):</span>
        <span class="s0">return 2 * np.arcsin(np.sqrt(rdist))</span>

    <span class="s0">def dist_to_rdist(self, dist):</span>
        <span class="s0">tmp = np.sin(0.5 * dist)</span>
        <span class="s0">return tmp * tmp</span>

    <span class="s0">cdef inline {{INPUT_DTYPE_t}} dist_csr(</span>
        <span class="s0">self,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x1_data,</span>
        <span class="s0">const int32_t* x1_indices,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x2_data,</span>
        <span class="s0">const int32_t* x2_indices,</span>
        <span class="s0">const int32_t x1_start,</span>
        <span class="s0">const int32_t x1_end,</span>
        <span class="s0">const int32_t x2_start,</span>
        <span class="s0">const int32_t x2_end,</span>
        <span class="s0">const intp_t size,</span>
    <span class="s0">) except -1 nogil:</span>
        <span class="s0">return 2 * asin(sqrt(self.rdist_csr(</span>
            <span class="s0">x1_data,</span>
            <span class="s0">x1_indices,</span>
            <span class="s0">x2_data,</span>
            <span class="s0">x2_indices,</span>
            <span class="s0">x1_start,</span>
            <span class="s0">x1_end,</span>
            <span class="s0">x2_start,</span>
            <span class="s0">x2_end,</span>
            <span class="s0">size,</span>
        <span class="s0">)))</span>

    <span class="s0">cdef inline {{INPUT_DTYPE_t}} rdist_csr(</span>
        <span class="s0">self,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x1_data,</span>
        <span class="s0">const int32_t* x1_indices,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x2_data,</span>
        <span class="s0">const int32_t* x2_indices,</span>
        <span class="s0">const int32_t x1_start,</span>
        <span class="s0">const int32_t x1_end,</span>
        <span class="s0">const int32_t x2_start,</span>
        <span class="s0">const int32_t x2_end,</span>
        <span class="s0">const intp_t size,</span>
    <span class="s0">) except -1 nogil:</span>

        <span class="s0">cdef:</span>
            <span class="s0">intp_t ix1, ix2</span>
            <span class="s0">intp_t i1 = x1_start</span>
            <span class="s0">intp_t i2 = x2_start</span>

            <span class="s0">float64_t x1_0 = 0</span>
            <span class="s0">float64_t x1_1 = 0</span>
            <span class="s0">float64_t x2_0 = 0</span>
            <span class="s0">float64_t x2_1 = 0</span>
            <span class="s0">float64_t sin_0</span>
            <span class="s0">float64_t sin_1</span>

        <span class="s0">while i1 &lt; x1_end and i2 &lt; x2_end:</span>
            <span class="s0">ix1 = x1_indices[i1]</span>
            <span class="s0">ix2 = x2_indices[i2]</span>

            <span class="s0"># Find the components in the 2D vectors to work with</span>
            <span class="s0">x1_component = ix1 if (x1_start == 0) else ix1 % x1_start</span>
            <span class="s0">x2_component = ix2 if (x2_start == 0) else ix2 % x2_start</span>

            <span class="s0">if x1_component == 0:</span>
                <span class="s0">x1_0 = x1_data[i1]</span>
            <span class="s0">else:</span>
                <span class="s0">x1_1 = x1_data[i1]</span>

            <span class="s0">if x2_component == 0:</span>
                <span class="s0">x2_0 = x2_data[i2]</span>
            <span class="s0">else:</span>
                <span class="s0">x2_1 = x2_data[i2]</span>

            <span class="s0">i1 = i1 + 1</span>
            <span class="s0">i2 = i2 + 1</span>

        <span class="s0">if i1 == x1_end:</span>
            <span class="s0">while i2 &lt; x2_end:</span>
                <span class="s0">ix2 = x2_indices[i2]</span>
                <span class="s0">x2_component = ix2 if (x2_start == 0) else ix2 % x2_start</span>
                <span class="s0">if x2_component == 0:</span>
                    <span class="s0">x2_0 = x2_data[i2]</span>
                <span class="s0">else:</span>
                    <span class="s0">x2_1 = x2_data[i2]</span>
                <span class="s0">i2 = i2 + 1</span>
        <span class="s0">else:</span>
            <span class="s0">while i1 &lt; x1_end:</span>
                <span class="s0">ix1 = x1_indices[i1]</span>
                <span class="s0">x1_component = ix1 if (x1_start == 0) else ix1 % x1_start</span>
                <span class="s0">if x1_component == 0:</span>
                    <span class="s0">x1_0 = x1_data[i1]</span>
                <span class="s0">else:</span>
                    <span class="s0">x1_1 = x1_data[i1]</span>
                <span class="s0">i1 = i1 + 1</span>

        <span class="s0">sin_0 = sin(0.5 * (x1_0 - x2_0))</span>
        <span class="s0">sin_1 = sin(0.5 * (x1_1 - x2_1))</span>

        <span class="s0">return (sin_0 * sin_0 + cos(x1_0) * cos(x2_0) * sin_1 * sin_1)</span>

<span class="s0">#------------------------------------------------------------</span>
<span class="s0"># User-defined distance</span>
<span class="s0">#</span>
<span class="s0">cdef class PyFuncDistance{{name_suffix}}(DistanceMetric{{name_suffix}}):</span>
    <span class="s0">&quot;&quot;&quot;PyFunc Distance</span>

    <span class="s0">A user-defined distance</span>

    <span class="s0">Parameters</span>
    <span class="s0">----------</span>
    <span class="s0">func : function</span>
        <span class="s0">func should take two numpy arrays as input, and return a distance.</span>
    <span class="s0">&quot;&quot;&quot;</span>
    <span class="s0">def __init__(self, func, **kwargs):</span>
        <span class="s0">self.func = func</span>
        <span class="s0">self.kwargs = kwargs</span>

    <span class="s0"># in cython &lt; 0.26, GIL was required to be acquired during definition of</span>
    <span class="s0"># the function and inside the body of the function. This behaviour is not</span>
    <span class="s0"># allowed in cython &gt;= 0.26 since it is a redundant GIL acquisition. The</span>
    <span class="s0"># only way to be back compatible is to inherit `dist` from the base class</span>
    <span class="s0"># without GIL and called an inline `_dist` which acquire GIL.</span>
    <span class="s0">cdef inline {{INPUT_DTYPE_t}} dist(</span>
        <span class="s0">self,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x1,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x2,</span>
        <span class="s0">intp_t size,</span>
    <span class="s0">) except -1 nogil:</span>
        <span class="s0">return self._dist(x1, x2, size)</span>

    <span class="s0">cdef inline {{INPUT_DTYPE_t}} _dist(</span>
        <span class="s0">self,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x1,</span>
        <span class="s0">const {{INPUT_DTYPE_t}}* x2,</span>
        <span class="s0">intp_t size,</span>
    <span class="s0">) except -1 with gil:</span>
        <span class="s0">cdef:</span>
            <span class="s0">object x1arr = _buffer_to_ndarray{{name_suffix}}(x1, size)</span>
            <span class="s0">object x2arr = _buffer_to_ndarray{{name_suffix}}(x2, size)</span>
        <span class="s0">d = self.func(x1arr, x2arr, **self.kwargs)</span>
        <span class="s0">try:</span>
            <span class="s0"># Cython generates code here that results in a TypeError</span>
            <span class="s0"># if d is the wrong type.</span>
            <span class="s0">return d</span>
        <span class="s0">except TypeError:</span>
            <span class="s0">raise TypeError(&quot;Custom distance function must accept two &quot;</span>
                            <span class="s0">&quot;vectors and return a float.&quot;)</span>

<span class="s0">{{endfor}}</span>
</pre>
</body>
</html>