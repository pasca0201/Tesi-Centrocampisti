<html>
<head>
<title>linear.cpp</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #6aab73;}
.s4 { color: #c77dbb;}
.s5 { color: #2aacb8;}
.s6 { color: #0da19e;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
linear.cpp</font>
</center></td></tr></table>
<pre><span class="s0">/* 
   Modified 2011: 
 
   - Make labels sorted in group_classes, Dan Yamins. 
 
   Modified 2012: 
 
   - Changes roles of +1 and -1 to match scikit API, Andreas Mueller 
        See issue 546: https://github.com/scikit-learn/scikit-learn/pull/546 
   - Also changed roles for pairwise class weights, Andreas Mueller 
        See issue 1491: https://github.com/scikit-learn/scikit-learn/pull/1491 
 
   Modified 2014: 
 
   - Remove the hard-coded value of max_iter (1000), that allows max_iter 
     to be passed as a parameter from the classes LogisticRegression and 
     LinearSVC, Manoj Kumar 
   - Added function get_n_iter that exposes the number of iterations. 
        See issue 3499: https://github.com/scikit-learn/scikit-learn/issues/3499 
        See pull 3501: https://github.com/scikit-learn/scikit-learn/pull/3501 
 
   Modified 2015: 
   - Patched liblinear for sample_weights - Manoj Kumar 
     See https://github.com/scikit-learn/scikit-learn/pull/5274 
 
   Modified 2020: 
   - Improved random number generator by using a mersenne twister + tweaked 
     lemire postprocessor. This fixed a convergence issue on windows targets. 
     Sylvain Marie, Schneider Electric 
     See &lt;https://github.com/scikit-learn/scikit-learn/pull/13511#issuecomment-481729756&gt; 
 
 */</span>

<span class="s2">#include </span><span class="s1">&lt;math.h&gt;</span>
<span class="s2">#include </span><span class="s1">&lt;stdio.h&gt;</span>
<span class="s2">#include </span><span class="s1">&lt;stdlib.h&gt;</span>
<span class="s2">#include </span><span class="s1">&lt;string.h&gt;</span>
<span class="s2">#include </span><span class="s1">&lt;stdarg.h&gt;</span>
<span class="s2">#include </span><span class="s1">&lt;locale.h&gt;</span>
<span class="s2">#include </span><span class="s3">&quot;linear.h&quot;</span>
<span class="s2">#include </span><span class="s3">&quot;tron.h&quot;</span>
<span class="s2">#include </span><span class="s1">&lt;climits&gt;</span>
<span class="s2">#include </span><span class="s1">&lt;random&gt;</span>
<span class="s2">#include </span><span class="s3">&quot;../newrand/newrand.h&quot;</span>

<span class="s2">typedef signed char </span><span class="s1">schar;</span>
<span class="s1">template &lt;</span><span class="s4">class </span><span class="s1">T&gt; </span><span class="s2">static </span><span class="s4">inline </span><span class="s2">void </span><span class="s1">swap(T&amp; x, T&amp; y) { T t=x; x=y; y=t; }</span>
<span class="s2">#ifndef </span><span class="s1">min</span>
<span class="s1">template &lt;</span><span class="s4">class </span><span class="s1">T&gt; </span><span class="s2">static </span><span class="s4">inline </span><span class="s1">T min(T x,T y) { </span><span class="s2">return </span><span class="s1">(x&lt;y)?x:y; }</span>
<span class="s2">#endif</span>
<span class="s2">#ifndef </span><span class="s1">max</span>
<span class="s1">template &lt;</span><span class="s4">class </span><span class="s1">T&gt; </span><span class="s2">static </span><span class="s4">inline </span><span class="s1">T max(T x,T y) { </span><span class="s2">return </span><span class="s1">(x&gt;y)?x:y; }</span>
<span class="s2">#endif</span>
<span class="s1">template &lt;</span><span class="s4">class </span><span class="s1">S, </span><span class="s4">class </span><span class="s1">T&gt; </span><span class="s2">static </span><span class="s4">inline </span><span class="s2">void </span><span class="s1">clone(T*&amp; dst, S* src, </span><span class="s2">int </span><span class="s1">n)</span>
<span class="s1">{</span>
	<span class="s1">dst = </span><span class="s4">new </span><span class="s1">T[n];</span>
	<span class="s1">memcpy((</span><span class="s2">void </span><span class="s1">*)dst,(</span><span class="s2">void </span><span class="s1">*)src,</span><span class="s2">sizeof</span><span class="s1">(T)*n);</span>
<span class="s1">}</span>
<span class="s2">#define </span><span class="s1">Malloc(type,n) (type *)malloc((n)*</span><span class="s2">sizeof</span><span class="s1">(type))</span>
<span class="s2">#define </span><span class="s1">INF HUGE_VAL</span>

<span class="s2">static void </span><span class="s1">print_string_stdout(</span><span class="s2">const char </span><span class="s1">*s)</span>
<span class="s1">{</span>
	<span class="s1">fputs(s,stdout);</span>
	<span class="s1">fflush(stdout);</span>
<span class="s1">}</span>

<span class="s2">static void </span><span class="s1">(*liblinear_print_string) (</span><span class="s2">const char </span><span class="s1">*) = &amp;print_string_stdout;</span>

<span class="s2">#if </span><span class="s5">1</span>
<span class="s2">static void </span><span class="s1">info(</span><span class="s2">const char </span><span class="s1">*fmt,...)</span>
<span class="s1">{</span>
	<span class="s2">char </span><span class="s1">buf[BUFSIZ];</span>
	<span class="s1">va_list ap;</span>
	<span class="s1">va_start(ap,fmt);</span>
	<span class="s1">vsprintf(buf,fmt,ap);</span>
	<span class="s1">va_end(ap);</span>
	<span class="s1">(*liblinear_print_string)(buf);</span>
<span class="s1">}</span>
<span class="s2">#else</span>
<span class="s2">static void </span><span class="s1">info(</span><span class="s2">const char </span><span class="s1">*fmt,...) {}</span>
<span class="s2">#endif</span>

<span class="s4">class </span><span class="s1">l2r_lr_fun: </span><span class="s4">public </span><span class="s1">function</span>
<span class="s1">{</span>
<span class="s4">public</span><span class="s1">:</span>
	<span class="s1">l2r_lr_fun(</span><span class="s2">const </span><span class="s1">problem *prob, </span><span class="s2">double </span><span class="s1">*C);</span>
	<span class="s1">~l2r_lr_fun();</span>

	<span class="s2">double </span><span class="s1">fun(</span><span class="s2">double </span><span class="s1">*w);</span>
	<span class="s2">void </span><span class="s1">grad(</span><span class="s2">double </span><span class="s1">*w, </span><span class="s2">double </span><span class="s1">*g);</span>
	<span class="s2">void </span><span class="s1">Hv(</span><span class="s2">double </span><span class="s1">*s, </span><span class="s2">double </span><span class="s1">*Hs);</span>

	<span class="s2">int </span><span class="s1">get_nr_variable(</span><span class="s2">void</span><span class="s1">);</span>

<span class="s4">private</span><span class="s1">:</span>
	<span class="s2">void </span><span class="s1">Xv(</span><span class="s2">double </span><span class="s1">*v, </span><span class="s2">double </span><span class="s1">*Xv);</span>
	<span class="s2">void </span><span class="s1">XTv(</span><span class="s2">double </span><span class="s1">*v, </span><span class="s2">double </span><span class="s1">*XTv);</span>

	<span class="s2">double </span><span class="s1">*C;</span>
	<span class="s2">double </span><span class="s1">*z;</span>
	<span class="s2">double </span><span class="s1">*D;</span>
	<span class="s2">const </span><span class="s1">problem *prob;</span>
<span class="s1">};</span>

<span class="s1">l2r_lr_fun::l2r_lr_fun(</span><span class="s2">const </span><span class="s1">problem *prob, </span><span class="s2">double </span><span class="s1">*C)</span>
<span class="s1">{</span>
	<span class="s2">int </span><span class="s1">l=prob</span><span class="s6">-&gt;</span><span class="s1">l;</span>

	<span class="s4">this</span><span class="s6">-&gt;</span><span class="s1">prob = prob;</span>

	<span class="s1">z = </span><span class="s4">new </span><span class="s2">double</span><span class="s1">[l];</span>
	<span class="s1">D = </span><span class="s4">new </span><span class="s2">double</span><span class="s1">[l];</span>
	<span class="s4">this</span><span class="s6">-&gt;</span><span class="s1">C = C;</span>
<span class="s1">}</span>

<span class="s1">l2r_lr_fun::~l2r_lr_fun()</span>
<span class="s1">{</span>
	<span class="s2">delete</span><span class="s1">[] z;</span>
	<span class="s2">delete</span><span class="s1">[] D;</span>
<span class="s1">}</span>


<span class="s2">double </span><span class="s1">l2r_lr_fun::fun(</span><span class="s2">double </span><span class="s1">*w)</span>
<span class="s1">{</span>
	<span class="s2">int </span><span class="s1">i;</span>
	<span class="s2">double </span><span class="s1">f=</span><span class="s5">0</span><span class="s1">;</span>
	<span class="s2">double </span><span class="s1">*y=prob</span><span class="s6">-&gt;</span><span class="s1">y;</span>
	<span class="s2">int </span><span class="s1">l=prob</span><span class="s6">-&gt;</span><span class="s1">l;</span>
	<span class="s2">int </span><span class="s1">w_size=get_nr_variable();</span>

	<span class="s1">Xv(w, z);</span>

	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;w_size;i++)</span>
		<span class="s1">f += w[i]*w[i];</span>
	<span class="s1">f /= </span><span class="s5">2.0</span><span class="s1">;</span>
	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;l;i++)</span>
	<span class="s1">{</span>
		<span class="s2">double </span><span class="s1">yz = y[i]*z[i];</span>
		<span class="s2">if </span><span class="s1">(yz &gt;= </span><span class="s5">0</span><span class="s1">)</span>
			<span class="s1">f += C[i]*log(</span><span class="s5">1 </span><span class="s1">+ exp(-yz));</span>
		<span class="s2">else</span>
			<span class="s1">f += C[i]*(-yz+log(</span><span class="s5">1 </span><span class="s1">+ exp(yz)));</span>
	<span class="s1">}</span>

	<span class="s2">return</span><span class="s1">(f);</span>
<span class="s1">}</span>

<span class="s2">void </span><span class="s1">l2r_lr_fun::grad(</span><span class="s2">double </span><span class="s1">*w, </span><span class="s2">double </span><span class="s1">*g)</span>
<span class="s1">{</span>
	<span class="s2">int </span><span class="s1">i;</span>
	<span class="s2">double </span><span class="s1">*y=prob</span><span class="s6">-&gt;</span><span class="s1">y;</span>
	<span class="s2">int </span><span class="s1">l=prob</span><span class="s6">-&gt;</span><span class="s1">l;</span>
	<span class="s2">int </span><span class="s1">w_size=get_nr_variable();</span>

	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;l;i++)</span>
	<span class="s1">{</span>
		<span class="s1">z[i] = </span><span class="s5">1</span><span class="s1">/(</span><span class="s5">1 </span><span class="s1">+ exp(-y[i]*z[i]));</span>
		<span class="s1">D[i] = z[i]*(</span><span class="s5">1</span><span class="s1">-z[i]);</span>
		<span class="s1">z[i] = C[i]*(z[i]-</span><span class="s5">1</span><span class="s1">)*y[i];</span>
	<span class="s1">}</span>
	<span class="s1">XTv(z, g);</span>

	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;w_size;i++)</span>
		<span class="s1">g[i] = w[i] + g[i];</span>
<span class="s1">}</span>

<span class="s2">int </span><span class="s1">l2r_lr_fun::get_nr_variable(</span><span class="s2">void</span><span class="s1">)</span>
<span class="s1">{</span>
	<span class="s2">return </span><span class="s1">prob</span><span class="s6">-&gt;</span><span class="s1">n;</span>
<span class="s1">}</span>

<span class="s2">void </span><span class="s1">l2r_lr_fun::Hv(</span><span class="s2">double </span><span class="s1">*s, </span><span class="s2">double </span><span class="s1">*Hs)</span>
<span class="s1">{</span>
	<span class="s2">int </span><span class="s1">i;</span>
	<span class="s2">int </span><span class="s1">l=prob</span><span class="s6">-&gt;</span><span class="s1">l;</span>
	<span class="s2">int </span><span class="s1">w_size=get_nr_variable();</span>
	<span class="s2">double </span><span class="s1">*wa = </span><span class="s4">new </span><span class="s2">double</span><span class="s1">[l];</span>

	<span class="s1">Xv(s, wa);</span>
	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;l;i++)</span>
		<span class="s1">wa[i] = C[i]*D[i]*wa[i];</span>

	<span class="s1">XTv(wa, Hs);</span>
	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;w_size;i++)</span>
		<span class="s1">Hs[i] = s[i] + Hs[i];</span>
	<span class="s2">delete</span><span class="s1">[] wa;</span>
<span class="s1">}</span>

<span class="s2">void </span><span class="s1">l2r_lr_fun::Xv(</span><span class="s2">double </span><span class="s1">*v, </span><span class="s2">double </span><span class="s1">*Xv)</span>
<span class="s1">{</span>
	<span class="s2">int </span><span class="s1">i;</span>
	<span class="s2">int </span><span class="s1">l=prob</span><span class="s6">-&gt;</span><span class="s1">l;</span>
	<span class="s1">feature_node **x=prob</span><span class="s6">-&gt;</span><span class="s1">x;</span>

	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;l;i++)</span>
	<span class="s1">{</span>
		<span class="s1">feature_node *s=x[i];</span>
		<span class="s1">Xv[i]=</span><span class="s5">0</span><span class="s1">;</span>
		<span class="s2">while</span><span class="s1">(s</span><span class="s6">-&gt;</span><span class="s1">index!=-</span><span class="s5">1</span><span class="s1">)</span>
		<span class="s1">{</span>
			<span class="s1">Xv[i]+=v[s</span><span class="s6">-&gt;</span><span class="s1">index-1]*s</span><span class="s6">-&gt;</span><span class="s1">value;</span>
			<span class="s1">s++;</span>
		<span class="s1">}</span>
	<span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">void </span><span class="s1">l2r_lr_fun::XTv(</span><span class="s2">double </span><span class="s1">*v, </span><span class="s2">double </span><span class="s1">*XTv)</span>
<span class="s1">{</span>
	<span class="s2">int </span><span class="s1">i;</span>
	<span class="s2">int </span><span class="s1">l=prob</span><span class="s6">-&gt;</span><span class="s1">l;</span>
	<span class="s2">int </span><span class="s1">w_size=get_nr_variable();</span>
	<span class="s1">feature_node **x=prob</span><span class="s6">-&gt;</span><span class="s1">x;</span>

	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;w_size;i++)</span>
		<span class="s1">XTv[i]=</span><span class="s5">0</span><span class="s1">;</span>
	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;l;i++)</span>
	<span class="s1">{</span>
		<span class="s1">feature_node *s=x[i];</span>
		<span class="s2">while</span><span class="s1">(s</span><span class="s6">-&gt;</span><span class="s1">index!=-</span><span class="s5">1</span><span class="s1">)</span>
		<span class="s1">{</span>
			<span class="s1">XTv[s</span><span class="s6">-&gt;</span><span class="s1">index-1]+=v[i]*s</span><span class="s6">-&gt;</span><span class="s1">value;</span>
			<span class="s1">s++;</span>
		<span class="s1">}</span>
	<span class="s1">}</span>
<span class="s1">}</span>

<span class="s4">class </span><span class="s1">l2r_l2_svc_fun: </span><span class="s4">public </span><span class="s1">function</span>
<span class="s1">{</span>
<span class="s4">public</span><span class="s1">:</span>
	<span class="s1">l2r_l2_svc_fun(</span><span class="s2">const </span><span class="s1">problem *prob, </span><span class="s2">double </span><span class="s1">*C);</span>
	<span class="s1">~l2r_l2_svc_fun();</span>

	<span class="s2">double </span><span class="s1">fun(</span><span class="s2">double </span><span class="s1">*w);</span>
	<span class="s2">void </span><span class="s1">grad(</span><span class="s2">double </span><span class="s1">*w, </span><span class="s2">double </span><span class="s1">*g);</span>
	<span class="s2">void </span><span class="s1">Hv(</span><span class="s2">double </span><span class="s1">*s, </span><span class="s2">double </span><span class="s1">*Hs);</span>

	<span class="s2">int </span><span class="s1">get_nr_variable(</span><span class="s2">void</span><span class="s1">);</span>

<span class="s4">protected</span><span class="s1">:</span>
	<span class="s2">void </span><span class="s1">Xv(</span><span class="s2">double </span><span class="s1">*v, </span><span class="s2">double </span><span class="s1">*Xv);</span>
	<span class="s2">void </span><span class="s1">subXv(</span><span class="s2">double </span><span class="s1">*v, </span><span class="s2">double </span><span class="s1">*Xv);</span>
	<span class="s2">void </span><span class="s1">subXTv(</span><span class="s2">double </span><span class="s1">*v, </span><span class="s2">double </span><span class="s1">*XTv);</span>

	<span class="s2">double </span><span class="s1">*C;</span>
	<span class="s2">double </span><span class="s1">*z;</span>
	<span class="s2">double </span><span class="s1">*D;</span>
	<span class="s2">int </span><span class="s1">*I;</span>
	<span class="s2">int </span><span class="s1">sizeI;</span>
	<span class="s2">const </span><span class="s1">problem *prob;</span>
<span class="s1">};</span>

<span class="s1">l2r_l2_svc_fun::l2r_l2_svc_fun(</span><span class="s2">const </span><span class="s1">problem *prob, </span><span class="s2">double </span><span class="s1">*C)</span>
<span class="s1">{</span>
	<span class="s2">int </span><span class="s1">l=prob</span><span class="s6">-&gt;</span><span class="s1">l;</span>

	<span class="s4">this</span><span class="s6">-&gt;</span><span class="s1">prob = prob;</span>

	<span class="s1">z = </span><span class="s4">new </span><span class="s2">double</span><span class="s1">[l];</span>
	<span class="s1">D = </span><span class="s4">new </span><span class="s2">double</span><span class="s1">[l];</span>
	<span class="s1">I = </span><span class="s4">new </span><span class="s2">int</span><span class="s1">[l];</span>
	<span class="s4">this</span><span class="s6">-&gt;</span><span class="s1">C = C;</span>
<span class="s1">}</span>

<span class="s1">l2r_l2_svc_fun::~l2r_l2_svc_fun()</span>
<span class="s1">{</span>
	<span class="s2">delete</span><span class="s1">[] z;</span>
	<span class="s2">delete</span><span class="s1">[] D;</span>
	<span class="s2">delete</span><span class="s1">[] I;</span>
<span class="s1">}</span>

<span class="s2">double </span><span class="s1">l2r_l2_svc_fun::fun(</span><span class="s2">double </span><span class="s1">*w)</span>
<span class="s1">{</span>
	<span class="s2">int </span><span class="s1">i;</span>
	<span class="s2">double </span><span class="s1">f=</span><span class="s5">0</span><span class="s1">;</span>
	<span class="s2">double </span><span class="s1">*y=prob</span><span class="s6">-&gt;</span><span class="s1">y;</span>
	<span class="s2">int </span><span class="s1">l=prob</span><span class="s6">-&gt;</span><span class="s1">l;</span>
	<span class="s2">int </span><span class="s1">w_size=get_nr_variable();</span>

	<span class="s1">Xv(w, z);</span>

	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;w_size;i++)</span>
		<span class="s1">f += w[i]*w[i];</span>
	<span class="s1">f /= </span><span class="s5">2.0</span><span class="s1">;</span>
	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;l;i++)</span>
	<span class="s1">{</span>
		<span class="s1">z[i] = y[i]*z[i];</span>
		<span class="s2">double </span><span class="s1">d = </span><span class="s5">1</span><span class="s1">-z[i];</span>
		<span class="s2">if </span><span class="s1">(d &gt; </span><span class="s5">0</span><span class="s1">)</span>
			<span class="s1">f += C[i]*d*d;</span>
	<span class="s1">}</span>

	<span class="s2">return</span><span class="s1">(f);</span>
<span class="s1">}</span>

<span class="s2">void </span><span class="s1">l2r_l2_svc_fun::grad(</span><span class="s2">double </span><span class="s1">*w, </span><span class="s2">double </span><span class="s1">*g)</span>
<span class="s1">{</span>
	<span class="s2">int </span><span class="s1">i;</span>
	<span class="s2">double </span><span class="s1">*y=prob</span><span class="s6">-&gt;</span><span class="s1">y;</span>
	<span class="s2">int </span><span class="s1">l=prob</span><span class="s6">-&gt;</span><span class="s1">l;</span>
	<span class="s2">int </span><span class="s1">w_size=get_nr_variable();</span>

	<span class="s1">sizeI = </span><span class="s5">0</span><span class="s1">;</span>
	<span class="s2">for </span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;l;i++)</span>
		<span class="s2">if </span><span class="s1">(z[i] &lt; </span><span class="s5">1</span><span class="s1">)</span>
		<span class="s1">{</span>
			<span class="s1">z[sizeI] = C[i]*y[i]*(z[i]-</span><span class="s5">1</span><span class="s1">);</span>
			<span class="s1">I[sizeI] = i;</span>
			<span class="s1">sizeI++;</span>
		<span class="s1">}</span>
	<span class="s1">subXTv(z, g);</span>

	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;w_size;i++)</span>
		<span class="s1">g[i] = w[i] + </span><span class="s5">2</span><span class="s1">*g[i];</span>
<span class="s1">}</span>

<span class="s2">int </span><span class="s1">l2r_l2_svc_fun::get_nr_variable(</span><span class="s2">void</span><span class="s1">)</span>
<span class="s1">{</span>
	<span class="s2">return </span><span class="s1">prob</span><span class="s6">-&gt;</span><span class="s1">n;</span>
<span class="s1">}</span>

<span class="s2">void </span><span class="s1">l2r_l2_svc_fun::Hv(</span><span class="s2">double </span><span class="s1">*s, </span><span class="s2">double </span><span class="s1">*Hs)</span>
<span class="s1">{</span>
	<span class="s2">int </span><span class="s1">i;</span>
	<span class="s2">int </span><span class="s1">w_size=get_nr_variable();</span>
	<span class="s2">double </span><span class="s1">*wa = </span><span class="s4">new </span><span class="s2">double</span><span class="s1">[sizeI];</span>

	<span class="s1">subXv(s, wa);</span>
	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;sizeI;i++)</span>
		<span class="s1">wa[i] = C[I[i]]*wa[i];</span>

	<span class="s1">subXTv(wa, Hs);</span>
	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;w_size;i++)</span>
		<span class="s1">Hs[i] = s[i] + </span><span class="s5">2</span><span class="s1">*Hs[i];</span>
	<span class="s2">delete</span><span class="s1">[] wa;</span>
<span class="s1">}</span>

<span class="s2">void </span><span class="s1">l2r_l2_svc_fun::Xv(</span><span class="s2">double </span><span class="s1">*v, </span><span class="s2">double </span><span class="s1">*Xv)</span>
<span class="s1">{</span>
	<span class="s2">int </span><span class="s1">i;</span>
	<span class="s2">int </span><span class="s1">l=prob</span><span class="s6">-&gt;</span><span class="s1">l;</span>
	<span class="s1">feature_node **x=prob</span><span class="s6">-&gt;</span><span class="s1">x;</span>

	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;l;i++)</span>
	<span class="s1">{</span>
		<span class="s1">feature_node *s=x[i];</span>
		<span class="s1">Xv[i]=</span><span class="s5">0</span><span class="s1">;</span>
		<span class="s2">while</span><span class="s1">(s</span><span class="s6">-&gt;</span><span class="s1">index!=-</span><span class="s5">1</span><span class="s1">)</span>
		<span class="s1">{</span>
			<span class="s1">Xv[i]+=v[s</span><span class="s6">-&gt;</span><span class="s1">index-1]*s</span><span class="s6">-&gt;</span><span class="s1">value;</span>
			<span class="s1">s++;</span>
		<span class="s1">}</span>
	<span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">void </span><span class="s1">l2r_l2_svc_fun::subXv(</span><span class="s2">double </span><span class="s1">*v, </span><span class="s2">double </span><span class="s1">*Xv)</span>
<span class="s1">{</span>
	<span class="s2">int </span><span class="s1">i;</span>
	<span class="s1">feature_node **x=prob</span><span class="s6">-&gt;</span><span class="s1">x;</span>

	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;sizeI;i++)</span>
	<span class="s1">{</span>
		<span class="s1">feature_node *s=x[I[i]];</span>
		<span class="s1">Xv[i]=</span><span class="s5">0</span><span class="s1">;</span>
		<span class="s2">while</span><span class="s1">(s</span><span class="s6">-&gt;</span><span class="s1">index!=-</span><span class="s5">1</span><span class="s1">)</span>
		<span class="s1">{</span>
			<span class="s1">Xv[i]+=v[s</span><span class="s6">-&gt;</span><span class="s1">index-1]*s</span><span class="s6">-&gt;</span><span class="s1">value;</span>
			<span class="s1">s++;</span>
		<span class="s1">}</span>
	<span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">void </span><span class="s1">l2r_l2_svc_fun::subXTv(</span><span class="s2">double </span><span class="s1">*v, </span><span class="s2">double </span><span class="s1">*XTv)</span>
<span class="s1">{</span>
	<span class="s2">int </span><span class="s1">i;</span>
	<span class="s2">int </span><span class="s1">w_size=get_nr_variable();</span>
	<span class="s1">feature_node **x=prob</span><span class="s6">-&gt;</span><span class="s1">x;</span>

	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;w_size;i++)</span>
		<span class="s1">XTv[i]=</span><span class="s5">0</span><span class="s1">;</span>
	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;sizeI;i++)</span>
	<span class="s1">{</span>
		<span class="s1">feature_node *s=x[I[i]];</span>
		<span class="s2">while</span><span class="s1">(s</span><span class="s6">-&gt;</span><span class="s1">index!=-</span><span class="s5">1</span><span class="s1">)</span>
		<span class="s1">{</span>
			<span class="s1">XTv[s</span><span class="s6">-&gt;</span><span class="s1">index-1]+=v[i]*s</span><span class="s6">-&gt;</span><span class="s1">value;</span>
			<span class="s1">s++;</span>
		<span class="s1">}</span>
	<span class="s1">}</span>
<span class="s1">}</span>

<span class="s4">class </span><span class="s1">l2r_l2_svr_fun: </span><span class="s4">public </span><span class="s1">l2r_l2_svc_fun</span>
<span class="s1">{</span>
<span class="s4">public</span><span class="s1">:</span>
	<span class="s1">l2r_l2_svr_fun(</span><span class="s2">const </span><span class="s1">problem *prob, </span><span class="s2">double </span><span class="s1">*C, </span><span class="s2">double </span><span class="s1">p);</span>

	<span class="s2">double </span><span class="s1">fun(</span><span class="s2">double </span><span class="s1">*w);</span>
	<span class="s2">void </span><span class="s1">grad(</span><span class="s2">double </span><span class="s1">*w, </span><span class="s2">double </span><span class="s1">*g);</span>

<span class="s4">private</span><span class="s1">:</span>
	<span class="s2">double </span><span class="s1">p;</span>
<span class="s1">};</span>

<span class="s1">l2r_l2_svr_fun::l2r_l2_svr_fun(</span><span class="s2">const </span><span class="s1">problem *prob, </span><span class="s2">double </span><span class="s1">*C, </span><span class="s2">double </span><span class="s1">p):</span>
	<span class="s1">l2r_l2_svc_fun(prob, C)</span>
<span class="s1">{</span>
	<span class="s4">this</span><span class="s6">-&gt;</span><span class="s1">p = p;</span>
<span class="s1">}</span>

<span class="s2">double </span><span class="s1">l2r_l2_svr_fun::fun(</span><span class="s2">double </span><span class="s1">*w)</span>
<span class="s1">{</span>
	<span class="s2">int </span><span class="s1">i;</span>
	<span class="s2">double </span><span class="s1">f=</span><span class="s5">0</span><span class="s1">;</span>
	<span class="s2">double </span><span class="s1">*y=prob</span><span class="s6">-&gt;</span><span class="s1">y;</span>
	<span class="s2">int </span><span class="s1">l=prob</span><span class="s6">-&gt;</span><span class="s1">l;</span>
	<span class="s2">int </span><span class="s1">w_size=get_nr_variable();</span>
	<span class="s2">double </span><span class="s1">d;</span>

	<span class="s1">Xv(w, z);</span>

	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;w_size;i++)</span>
		<span class="s1">f += w[i]*w[i];</span>
	<span class="s1">f /= </span><span class="s5">2</span><span class="s1">;</span>
	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;l;i++)</span>
	<span class="s1">{</span>
		<span class="s1">d = z[i] - y[i];</span>
		<span class="s2">if</span><span class="s1">(d &lt; -p)</span>
			<span class="s1">f += C[i]*(d+p)*(d+p);</span>
		<span class="s2">else if</span><span class="s1">(d &gt; p)</span>
			<span class="s1">f += C[i]*(d-p)*(d-p);</span>
	<span class="s1">}</span>

	<span class="s2">return</span><span class="s1">(f);</span>
<span class="s1">}</span>

<span class="s2">void </span><span class="s1">l2r_l2_svr_fun::grad(</span><span class="s2">double </span><span class="s1">*w, </span><span class="s2">double </span><span class="s1">*g)</span>
<span class="s1">{</span>
	<span class="s2">int </span><span class="s1">i;</span>
	<span class="s2">double </span><span class="s1">*y=prob</span><span class="s6">-&gt;</span><span class="s1">y;</span>
	<span class="s2">int </span><span class="s1">l=prob</span><span class="s6">-&gt;</span><span class="s1">l;</span>
	<span class="s2">int </span><span class="s1">w_size=get_nr_variable();</span>
	<span class="s2">double </span><span class="s1">d;</span>

	<span class="s1">sizeI = </span><span class="s5">0</span><span class="s1">;</span>
	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;l;i++)</span>
	<span class="s1">{</span>
		<span class="s1">d = z[i] - y[i];</span>

		<span class="s0">// generate index set I</span>
		<span class="s2">if</span><span class="s1">(d &lt; -p)</span>
		<span class="s1">{</span>
			<span class="s1">z[sizeI] = C[i]*(d+p);</span>
			<span class="s1">I[sizeI] = i;</span>
			<span class="s1">sizeI++;</span>
		<span class="s1">}</span>
		<span class="s2">else if</span><span class="s1">(d &gt; p)</span>
		<span class="s1">{</span>
			<span class="s1">z[sizeI] = C[i]*(d-p);</span>
			<span class="s1">I[sizeI] = i;</span>
			<span class="s1">sizeI++;</span>
		<span class="s1">}</span>

	<span class="s1">}</span>
	<span class="s1">subXTv(z, g);</span>

	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;w_size;i++)</span>
		<span class="s1">g[i] = w[i] + </span><span class="s5">2</span><span class="s1">*g[i];</span>
<span class="s1">}</span>

<span class="s0">// A coordinate descent algorithm for</span>
<span class="s0">// multi-class support vector machines by Crammer and Singer</span>
<span class="s0">//</span>
<span class="s0">//  min_{\alpha}  0.5 \sum_m ||w_m(\alpha)||^2 + \sum_i \sum_m e^m_i alpha^m_i</span>
<span class="s0">//    s.t.     \alpha^m_i &lt;= C^m_i \forall m,i , \sum_m \alpha^m_i=0 \forall i</span>
<span class="s0">//</span>
<span class="s0">//  where e^m_i = 0 if y_i  = m,</span>
<span class="s0">//        e^m_i = 1 if y_i != m,</span>
<span class="s0">//  C^m_i = C if m  = y_i,</span>
<span class="s0">//  C^m_i = 0 if m != y_i,</span>
<span class="s0">//  and w_m(\alpha) = \sum_i \alpha^m_i x_i</span>
<span class="s0">//</span>
<span class="s0">// Given:</span>
<span class="s0">// x, y, C</span>
<span class="s0">// eps is the stopping tolerance</span>
<span class="s0">//</span>
<span class="s0">// solution will be put in w</span>
<span class="s0">//</span>
<span class="s0">// See Appendix of LIBLINEAR paper, Fan et al. (2008)</span>

<span class="s2">#define </span><span class="s1">GETI(i) (i)</span>
<span class="s0">// To support weights for instances, use GETI(i) (i)</span>

<span class="s4">class </span><span class="s1">Solver_MCSVM_CS</span>
<span class="s1">{</span>
	<span class="s4">public</span><span class="s1">:</span>
		<span class="s1">Solver_MCSVM_CS(</span><span class="s2">const </span><span class="s1">problem *prob, </span><span class="s2">int </span><span class="s1">nr_class, </span><span class="s2">double </span><span class="s1">*C, </span><span class="s2">double </span><span class="s1">eps=</span><span class="s5">0.1</span><span class="s1">, </span><span class="s2">int </span><span class="s1">max_iter=</span><span class="s5">100000</span><span class="s1">);</span>
		<span class="s1">~Solver_MCSVM_CS();</span>
		<span class="s2">int </span><span class="s1">Solve(</span><span class="s2">double </span><span class="s1">*w);</span>
	<span class="s4">private</span><span class="s1">:</span>
		<span class="s2">void </span><span class="s1">solve_sub_problem(</span><span class="s2">double </span><span class="s1">A_i, </span><span class="s2">int </span><span class="s1">yi, </span><span class="s2">double </span><span class="s1">C_yi, </span><span class="s2">int </span><span class="s1">active_i, </span><span class="s2">double </span><span class="s1">*alpha_new);</span>
		<span class="s2">bool </span><span class="s1">be_shrunk(</span><span class="s2">int </span><span class="s1">i, </span><span class="s2">int </span><span class="s1">m, </span><span class="s2">int </span><span class="s1">yi, </span><span class="s2">double </span><span class="s1">alpha_i, </span><span class="s2">double </span><span class="s1">minG);</span>
		<span class="s2">double </span><span class="s1">*B, *C, *G;</span>
		<span class="s2">int </span><span class="s1">w_size, l;</span>
		<span class="s2">int </span><span class="s1">nr_class;</span>
		<span class="s2">int </span><span class="s1">max_iter;</span>
		<span class="s2">double </span><span class="s1">eps;</span>
		<span class="s2">const </span><span class="s1">problem *prob;</span>
<span class="s1">};</span>

<span class="s1">Solver_MCSVM_CS::Solver_MCSVM_CS(</span><span class="s2">const </span><span class="s1">problem *prob, </span><span class="s2">int </span><span class="s1">nr_class, </span><span class="s2">double </span><span class="s1">*weighted_C, </span><span class="s2">double </span><span class="s1">eps, </span><span class="s2">int </span><span class="s1">max_iter)</span>
<span class="s1">{</span>
	<span class="s4">this</span><span class="s6">-&gt;</span><span class="s1">w_size = prob</span><span class="s6">-&gt;</span><span class="s1">n;</span>
	<span class="s4">this</span><span class="s6">-&gt;</span><span class="s1">l = prob</span><span class="s6">-&gt;</span><span class="s1">l;</span>
	<span class="s4">this</span><span class="s6">-&gt;</span><span class="s1">nr_class = nr_class;</span>
	<span class="s4">this</span><span class="s6">-&gt;</span><span class="s1">eps = eps;</span>
	<span class="s4">this</span><span class="s6">-&gt;</span><span class="s1">max_iter = max_iter;</span>
	<span class="s4">this</span><span class="s6">-&gt;</span><span class="s1">prob = prob;</span>
	<span class="s4">this</span><span class="s6">-&gt;</span><span class="s1">B = </span><span class="s4">new </span><span class="s2">double</span><span class="s1">[nr_class];</span>
	<span class="s4">this</span><span class="s6">-&gt;</span><span class="s1">G = </span><span class="s4">new </span><span class="s2">double</span><span class="s1">[nr_class];</span>
	<span class="s4">this</span><span class="s6">-&gt;</span><span class="s1">C = </span><span class="s4">new </span><span class="s2">double</span><span class="s1">[prob</span><span class="s6">-&gt;</span><span class="s1">l];</span>
	<span class="s2">for</span><span class="s1">(</span><span class="s2">int </span><span class="s1">i = </span><span class="s5">0</span><span class="s1">; i &lt; prob</span><span class="s6">-&gt;</span><span class="s1">l; i++)</span>
		<span class="s4">this</span><span class="s6">-&gt;</span><span class="s1">C[i] = prob</span><span class="s6">-&gt;</span><span class="s1">W[i] * weighted_C[(</span><span class="s2">int</span><span class="s1">)prob</span><span class="s6">-&gt;</span><span class="s1">y[i]];</span>
<span class="s1">}</span>

<span class="s1">Solver_MCSVM_CS::~Solver_MCSVM_CS()</span>
<span class="s1">{</span>
	<span class="s2">delete</span><span class="s1">[] B;</span>
	<span class="s2">delete</span><span class="s1">[] G;</span>
	<span class="s2">delete</span><span class="s1">[] C;</span>
<span class="s1">}</span>

<span class="s2">int </span><span class="s1">compare_double(</span><span class="s2">const void </span><span class="s1">*a, </span><span class="s2">const void </span><span class="s1">*b)</span>
<span class="s1">{</span>
	<span class="s2">if</span><span class="s1">(*(</span><span class="s2">double </span><span class="s1">*)a &gt; *(</span><span class="s2">double </span><span class="s1">*)b)</span>
		<span class="s2">return </span><span class="s1">-</span><span class="s5">1</span><span class="s1">;</span>
	<span class="s2">if</span><span class="s1">(*(</span><span class="s2">double </span><span class="s1">*)a &lt; *(</span><span class="s2">double </span><span class="s1">*)b)</span>
		<span class="s2">return </span><span class="s5">1</span><span class="s1">;</span>
	<span class="s2">return </span><span class="s5">0</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">void </span><span class="s1">Solver_MCSVM_CS::solve_sub_problem(</span><span class="s2">double </span><span class="s1">A_i, </span><span class="s2">int </span><span class="s1">yi, </span><span class="s2">double </span><span class="s1">C_yi, </span><span class="s2">int </span><span class="s1">active_i, </span><span class="s2">double </span><span class="s1">*alpha_new)</span>
<span class="s1">{</span>
	<span class="s2">int </span><span class="s1">r;</span>
	<span class="s2">double </span><span class="s1">*D;</span>

	<span class="s1">clone(D, B, active_i);</span>
	<span class="s2">if</span><span class="s1">(yi &lt; active_i)</span>
		<span class="s1">D[yi] += A_i*C_yi;</span>
	<span class="s1">qsort(D, active_i, </span><span class="s2">sizeof</span><span class="s1">(</span><span class="s2">double</span><span class="s1">), compare_double);</span>

	<span class="s2">double </span><span class="s1">beta = D[</span><span class="s5">0</span><span class="s1">] - A_i*C_yi;</span>
	<span class="s2">for</span><span class="s1">(r=</span><span class="s5">1</span><span class="s1">;r&lt;active_i &amp;&amp; beta&lt;r*D[r];r++)</span>
		<span class="s1">beta += D[r];</span>
	<span class="s1">beta /= r;</span>

	<span class="s2">for</span><span class="s1">(r=</span><span class="s5">0</span><span class="s1">;r&lt;active_i;r++)</span>
	<span class="s1">{</span>
		<span class="s2">if</span><span class="s1">(r == yi)</span>
			<span class="s1">alpha_new[r] = min(C_yi, (beta-B[r])/A_i);</span>
		<span class="s2">else</span>
			<span class="s1">alpha_new[r] = min((</span><span class="s2">double</span><span class="s1">)</span><span class="s5">0</span><span class="s1">, (beta - B[r])/A_i);</span>
	<span class="s1">}</span>
	<span class="s2">delete</span><span class="s1">[] D;</span>
<span class="s1">}</span>

<span class="s2">bool </span><span class="s1">Solver_MCSVM_CS::be_shrunk(</span><span class="s2">int </span><span class="s1">i, </span><span class="s2">int </span><span class="s1">m, </span><span class="s2">int </span><span class="s1">yi, </span><span class="s2">double </span><span class="s1">alpha_i, </span><span class="s2">double </span><span class="s1">minG)</span>
<span class="s1">{</span>
	<span class="s2">double </span><span class="s1">bound = </span><span class="s5">0</span><span class="s1">;</span>
	<span class="s2">if</span><span class="s1">(m == yi)</span>
		<span class="s1">bound = C[GETI(i)];</span>
	<span class="s2">if</span><span class="s1">(alpha_i == bound &amp;&amp; G[m] &lt; minG)</span>
		<span class="s2">return </span><span class="s4">true</span><span class="s1">;</span>
	<span class="s2">return false</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">int </span><span class="s1">Solver_MCSVM_CS::Solve(</span><span class="s2">double </span><span class="s1">*w)</span>
<span class="s1">{</span>
	<span class="s2">int </span><span class="s1">i, m, s;</span>
	<span class="s2">int </span><span class="s1">iter = </span><span class="s5">0</span><span class="s1">;</span>
	<span class="s2">double </span><span class="s1">*alpha =  </span><span class="s4">new </span><span class="s2">double</span><span class="s1">[l*nr_class];</span>
	<span class="s2">double </span><span class="s1">*alpha_new = </span><span class="s4">new </span><span class="s2">double</span><span class="s1">[nr_class];</span>
	<span class="s2">int </span><span class="s1">*index = </span><span class="s4">new </span><span class="s2">int</span><span class="s1">[l];</span>
	<span class="s2">double </span><span class="s1">*QD = </span><span class="s4">new </span><span class="s2">double</span><span class="s1">[l];</span>
	<span class="s2">int </span><span class="s1">*d_ind = </span><span class="s4">new </span><span class="s2">int</span><span class="s1">[nr_class];</span>
	<span class="s2">double </span><span class="s1">*d_val = </span><span class="s4">new </span><span class="s2">double</span><span class="s1">[nr_class];</span>
	<span class="s2">int </span><span class="s1">*alpha_index = </span><span class="s4">new </span><span class="s2">int</span><span class="s1">[nr_class*l];</span>
	<span class="s2">int </span><span class="s1">*y_index = </span><span class="s4">new </span><span class="s2">int</span><span class="s1">[l];</span>
	<span class="s2">int </span><span class="s1">active_size = l;</span>
	<span class="s2">int </span><span class="s1">*active_size_i = </span><span class="s4">new </span><span class="s2">int</span><span class="s1">[l];</span>
	<span class="s2">double </span><span class="s1">eps_shrink = max(</span><span class="s5">10.0</span><span class="s1">*eps, </span><span class="s5">1.0</span><span class="s1">); </span><span class="s0">// stopping tolerance for shrinking</span>
	<span class="s2">bool </span><span class="s1">start_from_all = </span><span class="s4">true</span><span class="s1">;</span>

	<span class="s0">// Initial alpha can be set here. Note that</span>
	<span class="s0">// sum_m alpha[i*nr_class+m] = 0, for all i=1,...,l-1</span>
	<span class="s0">// alpha[i*nr_class+m] &lt;= C[GETI(i)] if prob-&gt;y[i] == m</span>
	<span class="s0">// alpha[i*nr_class+m] &lt;= 0 if prob-&gt;y[i] != m</span>
	<span class="s0">// If initial alpha isn't zero, uncomment the for loop below to initialize w</span>
	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;l*nr_class;i++)</span>
		<span class="s1">alpha[i] = </span><span class="s5">0</span><span class="s1">;</span>

	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;w_size*nr_class;i++)</span>
		<span class="s1">w[i] = </span><span class="s5">0</span><span class="s1">;</span>
	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;l;i++)</span>
	<span class="s1">{</span>
		<span class="s2">for</span><span class="s1">(m=</span><span class="s5">0</span><span class="s1">;m&lt;nr_class;m++)</span>
			<span class="s1">alpha_index[i*nr_class+m] = m;</span>
		<span class="s1">feature_node *xi = prob</span><span class="s6">-&gt;</span><span class="s1">x[i];</span>
		<span class="s1">QD[i] = </span><span class="s5">0</span><span class="s1">;</span>
		<span class="s2">while</span><span class="s1">(xi</span><span class="s6">-&gt;</span><span class="s1">index != -</span><span class="s5">1</span><span class="s1">)</span>
		<span class="s1">{</span>
			<span class="s2">double </span><span class="s1">val = xi</span><span class="s6">-&gt;</span><span class="s1">value;</span>
			<span class="s1">QD[i] += val*val;</span>

			<span class="s0">// Uncomment the for loop if initial alpha isn't zero</span>
			<span class="s0">// for(m=0; m&lt;nr_class; m++)</span>
			<span class="s0">//  w[(xi-&gt;index-1)*nr_class+m] += alpha[i*nr_class+m]*val;</span>
			<span class="s1">xi++;</span>
		<span class="s1">}</span>
		<span class="s1">active_size_i[i] = nr_class;</span>
		<span class="s1">y_index[i] = (</span><span class="s2">int</span><span class="s1">)prob</span><span class="s6">-&gt;</span><span class="s1">y[i];</span>
		<span class="s1">index[i] = i;</span>
	<span class="s1">}</span>

	<span class="s2">while</span><span class="s1">(iter &lt; max_iter)</span>
	<span class="s1">{</span>
		<span class="s2">double </span><span class="s1">stopping = -INF;</span>
		<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;active_size;i++)</span>
		<span class="s1">{</span>
			<span class="s2">int </span><span class="s1">j = i+bounded_rand_int(active_size-i);</span>
			<span class="s1">swap(index[i], index[j]);</span>
		<span class="s1">}</span>
		<span class="s2">for</span><span class="s1">(s=</span><span class="s5">0</span><span class="s1">;s&lt;active_size;s++)</span>
		<span class="s1">{</span>
			<span class="s1">i = index[s];</span>
			<span class="s2">double </span><span class="s1">Ai = QD[i];</span>
			<span class="s2">double </span><span class="s1">*alpha_i = &amp;alpha[i*nr_class];</span>
			<span class="s2">int </span><span class="s1">*alpha_index_i = &amp;alpha_index[i*nr_class];</span>

			<span class="s2">if</span><span class="s1">(Ai &gt; </span><span class="s5">0</span><span class="s1">)</span>
			<span class="s1">{</span>
				<span class="s2">for</span><span class="s1">(m=</span><span class="s5">0</span><span class="s1">;m&lt;active_size_i[i];m++)</span>
					<span class="s1">G[m] = </span><span class="s5">1</span><span class="s1">;</span>
				<span class="s2">if</span><span class="s1">(y_index[i] &lt; active_size_i[i])</span>
					<span class="s1">G[y_index[i]] = </span><span class="s5">0</span><span class="s1">;</span>

				<span class="s1">feature_node *xi = prob</span><span class="s6">-&gt;</span><span class="s1">x[i];</span>
				<span class="s2">while</span><span class="s1">(xi</span><span class="s6">-&gt;</span><span class="s1">index!= -</span><span class="s5">1</span><span class="s1">)</span>
				<span class="s1">{</span>
					<span class="s2">double </span><span class="s1">*w_i = &amp;w[(xi</span><span class="s6">-&gt;</span><span class="s1">index-1)*nr_class];</span>
					<span class="s2">for</span><span class="s1">(m=</span><span class="s5">0</span><span class="s1">;m&lt;active_size_i[i];m++)</span>
						<span class="s1">G[m] += w_i[alpha_index_i[m]]*(xi</span><span class="s6">-&gt;</span><span class="s1">value);</span>
					<span class="s1">xi++;</span>
				<span class="s1">}</span>

				<span class="s2">double </span><span class="s1">minG = INF;</span>
				<span class="s2">double </span><span class="s1">maxG = -INF;</span>
				<span class="s2">for</span><span class="s1">(m=</span><span class="s5">0</span><span class="s1">;m&lt;active_size_i[i];m++)</span>
				<span class="s1">{</span>
					<span class="s2">if</span><span class="s1">(alpha_i[alpha_index_i[m]] &lt; </span><span class="s5">0 </span><span class="s1">&amp;&amp; G[m] &lt; minG)</span>
						<span class="s1">minG = G[m];</span>
					<span class="s2">if</span><span class="s1">(G[m] &gt; maxG)</span>
						<span class="s1">maxG = G[m];</span>
				<span class="s1">}</span>
				<span class="s2">if</span><span class="s1">(y_index[i] &lt; active_size_i[i])</span>
					<span class="s2">if</span><span class="s1">(alpha_i[(</span><span class="s2">int</span><span class="s1">) prob</span><span class="s6">-&gt;</span><span class="s1">y[i]] &lt; C[GETI(i)] &amp;&amp; G[y_index[i]] &lt; minG)</span>
						<span class="s1">minG = G[y_index[i]];</span>

				<span class="s2">for</span><span class="s1">(m=</span><span class="s5">0</span><span class="s1">;m&lt;active_size_i[i];m++)</span>
				<span class="s1">{</span>
					<span class="s2">if</span><span class="s1">(be_shrunk(i, m, y_index[i], alpha_i[alpha_index_i[m]], minG))</span>
					<span class="s1">{</span>
						<span class="s1">active_size_i[i]--;</span>
						<span class="s2">while</span><span class="s1">(active_size_i[i]&gt;m)</span>
						<span class="s1">{</span>
							<span class="s2">if</span><span class="s1">(!be_shrunk(i, active_size_i[i], y_index[i],</span>
											<span class="s1">alpha_i[alpha_index_i[active_size_i[i]]], minG))</span>
							<span class="s1">{</span>
								<span class="s1">swap(alpha_index_i[m], alpha_index_i[active_size_i[i]]);</span>
								<span class="s1">swap(G[m], G[active_size_i[i]]);</span>
								<span class="s2">if</span><span class="s1">(y_index[i] == active_size_i[i])</span>
									<span class="s1">y_index[i] = m;</span>
								<span class="s2">else if</span><span class="s1">(y_index[i] == m)</span>
									<span class="s1">y_index[i] = active_size_i[i];</span>
								<span class="s2">break</span><span class="s1">;</span>
							<span class="s1">}</span>
							<span class="s1">active_size_i[i]--;</span>
						<span class="s1">}</span>
					<span class="s1">}</span>
				<span class="s1">}</span>

				<span class="s2">if</span><span class="s1">(active_size_i[i] &lt;= </span><span class="s5">1</span><span class="s1">)</span>
				<span class="s1">{</span>
					<span class="s1">active_size--;</span>
					<span class="s1">swap(index[s], index[active_size]);</span>
					<span class="s1">s--;</span>
					<span class="s2">continue</span><span class="s1">;</span>
				<span class="s1">}</span>

				<span class="s2">if</span><span class="s1">(maxG-minG &lt;= </span><span class="s5">1</span><span class="s1">e-12)</span>
					<span class="s2">continue</span><span class="s1">;</span>
				<span class="s2">else</span>
					<span class="s1">stopping = max(maxG - minG, stopping);</span>

				<span class="s2">for</span><span class="s1">(m=</span><span class="s5">0</span><span class="s1">;m&lt;active_size_i[i];m++)</span>
					<span class="s1">B[m] = G[m] - Ai*alpha_i[alpha_index_i[m]] ;</span>

				<span class="s1">solve_sub_problem(Ai, y_index[i], C[GETI(i)], active_size_i[i], alpha_new);</span>
				<span class="s2">int </span><span class="s1">nz_d = </span><span class="s5">0</span><span class="s1">;</span>
				<span class="s2">for</span><span class="s1">(m=</span><span class="s5">0</span><span class="s1">;m&lt;active_size_i[i];m++)</span>
				<span class="s1">{</span>
					<span class="s2">double </span><span class="s1">d = alpha_new[m] - alpha_i[alpha_index_i[m]];</span>
					<span class="s1">alpha_i[alpha_index_i[m]] = alpha_new[m];</span>
					<span class="s2">if</span><span class="s1">(fabs(d) &gt;= </span><span class="s5">1</span><span class="s1">e-12)</span>
					<span class="s1">{</span>
						<span class="s1">d_ind[nz_d] = alpha_index_i[m];</span>
						<span class="s1">d_val[nz_d] = d;</span>
						<span class="s1">nz_d++;</span>
					<span class="s1">}</span>
				<span class="s1">}</span>

				<span class="s1">xi = prob</span><span class="s6">-&gt;</span><span class="s1">x[i];</span>
				<span class="s2">while</span><span class="s1">(xi</span><span class="s6">-&gt;</span><span class="s1">index != -</span><span class="s5">1</span><span class="s1">)</span>
				<span class="s1">{</span>
					<span class="s2">double </span><span class="s1">*w_i = &amp;w[(xi</span><span class="s6">-&gt;</span><span class="s1">index-1)*nr_class];</span>
					<span class="s2">for</span><span class="s1">(m=</span><span class="s5">0</span><span class="s1">;m&lt;nz_d;m++)</span>
						<span class="s1">w_i[d_ind[m]] += d_val[m]*xi</span><span class="s6">-&gt;</span><span class="s1">value;</span>
					<span class="s1">xi++;</span>
				<span class="s1">}</span>
			<span class="s1">}</span>
		<span class="s1">}</span>

		<span class="s1">iter++;</span>
		<span class="s2">if</span><span class="s1">(iter % </span><span class="s5">10 </span><span class="s1">== </span><span class="s5">0</span><span class="s1">)</span>
		<span class="s1">{</span>
			<span class="s1">info(</span><span class="s3">&quot;.&quot;</span><span class="s1">);</span>
		<span class="s1">}</span>

		<span class="s2">if</span><span class="s1">(stopping &lt; eps_shrink)</span>
		<span class="s1">{</span>
			<span class="s2">if</span><span class="s1">(stopping &lt; eps &amp;&amp; start_from_all == </span><span class="s4">true</span><span class="s1">)</span>
				<span class="s2">break</span><span class="s1">;</span>
			<span class="s2">else</span>
			<span class="s1">{</span>
				<span class="s1">active_size = l;</span>
				<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;l;i++)</span>
					<span class="s1">active_size_i[i] = nr_class;</span>
				<span class="s1">info(</span><span class="s3">&quot;*&quot;</span><span class="s1">);</span>
				<span class="s1">eps_shrink = max(eps_shrink/</span><span class="s5">2</span><span class="s1">, eps);</span>
				<span class="s1">start_from_all = </span><span class="s4">true</span><span class="s1">;</span>
			<span class="s1">}</span>
		<span class="s1">}</span>
		<span class="s2">else</span>
			<span class="s1">start_from_all = </span><span class="s2">false</span><span class="s1">;</span>
	<span class="s1">}</span>

	<span class="s1">info(</span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">optimization finished, #iter = %d</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">,iter);</span>
	<span class="s2">if </span><span class="s1">(iter &gt;= max_iter)</span>
		<span class="s1">info(</span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">WARNING: reaching max number of iterations</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">);</span>

	<span class="s0">// calculate objective value</span>
	<span class="s2">double </span><span class="s1">v = </span><span class="s5">0</span><span class="s1">;</span>
	<span class="s2">int </span><span class="s1">nSV = </span><span class="s5">0</span><span class="s1">;</span>
	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;w_size*nr_class;i++)</span>
		<span class="s1">v += w[i]*w[i];</span>
	<span class="s1">v = </span><span class="s5">0.5</span><span class="s1">*v;</span>
	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;l*nr_class;i++)</span>
	<span class="s1">{</span>
		<span class="s1">v += alpha[i];</span>
		<span class="s2">if</span><span class="s1">(fabs(alpha[i]) &gt; </span><span class="s5">0</span><span class="s1">)</span>
			<span class="s1">nSV++;</span>
	<span class="s1">}</span>
	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;l;i++)</span>
		<span class="s1">v -= alpha[i*nr_class+(</span><span class="s2">int</span><span class="s1">)prob</span><span class="s6">-&gt;</span><span class="s1">y[i]];</span>
	<span class="s1">info(</span><span class="s3">&quot;Objective value = %lf</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">,v);</span>
	<span class="s1">info(</span><span class="s3">&quot;nSV = %d</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">,nSV);</span>

	<span class="s2">delete </span><span class="s1">[] alpha;</span>
	<span class="s2">delete </span><span class="s1">[] alpha_new;</span>
	<span class="s2">delete </span><span class="s1">[] index;</span>
	<span class="s2">delete </span><span class="s1">[] QD;</span>
	<span class="s2">delete </span><span class="s1">[] d_ind;</span>
	<span class="s2">delete </span><span class="s1">[] d_val;</span>
	<span class="s2">delete </span><span class="s1">[] alpha_index;</span>
	<span class="s2">delete </span><span class="s1">[] y_index;</span>
	<span class="s2">delete </span><span class="s1">[] active_size_i;</span>
	<span class="s2">return </span><span class="s1">iter;</span>
<span class="s1">}</span>

<span class="s0">// A coordinate descent algorithm for</span>
<span class="s0">// L1-loss and L2-loss SVM dual problems</span>
<span class="s0">//</span>
<span class="s0">//  min_\alpha  0.5(\alpha^T (Q + D)\alpha) - e^T \alpha,</span>
<span class="s0">//    s.t.      0 &lt;= \alpha_i &lt;= upper_bound_i,</span>
<span class="s0">//</span>
<span class="s0">//  where Qij = yi yj xi^T xj and</span>
<span class="s0">//  D is a diagonal matrix</span>
<span class="s0">//</span>
<span class="s0">// In L1-SVM case:</span>
<span class="s0">//      upper_bound_i = Cp if y_i = 1</span>
<span class="s0">//      upper_bound_i = Cn if y_i = -1</span>
<span class="s0">//      D_ii = 0</span>
<span class="s0">// In L2-SVM case:</span>
<span class="s0">//      upper_bound_i = INF</span>
<span class="s0">//      D_ii = 1/(2*Cp) if y_i = 1</span>
<span class="s0">//      D_ii = 1/(2*Cn) if y_i = -1</span>
<span class="s0">//</span>
<span class="s0">// Given:</span>
<span class="s0">// x, y, Cp, Cn</span>
<span class="s0">// eps is the stopping tolerance</span>
<span class="s0">//</span>
<span class="s0">// solution will be put in w</span>
<span class="s0">//</span>
<span class="s0">// See Algorithm 3 of Hsieh et al., ICML 2008</span>

<span class="s2">#undef </span><span class="s1">GETI</span>
<span class="s2">#define </span><span class="s1">GETI(i) (i)</span>
<span class="s0">// To support weights for instances, use GETI(i) (i)</span>

<span class="s2">static int </span><span class="s1">solve_l2r_l1l2_svc(</span>
	<span class="s2">const </span><span class="s1">problem *prob, </span><span class="s2">double </span><span class="s1">*w, </span><span class="s2">double </span><span class="s1">eps,</span>
	<span class="s2">double </span><span class="s1">Cp, </span><span class="s2">double </span><span class="s1">Cn, </span><span class="s2">int </span><span class="s1">solver_type, </span><span class="s2">int </span><span class="s1">max_iter)</span>
<span class="s1">{</span>
	<span class="s2">int </span><span class="s1">l = prob</span><span class="s6">-&gt;</span><span class="s1">l;</span>
	<span class="s2">int </span><span class="s1">w_size = prob</span><span class="s6">-&gt;</span><span class="s1">n;</span>
	<span class="s2">int </span><span class="s1">i, s, iter = </span><span class="s5">0</span><span class="s1">;</span>
	<span class="s2">double </span><span class="s1">C, d, G;</span>
	<span class="s2">double </span><span class="s1">*QD = </span><span class="s4">new </span><span class="s2">double</span><span class="s1">[l];</span>
	<span class="s2">int </span><span class="s1">*index = </span><span class="s4">new </span><span class="s2">int</span><span class="s1">[l];</span>
	<span class="s2">double </span><span class="s1">*alpha = </span><span class="s4">new </span><span class="s2">double</span><span class="s1">[l];</span>
	<span class="s1">schar *y = </span><span class="s4">new </span><span class="s1">schar[l];</span>
	<span class="s2">int </span><span class="s1">active_size = l;</span>

	<span class="s0">// PG: projected gradient, for shrinking and stopping</span>
	<span class="s2">double </span><span class="s1">PG;</span>
	<span class="s2">double </span><span class="s1">PGmax_old = INF;</span>
	<span class="s2">double </span><span class="s1">PGmin_old = -INF;</span>
	<span class="s2">double </span><span class="s1">PGmax_new, PGmin_new;</span>

	<span class="s0">// default solver_type: L2R_L2LOSS_SVC_DUAL</span>
	<span class="s2">double </span><span class="s1">*diag = </span><span class="s4">new </span><span class="s2">double</span><span class="s1">[l];</span>
	<span class="s2">double </span><span class="s1">*upper_bound = </span><span class="s4">new </span><span class="s2">double</span><span class="s1">[l];</span>
	<span class="s2">double </span><span class="s1">*C_ = </span><span class="s4">new </span><span class="s2">double</span><span class="s1">[l];</span>
	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">; i&lt;l; i++)</span>
	<span class="s1">{</span>
		<span class="s2">if</span><span class="s1">(prob</span><span class="s6">-&gt;</span><span class="s1">y[i]&gt;</span><span class="s5">0</span><span class="s1">)</span>
			<span class="s1">C_[i] = prob</span><span class="s6">-&gt;</span><span class="s1">W[i] * Cp;</span>
		<span class="s2">else</span>
			<span class="s1">C_[i] = prob</span><span class="s6">-&gt;</span><span class="s1">W[i] * Cn;</span>
		<span class="s1">diag[i] = </span><span class="s5">0.5</span><span class="s1">/C_[i];</span>
		<span class="s1">upper_bound[i] = INF;</span>
	<span class="s1">}</span>
	<span class="s2">if</span><span class="s1">(solver_type == L2R_L1LOSS_SVC_DUAL)</span>
	<span class="s1">{</span>
		<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">; i&lt;l; i++)</span>
		<span class="s1">{</span>
			<span class="s1">diag[i] = </span><span class="s5">0</span><span class="s1">;</span>
			<span class="s1">upper_bound[i] = C_[i];</span>
		<span class="s1">}</span>
	<span class="s1">}</span>

	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">; i&lt;l; i++)</span>
	<span class="s1">{</span>
		<span class="s2">if</span><span class="s1">(prob</span><span class="s6">-&gt;</span><span class="s1">y[i] &gt; </span><span class="s5">0</span><span class="s1">)</span>
		<span class="s1">{</span>
			<span class="s1">y[i] = +</span><span class="s5">1</span><span class="s1">;</span>
		<span class="s1">}</span>
		<span class="s2">else</span>
		<span class="s1">{</span>
			<span class="s1">y[i] = -</span><span class="s5">1</span><span class="s1">;</span>
		<span class="s1">}</span>
	<span class="s1">}</span>

	<span class="s0">// Initial alpha can be set here. Note that</span>
	<span class="s0">// 0 &lt;= alpha[i] &lt;= upper_bound[GETI(i)]</span>
	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">; i&lt;l; i++)</span>
		<span class="s1">alpha[i] = </span><span class="s5">0</span><span class="s1">;</span>

	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">; i&lt;w_size; i++)</span>
		<span class="s1">w[i] = </span><span class="s5">0</span><span class="s1">;</span>
	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">; i&lt;l; i++)</span>
	<span class="s1">{</span>
		<span class="s1">QD[i] = diag[GETI(i)];</span>

		<span class="s1">feature_node *xi = prob</span><span class="s6">-&gt;</span><span class="s1">x[i];</span>
		<span class="s2">while </span><span class="s1">(xi</span><span class="s6">-&gt;</span><span class="s1">index != -</span><span class="s5">1</span><span class="s1">)</span>
		<span class="s1">{</span>
			<span class="s2">double </span><span class="s1">val = xi</span><span class="s6">-&gt;</span><span class="s1">value;</span>
			<span class="s1">QD[i] += val*val;</span>
			<span class="s1">w[xi</span><span class="s6">-&gt;</span><span class="s1">index-1] += y[i]*alpha[i]*val;</span>
			<span class="s1">xi++;</span>
		<span class="s1">}</span>
		<span class="s1">index[i] = i;</span>
	<span class="s1">}</span>

	<span class="s2">while </span><span class="s1">(iter &lt; max_iter)</span>
	<span class="s1">{</span>
		<span class="s1">PGmax_new = -INF;</span>
		<span class="s1">PGmin_new = INF;</span>

		<span class="s2">for </span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">; i&lt;active_size; i++)</span>
		<span class="s1">{</span>
			<span class="s2">int </span><span class="s1">j = i+bounded_rand_int(active_size-i);</span>
			<span class="s1">swap(index[i], index[j]);</span>
		<span class="s1">}</span>

		<span class="s2">for </span><span class="s1">(s=</span><span class="s5">0</span><span class="s1">; s&lt;active_size; s++)</span>
		<span class="s1">{</span>
			<span class="s1">i = index[s];</span>
			<span class="s1">G = </span><span class="s5">0</span><span class="s1">;</span>
			<span class="s1">schar yi = y[i];</span>

			<span class="s1">feature_node *xi = prob</span><span class="s6">-&gt;</span><span class="s1">x[i];</span>
			<span class="s2">while</span><span class="s1">(xi</span><span class="s6">-&gt;</span><span class="s1">index!= -</span><span class="s5">1</span><span class="s1">)</span>
			<span class="s1">{</span>
				<span class="s1">G += w[xi</span><span class="s6">-&gt;</span><span class="s1">index-1]*(xi</span><span class="s6">-&gt;</span><span class="s1">value);</span>
				<span class="s1">xi++;</span>
			<span class="s1">}</span>
			<span class="s1">G = G*yi-1;</span>

			<span class="s1">C = upper_bound[GETI(i)];</span>
			<span class="s1">G += alpha[i]*diag[GETI(i)];</span>

			<span class="s1">PG = </span><span class="s5">0</span><span class="s1">;</span>
			<span class="s2">if </span><span class="s1">(alpha[i] == </span><span class="s5">0</span><span class="s1">)</span>
			<span class="s1">{</span>
				<span class="s2">if </span><span class="s1">(G &gt; PGmax_old)</span>
				<span class="s1">{</span>
					<span class="s1">active_size--;</span>
					<span class="s1">swap(index[s], index[active_size]);</span>
					<span class="s1">s--;</span>
					<span class="s2">continue</span><span class="s1">;</span>
				<span class="s1">}</span>
				<span class="s2">else if </span><span class="s1">(G &lt; </span><span class="s5">0</span><span class="s1">)</span>
					<span class="s1">PG = G;</span>
			<span class="s1">}</span>
			<span class="s2">else if </span><span class="s1">(alpha[i] == C)</span>
			<span class="s1">{</span>
				<span class="s2">if </span><span class="s1">(G &lt; PGmin_old)</span>
				<span class="s1">{</span>
					<span class="s1">active_size--;</span>
					<span class="s1">swap(index[s], index[active_size]);</span>
					<span class="s1">s--;</span>
					<span class="s2">continue</span><span class="s1">;</span>
				<span class="s1">}</span>
				<span class="s2">else if </span><span class="s1">(G &gt; </span><span class="s5">0</span><span class="s1">)</span>
					<span class="s1">PG = G;</span>
			<span class="s1">}</span>
			<span class="s2">else</span>
				<span class="s1">PG = G;</span>

			<span class="s1">PGmax_new = max(PGmax_new, PG);</span>
			<span class="s1">PGmin_new = min(PGmin_new, PG);</span>

			<span class="s2">if</span><span class="s1">(fabs(PG) &gt; </span><span class="s5">1</span><span class="s1">.</span><span class="s5">0</span><span class="s1">e-12)</span>
			<span class="s1">{</span>
				<span class="s2">double </span><span class="s1">alpha_old = alpha[i];</span>
				<span class="s1">alpha[i] = min(max(alpha[i] - G/QD[i], </span><span class="s5">0.0</span><span class="s1">), C);</span>
				<span class="s1">d = (alpha[i] - alpha_old)*yi;</span>
				<span class="s1">xi = prob</span><span class="s6">-&gt;</span><span class="s1">x[i];</span>
				<span class="s2">while </span><span class="s1">(xi</span><span class="s6">-&gt;</span><span class="s1">index != -</span><span class="s5">1</span><span class="s1">)</span>
				<span class="s1">{</span>
					<span class="s1">w[xi</span><span class="s6">-&gt;</span><span class="s1">index-1] += d*xi</span><span class="s6">-&gt;</span><span class="s1">value;</span>
					<span class="s1">xi++;</span>
				<span class="s1">}</span>
			<span class="s1">}</span>
		<span class="s1">}</span>

		<span class="s1">iter++;</span>
		<span class="s2">if</span><span class="s1">(iter % </span><span class="s5">10 </span><span class="s1">== </span><span class="s5">0</span><span class="s1">)</span>
			<span class="s1">info(</span><span class="s3">&quot;.&quot;</span><span class="s1">);</span>

		<span class="s2">if</span><span class="s1">(PGmax_new - PGmin_new &lt;= eps)</span>
		<span class="s1">{</span>
			<span class="s2">if</span><span class="s1">(active_size == l)</span>
				<span class="s2">break</span><span class="s1">;</span>
			<span class="s2">else</span>
			<span class="s1">{</span>
				<span class="s1">active_size = l;</span>
				<span class="s1">info(</span><span class="s3">&quot;*&quot;</span><span class="s1">);</span>
				<span class="s1">PGmax_old = INF;</span>
				<span class="s1">PGmin_old = -INF;</span>
				<span class="s2">continue</span><span class="s1">;</span>
			<span class="s1">}</span>
		<span class="s1">}</span>
		<span class="s1">PGmax_old = PGmax_new;</span>
		<span class="s1">PGmin_old = PGmin_new;</span>
		<span class="s2">if </span><span class="s1">(PGmax_old &lt;= </span><span class="s5">0</span><span class="s1">)</span>
			<span class="s1">PGmax_old = INF;</span>
		<span class="s2">if </span><span class="s1">(PGmin_old &gt;= </span><span class="s5">0</span><span class="s1">)</span>
			<span class="s1">PGmin_old = -INF;</span>
	<span class="s1">}</span>

	<span class="s1">info(</span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">optimization finished, #iter = %d</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">,iter);</span>
	<span class="s2">if </span><span class="s1">(iter &gt;= max_iter)</span>
		<span class="s1">info(</span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">WARNING: reaching max number of iterations</span><span class="s2">\n</span><span class="s3">Using -s 2 may be faster (also see FAQ)</span><span class="s2">\n\n</span><span class="s3">&quot;</span><span class="s1">);</span>

	<span class="s0">// calculate objective value</span>

	<span class="s2">double </span><span class="s1">v = </span><span class="s5">0</span><span class="s1">;</span>
	<span class="s2">int </span><span class="s1">nSV = </span><span class="s5">0</span><span class="s1">;</span>
	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">; i&lt;w_size; i++)</span>
		<span class="s1">v += w[i]*w[i];</span>
	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">; i&lt;l; i++)</span>
	<span class="s1">{</span>
		<span class="s1">v += alpha[i]*(alpha[i]*diag[GETI(i)] - </span><span class="s5">2</span><span class="s1">);</span>
		<span class="s2">if</span><span class="s1">(alpha[i] &gt; </span><span class="s5">0</span><span class="s1">)</span>
			<span class="s1">++nSV;</span>
	<span class="s1">}</span>
	<span class="s1">info(</span><span class="s3">&quot;Objective value = %lf</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">,v/</span><span class="s5">2</span><span class="s1">);</span>
	<span class="s1">info(</span><span class="s3">&quot;nSV = %d</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">,nSV);</span>

	<span class="s2">delete </span><span class="s1">[] QD;</span>
	<span class="s2">delete </span><span class="s1">[] alpha;</span>
	<span class="s2">delete </span><span class="s1">[] y;</span>
	<span class="s2">delete </span><span class="s1">[] index;</span>
	<span class="s2">delete </span><span class="s1">[] diag;</span>
	<span class="s2">delete </span><span class="s1">[] upper_bound;</span>
	<span class="s2">delete </span><span class="s1">[] C_;</span>
	<span class="s2">return </span><span class="s1">iter;</span>
<span class="s1">}</span>


<span class="s0">// A coordinate descent algorithm for</span>
<span class="s0">// L1-loss and L2-loss epsilon-SVR dual problem</span>
<span class="s0">//</span>
<span class="s0">//  min_\beta  0.5\beta^T (Q + diag(lambda)) \beta - p \sum_{i=1}^l|\beta_i| + \sum_{i=1}^l yi\beta_i,</span>
<span class="s0">//    s.t.      -upper_bound_i &lt;= \beta_i &lt;= upper_bound_i,</span>
<span class="s0">//</span>
<span class="s0">//  where Qij = xi^T xj and</span>
<span class="s0">//  D is a diagonal matrix</span>
<span class="s0">//</span>
<span class="s0">// In L1-SVM case:</span>
<span class="s0">//      upper_bound_i = C</span>
<span class="s0">//      lambda_i = 0</span>
<span class="s0">// In L2-SVM case:</span>
<span class="s0">//      upper_bound_i = INF</span>
<span class="s0">//      lambda_i = 1/(2*C)</span>
<span class="s0">//</span>
<span class="s0">// Given:</span>
<span class="s0">// x, y, p, C</span>
<span class="s0">// eps is the stopping tolerance</span>
<span class="s0">//</span>
<span class="s0">// solution will be put in w</span>
<span class="s0">//</span>
<span class="s0">// See Algorithm 4 of Ho and Lin, 2012</span>

<span class="s2">#undef </span><span class="s1">GETI</span>
<span class="s2">#define </span><span class="s1">GETI(i) (i)</span>
<span class="s0">// To support weights for instances, use GETI(i) (i)</span>

<span class="s2">static int </span><span class="s1">solve_l2r_l1l2_svr(</span>
	<span class="s2">const </span><span class="s1">problem *prob, </span><span class="s2">double </span><span class="s1">*w, </span><span class="s2">const </span><span class="s1">parameter *param,</span>
	<span class="s2">int </span><span class="s1">solver_type, </span><span class="s2">int </span><span class="s1">max_iter)</span>
<span class="s1">{</span>
	<span class="s2">int </span><span class="s1">l = prob</span><span class="s6">-&gt;</span><span class="s1">l;</span>
	<span class="s2">double </span><span class="s1">C = param</span><span class="s6">-&gt;</span><span class="s1">C;</span>
	<span class="s2">double </span><span class="s1">p = param</span><span class="s6">-&gt;</span><span class="s1">p;</span>
	<span class="s2">int </span><span class="s1">w_size = prob</span><span class="s6">-&gt;</span><span class="s1">n;</span>
	<span class="s2">double </span><span class="s1">eps = param</span><span class="s6">-&gt;</span><span class="s1">eps;</span>
	<span class="s2">int </span><span class="s1">i, s, iter = </span><span class="s5">0</span><span class="s1">;</span>
	<span class="s2">int </span><span class="s1">active_size = l;</span>
	<span class="s2">int </span><span class="s1">*index = </span><span class="s4">new </span><span class="s2">int</span><span class="s1">[l];</span>

	<span class="s2">double </span><span class="s1">d, G, H;</span>
	<span class="s2">double </span><span class="s1">Gmax_old = INF;</span>
	<span class="s2">double </span><span class="s1">Gmax_new, Gnorm1_new;</span>
	<span class="s2">double </span><span class="s1">Gnorm1_init = -</span><span class="s5">1.0</span><span class="s1">; </span><span class="s0">// Gnorm1_init is initialized at the first iteration</span>
	<span class="s2">double </span><span class="s1">*beta = </span><span class="s4">new </span><span class="s2">double</span><span class="s1">[l];</span>
	<span class="s2">double </span><span class="s1">*QD = </span><span class="s4">new </span><span class="s2">double</span><span class="s1">[l];</span>
	<span class="s2">double </span><span class="s1">*y = prob</span><span class="s6">-&gt;</span><span class="s1">y;</span>

	<span class="s0">// L2R_L2LOSS_SVR_DUAL</span>
	<span class="s2">double </span><span class="s1">*lambda = </span><span class="s4">new </span><span class="s2">double</span><span class="s1">[l];</span>
	<span class="s2">double </span><span class="s1">*upper_bound = </span><span class="s4">new </span><span class="s2">double</span><span class="s1">[l];</span>
	<span class="s2">double </span><span class="s1">*C_ = </span><span class="s4">new </span><span class="s2">double</span><span class="s1">[l];</span>
	<span class="s2">for </span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">; i&lt;l; i++)</span>
	<span class="s1">{</span>
		<span class="s1">C_[i] = prob</span><span class="s6">-&gt;</span><span class="s1">W[i] * C;</span>
		<span class="s1">lambda[i] = </span><span class="s5">0.5</span><span class="s1">/C_[i];</span>
		<span class="s1">upper_bound[i] = INF;</span>
	<span class="s1">}</span>
	<span class="s2">if</span><span class="s1">(solver_type == L2R_L1LOSS_SVR_DUAL)</span>
	<span class="s1">{</span>
		<span class="s2">for </span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">; i&lt;l; i++)</span>
		<span class="s1">{</span>
			<span class="s1">lambda[i] = </span><span class="s5">0</span><span class="s1">;</span>
			<span class="s1">upper_bound[i] = C_[i];</span>
		<span class="s1">}</span>
	<span class="s1">}</span>

	<span class="s0">// Initial beta can be set here. Note that</span>
	<span class="s0">// -upper_bound &lt;= beta[i] &lt;= upper_bound</span>
	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">; i&lt;l; i++)</span>
		<span class="s1">beta[i] = </span><span class="s5">0</span><span class="s1">;</span>

	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">; i&lt;w_size; i++)</span>
		<span class="s1">w[i] = </span><span class="s5">0</span><span class="s1">;</span>
	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">; i&lt;l; i++)</span>
	<span class="s1">{</span>
		<span class="s1">QD[i] = </span><span class="s5">0</span><span class="s1">;</span>
		<span class="s1">feature_node *xi = prob</span><span class="s6">-&gt;</span><span class="s1">x[i];</span>
		<span class="s2">while</span><span class="s1">(xi</span><span class="s6">-&gt;</span><span class="s1">index != -</span><span class="s5">1</span><span class="s1">)</span>
		<span class="s1">{</span>
			<span class="s2">double </span><span class="s1">val = xi</span><span class="s6">-&gt;</span><span class="s1">value;</span>
			<span class="s1">QD[i] += val*val;</span>
			<span class="s1">w[xi</span><span class="s6">-&gt;</span><span class="s1">index-1] += beta[i]*val;</span>
			<span class="s1">xi++;</span>
		<span class="s1">}</span>

		<span class="s1">index[i] = i;</span>
	<span class="s1">}</span>


	<span class="s2">while</span><span class="s1">(iter &lt; max_iter)</span>
	<span class="s1">{</span>
		<span class="s1">Gmax_new = </span><span class="s5">0</span><span class="s1">;</span>
		<span class="s1">Gnorm1_new = </span><span class="s5">0</span><span class="s1">;</span>

		<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">; i&lt;active_size; i++)</span>
		<span class="s1">{</span>
			<span class="s2">int </span><span class="s1">j = i+bounded_rand_int(active_size-i);</span>
			<span class="s1">swap(index[i], index[j]);</span>
		<span class="s1">}</span>

		<span class="s2">for</span><span class="s1">(s=</span><span class="s5">0</span><span class="s1">; s&lt;active_size; s++)</span>
		<span class="s1">{</span>
			<span class="s1">i = index[s];</span>
			<span class="s1">G = -y[i] + lambda[GETI(i)]*beta[i];</span>
			<span class="s1">H = QD[i] + lambda[GETI(i)];</span>

			<span class="s1">feature_node *xi = prob</span><span class="s6">-&gt;</span><span class="s1">x[i];</span>
			<span class="s2">while</span><span class="s1">(xi</span><span class="s6">-&gt;</span><span class="s1">index != -</span><span class="s5">1</span><span class="s1">)</span>
			<span class="s1">{</span>
				<span class="s2">int </span><span class="s1">ind = xi</span><span class="s6">-&gt;</span><span class="s1">index-1;</span>
				<span class="s2">double </span><span class="s1">val = xi</span><span class="s6">-&gt;</span><span class="s1">value;</span>
				<span class="s1">G += val*w[ind];</span>
				<span class="s1">xi++;</span>
			<span class="s1">}</span>

			<span class="s2">double </span><span class="s1">Gp = G+p;</span>
			<span class="s2">double </span><span class="s1">Gn = G-p;</span>
			<span class="s2">double </span><span class="s1">violation = </span><span class="s5">0</span><span class="s1">;</span>
			<span class="s2">if</span><span class="s1">(beta[i] == </span><span class="s5">0</span><span class="s1">)</span>
			<span class="s1">{</span>
				<span class="s2">if</span><span class="s1">(Gp &lt; </span><span class="s5">0</span><span class="s1">)</span>
					<span class="s1">violation = -Gp;</span>
				<span class="s2">else if</span><span class="s1">(Gn &gt; </span><span class="s5">0</span><span class="s1">)</span>
					<span class="s1">violation = Gn;</span>
				<span class="s2">else if</span><span class="s1">(Gp&gt;Gmax_old &amp;&amp; Gn&lt;-Gmax_old)</span>
				<span class="s1">{</span>
					<span class="s1">active_size--;</span>
					<span class="s1">swap(index[s], index[active_size]);</span>
					<span class="s1">s--;</span>
					<span class="s2">continue</span><span class="s1">;</span>
				<span class="s1">}</span>
			<span class="s1">}</span>
			<span class="s2">else if</span><span class="s1">(beta[i] &gt;= upper_bound[GETI(i)])</span>
			<span class="s1">{</span>
				<span class="s2">if</span><span class="s1">(Gp &gt; </span><span class="s5">0</span><span class="s1">)</span>
					<span class="s1">violation = Gp;</span>
				<span class="s2">else if</span><span class="s1">(Gp &lt; -Gmax_old)</span>
				<span class="s1">{</span>
					<span class="s1">active_size--;</span>
					<span class="s1">swap(index[s], index[active_size]);</span>
					<span class="s1">s--;</span>
					<span class="s2">continue</span><span class="s1">;</span>
				<span class="s1">}</span>
			<span class="s1">}</span>
			<span class="s2">else if</span><span class="s1">(beta[i] &lt;= -upper_bound[GETI(i)])</span>
			<span class="s1">{</span>
				<span class="s2">if</span><span class="s1">(Gn &lt; </span><span class="s5">0</span><span class="s1">)</span>
					<span class="s1">violation = -Gn;</span>
				<span class="s2">else if</span><span class="s1">(Gn &gt; Gmax_old)</span>
				<span class="s1">{</span>
					<span class="s1">active_size--;</span>
					<span class="s1">swap(index[s], index[active_size]);</span>
					<span class="s1">s--;</span>
					<span class="s2">continue</span><span class="s1">;</span>
				<span class="s1">}</span>
			<span class="s1">}</span>
			<span class="s2">else if</span><span class="s1">(beta[i] &gt; </span><span class="s5">0</span><span class="s1">)</span>
				<span class="s1">violation = fabs(Gp);</span>
			<span class="s2">else</span>
				<span class="s1">violation = fabs(Gn);</span>

			<span class="s1">Gmax_new = max(Gmax_new, violation);</span>
			<span class="s1">Gnorm1_new += violation;</span>

			<span class="s0">// obtain Newton direction d</span>
			<span class="s2">if</span><span class="s1">(Gp &lt; H*beta[i])</span>
				<span class="s1">d = -Gp/H;</span>
			<span class="s2">else if</span><span class="s1">(Gn &gt; H*beta[i])</span>
				<span class="s1">d = -Gn/H;</span>
			<span class="s2">else</span>
				<span class="s1">d = -beta[i];</span>

			<span class="s2">if</span><span class="s1">(fabs(d) &lt; </span><span class="s5">1</span><span class="s1">.</span><span class="s5">0</span><span class="s1">e-12)</span>
				<span class="s2">continue</span><span class="s1">;</span>

			<span class="s2">double </span><span class="s1">beta_old = beta[i];</span>
			<span class="s1">beta[i] = min(max(beta[i]+d, -upper_bound[GETI(i)]), upper_bound[GETI(i)]);</span>
			<span class="s1">d = beta[i]-beta_old;</span>

			<span class="s2">if</span><span class="s1">(d != </span><span class="s5">0</span><span class="s1">)</span>
			<span class="s1">{</span>
				<span class="s1">xi = prob</span><span class="s6">-&gt;</span><span class="s1">x[i];</span>
				<span class="s2">while</span><span class="s1">(xi</span><span class="s6">-&gt;</span><span class="s1">index != -</span><span class="s5">1</span><span class="s1">)</span>
				<span class="s1">{</span>
					<span class="s1">w[xi</span><span class="s6">-&gt;</span><span class="s1">index-1] += d*xi</span><span class="s6">-&gt;</span><span class="s1">value;</span>
					<span class="s1">xi++;</span>
				<span class="s1">}</span>
			<span class="s1">}</span>
		<span class="s1">}</span>

		<span class="s2">if</span><span class="s1">(iter == </span><span class="s5">0</span><span class="s1">)</span>
			<span class="s1">Gnorm1_init = Gnorm1_new;</span>
		<span class="s1">iter++;</span>
		<span class="s2">if</span><span class="s1">(iter % </span><span class="s5">10 </span><span class="s1">== </span><span class="s5">0</span><span class="s1">)</span>
			<span class="s1">info(</span><span class="s3">&quot;.&quot;</span><span class="s1">);</span>

		<span class="s2">if</span><span class="s1">(Gnorm1_new &lt;= eps*Gnorm1_init)</span>
		<span class="s1">{</span>
			<span class="s2">if</span><span class="s1">(active_size == l)</span>
				<span class="s2">break</span><span class="s1">;</span>
			<span class="s2">else</span>
			<span class="s1">{</span>
				<span class="s1">active_size = l;</span>
				<span class="s1">info(</span><span class="s3">&quot;*&quot;</span><span class="s1">);</span>
				<span class="s1">Gmax_old = INF;</span>
				<span class="s2">continue</span><span class="s1">;</span>
			<span class="s1">}</span>
		<span class="s1">}</span>

		<span class="s1">Gmax_old = Gmax_new;</span>
	<span class="s1">}</span>

	<span class="s1">info(</span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">optimization finished, #iter = %d</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">, iter);</span>
	<span class="s2">if</span><span class="s1">(iter &gt;= max_iter)</span>
		<span class="s1">info(</span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">WARNING: reaching max number of iterations</span><span class="s2">\n</span><span class="s3">Using -s 11 may be faster</span><span class="s2">\n\n</span><span class="s3">&quot;</span><span class="s1">);</span>

	<span class="s0">// calculate objective value</span>
	<span class="s2">double </span><span class="s1">v = </span><span class="s5">0</span><span class="s1">;</span>
	<span class="s2">int </span><span class="s1">nSV = </span><span class="s5">0</span><span class="s1">;</span>
	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">; i&lt;w_size; i++)</span>
		<span class="s1">v += w[i]*w[i];</span>
	<span class="s1">v = </span><span class="s5">0.5</span><span class="s1">*v;</span>
	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">; i&lt;l; i++)</span>
	<span class="s1">{</span>
		<span class="s1">v += p*fabs(beta[i]) - y[i]*beta[i] + </span><span class="s5">0.5</span><span class="s1">*lambda[GETI(i)]*beta[i]*beta[i];</span>
		<span class="s2">if</span><span class="s1">(beta[i] != </span><span class="s5">0</span><span class="s1">)</span>
			<span class="s1">nSV++;</span>
	<span class="s1">}</span>

	<span class="s1">info(</span><span class="s3">&quot;Objective value = %lf</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">, v);</span>
	<span class="s1">info(</span><span class="s3">&quot;nSV = %d</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">,nSV);</span>

	<span class="s2">delete </span><span class="s1">[] beta;</span>
	<span class="s2">delete </span><span class="s1">[] QD;</span>
	<span class="s2">delete </span><span class="s1">[] index;</span>
	<span class="s2">delete </span><span class="s1">[] lambda;</span>
	<span class="s2">delete </span><span class="s1">[] upper_bound;</span>
	<span class="s2">delete </span><span class="s1">[] C_;</span>
	<span class="s2">return </span><span class="s1">iter;</span>
<span class="s1">}</span>


<span class="s0">// A coordinate descent algorithm for</span>
<span class="s0">// the dual of L2-regularized logistic regression problems</span>
<span class="s0">//</span>
<span class="s0">//  min_\alpha  0.5(\alpha^T Q \alpha) + \sum \alpha_i log (\alpha_i) + (upper_bound_i - \alpha_i) log (upper_bound_i - \alpha_i),</span>
<span class="s0">//    s.t.      0 &lt;= \alpha_i &lt;= upper_bound_i,</span>
<span class="s0">//</span>
<span class="s0">//  where Qij = yi yj xi^T xj and</span>
<span class="s0">//  upper_bound_i = Cp if y_i = 1</span>
<span class="s0">//  upper_bound_i = Cn if y_i = -1</span>
<span class="s0">//</span>
<span class="s0">// Given:</span>
<span class="s0">// x, y, Cp, Cn</span>
<span class="s0">// eps is the stopping tolerance</span>
<span class="s0">//</span>
<span class="s0">// solution will be put in w</span>
<span class="s0">//</span>
<span class="s0">// See Algorithm 5 of Yu et al., MLJ 2010</span>

<span class="s2">#undef </span><span class="s1">GETI</span>
<span class="s2">#define </span><span class="s1">GETI(i) (i)</span>
<span class="s0">// To support weights for instances, use GETI(i) (i)</span>

<span class="s2">int </span><span class="s1">solve_l2r_lr_dual(</span><span class="s2">const </span><span class="s1">problem *prob, </span><span class="s2">double </span><span class="s1">*w, </span><span class="s2">double </span><span class="s1">eps, </span><span class="s2">double </span><span class="s1">Cp, </span><span class="s2">double </span><span class="s1">Cn,</span>
					   <span class="s2">int </span><span class="s1">max_iter)</span>
<span class="s1">{</span>
	<span class="s2">int </span><span class="s1">l = prob</span><span class="s6">-&gt;</span><span class="s1">l;</span>
	<span class="s2">int </span><span class="s1">w_size = prob</span><span class="s6">-&gt;</span><span class="s1">n;</span>
	<span class="s2">int </span><span class="s1">i, s, iter = </span><span class="s5">0</span><span class="s1">;</span>
	<span class="s2">double </span><span class="s1">*xTx = </span><span class="s4">new </span><span class="s2">double</span><span class="s1">[l];</span>
	<span class="s2">int </span><span class="s1">*index = </span><span class="s4">new </span><span class="s2">int</span><span class="s1">[l];</span>
	<span class="s2">double </span><span class="s1">*alpha = </span><span class="s4">new </span><span class="s2">double</span><span class="s1">[</span><span class="s5">2</span><span class="s1">*l]; </span><span class="s0">// store alpha and C - alpha</span>
	<span class="s1">schar *y = </span><span class="s4">new </span><span class="s1">schar[l];</span>
	<span class="s2">int </span><span class="s1">max_inner_iter = </span><span class="s5">100</span><span class="s1">; </span><span class="s0">// for inner Newton</span>
	<span class="s2">double </span><span class="s1">innereps = </span><span class="s5">1</span><span class="s1">e-2;</span>
	<span class="s2">double </span><span class="s1">innereps_min = min(</span><span class="s5">1</span><span class="s1">e-8, eps);</span>
	<span class="s2">double </span><span class="s1">*upper_bound = </span><span class="s4">new </span><span class="s2">double </span><span class="s1">[l];</span>

	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">; i&lt;l; i++)</span>
	<span class="s1">{</span>
		<span class="s2">if</span><span class="s1">(prob</span><span class="s6">-&gt;</span><span class="s1">y[i] &gt; </span><span class="s5">0</span><span class="s1">)</span>
		<span class="s1">{</span>
			<span class="s1">upper_bound[i] = prob</span><span class="s6">-&gt;</span><span class="s1">W[i] * Cp;</span>
			<span class="s1">y[i] = +</span><span class="s5">1</span><span class="s1">;</span>
		<span class="s1">}</span>
		<span class="s2">else</span>
		<span class="s1">{</span>
			<span class="s1">upper_bound[i] = prob</span><span class="s6">-&gt;</span><span class="s1">W[i] * Cn;</span>
			<span class="s1">y[i] = -</span><span class="s5">1</span><span class="s1">;</span>
		<span class="s1">}</span>
	<span class="s1">}</span>

	<span class="s0">// Initial alpha can be set here. Note that</span>
	<span class="s0">// 0 &lt; alpha[i] &lt; upper_bound[GETI(i)]</span>
	<span class="s0">// alpha[2*i] + alpha[2*i+1] = upper_bound[GETI(i)]</span>
	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">; i&lt;l; i++)</span>
	<span class="s1">{</span>
		<span class="s1">alpha[</span><span class="s5">2</span><span class="s1">*i] = min(</span><span class="s5">0.001</span><span class="s1">*upper_bound[GETI(i)], </span><span class="s5">1</span><span class="s1">e-8);</span>
		<span class="s1">alpha[</span><span class="s5">2</span><span class="s1">*i+</span><span class="s5">1</span><span class="s1">] = upper_bound[GETI(i)] - alpha[</span><span class="s5">2</span><span class="s1">*i];</span>
	<span class="s1">}</span>

	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">; i&lt;w_size; i++)</span>
		<span class="s1">w[i] = </span><span class="s5">0</span><span class="s1">;</span>
	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">; i&lt;l; i++)</span>
	<span class="s1">{</span>
		<span class="s1">xTx[i] = </span><span class="s5">0</span><span class="s1">;</span>
		<span class="s1">feature_node *xi = prob</span><span class="s6">-&gt;</span><span class="s1">x[i];</span>
		<span class="s2">while </span><span class="s1">(xi</span><span class="s6">-&gt;</span><span class="s1">index != -</span><span class="s5">1</span><span class="s1">)</span>
		<span class="s1">{</span>
			<span class="s2">double </span><span class="s1">val = xi</span><span class="s6">-&gt;</span><span class="s1">value;</span>
			<span class="s1">xTx[i] += val*val;</span>
			<span class="s1">w[xi</span><span class="s6">-&gt;</span><span class="s1">index-1] += y[i]*alpha[</span><span class="s5">2</span><span class="s1">*i]*val;</span>
			<span class="s1">xi++;</span>
		<span class="s1">}</span>
		<span class="s1">index[i] = i;</span>
	<span class="s1">}</span>

	<span class="s2">while </span><span class="s1">(iter &lt; max_iter)</span>
	<span class="s1">{</span>
		<span class="s2">for </span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">; i&lt;l; i++)</span>
		<span class="s1">{</span>
			<span class="s2">int </span><span class="s1">j = i+bounded_rand_int(l-i);</span>
			<span class="s1">swap(index[i], index[j]);</span>
		<span class="s1">}</span>
		<span class="s2">int </span><span class="s1">newton_iter = </span><span class="s5">0</span><span class="s1">;</span>
		<span class="s2">double </span><span class="s1">Gmax = </span><span class="s5">0</span><span class="s1">;</span>
		<span class="s2">for </span><span class="s1">(s=</span><span class="s5">0</span><span class="s1">; s&lt;l; s++)</span>
		<span class="s1">{</span>
			<span class="s1">i = index[s];</span>
			<span class="s1">schar yi = y[i];</span>
			<span class="s2">double </span><span class="s1">C = upper_bound[GETI(i)];</span>
			<span class="s2">double </span><span class="s1">ywTx = </span><span class="s5">0</span><span class="s1">, xisq = xTx[i];</span>
			<span class="s1">feature_node *xi = prob</span><span class="s6">-&gt;</span><span class="s1">x[i];</span>
			<span class="s2">while </span><span class="s1">(xi</span><span class="s6">-&gt;</span><span class="s1">index != -</span><span class="s5">1</span><span class="s1">)</span>
			<span class="s1">{</span>
				<span class="s1">ywTx += w[xi</span><span class="s6">-&gt;</span><span class="s1">index-1]*xi</span><span class="s6">-&gt;</span><span class="s1">value;</span>
				<span class="s1">xi++;</span>
			<span class="s1">}</span>
			<span class="s1">ywTx *= y[i];</span>
			<span class="s2">double </span><span class="s1">a = xisq, b = ywTx;</span>

			<span class="s0">// Decide to minimize g_1(z) or g_2(z)</span>
			<span class="s2">int </span><span class="s1">ind1 = </span><span class="s5">2</span><span class="s1">*i, ind2 = </span><span class="s5">2</span><span class="s1">*i+</span><span class="s5">1</span><span class="s1">, sign = </span><span class="s5">1</span><span class="s1">;</span>
			<span class="s2">if</span><span class="s1">(</span><span class="s5">0.5</span><span class="s1">*a*(alpha[ind2]-alpha[ind1])+b &lt; </span><span class="s5">0</span><span class="s1">)</span>
			<span class="s1">{</span>
				<span class="s1">ind1 = </span><span class="s5">2</span><span class="s1">*i+</span><span class="s5">1</span><span class="s1">;</span>
				<span class="s1">ind2 = </span><span class="s5">2</span><span class="s1">*i;</span>
				<span class="s1">sign = -</span><span class="s5">1</span><span class="s1">;</span>
			<span class="s1">}</span>

			<span class="s0">//  g_t(z) = z*log(z) + (C-z)*log(C-z) + 0.5a(z-alpha_old)^2 + sign*b(z-alpha_old)</span>
			<span class="s2">double </span><span class="s1">alpha_old = alpha[ind1];</span>
			<span class="s2">double </span><span class="s1">z = alpha_old;</span>
			<span class="s2">if</span><span class="s1">(C - z &lt; </span><span class="s5">0.5 </span><span class="s1">* C)</span>
				<span class="s1">z = </span><span class="s5">0.1</span><span class="s1">*z;</span>
			<span class="s2">double </span><span class="s1">gp = a*(z-alpha_old)+sign*b+log(z/(C-z));</span>
			<span class="s1">Gmax = max(Gmax, fabs(gp));</span>

			<span class="s0">// Newton method on the sub-problem</span>
			<span class="s2">const double </span><span class="s1">eta = </span><span class="s5">0.1</span><span class="s1">; </span><span class="s0">// xi in the paper</span>
			<span class="s2">int </span><span class="s1">inner_iter = </span><span class="s5">0</span><span class="s1">;</span>
			<span class="s2">while </span><span class="s1">(inner_iter &lt;= max_inner_iter)</span>
			<span class="s1">{</span>
				<span class="s2">if</span><span class="s1">(fabs(gp) &lt; innereps)</span>
					<span class="s2">break</span><span class="s1">;</span>
				<span class="s2">double </span><span class="s1">gpp = a + C/(C-z)/z;</span>
				<span class="s2">double </span><span class="s1">tmpz = z - gp/gpp;</span>
				<span class="s2">if</span><span class="s1">(tmpz &lt;= </span><span class="s5">0</span><span class="s1">)</span>
					<span class="s1">z *= eta;</span>
				<span class="s2">else </span><span class="s0">// tmpz in (0, C)</span>
					<span class="s1">z = tmpz;</span>
				<span class="s1">gp = a*(z-alpha_old)+sign*b+log(z/(C-z));</span>
				<span class="s1">newton_iter++;</span>
				<span class="s1">inner_iter++;</span>
			<span class="s1">}</span>

			<span class="s2">if</span><span class="s1">(inner_iter &gt; </span><span class="s5">0</span><span class="s1">) </span><span class="s0">// update w</span>
			<span class="s1">{</span>
				<span class="s1">alpha[ind1] = z;</span>
				<span class="s1">alpha[ind2] = C-z;</span>
				<span class="s1">xi = prob</span><span class="s6">-&gt;</span><span class="s1">x[i];</span>
				<span class="s2">while </span><span class="s1">(xi</span><span class="s6">-&gt;</span><span class="s1">index != -</span><span class="s5">1</span><span class="s1">)</span>
				<span class="s1">{</span>
					<span class="s1">w[xi</span><span class="s6">-&gt;</span><span class="s1">index-1] += sign*(z-alpha_old)*yi*xi</span><span class="s6">-&gt;</span><span class="s1">value;</span>
					<span class="s1">xi++;</span>
				<span class="s1">}</span>
			<span class="s1">}</span>
		<span class="s1">}</span>

		<span class="s1">iter++;</span>
		<span class="s2">if</span><span class="s1">(iter % </span><span class="s5">10 </span><span class="s1">== </span><span class="s5">0</span><span class="s1">)</span>
			<span class="s1">info(</span><span class="s3">&quot;.&quot;</span><span class="s1">);</span>

		<span class="s2">if</span><span class="s1">(Gmax &lt; eps)</span>
			<span class="s2">break</span><span class="s1">;</span>

		<span class="s2">if</span><span class="s1">(newton_iter &lt;= l/</span><span class="s5">10</span><span class="s1">)</span>
			<span class="s1">innereps = max(innereps_min, </span><span class="s5">0.1</span><span class="s1">*innereps);</span>

	<span class="s1">}</span>

	<span class="s1">info(</span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">optimization finished, #iter = %d</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">,iter);</span>
	<span class="s2">if </span><span class="s1">(iter &gt;= max_iter)</span>
		<span class="s1">info(</span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">WARNING: reaching max number of iterations</span><span class="s2">\n</span><span class="s3">Using -s 0 may be faster (also see FAQ)</span><span class="s2">\n\n</span><span class="s3">&quot;</span><span class="s1">);</span>

	<span class="s0">// calculate objective value</span>

	<span class="s2">double </span><span class="s1">v = </span><span class="s5">0</span><span class="s1">;</span>
	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">; i&lt;w_size; i++)</span>
		<span class="s1">v += w[i] * w[i];</span>
	<span class="s1">v *= </span><span class="s5">0.5</span><span class="s1">;</span>
	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">; i&lt;l; i++)</span>
		<span class="s1">v += alpha[</span><span class="s5">2</span><span class="s1">*i] * log(alpha[</span><span class="s5">2</span><span class="s1">*i]) + alpha[</span><span class="s5">2</span><span class="s1">*i+</span><span class="s5">1</span><span class="s1">] * log(alpha[</span><span class="s5">2</span><span class="s1">*i+</span><span class="s5">1</span><span class="s1">])</span>
			<span class="s1">- upper_bound[GETI(i)] * log(upper_bound[GETI(i)]);</span>
	<span class="s1">info(</span><span class="s3">&quot;Objective value = %lf</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">, v);</span>

	<span class="s2">delete </span><span class="s1">[] xTx;</span>
	<span class="s2">delete </span><span class="s1">[] alpha;</span>
	<span class="s2">delete </span><span class="s1">[] y;</span>
	<span class="s2">delete </span><span class="s1">[] index;</span>
	<span class="s2">delete </span><span class="s1">[] upper_bound;</span>
	<span class="s2">return </span><span class="s1">iter;</span>
<span class="s1">}</span>

<span class="s0">// A coordinate descent algorithm for</span>
<span class="s0">// L1-regularized L2-loss support vector classification</span>
<span class="s0">//</span>
<span class="s0">//  min_w \sum |wj| + C \sum max(0, 1-yi w^T xi)^2,</span>
<span class="s0">//</span>
<span class="s0">// Given:</span>
<span class="s0">// x, y, Cp, Cn</span>
<span class="s0">// eps is the stopping tolerance</span>
<span class="s0">//</span>
<span class="s0">// solution will be put in w</span>
<span class="s0">//</span>
<span class="s0">// See Yuan et al. (2010) and appendix of LIBLINEAR paper, Fan et al. (2008)</span>

<span class="s2">#undef </span><span class="s1">GETI</span>
<span class="s2">#define </span><span class="s1">GETI(i) (i)</span>
<span class="s0">// To support weights for instances, use GETI(i) (i)</span>

<span class="s2">static int </span><span class="s1">solve_l1r_l2_svc(</span>
	<span class="s1">problem *prob_col, </span><span class="s2">double </span><span class="s1">*w, </span><span class="s2">double </span><span class="s1">eps,</span>
	<span class="s2">double </span><span class="s1">Cp, </span><span class="s2">double </span><span class="s1">Cn, </span><span class="s2">int </span><span class="s1">max_iter)</span>
<span class="s1">{</span>
	<span class="s2">int </span><span class="s1">l = prob_col</span><span class="s6">-&gt;</span><span class="s1">l;</span>
	<span class="s2">int </span><span class="s1">w_size = prob_col</span><span class="s6">-&gt;</span><span class="s1">n;</span>
	<span class="s2">int </span><span class="s1">j, s, iter = </span><span class="s5">0</span><span class="s1">;</span>
	<span class="s2">int </span><span class="s1">active_size = w_size;</span>
	<span class="s2">int </span><span class="s1">max_num_linesearch = </span><span class="s5">20</span><span class="s1">;</span>

	<span class="s2">double </span><span class="s1">sigma = </span><span class="s5">0.01</span><span class="s1">;</span>
	<span class="s2">double </span><span class="s1">d, G_loss, G, H;</span>
	<span class="s2">double </span><span class="s1">Gmax_old = INF;</span>
	<span class="s2">double </span><span class="s1">Gmax_new, Gnorm1_new;</span>
	<span class="s2">double </span><span class="s1">Gnorm1_init = -</span><span class="s5">1.0</span><span class="s1">; </span><span class="s0">// Gnorm1_init is initialized at the first iteration</span>
	<span class="s2">double </span><span class="s1">d_old, d_diff;</span>
	<span class="s2">double </span><span class="s1">loss_old, loss_new;</span>
	<span class="s2">double </span><span class="s1">appxcond, cond;</span>

	<span class="s2">int </span><span class="s1">*index = </span><span class="s4">new </span><span class="s2">int</span><span class="s1">[w_size];</span>
	<span class="s1">schar *y = </span><span class="s4">new </span><span class="s1">schar[l];</span>
	<span class="s2">double </span><span class="s1">*b = </span><span class="s4">new </span><span class="s2">double</span><span class="s1">[l]; </span><span class="s0">// b = 1-ywTx</span>
	<span class="s2">double </span><span class="s1">*xj_sq = </span><span class="s4">new </span><span class="s2">double</span><span class="s1">[w_size];</span>
	<span class="s1">feature_node *x;</span>

	<span class="s2">double </span><span class="s1">*C = </span><span class="s4">new </span><span class="s2">double</span><span class="s1">[l];</span>

	<span class="s0">// Initial w can be set here.</span>
	<span class="s2">for</span><span class="s1">(j=</span><span class="s5">0</span><span class="s1">; j&lt;w_size; j++)</span>
		<span class="s1">w[j] = </span><span class="s5">0</span><span class="s1">;</span>

	<span class="s2">for</span><span class="s1">(j=</span><span class="s5">0</span><span class="s1">; j&lt;l; j++)</span>
	<span class="s1">{</span>
		<span class="s1">b[j] = </span><span class="s5">1</span><span class="s1">;</span>
		<span class="s2">if</span><span class="s1">(prob_col</span><span class="s6">-&gt;</span><span class="s1">y[j] &gt; </span><span class="s5">0</span><span class="s1">)</span>
		<span class="s1">{</span>
			<span class="s1">y[j] = </span><span class="s5">1</span><span class="s1">;</span>
			<span class="s1">C[j] = prob_col</span><span class="s6">-&gt;</span><span class="s1">W[j] * Cp;</span>
		<span class="s1">}</span>
		<span class="s2">else</span>
		<span class="s1">{</span>
			<span class="s1">y[j] = -</span><span class="s5">1</span><span class="s1">;</span>
			<span class="s1">C[j] = prob_col</span><span class="s6">-&gt;</span><span class="s1">W[j] * Cn;</span>
		<span class="s1">}</span>
	<span class="s1">}</span>
	<span class="s2">for</span><span class="s1">(j=</span><span class="s5">0</span><span class="s1">; j&lt;w_size; j++)</span>
	<span class="s1">{</span>
		<span class="s1">index[j] = j;</span>
		<span class="s1">xj_sq[j] = </span><span class="s5">0</span><span class="s1">;</span>
		<span class="s1">x = prob_col</span><span class="s6">-&gt;</span><span class="s1">x[j];</span>
		<span class="s2">while</span><span class="s1">(x</span><span class="s6">-&gt;</span><span class="s1">index != -</span><span class="s5">1</span><span class="s1">)</span>
		<span class="s1">{</span>
			<span class="s2">int </span><span class="s1">ind = x</span><span class="s6">-&gt;</span><span class="s1">index-1;</span>
			<span class="s1">x</span><span class="s6">-&gt;</span><span class="s1">value *= y[ind]; </span><span class="s0">// x-&gt;value stores yi*xij</span>
			<span class="s2">double </span><span class="s1">val = x</span><span class="s6">-&gt;</span><span class="s1">value;</span>
			<span class="s1">b[ind] -= w[j]*val;</span>
			<span class="s1">xj_sq[j] += C[GETI(ind)]*val*val;</span>
			<span class="s1">x++;</span>
		<span class="s1">}</span>
	<span class="s1">}</span>

	<span class="s2">while</span><span class="s1">(iter &lt; max_iter)</span>
	<span class="s1">{</span>
		<span class="s1">Gmax_new = </span><span class="s5">0</span><span class="s1">;</span>
		<span class="s1">Gnorm1_new = </span><span class="s5">0</span><span class="s1">;</span>

		<span class="s2">for</span><span class="s1">(j=</span><span class="s5">0</span><span class="s1">; j&lt;active_size; j++)</span>
		<span class="s1">{</span>
			<span class="s2">int </span><span class="s1">i = j+bounded_rand_int(active_size-j);</span>
			<span class="s1">swap(index[i], index[j]);</span>
		<span class="s1">}</span>

		<span class="s2">for</span><span class="s1">(s=</span><span class="s5">0</span><span class="s1">; s&lt;active_size; s++)</span>
		<span class="s1">{</span>
			<span class="s1">j = index[s];</span>
			<span class="s1">G_loss = </span><span class="s5">0</span><span class="s1">;</span>
			<span class="s1">H = </span><span class="s5">0</span><span class="s1">;</span>

			<span class="s1">x = prob_col</span><span class="s6">-&gt;</span><span class="s1">x[j];</span>
			<span class="s2">while</span><span class="s1">(x</span><span class="s6">-&gt;</span><span class="s1">index != -</span><span class="s5">1</span><span class="s1">)</span>
			<span class="s1">{</span>
				<span class="s2">int </span><span class="s1">ind = x</span><span class="s6">-&gt;</span><span class="s1">index-1;</span>
				<span class="s2">if</span><span class="s1">(b[ind] &gt; </span><span class="s5">0</span><span class="s1">)</span>
				<span class="s1">{</span>
					<span class="s2">double </span><span class="s1">val = x</span><span class="s6">-&gt;</span><span class="s1">value;</span>
					<span class="s2">double </span><span class="s1">tmp = C[GETI(ind)]*val;</span>
					<span class="s1">G_loss -= tmp*b[ind];</span>
					<span class="s1">H += tmp*val;</span>
				<span class="s1">}</span>
				<span class="s1">x++;</span>
			<span class="s1">}</span>
			<span class="s1">G_loss *= </span><span class="s5">2</span><span class="s1">;</span>

			<span class="s1">G = G_loss;</span>
			<span class="s1">H *= </span><span class="s5">2</span><span class="s1">;</span>
			<span class="s1">H = max(H, </span><span class="s5">1</span><span class="s1">e-12);</span>

			<span class="s2">double </span><span class="s1">Gp = G+</span><span class="s5">1</span><span class="s1">;</span>
			<span class="s2">double </span><span class="s1">Gn = G-1;</span>
			<span class="s2">double </span><span class="s1">violation = </span><span class="s5">0</span><span class="s1">;</span>
			<span class="s2">if</span><span class="s1">(w[j] == </span><span class="s5">0</span><span class="s1">)</span>
			<span class="s1">{</span>
				<span class="s2">if</span><span class="s1">(Gp &lt; </span><span class="s5">0</span><span class="s1">)</span>
					<span class="s1">violation = -Gp;</span>
				<span class="s2">else if</span><span class="s1">(Gn &gt; </span><span class="s5">0</span><span class="s1">)</span>
					<span class="s1">violation = Gn;</span>
				<span class="s2">else if</span><span class="s1">(Gp&gt;Gmax_old/l &amp;&amp; Gn&lt;-Gmax_old/l)</span>
				<span class="s1">{</span>
					<span class="s1">active_size--;</span>
					<span class="s1">swap(index[s], index[active_size]);</span>
					<span class="s1">s--;</span>
					<span class="s2">continue</span><span class="s1">;</span>
				<span class="s1">}</span>
			<span class="s1">}</span>
			<span class="s2">else if</span><span class="s1">(w[j] &gt; </span><span class="s5">0</span><span class="s1">)</span>
				<span class="s1">violation = fabs(Gp);</span>
			<span class="s2">else</span>
				<span class="s1">violation = fabs(Gn);</span>

			<span class="s1">Gmax_new = max(Gmax_new, violation);</span>
			<span class="s1">Gnorm1_new += violation;</span>

			<span class="s0">// obtain Newton direction d</span>
			<span class="s2">if</span><span class="s1">(Gp &lt; H*w[j])</span>
				<span class="s1">d = -Gp/H;</span>
			<span class="s2">else if</span><span class="s1">(Gn &gt; H*w[j])</span>
				<span class="s1">d = -Gn/H;</span>
			<span class="s2">else</span>
				<span class="s1">d = -w[j];</span>

			<span class="s2">if</span><span class="s1">(fabs(d) &lt; </span><span class="s5">1</span><span class="s1">.</span><span class="s5">0</span><span class="s1">e-12)</span>
				<span class="s2">continue</span><span class="s1">;</span>

			<span class="s2">double </span><span class="s1">delta = fabs(w[j]+d)-fabs(w[j]) + G*d;</span>
			<span class="s1">d_old = </span><span class="s5">0</span><span class="s1">;</span>
			<span class="s2">int </span><span class="s1">num_linesearch;</span>
			<span class="s2">for</span><span class="s1">(num_linesearch=</span><span class="s5">0</span><span class="s1">; num_linesearch &lt; max_num_linesearch; num_linesearch++)</span>
			<span class="s1">{</span>
				<span class="s1">d_diff = d_old - d;</span>
				<span class="s1">cond = fabs(w[j]+d)-fabs(w[j]) - sigma*delta;</span>

				<span class="s1">appxcond = xj_sq[j]*d*d + G_loss*d + cond;</span>
				<span class="s2">if</span><span class="s1">(appxcond &lt;= </span><span class="s5">0</span><span class="s1">)</span>
				<span class="s1">{</span>
					<span class="s1">x = prob_col</span><span class="s6">-&gt;</span><span class="s1">x[j];</span>
					<span class="s2">while</span><span class="s1">(x</span><span class="s6">-&gt;</span><span class="s1">index != -</span><span class="s5">1</span><span class="s1">)</span>
					<span class="s1">{</span>
						<span class="s1">b[x</span><span class="s6">-&gt;</span><span class="s1">index-1] += d_diff*x</span><span class="s6">-&gt;</span><span class="s1">value;</span>
						<span class="s1">x++;</span>
					<span class="s1">}</span>
					<span class="s2">break</span><span class="s1">;</span>
				<span class="s1">}</span>

				<span class="s2">if</span><span class="s1">(num_linesearch == </span><span class="s5">0</span><span class="s1">)</span>
				<span class="s1">{</span>
					<span class="s1">loss_old = </span><span class="s5">0</span><span class="s1">;</span>
					<span class="s1">loss_new = </span><span class="s5">0</span><span class="s1">;</span>
					<span class="s1">x = prob_col</span><span class="s6">-&gt;</span><span class="s1">x[j];</span>
					<span class="s2">while</span><span class="s1">(x</span><span class="s6">-&gt;</span><span class="s1">index != -</span><span class="s5">1</span><span class="s1">)</span>
					<span class="s1">{</span>
						<span class="s2">int </span><span class="s1">ind = x</span><span class="s6">-&gt;</span><span class="s1">index-1;</span>
						<span class="s2">if</span><span class="s1">(b[ind] &gt; </span><span class="s5">0</span><span class="s1">)</span>
							<span class="s1">loss_old += C[GETI(ind)]*b[ind]*b[ind];</span>
						<span class="s2">double </span><span class="s1">b_new = b[ind] + d_diff*x</span><span class="s6">-&gt;</span><span class="s1">value;</span>
						<span class="s1">b[ind] = b_new;</span>
						<span class="s2">if</span><span class="s1">(b_new &gt; </span><span class="s5">0</span><span class="s1">)</span>
							<span class="s1">loss_new += C[GETI(ind)]*b_new*b_new;</span>
						<span class="s1">x++;</span>
					<span class="s1">}</span>
				<span class="s1">}</span>
				<span class="s2">else</span>
				<span class="s1">{</span>
					<span class="s1">loss_new = </span><span class="s5">0</span><span class="s1">;</span>
					<span class="s1">x = prob_col</span><span class="s6">-&gt;</span><span class="s1">x[j];</span>
					<span class="s2">while</span><span class="s1">(x</span><span class="s6">-&gt;</span><span class="s1">index != -</span><span class="s5">1</span><span class="s1">)</span>
					<span class="s1">{</span>
						<span class="s2">int </span><span class="s1">ind = x</span><span class="s6">-&gt;</span><span class="s1">index-1;</span>
						<span class="s2">double </span><span class="s1">b_new = b[ind] + d_diff*x</span><span class="s6">-&gt;</span><span class="s1">value;</span>
						<span class="s1">b[ind] = b_new;</span>
						<span class="s2">if</span><span class="s1">(b_new &gt; </span><span class="s5">0</span><span class="s1">)</span>
							<span class="s1">loss_new += C[GETI(ind)]*b_new*b_new;</span>
						<span class="s1">x++;</span>
					<span class="s1">}</span>
				<span class="s1">}</span>

				<span class="s1">cond = cond + loss_new - loss_old;</span>
				<span class="s2">if</span><span class="s1">(cond &lt;= </span><span class="s5">0</span><span class="s1">)</span>
					<span class="s2">break</span><span class="s1">;</span>
				<span class="s2">else</span>
				<span class="s1">{</span>
					<span class="s1">d_old = d;</span>
					<span class="s1">d *= </span><span class="s5">0.5</span><span class="s1">;</span>
					<span class="s1">delta *= </span><span class="s5">0.5</span><span class="s1">;</span>
				<span class="s1">}</span>
			<span class="s1">}</span>

			<span class="s1">w[j] += d;</span>

			<span class="s0">// recompute b[] if line search takes too many steps</span>
			<span class="s2">if</span><span class="s1">(num_linesearch &gt;= max_num_linesearch)</span>
			<span class="s1">{</span>
				<span class="s1">info(</span><span class="s3">&quot;#&quot;</span><span class="s1">);</span>
				<span class="s2">for</span><span class="s1">(</span><span class="s2">int </span><span class="s1">i=</span><span class="s5">0</span><span class="s1">; i&lt;l; i++)</span>
					<span class="s1">b[i] = </span><span class="s5">1</span><span class="s1">;</span>

				<span class="s2">for</span><span class="s1">(</span><span class="s2">int </span><span class="s1">i=</span><span class="s5">0</span><span class="s1">; i&lt;w_size; i++)</span>
				<span class="s1">{</span>
					<span class="s2">if</span><span class="s1">(w[i]==</span><span class="s5">0</span><span class="s1">) </span><span class="s2">continue</span><span class="s1">;</span>
					<span class="s1">x = prob_col</span><span class="s6">-&gt;</span><span class="s1">x[i];</span>
					<span class="s2">while</span><span class="s1">(x</span><span class="s6">-&gt;</span><span class="s1">index != -</span><span class="s5">1</span><span class="s1">)</span>
					<span class="s1">{</span>
						<span class="s1">b[x</span><span class="s6">-&gt;</span><span class="s1">index-1] -= w[i]*x</span><span class="s6">-&gt;</span><span class="s1">value;</span>
						<span class="s1">x++;</span>
					<span class="s1">}</span>
				<span class="s1">}</span>
			<span class="s1">}</span>
		<span class="s1">}</span>

		<span class="s2">if</span><span class="s1">(iter == </span><span class="s5">0</span><span class="s1">)</span>
			<span class="s1">Gnorm1_init = Gnorm1_new;</span>
		<span class="s1">iter++;</span>
		<span class="s2">if</span><span class="s1">(iter % </span><span class="s5">10 </span><span class="s1">== </span><span class="s5">0</span><span class="s1">)</span>
			<span class="s1">info(</span><span class="s3">&quot;.&quot;</span><span class="s1">);</span>

		<span class="s2">if</span><span class="s1">(Gnorm1_new &lt;= eps*Gnorm1_init)</span>
		<span class="s1">{</span>
			<span class="s2">if</span><span class="s1">(active_size == w_size)</span>
				<span class="s2">break</span><span class="s1">;</span>
			<span class="s2">else</span>
			<span class="s1">{</span>
				<span class="s1">active_size = w_size;</span>
				<span class="s1">info(</span><span class="s3">&quot;*&quot;</span><span class="s1">);</span>
				<span class="s1">Gmax_old = INF;</span>
				<span class="s2">continue</span><span class="s1">;</span>
			<span class="s1">}</span>
		<span class="s1">}</span>

		<span class="s1">Gmax_old = Gmax_new;</span>
	<span class="s1">}</span>

	<span class="s1">info(</span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">optimization finished, #iter = %d</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">, iter);</span>
	<span class="s2">if</span><span class="s1">(iter &gt;= max_iter)</span>
		<span class="s1">info(</span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">WARNING: reaching max number of iterations</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">);</span>

	<span class="s0">// calculate objective value</span>

	<span class="s2">double </span><span class="s1">v = </span><span class="s5">0</span><span class="s1">;</span>
	<span class="s2">int </span><span class="s1">nnz = </span><span class="s5">0</span><span class="s1">;</span>
	<span class="s2">for</span><span class="s1">(j=</span><span class="s5">0</span><span class="s1">; j&lt;w_size; j++)</span>
	<span class="s1">{</span>
		<span class="s1">x = prob_col</span><span class="s6">-&gt;</span><span class="s1">x[j];</span>
		<span class="s2">while</span><span class="s1">(x</span><span class="s6">-&gt;</span><span class="s1">index != -</span><span class="s5">1</span><span class="s1">)</span>
		<span class="s1">{</span>
			<span class="s1">x</span><span class="s6">-&gt;</span><span class="s1">value *= prob_col</span><span class="s6">-&gt;</span><span class="s1">y[x</span><span class="s6">-&gt;</span><span class="s1">index-1]; </span><span class="s0">// restore x-&gt;value</span>
			<span class="s1">x++;</span>
		<span class="s1">}</span>
		<span class="s2">if</span><span class="s1">(w[j] != </span><span class="s5">0</span><span class="s1">)</span>
		<span class="s1">{</span>
			<span class="s1">v += fabs(w[j]);</span>
			<span class="s1">nnz++;</span>
		<span class="s1">}</span>
	<span class="s1">}</span>
	<span class="s2">for</span><span class="s1">(j=</span><span class="s5">0</span><span class="s1">; j&lt;l; j++)</span>
		<span class="s2">if</span><span class="s1">(b[j] &gt; </span><span class="s5">0</span><span class="s1">)</span>
			<span class="s1">v += C[GETI(j)]*b[j]*b[j];</span>

	<span class="s1">info(</span><span class="s3">&quot;Objective value = %lf</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">, v);</span>
	<span class="s1">info(</span><span class="s3">&quot;#nonzeros/#features = %d/%d</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">, nnz, w_size);</span>

	<span class="s2">delete </span><span class="s1">[] index;</span>
	<span class="s2">delete </span><span class="s1">[] y;</span>
	<span class="s2">delete </span><span class="s1">[] b;</span>
	<span class="s2">delete </span><span class="s1">[] xj_sq;</span>
	<span class="s2">delete </span><span class="s1">[] C;</span>
	<span class="s2">return </span><span class="s1">iter;</span>
<span class="s1">}</span>

<span class="s0">// A coordinate descent algorithm for</span>
<span class="s0">// L1-regularized logistic regression problems</span>
<span class="s0">//</span>
<span class="s0">//  min_w \sum |wj| + C \sum log(1+exp(-yi w^T xi)),</span>
<span class="s0">//</span>
<span class="s0">// Given:</span>
<span class="s0">// x, y, Cp, Cn</span>
<span class="s0">// eps is the stopping tolerance</span>
<span class="s0">//</span>
<span class="s0">// solution will be put in w</span>
<span class="s0">//</span>
<span class="s0">// See Yuan et al. (2011) and appendix of LIBLINEAR paper, Fan et al. (2008)</span>

<span class="s2">#undef </span><span class="s1">GETI</span>
<span class="s2">#define </span><span class="s1">GETI(i) (i)</span>
<span class="s0">// To support weights for instances, use GETI(i) (i)</span>

<span class="s2">static int </span><span class="s1">solve_l1r_lr(</span>
	<span class="s2">const </span><span class="s1">problem *prob_col, </span><span class="s2">double </span><span class="s1">*w, </span><span class="s2">double </span><span class="s1">eps,</span>
	<span class="s2">double </span><span class="s1">Cp, </span><span class="s2">double </span><span class="s1">Cn, </span><span class="s2">int </span><span class="s1">max_newton_iter)</span>
<span class="s1">{</span>
	<span class="s2">int </span><span class="s1">l = prob_col</span><span class="s6">-&gt;</span><span class="s1">l;</span>
	<span class="s2">int </span><span class="s1">w_size = prob_col</span><span class="s6">-&gt;</span><span class="s1">n;</span>
	<span class="s2">int </span><span class="s1">j, s, newton_iter=</span><span class="s5">0</span><span class="s1">, iter=</span><span class="s5">0</span><span class="s1">;</span>
	<span class="s2">int </span><span class="s1">max_iter = </span><span class="s5">1000</span><span class="s1">;</span>
	<span class="s2">int </span><span class="s1">max_num_linesearch = </span><span class="s5">20</span><span class="s1">;</span>
	<span class="s2">int </span><span class="s1">active_size;</span>
	<span class="s2">int </span><span class="s1">QP_active_size;</span>
	<span class="s2">int </span><span class="s1">QP_no_change = </span><span class="s5">0</span><span class="s1">;</span>

	<span class="s2">double </span><span class="s1">nu = </span><span class="s5">1</span><span class="s1">e-12;</span>
	<span class="s2">double </span><span class="s1">inner_eps = </span><span class="s5">1</span><span class="s1">;</span>
	<span class="s2">double </span><span class="s1">sigma = </span><span class="s5">0.01</span><span class="s1">;</span>
	<span class="s2">double </span><span class="s1">w_norm, w_norm_new;</span>
	<span class="s2">double </span><span class="s1">z, G, H;</span>
	<span class="s2">double </span><span class="s1">Gnorm1_init = -</span><span class="s5">1.0</span><span class="s1">; </span><span class="s0">// Gnorm1_init is initialized at the first iteration</span>
	<span class="s2">double </span><span class="s1">Gmax_old = INF;</span>
	<span class="s2">double </span><span class="s1">Gmax_new, Gnorm1_new;</span>
	<span class="s2">double </span><span class="s1">QP_Gmax_old = INF;</span>
	<span class="s2">double </span><span class="s1">QP_Gmax_new, QP_Gnorm1_new;</span>
	<span class="s2">double </span><span class="s1">delta, negsum_xTd, cond;</span>

	<span class="s2">int </span><span class="s1">*index = </span><span class="s4">new </span><span class="s2">int</span><span class="s1">[w_size];</span>
	<span class="s1">schar *y = </span><span class="s4">new </span><span class="s1">schar[l];</span>
	<span class="s2">double </span><span class="s1">*Hdiag = </span><span class="s4">new </span><span class="s2">double</span><span class="s1">[w_size];</span>
	<span class="s2">double </span><span class="s1">*Grad = </span><span class="s4">new </span><span class="s2">double</span><span class="s1">[w_size];</span>
	<span class="s2">double </span><span class="s1">*wpd = </span><span class="s4">new </span><span class="s2">double</span><span class="s1">[w_size];</span>
	<span class="s2">double </span><span class="s1">*xjneg_sum = </span><span class="s4">new </span><span class="s2">double</span><span class="s1">[w_size];</span>
	<span class="s2">double </span><span class="s1">*xTd = </span><span class="s4">new </span><span class="s2">double</span><span class="s1">[l];</span>
	<span class="s2">double </span><span class="s1">*exp_wTx = </span><span class="s4">new </span><span class="s2">double</span><span class="s1">[l];</span>
	<span class="s2">double </span><span class="s1">*exp_wTx_new = </span><span class="s4">new </span><span class="s2">double</span><span class="s1">[l];</span>
	<span class="s2">double </span><span class="s1">*tau = </span><span class="s4">new </span><span class="s2">double</span><span class="s1">[l];</span>
	<span class="s2">double </span><span class="s1">*D = </span><span class="s4">new </span><span class="s2">double</span><span class="s1">[l];</span>
	<span class="s1">feature_node *x;</span>

	<span class="s2">double </span><span class="s1">*C = </span><span class="s4">new </span><span class="s2">double</span><span class="s1">[l];</span>

	<span class="s0">// Initial w can be set here.</span>
	<span class="s2">for</span><span class="s1">(j=</span><span class="s5">0</span><span class="s1">; j&lt;w_size; j++)</span>
		<span class="s1">w[j] = </span><span class="s5">0</span><span class="s1">;</span>

	<span class="s2">for</span><span class="s1">(j=</span><span class="s5">0</span><span class="s1">; j&lt;l; j++)</span>
	<span class="s1">{</span>
		<span class="s2">if</span><span class="s1">(prob_col</span><span class="s6">-&gt;</span><span class="s1">y[j] &gt; </span><span class="s5">0</span><span class="s1">)</span>
		<span class="s1">{</span>
			<span class="s1">y[j] = </span><span class="s5">1</span><span class="s1">;</span>
			<span class="s1">C[j] = prob_col</span><span class="s6">-&gt;</span><span class="s1">W[j] * Cp;</span>
		<span class="s1">}</span>
		<span class="s2">else</span>
		<span class="s1">{</span>
			<span class="s1">y[j] = -</span><span class="s5">1</span><span class="s1">;</span>
			<span class="s1">C[j] = prob_col</span><span class="s6">-&gt;</span><span class="s1">W[j] * Cn;</span>
		<span class="s1">}</span>

		<span class="s1">exp_wTx[j] = </span><span class="s5">0</span><span class="s1">;</span>
	<span class="s1">}</span>

	<span class="s1">w_norm = </span><span class="s5">0</span><span class="s1">;</span>
	<span class="s2">for</span><span class="s1">(j=</span><span class="s5">0</span><span class="s1">; j&lt;w_size; j++)</span>
	<span class="s1">{</span>
		<span class="s1">w_norm += fabs(w[j]);</span>
		<span class="s1">wpd[j] = w[j];</span>
		<span class="s1">index[j] = j;</span>
		<span class="s1">xjneg_sum[j] = </span><span class="s5">0</span><span class="s1">;</span>
		<span class="s1">x = prob_col</span><span class="s6">-&gt;</span><span class="s1">x[j];</span>
		<span class="s2">while</span><span class="s1">(x</span><span class="s6">-&gt;</span><span class="s1">index != -</span><span class="s5">1</span><span class="s1">)</span>
		<span class="s1">{</span>
			<span class="s2">int </span><span class="s1">ind = x</span><span class="s6">-&gt;</span><span class="s1">index-1;</span>
			<span class="s2">double </span><span class="s1">val = x</span><span class="s6">-&gt;</span><span class="s1">value;</span>
			<span class="s1">exp_wTx[ind] += w[j]*val;</span>
			<span class="s2">if</span><span class="s1">(y[ind] == -</span><span class="s5">1</span><span class="s1">)</span>
				<span class="s1">xjneg_sum[j] += C[GETI(ind)]*val;</span>
			<span class="s1">x++;</span>
		<span class="s1">}</span>
	<span class="s1">}</span>
	<span class="s2">for</span><span class="s1">(j=</span><span class="s5">0</span><span class="s1">; j&lt;l; j++)</span>
	<span class="s1">{</span>
		<span class="s1">exp_wTx[j] = exp(exp_wTx[j]);</span>
		<span class="s2">double </span><span class="s1">tau_tmp = </span><span class="s5">1</span><span class="s1">/(</span><span class="s5">1</span><span class="s1">+exp_wTx[j]);</span>
		<span class="s1">tau[j] = C[GETI(j)]*tau_tmp;</span>
		<span class="s1">D[j] = C[GETI(j)]*exp_wTx[j]*tau_tmp*tau_tmp;</span>
	<span class="s1">}</span>

	<span class="s2">while</span><span class="s1">(newton_iter &lt; max_newton_iter)</span>
	<span class="s1">{</span>
		<span class="s1">Gmax_new = </span><span class="s5">0</span><span class="s1">;</span>
		<span class="s1">Gnorm1_new = </span><span class="s5">0</span><span class="s1">;</span>
		<span class="s1">active_size = w_size;</span>

		<span class="s2">for</span><span class="s1">(s=</span><span class="s5">0</span><span class="s1">; s&lt;active_size; s++)</span>
		<span class="s1">{</span>
			<span class="s1">j = index[s];</span>
			<span class="s1">Hdiag[j] = nu;</span>
			<span class="s1">Grad[j] = </span><span class="s5">0</span><span class="s1">;</span>

			<span class="s2">double </span><span class="s1">tmp = </span><span class="s5">0</span><span class="s1">;</span>
			<span class="s1">x = prob_col</span><span class="s6">-&gt;</span><span class="s1">x[j];</span>
			<span class="s2">while</span><span class="s1">(x</span><span class="s6">-&gt;</span><span class="s1">index != -</span><span class="s5">1</span><span class="s1">)</span>
			<span class="s1">{</span>
				<span class="s2">int </span><span class="s1">ind = x</span><span class="s6">-&gt;</span><span class="s1">index-1;</span>
				<span class="s1">Hdiag[j] += x</span><span class="s6">-&gt;</span><span class="s1">value*x</span><span class="s6">-&gt;</span><span class="s1">value*D[ind];</span>
				<span class="s1">tmp += x</span><span class="s6">-&gt;</span><span class="s1">value*tau[ind];</span>
				<span class="s1">x++;</span>
			<span class="s1">}</span>
			<span class="s1">Grad[j] = -tmp + xjneg_sum[j];</span>

			<span class="s2">double </span><span class="s1">Gp = Grad[j]+</span><span class="s5">1</span><span class="s1">;</span>
			<span class="s2">double </span><span class="s1">Gn = Grad[j]-</span><span class="s5">1</span><span class="s1">;</span>
			<span class="s2">double </span><span class="s1">violation = </span><span class="s5">0</span><span class="s1">;</span>
			<span class="s2">if</span><span class="s1">(w[j] == </span><span class="s5">0</span><span class="s1">)</span>
			<span class="s1">{</span>
				<span class="s2">if</span><span class="s1">(Gp &lt; </span><span class="s5">0</span><span class="s1">)</span>
					<span class="s1">violation = -Gp;</span>
				<span class="s2">else if</span><span class="s1">(Gn &gt; </span><span class="s5">0</span><span class="s1">)</span>
					<span class="s1">violation = Gn;</span>
				<span class="s0">//outer-level shrinking</span>
				<span class="s2">else if</span><span class="s1">(Gp&gt;Gmax_old/l &amp;&amp; Gn&lt;-Gmax_old/l)</span>
				<span class="s1">{</span>
					<span class="s1">active_size--;</span>
					<span class="s1">swap(index[s], index[active_size]);</span>
					<span class="s1">s--;</span>
					<span class="s2">continue</span><span class="s1">;</span>
				<span class="s1">}</span>
			<span class="s1">}</span>
			<span class="s2">else if</span><span class="s1">(w[j] &gt; </span><span class="s5">0</span><span class="s1">)</span>
				<span class="s1">violation = fabs(Gp);</span>
			<span class="s2">else</span>
				<span class="s1">violation = fabs(Gn);</span>

			<span class="s1">Gmax_new = max(Gmax_new, violation);</span>
			<span class="s1">Gnorm1_new += violation;</span>
		<span class="s1">}</span>

		<span class="s2">if</span><span class="s1">(newton_iter == </span><span class="s5">0</span><span class="s1">)</span>
			<span class="s1">Gnorm1_init = Gnorm1_new;</span>

		<span class="s0">// Break outer-loop if the accumulated violation is small.</span>
		<span class="s0">// Also break if no update in QP inner-loop ten times in a row.</span>
		<span class="s2">if</span><span class="s1">(Gnorm1_new &lt;= eps*Gnorm1_init || QP_no_change &gt;= </span><span class="s5">10</span><span class="s1">)</span>
			<span class="s2">break</span><span class="s1">;</span>

		<span class="s1">QP_no_change++;</span>

		<span class="s1">iter = </span><span class="s5">0</span><span class="s1">;</span>
		<span class="s1">QP_Gmax_old = INF;</span>
		<span class="s1">QP_active_size = active_size;</span>

		<span class="s2">for</span><span class="s1">(</span><span class="s2">int </span><span class="s1">i=</span><span class="s5">0</span><span class="s1">; i&lt;l; i++)</span>
			<span class="s1">xTd[i] = </span><span class="s5">0</span><span class="s1">;</span>

		<span class="s0">// optimize QP over wpd</span>
		<span class="s2">while</span><span class="s1">(iter &lt; max_iter)</span>
		<span class="s1">{</span>
			<span class="s1">QP_Gmax_new = </span><span class="s5">0</span><span class="s1">;</span>
			<span class="s1">QP_Gnorm1_new = </span><span class="s5">0</span><span class="s1">;</span>

			<span class="s2">for</span><span class="s1">(j=</span><span class="s5">0</span><span class="s1">; j&lt;QP_active_size; j++)</span>
			<span class="s1">{</span>
				<span class="s2">int </span><span class="s1">i = j+bounded_rand_int(QP_active_size-j);</span>
				<span class="s1">swap(index[i], index[j]);</span>
			<span class="s1">}</span>

			<span class="s2">for</span><span class="s1">(s=</span><span class="s5">0</span><span class="s1">; s&lt;QP_active_size; s++)</span>
			<span class="s1">{</span>
				<span class="s1">j = index[s];</span>
				<span class="s1">H = Hdiag[j];</span>

				<span class="s1">x = prob_col</span><span class="s6">-&gt;</span><span class="s1">x[j];</span>
				<span class="s1">G = Grad[j] + (wpd[j]-w[j])*nu;</span>
				<span class="s2">while</span><span class="s1">(x</span><span class="s6">-&gt;</span><span class="s1">index != -</span><span class="s5">1</span><span class="s1">)</span>
				<span class="s1">{</span>
					<span class="s2">int </span><span class="s1">ind = x</span><span class="s6">-&gt;</span><span class="s1">index-1;</span>
					<span class="s1">G += x</span><span class="s6">-&gt;</span><span class="s1">value*D[ind]*xTd[ind];</span>
					<span class="s1">x++;</span>
				<span class="s1">}</span>

				<span class="s2">double </span><span class="s1">Gp = G+</span><span class="s5">1</span><span class="s1">;</span>
				<span class="s2">double </span><span class="s1">Gn = G-1;</span>
				<span class="s2">double </span><span class="s1">violation = </span><span class="s5">0</span><span class="s1">;</span>
				<span class="s2">if</span><span class="s1">(wpd[j] == </span><span class="s5">0</span><span class="s1">)</span>
				<span class="s1">{</span>
					<span class="s2">if</span><span class="s1">(Gp &lt; </span><span class="s5">0</span><span class="s1">)</span>
						<span class="s1">violation = -Gp;</span>
					<span class="s2">else if</span><span class="s1">(Gn &gt; </span><span class="s5">0</span><span class="s1">)</span>
						<span class="s1">violation = Gn;</span>
					<span class="s0">//inner-level shrinking</span>
					<span class="s2">else if</span><span class="s1">(Gp&gt;QP_Gmax_old/l &amp;&amp; Gn&lt;-QP_Gmax_old/l)</span>
					<span class="s1">{</span>
						<span class="s1">QP_active_size--;</span>
						<span class="s1">swap(index[s], index[QP_active_size]);</span>
						<span class="s1">s--;</span>
						<span class="s2">continue</span><span class="s1">;</span>
					<span class="s1">}</span>
				<span class="s1">}</span>
				<span class="s2">else if</span><span class="s1">(wpd[j] &gt; </span><span class="s5">0</span><span class="s1">)</span>
					<span class="s1">violation = fabs(Gp);</span>
				<span class="s2">else</span>
					<span class="s1">violation = fabs(Gn);</span>

				<span class="s0">// obtain solution of one-variable problem</span>
				<span class="s2">if</span><span class="s1">(Gp &lt; H*wpd[j])</span>
					<span class="s1">z = -Gp/H;</span>
				<span class="s2">else if</span><span class="s1">(Gn &gt; H*wpd[j])</span>
					<span class="s1">z = -Gn/H;</span>
				<span class="s2">else</span>
					<span class="s1">z = -wpd[j];</span>

				<span class="s2">if</span><span class="s1">(fabs(z) &lt; </span><span class="s5">1</span><span class="s1">.</span><span class="s5">0</span><span class="s1">e-12)</span>
					<span class="s2">continue</span><span class="s1">;</span>
				<span class="s1">z = min(max(z,-</span><span class="s5">10.0</span><span class="s1">),</span><span class="s5">10.0</span><span class="s1">);</span>

				<span class="s1">QP_no_change = </span><span class="s5">0</span><span class="s1">;</span>
				<span class="s1">QP_Gmax_new = max(QP_Gmax_new, violation);</span>
				<span class="s1">QP_Gnorm1_new += violation;</span>

				<span class="s1">wpd[j] += z;</span>

				<span class="s1">x = prob_col</span><span class="s6">-&gt;</span><span class="s1">x[j];</span>
				<span class="s2">while</span><span class="s1">(x</span><span class="s6">-&gt;</span><span class="s1">index != -</span><span class="s5">1</span><span class="s1">)</span>
				<span class="s1">{</span>
					<span class="s2">int </span><span class="s1">ind = x</span><span class="s6">-&gt;</span><span class="s1">index-1;</span>
					<span class="s1">xTd[ind] += x</span><span class="s6">-&gt;</span><span class="s1">value*z;</span>
					<span class="s1">x++;</span>
				<span class="s1">}</span>
			<span class="s1">}</span>

			<span class="s1">iter++;</span>

			<span class="s2">if</span><span class="s1">(QP_Gnorm1_new &lt;= inner_eps*Gnorm1_init)</span>
			<span class="s1">{</span>
				<span class="s0">//inner stopping</span>
				<span class="s2">if</span><span class="s1">(QP_active_size == active_size)</span>
					<span class="s2">break</span><span class="s1">;</span>
				<span class="s0">//active set reactivation</span>
				<span class="s2">else</span>
				<span class="s1">{</span>
					<span class="s1">QP_active_size = active_size;</span>
					<span class="s1">QP_Gmax_old = INF;</span>
					<span class="s2">continue</span><span class="s1">;</span>
				<span class="s1">}</span>
			<span class="s1">}</span>

			<span class="s1">QP_Gmax_old = QP_Gmax_new;</span>
		<span class="s1">}</span>

		<span class="s2">if</span><span class="s1">(iter &gt;= max_iter)</span>
			<span class="s1">info(</span><span class="s3">&quot;WARNING: reaching max number of inner iterations</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">);</span>

		<span class="s1">delta = </span><span class="s5">0</span><span class="s1">;</span>
		<span class="s1">w_norm_new = </span><span class="s5">0</span><span class="s1">;</span>
		<span class="s2">for</span><span class="s1">(j=</span><span class="s5">0</span><span class="s1">; j&lt;w_size; j++)</span>
		<span class="s1">{</span>
			<span class="s1">delta += Grad[j]*(wpd[j]-w[j]);</span>
			<span class="s2">if</span><span class="s1">(wpd[j] != </span><span class="s5">0</span><span class="s1">)</span>
				<span class="s1">w_norm_new += fabs(wpd[j]);</span>
		<span class="s1">}</span>
		<span class="s1">delta += (w_norm_new-w_norm);</span>

		<span class="s1">negsum_xTd = </span><span class="s5">0</span><span class="s1">;</span>
		<span class="s2">for</span><span class="s1">(</span><span class="s2">int </span><span class="s1">i=</span><span class="s5">0</span><span class="s1">; i&lt;l; i++)</span>
			<span class="s2">if</span><span class="s1">(y[i] == -</span><span class="s5">1</span><span class="s1">)</span>
				<span class="s1">negsum_xTd += C[GETI(i)]*xTd[i];</span>

		<span class="s2">int </span><span class="s1">num_linesearch;</span>
		<span class="s2">for</span><span class="s1">(num_linesearch=</span><span class="s5">0</span><span class="s1">; num_linesearch &lt; max_num_linesearch; num_linesearch++)</span>
		<span class="s1">{</span>
			<span class="s1">cond = w_norm_new - w_norm + negsum_xTd - sigma*delta;</span>

			<span class="s2">for</span><span class="s1">(</span><span class="s2">int </span><span class="s1">i=</span><span class="s5">0</span><span class="s1">; i&lt;l; i++)</span>
			<span class="s1">{</span>
				<span class="s2">double </span><span class="s1">exp_xTd = exp(xTd[i]);</span>
				<span class="s1">exp_wTx_new[i] = exp_wTx[i]*exp_xTd;</span>
				<span class="s1">cond += C[GETI(i)]*log((</span><span class="s5">1</span><span class="s1">+exp_wTx_new[i])/(exp_xTd+exp_wTx_new[i]));</span>
			<span class="s1">}</span>

			<span class="s2">if</span><span class="s1">(cond &lt;= </span><span class="s5">0</span><span class="s1">)</span>
			<span class="s1">{</span>
				<span class="s1">w_norm = w_norm_new;</span>
				<span class="s2">for</span><span class="s1">(j=</span><span class="s5">0</span><span class="s1">; j&lt;w_size; j++)</span>
					<span class="s1">w[j] = wpd[j];</span>
				<span class="s2">for</span><span class="s1">(</span><span class="s2">int </span><span class="s1">i=</span><span class="s5">0</span><span class="s1">; i&lt;l; i++)</span>
				<span class="s1">{</span>
					<span class="s1">exp_wTx[i] = exp_wTx_new[i];</span>
					<span class="s2">double </span><span class="s1">tau_tmp = </span><span class="s5">1</span><span class="s1">/(</span><span class="s5">1</span><span class="s1">+exp_wTx[i]);</span>
					<span class="s1">tau[i] = C[GETI(i)]*tau_tmp;</span>
					<span class="s1">D[i] = C[GETI(i)]*exp_wTx[i]*tau_tmp*tau_tmp;</span>
				<span class="s1">}</span>
				<span class="s2">break</span><span class="s1">;</span>
			<span class="s1">}</span>
			<span class="s2">else</span>
			<span class="s1">{</span>
				<span class="s1">w_norm_new = </span><span class="s5">0</span><span class="s1">;</span>
				<span class="s2">for</span><span class="s1">(j=</span><span class="s5">0</span><span class="s1">; j&lt;w_size; j++)</span>
				<span class="s1">{</span>
					<span class="s1">wpd[j] = (w[j]+wpd[j])*</span><span class="s5">0.5</span><span class="s1">;</span>
					<span class="s2">if</span><span class="s1">(wpd[j] != </span><span class="s5">0</span><span class="s1">)</span>
						<span class="s1">w_norm_new += fabs(wpd[j]);</span>
				<span class="s1">}</span>
				<span class="s1">delta *= </span><span class="s5">0.5</span><span class="s1">;</span>
				<span class="s1">negsum_xTd *= </span><span class="s5">0.5</span><span class="s1">;</span>
				<span class="s2">for</span><span class="s1">(</span><span class="s2">int </span><span class="s1">i=</span><span class="s5">0</span><span class="s1">; i&lt;l; i++)</span>
					<span class="s1">xTd[i] *= </span><span class="s5">0.5</span><span class="s1">;</span>
			<span class="s1">}</span>
		<span class="s1">}</span>

		<span class="s0">// Recompute some info due to too many line search steps</span>
		<span class="s2">if</span><span class="s1">(num_linesearch &gt;= max_num_linesearch)</span>
		<span class="s1">{</span>
			<span class="s2">for</span><span class="s1">(</span><span class="s2">int </span><span class="s1">i=</span><span class="s5">0</span><span class="s1">; i&lt;l; i++)</span>
				<span class="s1">exp_wTx[i] = </span><span class="s5">0</span><span class="s1">;</span>

			<span class="s2">for</span><span class="s1">(</span><span class="s2">int </span><span class="s1">i=</span><span class="s5">0</span><span class="s1">; i&lt;w_size; i++)</span>
			<span class="s1">{</span>
				<span class="s2">if</span><span class="s1">(w[i]==</span><span class="s5">0</span><span class="s1">) </span><span class="s2">continue</span><span class="s1">;</span>
				<span class="s1">x = prob_col</span><span class="s6">-&gt;</span><span class="s1">x[i];</span>
				<span class="s2">while</span><span class="s1">(x</span><span class="s6">-&gt;</span><span class="s1">index != -</span><span class="s5">1</span><span class="s1">)</span>
				<span class="s1">{</span>
					<span class="s1">exp_wTx[x</span><span class="s6">-&gt;</span><span class="s1">index-1] += w[i]*x</span><span class="s6">-&gt;</span><span class="s1">value;</span>
					<span class="s1">x++;</span>
				<span class="s1">}</span>
			<span class="s1">}</span>

			<span class="s2">for</span><span class="s1">(</span><span class="s2">int </span><span class="s1">i=</span><span class="s5">0</span><span class="s1">; i&lt;l; i++)</span>
				<span class="s1">exp_wTx[i] = exp(exp_wTx[i]);</span>
		<span class="s1">}</span>

		<span class="s2">if</span><span class="s1">(iter == </span><span class="s5">1</span><span class="s1">)</span>
			<span class="s1">inner_eps *= </span><span class="s5">0.25</span><span class="s1">;</span>

		<span class="s1">newton_iter++;</span>
		<span class="s1">Gmax_old = Gmax_new;</span>

		<span class="s1">info(</span><span class="s3">&quot;iter %3d  #CD cycles %d</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">, newton_iter, iter);</span>
	<span class="s1">}</span>

	<span class="s1">info(</span><span class="s3">&quot;=========================</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">);</span>
	<span class="s1">info(</span><span class="s3">&quot;optimization finished, #iter = %d</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">, newton_iter);</span>
	<span class="s2">if</span><span class="s1">(newton_iter &gt;= max_newton_iter)</span>
		<span class="s1">info(</span><span class="s3">&quot;WARNING: reaching max number of iterations</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">);</span>

	<span class="s0">// calculate objective value</span>

	<span class="s2">double </span><span class="s1">v = </span><span class="s5">0</span><span class="s1">;</span>
	<span class="s2">int </span><span class="s1">nnz = </span><span class="s5">0</span><span class="s1">;</span>
	<span class="s2">for</span><span class="s1">(j=</span><span class="s5">0</span><span class="s1">; j&lt;w_size; j++)</span>
		<span class="s2">if</span><span class="s1">(w[j] != </span><span class="s5">0</span><span class="s1">)</span>
		<span class="s1">{</span>
			<span class="s1">v += fabs(w[j]);</span>
			<span class="s1">nnz++;</span>
		<span class="s1">}</span>
	<span class="s2">for</span><span class="s1">(j=</span><span class="s5">0</span><span class="s1">; j&lt;l; j++)</span>
		<span class="s2">if</span><span class="s1">(y[j] == </span><span class="s5">1</span><span class="s1">)</span>
			<span class="s1">v += C[GETI(j)]*log(</span><span class="s5">1</span><span class="s1">+</span><span class="s5">1</span><span class="s1">/exp_wTx[j]);</span>
		<span class="s2">else</span>
			<span class="s1">v += C[GETI(j)]*log(</span><span class="s5">1</span><span class="s1">+exp_wTx[j]);</span>

	<span class="s1">info(</span><span class="s3">&quot;Objective value = %lf</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">, v);</span>
	<span class="s1">info(</span><span class="s3">&quot;#nonzeros/#features = %d/%d</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">, nnz, w_size);</span>

	<span class="s2">delete </span><span class="s1">[] index;</span>
	<span class="s2">delete </span><span class="s1">[] y;</span>
	<span class="s2">delete </span><span class="s1">[] Hdiag;</span>
	<span class="s2">delete </span><span class="s1">[] Grad;</span>
	<span class="s2">delete </span><span class="s1">[] wpd;</span>
	<span class="s2">delete </span><span class="s1">[] xjneg_sum;</span>
	<span class="s2">delete </span><span class="s1">[] xTd;</span>
	<span class="s2">delete </span><span class="s1">[] exp_wTx;</span>
	<span class="s2">delete </span><span class="s1">[] exp_wTx_new;</span>
	<span class="s2">delete </span><span class="s1">[] tau;</span>
	<span class="s2">delete </span><span class="s1">[] D;</span>
	<span class="s2">delete </span><span class="s1">[] C;</span>
	<span class="s2">return </span><span class="s1">newton_iter;</span>
<span class="s1">}</span>

<span class="s0">// transpose matrix X from row format to column format</span>
<span class="s2">static void </span><span class="s1">transpose(</span><span class="s2">const </span><span class="s1">problem *prob, feature_node **x_space_ret, problem *prob_col)</span>
<span class="s1">{</span>
	<span class="s2">int </span><span class="s1">i;</span>
	<span class="s2">int </span><span class="s1">l = prob</span><span class="s6">-&gt;</span><span class="s1">l;</span>
	<span class="s2">int </span><span class="s1">n = prob</span><span class="s6">-&gt;</span><span class="s1">n;</span>
	<span class="s1">size_t nnz = </span><span class="s5">0</span><span class="s1">;</span>
	<span class="s1">size_t *col_ptr = </span><span class="s4">new </span><span class="s1">size_t [n+</span><span class="s5">1</span><span class="s1">];</span>
	<span class="s1">feature_node *x_space;</span>
	<span class="s1">prob_col</span><span class="s6">-&gt;</span><span class="s1">l = l;</span>
	<span class="s1">prob_col</span><span class="s6">-&gt;</span><span class="s1">n = n;</span>
	<span class="s1">prob_col</span><span class="s6">-&gt;</span><span class="s1">y = </span><span class="s4">new </span><span class="s2">double</span><span class="s1">[l];</span>
	<span class="s1">prob_col</span><span class="s6">-&gt;</span><span class="s1">x = </span><span class="s4">new </span><span class="s1">feature_node*[n];</span>
	<span class="s1">prob_col</span><span class="s6">-&gt;</span><span class="s1">W = </span><span class="s4">new </span><span class="s2">double</span><span class="s1">[l];</span>

	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">; i&lt;l; i++)</span>
	<span class="s1">{</span>
		<span class="s1">prob_col</span><span class="s6">-&gt;</span><span class="s1">y[i] = prob</span><span class="s6">-&gt;</span><span class="s1">y[i];</span>
		<span class="s1">prob_col</span><span class="s6">-&gt;</span><span class="s1">W[i] = prob</span><span class="s6">-&gt;</span><span class="s1">W[i];</span>
	<span class="s1">}</span>

	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">; i&lt;n+</span><span class="s5">1</span><span class="s1">; i++)</span>
		<span class="s1">col_ptr[i] = </span><span class="s5">0</span><span class="s1">;</span>
	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">; i&lt;l; i++)</span>
	<span class="s1">{</span>
		<span class="s1">feature_node *x = prob</span><span class="s6">-&gt;</span><span class="s1">x[i];</span>
		<span class="s2">while</span><span class="s1">(x</span><span class="s6">-&gt;</span><span class="s1">index != -</span><span class="s5">1</span><span class="s1">)</span>
		<span class="s1">{</span>
			<span class="s1">nnz++;</span>
			<span class="s1">col_ptr[x</span><span class="s6">-&gt;</span><span class="s1">index]++;</span>
			<span class="s1">x++;</span>
		<span class="s1">}</span>
	<span class="s1">}</span>
	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">1</span><span class="s1">; i&lt;n+</span><span class="s5">1</span><span class="s1">; i++)</span>
		<span class="s1">col_ptr[i] += col_ptr[i-1] + </span><span class="s5">1</span><span class="s1">;</span>

	<span class="s1">x_space = </span><span class="s4">new </span><span class="s1">feature_node[nnz+n];</span>
	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">; i&lt;n; i++)</span>
		<span class="s1">prob_col</span><span class="s6">-&gt;</span><span class="s1">x[i] = &amp;x_space[col_ptr[i]];</span>

	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">; i&lt;l; i++)</span>
	<span class="s1">{</span>
		<span class="s1">feature_node *x = prob</span><span class="s6">-&gt;</span><span class="s1">x[i];</span>
		<span class="s2">while</span><span class="s1">(x</span><span class="s6">-&gt;</span><span class="s1">index != -</span><span class="s5">1</span><span class="s1">)</span>
		<span class="s1">{</span>
			<span class="s2">int </span><span class="s1">ind = x</span><span class="s6">-&gt;</span><span class="s1">index-1;</span>
			<span class="s1">x_space[col_ptr[ind]].index = i+</span><span class="s5">1</span><span class="s1">; </span><span class="s0">// starts from 1</span>
			<span class="s1">x_space[col_ptr[ind]].value = x</span><span class="s6">-&gt;</span><span class="s1">value;</span>
			<span class="s1">col_ptr[ind]++;</span>
			<span class="s1">x++;</span>
		<span class="s1">}</span>
	<span class="s1">}</span>
	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">; i&lt;n; i++)</span>
		<span class="s1">x_space[col_ptr[i]].index = -</span><span class="s5">1</span><span class="s1">;</span>

	<span class="s1">*x_space_ret = x_space;</span>

	<span class="s2">delete </span><span class="s1">[] col_ptr;</span>
<span class="s1">}</span>

<span class="s0">// label: label name, start: begin of each class, count: #data of classes, perm: indices to the original data</span>
<span class="s0">// perm, length l, must be allocated before calling this subroutine</span>
<span class="s2">static void </span><span class="s1">group_classes(</span><span class="s2">const </span><span class="s1">problem *prob, </span><span class="s2">int </span><span class="s1">*nr_class_ret, </span><span class="s2">int </span><span class="s1">**label_ret, </span><span class="s2">int </span><span class="s1">**start_ret, </span><span class="s2">int </span><span class="s1">**count_ret, </span><span class="s2">int </span><span class="s1">*perm)</span>
<span class="s1">{</span>
	<span class="s2">int </span><span class="s1">l = prob</span><span class="s6">-&gt;</span><span class="s1">l;</span>
	<span class="s2">int </span><span class="s1">max_nr_class = </span><span class="s5">16</span><span class="s1">;</span>
	<span class="s2">int </span><span class="s1">nr_class = </span><span class="s5">0</span><span class="s1">;</span>
	<span class="s2">int </span><span class="s1">*label = Malloc(</span><span class="s2">int</span><span class="s1">,max_nr_class);</span>
	<span class="s2">int </span><span class="s1">*count = Malloc(</span><span class="s2">int</span><span class="s1">,max_nr_class);</span>
	<span class="s2">int </span><span class="s1">*data_label = Malloc(</span><span class="s2">int</span><span class="s1">,l);</span>
	<span class="s2">int </span><span class="s1">i;</span>

	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;l;i++)</span>
	<span class="s1">{</span>
		<span class="s2">int </span><span class="s1">this_label = (</span><span class="s2">int</span><span class="s1">)prob</span><span class="s6">-&gt;</span><span class="s1">y[i];</span>
		<span class="s2">int </span><span class="s1">j;</span>
		<span class="s2">for</span><span class="s1">(j=</span><span class="s5">0</span><span class="s1">;j&lt;nr_class;j++)</span>
		<span class="s1">{</span>
			<span class="s2">if</span><span class="s1">(this_label == label[j])</span>
			<span class="s1">{</span>
				<span class="s1">++count[j];</span>
				<span class="s2">break</span><span class="s1">;</span>
			<span class="s1">}</span>
		<span class="s1">}</span>
		<span class="s1">data_label[i] = j;</span>
		<span class="s2">if</span><span class="s1">(j == nr_class)</span>
		<span class="s1">{</span>
			<span class="s2">if</span><span class="s1">(nr_class == max_nr_class)</span>
			<span class="s1">{</span>
				<span class="s1">max_nr_class *= </span><span class="s5">2</span><span class="s1">;</span>
				<span class="s1">label = (</span><span class="s2">int </span><span class="s1">*)realloc(label,max_nr_class*</span><span class="s2">sizeof</span><span class="s1">(</span><span class="s2">int</span><span class="s1">));</span>
				<span class="s1">count = (</span><span class="s2">int </span><span class="s1">*)realloc(count,max_nr_class*</span><span class="s2">sizeof</span><span class="s1">(</span><span class="s2">int</span><span class="s1">));</span>
			<span class="s1">}</span>
			<span class="s1">label[nr_class] = this_label;</span>
			<span class="s1">count[nr_class] = </span><span class="s5">1</span><span class="s1">;</span>
			<span class="s1">++nr_class;</span>
		<span class="s1">}</span>
	<span class="s1">}</span>

        <span class="s0">/* START MOD: Sort labels and apply to array count --dyamins */</span>

        <span class="s2">int </span><span class="s1">j;</span>
        <span class="s2">for </span><span class="s1">(j=</span><span class="s5">1</span><span class="s1">; j&lt;nr_class; j++)</span>
        <span class="s1">{</span>
                <span class="s1">i = j-1;</span>
                <span class="s2">int </span><span class="s1">this_label = label[j];</span>
                <span class="s2">int </span><span class="s1">this_count = count[j];</span>
                <span class="s2">while</span><span class="s1">(i&gt;=</span><span class="s5">0 </span><span class="s1">&amp;&amp; label[i] &gt; this_label)</span>
                <span class="s1">{</span>
                        <span class="s1">label[i+</span><span class="s5">1</span><span class="s1">] = label[i];</span>
                        <span class="s1">count[i+</span><span class="s5">1</span><span class="s1">] = count[i];</span>
                        <span class="s1">i--;</span>
                <span class="s1">}</span>
                <span class="s1">label[i+</span><span class="s5">1</span><span class="s1">] = this_label;</span>
                <span class="s1">count[i+</span><span class="s5">1</span><span class="s1">] = this_count;</span>
        <span class="s1">}</span>

        <span class="s2">for </span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">; i &lt;l; i++)</span>
        <span class="s1">{</span>
                <span class="s1">j = </span><span class="s5">0</span><span class="s1">;</span>
                <span class="s2">int </span><span class="s1">this_label = (</span><span class="s2">int</span><span class="s1">)prob</span><span class="s6">-&gt;</span><span class="s1">y[i];</span>
                <span class="s2">while</span><span class="s1">(this_label != label[j])</span>
                <span class="s1">{</span>
                        <span class="s1">j++;</span>
                <span class="s1">}</span>
                <span class="s1">data_label[i] = j;</span>

        <span class="s1">}</span>

        <span class="s0">/* END MOD */</span>

<span class="s2">#if </span><span class="s5">0</span>
	<span class="s0">//</span>
	<span class="s0">// Labels are ordered by their first occurrence in the training set.</span>
	<span class="s0">// However, for two-class sets with -1/+1 labels and -1 appears first,</span>
	<span class="s0">// we swap labels to ensure that internally the binary SVM has positive data corresponding to the +1 instances.</span>
	<span class="s0">//</span>
	<span class="s2">if </span><span class="s1">(nr_class == </span><span class="s5">2 </span><span class="s1">&amp;&amp; label[</span><span class="s5">0</span><span class="s1">] == -</span><span class="s5">1 </span><span class="s1">&amp;&amp; label[</span><span class="s5">1</span><span class="s1">] == </span><span class="s5">1</span><span class="s1">)</span>
	<span class="s1">{</span>
		<span class="s1">swap(label[</span><span class="s5">0</span><span class="s1">],label[</span><span class="s5">1</span><span class="s1">]);</span>
		<span class="s1">swap(count[</span><span class="s5">0</span><span class="s1">],count[</span><span class="s5">1</span><span class="s1">]);</span>
		<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;l;i++)</span>
		<span class="s1">{</span>
			<span class="s2">if</span><span class="s1">(data_label[i] == </span><span class="s5">0</span><span class="s1">)</span>
				<span class="s1">data_label[i] = </span><span class="s5">1</span><span class="s1">;</span>
			<span class="s2">else</span>
				<span class="s1">data_label[i] = </span><span class="s5">0</span><span class="s1">;</span>
		<span class="s1">}</span>
	<span class="s1">}</span>
<span class="s2">#endif</span>

	<span class="s2">int </span><span class="s1">*start = Malloc(</span><span class="s2">int</span><span class="s1">,nr_class);</span>
	<span class="s1">start[</span><span class="s5">0</span><span class="s1">] = </span><span class="s5">0</span><span class="s1">;</span>
	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">1</span><span class="s1">;i&lt;nr_class;i++)</span>
		<span class="s1">start[i] = start[i-1]+count[i-1];</span>
	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;l;i++)</span>
	<span class="s1">{</span>
		<span class="s1">perm[start[data_label[i]]] = i;</span>
		<span class="s1">++start[data_label[i]];</span>
	<span class="s1">}</span>
	<span class="s1">start[</span><span class="s5">0</span><span class="s1">] = </span><span class="s5">0</span><span class="s1">;</span>
	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">1</span><span class="s1">;i&lt;nr_class;i++)</span>
		<span class="s1">start[i] = start[i-1]+count[i-1];</span>

	<span class="s1">*nr_class_ret = nr_class;</span>
	<span class="s1">*label_ret = label;</span>
	<span class="s1">*start_ret = start;</span>
	<span class="s1">*count_ret = count;</span>
	<span class="s1">free(data_label);</span>
<span class="s1">}</span>

<span class="s2">static int </span><span class="s1">train_one(</span><span class="s2">const </span><span class="s1">problem *prob, </span><span class="s2">const </span><span class="s1">parameter *param, </span><span class="s2">double </span><span class="s1">*w, </span><span class="s2">double </span><span class="s1">Cp, </span><span class="s2">double </span><span class="s1">Cn, BlasFunctions *blas_functions)</span>
<span class="s1">{</span>
	<span class="s2">double </span><span class="s1">eps=param</span><span class="s6">-&gt;</span><span class="s1">eps;</span>
	<span class="s2">int </span><span class="s1">max_iter=param</span><span class="s6">-&gt;</span><span class="s1">max_iter;</span>
	<span class="s2">int </span><span class="s1">pos = </span><span class="s5">0</span><span class="s1">;</span>
	<span class="s2">int </span><span class="s1">neg = </span><span class="s5">0</span><span class="s1">;</span>
	<span class="s2">int </span><span class="s1">n_iter = -</span><span class="s5">1</span><span class="s1">;</span>
	<span class="s2">for</span><span class="s1">(</span><span class="s2">int </span><span class="s1">i=</span><span class="s5">0</span><span class="s1">;i&lt;prob</span><span class="s6">-&gt;</span><span class="s1">l;i++)</span>
		<span class="s2">if</span><span class="s1">(prob</span><span class="s6">-&gt;</span><span class="s1">y[i] &gt; </span><span class="s5">0</span><span class="s1">)</span>
			<span class="s1">pos++;</span>
	<span class="s1">neg = prob</span><span class="s6">-&gt;</span><span class="s1">l - pos;</span>

	<span class="s2">double </span><span class="s1">primal_solver_tol = eps*max(min(pos,neg), </span><span class="s5">1</span><span class="s1">)/prob</span><span class="s6">-&gt;</span><span class="s1">l;</span>

	<span class="s1">function *fun_obj=NULL;</span>
	<span class="s2">switch</span><span class="s1">(param</span><span class="s6">-&gt;</span><span class="s1">solver_type)</span>
	<span class="s1">{</span>
		<span class="s2">case </span><span class="s1">L2R_LR:</span>
		<span class="s1">{</span>
			<span class="s2">double </span><span class="s1">*C = </span><span class="s4">new </span><span class="s2">double</span><span class="s1">[prob</span><span class="s6">-&gt;</span><span class="s1">l];</span>
			<span class="s2">for</span><span class="s1">(</span><span class="s2">int </span><span class="s1">i = </span><span class="s5">0</span><span class="s1">; i &lt; prob</span><span class="s6">-&gt;</span><span class="s1">l; i++)</span>
			<span class="s1">{</span>
				<span class="s2">if</span><span class="s1">(prob</span><span class="s6">-&gt;</span><span class="s1">y[i] &gt; </span><span class="s5">0</span><span class="s1">)</span>
					<span class="s1">C[i] = prob</span><span class="s6">-&gt;</span><span class="s1">W[i] * Cp;</span>
				<span class="s2">else</span>
					<span class="s1">C[i] = prob</span><span class="s6">-&gt;</span><span class="s1">W[i] * Cn;</span>
			<span class="s1">}</span>

			<span class="s1">fun_obj=</span><span class="s4">new </span><span class="s1">l2r_lr_fun(prob, C);</span>
			<span class="s1">TRON tron_obj(fun_obj, primal_solver_tol, max_iter, blas_functions);</span>
			<span class="s1">tron_obj.set_print_string(liblinear_print_string);</span>
			<span class="s1">n_iter=tron_obj.tron(w);</span>
			<span class="s2">delete </span><span class="s1">fun_obj;</span>
			<span class="s2">delete</span><span class="s1">[] C;</span>
			<span class="s2">break</span><span class="s1">;</span>
		<span class="s1">}</span>
		<span class="s2">case </span><span class="s1">L2R_L2LOSS_SVC:</span>
		<span class="s1">{</span>
			<span class="s2">double </span><span class="s1">*C = </span><span class="s4">new </span><span class="s2">double</span><span class="s1">[prob</span><span class="s6">-&gt;</span><span class="s1">l];</span>
			<span class="s2">for</span><span class="s1">(</span><span class="s2">int </span><span class="s1">i = </span><span class="s5">0</span><span class="s1">; i &lt; prob</span><span class="s6">-&gt;</span><span class="s1">l; i++)</span>
			<span class="s1">{</span>
				<span class="s2">if</span><span class="s1">(prob</span><span class="s6">-&gt;</span><span class="s1">y[i] &gt; </span><span class="s5">0</span><span class="s1">)</span>
					<span class="s1">C[i] = prob</span><span class="s6">-&gt;</span><span class="s1">W[i] * Cp;</span>
				<span class="s2">else</span>
					<span class="s1">C[i] = prob</span><span class="s6">-&gt;</span><span class="s1">W[i] * Cn;</span>
			<span class="s1">}</span>
			<span class="s1">fun_obj=</span><span class="s4">new </span><span class="s1">l2r_l2_svc_fun(prob, C);</span>
			<span class="s1">TRON tron_obj(fun_obj, primal_solver_tol, max_iter, blas_functions);</span>
			<span class="s1">tron_obj.set_print_string(liblinear_print_string);</span>
			<span class="s1">n_iter=tron_obj.tron(w);</span>
			<span class="s2">delete </span><span class="s1">fun_obj;</span>
			<span class="s2">delete</span><span class="s1">[] C;</span>
			<span class="s2">break</span><span class="s1">;</span>
		<span class="s1">}</span>
		<span class="s2">case </span><span class="s1">L2R_L2LOSS_SVC_DUAL:</span>
			<span class="s1">n_iter=solve_l2r_l1l2_svc(prob, w, eps, Cp, Cn, L2R_L2LOSS_SVC_DUAL, max_iter);</span>
			<span class="s2">break</span><span class="s1">;</span>
		<span class="s2">case </span><span class="s1">L2R_L1LOSS_SVC_DUAL:</span>
			<span class="s1">n_iter=solve_l2r_l1l2_svc(prob, w, eps, Cp, Cn, L2R_L1LOSS_SVC_DUAL, max_iter);</span>
			<span class="s2">break</span><span class="s1">;</span>
		<span class="s2">case </span><span class="s1">L1R_L2LOSS_SVC:</span>
		<span class="s1">{</span>
			<span class="s1">problem prob_col;</span>
			<span class="s1">feature_node *x_space = NULL;</span>
			<span class="s1">transpose(prob, &amp;x_space ,&amp;prob_col);</span>
			<span class="s1">n_iter=solve_l1r_l2_svc(&amp;prob_col, w, primal_solver_tol, Cp, Cn, max_iter);</span>
			<span class="s2">delete </span><span class="s1">[] prob_col.y;</span>
			<span class="s2">delete </span><span class="s1">[] prob_col.x;</span>
			<span class="s2">delete </span><span class="s1">[] prob_col.W;</span>
			<span class="s2">delete </span><span class="s1">[] x_space;</span>
			<span class="s2">break</span><span class="s1">;</span>
		<span class="s1">}</span>
		<span class="s2">case </span><span class="s1">L1R_LR:</span>
		<span class="s1">{</span>
			<span class="s1">problem prob_col;</span>
			<span class="s1">feature_node *x_space = NULL;</span>
			<span class="s1">transpose(prob, &amp;x_space ,&amp;prob_col);</span>
			<span class="s1">n_iter=solve_l1r_lr(&amp;prob_col, w, primal_solver_tol, Cp, Cn, max_iter);</span>
			<span class="s2">delete </span><span class="s1">[] prob_col.y;</span>
			<span class="s2">delete </span><span class="s1">[] prob_col.x;</span>
			<span class="s2">delete </span><span class="s1">[] prob_col.W;</span>
			<span class="s2">delete </span><span class="s1">[] x_space;</span>
			<span class="s2">break</span><span class="s1">;</span>
		<span class="s1">}</span>
		<span class="s2">case </span><span class="s1">L2R_LR_DUAL:</span>
			<span class="s1">n_iter=solve_l2r_lr_dual(prob, w, eps, Cp, Cn, max_iter);</span>
			<span class="s2">break</span><span class="s1">;</span>
		<span class="s2">case </span><span class="s1">L2R_L2LOSS_SVR:</span>
		<span class="s1">{</span>
			<span class="s2">double </span><span class="s1">*C = </span><span class="s4">new </span><span class="s2">double</span><span class="s1">[prob</span><span class="s6">-&gt;</span><span class="s1">l];</span>
			<span class="s2">for</span><span class="s1">(</span><span class="s2">int </span><span class="s1">i = </span><span class="s5">0</span><span class="s1">; i &lt; prob</span><span class="s6">-&gt;</span><span class="s1">l; i++)</span>
				<span class="s1">C[i] = prob</span><span class="s6">-&gt;</span><span class="s1">W[i] * param</span><span class="s6">-&gt;</span><span class="s1">C;</span>

			<span class="s1">fun_obj=</span><span class="s4">new </span><span class="s1">l2r_l2_svr_fun(prob, C, param</span><span class="s6">-&gt;</span><span class="s1">p);</span>
			<span class="s1">TRON tron_obj(fun_obj, param</span><span class="s6">-&gt;</span><span class="s1">eps, max_iter, blas_functions);</span>
			<span class="s1">tron_obj.set_print_string(liblinear_print_string);</span>
			<span class="s1">n_iter=tron_obj.tron(w);</span>
			<span class="s2">delete </span><span class="s1">fun_obj;</span>
			<span class="s2">delete</span><span class="s1">[] C;</span>
			<span class="s2">break</span><span class="s1">;</span>

		<span class="s1">}</span>
		<span class="s2">case </span><span class="s1">L2R_L1LOSS_SVR_DUAL:</span>
			<span class="s1">n_iter=solve_l2r_l1l2_svr(prob, w, param, L2R_L1LOSS_SVR_DUAL, max_iter);</span>
			<span class="s2">break</span><span class="s1">;</span>
		<span class="s2">case </span><span class="s1">L2R_L2LOSS_SVR_DUAL:</span>
			<span class="s1">n_iter=solve_l2r_l1l2_svr(prob, w, param, L2R_L2LOSS_SVR_DUAL, max_iter);</span>
			<span class="s2">break</span><span class="s1">;</span>
		<span class="s2">default</span><span class="s1">:</span>
			<span class="s1">fprintf(stderr, </span><span class="s3">&quot;ERROR: unknown solver_type</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">);</span>
			<span class="s2">break</span><span class="s1">;</span>
	<span class="s1">}</span>
	<span class="s2">return </span><span class="s1">n_iter;</span>
<span class="s1">}</span>

<span class="s0">//</span>
<span class="s0">// Remove zero weighed data as libsvm and some liblinear solvers require C &gt; 0.</span>
<span class="s0">//</span>
<span class="s2">static void </span><span class="s1">remove_zero_weight(problem *newprob, </span><span class="s2">const </span><span class="s1">problem *prob)</span>
<span class="s1">{</span>
	<span class="s2">int </span><span class="s1">i;</span>
	<span class="s2">int </span><span class="s1">l = </span><span class="s5">0</span><span class="s1">;</span>
	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;prob</span><span class="s6">-&gt;</span><span class="s1">l;i++)</span>
		<span class="s2">if</span><span class="s1">(prob</span><span class="s6">-&gt;</span><span class="s1">W[i] &gt; </span><span class="s5">0</span><span class="s1">) l++;</span>
	<span class="s1">*newprob = *prob;</span>
	<span class="s1">newprob</span><span class="s6">-&gt;</span><span class="s1">l = l;</span>
	<span class="s1">newprob</span><span class="s6">-&gt;</span><span class="s1">x = Malloc(feature_node*,l);</span>
	<span class="s1">newprob</span><span class="s6">-&gt;</span><span class="s1">y = Malloc(</span><span class="s2">double</span><span class="s1">,l);</span>
	<span class="s1">newprob</span><span class="s6">-&gt;</span><span class="s1">W = Malloc(</span><span class="s2">double</span><span class="s1">,l);</span>

	<span class="s2">int </span><span class="s1">j = </span><span class="s5">0</span><span class="s1">;</span>
	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;prob</span><span class="s6">-&gt;</span><span class="s1">l;i++)</span>
		<span class="s2">if</span><span class="s1">(prob</span><span class="s6">-&gt;</span><span class="s1">W[i] &gt; </span><span class="s5">0</span><span class="s1">)</span>
		<span class="s1">{</span>
			<span class="s1">newprob</span><span class="s6">-&gt;</span><span class="s1">x[j] = prob</span><span class="s6">-&gt;</span><span class="s1">x[i];</span>
			<span class="s1">newprob</span><span class="s6">-&gt;</span><span class="s1">y[j] = prob</span><span class="s6">-&gt;</span><span class="s1">y[i];</span>
			<span class="s1">newprob</span><span class="s6">-&gt;</span><span class="s1">W[j] = prob</span><span class="s6">-&gt;</span><span class="s1">W[i];</span>
			<span class="s1">j++;</span>
		<span class="s1">}</span>
<span class="s1">}</span>

<span class="s0">//</span>
<span class="s0">// Interface functions</span>
<span class="s0">//</span>
<span class="s1">model* train(</span><span class="s2">const </span><span class="s1">problem *prob, </span><span class="s2">const </span><span class="s1">parameter *param, BlasFunctions *blas_functions)</span>
<span class="s1">{</span>
	<span class="s1">problem newprob;</span>
	<span class="s1">remove_zero_weight(&amp;newprob, prob);</span>
	<span class="s1">prob = &amp;newprob;</span>
	<span class="s2">int </span><span class="s1">i,j;</span>
	<span class="s2">int </span><span class="s1">l = prob</span><span class="s6">-&gt;</span><span class="s1">l;</span>
	<span class="s2">int </span><span class="s1">n = prob</span><span class="s6">-&gt;</span><span class="s1">n;</span>
	<span class="s2">int </span><span class="s1">w_size = prob</span><span class="s6">-&gt;</span><span class="s1">n;</span>
	<span class="s1">model *model_ = Malloc(model,</span><span class="s5">1</span><span class="s1">);</span>

	<span class="s2">if</span><span class="s1">(prob</span><span class="s6">-&gt;</span><span class="s1">bias&gt;=</span><span class="s5">0</span><span class="s1">)</span>
		<span class="s1">model_</span><span class="s6">-&gt;</span><span class="s1">nr_feature=n-1;</span>
	<span class="s2">else</span>
		<span class="s1">model_</span><span class="s6">-&gt;</span><span class="s1">nr_feature=n;</span>
	<span class="s1">model_</span><span class="s6">-&gt;</span><span class="s1">param = *param;</span>
	<span class="s1">model_</span><span class="s6">-&gt;</span><span class="s1">bias = prob</span><span class="s6">-&gt;</span><span class="s1">bias;</span>

	<span class="s2">if</span><span class="s1">(check_regression_model(model_))</span>
	<span class="s1">{</span>
		<span class="s1">model_</span><span class="s6">-&gt;</span><span class="s1">w = Malloc(</span><span class="s2">double</span><span class="s1">, w_size);</span>
		<span class="s1">model_</span><span class="s6">-&gt;</span><span class="s1">n_iter = Malloc(</span><span class="s2">int</span><span class="s1">, </span><span class="s5">1</span><span class="s1">);</span>
		<span class="s1">model_</span><span class="s6">-&gt;</span><span class="s1">nr_class = </span><span class="s5">2</span><span class="s1">;</span>
		<span class="s1">model_</span><span class="s6">-&gt;</span><span class="s1">label = NULL;</span>
		<span class="s1">model_</span><span class="s6">-&gt;</span><span class="s1">n_iter[</span><span class="s5">0</span><span class="s1">] =train_one(prob, param, &amp;model_</span><span class="s6">-&gt;</span><span class="s1">w[</span><span class="s5">0</span><span class="s1">], </span><span class="s5">0</span><span class="s1">, </span><span class="s5">0</span><span class="s1">, blas_functions);</span>
	<span class="s1">}</span>
	<span class="s2">else</span>
	<span class="s1">{</span>
		<span class="s2">int </span><span class="s1">nr_class;</span>
		<span class="s2">int </span><span class="s1">*label = NULL;</span>
		<span class="s2">int </span><span class="s1">*start = NULL;</span>
		<span class="s2">int </span><span class="s1">*count = NULL;</span>
		<span class="s2">int </span><span class="s1">*perm = Malloc(</span><span class="s2">int</span><span class="s1">,l);</span>

		<span class="s0">// group training data of the same class</span>
		<span class="s1">group_classes(prob,&amp;nr_class,&amp;label,&amp;start,&amp;count,perm);</span>

		<span class="s1">model_</span><span class="s6">-&gt;</span><span class="s1">nr_class=nr_class;</span>
		<span class="s1">model_</span><span class="s6">-&gt;</span><span class="s1">label = Malloc(</span><span class="s2">int</span><span class="s1">,nr_class);</span>
		<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;nr_class;i++)</span>
			<span class="s1">model_</span><span class="s6">-&gt;</span><span class="s1">label[i] = label[i];</span>

		<span class="s0">// calculate weighted C</span>
		<span class="s2">double </span><span class="s1">*weighted_C = Malloc(</span><span class="s2">double</span><span class="s1">, nr_class);</span>
		<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;nr_class;i++)</span>
			<span class="s1">weighted_C[i] = param</span><span class="s6">-&gt;</span><span class="s1">C;</span>
		<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;param</span><span class="s6">-&gt;</span><span class="s1">nr_weight;i++)</span>
		<span class="s1">{</span>
			<span class="s2">for</span><span class="s1">(j=</span><span class="s5">0</span><span class="s1">;j&lt;nr_class;j++)</span>
				<span class="s2">if</span><span class="s1">(param</span><span class="s6">-&gt;</span><span class="s1">weight_label[i] == label[j])</span>
					<span class="s2">break</span><span class="s1">;</span>
			<span class="s2">if</span><span class="s1">(j == nr_class)</span>
				<span class="s1">fprintf(stderr,</span><span class="s3">&quot;WARNING: class label %d specified in weight is not found</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">, param</span><span class="s6">-&gt;</span><span class="s1">weight_label[i]);</span>
			<span class="s2">else</span>
				<span class="s1">weighted_C[j] *= param</span><span class="s6">-&gt;</span><span class="s1">weight[i];</span>
		<span class="s1">}</span>

		<span class="s0">// constructing the subproblem</span>
		<span class="s1">feature_node **x = Malloc(feature_node *,l);</span>
		<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;l;i++)</span>
			<span class="s1">x[i] = prob</span><span class="s6">-&gt;</span><span class="s1">x[perm[i]];</span>

		<span class="s2">int </span><span class="s1">k;</span>
		<span class="s1">problem sub_prob;</span>
		<span class="s1">sub_prob.l = l;</span>
		<span class="s1">sub_prob.n = n;</span>
		<span class="s1">sub_prob.x = Malloc(feature_node *,sub_prob.l);</span>
		<span class="s1">sub_prob.y = Malloc(</span><span class="s2">double</span><span class="s1">,sub_prob.l);</span>
		<span class="s1">sub_prob.W = Malloc(</span><span class="s2">double</span><span class="s1">,sub_prob.l);</span>
		<span class="s2">for</span><span class="s1">(k=</span><span class="s5">0</span><span class="s1">; k&lt;sub_prob.l; k++){</span>
			<span class="s1">sub_prob.x[k] = x[k];</span>
			<span class="s1">sub_prob.W[k] = prob</span><span class="s6">-&gt;</span><span class="s1">W[perm[k]];</span>
		<span class="s1">}</span>

		<span class="s0">// multi-class svm by Crammer and Singer</span>
		<span class="s2">if</span><span class="s1">(param</span><span class="s6">-&gt;</span><span class="s1">solver_type == MCSVM_CS)</span>
		<span class="s1">{</span>
			<span class="s1">model_</span><span class="s6">-&gt;</span><span class="s1">w=Malloc(</span><span class="s2">double</span><span class="s1">, n*nr_class);</span>
			<span class="s1">model_</span><span class="s6">-&gt;</span><span class="s1">n_iter=Malloc(</span><span class="s2">int</span><span class="s1">, </span><span class="s5">1</span><span class="s1">);</span>
			<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;nr_class;i++)</span>
				<span class="s2">for</span><span class="s1">(j=start[i];j&lt;start[i]+count[i];j++)</span>
					<span class="s1">sub_prob.y[j] = i;</span>
			<span class="s1">Solver_MCSVM_CS Solver(&amp;sub_prob, nr_class, weighted_C, param</span><span class="s6">-&gt;</span><span class="s1">eps);</span>
			<span class="s1">model_</span><span class="s6">-&gt;</span><span class="s1">n_iter[</span><span class="s5">0</span><span class="s1">]=Solver.Solve(model_</span><span class="s6">-&gt;</span><span class="s1">w);</span>
		<span class="s1">}</span>
		<span class="s2">else</span>
		<span class="s1">{</span>
			<span class="s2">if</span><span class="s1">(nr_class == </span><span class="s5">2</span><span class="s1">)</span>
			<span class="s1">{</span>
				<span class="s1">model_</span><span class="s6">-&gt;</span><span class="s1">w=Malloc(</span><span class="s2">double</span><span class="s1">, w_size);</span>
				<span class="s1">model_</span><span class="s6">-&gt;</span><span class="s1">n_iter=Malloc(</span><span class="s2">int</span><span class="s1">, </span><span class="s5">1</span><span class="s1">);</span>
				<span class="s2">int </span><span class="s1">e0 = start[</span><span class="s5">0</span><span class="s1">]+count[</span><span class="s5">0</span><span class="s1">];</span>
				<span class="s1">k=</span><span class="s5">0</span><span class="s1">;</span>
				<span class="s2">for</span><span class="s1">(; k&lt;e0; k++)</span>
					<span class="s1">sub_prob.y[k] = -</span><span class="s5">1</span><span class="s1">;</span>
				<span class="s2">for</span><span class="s1">(; k&lt;sub_prob.l; k++)</span>
					<span class="s1">sub_prob.y[k] = +</span><span class="s5">1</span><span class="s1">;</span>

				<span class="s1">model_</span><span class="s6">-&gt;</span><span class="s1">n_iter[</span><span class="s5">0</span><span class="s1">]=train_one(&amp;sub_prob, param, &amp;model_</span><span class="s6">-&gt;</span><span class="s1">w[</span><span class="s5">0</span><span class="s1">], weighted_C[</span><span class="s5">1</span><span class="s1">], weighted_C[</span><span class="s5">0</span><span class="s1">], blas_functions);</span>
			<span class="s1">}</span>
			<span class="s2">else</span>
			<span class="s1">{</span>
				<span class="s1">model_</span><span class="s6">-&gt;</span><span class="s1">w=Malloc(</span><span class="s2">double</span><span class="s1">, w_size*nr_class);</span>
				<span class="s2">double </span><span class="s1">*w=Malloc(</span><span class="s2">double</span><span class="s1">, w_size);</span>
				<span class="s1">model_</span><span class="s6">-&gt;</span><span class="s1">n_iter=Malloc(</span><span class="s2">int</span><span class="s1">, nr_class);</span>
				<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;nr_class;i++)</span>
				<span class="s1">{</span>
					<span class="s2">int </span><span class="s1">si = start[i];</span>
					<span class="s2">int </span><span class="s1">ei = si+count[i];</span>

					<span class="s1">k=</span><span class="s5">0</span><span class="s1">;</span>
					<span class="s2">for</span><span class="s1">(; k&lt;si; k++)</span>
						<span class="s1">sub_prob.y[k] = -</span><span class="s5">1</span><span class="s1">;</span>
					<span class="s2">for</span><span class="s1">(; k&lt;ei; k++)</span>
						<span class="s1">sub_prob.y[k] = +</span><span class="s5">1</span><span class="s1">;</span>
					<span class="s2">for</span><span class="s1">(; k&lt;sub_prob.l; k++)</span>
						<span class="s1">sub_prob.y[k] = -</span><span class="s5">1</span><span class="s1">;</span>

					<span class="s1">model_</span><span class="s6">-&gt;</span><span class="s1">n_iter[i]=train_one(&amp;sub_prob, param, w, weighted_C[i], param</span><span class="s6">-&gt;</span><span class="s1">C, blas_functions);</span>

					<span class="s2">for</span><span class="s1">(</span><span class="s2">int </span><span class="s1">j=</span><span class="s5">0</span><span class="s1">;j&lt;w_size;j++)</span>
						<span class="s1">model_</span><span class="s6">-&gt;</span><span class="s1">w[j*nr_class+i] = w[j];</span>
				<span class="s1">}</span>
				<span class="s1">free(w);</span>
			<span class="s1">}</span>

		<span class="s1">}</span>

		<span class="s1">free(x);</span>
		<span class="s1">free(label);</span>
		<span class="s1">free(start);</span>
		<span class="s1">free(count);</span>
		<span class="s1">free(perm);</span>
		<span class="s1">free(sub_prob.x);</span>
		<span class="s1">free(sub_prob.y);</span>
		<span class="s1">free(sub_prob.W);</span>
		<span class="s1">free(weighted_C);</span>
		<span class="s1">free(newprob.x);</span>
		<span class="s1">free(newprob.y);</span>
		<span class="s1">free(newprob.W);</span>
	<span class="s1">}</span>
	<span class="s2">return </span><span class="s1">model_;</span>
<span class="s1">}</span>

<span class="s2">#if </span><span class="s5">0</span>
<span class="s2">void </span><span class="s1">cross_validation(</span><span class="s2">const </span><span class="s1">problem *prob, </span><span class="s2">const </span><span class="s1">parameter *param, </span><span class="s2">int </span><span class="s1">nr_fold, </span><span class="s2">double </span><span class="s1">*target)</span>
<span class="s1">{</span>
	<span class="s2">int </span><span class="s1">i;</span>
	<span class="s2">int </span><span class="s1">*fold_start;</span>
	<span class="s2">int </span><span class="s1">l = prob</span><span class="s6">-&gt;</span><span class="s1">l;</span>
	<span class="s2">int </span><span class="s1">*perm = Malloc(</span><span class="s2">int</span><span class="s1">,l);</span>
	<span class="s2">if </span><span class="s1">(nr_fold &gt; l)</span>
	<span class="s1">{</span>
		<span class="s1">nr_fold = l;</span>
		<span class="s1">fprintf(stderr,</span><span class="s3">&quot;WARNING: # folds &gt; # data. Will use # folds = # data instead (i.e., leave-one-out cross validation)</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">);</span>
	<span class="s1">}</span>
	<span class="s1">fold_start = Malloc(</span><span class="s2">int</span><span class="s1">,nr_fold+</span><span class="s5">1</span><span class="s1">);</span>
	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;l;i++) perm[i]=i;</span>
	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;l;i++)</span>
	<span class="s1">{</span>
		<span class="s2">int </span><span class="s1">j = i+bounded_rand_int(l-i);</span>
		<span class="s1">swap(perm[i],perm[j]);</span>
	<span class="s1">}</span>
	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;=nr_fold;i++)</span>
		<span class="s1">fold_start[i]=i*l/nr_fold;</span>

	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;nr_fold;i++)</span>
	<span class="s1">{</span>
		<span class="s2">int </span><span class="s1">begin = fold_start[i];</span>
		<span class="s2">int </span><span class="s1">end = fold_start[i+</span><span class="s5">1</span><span class="s1">];</span>
		<span class="s2">int </span><span class="s1">j,k;</span>
		<span class="s2">struct </span><span class="s1">problem subprob;</span>

		<span class="s1">subprob.bias = prob</span><span class="s6">-&gt;</span><span class="s1">bias;</span>
		<span class="s1">subprob.n = prob</span><span class="s6">-&gt;</span><span class="s1">n;</span>
		<span class="s1">subprob.l = l-(end-begin);</span>
		<span class="s1">subprob.x = Malloc(</span><span class="s2">struct </span><span class="s1">feature_node*,subprob.l);</span>
		<span class="s1">subprob.y = Malloc(</span><span class="s2">double</span><span class="s1">,subprob.l);</span>

		<span class="s1">k=</span><span class="s5">0</span><span class="s1">;</span>
		<span class="s2">for</span><span class="s1">(j=</span><span class="s5">0</span><span class="s1">;j&lt;begin;j++)</span>
		<span class="s1">{</span>
			<span class="s1">subprob.x[k] = prob</span><span class="s6">-&gt;</span><span class="s1">x[perm[j]];</span>
			<span class="s1">subprob.y[k] = prob</span><span class="s6">-&gt;</span><span class="s1">y[perm[j]];</span>
			<span class="s1">++k;</span>
		<span class="s1">}</span>
		<span class="s2">for</span><span class="s1">(j=end;j&lt;l;j++)</span>
		<span class="s1">{</span>
			<span class="s1">subprob.x[k] = prob</span><span class="s6">-&gt;</span><span class="s1">x[perm[j]];</span>
			<span class="s1">subprob.y[k] = prob</span><span class="s6">-&gt;</span><span class="s1">y[perm[j]];</span>
			<span class="s1">++k;</span>
		<span class="s1">}</span>
		<span class="s2">struct </span><span class="s1">model *submodel = train(&amp;subprob,param);</span>
		<span class="s2">for</span><span class="s1">(j=begin;j&lt;end;j++)</span>
			<span class="s1">target[perm[j]] = predict(submodel,prob</span><span class="s6">-&gt;</span><span class="s1">x[perm[j]]);</span>
		<span class="s1">free_and_destroy_model(&amp;submodel);</span>
		<span class="s1">free(subprob.x);</span>
		<span class="s1">free(subprob.y);</span>
	<span class="s1">}</span>
	<span class="s1">free(fold_start);</span>
	<span class="s1">free(perm);</span>
<span class="s1">}</span>

<span class="s2">double </span><span class="s1">predict_values(</span><span class="s2">const struct </span><span class="s1">model *model_, </span><span class="s2">const struct </span><span class="s1">feature_node *x, </span><span class="s2">double </span><span class="s1">*dec_values)</span>
<span class="s1">{</span>
	<span class="s2">int </span><span class="s1">idx;</span>
	<span class="s2">int </span><span class="s1">n;</span>
	<span class="s2">if</span><span class="s1">(model_</span><span class="s6">-&gt;</span><span class="s1">bias&gt;=</span><span class="s5">0</span><span class="s1">)</span>
		<span class="s1">n=model_</span><span class="s6">-&gt;</span><span class="s1">nr_feature+</span><span class="s5">1</span><span class="s1">;</span>
	<span class="s2">else</span>
		<span class="s1">n=model_</span><span class="s6">-&gt;</span><span class="s1">nr_feature;</span>
	<span class="s2">double </span><span class="s1">*w=model_</span><span class="s6">-&gt;</span><span class="s1">w;</span>
	<span class="s2">int </span><span class="s1">nr_class=model_</span><span class="s6">-&gt;</span><span class="s1">nr_class;</span>
	<span class="s2">int </span><span class="s1">i;</span>
	<span class="s2">int </span><span class="s1">nr_w;</span>
	<span class="s2">if</span><span class="s1">(nr_class==</span><span class="s5">2 </span><span class="s1">&amp;&amp; model_</span><span class="s6">-&gt;</span><span class="s1">param.solver_type != MCSVM_CS)</span>
		<span class="s1">nr_w = </span><span class="s5">1</span><span class="s1">;</span>
	<span class="s2">else</span>
		<span class="s1">nr_w = nr_class;</span>

	<span class="s2">const </span><span class="s1">feature_node *lx=x;</span>
	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;nr_w;i++)</span>
		<span class="s1">dec_values[i] = </span><span class="s5">0</span><span class="s1">;</span>
	<span class="s2">for</span><span class="s1">(; (idx=lx</span><span class="s6">-&gt;</span><span class="s1">index)!=-</span><span class="s5">1</span><span class="s1">; lx++)</span>
	<span class="s1">{</span>
		<span class="s0">// the dimension of testing data may exceed that of training</span>
		<span class="s2">if</span><span class="s1">(idx&lt;=n)</span>
			<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;nr_w;i++)</span>
				<span class="s1">dec_values[i] += w[(idx-1)*nr_w+i]*lx</span><span class="s6">-&gt;</span><span class="s1">value;</span>
	<span class="s1">}</span>

	<span class="s2">if</span><span class="s1">(nr_class==</span><span class="s5">2</span><span class="s1">)</span>
	<span class="s1">{</span>
		<span class="s2">if</span><span class="s1">(check_regression_model(model_))</span>
			<span class="s2">return </span><span class="s1">dec_values[</span><span class="s5">0</span><span class="s1">];</span>
		<span class="s2">else</span>
			<span class="s2">return </span><span class="s1">(dec_values[</span><span class="s5">0</span><span class="s1">]&gt;</span><span class="s5">0</span><span class="s1">)?model_</span><span class="s6">-&gt;</span><span class="s1">label[</span><span class="s5">0</span><span class="s1">]:model_</span><span class="s6">-&gt;</span><span class="s1">label[</span><span class="s5">1</span><span class="s1">];</span>
	<span class="s1">}</span>
	<span class="s2">else</span>
	<span class="s1">{</span>
		<span class="s2">int </span><span class="s1">dec_max_idx = </span><span class="s5">0</span><span class="s1">;</span>
		<span class="s2">for</span><span class="s1">(i=</span><span class="s5">1</span><span class="s1">;i&lt;nr_class;i++)</span>
		<span class="s1">{</span>
			<span class="s2">if</span><span class="s1">(dec_values[i] &gt; dec_values[dec_max_idx])</span>
				<span class="s1">dec_max_idx = i;</span>
		<span class="s1">}</span>
		<span class="s2">return </span><span class="s1">model_</span><span class="s6">-&gt;</span><span class="s1">label[dec_max_idx];</span>
	<span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">double </span><span class="s1">predict(</span><span class="s2">const </span><span class="s1">model *model_, </span><span class="s2">const </span><span class="s1">feature_node *x)</span>
<span class="s1">{</span>
	<span class="s2">double </span><span class="s1">*dec_values = Malloc(</span><span class="s2">double</span><span class="s1">, model_</span><span class="s6">-&gt;</span><span class="s1">nr_class);</span>
	<span class="s2">double </span><span class="s1">label=predict_values(model_, x, dec_values);</span>
	<span class="s1">free(dec_values);</span>
	<span class="s2">return </span><span class="s1">label;</span>
<span class="s1">}</span>

<span class="s2">double </span><span class="s1">predict_probability(</span><span class="s2">const struct </span><span class="s1">model *model_, </span><span class="s2">const struct </span><span class="s1">feature_node *x, </span><span class="s2">double</span><span class="s1">* prob_estimates)</span>
<span class="s1">{</span>
	<span class="s2">if</span><span class="s1">(check_probability_model(model_))</span>
	<span class="s1">{</span>
		<span class="s2">int </span><span class="s1">i;</span>
		<span class="s2">int </span><span class="s1">nr_class=model_</span><span class="s6">-&gt;</span><span class="s1">nr_class;</span>
		<span class="s2">int </span><span class="s1">nr_w;</span>
		<span class="s2">if</span><span class="s1">(nr_class==</span><span class="s5">2</span><span class="s1">)</span>
			<span class="s1">nr_w = </span><span class="s5">1</span><span class="s1">;</span>
		<span class="s2">else</span>
			<span class="s1">nr_w = nr_class;</span>

		<span class="s2">double </span><span class="s1">label=predict_values(model_, x, prob_estimates);</span>
		<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;nr_w;i++)</span>
			<span class="s1">prob_estimates[i]=</span><span class="s5">1</span><span class="s1">/(</span><span class="s5">1</span><span class="s1">+exp(-prob_estimates[i]));</span>

		<span class="s2">if</span><span class="s1">(nr_class==</span><span class="s5">2</span><span class="s1">) </span><span class="s0">// for binary classification</span>
			<span class="s1">prob_estimates[</span><span class="s5">1</span><span class="s1">]=</span><span class="s5">1</span><span class="s1">.-prob_estimates[</span><span class="s5">0</span><span class="s1">];</span>
		<span class="s2">else</span>
		<span class="s1">{</span>
			<span class="s2">double </span><span class="s1">sum=</span><span class="s5">0</span><span class="s1">;</span>
			<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">; i&lt;nr_class; i++)</span>
				<span class="s1">sum+=prob_estimates[i];</span>

			<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">; i&lt;nr_class; i++)</span>
				<span class="s1">prob_estimates[i]=prob_estimates[i]/sum;</span>
		<span class="s1">}</span>

		<span class="s2">return </span><span class="s1">label;</span>
	<span class="s1">}</span>
	<span class="s2">else</span>
		<span class="s2">return </span><span class="s5">0</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">static const char </span><span class="s1">*solver_type_table[]=</span>
<span class="s1">{</span>
	<span class="s3">&quot;L2R_LR&quot;</span><span class="s1">, </span><span class="s3">&quot;L2R_L2LOSS_SVC_DUAL&quot;</span><span class="s1">, </span><span class="s3">&quot;L2R_L2LOSS_SVC&quot;</span><span class="s1">, </span><span class="s3">&quot;L2R_L1LOSS_SVC_DUAL&quot;</span><span class="s1">, </span><span class="s3">&quot;MCSVM_CS&quot;</span><span class="s1">,</span>
	<span class="s3">&quot;L1R_L2LOSS_SVC&quot;</span><span class="s1">, </span><span class="s3">&quot;L1R_LR&quot;</span><span class="s1">, </span><span class="s3">&quot;L2R_LR_DUAL&quot;</span><span class="s1">,</span>
	<span class="s3">&quot;&quot;</span><span class="s1">, </span><span class="s3">&quot;&quot;</span><span class="s1">, </span><span class="s3">&quot;&quot;</span><span class="s1">,</span>
	<span class="s3">&quot;L2R_L2LOSS_SVR&quot;</span><span class="s1">, </span><span class="s3">&quot;L2R_L2LOSS_SVR_DUAL&quot;</span><span class="s1">, </span><span class="s3">&quot;L2R_L1LOSS_SVR_DUAL&quot;</span><span class="s1">, NULL</span>
<span class="s1">};</span>

<span class="s2">int </span><span class="s1">save_model(</span><span class="s2">const char </span><span class="s1">*model_file_name, </span><span class="s2">const struct </span><span class="s1">model *model_)</span>
<span class="s1">{</span>
	<span class="s2">int </span><span class="s1">i;</span>
	<span class="s2">int </span><span class="s1">nr_feature=model_</span><span class="s6">-&gt;</span><span class="s1">nr_feature;</span>
	<span class="s2">int </span><span class="s1">n;</span>
	<span class="s2">const </span><span class="s1">parameter&amp; param = model_</span><span class="s6">-&gt;</span><span class="s1">param;</span>

	<span class="s2">if</span><span class="s1">(model_</span><span class="s6">-&gt;</span><span class="s1">bias&gt;=</span><span class="s5">0</span><span class="s1">)</span>
		<span class="s1">n=nr_feature+</span><span class="s5">1</span><span class="s1">;</span>
	<span class="s2">else</span>
		<span class="s1">n=nr_feature;</span>
	<span class="s2">int </span><span class="s1">w_size = n;</span>
	<span class="s1">FILE *fp = fopen(model_file_name,</span><span class="s3">&quot;w&quot;</span><span class="s1">);</span>
	<span class="s2">if</span><span class="s1">(fp==NULL) </span><span class="s2">return </span><span class="s1">-</span><span class="s5">1</span><span class="s1">;</span>

	<span class="s2">char </span><span class="s1">*old_locale = strdup(setlocale(LC_ALL, NULL));</span>
	<span class="s1">setlocale(LC_ALL, </span><span class="s3">&quot;C&quot;</span><span class="s1">);</span>

	<span class="s2">int </span><span class="s1">nr_w;</span>
	<span class="s2">if</span><span class="s1">(model_</span><span class="s6">-&gt;</span><span class="s1">nr_class==</span><span class="s5">2 </span><span class="s1">&amp;&amp; model_</span><span class="s6">-&gt;</span><span class="s1">param.solver_type != MCSVM_CS)</span>
		<span class="s1">nr_w=</span><span class="s5">1</span><span class="s1">;</span>
	<span class="s2">else</span>
		<span class="s1">nr_w=model_</span><span class="s6">-&gt;</span><span class="s1">nr_class;</span>

	<span class="s1">fprintf(fp, </span><span class="s3">&quot;solver_type %s</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">, solver_type_table[param.solver_type]);</span>
	<span class="s1">fprintf(fp, </span><span class="s3">&quot;nr_class %d</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">, model_</span><span class="s6">-&gt;</span><span class="s1">nr_class);</span>

	<span class="s2">if</span><span class="s1">(model_</span><span class="s6">-&gt;</span><span class="s1">label)</span>
	<span class="s1">{</span>
		<span class="s1">fprintf(fp, </span><span class="s3">&quot;label&quot;</span><span class="s1">);</span>
		<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">; i&lt;model_</span><span class="s6">-&gt;</span><span class="s1">nr_class; i++)</span>
			<span class="s1">fprintf(fp, </span><span class="s3">&quot; %d&quot;</span><span class="s1">, model_</span><span class="s6">-&gt;</span><span class="s1">label[i]);</span>
		<span class="s1">fprintf(fp, </span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">);</span>
	<span class="s1">}</span>

	<span class="s1">fprintf(fp, </span><span class="s3">&quot;nr_feature %d</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">, nr_feature);</span>

	<span class="s1">fprintf(fp, </span><span class="s3">&quot;bias %.16g</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">, model_</span><span class="s6">-&gt;</span><span class="s1">bias);</span>

	<span class="s1">fprintf(fp, </span><span class="s3">&quot;w</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">);</span>
	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">; i&lt;w_size; i++)</span>
	<span class="s1">{</span>
		<span class="s2">int </span><span class="s1">j;</span>
		<span class="s2">for</span><span class="s1">(j=</span><span class="s5">0</span><span class="s1">; j&lt;nr_w; j++)</span>
			<span class="s1">fprintf(fp, </span><span class="s3">&quot;%.16g &quot;</span><span class="s1">, model_</span><span class="s6">-&gt;</span><span class="s1">w[i*nr_w+j]);</span>
		<span class="s1">fprintf(fp, </span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">);</span>
	<span class="s1">}</span>

	<span class="s1">setlocale(LC_ALL, old_locale);</span>
	<span class="s1">free(old_locale);</span>

	<span class="s2">if </span><span class="s1">(ferror(fp) != </span><span class="s5">0 </span><span class="s1">|| fclose(fp) != </span><span class="s5">0</span><span class="s1">) </span><span class="s2">return </span><span class="s1">-</span><span class="s5">1</span><span class="s1">;</span>
	<span class="s2">else return </span><span class="s5">0</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">struct </span><span class="s1">model *load_model(</span><span class="s2">const char </span><span class="s1">*model_file_name)</span>
<span class="s1">{</span>
	<span class="s1">FILE *fp = fopen(model_file_name,</span><span class="s3">&quot;r&quot;</span><span class="s1">);</span>
	<span class="s2">if</span><span class="s1">(fp==NULL) </span><span class="s2">return </span><span class="s1">NULL;</span>

	<span class="s2">int </span><span class="s1">i;</span>
	<span class="s2">int </span><span class="s1">nr_feature;</span>
	<span class="s2">int </span><span class="s1">n;</span>
	<span class="s2">int </span><span class="s1">nr_class;</span>
	<span class="s2">double </span><span class="s1">bias;</span>
	<span class="s1">model *model_ = Malloc(model,</span><span class="s5">1</span><span class="s1">);</span>
	<span class="s1">parameter&amp; param = model_</span><span class="s6">-&gt;</span><span class="s1">param;</span>

	<span class="s1">model_</span><span class="s6">-&gt;</span><span class="s1">label = NULL;</span>

	<span class="s2">char </span><span class="s1">*old_locale = strdup(setlocale(LC_ALL, NULL));</span>
	<span class="s1">setlocale(LC_ALL, </span><span class="s3">&quot;C&quot;</span><span class="s1">);</span>

	<span class="s2">char </span><span class="s1">cmd[</span><span class="s5">81</span><span class="s1">];</span>
	<span class="s2">while</span><span class="s1">(</span><span class="s5">1</span><span class="s1">)</span>
	<span class="s1">{</span>
		<span class="s1">fscanf(fp,</span><span class="s3">&quot;%80s&quot;</span><span class="s1">,cmd);</span>
		<span class="s2">if</span><span class="s1">(strcmp(cmd,</span><span class="s3">&quot;solver_type&quot;</span><span class="s1">)==</span><span class="s5">0</span><span class="s1">)</span>
		<span class="s1">{</span>
			<span class="s1">fscanf(fp,</span><span class="s3">&quot;%80s&quot;</span><span class="s1">,cmd);</span>
			<span class="s2">int </span><span class="s1">i;</span>
			<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;solver_type_table[i];i++)</span>
			<span class="s1">{</span>
				<span class="s2">if</span><span class="s1">(strcmp(solver_type_table[i],cmd)==</span><span class="s5">0</span><span class="s1">)</span>
				<span class="s1">{</span>
					<span class="s1">param.solver_type=i;</span>
					<span class="s2">break</span><span class="s1">;</span>
				<span class="s1">}</span>
			<span class="s1">}</span>
			<span class="s2">if</span><span class="s1">(solver_type_table[i] == NULL)</span>
			<span class="s1">{</span>
				<span class="s1">fprintf(stderr,</span><span class="s3">&quot;unknown solver type.</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">);</span>

				<span class="s1">setlocale(LC_ALL, old_locale);</span>
				<span class="s1">free(model_</span><span class="s6">-&gt;</span><span class="s1">label);</span>
				<span class="s1">free(model_);</span>
				<span class="s1">free(old_locale);</span>
				<span class="s2">return </span><span class="s1">NULL;</span>
			<span class="s1">}</span>
		<span class="s1">}</span>
		<span class="s2">else if</span><span class="s1">(strcmp(cmd,</span><span class="s3">&quot;nr_class&quot;</span><span class="s1">)==</span><span class="s5">0</span><span class="s1">)</span>
		<span class="s1">{</span>
			<span class="s1">fscanf(fp,</span><span class="s3">&quot;%d&quot;</span><span class="s1">,&amp;nr_class);</span>
			<span class="s1">model_</span><span class="s6">-&gt;</span><span class="s1">nr_class=nr_class;</span>
		<span class="s1">}</span>
		<span class="s2">else if</span><span class="s1">(strcmp(cmd,</span><span class="s3">&quot;nr_feature&quot;</span><span class="s1">)==</span><span class="s5">0</span><span class="s1">)</span>
		<span class="s1">{</span>
			<span class="s1">fscanf(fp,</span><span class="s3">&quot;%d&quot;</span><span class="s1">,&amp;nr_feature);</span>
			<span class="s1">model_</span><span class="s6">-&gt;</span><span class="s1">nr_feature=nr_feature;</span>
		<span class="s1">}</span>
		<span class="s2">else if</span><span class="s1">(strcmp(cmd,</span><span class="s3">&quot;bias&quot;</span><span class="s1">)==</span><span class="s5">0</span><span class="s1">)</span>
		<span class="s1">{</span>
			<span class="s1">fscanf(fp,</span><span class="s3">&quot;%lf&quot;</span><span class="s1">,&amp;bias);</span>
			<span class="s1">model_</span><span class="s6">-&gt;</span><span class="s1">bias=bias;</span>
		<span class="s1">}</span>
		<span class="s2">else if</span><span class="s1">(strcmp(cmd,</span><span class="s3">&quot;w&quot;</span><span class="s1">)==</span><span class="s5">0</span><span class="s1">)</span>
		<span class="s1">{</span>
			<span class="s2">break</span><span class="s1">;</span>
		<span class="s1">}</span>
		<span class="s2">else if</span><span class="s1">(strcmp(cmd,</span><span class="s3">&quot;label&quot;</span><span class="s1">)==</span><span class="s5">0</span><span class="s1">)</span>
		<span class="s1">{</span>
			<span class="s2">int </span><span class="s1">nr_class = model_</span><span class="s6">-&gt;</span><span class="s1">nr_class;</span>
			<span class="s1">model_</span><span class="s6">-&gt;</span><span class="s1">label = Malloc(</span><span class="s2">int</span><span class="s1">,nr_class);</span>
			<span class="s2">for</span><span class="s1">(</span><span class="s2">int </span><span class="s1">i=</span><span class="s5">0</span><span class="s1">;i&lt;nr_class;i++)</span>
				<span class="s1">fscanf(fp,</span><span class="s3">&quot;%d&quot;</span><span class="s1">,&amp;model_</span><span class="s6">-&gt;</span><span class="s1">label[i]);</span>
		<span class="s1">}</span>
		<span class="s2">else</span>
		<span class="s1">{</span>
			<span class="s1">fprintf(stderr,</span><span class="s3">&quot;unknown text in model file: [%s]</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">,cmd);</span>
			<span class="s1">setlocale(LC_ALL, old_locale);</span>
			<span class="s1">free(model_</span><span class="s6">-&gt;</span><span class="s1">label);</span>
			<span class="s1">free(model_);</span>
			<span class="s1">free(old_locale);</span>
			<span class="s2">return </span><span class="s1">NULL;</span>
		<span class="s1">}</span>
	<span class="s1">}</span>

	<span class="s1">nr_feature=model_</span><span class="s6">-&gt;</span><span class="s1">nr_feature;</span>
	<span class="s2">if</span><span class="s1">(model_</span><span class="s6">-&gt;</span><span class="s1">bias&gt;=</span><span class="s5">0</span><span class="s1">)</span>
		<span class="s1">n=nr_feature+</span><span class="s5">1</span><span class="s1">;</span>
	<span class="s2">else</span>
		<span class="s1">n=nr_feature;</span>
	<span class="s2">int </span><span class="s1">w_size = n;</span>
	<span class="s2">int </span><span class="s1">nr_w;</span>
	<span class="s2">if</span><span class="s1">(nr_class==</span><span class="s5">2 </span><span class="s1">&amp;&amp; param.solver_type != MCSVM_CS)</span>
		<span class="s1">nr_w = </span><span class="s5">1</span><span class="s1">;</span>
	<span class="s2">else</span>
		<span class="s1">nr_w = nr_class;</span>

	<span class="s1">model_</span><span class="s6">-&gt;</span><span class="s1">w=Malloc(</span><span class="s2">double</span><span class="s1">, w_size*nr_w);</span>
	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">; i&lt;w_size; i++)</span>
	<span class="s1">{</span>
		<span class="s2">int </span><span class="s1">j;</span>
		<span class="s2">for</span><span class="s1">(j=</span><span class="s5">0</span><span class="s1">; j&lt;nr_w; j++)</span>
			<span class="s1">fscanf(fp, </span><span class="s3">&quot;%lf &quot;</span><span class="s1">, &amp;model_</span><span class="s6">-&gt;</span><span class="s1">w[i*nr_w+j]);</span>
		<span class="s1">fscanf(fp, </span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">);</span>
	<span class="s1">}</span>

	<span class="s1">setlocale(LC_ALL, old_locale);</span>
	<span class="s1">free(old_locale);</span>

	<span class="s2">if </span><span class="s1">(ferror(fp) != </span><span class="s5">0 </span><span class="s1">|| fclose(fp) != </span><span class="s5">0</span><span class="s1">) </span><span class="s2">return </span><span class="s1">NULL;</span>

	<span class="s2">return </span><span class="s1">model_;</span>
<span class="s1">}</span>
<span class="s2">#endif</span>

<span class="s2">int </span><span class="s1">get_nr_feature(</span><span class="s2">const </span><span class="s1">model *model_)</span>
<span class="s1">{</span>
	<span class="s2">return </span><span class="s1">model_</span><span class="s6">-&gt;</span><span class="s1">nr_feature;</span>
<span class="s1">}</span>

<span class="s2">int </span><span class="s1">get_nr_class(</span><span class="s2">const </span><span class="s1">model *model_)</span>
<span class="s1">{</span>
	<span class="s2">return </span><span class="s1">model_</span><span class="s6">-&gt;</span><span class="s1">nr_class;</span>
<span class="s1">}</span>

<span class="s2">void </span><span class="s1">get_labels(</span><span class="s2">const </span><span class="s1">model *model_, </span><span class="s2">int</span><span class="s1">* label)</span>
<span class="s1">{</span>
	<span class="s2">if </span><span class="s1">(model_</span><span class="s6">-&gt;</span><span class="s1">label != NULL)</span>
		<span class="s2">for</span><span class="s1">(</span><span class="s2">int </span><span class="s1">i=</span><span class="s5">0</span><span class="s1">;i&lt;model_</span><span class="s6">-&gt;</span><span class="s1">nr_class;i++)</span>
			<span class="s1">label[i] = model_</span><span class="s6">-&gt;</span><span class="s1">label[i];</span>
<span class="s1">}</span>

<span class="s2">void </span><span class="s1">get_n_iter(</span><span class="s2">const </span><span class="s1">model *model_, </span><span class="s2">int</span><span class="s1">* n_iter)</span>
<span class="s1">{</span>
    <span class="s2">int </span><span class="s1">labels;</span>
    <span class="s1">labels = model_</span><span class="s6">-&gt;</span><span class="s1">nr_class;</span>
    <span class="s2">if </span><span class="s1">(labels == </span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">labels = </span><span class="s5">1</span><span class="s1">;</span>

    <span class="s2">if </span><span class="s1">(model_</span><span class="s6">-&gt;</span><span class="s1">n_iter != NULL)</span>
        <span class="s2">for</span><span class="s1">(</span><span class="s2">int </span><span class="s1">i=</span><span class="s5">0</span><span class="s1">;i&lt;labels;i++)</span>
            <span class="s1">n_iter[i] = model_</span><span class="s6">-&gt;</span><span class="s1">n_iter[i];</span>
<span class="s1">}</span>

<span class="s2">#if </span><span class="s5">0</span>
<span class="s0">// use inline here for better performance (around 20% faster than the non-inline one)</span>
<span class="s2">static </span><span class="s4">inline </span><span class="s2">double </span><span class="s1">get_w_value(</span><span class="s2">const struct </span><span class="s1">model *model_, </span><span class="s2">int </span><span class="s1">idx, </span><span class="s2">int </span><span class="s1">label_idx)</span>
<span class="s1">{</span>
	<span class="s2">int </span><span class="s1">nr_class = model_</span><span class="s6">-&gt;</span><span class="s1">nr_class;</span>
	<span class="s2">int </span><span class="s1">solver_type = model_</span><span class="s6">-&gt;</span><span class="s1">param.solver_type;</span>
	<span class="s2">const double </span><span class="s1">*w = model_</span><span class="s6">-&gt;</span><span class="s1">w;</span>

	<span class="s2">if</span><span class="s1">(idx &lt; </span><span class="s5">0 </span><span class="s1">|| idx &gt; model_</span><span class="s6">-&gt;</span><span class="s1">nr_feature)</span>
		<span class="s2">return </span><span class="s5">0</span><span class="s1">;</span>
	<span class="s2">if</span><span class="s1">(check_regression_model(model_))</span>
		<span class="s2">return </span><span class="s1">w[idx];</span>
	<span class="s2">else</span>
	<span class="s1">{</span>
		<span class="s2">if</span><span class="s1">(label_idx &lt; </span><span class="s5">0 </span><span class="s1">|| label_idx &gt;= nr_class)</span>
			<span class="s2">return </span><span class="s5">0</span><span class="s1">;</span>
		<span class="s2">if</span><span class="s1">(nr_class == </span><span class="s5">2 </span><span class="s1">&amp;&amp; solver_type != MCSVM_CS)</span>
		<span class="s1">{</span>
			<span class="s2">if</span><span class="s1">(label_idx == </span><span class="s5">0</span><span class="s1">)</span>
				<span class="s2">return </span><span class="s1">w[idx];</span>
			<span class="s2">else</span>
				<span class="s2">return </span><span class="s1">-w[idx];</span>
		<span class="s1">}</span>
		<span class="s2">else</span>
			<span class="s2">return </span><span class="s1">w[idx*nr_class+label_idx];</span>
	<span class="s1">}</span>
<span class="s1">}</span>

<span class="s0">// feat_idx: starting from 1 to nr_feature</span>
<span class="s0">// label_idx: starting from 0 to nr_class-1 for classification models;</span>
<span class="s0">//            for regression models, label_idx is ignored.</span>
<span class="s2">double </span><span class="s1">get_decfun_coef(</span><span class="s2">const struct </span><span class="s1">model *model_, </span><span class="s2">int </span><span class="s1">feat_idx, </span><span class="s2">int </span><span class="s1">label_idx)</span>
<span class="s1">{</span>
	<span class="s2">if</span><span class="s1">(feat_idx &gt; model_</span><span class="s6">-&gt;</span><span class="s1">nr_feature)</span>
		<span class="s2">return </span><span class="s5">0</span><span class="s1">;</span>
	<span class="s2">return </span><span class="s1">get_w_value(model_, feat_idx-1, label_idx);</span>
<span class="s1">}</span>

<span class="s2">double </span><span class="s1">get_decfun_bias(</span><span class="s2">const struct </span><span class="s1">model *model_, </span><span class="s2">int </span><span class="s1">label_idx)</span>
<span class="s1">{</span>
	<span class="s2">int </span><span class="s1">bias_idx = model_</span><span class="s6">-&gt;</span><span class="s1">nr_feature;</span>
	<span class="s2">double </span><span class="s1">bias = model_</span><span class="s6">-&gt;</span><span class="s1">bias;</span>
	<span class="s2">if</span><span class="s1">(bias &lt;= </span><span class="s5">0</span><span class="s1">)</span>
		<span class="s2">return </span><span class="s5">0</span><span class="s1">;</span>
	<span class="s2">else</span>
		<span class="s2">return </span><span class="s1">bias*get_w_value(model_, bias_idx, label_idx);</span>
<span class="s1">}</span>
<span class="s2">#endif</span>

<span class="s2">void </span><span class="s1">free_model_content(</span><span class="s2">struct </span><span class="s1">model *model_ptr)</span>
<span class="s1">{</span>
	<span class="s2">if</span><span class="s1">(model_ptr</span><span class="s6">-&gt;</span><span class="s1">w != NULL)</span>
		<span class="s1">free(model_ptr</span><span class="s6">-&gt;</span><span class="s1">w);</span>
	<span class="s2">if</span><span class="s1">(model_ptr</span><span class="s6">-&gt;</span><span class="s1">label != NULL)</span>
		<span class="s1">free(model_ptr</span><span class="s6">-&gt;</span><span class="s1">label);</span>
	<span class="s2">if</span><span class="s1">(model_ptr</span><span class="s6">-&gt;</span><span class="s1">n_iter != NULL)</span>
	    <span class="s1">free(model_ptr</span><span class="s6">-&gt;</span><span class="s1">n_iter);</span>
<span class="s1">}</span>

<span class="s2">void </span><span class="s1">free_and_destroy_model(</span><span class="s2">struct </span><span class="s1">model **model_ptr_ptr)</span>
<span class="s1">{</span>
	<span class="s2">struct </span><span class="s1">model *model_ptr = *model_ptr_ptr;</span>
	<span class="s2">if</span><span class="s1">(model_ptr != NULL)</span>
	<span class="s1">{</span>
		<span class="s1">free_model_content(model_ptr);</span>
		<span class="s1">free(model_ptr);</span>
	<span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">void </span><span class="s1">destroy_param(parameter* param)</span>
<span class="s1">{</span>
	<span class="s2">if</span><span class="s1">(param</span><span class="s6">-&gt;</span><span class="s1">weight_label != NULL)</span>
		<span class="s1">free(param</span><span class="s6">-&gt;</span><span class="s1">weight_label);</span>
	<span class="s2">if</span><span class="s1">(param</span><span class="s6">-&gt;</span><span class="s1">weight != NULL)</span>
		<span class="s1">free(param</span><span class="s6">-&gt;</span><span class="s1">weight);</span>
<span class="s1">}</span>

<span class="s2">const char </span><span class="s1">*check_parameter(</span><span class="s2">const </span><span class="s1">problem *prob, </span><span class="s2">const </span><span class="s1">parameter *param)</span>
<span class="s1">{</span>
	<span class="s2">if</span><span class="s1">(param</span><span class="s6">-&gt;</span><span class="s1">eps &lt;= </span><span class="s5">0</span><span class="s1">)</span>
		<span class="s2">return </span><span class="s3">&quot;eps &lt;= 0&quot;</span><span class="s1">;</span>

	<span class="s2">if</span><span class="s1">(param</span><span class="s6">-&gt;</span><span class="s1">C &lt;= </span><span class="s5">0</span><span class="s1">)</span>
		<span class="s2">return </span><span class="s3">&quot;C &lt;= 0&quot;</span><span class="s1">;</span>

	<span class="s2">if</span><span class="s1">(param</span><span class="s6">-&gt;</span><span class="s1">p &lt; </span><span class="s5">0</span><span class="s1">)</span>
		<span class="s2">return </span><span class="s3">&quot;p &lt; 0&quot;</span><span class="s1">;</span>

	<span class="s2">if</span><span class="s1">(param</span><span class="s6">-&gt;</span><span class="s1">solver_type != L2R_LR</span>
		<span class="s1">&amp;&amp; param</span><span class="s6">-&gt;</span><span class="s1">solver_type != L2R_L2LOSS_SVC_DUAL</span>
		<span class="s1">&amp;&amp; param</span><span class="s6">-&gt;</span><span class="s1">solver_type != L2R_L2LOSS_SVC</span>
		<span class="s1">&amp;&amp; param</span><span class="s6">-&gt;</span><span class="s1">solver_type != L2R_L1LOSS_SVC_DUAL</span>
		<span class="s1">&amp;&amp; param</span><span class="s6">-&gt;</span><span class="s1">solver_type != MCSVM_CS</span>
		<span class="s1">&amp;&amp; param</span><span class="s6">-&gt;</span><span class="s1">solver_type != L1R_L2LOSS_SVC</span>
		<span class="s1">&amp;&amp; param</span><span class="s6">-&gt;</span><span class="s1">solver_type != L1R_LR</span>
		<span class="s1">&amp;&amp; param</span><span class="s6">-&gt;</span><span class="s1">solver_type != L2R_LR_DUAL</span>
		<span class="s1">&amp;&amp; param</span><span class="s6">-&gt;</span><span class="s1">solver_type != L2R_L2LOSS_SVR</span>
		<span class="s1">&amp;&amp; param</span><span class="s6">-&gt;</span><span class="s1">solver_type != L2R_L2LOSS_SVR_DUAL</span>
		<span class="s1">&amp;&amp; param</span><span class="s6">-&gt;</span><span class="s1">solver_type != L2R_L1LOSS_SVR_DUAL)</span>
		<span class="s2">return </span><span class="s3">&quot;unknown solver type&quot;</span><span class="s1">;</span>

	<span class="s2">return </span><span class="s1">NULL;</span>
<span class="s1">}</span>

<span class="s2">#if </span><span class="s5">0</span>
<span class="s2">int </span><span class="s1">check_probability_model(</span><span class="s2">const struct </span><span class="s1">model *model_)</span>
<span class="s1">{</span>
	<span class="s2">return </span><span class="s1">(model_</span><span class="s6">-&gt;</span><span class="s1">param.solver_type==L2R_LR ||</span>
			<span class="s1">model_</span><span class="s6">-&gt;</span><span class="s1">param.solver_type==L2R_LR_DUAL ||</span>
			<span class="s1">model_</span><span class="s6">-&gt;</span><span class="s1">param.solver_type==L1R_LR);</span>
<span class="s1">}</span>
<span class="s2">#endif</span>

<span class="s2">int </span><span class="s1">check_regression_model(</span><span class="s2">const struct </span><span class="s1">model *model_)</span>
<span class="s1">{</span>
	<span class="s2">return </span><span class="s1">(model_</span><span class="s6">-&gt;</span><span class="s1">param.solver_type==L2R_L2LOSS_SVR ||</span>
			<span class="s1">model_</span><span class="s6">-&gt;</span><span class="s1">param.solver_type==L2R_L1LOSS_SVR_DUAL ||</span>
			<span class="s1">model_</span><span class="s6">-&gt;</span><span class="s1">param.solver_type==L2R_L2LOSS_SVR_DUAL);</span>
<span class="s1">}</span>

<span class="s2">void </span><span class="s1">set_print_string_function(</span><span class="s2">void </span><span class="s1">(*print_func)(</span><span class="s2">const char</span><span class="s1">*))</span>
<span class="s1">{</span>
	<span class="s2">if </span><span class="s1">(print_func == NULL)</span>
		<span class="s1">liblinear_print_string = &amp;print_string_stdout;</span>
	<span class="s2">else</span>
		<span class="s1">liblinear_print_string = print_func;</span>
<span class="s1">}</span>
</pre>
</body>
</html>