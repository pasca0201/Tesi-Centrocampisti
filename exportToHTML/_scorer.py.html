<html>
<head>
<title>_scorer.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #7a7e85;}
.s3 { color: #cf8e6d;}
.s4 { color: #bcbec4;}
.s5 { color: #6aab73;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_scorer.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
The :mod:`sklearn.metrics.scorer` submodule implements a flexible 
interface for model selection and evaluation using 
arbitrary score functions. 
 
A scorer object is a callable that can be passed to 
:class:`~sklearn.model_selection.GridSearchCV` or 
:func:`sklearn.model_selection.cross_val_score` as the ``scoring`` 
parameter, to specify how a model should be evaluated. 
 
The signature of the call is ``(estimator, X, y)`` where ``estimator`` 
is the model to be evaluated, ``X`` is the test data and ``y`` is the 
ground truth labeling (or ``None`` in the case of unsupervised models). 
&quot;&quot;&quot;</span>

<span class="s2"># Authors: Andreas Mueller &lt;amueller@ais.uni-bonn.de&gt;</span>
<span class="s2">#          Lars Buitinck</span>
<span class="s2">#          Arnaud Joly &lt;arnaud.v.joly@gmail.com&gt;</span>
<span class="s2"># License: Simplified BSD</span>

<span class="s3">import </span><span class="s1">copy</span>
<span class="s3">import </span><span class="s1">warnings</span>
<span class="s3">from </span><span class="s1">collections </span><span class="s3">import </span><span class="s1">Counter</span>
<span class="s3">from </span><span class="s1">functools </span><span class="s3">import </span><span class="s1">partial</span>
<span class="s3">from </span><span class="s1">inspect </span><span class="s3">import </span><span class="s1">signature</span>
<span class="s3">from </span><span class="s1">traceback </span><span class="s3">import </span><span class="s1">format_exc</span>

<span class="s3">from </span><span class="s4">..</span><span class="s1">base </span><span class="s3">import </span><span class="s1">is_regressor</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">utils </span><span class="s3">import </span><span class="s1">Bunch</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">utils</span><span class="s4">.</span><span class="s1">_param_validation </span><span class="s3">import </span><span class="s1">HasMethods</span><span class="s4">, </span><span class="s1">Hidden</span><span class="s4">, </span><span class="s1">StrOptions</span><span class="s4">, </span><span class="s1">validate_params</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">utils</span><span class="s4">.</span><span class="s1">_response </span><span class="s3">import </span><span class="s1">_get_response_values</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">utils</span><span class="s4">.</span><span class="s1">metadata_routing </span><span class="s3">import </span><span class="s4">(</span>
    <span class="s1">MetadataRequest</span><span class="s4">,</span>
    <span class="s1">MetadataRouter</span><span class="s4">,</span>
    <span class="s1">MethodMapping</span><span class="s4">,</span>
    <span class="s1">_MetadataRequester</span><span class="s4">,</span>
    <span class="s1">_raise_for_params</span><span class="s4">,</span>
    <span class="s1">_routing_enabled</span><span class="s4">,</span>
    <span class="s1">get_routing_for_object</span><span class="s4">,</span>
    <span class="s1">process_routing</span><span class="s4">,</span>
<span class="s4">)</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">utils</span><span class="s4">.</span><span class="s1">validation </span><span class="s3">import </span><span class="s1">_check_response_method</span>
<span class="s3">from </span><span class="s4">. </span><span class="s3">import </span><span class="s4">(</span>
    <span class="s1">accuracy_score</span><span class="s4">,</span>
    <span class="s1">average_precision_score</span><span class="s4">,</span>
    <span class="s1">balanced_accuracy_score</span><span class="s4">,</span>
    <span class="s1">brier_score_loss</span><span class="s4">,</span>
    <span class="s1">class_likelihood_ratios</span><span class="s4">,</span>
    <span class="s1">d2_absolute_error_score</span><span class="s4">,</span>
    <span class="s1">explained_variance_score</span><span class="s4">,</span>
    <span class="s1">f1_score</span><span class="s4">,</span>
    <span class="s1">jaccard_score</span><span class="s4">,</span>
    <span class="s1">log_loss</span><span class="s4">,</span>
    <span class="s1">matthews_corrcoef</span><span class="s4">,</span>
    <span class="s1">max_error</span><span class="s4">,</span>
    <span class="s1">mean_absolute_error</span><span class="s4">,</span>
    <span class="s1">mean_absolute_percentage_error</span><span class="s4">,</span>
    <span class="s1">mean_gamma_deviance</span><span class="s4">,</span>
    <span class="s1">mean_poisson_deviance</span><span class="s4">,</span>
    <span class="s1">mean_squared_error</span><span class="s4">,</span>
    <span class="s1">mean_squared_log_error</span><span class="s4">,</span>
    <span class="s1">median_absolute_error</span><span class="s4">,</span>
    <span class="s1">precision_score</span><span class="s4">,</span>
    <span class="s1">r2_score</span><span class="s4">,</span>
    <span class="s1">recall_score</span><span class="s4">,</span>
    <span class="s1">roc_auc_score</span><span class="s4">,</span>
    <span class="s1">root_mean_squared_error</span><span class="s4">,</span>
    <span class="s1">root_mean_squared_log_error</span><span class="s4">,</span>
    <span class="s1">top_k_accuracy_score</span><span class="s4">,</span>
<span class="s4">)</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">cluster </span><span class="s3">import </span><span class="s4">(</span>
    <span class="s1">adjusted_mutual_info_score</span><span class="s4">,</span>
    <span class="s1">adjusted_rand_score</span><span class="s4">,</span>
    <span class="s1">completeness_score</span><span class="s4">,</span>
    <span class="s1">fowlkes_mallows_score</span><span class="s4">,</span>
    <span class="s1">homogeneity_score</span><span class="s4">,</span>
    <span class="s1">mutual_info_score</span><span class="s4">,</span>
    <span class="s1">normalized_mutual_info_score</span><span class="s4">,</span>
    <span class="s1">rand_score</span><span class="s4">,</span>
    <span class="s1">v_measure_score</span><span class="s4">,</span>
<span class="s4">)</span>


<span class="s3">def </span><span class="s1">_cached_call</span><span class="s4">(</span><span class="s1">cache</span><span class="s4">, </span><span class="s1">estimator</span><span class="s4">, </span><span class="s1">response_method</span><span class="s4">, *</span><span class="s1">args</span><span class="s4">, **</span><span class="s1">kwargs</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Call estimator with method and args and kwargs.&quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">cache </span><span class="s3">is not None and </span><span class="s1">response_method </span><span class="s3">in </span><span class="s1">cache</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">cache</span><span class="s4">[</span><span class="s1">response_method</span><span class="s4">]</span>

    <span class="s1">result</span><span class="s4">, </span><span class="s1">_ </span><span class="s4">= </span><span class="s1">_get_response_values</span><span class="s4">(</span>
        <span class="s1">estimator</span><span class="s4">, *</span><span class="s1">args</span><span class="s4">, </span><span class="s1">response_method</span><span class="s4">=</span><span class="s1">response_method</span><span class="s4">, **</span><span class="s1">kwargs</span>
    <span class="s4">)</span>

    <span class="s3">if </span><span class="s1">cache </span><span class="s3">is not None</span><span class="s4">:</span>
        <span class="s1">cache</span><span class="s4">[</span><span class="s1">response_method</span><span class="s4">] = </span><span class="s1">result</span>

    <span class="s3">return </span><span class="s1">result</span>


<span class="s3">class </span><span class="s1">_MultimetricScorer</span><span class="s4">:</span>
    <span class="s0">&quot;&quot;&quot;Callable for multimetric scoring used to avoid repeated calls 
    to `predict_proba`, `predict`, and `decision_function`. 
 
    `_MultimetricScorer` will return a dictionary of scores corresponding to 
    the scorers in the dictionary. Note that `_MultimetricScorer` can be 
    created with a dictionary with one key  (i.e. only one actual scorer). 
 
    Parameters 
    ---------- 
    scorers : dict 
        Dictionary mapping names to callable scorers. 
 
    raise_exc : bool, default=True 
        Whether to raise the exception in `__call__` or not. If set to `False` 
        a formatted string of the exception details is passed as result of 
        the failing scorer. 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, *, </span><span class="s1">scorers</span><span class="s4">, </span><span class="s1">raise_exc</span><span class="s4">=</span><span class="s3">True</span><span class="s4">):</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_scorers </span><span class="s4">= </span><span class="s1">scorers</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_raise_exc </span><span class="s4">= </span><span class="s1">raise_exc</span>

    <span class="s3">def </span><span class="s1">__call__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">estimator</span><span class="s4">, *</span><span class="s1">args</span><span class="s4">, **</span><span class="s1">kwargs</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Evaluate predicted target values.&quot;&quot;&quot;</span>
        <span class="s1">scores </span><span class="s4">= {}</span>
        <span class="s1">cache </span><span class="s4">= {} </span><span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_use_cache</span><span class="s4">(</span><span class="s1">estimator</span><span class="s4">) </span><span class="s3">else None</span>
        <span class="s1">cached_call </span><span class="s4">= </span><span class="s1">partial</span><span class="s4">(</span><span class="s1">_cached_call</span><span class="s4">, </span><span class="s1">cache</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s1">_routing_enabled</span><span class="s4">():</span>
            <span class="s1">routed_params </span><span class="s4">= </span><span class="s1">process_routing</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s5">&quot;score&quot;</span><span class="s4">, **</span><span class="s1">kwargs</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s2"># they all get the same args, and they all get them all</span>
            <span class="s1">routed_params </span><span class="s4">= </span><span class="s1">Bunch</span><span class="s4">(</span>
                <span class="s4">**{</span><span class="s1">name</span><span class="s4">: </span><span class="s1">Bunch</span><span class="s4">(</span><span class="s1">score</span><span class="s4">=</span><span class="s1">kwargs</span><span class="s4">) </span><span class="s3">for </span><span class="s1">name </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_scorers</span><span class="s4">}</span>
            <span class="s4">)</span>

        <span class="s3">for </span><span class="s1">name</span><span class="s4">, </span><span class="s1">scorer </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_scorers</span><span class="s4">.</span><span class="s1">items</span><span class="s4">():</span>
            <span class="s3">try</span><span class="s4">:</span>
                <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">scorer</span><span class="s4">, </span><span class="s1">_BaseScorer</span><span class="s4">):</span>
                    <span class="s1">score </span><span class="s4">= </span><span class="s1">scorer</span><span class="s4">.</span><span class="s1">_score</span><span class="s4">(</span>
                        <span class="s1">cached_call</span><span class="s4">, </span><span class="s1">estimator</span><span class="s4">, *</span><span class="s1">args</span><span class="s4">, **</span><span class="s1">routed_params</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s1">name</span><span class="s4">).</span><span class="s1">score</span>
                    <span class="s4">)</span>
                <span class="s3">else</span><span class="s4">:</span>
                    <span class="s1">score </span><span class="s4">= </span><span class="s1">scorer</span><span class="s4">(</span><span class="s1">estimator</span><span class="s4">, *</span><span class="s1">args</span><span class="s4">, **</span><span class="s1">routed_params</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s1">name</span><span class="s4">).</span><span class="s1">score</span><span class="s4">)</span>
                <span class="s1">scores</span><span class="s4">[</span><span class="s1">name</span><span class="s4">] = </span><span class="s1">score</span>
            <span class="s3">except </span><span class="s1">Exception </span><span class="s3">as </span><span class="s1">e</span><span class="s4">:</span>
                <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_raise_exc</span><span class="s4">:</span>
                    <span class="s3">raise </span><span class="s1">e</span>
                <span class="s3">else</span><span class="s4">:</span>
                    <span class="s1">scores</span><span class="s4">[</span><span class="s1">name</span><span class="s4">] = </span><span class="s1">format_exc</span><span class="s4">()</span>
        <span class="s3">return </span><span class="s1">scores</span>

    <span class="s3">def </span><span class="s1">__repr__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s1">scorers </span><span class="s4">= </span><span class="s5">&quot;, &quot;</span><span class="s4">.</span><span class="s1">join</span><span class="s4">([</span><span class="s5">f'&quot;</span><span class="s3">{</span><span class="s1">s</span><span class="s3">}</span><span class="s5">&quot;' </span><span class="s3">for </span><span class="s1">s </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_scorers</span><span class="s4">])</span>
        <span class="s3">return </span><span class="s5">f&quot;MultiMetricScorer(</span><span class="s3">{</span><span class="s1">scorers</span><span class="s3">}</span><span class="s5">)&quot;</span>

    <span class="s3">def </span><span class="s1">_use_cache</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">estimator</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Return True if using a cache is beneficial, thus when a response method will 
        be called several time. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_scorers</span><span class="s4">) == </span><span class="s6">1</span><span class="s4">:  </span><span class="s2"># Only one scorer</span>
            <span class="s3">return False</span>

        <span class="s1">counter </span><span class="s4">= </span><span class="s1">Counter</span><span class="s4">(</span>
            <span class="s4">[</span>
                <span class="s1">_check_response_method</span><span class="s4">(</span><span class="s1">estimator</span><span class="s4">, </span><span class="s1">scorer</span><span class="s4">.</span><span class="s1">_response_method</span><span class="s4">).</span><span class="s1">__name__</span>
                <span class="s3">for </span><span class="s1">scorer </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_scorers</span><span class="s4">.</span><span class="s1">values</span><span class="s4">()</span>
                <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">scorer</span><span class="s4">, </span><span class="s1">_BaseScorer</span><span class="s4">)</span>
            <span class="s4">]</span>
        <span class="s4">)</span>
        <span class="s3">if </span><span class="s1">any</span><span class="s4">(</span><span class="s1">val </span><span class="s4">&gt; </span><span class="s6">1 </span><span class="s3">for </span><span class="s1">val </span><span class="s3">in </span><span class="s1">counter</span><span class="s4">.</span><span class="s1">values</span><span class="s4">()):</span>
            <span class="s2"># The exact same response method or iterable of response methods</span>
            <span class="s2"># will be called more than once.</span>
            <span class="s3">return True</span>

        <span class="s3">return False</span>

    <span class="s3">def </span><span class="s1">get_metadata_routing</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Get metadata routing of this object. 
 
        Please check :ref:`User Guide &lt;metadata_routing&gt;` on how the routing 
        mechanism works. 
 
        .. versionadded:: 1.3 
 
        Returns 
        ------- 
        routing : MetadataRouter 
            A :class:`~utils.metadata_routing.MetadataRouter` encapsulating 
            routing information. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">MetadataRouter</span><span class="s4">(</span><span class="s1">owner</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">__class__</span><span class="s4">.</span><span class="s1">__name__</span><span class="s4">).</span><span class="s1">add</span><span class="s4">(</span>
            <span class="s4">**</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_scorers</span><span class="s4">,</span>
            <span class="s1">method_mapping</span><span class="s4">=</span><span class="s1">MethodMapping</span><span class="s4">().</span><span class="s1">add</span><span class="s4">(</span><span class="s1">caller</span><span class="s4">=</span><span class="s5">&quot;score&quot;</span><span class="s4">, </span><span class="s1">callee</span><span class="s4">=</span><span class="s5">&quot;score&quot;</span><span class="s4">),</span>
        <span class="s4">)</span>


<span class="s3">class </span><span class="s1">_BaseScorer</span><span class="s4">(</span><span class="s1">_MetadataRequester</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Base scorer that is used as `scorer(estimator, X, y_true)`. 
 
    Parameters 
    ---------- 
    score_func : callable 
        The score function to use. It will be called as 
        `score_func(y_true, y_pred, **kwargs)`. 
 
    sign : int 
        Either 1 or -1 to returns the score with `sign * score_func(estimator, X, y)`. 
        Thus, `sign` defined if higher scores are better or worse. 
 
    kwargs : dict 
        Additional parameters to pass to the score function. 
 
    response_method : str 
        The method to call on the estimator to get the response values. 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">score_func</span><span class="s4">, </span><span class="s1">sign</span><span class="s4">, </span><span class="s1">kwargs</span><span class="s4">, </span><span class="s1">response_method</span><span class="s4">=</span><span class="s5">&quot;predict&quot;</span><span class="s4">):</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_score_func </span><span class="s4">= </span><span class="s1">score_func</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_sign </span><span class="s4">= </span><span class="s1">sign</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_kwargs </span><span class="s4">= </span><span class="s1">kwargs</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_response_method </span><span class="s4">= </span><span class="s1">response_method</span>

    <span class="s3">def </span><span class="s1">_get_pos_label</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s5">&quot;pos_label&quot; </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_kwargs</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_kwargs</span><span class="s4">[</span><span class="s5">&quot;pos_label&quot;</span><span class="s4">]</span>
        <span class="s1">score_func_params </span><span class="s4">= </span><span class="s1">signature</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_score_func</span><span class="s4">).</span><span class="s1">parameters</span>
        <span class="s3">if </span><span class="s5">&quot;pos_label&quot; </span><span class="s3">in </span><span class="s1">score_func_params</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">score_func_params</span><span class="s4">[</span><span class="s5">&quot;pos_label&quot;</span><span class="s4">].</span><span class="s1">default</span>
        <span class="s3">return None</span>

    <span class="s3">def </span><span class="s1">__repr__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s1">sign_string </span><span class="s4">= </span><span class="s5">&quot;&quot; </span><span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_sign </span><span class="s4">&gt; </span><span class="s6">0 </span><span class="s3">else </span><span class="s5">&quot;, greater_is_better=False&quot;</span>
        <span class="s1">response_method_string </span><span class="s4">= </span><span class="s5">f&quot;, response_method=</span><span class="s3">{</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_response_method</span><span class="s3">!r}</span><span class="s5">&quot;</span>
        <span class="s1">kwargs_string </span><span class="s4">= </span><span class="s5">&quot;&quot;</span><span class="s4">.</span><span class="s1">join</span><span class="s4">([</span><span class="s5">f&quot;, </span><span class="s3">{</span><span class="s1">k</span><span class="s3">}</span><span class="s5">=</span><span class="s3">{</span><span class="s1">v</span><span class="s3">}</span><span class="s5">&quot; </span><span class="s3">for </span><span class="s1">k</span><span class="s4">, </span><span class="s1">v </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_kwargs</span><span class="s4">.</span><span class="s1">items</span><span class="s4">()])</span>

        <span class="s3">return </span><span class="s4">(</span>
            <span class="s5">f&quot;make_scorer(</span><span class="s3">{</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_score_func</span><span class="s4">.</span><span class="s1">__name__</span><span class="s3">}{</span><span class="s1">sign_string</span><span class="s3">}</span><span class="s5">&quot;</span>
            <span class="s5">f&quot;</span><span class="s3">{</span><span class="s1">response_method_string</span><span class="s3">}{</span><span class="s1">kwargs_string</span><span class="s3">}</span><span class="s5">)&quot;</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">__call__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">estimator</span><span class="s4">, </span><span class="s1">X</span><span class="s4">, </span><span class="s1">y_true</span><span class="s4">, </span><span class="s1">sample_weight</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, **</span><span class="s1">kwargs</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Evaluate predicted target values for X relative to y_true. 
 
        Parameters 
        ---------- 
        estimator : object 
            Trained estimator to use for scoring. Must have a predict_proba 
            method; the output of that is used to compute the score. 
 
        X : {array-like, sparse matrix} 
            Test data that will be fed to estimator.predict. 
 
        y_true : array-like 
            Gold standard target values for X. 
 
        sample_weight : array-like of shape (n_samples,), default=None 
            Sample weights. 
 
        **kwargs : dict 
            Other parameters passed to the scorer. Refer to 
            :func:`set_score_request` for more details. 
 
            Only available if `enable_metadata_routing=True`. See the 
            :ref:`User Guide &lt;metadata_routing&gt;`. 
 
            .. versionadded:: 1.3 
 
        Returns 
        ------- 
        score : float 
            Score function applied to prediction of estimator on X. 
        &quot;&quot;&quot;</span>
        <span class="s1">_raise_for_params</span><span class="s4">(</span><span class="s1">kwargs</span><span class="s4">, </span><span class="s1">self</span><span class="s4">, </span><span class="s3">None</span><span class="s4">)</span>

        <span class="s1">_kwargs </span><span class="s4">= </span><span class="s1">copy</span><span class="s4">.</span><span class="s1">deepcopy</span><span class="s4">(</span><span class="s1">kwargs</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">sample_weight </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s1">_kwargs</span><span class="s4">[</span><span class="s5">&quot;sample_weight&quot;</span><span class="s4">] = </span><span class="s1">sample_weight</span>

        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_score</span><span class="s4">(</span><span class="s1">partial</span><span class="s4">(</span><span class="s1">_cached_call</span><span class="s4">, </span><span class="s3">None</span><span class="s4">), </span><span class="s1">estimator</span><span class="s4">, </span><span class="s1">X</span><span class="s4">, </span><span class="s1">y_true</span><span class="s4">, **</span><span class="s1">_kwargs</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_warn_overlap</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">message</span><span class="s4">, </span><span class="s1">kwargs</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Warn if there is any overlap between ``self._kwargs`` and ``kwargs``. 
 
        This method is intended to be used to check for overlap between 
        ``self._kwargs`` and ``kwargs`` passed as metadata. 
        &quot;&quot;&quot;</span>
        <span class="s1">_kwargs </span><span class="s4">= </span><span class="s1">set</span><span class="s4">() </span><span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_kwargs </span><span class="s3">is None else </span><span class="s1">set</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_kwargs</span><span class="s4">.</span><span class="s1">keys</span><span class="s4">())</span>
        <span class="s1">overlap </span><span class="s4">= </span><span class="s1">_kwargs</span><span class="s4">.</span><span class="s1">intersection</span><span class="s4">(</span><span class="s1">kwargs</span><span class="s4">.</span><span class="s1">keys</span><span class="s4">())</span>
        <span class="s3">if </span><span class="s1">overlap</span><span class="s4">:</span>
            <span class="s1">warnings</span><span class="s4">.</span><span class="s1">warn</span><span class="s4">(</span>
                <span class="s5">f&quot;</span><span class="s3">{</span><span class="s1">message</span><span class="s3">} </span><span class="s5">Overlapping parameters are: </span><span class="s3">{</span><span class="s1">overlap</span><span class="s3">}</span><span class="s5">&quot;</span><span class="s4">, </span><span class="s1">UserWarning</span>
            <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">set_score_request</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, **</span><span class="s1">kwargs</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Set requested parameters by the scorer. 
 
        Please see :ref:`User Guide &lt;metadata_routing&gt;` on how the routing 
        mechanism works. 
 
        .. versionadded:: 1.3 
 
        Parameters 
        ---------- 
        kwargs : dict 
            Arguments should be of the form ``param_name=alias``, and `alias` 
            can be one of ``{True, False, None, str}``. 
        &quot;&quot;&quot;</span>
        <span class="s3">if not </span><span class="s1">_routing_enabled</span><span class="s4">():</span>
            <span class="s3">raise </span><span class="s1">RuntimeError</span><span class="s4">(</span>
                <span class="s5">&quot;This method is only available when metadata routing is enabled.&quot;</span>
                <span class="s5">&quot; You can enable it using&quot;</span>
                <span class="s5">&quot; sklearn.set_config(enable_metadata_routing=True).&quot;</span>
            <span class="s4">)</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">_warn_overlap</span><span class="s4">(</span>
            <span class="s1">message</span><span class="s4">=(</span>
                <span class="s5">&quot;You are setting metadata request for parameters which are &quot;</span>
                <span class="s5">&quot;already set as kwargs for this metric. These set values will be &quot;</span>
                <span class="s5">&quot;overridden by passed metadata if provided. Please pass them either &quot;</span>
                <span class="s5">&quot;as metadata or kwargs to `make_scorer`.&quot;</span>
            <span class="s4">),</span>
            <span class="s1">kwargs</span><span class="s4">=</span><span class="s1">kwargs</span><span class="s4">,</span>
        <span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_metadata_request </span><span class="s4">= </span><span class="s1">MetadataRequest</span><span class="s4">(</span><span class="s1">owner</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">__class__</span><span class="s4">.</span><span class="s1">__name__</span><span class="s4">)</span>
        <span class="s3">for </span><span class="s1">param</span><span class="s4">, </span><span class="s1">alias </span><span class="s3">in </span><span class="s1">kwargs</span><span class="s4">.</span><span class="s1">items</span><span class="s4">():</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_metadata_request</span><span class="s4">.</span><span class="s1">score</span><span class="s4">.</span><span class="s1">add_request</span><span class="s4">(</span><span class="s1">param</span><span class="s4">=</span><span class="s1">param</span><span class="s4">, </span><span class="s1">alias</span><span class="s4">=</span><span class="s1">alias</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">self</span>


<span class="s3">class </span><span class="s1">_Scorer</span><span class="s4">(</span><span class="s1">_BaseScorer</span><span class="s4">):</span>
    <span class="s3">def </span><span class="s1">_score</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">method_caller</span><span class="s4">, </span><span class="s1">estimator</span><span class="s4">, </span><span class="s1">X</span><span class="s4">, </span><span class="s1">y_true</span><span class="s4">, **</span><span class="s1">kwargs</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Evaluate the response method of `estimator` on `X` and `y_true`. 
 
        Parameters 
        ---------- 
        method_caller : callable 
            Returns predictions given an estimator, method name, and other 
            arguments, potentially caching results. 
 
        estimator : object 
            Trained estimator to use for scoring. 
 
        X : {array-like, sparse matrix} 
            Test data that will be fed to clf.decision_function or 
            clf.predict_proba. 
 
        y_true : array-like 
            Gold standard target values for X. These must be class labels, 
            not decision function values. 
 
        **kwargs : dict 
            Other parameters passed to the scorer. Refer to 
            :func:`set_score_request` for more details. 
 
        Returns 
        ------- 
        score : float 
            Score function applied to prediction of estimator on X. 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_warn_overlap</span><span class="s4">(</span>
            <span class="s1">message</span><span class="s4">=(</span>
                <span class="s5">&quot;There is an overlap between set kwargs of this scorer instance and&quot;</span>
                <span class="s5">&quot; passed metadata. Please pass them either as kwargs to `make_scorer`&quot;</span>
                <span class="s5">&quot; or metadata, but not both.&quot;</span>
            <span class="s4">),</span>
            <span class="s1">kwargs</span><span class="s4">=</span><span class="s1">kwargs</span><span class="s4">,</span>
        <span class="s4">)</span>

        <span class="s1">pos_label </span><span class="s4">= </span><span class="s3">None if </span><span class="s1">is_regressor</span><span class="s4">(</span><span class="s1">estimator</span><span class="s4">) </span><span class="s3">else </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_get_pos_label</span><span class="s4">()</span>
        <span class="s1">response_method </span><span class="s4">= </span><span class="s1">_check_response_method</span><span class="s4">(</span><span class="s1">estimator</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_response_method</span><span class="s4">)</span>
        <span class="s1">y_pred </span><span class="s4">= </span><span class="s1">method_caller</span><span class="s4">(</span>
            <span class="s1">estimator</span><span class="s4">, </span><span class="s1">response_method</span><span class="s4">.</span><span class="s1">__name__</span><span class="s4">, </span><span class="s1">X</span><span class="s4">, </span><span class="s1">pos_label</span><span class="s4">=</span><span class="s1">pos_label</span>
        <span class="s4">)</span>

        <span class="s1">scoring_kwargs </span><span class="s4">= {**</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_kwargs</span><span class="s4">, **</span><span class="s1">kwargs</span><span class="s4">}</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_sign </span><span class="s4">* </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_score_func</span><span class="s4">(</span><span class="s1">y_true</span><span class="s4">, </span><span class="s1">y_pred</span><span class="s4">, **</span><span class="s1">scoring_kwargs</span><span class="s4">)</span>


<span class="s4">@</span><span class="s1">validate_params</span><span class="s4">(</span>
    <span class="s4">{</span>
        <span class="s5">&quot;scoring&quot;</span><span class="s4">: [</span><span class="s1">str</span><span class="s4">, </span><span class="s1">callable</span><span class="s4">, </span><span class="s3">None</span><span class="s4">],</span>
    <span class="s4">},</span>
    <span class="s1">prefer_skip_nested_validation</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
<span class="s4">)</span>
<span class="s3">def </span><span class="s1">get_scorer</span><span class="s4">(</span><span class="s1">scoring</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Get a scorer from string. 
 
    Read more in the :ref:`User Guide &lt;scoring_parameter&gt;`. 
    :func:`~sklearn.metrics.get_scorer_names` can be used to retrieve the names 
    of all available scorers. 
 
    Parameters 
    ---------- 
    scoring : str, callable or None 
        Scoring method as string. If callable it is returned as is. 
        If None, returns None. 
 
    Returns 
    ------- 
    scorer : callable 
        The scorer. 
 
    Notes 
    ----- 
    When passed a string, this function always returns a copy of the scorer 
    object. Calling `get_scorer` twice for the same scorer results in two 
    separate scorer objects. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from sklearn.dummy import DummyClassifier 
    &gt;&gt;&gt; from sklearn.metrics import get_scorer 
    &gt;&gt;&gt; X = np.reshape([0, 1, -1, -0.5, 2], (-1, 1)) 
    &gt;&gt;&gt; y = np.array([0, 1, 1, 0, 1]) 
    &gt;&gt;&gt; classifier = DummyClassifier(strategy=&quot;constant&quot;, constant=0).fit(X, y) 
    &gt;&gt;&gt; accuracy = get_scorer(&quot;accuracy&quot;) 
    &gt;&gt;&gt; accuracy(classifier, X, y) 
    0.4 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">scoring</span><span class="s4">, </span><span class="s1">str</span><span class="s4">):</span>
        <span class="s3">try</span><span class="s4">:</span>
            <span class="s1">scorer </span><span class="s4">= </span><span class="s1">copy</span><span class="s4">.</span><span class="s1">deepcopy</span><span class="s4">(</span><span class="s1">_SCORERS</span><span class="s4">[</span><span class="s1">scoring</span><span class="s4">])</span>
        <span class="s3">except </span><span class="s1">KeyError</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span>
                <span class="s5">&quot;%r is not a valid scoring value. &quot;</span>
                <span class="s5">&quot;Use sklearn.metrics.get_scorer_names() &quot;</span>
                <span class="s5">&quot;to get valid options.&quot; </span><span class="s4">% </span><span class="s1">scoring</span>
            <span class="s4">)</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">scorer </span><span class="s4">= </span><span class="s1">scoring</span>
    <span class="s3">return </span><span class="s1">scorer</span>


<span class="s3">class </span><span class="s1">_PassthroughScorer</span><span class="s4">(</span><span class="s1">_MetadataRequester</span><span class="s4">):</span>
    <span class="s2"># Passes scoring of estimator's `score` method back to estimator if scoring</span>
    <span class="s2"># is `None`.</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">estimator</span><span class="s4">):</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_estimator </span><span class="s4">= </span><span class="s1">estimator</span>

        <span class="s1">requests </span><span class="s4">= </span><span class="s1">MetadataRequest</span><span class="s4">(</span><span class="s1">owner</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">__class__</span><span class="s4">.</span><span class="s1">__name__</span><span class="s4">)</span>
        <span class="s3">try</span><span class="s4">:</span>
            <span class="s1">requests</span><span class="s4">.</span><span class="s1">score </span><span class="s4">= </span><span class="s1">copy</span><span class="s4">.</span><span class="s1">deepcopy</span><span class="s4">(</span><span class="s1">estimator</span><span class="s4">.</span><span class="s1">_metadata_request</span><span class="s4">.</span><span class="s1">score</span><span class="s4">)</span>
        <span class="s3">except </span><span class="s1">AttributeError</span><span class="s4">:</span>
            <span class="s3">try</span><span class="s4">:</span>
                <span class="s1">requests</span><span class="s4">.</span><span class="s1">score </span><span class="s4">= </span><span class="s1">copy</span><span class="s4">.</span><span class="s1">deepcopy</span><span class="s4">(</span><span class="s1">estimator</span><span class="s4">.</span><span class="s1">_get_default_requests</span><span class="s4">().</span><span class="s1">score</span><span class="s4">)</span>
            <span class="s3">except </span><span class="s1">AttributeError</span><span class="s4">:</span>
                <span class="s3">pass</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">_metadata_request </span><span class="s4">= </span><span class="s1">requests</span>

    <span class="s3">def </span><span class="s1">__call__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">estimator</span><span class="s4">, *</span><span class="s1">args</span><span class="s4">, **</span><span class="s1">kwargs</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Method that wraps estimator.score&quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">estimator</span><span class="s4">.</span><span class="s1">score</span><span class="s4">(*</span><span class="s1">args</span><span class="s4">, **</span><span class="s1">kwargs</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">__repr__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s5">f&quot;</span><span class="s3">{</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_estimator</span><span class="s4">.</span><span class="s1">__class__</span><span class="s3">}</span><span class="s5">.score&quot;</span>

    <span class="s3">def </span><span class="s1">get_metadata_routing</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Get requested data properties. 
 
        Please check :ref:`User Guide &lt;metadata_routing&gt;` on how the routing 
        mechanism works. 
 
        .. versionadded:: 1.3 
 
        Returns 
        ------- 
        routing : MetadataRouter 
            A :class:`~utils.metadata_routing.MetadataRouter` encapsulating 
            routing information. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">get_routing_for_object</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_metadata_request</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">set_score_request</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, **</span><span class="s1">kwargs</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Set requested parameters by the scorer. 
 
        Please see :ref:`User Guide &lt;metadata_routing&gt;` on how the routing 
        mechanism works. 
 
        .. versionadded:: 1.5 
 
        Parameters 
        ---------- 
        kwargs : dict 
            Arguments should be of the form ``param_name=alias``, and `alias` 
            can be one of ``{True, False, None, str}``. 
        &quot;&quot;&quot;</span>
        <span class="s3">if not </span><span class="s1">_routing_enabled</span><span class="s4">():</span>
            <span class="s3">raise </span><span class="s1">RuntimeError</span><span class="s4">(</span>
                <span class="s5">&quot;This method is only available when metadata routing is enabled.&quot;</span>
                <span class="s5">&quot; You can enable it using&quot;</span>
                <span class="s5">&quot; sklearn.set_config(enable_metadata_routing=True).&quot;</span>
            <span class="s4">)</span>

        <span class="s3">for </span><span class="s1">param</span><span class="s4">, </span><span class="s1">alias </span><span class="s3">in </span><span class="s1">kwargs</span><span class="s4">.</span><span class="s1">items</span><span class="s4">():</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_metadata_request</span><span class="s4">.</span><span class="s1">score</span><span class="s4">.</span><span class="s1">add_request</span><span class="s4">(</span><span class="s1">param</span><span class="s4">=</span><span class="s1">param</span><span class="s4">, </span><span class="s1">alias</span><span class="s4">=</span><span class="s1">alias</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">self</span>


<span class="s3">def </span><span class="s1">_check_multimetric_scoring</span><span class="s4">(</span><span class="s1">estimator</span><span class="s4">, </span><span class="s1">scoring</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Check the scoring parameter in cases when multiple metrics are allowed. 
 
    In addition, multimetric scoring leverages a caching mechanism to not call the same 
    estimator response method multiple times. Hence, the scorer is modified to only use 
    a single response method given a list of response methods and the estimator. 
 
    Parameters 
    ---------- 
    estimator : sklearn estimator instance 
        The estimator for which the scoring will be applied. 
 
    scoring : list, tuple or dict 
        Strategy to evaluate the performance of the cross-validated model on 
        the test set. 
 
        The possibilities are: 
 
        - a list or tuple of unique strings; 
        - a callable returning a dictionary where they keys are the metric 
          names and the values are the metric scores; 
        - a dictionary with metric names as keys and callables a values. 
 
        See :ref:`multimetric_grid_search` for an example. 
 
    Returns 
    ------- 
    scorers_dict : dict 
        A dict mapping each scorer name to its validated scorer. 
    &quot;&quot;&quot;</span>
    <span class="s1">err_msg_generic </span><span class="s4">= (</span>
        <span class="s5">f&quot;scoring is invalid (got </span><span class="s3">{</span><span class="s1">scoring</span><span class="s3">!r}</span><span class="s5">). Refer to the &quot;</span>
        <span class="s5">&quot;scoring glossary for details: &quot;</span>
        <span class="s5">&quot;https://scikit-learn.org/stable/glossary.html#term-scoring&quot;</span>
    <span class="s4">)</span>

    <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">scoring</span><span class="s4">, (</span><span class="s1">list</span><span class="s4">, </span><span class="s1">tuple</span><span class="s4">, </span><span class="s1">set</span><span class="s4">)):</span>
        <span class="s1">err_msg </span><span class="s4">= (</span>
            <span class="s5">&quot;The list/tuple elements must be unique strings of predefined scorers. &quot;</span>
        <span class="s4">)</span>
        <span class="s3">try</span><span class="s4">:</span>
            <span class="s1">keys </span><span class="s4">= </span><span class="s1">set</span><span class="s4">(</span><span class="s1">scoring</span><span class="s4">)</span>
        <span class="s3">except </span><span class="s1">TypeError </span><span class="s3">as </span><span class="s1">e</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s1">err_msg</span><span class="s4">) </span><span class="s3">from </span><span class="s1">e</span>

        <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">keys</span><span class="s4">) != </span><span class="s1">len</span><span class="s4">(</span><span class="s1">scoring</span><span class="s4">):</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span>
                <span class="s5">f&quot;</span><span class="s3">{</span><span class="s1">err_msg</span><span class="s3">} </span><span class="s5">Duplicate elements were found in&quot;</span>
                <span class="s5">f&quot; the given list. </span><span class="s3">{</span><span class="s1">scoring</span><span class="s3">!r}</span><span class="s5">&quot;</span>
            <span class="s4">)</span>
        <span class="s3">elif </span><span class="s1">len</span><span class="s4">(</span><span class="s1">keys</span><span class="s4">) &gt; </span><span class="s6">0</span><span class="s4">:</span>
            <span class="s3">if not </span><span class="s1">all</span><span class="s4">(</span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">k</span><span class="s4">, </span><span class="s1">str</span><span class="s4">) </span><span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">keys</span><span class="s4">):</span>
                <span class="s3">if </span><span class="s1">any</span><span class="s4">(</span><span class="s1">callable</span><span class="s4">(</span><span class="s1">k</span><span class="s4">) </span><span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">keys</span><span class="s4">):</span>
                    <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span>
                        <span class="s5">f&quot;</span><span class="s3">{</span><span class="s1">err_msg</span><span class="s3">} </span><span class="s5">One or more of the elements &quot;</span>
                        <span class="s5">&quot;were callables. Use a dict of score &quot;</span>
                        <span class="s5">&quot;name mapped to the scorer callable. &quot;</span>
                        <span class="s5">f&quot;Got </span><span class="s3">{</span><span class="s1">scoring</span><span class="s3">!r}</span><span class="s5">&quot;</span>
                    <span class="s4">)</span>
                <span class="s3">else</span><span class="s4">:</span>
                    <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span>
                        <span class="s5">f&quot;</span><span class="s3">{</span><span class="s1">err_msg</span><span class="s3">} </span><span class="s5">Non-string types were found &quot;</span>
                        <span class="s5">f&quot;in the given list. Got </span><span class="s3">{</span><span class="s1">scoring</span><span class="s3">!r}</span><span class="s5">&quot;</span>
                    <span class="s4">)</span>
            <span class="s1">scorers </span><span class="s4">= {</span>
                <span class="s1">scorer</span><span class="s4">: </span><span class="s1">check_scoring</span><span class="s4">(</span><span class="s1">estimator</span><span class="s4">, </span><span class="s1">scoring</span><span class="s4">=</span><span class="s1">scorer</span><span class="s4">) </span><span class="s3">for </span><span class="s1">scorer </span><span class="s3">in </span><span class="s1">scoring</span>
            <span class="s4">}</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">f&quot;</span><span class="s3">{</span><span class="s1">err_msg</span><span class="s3">} </span><span class="s5">Empty list was given. </span><span class="s3">{</span><span class="s1">scoring</span><span class="s3">!r}</span><span class="s5">&quot;</span><span class="s4">)</span>

    <span class="s3">elif </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">scoring</span><span class="s4">, </span><span class="s1">dict</span><span class="s4">):</span>
        <span class="s1">keys </span><span class="s4">= </span><span class="s1">set</span><span class="s4">(</span><span class="s1">scoring</span><span class="s4">)</span>
        <span class="s3">if not </span><span class="s1">all</span><span class="s4">(</span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">k</span><span class="s4">, </span><span class="s1">str</span><span class="s4">) </span><span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">keys</span><span class="s4">):</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span>
                <span class="s5">&quot;Non-string types were found in the keys of &quot;</span>
                <span class="s5">f&quot;the given dict. scoring=</span><span class="s3">{</span><span class="s1">scoring</span><span class="s3">!r}</span><span class="s5">&quot;</span>
            <span class="s4">)</span>
        <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">keys</span><span class="s4">) == </span><span class="s6">0</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">f&quot;An empty dict was passed. </span><span class="s3">{</span><span class="s1">scoring</span><span class="s3">!r}</span><span class="s5">&quot;</span><span class="s4">)</span>
        <span class="s1">scorers </span><span class="s4">= {</span>
            <span class="s1">key</span><span class="s4">: </span><span class="s1">check_scoring</span><span class="s4">(</span><span class="s1">estimator</span><span class="s4">, </span><span class="s1">scoring</span><span class="s4">=</span><span class="s1">scorer</span><span class="s4">)</span>
            <span class="s3">for </span><span class="s1">key</span><span class="s4">, </span><span class="s1">scorer </span><span class="s3">in </span><span class="s1">scoring</span><span class="s4">.</span><span class="s1">items</span><span class="s4">()</span>
        <span class="s4">}</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s1">err_msg_generic</span><span class="s4">)</span>

    <span class="s3">return </span><span class="s1">scorers</span>


<span class="s3">def </span><span class="s1">_get_response_method</span><span class="s4">(</span><span class="s1">response_method</span><span class="s4">, </span><span class="s1">needs_threshold</span><span class="s4">, </span><span class="s1">needs_proba</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Handles deprecation of `needs_threshold` and `needs_proba` parameters in 
    favor of `response_method`. 
    &quot;&quot;&quot;</span>
    <span class="s1">needs_threshold_provided </span><span class="s4">= </span><span class="s1">needs_threshold </span><span class="s4">!= </span><span class="s5">&quot;deprecated&quot;</span>
    <span class="s1">needs_proba_provided </span><span class="s4">= </span><span class="s1">needs_proba </span><span class="s4">!= </span><span class="s5">&quot;deprecated&quot;</span>
    <span class="s1">response_method_provided </span><span class="s4">= </span><span class="s1">response_method </span><span class="s3">is not None</span>

    <span class="s1">needs_threshold </span><span class="s4">= </span><span class="s3">False if </span><span class="s1">needs_threshold </span><span class="s4">== </span><span class="s5">&quot;deprecated&quot; </span><span class="s3">else </span><span class="s1">needs_threshold</span>
    <span class="s1">needs_proba </span><span class="s4">= </span><span class="s3">False if </span><span class="s1">needs_proba </span><span class="s4">== </span><span class="s5">&quot;deprecated&quot; </span><span class="s3">else </span><span class="s1">needs_proba</span>

    <span class="s3">if </span><span class="s1">response_method_provided </span><span class="s3">and </span><span class="s4">(</span><span class="s1">needs_proba_provided </span><span class="s3">or </span><span class="s1">needs_threshold_provided</span><span class="s4">):</span>
        <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span>
            <span class="s5">&quot;You cannot set both `response_method` and `needs_proba` or &quot;</span>
            <span class="s5">&quot;`needs_threshold` at the same time. Only use `response_method` since &quot;</span>
            <span class="s5">&quot;the other two are deprecated in version 1.4 and will be removed in 1.6.&quot;</span>
        <span class="s4">)</span>

    <span class="s3">if </span><span class="s1">needs_proba_provided </span><span class="s3">or </span><span class="s1">needs_threshold_provided</span><span class="s4">:</span>
        <span class="s1">warnings</span><span class="s4">.</span><span class="s1">warn</span><span class="s4">(</span>
            <span class="s4">(</span>
                <span class="s5">&quot;The `needs_threshold` and `needs_proba` parameter are deprecated in &quot;</span>
                <span class="s5">&quot;version 1.4 and will be removed in 1.6. You can either let &quot;</span>
                <span class="s5">&quot;`response_method` be `None` or set it to `predict` to preserve the &quot;</span>
                <span class="s5">&quot;same behaviour.&quot;</span>
            <span class="s4">),</span>
            <span class="s1">FutureWarning</span><span class="s4">,</span>
        <span class="s4">)</span>

    <span class="s3">if </span><span class="s1">response_method_provided</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">response_method</span>

    <span class="s3">if </span><span class="s1">needs_proba </span><span class="s3">is True and </span><span class="s1">needs_threshold </span><span class="s3">is True</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span>
            <span class="s5">&quot;You cannot set both `needs_proba` and `needs_threshold` at the same &quot;</span>
            <span class="s5">&quot;time. Use `response_method` instead since the other two are deprecated &quot;</span>
            <span class="s5">&quot;in version 1.4 and will be removed in 1.6.&quot;</span>
        <span class="s4">)</span>

    <span class="s3">if </span><span class="s1">needs_proba </span><span class="s3">is True</span><span class="s4">:</span>
        <span class="s1">response_method </span><span class="s4">= </span><span class="s5">&quot;predict_proba&quot;</span>
    <span class="s3">elif </span><span class="s1">needs_threshold </span><span class="s3">is True</span><span class="s4">:</span>
        <span class="s1">response_method </span><span class="s4">= (</span><span class="s5">&quot;decision_function&quot;</span><span class="s4">, </span><span class="s5">&quot;predict_proba&quot;</span><span class="s4">)</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">response_method </span><span class="s4">= </span><span class="s5">&quot;predict&quot;</span>

    <span class="s3">return </span><span class="s1">response_method</span>


<span class="s4">@</span><span class="s1">validate_params</span><span class="s4">(</span>
    <span class="s4">{</span>
        <span class="s5">&quot;score_func&quot;</span><span class="s4">: [</span><span class="s1">callable</span><span class="s4">],</span>
        <span class="s5">&quot;response_method&quot;</span><span class="s4">: [</span>
            <span class="s3">None</span><span class="s4">,</span>
            <span class="s1">list</span><span class="s4">,</span>
            <span class="s1">tuple</span><span class="s4">,</span>
            <span class="s1">StrOptions</span><span class="s4">({</span><span class="s5">&quot;predict&quot;</span><span class="s4">, </span><span class="s5">&quot;predict_proba&quot;</span><span class="s4">, </span><span class="s5">&quot;decision_function&quot;</span><span class="s4">}),</span>
        <span class="s4">],</span>
        <span class="s5">&quot;greater_is_better&quot;</span><span class="s4">: [</span><span class="s5">&quot;boolean&quot;</span><span class="s4">],</span>
        <span class="s5">&quot;needs_proba&quot;</span><span class="s4">: [</span><span class="s5">&quot;boolean&quot;</span><span class="s4">, </span><span class="s1">Hidden</span><span class="s4">(</span><span class="s1">StrOptions</span><span class="s4">({</span><span class="s5">&quot;deprecated&quot;</span><span class="s4">}))],</span>
        <span class="s5">&quot;needs_threshold&quot;</span><span class="s4">: [</span><span class="s5">&quot;boolean&quot;</span><span class="s4">, </span><span class="s1">Hidden</span><span class="s4">(</span><span class="s1">StrOptions</span><span class="s4">({</span><span class="s5">&quot;deprecated&quot;</span><span class="s4">}))],</span>
    <span class="s4">},</span>
    <span class="s1">prefer_skip_nested_validation</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
<span class="s4">)</span>
<span class="s3">def </span><span class="s1">make_scorer</span><span class="s4">(</span>
    <span class="s1">score_func</span><span class="s4">,</span>
    <span class="s4">*,</span>
    <span class="s1">response_method</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
    <span class="s1">greater_is_better</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
    <span class="s1">needs_proba</span><span class="s4">=</span><span class="s5">&quot;deprecated&quot;</span><span class="s4">,</span>
    <span class="s1">needs_threshold</span><span class="s4">=</span><span class="s5">&quot;deprecated&quot;</span><span class="s4">,</span>
    <span class="s4">**</span><span class="s1">kwargs</span><span class="s4">,</span>
<span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Make a scorer from a performance metric or loss function. 
 
    A scorer is a wrapper around an arbitrary metric or loss function that is called 
    with the signature `scorer(estimator, X, y_true, **kwargs)`. 
 
    It is accepted in all scikit-learn estimators or functions allowing a `scoring` 
    parameter. 
 
    The parameter `response_method` allows to specify which method of the estimator 
    should be used to feed the scoring/loss function. 
 
    Read more in the :ref:`User Guide &lt;scoring&gt;`. 
 
    Parameters 
    ---------- 
    score_func : callable 
        Score function (or loss function) with signature 
        ``score_func(y, y_pred, **kwargs)``. 
 
    response_method : {&quot;predict_proba&quot;, &quot;decision_function&quot;, &quot;predict&quot;} or \ 
            list/tuple of such str, default=None 
 
        Specifies the response method to use get prediction from an estimator 
        (i.e. :term:`predict_proba`, :term:`decision_function` or 
        :term:`predict`). Possible choices are: 
 
        - if `str`, it corresponds to the name to the method to return; 
        - if a list or tuple of `str`, it provides the method names in order of 
          preference. The method returned corresponds to the first method in 
          the list and which is implemented by `estimator`. 
        - if `None`, it is equivalent to `&quot;predict&quot;`. 
 
        .. versionadded:: 1.4 
 
    greater_is_better : bool, default=True 
        Whether `score_func` is a score function (default), meaning high is 
        good, or a loss function, meaning low is good. In the latter case, the 
        scorer object will sign-flip the outcome of the `score_func`. 
 
    needs_proba : bool, default=False 
        Whether `score_func` requires `predict_proba` to get probability 
        estimates out of a classifier. 
 
        If True, for binary `y_true`, the score function is supposed to accept 
        a 1D `y_pred` (i.e., probability of the positive class, shape 
        `(n_samples,)`). 
 
        .. deprecated:: 1.4 
           `needs_proba` is deprecated in version 1.4 and will be removed in 
           1.6. Use `response_method=&quot;predict_proba&quot;` instead. 
 
    needs_threshold : bool, default=False 
        Whether `score_func` takes a continuous decision certainty. 
        This only works for binary classification using estimators that 
        have either a `decision_function` or `predict_proba` method. 
 
        If True, for binary `y_true`, the score function is supposed to accept 
        a 1D `y_pred` (i.e., probability of the positive class or the decision 
        function, shape `(n_samples,)`). 
 
        For example `average_precision` or the area under the roc curve 
        can not be computed using discrete predictions alone. 
 
        .. deprecated:: 1.4 
           `needs_threshold` is deprecated in version 1.4 and will be removed 
           in 1.6. Use `response_method=(&quot;decision_function&quot;, &quot;predict_proba&quot;)` 
           instead to preserve the same behaviour. 
 
    **kwargs : additional arguments 
        Additional parameters to be passed to `score_func`. 
 
    Returns 
    ------- 
    scorer : callable 
        Callable object that returns a scalar score; greater is better. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from sklearn.metrics import fbeta_score, make_scorer 
    &gt;&gt;&gt; ftwo_scorer = make_scorer(fbeta_score, beta=2) 
    &gt;&gt;&gt; ftwo_scorer 
    make_scorer(fbeta_score, response_method='predict', beta=2) 
    &gt;&gt;&gt; from sklearn.model_selection import GridSearchCV 
    &gt;&gt;&gt; from sklearn.svm import LinearSVC 
    &gt;&gt;&gt; grid = GridSearchCV(LinearSVC(), param_grid={'C': [1, 10]}, 
    ...                     scoring=ftwo_scorer) 
    &quot;&quot;&quot;</span>
    <span class="s1">response_method </span><span class="s4">= </span><span class="s1">_get_response_method</span><span class="s4">(</span>
        <span class="s1">response_method</span><span class="s4">, </span><span class="s1">needs_threshold</span><span class="s4">, </span><span class="s1">needs_proba</span>
    <span class="s4">)</span>
    <span class="s1">sign </span><span class="s4">= </span><span class="s6">1 </span><span class="s3">if </span><span class="s1">greater_is_better </span><span class="s3">else </span><span class="s4">-</span><span class="s6">1</span>
    <span class="s3">return </span><span class="s1">_Scorer</span><span class="s4">(</span><span class="s1">score_func</span><span class="s4">, </span><span class="s1">sign</span><span class="s4">, </span><span class="s1">kwargs</span><span class="s4">, </span><span class="s1">response_method</span><span class="s4">)</span>


<span class="s2"># Standard regression scores</span>
<span class="s1">explained_variance_scorer </span><span class="s4">= </span><span class="s1">make_scorer</span><span class="s4">(</span><span class="s1">explained_variance_score</span><span class="s4">)</span>
<span class="s1">r2_scorer </span><span class="s4">= </span><span class="s1">make_scorer</span><span class="s4">(</span><span class="s1">r2_score</span><span class="s4">)</span>
<span class="s1">max_error_scorer </span><span class="s4">= </span><span class="s1">make_scorer</span><span class="s4">(</span><span class="s1">max_error</span><span class="s4">, </span><span class="s1">greater_is_better</span><span class="s4">=</span><span class="s3">False</span><span class="s4">)</span>
<span class="s1">neg_mean_squared_error_scorer </span><span class="s4">= </span><span class="s1">make_scorer</span><span class="s4">(</span><span class="s1">mean_squared_error</span><span class="s4">, </span><span class="s1">greater_is_better</span><span class="s4">=</span><span class="s3">False</span><span class="s4">)</span>
<span class="s1">neg_mean_squared_log_error_scorer </span><span class="s4">= </span><span class="s1">make_scorer</span><span class="s4">(</span>
    <span class="s1">mean_squared_log_error</span><span class="s4">, </span><span class="s1">greater_is_better</span><span class="s4">=</span><span class="s3">False</span>
<span class="s4">)</span>
<span class="s1">neg_mean_absolute_error_scorer </span><span class="s4">= </span><span class="s1">make_scorer</span><span class="s4">(</span>
    <span class="s1">mean_absolute_error</span><span class="s4">, </span><span class="s1">greater_is_better</span><span class="s4">=</span><span class="s3">False</span>
<span class="s4">)</span>
<span class="s1">neg_mean_absolute_percentage_error_scorer </span><span class="s4">= </span><span class="s1">make_scorer</span><span class="s4">(</span>
    <span class="s1">mean_absolute_percentage_error</span><span class="s4">, </span><span class="s1">greater_is_better</span><span class="s4">=</span><span class="s3">False</span>
<span class="s4">)</span>
<span class="s1">neg_median_absolute_error_scorer </span><span class="s4">= </span><span class="s1">make_scorer</span><span class="s4">(</span>
    <span class="s1">median_absolute_error</span><span class="s4">, </span><span class="s1">greater_is_better</span><span class="s4">=</span><span class="s3">False</span>
<span class="s4">)</span>
<span class="s1">neg_root_mean_squared_error_scorer </span><span class="s4">= </span><span class="s1">make_scorer</span><span class="s4">(</span>
    <span class="s1">root_mean_squared_error</span><span class="s4">, </span><span class="s1">greater_is_better</span><span class="s4">=</span><span class="s3">False</span>
<span class="s4">)</span>
<span class="s1">neg_root_mean_squared_log_error_scorer </span><span class="s4">= </span><span class="s1">make_scorer</span><span class="s4">(</span>
    <span class="s1">root_mean_squared_log_error</span><span class="s4">, </span><span class="s1">greater_is_better</span><span class="s4">=</span><span class="s3">False</span>
<span class="s4">)</span>
<span class="s1">neg_mean_poisson_deviance_scorer </span><span class="s4">= </span><span class="s1">make_scorer</span><span class="s4">(</span>
    <span class="s1">mean_poisson_deviance</span><span class="s4">, </span><span class="s1">greater_is_better</span><span class="s4">=</span><span class="s3">False</span>
<span class="s4">)</span>

<span class="s1">neg_mean_gamma_deviance_scorer </span><span class="s4">= </span><span class="s1">make_scorer</span><span class="s4">(</span>
    <span class="s1">mean_gamma_deviance</span><span class="s4">, </span><span class="s1">greater_is_better</span><span class="s4">=</span><span class="s3">False</span>
<span class="s4">)</span>
<span class="s1">d2_absolute_error_scorer </span><span class="s4">= </span><span class="s1">make_scorer</span><span class="s4">(</span><span class="s1">d2_absolute_error_score</span><span class="s4">)</span>

<span class="s2"># Standard Classification Scores</span>
<span class="s1">accuracy_scorer </span><span class="s4">= </span><span class="s1">make_scorer</span><span class="s4">(</span><span class="s1">accuracy_score</span><span class="s4">)</span>
<span class="s1">balanced_accuracy_scorer </span><span class="s4">= </span><span class="s1">make_scorer</span><span class="s4">(</span><span class="s1">balanced_accuracy_score</span><span class="s4">)</span>
<span class="s1">matthews_corrcoef_scorer </span><span class="s4">= </span><span class="s1">make_scorer</span><span class="s4">(</span><span class="s1">matthews_corrcoef</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">positive_likelihood_ratio</span><span class="s4">(</span><span class="s1">y_true</span><span class="s4">, </span><span class="s1">y_pred</span><span class="s4">):</span>
    <span class="s3">return </span><span class="s1">class_likelihood_ratios</span><span class="s4">(</span><span class="s1">y_true</span><span class="s4">, </span><span class="s1">y_pred</span><span class="s4">)[</span><span class="s6">0</span><span class="s4">]</span>


<span class="s3">def </span><span class="s1">negative_likelihood_ratio</span><span class="s4">(</span><span class="s1">y_true</span><span class="s4">, </span><span class="s1">y_pred</span><span class="s4">):</span>
    <span class="s3">return </span><span class="s1">class_likelihood_ratios</span><span class="s4">(</span><span class="s1">y_true</span><span class="s4">, </span><span class="s1">y_pred</span><span class="s4">)[</span><span class="s6">1</span><span class="s4">]</span>


<span class="s1">positive_likelihood_ratio_scorer </span><span class="s4">= </span><span class="s1">make_scorer</span><span class="s4">(</span><span class="s1">positive_likelihood_ratio</span><span class="s4">)</span>
<span class="s1">neg_negative_likelihood_ratio_scorer </span><span class="s4">= </span><span class="s1">make_scorer</span><span class="s4">(</span>
    <span class="s1">negative_likelihood_ratio</span><span class="s4">, </span><span class="s1">greater_is_better</span><span class="s4">=</span><span class="s3">False</span>
<span class="s4">)</span>

<span class="s2"># Score functions that need decision values</span>
<span class="s1">top_k_accuracy_scorer </span><span class="s4">= </span><span class="s1">make_scorer</span><span class="s4">(</span>
    <span class="s1">top_k_accuracy_score</span><span class="s4">,</span>
    <span class="s1">greater_is_better</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
    <span class="s1">response_method</span><span class="s4">=(</span><span class="s5">&quot;decision_function&quot;</span><span class="s4">, </span><span class="s5">&quot;predict_proba&quot;</span><span class="s4">),</span>
<span class="s4">)</span>
<span class="s1">roc_auc_scorer </span><span class="s4">= </span><span class="s1">make_scorer</span><span class="s4">(</span>
    <span class="s1">roc_auc_score</span><span class="s4">,</span>
    <span class="s1">greater_is_better</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
    <span class="s1">response_method</span><span class="s4">=(</span><span class="s5">&quot;decision_function&quot;</span><span class="s4">, </span><span class="s5">&quot;predict_proba&quot;</span><span class="s4">),</span>
<span class="s4">)</span>
<span class="s1">average_precision_scorer </span><span class="s4">= </span><span class="s1">make_scorer</span><span class="s4">(</span>
    <span class="s1">average_precision_score</span><span class="s4">,</span>
    <span class="s1">response_method</span><span class="s4">=(</span><span class="s5">&quot;decision_function&quot;</span><span class="s4">, </span><span class="s5">&quot;predict_proba&quot;</span><span class="s4">),</span>
<span class="s4">)</span>
<span class="s1">roc_auc_ovo_scorer </span><span class="s4">= </span><span class="s1">make_scorer</span><span class="s4">(</span>
    <span class="s1">roc_auc_score</span><span class="s4">, </span><span class="s1">response_method</span><span class="s4">=</span><span class="s5">&quot;predict_proba&quot;</span><span class="s4">, </span><span class="s1">multi_class</span><span class="s4">=</span><span class="s5">&quot;ovo&quot;</span>
<span class="s4">)</span>
<span class="s1">roc_auc_ovo_weighted_scorer </span><span class="s4">= </span><span class="s1">make_scorer</span><span class="s4">(</span>
    <span class="s1">roc_auc_score</span><span class="s4">,</span>
    <span class="s1">response_method</span><span class="s4">=</span><span class="s5">&quot;predict_proba&quot;</span><span class="s4">,</span>
    <span class="s1">multi_class</span><span class="s4">=</span><span class="s5">&quot;ovo&quot;</span><span class="s4">,</span>
    <span class="s1">average</span><span class="s4">=</span><span class="s5">&quot;weighted&quot;</span><span class="s4">,</span>
<span class="s4">)</span>
<span class="s1">roc_auc_ovr_scorer </span><span class="s4">= </span><span class="s1">make_scorer</span><span class="s4">(</span>
    <span class="s1">roc_auc_score</span><span class="s4">, </span><span class="s1">response_method</span><span class="s4">=</span><span class="s5">&quot;predict_proba&quot;</span><span class="s4">, </span><span class="s1">multi_class</span><span class="s4">=</span><span class="s5">&quot;ovr&quot;</span>
<span class="s4">)</span>
<span class="s1">roc_auc_ovr_weighted_scorer </span><span class="s4">= </span><span class="s1">make_scorer</span><span class="s4">(</span>
    <span class="s1">roc_auc_score</span><span class="s4">,</span>
    <span class="s1">response_method</span><span class="s4">=</span><span class="s5">&quot;predict_proba&quot;</span><span class="s4">,</span>
    <span class="s1">multi_class</span><span class="s4">=</span><span class="s5">&quot;ovr&quot;</span><span class="s4">,</span>
    <span class="s1">average</span><span class="s4">=</span><span class="s5">&quot;weighted&quot;</span><span class="s4">,</span>
<span class="s4">)</span>

<span class="s2"># Score function for probabilistic classification</span>
<span class="s1">neg_log_loss_scorer </span><span class="s4">= </span><span class="s1">make_scorer</span><span class="s4">(</span>
    <span class="s1">log_loss</span><span class="s4">, </span><span class="s1">greater_is_better</span><span class="s4">=</span><span class="s3">False</span><span class="s4">, </span><span class="s1">response_method</span><span class="s4">=</span><span class="s5">&quot;predict_proba&quot;</span>
<span class="s4">)</span>
<span class="s1">neg_brier_score_scorer </span><span class="s4">= </span><span class="s1">make_scorer</span><span class="s4">(</span>
    <span class="s1">brier_score_loss</span><span class="s4">, </span><span class="s1">greater_is_better</span><span class="s4">=</span><span class="s3">False</span><span class="s4">, </span><span class="s1">response_method</span><span class="s4">=</span><span class="s5">&quot;predict_proba&quot;</span>
<span class="s4">)</span>
<span class="s1">brier_score_loss_scorer </span><span class="s4">= </span><span class="s1">make_scorer</span><span class="s4">(</span>
    <span class="s1">brier_score_loss</span><span class="s4">, </span><span class="s1">greater_is_better</span><span class="s4">=</span><span class="s3">False</span><span class="s4">, </span><span class="s1">response_method</span><span class="s4">=</span><span class="s5">&quot;predict_proba&quot;</span>
<span class="s4">)</span>


<span class="s2"># Clustering scores</span>
<span class="s1">adjusted_rand_scorer </span><span class="s4">= </span><span class="s1">make_scorer</span><span class="s4">(</span><span class="s1">adjusted_rand_score</span><span class="s4">)</span>
<span class="s1">rand_scorer </span><span class="s4">= </span><span class="s1">make_scorer</span><span class="s4">(</span><span class="s1">rand_score</span><span class="s4">)</span>
<span class="s1">homogeneity_scorer </span><span class="s4">= </span><span class="s1">make_scorer</span><span class="s4">(</span><span class="s1">homogeneity_score</span><span class="s4">)</span>
<span class="s1">completeness_scorer </span><span class="s4">= </span><span class="s1">make_scorer</span><span class="s4">(</span><span class="s1">completeness_score</span><span class="s4">)</span>
<span class="s1">v_measure_scorer </span><span class="s4">= </span><span class="s1">make_scorer</span><span class="s4">(</span><span class="s1">v_measure_score</span><span class="s4">)</span>
<span class="s1">mutual_info_scorer </span><span class="s4">= </span><span class="s1">make_scorer</span><span class="s4">(</span><span class="s1">mutual_info_score</span><span class="s4">)</span>
<span class="s1">adjusted_mutual_info_scorer </span><span class="s4">= </span><span class="s1">make_scorer</span><span class="s4">(</span><span class="s1">adjusted_mutual_info_score</span><span class="s4">)</span>
<span class="s1">normalized_mutual_info_scorer </span><span class="s4">= </span><span class="s1">make_scorer</span><span class="s4">(</span><span class="s1">normalized_mutual_info_score</span><span class="s4">)</span>
<span class="s1">fowlkes_mallows_scorer </span><span class="s4">= </span><span class="s1">make_scorer</span><span class="s4">(</span><span class="s1">fowlkes_mallows_score</span><span class="s4">)</span>


<span class="s1">_SCORERS </span><span class="s4">= </span><span class="s1">dict</span><span class="s4">(</span>
    <span class="s1">explained_variance</span><span class="s4">=</span><span class="s1">explained_variance_scorer</span><span class="s4">,</span>
    <span class="s1">r2</span><span class="s4">=</span><span class="s1">r2_scorer</span><span class="s4">,</span>
    <span class="s1">max_error</span><span class="s4">=</span><span class="s1">max_error_scorer</span><span class="s4">,</span>
    <span class="s1">matthews_corrcoef</span><span class="s4">=</span><span class="s1">matthews_corrcoef_scorer</span><span class="s4">,</span>
    <span class="s1">neg_median_absolute_error</span><span class="s4">=</span><span class="s1">neg_median_absolute_error_scorer</span><span class="s4">,</span>
    <span class="s1">neg_mean_absolute_error</span><span class="s4">=</span><span class="s1">neg_mean_absolute_error_scorer</span><span class="s4">,</span>
    <span class="s1">neg_mean_absolute_percentage_error</span><span class="s4">=</span><span class="s1">neg_mean_absolute_percentage_error_scorer</span><span class="s4">,</span>
    <span class="s1">neg_mean_squared_error</span><span class="s4">=</span><span class="s1">neg_mean_squared_error_scorer</span><span class="s4">,</span>
    <span class="s1">neg_mean_squared_log_error</span><span class="s4">=</span><span class="s1">neg_mean_squared_log_error_scorer</span><span class="s4">,</span>
    <span class="s1">neg_root_mean_squared_error</span><span class="s4">=</span><span class="s1">neg_root_mean_squared_error_scorer</span><span class="s4">,</span>
    <span class="s1">neg_root_mean_squared_log_error</span><span class="s4">=</span><span class="s1">neg_root_mean_squared_log_error_scorer</span><span class="s4">,</span>
    <span class="s1">neg_mean_poisson_deviance</span><span class="s4">=</span><span class="s1">neg_mean_poisson_deviance_scorer</span><span class="s4">,</span>
    <span class="s1">neg_mean_gamma_deviance</span><span class="s4">=</span><span class="s1">neg_mean_gamma_deviance_scorer</span><span class="s4">,</span>
    <span class="s1">d2_absolute_error_score</span><span class="s4">=</span><span class="s1">d2_absolute_error_scorer</span><span class="s4">,</span>
    <span class="s1">accuracy</span><span class="s4">=</span><span class="s1">accuracy_scorer</span><span class="s4">,</span>
    <span class="s1">top_k_accuracy</span><span class="s4">=</span><span class="s1">top_k_accuracy_scorer</span><span class="s4">,</span>
    <span class="s1">roc_auc</span><span class="s4">=</span><span class="s1">roc_auc_scorer</span><span class="s4">,</span>
    <span class="s1">roc_auc_ovr</span><span class="s4">=</span><span class="s1">roc_auc_ovr_scorer</span><span class="s4">,</span>
    <span class="s1">roc_auc_ovo</span><span class="s4">=</span><span class="s1">roc_auc_ovo_scorer</span><span class="s4">,</span>
    <span class="s1">roc_auc_ovr_weighted</span><span class="s4">=</span><span class="s1">roc_auc_ovr_weighted_scorer</span><span class="s4">,</span>
    <span class="s1">roc_auc_ovo_weighted</span><span class="s4">=</span><span class="s1">roc_auc_ovo_weighted_scorer</span><span class="s4">,</span>
    <span class="s1">balanced_accuracy</span><span class="s4">=</span><span class="s1">balanced_accuracy_scorer</span><span class="s4">,</span>
    <span class="s1">average_precision</span><span class="s4">=</span><span class="s1">average_precision_scorer</span><span class="s4">,</span>
    <span class="s1">neg_log_loss</span><span class="s4">=</span><span class="s1">neg_log_loss_scorer</span><span class="s4">,</span>
    <span class="s1">neg_brier_score</span><span class="s4">=</span><span class="s1">neg_brier_score_scorer</span><span class="s4">,</span>
    <span class="s1">positive_likelihood_ratio</span><span class="s4">=</span><span class="s1">positive_likelihood_ratio_scorer</span><span class="s4">,</span>
    <span class="s1">neg_negative_likelihood_ratio</span><span class="s4">=</span><span class="s1">neg_negative_likelihood_ratio_scorer</span><span class="s4">,</span>
    <span class="s2"># Cluster metrics that use supervised evaluation</span>
    <span class="s1">adjusted_rand_score</span><span class="s4">=</span><span class="s1">adjusted_rand_scorer</span><span class="s4">,</span>
    <span class="s1">rand_score</span><span class="s4">=</span><span class="s1">rand_scorer</span><span class="s4">,</span>
    <span class="s1">homogeneity_score</span><span class="s4">=</span><span class="s1">homogeneity_scorer</span><span class="s4">,</span>
    <span class="s1">completeness_score</span><span class="s4">=</span><span class="s1">completeness_scorer</span><span class="s4">,</span>
    <span class="s1">v_measure_score</span><span class="s4">=</span><span class="s1">v_measure_scorer</span><span class="s4">,</span>
    <span class="s1">mutual_info_score</span><span class="s4">=</span><span class="s1">mutual_info_scorer</span><span class="s4">,</span>
    <span class="s1">adjusted_mutual_info_score</span><span class="s4">=</span><span class="s1">adjusted_mutual_info_scorer</span><span class="s4">,</span>
    <span class="s1">normalized_mutual_info_score</span><span class="s4">=</span><span class="s1">normalized_mutual_info_scorer</span><span class="s4">,</span>
    <span class="s1">fowlkes_mallows_score</span><span class="s4">=</span><span class="s1">fowlkes_mallows_scorer</span><span class="s4">,</span>
<span class="s4">)</span>


<span class="s3">def </span><span class="s1">get_scorer_names</span><span class="s4">():</span>
    <span class="s0">&quot;&quot;&quot;Get the names of all available scorers. 
 
    These names can be passed to :func:`~sklearn.metrics.get_scorer` to 
    retrieve the scorer object. 
 
    Returns 
    ------- 
    list of str 
        Names of all available scorers. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from sklearn.metrics import get_scorer_names 
    &gt;&gt;&gt; all_scorers = get_scorer_names() 
    &gt;&gt;&gt; type(all_scorers) 
    &lt;class 'list'&gt; 
    &gt;&gt;&gt; all_scorers[:3] 
    ['accuracy', 'adjusted_mutual_info_score', 'adjusted_rand_score'] 
    &gt;&gt;&gt; &quot;roc_auc&quot; in all_scorers 
    True 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">sorted</span><span class="s4">(</span><span class="s1">_SCORERS</span><span class="s4">.</span><span class="s1">keys</span><span class="s4">())</span>


<span class="s3">for </span><span class="s1">name</span><span class="s4">, </span><span class="s1">metric </span><span class="s3">in </span><span class="s4">[</span>
    <span class="s4">(</span><span class="s5">&quot;precision&quot;</span><span class="s4">, </span><span class="s1">precision_score</span><span class="s4">),</span>
    <span class="s4">(</span><span class="s5">&quot;recall&quot;</span><span class="s4">, </span><span class="s1">recall_score</span><span class="s4">),</span>
    <span class="s4">(</span><span class="s5">&quot;f1&quot;</span><span class="s4">, </span><span class="s1">f1_score</span><span class="s4">),</span>
    <span class="s4">(</span><span class="s5">&quot;jaccard&quot;</span><span class="s4">, </span><span class="s1">jaccard_score</span><span class="s4">),</span>
<span class="s4">]:</span>
    <span class="s1">_SCORERS</span><span class="s4">[</span><span class="s1">name</span><span class="s4">] = </span><span class="s1">make_scorer</span><span class="s4">(</span><span class="s1">metric</span><span class="s4">, </span><span class="s1">average</span><span class="s4">=</span><span class="s5">&quot;binary&quot;</span><span class="s4">)</span>
    <span class="s3">for </span><span class="s1">average </span><span class="s3">in </span><span class="s4">[</span><span class="s5">&quot;macro&quot;</span><span class="s4">, </span><span class="s5">&quot;micro&quot;</span><span class="s4">, </span><span class="s5">&quot;samples&quot;</span><span class="s4">, </span><span class="s5">&quot;weighted&quot;</span><span class="s4">]:</span>
        <span class="s1">qualified_name </span><span class="s4">= </span><span class="s5">&quot;{0}_{1}&quot;</span><span class="s4">.</span><span class="s1">format</span><span class="s4">(</span><span class="s1">name</span><span class="s4">, </span><span class="s1">average</span><span class="s4">)</span>
        <span class="s1">_SCORERS</span><span class="s4">[</span><span class="s1">qualified_name</span><span class="s4">] = </span><span class="s1">make_scorer</span><span class="s4">(</span><span class="s1">metric</span><span class="s4">, </span><span class="s1">pos_label</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">average</span><span class="s4">=</span><span class="s1">average</span><span class="s4">)</span>


<span class="s4">@</span><span class="s1">validate_params</span><span class="s4">(</span>
    <span class="s4">{</span>
        <span class="s5">&quot;estimator&quot;</span><span class="s4">: [</span><span class="s1">HasMethods</span><span class="s4">(</span><span class="s5">&quot;fit&quot;</span><span class="s4">), </span><span class="s3">None</span><span class="s4">],</span>
        <span class="s5">&quot;scoring&quot;</span><span class="s4">: [</span>
            <span class="s1">StrOptions</span><span class="s4">(</span><span class="s1">set</span><span class="s4">(</span><span class="s1">get_scorer_names</span><span class="s4">())),</span>
            <span class="s1">callable</span><span class="s4">,</span>
            <span class="s1">list</span><span class="s4">,</span>
            <span class="s1">set</span><span class="s4">,</span>
            <span class="s1">tuple</span><span class="s4">,</span>
            <span class="s1">dict</span><span class="s4">,</span>
            <span class="s3">None</span><span class="s4">,</span>
        <span class="s4">],</span>
        <span class="s5">&quot;allow_none&quot;</span><span class="s4">: [</span><span class="s5">&quot;boolean&quot;</span><span class="s4">],</span>
    <span class="s4">},</span>
    <span class="s1">prefer_skip_nested_validation</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
<span class="s4">)</span>
<span class="s3">def </span><span class="s1">check_scoring</span><span class="s4">(</span><span class="s1">estimator</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">scoring</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, *, </span><span class="s1">allow_none</span><span class="s4">=</span><span class="s3">False</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Determine scorer from user options. 
 
    A TypeError will be thrown if the estimator cannot be scored. 
 
    Parameters 
    ---------- 
    estimator : estimator object implementing 'fit' or None, default=None 
        The object to use to fit the data. If `None`, then this function may error 
        depending on `allow_none`. 
 
    scoring : str, callable, list, tuple, or dict, default=None 
        Scorer to use. If `scoring` represents a single score, one can use: 
 
        - a single string (see :ref:`scoring_parameter`); 
        - a callable (see :ref:`scoring`) that returns a single value. 
 
        If `scoring` represents multiple scores, one can use: 
 
        - a list or tuple of unique strings; 
        - a callable returning a dictionary where the keys are the metric 
          names and the values are the metric scorers; 
        - a dictionary with metric names as keys and callables a values. 
 
        If None, the provided estimator object's `score` method is used. 
 
    allow_none : bool, default=False 
        If no scoring is specified and the estimator has no score function, we 
        can either return None or raise an exception. 
 
    Returns 
    ------- 
    scoring : callable 
        A scorer callable object / function with signature 
        ``scorer(estimator, X, y)``. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from sklearn.datasets import load_iris 
    &gt;&gt;&gt; from sklearn.metrics import check_scoring 
    &gt;&gt;&gt; from sklearn.tree import DecisionTreeClassifier 
    &gt;&gt;&gt; X, y = load_iris(return_X_y=True) 
    &gt;&gt;&gt; classifier = DecisionTreeClassifier(max_depth=2).fit(X, y) 
    &gt;&gt;&gt; scorer = check_scoring(classifier, scoring='accuracy') 
    &gt;&gt;&gt; scorer(classifier, X, y) 
    0.96... 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">scoring</span><span class="s4">, </span><span class="s1">str</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">get_scorer</span><span class="s4">(</span><span class="s1">scoring</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">callable</span><span class="s4">(</span><span class="s1">scoring</span><span class="s4">):</span>
        <span class="s2"># Heuristic to ensure user has not passed a metric</span>
        <span class="s1">module </span><span class="s4">= </span><span class="s1">getattr</span><span class="s4">(</span><span class="s1">scoring</span><span class="s4">, </span><span class="s5">&quot;__module__&quot;</span><span class="s4">, </span><span class="s3">None</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s4">(</span>
            <span class="s1">hasattr</span><span class="s4">(</span><span class="s1">module</span><span class="s4">, </span><span class="s5">&quot;startswith&quot;</span><span class="s4">)</span>
            <span class="s3">and </span><span class="s1">module</span><span class="s4">.</span><span class="s1">startswith</span><span class="s4">(</span><span class="s5">&quot;sklearn.metrics.&quot;</span><span class="s4">)</span>
            <span class="s3">and not </span><span class="s1">module</span><span class="s4">.</span><span class="s1">startswith</span><span class="s4">(</span><span class="s5">&quot;sklearn.metrics._scorer&quot;</span><span class="s4">)</span>
            <span class="s3">and not </span><span class="s1">module</span><span class="s4">.</span><span class="s1">startswith</span><span class="s4">(</span><span class="s5">&quot;sklearn.metrics.tests.&quot;</span><span class="s4">)</span>
        <span class="s4">):</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span>
                <span class="s5">&quot;scoring value %r looks like it is a metric &quot;</span>
                <span class="s5">&quot;function rather than a scorer. A scorer should &quot;</span>
                <span class="s5">&quot;require an estimator as its first parameter. &quot;</span>
                <span class="s5">&quot;Please use `make_scorer` to convert a metric &quot;</span>
                <span class="s5">&quot;to a scorer.&quot; </span><span class="s4">% </span><span class="s1">scoring</span>
            <span class="s4">)</span>
        <span class="s3">return </span><span class="s1">get_scorer</span><span class="s4">(</span><span class="s1">scoring</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">scoring</span><span class="s4">, (</span><span class="s1">list</span><span class="s4">, </span><span class="s1">tuple</span><span class="s4">, </span><span class="s1">set</span><span class="s4">, </span><span class="s1">dict</span><span class="s4">)):</span>
        <span class="s1">scorers </span><span class="s4">= </span><span class="s1">_check_multimetric_scoring</span><span class="s4">(</span><span class="s1">estimator</span><span class="s4">, </span><span class="s1">scoring</span><span class="s4">=</span><span class="s1">scoring</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">_MultimetricScorer</span><span class="s4">(</span><span class="s1">scorers</span><span class="s4">=</span><span class="s1">scorers</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">scoring </span><span class="s3">is None</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">estimator</span><span class="s4">, </span><span class="s5">&quot;score&quot;</span><span class="s4">):</span>
            <span class="s3">return </span><span class="s1">_PassthroughScorer</span><span class="s4">(</span><span class="s1">estimator</span><span class="s4">)</span>
        <span class="s3">elif </span><span class="s1">allow_none</span><span class="s4">:</span>
            <span class="s3">return None</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">TypeError</span><span class="s4">(</span>
                <span class="s5">&quot;If no scoring is specified, the estimator passed should &quot;</span>
                <span class="s5">&quot;have a 'score' method. The estimator %r does not.&quot; </span><span class="s4">% </span><span class="s1">estimator</span>
            <span class="s4">)</span>
</pre>
</body>
</html>