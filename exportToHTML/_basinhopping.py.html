<html>
<head>
<title>_basinhopping.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #6aab73;}
.s5 { color: #2aacb8;}
.s6 { color: #7a7e85;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_basinhopping.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
basinhopping: The basinhopping global optimization algorithm 
&quot;&quot;&quot;</span>
<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">import </span><span class="s1">math</span>
<span class="s2">import </span><span class="s1">inspect</span>
<span class="s2">import </span><span class="s1">scipy</span><span class="s3">.</span><span class="s1">optimize</span>
<span class="s2">from </span><span class="s1">scipy</span><span class="s3">.</span><span class="s1">_lib</span><span class="s3">.</span><span class="s1">_util </span><span class="s2">import </span><span class="s1">check_random_state</span>

<span class="s1">__all__ </span><span class="s3">= [</span><span class="s4">'basinhopping'</span><span class="s3">]</span>


<span class="s1">_params </span><span class="s3">= (</span><span class="s1">inspect</span><span class="s3">.</span><span class="s1">Parameter</span><span class="s3">(</span><span class="s4">'res_new'</span><span class="s3">, </span><span class="s1">kind</span><span class="s3">=</span><span class="s1">inspect</span><span class="s3">.</span><span class="s1">Parameter</span><span class="s3">.</span><span class="s1">KEYWORD_ONLY</span><span class="s3">),</span>
           <span class="s1">inspect</span><span class="s3">.</span><span class="s1">Parameter</span><span class="s3">(</span><span class="s4">'res_old'</span><span class="s3">, </span><span class="s1">kind</span><span class="s3">=</span><span class="s1">inspect</span><span class="s3">.</span><span class="s1">Parameter</span><span class="s3">.</span><span class="s1">KEYWORD_ONLY</span><span class="s3">))</span>
<span class="s1">_new_accept_test_signature </span><span class="s3">= </span><span class="s1">inspect</span><span class="s3">.</span><span class="s1">Signature</span><span class="s3">(</span><span class="s1">parameters</span><span class="s3">=</span><span class="s1">_params</span><span class="s3">)</span>


<span class="s2">class </span><span class="s1">Storage</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot; 
    Class used to store the lowest energy structure 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">minres</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_add</span><span class="s3">(</span><span class="s1">minres</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_add</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">minres</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">minres </span><span class="s3">= </span><span class="s1">minres</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">minres</span><span class="s3">.</span><span class="s1">x </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">(</span><span class="s1">minres</span><span class="s3">.</span><span class="s1">x</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">update</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">minres</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">minres</span><span class="s3">.</span><span class="s1">success </span><span class="s2">and </span><span class="s3">(</span><span class="s1">minres</span><span class="s3">.</span><span class="s1">fun </span><span class="s3">&lt; </span><span class="s1">self</span><span class="s3">.</span><span class="s1">minres</span><span class="s3">.</span><span class="s1">fun</span>
                               <span class="s2">or not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">minres</span><span class="s3">.</span><span class="s1">success</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_add</span><span class="s3">(</span><span class="s1">minres</span><span class="s3">)</span>
            <span class="s2">return True</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">return False</span>

    <span class="s2">def </span><span class="s1">get_lowest</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">minres</span>


<span class="s2">class </span><span class="s1">BasinHoppingRunner</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot;This class implements the core of the basinhopping algorithm. 
 
    x0 : ndarray 
        The starting coordinates. 
    minimizer : callable 
        The local minimizer, with signature ``result = minimizer(x)``. 
        The return value is an `optimize.OptimizeResult` object. 
    step_taking : callable 
        This function displaces the coordinates randomly. Signature should 
        be ``x_new = step_taking(x)``. Note that `x` may be modified in-place. 
    accept_tests : list of callables 
        Each test is passed the kwargs `f_new`, `x_new`, `f_old` and 
        `x_old`. These tests will be used to judge whether or not to accept 
        the step. The acceptable return values are True, False, or ``&quot;force 
        accept&quot;``. If any of the tests return False then the step is rejected. 
        If ``&quot;force accept&quot;``, then this will override any other tests in 
        order to accept the step. This can be used, for example, to forcefully 
        escape from a local minimum that ``basinhopping`` is trapped in. 
    disp : bool, optional 
        Display status messages. 
 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">x0</span><span class="s3">, </span><span class="s1">minimizer</span><span class="s3">, </span><span class="s1">step_taking</span><span class="s3">, </span><span class="s1">accept_tests</span><span class="s3">, </span><span class="s1">disp</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">x </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">(</span><span class="s1">x0</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">minimizer </span><span class="s3">= </span><span class="s1">minimizer</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">step_taking </span><span class="s3">= </span><span class="s1">step_taking</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">accept_tests </span><span class="s3">= </span><span class="s1">accept_tests</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">disp </span><span class="s3">= </span><span class="s1">disp</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">nstep </span><span class="s3">= </span><span class="s5">0</span>

        <span class="s6"># initialize return object</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">res </span><span class="s3">= </span><span class="s1">scipy</span><span class="s3">.</span><span class="s1">optimize</span><span class="s3">.</span><span class="s1">OptimizeResult</span><span class="s3">()</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">res</span><span class="s3">.</span><span class="s1">minimization_failures </span><span class="s3">= </span><span class="s5">0</span>

        <span class="s6"># do initial minimization</span>
        <span class="s1">minres </span><span class="s3">= </span><span class="s1">minimizer</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">x</span><span class="s3">)</span>
        <span class="s2">if not </span><span class="s1">minres</span><span class="s3">.</span><span class="s1">success</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">res</span><span class="s3">.</span><span class="s1">minimization_failures </span><span class="s3">+= </span><span class="s5">1</span>
            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">disp</span><span class="s3">:</span>
                <span class="s1">print</span><span class="s3">(</span><span class="s4">&quot;warning: basinhopping: local minimization failure&quot;</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">x </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">(</span><span class="s1">minres</span><span class="s3">.</span><span class="s1">x</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">energy </span><span class="s3">= </span><span class="s1">minres</span><span class="s3">.</span><span class="s1">fun</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">incumbent_minres </span><span class="s3">= </span><span class="s1">minres  </span><span class="s6"># best minimize result found so far</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">disp</span><span class="s3">:</span>
            <span class="s1">print</span><span class="s3">(</span><span class="s4">&quot;basinhopping step %d: f %g&quot; </span><span class="s3">% (</span><span class="s1">self</span><span class="s3">.</span><span class="s1">nstep</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">energy</span><span class="s3">))</span>

        <span class="s6"># initialize storage class</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">storage </span><span class="s3">= </span><span class="s1">Storage</span><span class="s3">(</span><span class="s1">minres</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">minres</span><span class="s3">, </span><span class="s4">&quot;nfev&quot;</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">res</span><span class="s3">.</span><span class="s1">nfev </span><span class="s3">= </span><span class="s1">minres</span><span class="s3">.</span><span class="s1">nfev</span>
        <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">minres</span><span class="s3">, </span><span class="s4">&quot;njev&quot;</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">res</span><span class="s3">.</span><span class="s1">njev </span><span class="s3">= </span><span class="s1">minres</span><span class="s3">.</span><span class="s1">njev</span>
        <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">minres</span><span class="s3">, </span><span class="s4">&quot;nhev&quot;</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">res</span><span class="s3">.</span><span class="s1">nhev </span><span class="s3">= </span><span class="s1">minres</span><span class="s3">.</span><span class="s1">nhev</span>

    <span class="s2">def </span><span class="s1">_monte_carlo_step</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Do one Monte Carlo iteration 
 
        Randomly displace the coordinates, minimize, and decide whether 
        or not to accept the new coordinates. 
        &quot;&quot;&quot;</span>
        <span class="s6"># Take a random step.  Make a copy of x because the step_taking</span>
        <span class="s6"># algorithm might change x in place</span>
        <span class="s1">x_after_step </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">x</span><span class="s3">)</span>
        <span class="s1">x_after_step </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">step_taking</span><span class="s3">(</span><span class="s1">x_after_step</span><span class="s3">)</span>

        <span class="s6"># do a local minimization</span>
        <span class="s1">minres </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">minimizer</span><span class="s3">(</span><span class="s1">x_after_step</span><span class="s3">)</span>
        <span class="s1">x_after_quench </span><span class="s3">= </span><span class="s1">minres</span><span class="s3">.</span><span class="s1">x</span>
        <span class="s1">energy_after_quench </span><span class="s3">= </span><span class="s1">minres</span><span class="s3">.</span><span class="s1">fun</span>
        <span class="s2">if not </span><span class="s1">minres</span><span class="s3">.</span><span class="s1">success</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">res</span><span class="s3">.</span><span class="s1">minimization_failures </span><span class="s3">+= </span><span class="s5">1</span>
            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">disp</span><span class="s3">:</span>
                <span class="s1">print</span><span class="s3">(</span><span class="s4">&quot;warning: basinhopping: local minimization failure&quot;</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">minres</span><span class="s3">, </span><span class="s4">&quot;nfev&quot;</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">res</span><span class="s3">.</span><span class="s1">nfev </span><span class="s3">+= </span><span class="s1">minres</span><span class="s3">.</span><span class="s1">nfev</span>
        <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">minres</span><span class="s3">, </span><span class="s4">&quot;njev&quot;</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">res</span><span class="s3">.</span><span class="s1">njev </span><span class="s3">+= </span><span class="s1">minres</span><span class="s3">.</span><span class="s1">njev</span>
        <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">minres</span><span class="s3">, </span><span class="s4">&quot;nhev&quot;</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">res</span><span class="s3">.</span><span class="s1">nhev </span><span class="s3">+= </span><span class="s1">minres</span><span class="s3">.</span><span class="s1">nhev</span>

        <span class="s6"># accept the move based on self.accept_tests. If any test is False,</span>
        <span class="s6"># then reject the step.  If any test returns the special string</span>
        <span class="s6"># 'force accept', then accept the step regardless. This can be used</span>
        <span class="s6"># to forcefully escape from a local minimum if normal basin hopping</span>
        <span class="s6"># steps are not sufficient.</span>
        <span class="s1">accept </span><span class="s3">= </span><span class="s2">True</span>
        <span class="s2">for </span><span class="s1">test </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">accept_tests</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">inspect</span><span class="s3">.</span><span class="s1">signature</span><span class="s3">(</span><span class="s1">test</span><span class="s3">) == </span><span class="s1">_new_accept_test_signature</span><span class="s3">:</span>
                <span class="s1">testres </span><span class="s3">= </span><span class="s1">test</span><span class="s3">(</span><span class="s1">res_new</span><span class="s3">=</span><span class="s1">minres</span><span class="s3">, </span><span class="s1">res_old</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">incumbent_minres</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">testres </span><span class="s3">= </span><span class="s1">test</span><span class="s3">(</span><span class="s1">f_new</span><span class="s3">=</span><span class="s1">energy_after_quench</span><span class="s3">, </span><span class="s1">x_new</span><span class="s3">=</span><span class="s1">x_after_quench</span><span class="s3">,</span>
                               <span class="s1">f_old</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">energy</span><span class="s3">, </span><span class="s1">x_old</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">x</span><span class="s3">)</span>

            <span class="s2">if </span><span class="s1">testres </span><span class="s3">== </span><span class="s4">'force accept'</span><span class="s3">:</span>
                <span class="s1">accept </span><span class="s3">= </span><span class="s2">True</span>
                <span class="s2">break</span>
            <span class="s2">elif </span><span class="s1">testres </span><span class="s2">is None</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;accept_tests must return True, False, or &quot;</span>
                                 <span class="s4">&quot;'force accept'&quot;</span><span class="s3">)</span>
            <span class="s2">elif not </span><span class="s1">testres</span><span class="s3">:</span>
                <span class="s1">accept </span><span class="s3">= </span><span class="s2">False</span>

        <span class="s6"># Report the result of the acceptance test to the take step class.</span>
        <span class="s6"># This is for adaptive step taking</span>
        <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">step_taking</span><span class="s3">, </span><span class="s4">&quot;report&quot;</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">step_taking</span><span class="s3">.</span><span class="s1">report</span><span class="s3">(</span><span class="s1">accept</span><span class="s3">, </span><span class="s1">f_new</span><span class="s3">=</span><span class="s1">energy_after_quench</span><span class="s3">,</span>
                                    <span class="s1">x_new</span><span class="s3">=</span><span class="s1">x_after_quench</span><span class="s3">, </span><span class="s1">f_old</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">energy</span><span class="s3">,</span>
                                    <span class="s1">x_old</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">x</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">accept</span><span class="s3">, </span><span class="s1">minres</span>

    <span class="s2">def </span><span class="s1">one_cycle</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Do one cycle of the basinhopping algorithm 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">nstep </span><span class="s3">+= </span><span class="s5">1</span>
        <span class="s1">new_global_min </span><span class="s3">= </span><span class="s2">False</span>

        <span class="s1">accept</span><span class="s3">, </span><span class="s1">minres </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_monte_carlo_step</span><span class="s3">()</span>

        <span class="s2">if </span><span class="s1">accept</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">energy </span><span class="s3">= </span><span class="s1">minres</span><span class="s3">.</span><span class="s1">fun</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">x </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">(</span><span class="s1">minres</span><span class="s3">.</span><span class="s1">x</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">incumbent_minres </span><span class="s3">= </span><span class="s1">minres  </span><span class="s6"># best minimize result found so far</span>
            <span class="s1">new_global_min </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">storage</span><span class="s3">.</span><span class="s1">update</span><span class="s3">(</span><span class="s1">minres</span><span class="s3">)</span>

        <span class="s6"># print some information</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">disp</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">print_report</span><span class="s3">(</span><span class="s1">minres</span><span class="s3">.</span><span class="s1">fun</span><span class="s3">, </span><span class="s1">accept</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">new_global_min</span><span class="s3">:</span>
                <span class="s1">print</span><span class="s3">(</span><span class="s4">&quot;found new global minimum on step %d with function&quot;</span>
                      <span class="s4">&quot; value %g&quot; </span><span class="s3">% (</span><span class="s1">self</span><span class="s3">.</span><span class="s1">nstep</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">energy</span><span class="s3">))</span>

        <span class="s6"># save some variables as BasinHoppingRunner attributes</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">xtrial </span><span class="s3">= </span><span class="s1">minres</span><span class="s3">.</span><span class="s1">x</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">energy_trial </span><span class="s3">= </span><span class="s1">minres</span><span class="s3">.</span><span class="s1">fun</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">accept </span><span class="s3">= </span><span class="s1">accept</span>

        <span class="s2">return </span><span class="s1">new_global_min</span>

    <span class="s2">def </span><span class="s1">print_report</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">energy_trial</span><span class="s3">, </span><span class="s1">accept</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;print a status update&quot;&quot;&quot;</span>
        <span class="s1">minres </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">storage</span><span class="s3">.</span><span class="s1">get_lowest</span><span class="s3">()</span>
        <span class="s1">print</span><span class="s3">(</span><span class="s4">&quot;basinhopping step %d: f %g trial_f %g accepted %d &quot;</span>
              <span class="s4">&quot; lowest_f %g&quot; </span><span class="s3">% (</span><span class="s1">self</span><span class="s3">.</span><span class="s1">nstep</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">energy</span><span class="s3">, </span><span class="s1">energy_trial</span><span class="s3">,</span>
                                <span class="s1">accept</span><span class="s3">, </span><span class="s1">minres</span><span class="s3">.</span><span class="s1">fun</span><span class="s3">))</span>


<span class="s2">class </span><span class="s1">AdaptiveStepsize</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot; 
    Class to implement adaptive stepsize. 
 
    This class wraps the step taking class and modifies the stepsize to 
    ensure the true acceptance rate is as close as possible to the target. 
 
    Parameters 
    ---------- 
    takestep : callable 
        The step taking routine.  Must contain modifiable attribute 
        takestep.stepsize 
    accept_rate : float, optional 
        The target step acceptance rate 
    interval : int, optional 
        Interval for how often to update the stepsize 
    factor : float, optional 
        The step size is multiplied or divided by this factor upon each 
        update. 
    verbose : bool, optional 
        Print information about each update 
 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">takestep</span><span class="s3">, </span><span class="s1">accept_rate</span><span class="s3">=</span><span class="s5">0.5</span><span class="s3">, </span><span class="s1">interval</span><span class="s3">=</span><span class="s5">50</span><span class="s3">, </span><span class="s1">factor</span><span class="s3">=</span><span class="s5">0.9</span><span class="s3">,</span>
                 <span class="s1">verbose</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">takestep </span><span class="s3">= </span><span class="s1">takestep</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">target_accept_rate </span><span class="s3">= </span><span class="s1">accept_rate</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">interval </span><span class="s3">= </span><span class="s1">interval</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">factor </span><span class="s3">= </span><span class="s1">factor</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">verbose </span><span class="s3">= </span><span class="s1">verbose</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">nstep </span><span class="s3">= </span><span class="s5">0</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">nstep_tot </span><span class="s3">= </span><span class="s5">0</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">naccept </span><span class="s3">= </span><span class="s5">0</span>

    <span class="s2">def </span><span class="s1">__call__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">take_step</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_adjust_step_size</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">old_stepsize </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">takestep</span><span class="s3">.</span><span class="s1">stepsize</span>
        <span class="s1">accept_rate </span><span class="s3">= </span><span class="s1">float</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">naccept</span><span class="s3">) / </span><span class="s1">self</span><span class="s3">.</span><span class="s1">nstep</span>
        <span class="s2">if </span><span class="s1">accept_rate </span><span class="s3">&gt; </span><span class="s1">self</span><span class="s3">.</span><span class="s1">target_accept_rate</span><span class="s3">:</span>
            <span class="s6"># We're accepting too many steps. This generally means we're</span>
            <span class="s6"># trapped in a basin. Take bigger steps.</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">takestep</span><span class="s3">.</span><span class="s1">stepsize </span><span class="s3">/= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">factor</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s6"># We're not accepting enough steps. Take smaller steps.</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">takestep</span><span class="s3">.</span><span class="s1">stepsize </span><span class="s3">*= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">factor</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">verbose</span><span class="s3">:</span>
            <span class="s1">print</span><span class="s3">(</span><span class="s4">f&quot;adaptive stepsize: acceptance rate </span><span class="s2">{</span><span class="s1">accept_rate</span><span class="s2">:</span><span class="s4">f</span><span class="s2">} </span><span class="s4">target &quot;</span>
                  <span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">self</span><span class="s3">.</span><span class="s1">target_accept_rate</span><span class="s2">:</span><span class="s4">f</span><span class="s2">} </span><span class="s4">new stepsize &quot;</span>
                  <span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">self</span><span class="s3">.</span><span class="s1">takestep</span><span class="s3">.</span><span class="s1">stepsize</span><span class="s2">:</span><span class="s4">g</span><span class="s2">} </span><span class="s4">old stepsize </span><span class="s2">{</span><span class="s1">old_stepsize</span><span class="s2">:</span><span class="s4">g</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">take_step</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">nstep </span><span class="s3">+= </span><span class="s5">1</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">nstep_tot </span><span class="s3">+= </span><span class="s5">1</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">nstep </span><span class="s3">% </span><span class="s1">self</span><span class="s3">.</span><span class="s1">interval </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_adjust_step_size</span><span class="s3">()</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">takestep</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">report</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">accept</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">):</span>
        <span class="s0">&quot;called by basinhopping to report the result of the step&quot;</span>
        <span class="s2">if </span><span class="s1">accept</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">naccept </span><span class="s3">+= </span><span class="s5">1</span>


<span class="s2">class </span><span class="s1">RandomDisplacement</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot;Add a random displacement of maximum size `stepsize` to each coordinate. 
 
    Calling this updates `x` in-place. 
 
    Parameters 
    ---------- 
    stepsize : float, optional 
        Maximum stepsize in any dimension 
    random_gen : {None, int, `numpy.random.Generator`, 
                  `numpy.random.RandomState`}, optional 
 
        If `seed` is None (or `np.random`), the `numpy.random.RandomState` 
        singleton is used. 
        If `seed` is an int, a new ``RandomState`` instance is used, 
        seeded with `seed`. 
        If `seed` is already a ``Generator`` or ``RandomState`` instance then 
        that instance is used. 
 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">stepsize</span><span class="s3">=</span><span class="s5">0.5</span><span class="s3">, </span><span class="s1">random_gen</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">stepsize </span><span class="s3">= </span><span class="s1">stepsize</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">random_gen </span><span class="s3">= </span><span class="s1">check_random_state</span><span class="s3">(</span><span class="s1">random_gen</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__call__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">):</span>
        <span class="s1">x </span><span class="s3">+= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">random_gen</span><span class="s3">.</span><span class="s1">uniform</span><span class="s3">(-</span><span class="s1">self</span><span class="s3">.</span><span class="s1">stepsize</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">stepsize</span><span class="s3">,</span>
                                     <span class="s1">np</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">(</span><span class="s1">x</span><span class="s3">))</span>
        <span class="s2">return </span><span class="s1">x</span>


<span class="s2">class </span><span class="s1">MinimizerWrapper</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot; 
    wrap a minimizer function as a minimizer class 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">minimizer</span><span class="s3">, </span><span class="s1">func</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">minimizer </span><span class="s3">= </span><span class="s1">minimizer</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">func </span><span class="s3">= </span><span class="s1">func</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">kwargs </span><span class="s3">= </span><span class="s1">kwargs</span>

    <span class="s2">def </span><span class="s1">__call__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">x0</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">func </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">minimizer</span><span class="s3">(</span><span class="s1">x0</span><span class="s3">, **</span><span class="s1">self</span><span class="s3">.</span><span class="s1">kwargs</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">minimizer</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">func</span><span class="s3">, </span><span class="s1">x0</span><span class="s3">, **</span><span class="s1">self</span><span class="s3">.</span><span class="s1">kwargs</span><span class="s3">)</span>


<span class="s2">class </span><span class="s1">Metropolis</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot;Metropolis acceptance criterion. 
 
    Parameters 
    ---------- 
    T : float 
        The &quot;temperature&quot; parameter for the accept or reject criterion. 
    random_gen : {None, int, `numpy.random.Generator`, 
                  `numpy.random.RandomState`}, optional 
 
        If `seed` is None (or `np.random`), the `numpy.random.RandomState` 
        singleton is used. 
        If `seed` is an int, a new ``RandomState`` instance is used, 
        seeded with `seed`. 
        If `seed` is already a ``Generator`` or ``RandomState`` instance then 
        that instance is used. 
        Random number generator used for acceptance test. 
 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">T</span><span class="s3">, </span><span class="s1">random_gen</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s6"># Avoid ZeroDivisionError since &quot;MBH can be regarded as a special case</span>
        <span class="s6"># of the BH framework with the Metropolis criterion, where temperature</span>
        <span class="s6"># T = 0.&quot; (Reject all steps that increase energy.)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">beta </span><span class="s3">= </span><span class="s5">1.0 </span><span class="s3">/ </span><span class="s1">T </span><span class="s2">if </span><span class="s1">T </span><span class="s3">!= </span><span class="s5">0 </span><span class="s2">else </span><span class="s1">float</span><span class="s3">(</span><span class="s4">'inf'</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">random_gen </span><span class="s3">= </span><span class="s1">check_random_state</span><span class="s3">(</span><span class="s1">random_gen</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">accept_reject</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">res_new</span><span class="s3">, </span><span class="s1">res_old</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Assuming the local search underlying res_new was successful: 
        If new energy is lower than old, it will always be accepted. 
        If new is higher than old, there is a chance it will be accepted, 
        less likely for larger differences. 
        &quot;&quot;&quot;</span>
        <span class="s2">with </span><span class="s1">np</span><span class="s3">.</span><span class="s1">errstate</span><span class="s3">(</span><span class="s1">invalid</span><span class="s3">=</span><span class="s4">'ignore'</span><span class="s3">):</span>
            <span class="s6"># The energy values being fed to Metropolis are 1-length arrays, and if</span>
            <span class="s6"># they are equal, their difference is 0, which gets multiplied by beta,</span>
            <span class="s6"># which is inf, and array([0]) * float('inf') causes</span>
            <span class="s6">#</span>
            <span class="s6"># RuntimeWarning: invalid value encountered in multiply</span>
            <span class="s6">#</span>
            <span class="s6"># Ignore this warning so when the algorithm is on a flat plane, it always</span>
            <span class="s6"># accepts the step, to try to move off the plane.</span>
            <span class="s1">prod </span><span class="s3">= -(</span><span class="s1">res_new</span><span class="s3">.</span><span class="s1">fun </span><span class="s3">- </span><span class="s1">res_old</span><span class="s3">.</span><span class="s1">fun</span><span class="s3">) * </span><span class="s1">self</span><span class="s3">.</span><span class="s1">beta</span>
            <span class="s1">w </span><span class="s3">= </span><span class="s1">math</span><span class="s3">.</span><span class="s1">exp</span><span class="s3">(</span><span class="s1">min</span><span class="s3">(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">prod</span><span class="s3">))</span>

        <span class="s1">rand </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">random_gen</span><span class="s3">.</span><span class="s1">uniform</span><span class="s3">()</span>
        <span class="s2">return </span><span class="s1">w </span><span class="s3">&gt;= </span><span class="s1">rand </span><span class="s2">and </span><span class="s3">(</span><span class="s1">res_new</span><span class="s3">.</span><span class="s1">success </span><span class="s2">or not </span><span class="s1">res_old</span><span class="s3">.</span><span class="s1">success</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__call__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, *, </span><span class="s1">res_new</span><span class="s3">, </span><span class="s1">res_old</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        f_new and f_old are mandatory in kwargs 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">bool</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">accept_reject</span><span class="s3">(</span><span class="s1">res_new</span><span class="s3">, </span><span class="s1">res_old</span><span class="s3">))</span>


<span class="s2">def </span><span class="s1">basinhopping</span><span class="s3">(</span><span class="s1">func</span><span class="s3">, </span><span class="s1">x0</span><span class="s3">, </span><span class="s1">niter</span><span class="s3">=</span><span class="s5">100</span><span class="s3">, </span><span class="s1">T</span><span class="s3">=</span><span class="s5">1.0</span><span class="s3">, </span><span class="s1">stepsize</span><span class="s3">=</span><span class="s5">0.5</span><span class="s3">,</span>
                 <span class="s1">minimizer_kwargs</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">take_step</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">accept_test</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
                 <span class="s1">callback</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">interval</span><span class="s3">=</span><span class="s5">50</span><span class="s3">, </span><span class="s1">disp</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">niter_success</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
                 <span class="s1">seed</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, *, </span><span class="s1">target_accept_rate</span><span class="s3">=</span><span class="s5">0.5</span><span class="s3">, </span><span class="s1">stepwise_factor</span><span class="s3">=</span><span class="s5">0.9</span><span class="s3">):</span>
    <span class="s4">&quot;&quot;&quot;Find the global minimum of a function using the basin-hopping algorithm. 
 
    Basin-hopping is a two-phase method that combines a global stepping 
    algorithm with local minimization at each step. Designed to mimic 
    the natural process of energy minimization of clusters of atoms, it works 
    well for similar problems with &quot;funnel-like, but rugged&quot; energy landscapes 
    [5]_. 
 
    As the step-taking, step acceptance, and minimization methods are all 
    customizable, this function can also be used to implement other two-phase 
    methods. 
 
    Parameters 
    ---------- 
    func : callable ``f(x, *args)`` 
        Function to be optimized.  ``args`` can be passed as an optional item 
        in the dict `minimizer_kwargs` 
    x0 : array_like 
        Initial guess. 
    niter : integer, optional 
        The number of basin-hopping iterations. There will be a total of 
        ``niter + 1`` runs of the local minimizer. 
    T : float, optional 
        The &quot;temperature&quot; parameter for the acceptance or rejection criterion. 
        Higher &quot;temperatures&quot; mean that larger jumps in function value will be 
        accepted.  For best results `T` should be comparable to the 
        separation (in function value) between local minima. 
    stepsize : float, optional 
        Maximum step size for use in the random displacement. 
    minimizer_kwargs : dict, optional 
        Extra keyword arguments to be passed to the local minimizer 
        `scipy.optimize.minimize` Some important options could be: 
 
            method : str 
                The minimization method (e.g. ``&quot;L-BFGS-B&quot;``) 
            args : tuple 
                Extra arguments passed to the objective function (`func`) and 
                its derivatives (Jacobian, Hessian). 
 
    take_step : callable ``take_step(x)``, optional 
        Replace the default step-taking routine with this routine. The default 
        step-taking routine is a random displacement of the coordinates, but 
        other step-taking algorithms may be better for some systems. 
        `take_step` can optionally have the attribute ``take_step.stepsize``. 
        If this attribute exists, then `basinhopping` will adjust 
        ``take_step.stepsize`` in order to try to optimize the global minimum 
        search. 
    accept_test : callable, ``accept_test(f_new=f_new, x_new=x_new, f_old=fold, x_old=x_old)``, optional 
        Define a test which will be used to judge whether to accept the 
        step. This will be used in addition to the Metropolis test based on 
        &quot;temperature&quot; `T`. The acceptable return values are True, 
        False, or ``&quot;force accept&quot;``. If any of the tests return False 
        then the step is rejected. If the latter, then this will override any 
        other tests in order to accept the step. This can be used, for example, 
        to forcefully escape from a local minimum that `basinhopping` is 
        trapped in. 
    callback : callable, ``callback(x, f, accept)``, optional 
        A callback function which will be called for all minima found. ``x`` 
        and ``f`` are the coordinates and function value of the trial minimum, 
        and ``accept`` is whether that minimum was accepted. This can 
        be used, for example, to save the lowest N minima found. Also, 
        `callback` can be used to specify a user defined stop criterion by 
        optionally returning True to stop the `basinhopping` routine. 
    interval : integer, optional 
        interval for how often to update the `stepsize` 
    disp : bool, optional 
        Set to True to print status messages 
    niter_success : integer, optional 
        Stop the run if the global minimum candidate remains the same for this 
        number of iterations. 
    seed : {None, int, `numpy.random.Generator`, `numpy.random.RandomState`}, optional 
 
        If `seed` is None (or `np.random`), the `numpy.random.RandomState` 
        singleton is used. 
        If `seed` is an int, a new ``RandomState`` instance is used, 
        seeded with `seed`. 
        If `seed` is already a ``Generator`` or ``RandomState`` instance then 
        that instance is used. 
        Specify `seed` for repeatable minimizations. The random numbers 
        generated with this seed only affect the default Metropolis 
        `accept_test` and the default `take_step`. If you supply your own 
        `take_step` and `accept_test`, and these functions use random 
        number generation, then those functions are responsible for the state 
        of their random number generator. 
    target_accept_rate : float, optional 
        The target acceptance rate that is used to adjust the `stepsize`. 
        If the current acceptance rate is greater than the target, 
        then the `stepsize` is increased. Otherwise, it is decreased. 
        Range is (0, 1). Default is 0.5. 
 
        .. versionadded:: 1.8.0 
 
    stepwise_factor : float, optional 
        The `stepsize` is multiplied or divided by this stepwise factor upon 
        each update. Range is (0, 1). Default is 0.9. 
 
        .. versionadded:: 1.8.0 
 
    Returns 
    ------- 
    res : OptimizeResult 
        The optimization result represented as a `OptimizeResult` object. 
        Important attributes are: ``x`` the solution array, ``fun`` the value 
        of the function at the solution, and ``message`` which describes the 
        cause of the termination. The ``OptimizeResult`` object returned by the 
        selected minimizer at the lowest minimum is also contained within this 
        object and can be accessed through the ``lowest_optimization_result`` 
        attribute.  See `OptimizeResult` for a description of other attributes. 
 
    See Also 
    -------- 
    minimize : 
        The local minimization function called once for each basinhopping step. 
        `minimizer_kwargs` is passed to this routine. 
 
    Notes 
    ----- 
    Basin-hopping is a stochastic algorithm which attempts to find the global 
    minimum of a smooth scalar function of one or more variables [1]_ [2]_ [3]_ 
    [4]_. The algorithm in its current form was described by David Wales and 
    Jonathan Doye [2]_ http://www-wales.ch.cam.ac.uk/. 
 
    The algorithm is iterative with each cycle composed of the following 
    features 
 
    1) random perturbation of the coordinates 
 
    2) local minimization 
 
    3) accept or reject the new coordinates based on the minimized function 
       value 
 
    The acceptance test used here is the Metropolis criterion of standard Monte 
    Carlo algorithms, although there are many other possibilities [3]_. 
 
    This global minimization method has been shown to be extremely efficient 
    for a wide variety of problems in physics and chemistry. It is 
    particularly useful when the function has many minima separated by large 
    barriers. See the `Cambridge Cluster Database 
    &lt;https://www-wales.ch.cam.ac.uk/CCD.html&gt;`_ for databases of molecular 
    systems that have been optimized primarily using basin-hopping. This 
    database includes minimization problems exceeding 300 degrees of freedom. 
 
    See the free software program `GMIN &lt;https://www-wales.ch.cam.ac.uk/GMIN&gt;`_ 
    for a Fortran implementation of basin-hopping. This implementation has many 
    variations of the procedure described above, including more 
    advanced step taking algorithms and alternate acceptance criterion. 
 
    For stochastic global optimization there is no way to determine if the true 
    global minimum has actually been found. Instead, as a consistency check, 
    the algorithm can be run from a number of different random starting points 
    to ensure the lowest minimum found in each example has converged to the 
    global minimum. For this reason, `basinhopping` will by default simply 
    run for the number of iterations `niter` and return the lowest minimum 
    found. It is left to the user to ensure that this is in fact the global 
    minimum. 
 
    Choosing `stepsize`:  This is a crucial parameter in `basinhopping` and 
    depends on the problem being solved. The step is chosen uniformly in the 
    region from x0-stepsize to x0+stepsize, in each dimension. Ideally, it 
    should be comparable to the typical separation (in argument values) between 
    local minima of the function being optimized. `basinhopping` will, by 
    default, adjust `stepsize` to find an optimal value, but this may take 
    many iterations. You will get quicker results if you set a sensible 
    initial value for ``stepsize``. 
 
    Choosing `T`: The parameter `T` is the &quot;temperature&quot; used in the 
    Metropolis criterion. Basinhopping steps are always accepted if 
    ``func(xnew) &lt; func(xold)``. Otherwise, they are accepted with 
    probability:: 
 
        exp( -(func(xnew) - func(xold)) / T ) 
 
    So, for best results, `T` should to be comparable to the typical 
    difference (in function values) between local minima. (The height of 
    &quot;walls&quot; between local minima is irrelevant.) 
 
    If `T` is 0, the algorithm becomes Monotonic Basin-Hopping, in which all 
    steps that increase energy are rejected. 
 
    .. versionadded:: 0.12.0 
 
    References 
    ---------- 
    .. [1] Wales, David J. 2003, Energy Landscapes, Cambridge University Press, 
        Cambridge, UK. 
    .. [2] Wales, D J, and Doye J P K, Global Optimization by Basin-Hopping and 
        the Lowest Energy Structures of Lennard-Jones Clusters Containing up to 
        110 Atoms.  Journal of Physical Chemistry A, 1997, 101, 5111. 
    .. [3] Li, Z. and Scheraga, H. A., Monte Carlo-minimization approach to the 
        multiple-minima problem in protein folding, Proc. Natl. Acad. Sci. USA, 
        1987, 84, 6611. 
    .. [4] Wales, D. J. and Scheraga, H. A., Global optimization of clusters, 
        crystals, and biomolecules, Science, 1999, 285, 1368. 
    .. [5] Olson, B., Hashmi, I., Molloy, K., and Shehu1, A., Basin Hopping as 
        a General and Versatile Optimization Framework for the Characterization 
        of Biological Macromolecules, Advances in Artificial Intelligence, 
        Volume 2012 (2012), Article ID 674832, :doi:`10.1155/2012/674832` 
 
    Examples 
    -------- 
    The following example is a 1-D minimization problem, with many 
    local minima superimposed on a parabola. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.optimize import basinhopping 
    &gt;&gt;&gt; func = lambda x: np.cos(14.5 * x - 0.3) + (x + 0.2) * x 
    &gt;&gt;&gt; x0 = [1.] 
 
    Basinhopping, internally, uses a local minimization algorithm. We will use 
    the parameter `minimizer_kwargs` to tell basinhopping which algorithm to 
    use and how to set up that minimizer. This parameter will be passed to 
    `scipy.optimize.minimize`. 
 
    &gt;&gt;&gt; minimizer_kwargs = {&quot;method&quot;: &quot;BFGS&quot;} 
    &gt;&gt;&gt; ret = basinhopping(func, x0, minimizer_kwargs=minimizer_kwargs, 
    ...                    niter=200) 
    &gt;&gt;&gt; # the global minimum is: 
    &gt;&gt;&gt; ret.x, ret.fun 
    -0.1951, -1.0009 
 
    Next consider a 2-D minimization problem. Also, this time, we 
    will use gradient information to significantly speed up the search. 
 
    &gt;&gt;&gt; def func2d(x): 
    ...     f = np.cos(14.5 * x[0] - 0.3) + (x[1] + 0.2) * x[1] + (x[0] + 
    ...                                                            0.2) * x[0] 
    ...     df = np.zeros(2) 
    ...     df[0] = -14.5 * np.sin(14.5 * x[0] - 0.3) + 2. * x[0] + 0.2 
    ...     df[1] = 2. * x[1] + 0.2 
    ...     return f, df 
 
    We'll also use a different local minimization algorithm. Also, we must tell 
    the minimizer that our function returns both energy and gradient (Jacobian). 
 
    &gt;&gt;&gt; minimizer_kwargs = {&quot;method&quot;:&quot;L-BFGS-B&quot;, &quot;jac&quot;:True} 
    &gt;&gt;&gt; x0 = [1.0, 1.0] 
    &gt;&gt;&gt; ret = basinhopping(func2d, x0, minimizer_kwargs=minimizer_kwargs, 
    ...                    niter=200) 
    &gt;&gt;&gt; print(&quot;global minimum: x = [%.4f, %.4f], f(x) = %.4f&quot; % (ret.x[0], 
    ...                                                           ret.x[1], 
    ...                                                           ret.fun)) 
    global minimum: x = [-0.1951, -0.1000], f(x) = -1.0109 
 
    Here is an example using a custom step-taking routine. Imagine you want 
    the first coordinate to take larger steps than the rest of the coordinates. 
    This can be implemented like so: 
 
    &gt;&gt;&gt; class MyTakeStep: 
    ...    def __init__(self, stepsize=0.5): 
    ...        self.stepsize = stepsize 
    ...        self.rng = np.random.default_rng() 
    ...    def __call__(self, x): 
    ...        s = self.stepsize 
    ...        x[0] += self.rng.uniform(-2.*s, 2.*s) 
    ...        x[1:] += self.rng.uniform(-s, s, x[1:].shape) 
    ...        return x 
 
    Since ``MyTakeStep.stepsize`` exists basinhopping will adjust the magnitude 
    of `stepsize` to optimize the search. We'll use the same 2-D function as 
    before 
 
    &gt;&gt;&gt; mytakestep = MyTakeStep() 
    &gt;&gt;&gt; ret = basinhopping(func2d, x0, minimizer_kwargs=minimizer_kwargs, 
    ...                    niter=200, take_step=mytakestep) 
    &gt;&gt;&gt; print(&quot;global minimum: x = [%.4f, %.4f], f(x) = %.4f&quot; % (ret.x[0], 
    ...                                                           ret.x[1], 
    ...                                                           ret.fun)) 
    global minimum: x = [-0.1951, -0.1000], f(x) = -1.0109 
 
    Now, let's do an example using a custom callback function which prints the 
    value of every minimum found 
 
    &gt;&gt;&gt; def print_fun(x, f, accepted): 
    ...         print(&quot;at minimum %.4f accepted %d&quot; % (f, int(accepted))) 
 
    We'll run it for only 10 basinhopping steps this time. 
 
    &gt;&gt;&gt; rng = np.random.default_rng() 
    &gt;&gt;&gt; ret = basinhopping(func2d, x0, minimizer_kwargs=minimizer_kwargs, 
    ...                    niter=10, callback=print_fun, seed=rng) 
    at minimum 0.4159 accepted 1 
    at minimum -0.4317 accepted 1 
    at minimum -1.0109 accepted 1 
    at minimum -0.9073 accepted 1 
    at minimum -0.4317 accepted 0 
    at minimum -0.1021 accepted 1 
    at minimum -0.7425 accepted 1 
    at minimum -0.9073 accepted 1 
    at minimum -0.4317 accepted 0 
    at minimum -0.7425 accepted 1 
    at minimum -0.9073 accepted 1 
 
    The minimum at -1.0109 is actually the global minimum, found already on the 
    8th iteration. 
 
    &quot;&quot;&quot; </span><span class="s6"># numpy/numpydoc#87  # noqa: E501</span>
    <span class="s2">if </span><span class="s1">target_accept_rate </span><span class="s3">&lt;= </span><span class="s5">0. </span><span class="s2">or </span><span class="s1">target_accept_rate </span><span class="s3">&gt;= </span><span class="s5">1.</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'target_accept_rate has to be in range (0, 1)'</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">stepwise_factor </span><span class="s3">&lt;= </span><span class="s5">0. </span><span class="s2">or </span><span class="s1">stepwise_factor </span><span class="s3">&gt;= </span><span class="s5">1.</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'stepwise_factor has to be in range (0, 1)'</span><span class="s3">)</span>

    <span class="s1">x0 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">x0</span><span class="s3">)</span>

    <span class="s6"># set up the np.random generator</span>
    <span class="s1">rng </span><span class="s3">= </span><span class="s1">check_random_state</span><span class="s3">(</span><span class="s1">seed</span><span class="s3">)</span>

    <span class="s6"># set up minimizer</span>
    <span class="s2">if </span><span class="s1">minimizer_kwargs </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">minimizer_kwargs </span><span class="s3">= </span><span class="s1">dict</span><span class="s3">()</span>
    <span class="s1">wrapped_minimizer </span><span class="s3">= </span><span class="s1">MinimizerWrapper</span><span class="s3">(</span><span class="s1">scipy</span><span class="s3">.</span><span class="s1">optimize</span><span class="s3">.</span><span class="s1">minimize</span><span class="s3">, </span><span class="s1">func</span><span class="s3">,</span>
                                         <span class="s3">**</span><span class="s1">minimizer_kwargs</span><span class="s3">)</span>

    <span class="s6"># set up step-taking algorithm</span>
    <span class="s2">if </span><span class="s1">take_step </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s2">if not </span><span class="s1">callable</span><span class="s3">(</span><span class="s1">take_step</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s4">&quot;take_step must be callable&quot;</span><span class="s3">)</span>
        <span class="s6"># if take_step.stepsize exists then use AdaptiveStepsize to control</span>
        <span class="s6"># take_step.stepsize</span>
        <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">take_step</span><span class="s3">, </span><span class="s4">&quot;stepsize&quot;</span><span class="s3">):</span>
            <span class="s1">take_step_wrapped </span><span class="s3">= </span><span class="s1">AdaptiveStepsize</span><span class="s3">(</span>
                <span class="s1">take_step</span><span class="s3">, </span><span class="s1">interval</span><span class="s3">=</span><span class="s1">interval</span><span class="s3">,</span>
                <span class="s1">accept_rate</span><span class="s3">=</span><span class="s1">target_accept_rate</span><span class="s3">,</span>
                <span class="s1">factor</span><span class="s3">=</span><span class="s1">stepwise_factor</span><span class="s3">,</span>
                <span class="s1">verbose</span><span class="s3">=</span><span class="s1">disp</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">take_step_wrapped </span><span class="s3">= </span><span class="s1">take_step</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s6"># use default</span>
        <span class="s1">displace </span><span class="s3">= </span><span class="s1">RandomDisplacement</span><span class="s3">(</span><span class="s1">stepsize</span><span class="s3">=</span><span class="s1">stepsize</span><span class="s3">, </span><span class="s1">random_gen</span><span class="s3">=</span><span class="s1">rng</span><span class="s3">)</span>
        <span class="s1">take_step_wrapped </span><span class="s3">= </span><span class="s1">AdaptiveStepsize</span><span class="s3">(</span><span class="s1">displace</span><span class="s3">, </span><span class="s1">interval</span><span class="s3">=</span><span class="s1">interval</span><span class="s3">,</span>
                                             <span class="s1">accept_rate</span><span class="s3">=</span><span class="s1">target_accept_rate</span><span class="s3">,</span>
                                             <span class="s1">factor</span><span class="s3">=</span><span class="s1">stepwise_factor</span><span class="s3">,</span>
                                             <span class="s1">verbose</span><span class="s3">=</span><span class="s1">disp</span><span class="s3">)</span>

    <span class="s6"># set up accept tests</span>
    <span class="s1">accept_tests </span><span class="s3">= []</span>
    <span class="s2">if </span><span class="s1">accept_test </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s2">if not </span><span class="s1">callable</span><span class="s3">(</span><span class="s1">accept_test</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s4">&quot;accept_test must be callable&quot;</span><span class="s3">)</span>
        <span class="s1">accept_tests </span><span class="s3">= [</span><span class="s1">accept_test</span><span class="s3">]</span>

    <span class="s6"># use default</span>
    <span class="s1">metropolis </span><span class="s3">= </span><span class="s1">Metropolis</span><span class="s3">(</span><span class="s1">T</span><span class="s3">, </span><span class="s1">random_gen</span><span class="s3">=</span><span class="s1">rng</span><span class="s3">)</span>
    <span class="s1">accept_tests</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">metropolis</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">niter_success </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">niter_success </span><span class="s3">= </span><span class="s1">niter </span><span class="s3">+ </span><span class="s5">2</span>

    <span class="s1">bh </span><span class="s3">= </span><span class="s1">BasinHoppingRunner</span><span class="s3">(</span><span class="s1">x0</span><span class="s3">, </span><span class="s1">wrapped_minimizer</span><span class="s3">, </span><span class="s1">take_step_wrapped</span><span class="s3">,</span>
                            <span class="s1">accept_tests</span><span class="s3">, </span><span class="s1">disp</span><span class="s3">=</span><span class="s1">disp</span><span class="s3">)</span>

    <span class="s6"># The wrapped minimizer is called once during construction of</span>
    <span class="s6"># BasinHoppingRunner, so run the callback</span>
    <span class="s2">if </span><span class="s1">callable</span><span class="s3">(</span><span class="s1">callback</span><span class="s3">):</span>
        <span class="s1">callback</span><span class="s3">(</span><span class="s1">bh</span><span class="s3">.</span><span class="s1">storage</span><span class="s3">.</span><span class="s1">minres</span><span class="s3">.</span><span class="s1">x</span><span class="s3">, </span><span class="s1">bh</span><span class="s3">.</span><span class="s1">storage</span><span class="s3">.</span><span class="s1">minres</span><span class="s3">.</span><span class="s1">fun</span><span class="s3">, </span><span class="s2">True</span><span class="s3">)</span>

    <span class="s6"># start main iteration loop</span>
    <span class="s1">count</span><span class="s3">, </span><span class="s1">i </span><span class="s3">= </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span>
    <span class="s1">message </span><span class="s3">= [</span><span class="s4">&quot;requested number of basinhopping iterations completed&quot;</span>
               <span class="s4">&quot; successfully&quot;</span><span class="s3">]</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">niter</span><span class="s3">):</span>
        <span class="s1">new_global_min </span><span class="s3">= </span><span class="s1">bh</span><span class="s3">.</span><span class="s1">one_cycle</span><span class="s3">()</span>

        <span class="s2">if </span><span class="s1">callable</span><span class="s3">(</span><span class="s1">callback</span><span class="s3">):</span>
            <span class="s6"># should we pass a copy of x?</span>
            <span class="s1">val </span><span class="s3">= </span><span class="s1">callback</span><span class="s3">(</span><span class="s1">bh</span><span class="s3">.</span><span class="s1">xtrial</span><span class="s3">, </span><span class="s1">bh</span><span class="s3">.</span><span class="s1">energy_trial</span><span class="s3">, </span><span class="s1">bh</span><span class="s3">.</span><span class="s1">accept</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">val </span><span class="s2">is not None</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">val</span><span class="s3">:</span>
                    <span class="s1">message </span><span class="s3">= [</span><span class="s4">&quot;callback function requested stop early by&quot;</span>
                               <span class="s4">&quot;returning True&quot;</span><span class="s3">]</span>
                    <span class="s2">break</span>

        <span class="s1">count </span><span class="s3">+= </span><span class="s5">1</span>
        <span class="s2">if </span><span class="s1">new_global_min</span><span class="s3">:</span>
            <span class="s1">count </span><span class="s3">= </span><span class="s5">0</span>
        <span class="s2">elif </span><span class="s1">count </span><span class="s3">&gt; </span><span class="s1">niter_success</span><span class="s3">:</span>
            <span class="s1">message </span><span class="s3">= [</span><span class="s4">&quot;success condition satisfied&quot;</span><span class="s3">]</span>
            <span class="s2">break</span>

    <span class="s6"># prepare return object</span>
    <span class="s1">res </span><span class="s3">= </span><span class="s1">bh</span><span class="s3">.</span><span class="s1">res</span>
    <span class="s1">res</span><span class="s3">.</span><span class="s1">lowest_optimization_result </span><span class="s3">= </span><span class="s1">bh</span><span class="s3">.</span><span class="s1">storage</span><span class="s3">.</span><span class="s1">get_lowest</span><span class="s3">()</span>
    <span class="s1">res</span><span class="s3">.</span><span class="s1">x </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">(</span><span class="s1">res</span><span class="s3">.</span><span class="s1">lowest_optimization_result</span><span class="s3">.</span><span class="s1">x</span><span class="s3">)</span>
    <span class="s1">res</span><span class="s3">.</span><span class="s1">fun </span><span class="s3">= </span><span class="s1">res</span><span class="s3">.</span><span class="s1">lowest_optimization_result</span><span class="s3">.</span><span class="s1">fun</span>
    <span class="s1">res</span><span class="s3">.</span><span class="s1">message </span><span class="s3">= </span><span class="s1">message</span>
    <span class="s1">res</span><span class="s3">.</span><span class="s1">nit </span><span class="s3">= </span><span class="s1">i </span><span class="s3">+ </span><span class="s5">1</span>
    <span class="s1">res</span><span class="s3">.</span><span class="s1">success </span><span class="s3">= </span><span class="s1">res</span><span class="s3">.</span><span class="s1">lowest_optimization_result</span><span class="s3">.</span><span class="s1">success</span>
    <span class="s2">return </span><span class="s1">res</span>
</pre>
</body>
</html>