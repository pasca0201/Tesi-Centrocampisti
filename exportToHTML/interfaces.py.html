<html>
<head>
<title>interfaces.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #5f826b; font-style: italic;}
.s3 { color: #cf8e6d;}
.s4 { color: #bcbec4;}
.s5 { color: #6aab73;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
interfaces.py</font>
</center></td></tr></table>
<pre><span class="s0"># engine/interfaces.py</span>
<span class="s0"># Copyright (C) 2005-2024 the SQLAlchemy authors and contributors</span>
<span class="s0"># &lt;see AUTHORS file&gt;</span>
<span class="s0">#</span>
<span class="s0"># This module is part of SQLAlchemy and is released under</span>
<span class="s0"># the MIT License: https://www.opensource.org/licenses/mit-license.php</span>

<span class="s2">&quot;&quot;&quot;Define core interfaces used by the engine system.&quot;&quot;&quot;</span>

<span class="s3">from </span><span class="s1">__future__ </span><span class="s3">import </span><span class="s1">annotations</span>

<span class="s3">from </span><span class="s1">enum </span><span class="s3">import </span><span class="s1">Enum</span>
<span class="s3">from </span><span class="s1">types </span><span class="s3">import </span><span class="s1">ModuleType</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Any</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Awaitable</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Callable</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">ClassVar</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Collection</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Dict</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Iterable</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Iterator</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">List</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Mapping</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">MutableMapping</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Optional</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Sequence</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Set</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Tuple</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Type</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">TYPE_CHECKING</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">TypeVar</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Union</span>

<span class="s3">from </span><span class="s4">.. </span><span class="s3">import </span><span class="s1">util</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">event </span><span class="s3">import </span><span class="s1">EventTarget</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">pool </span><span class="s3">import </span><span class="s1">Pool</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">pool </span><span class="s3">import </span><span class="s1">PoolProxiedConnection</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">compiler </span><span class="s3">import </span><span class="s1">Compiled </span><span class="s3">as </span><span class="s1">Compiled</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">compiler </span><span class="s3">import </span><span class="s1">Compiled  </span><span class="s0"># noqa</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">compiler </span><span class="s3">import </span><span class="s1">TypeCompiler </span><span class="s3">as </span><span class="s1">TypeCompiler</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">compiler </span><span class="s3">import </span><span class="s1">TypeCompiler  </span><span class="s0"># noqa</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">util </span><span class="s3">import </span><span class="s1">immutabledict</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">util</span><span class="s4">.</span><span class="s1">concurrency </span><span class="s3">import </span><span class="s1">await_only</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">util</span><span class="s4">.</span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Literal</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">util</span><span class="s4">.</span><span class="s1">typing </span><span class="s3">import </span><span class="s1">NotRequired</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">util</span><span class="s4">.</span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Protocol</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">util</span><span class="s4">.</span><span class="s1">typing </span><span class="s3">import </span><span class="s1">TypedDict</span>

<span class="s3">if </span><span class="s1">TYPE_CHECKING</span><span class="s4">:</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">base </span><span class="s3">import </span><span class="s1">Connection</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">base </span><span class="s3">import </span><span class="s1">Engine</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">cursor </span><span class="s3">import </span><span class="s1">CursorResult</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">url </span><span class="s3">import </span><span class="s1">URL</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">event </span><span class="s3">import </span><span class="s1">_ListenerFnType</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">event </span><span class="s3">import </span><span class="s1">dispatcher</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">exc </span><span class="s3">import </span><span class="s1">StatementError</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">sql </span><span class="s3">import </span><span class="s1">Executable</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">compiler </span><span class="s3">import </span><span class="s1">_InsertManyValuesBatch</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">compiler </span><span class="s3">import </span><span class="s1">DDLCompiler</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">compiler </span><span class="s3">import </span><span class="s1">IdentifierPreparer</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">compiler </span><span class="s3">import </span><span class="s1">InsertmanyvaluesSentinelOpts</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">compiler </span><span class="s3">import </span><span class="s1">Linting</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">compiler </span><span class="s3">import </span><span class="s1">SQLCompiler</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">elements </span><span class="s3">import </span><span class="s1">BindParameter</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">elements </span><span class="s3">import </span><span class="s1">ClauseElement</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">schema </span><span class="s3">import </span><span class="s1">Column</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">schema </span><span class="s3">import </span><span class="s1">DefaultGenerator</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">schema </span><span class="s3">import </span><span class="s1">SchemaItem</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">schema </span><span class="s3">import </span><span class="s1">Sequence </span><span class="s3">as </span><span class="s1">Sequence_SchemaItem</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">sqltypes </span><span class="s3">import </span><span class="s1">Integer</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">type_api </span><span class="s3">import </span><span class="s1">_TypeMemoDict</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">type_api </span><span class="s3">import </span><span class="s1">TypeEngine</span>

<span class="s1">ConnectArgsType </span><span class="s4">= </span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">Sequence</span><span class="s4">[</span><span class="s1">str</span><span class="s4">], </span><span class="s1">MutableMapping</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">Any</span><span class="s4">]]</span>

<span class="s1">_T </span><span class="s4">= </span><span class="s1">TypeVar</span><span class="s4">(</span><span class="s5">&quot;_T&quot;</span><span class="s4">, </span><span class="s1">bound</span><span class="s4">=</span><span class="s5">&quot;Any&quot;</span><span class="s4">)</span>


<span class="s3">class </span><span class="s1">CacheStats</span><span class="s4">(</span><span class="s1">Enum</span><span class="s4">):</span>
    <span class="s1">CACHE_HIT </span><span class="s4">= </span><span class="s6">0</span>
    <span class="s1">CACHE_MISS </span><span class="s4">= </span><span class="s6">1</span>
    <span class="s1">CACHING_DISABLED </span><span class="s4">= </span><span class="s6">2</span>
    <span class="s1">NO_CACHE_KEY </span><span class="s4">= </span><span class="s6">3</span>
    <span class="s1">NO_DIALECT_SUPPORT </span><span class="s4">= </span><span class="s6">4</span>


<span class="s3">class </span><span class="s1">ExecuteStyle</span><span class="s4">(</span><span class="s1">Enum</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;indicates the :term:`DBAPI` cursor method that will be used to invoke 
    a statement.&quot;&quot;&quot;</span>

    <span class="s1">EXECUTE </span><span class="s4">= </span><span class="s6">0</span>
    <span class="s5">&quot;&quot;&quot;indicates cursor.execute() will be used&quot;&quot;&quot;</span>

    <span class="s1">EXECUTEMANY </span><span class="s4">= </span><span class="s6">1</span>
    <span class="s5">&quot;&quot;&quot;indicates cursor.executemany() will be used.&quot;&quot;&quot;</span>

    <span class="s1">INSERTMANYVALUES </span><span class="s4">= </span><span class="s6">2</span>
    <span class="s5">&quot;&quot;&quot;indicates cursor.execute() will be used with an INSERT where the 
    VALUES expression will be expanded to accommodate for multiple 
    parameter sets 
 
    .. seealso:: 
 
        :ref:`engine_insertmanyvalues` 
 
    &quot;&quot;&quot;</span>


<span class="s3">class </span><span class="s1">DBAPIConnection</span><span class="s4">(</span><span class="s1">Protocol</span><span class="s4">):</span>
    <span class="s5">&quot;&quot;&quot;protocol representing a :pep:`249` database connection. 
 
    .. versionadded:: 2.0 
 
    .. seealso:: 
 
        `Connection Objects &lt;https://www.python.org/dev/peps/pep-0249/#connection-objects&gt;`_ 
        - in :pep:`249` 
 
    &quot;&quot;&quot;  </span><span class="s0"># noqa: E501</span>

    <span class="s3">def </span><span class="s1">close</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">: ...</span>

    <span class="s3">def </span><span class="s1">commit</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">: ...</span>

    <span class="s3">def </span><span class="s1">cursor</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; DBAPICursor</span><span class="s4">: ...</span>

    <span class="s3">def </span><span class="s1">rollback</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">: ...</span>

    <span class="s1">autocommit</span><span class="s4">: </span><span class="s1">bool</span>


<span class="s3">class </span><span class="s1">DBAPIType</span><span class="s4">(</span><span class="s1">Protocol</span><span class="s4">):</span>
    <span class="s5">&quot;&quot;&quot;protocol representing a :pep:`249` database type. 
 
    .. versionadded:: 2.0 
 
    .. seealso:: 
 
        `Type Objects &lt;https://www.python.org/dev/peps/pep-0249/#type-objects&gt;`_ 
        - in :pep:`249` 
 
    &quot;&quot;&quot;  </span><span class="s0"># noqa: E501</span>


<span class="s3">class </span><span class="s1">DBAPICursor</span><span class="s4">(</span><span class="s1">Protocol</span><span class="s4">):</span>
    <span class="s5">&quot;&quot;&quot;protocol representing a :pep:`249` database cursor. 
 
    .. versionadded:: 2.0 
 
    .. seealso:: 
 
        `Cursor Objects &lt;https://www.python.org/dev/peps/pep-0249/#cursor-objects&gt;`_ 
        - in :pep:`249` 
 
    &quot;&quot;&quot;  </span><span class="s0"># noqa: E501</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">description</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; _DBAPICursorDescription</span><span class="s4">:</span>
        <span class="s5">&quot;&quot;&quot;The description attribute of the Cursor. 
 
        .. seealso:: 
 
            `cursor.description &lt;https://www.python.org/dev/peps/pep-0249/#description&gt;`_ 
            - in :pep:`249` 
 
 
        &quot;&quot;&quot;  </span><span class="s0"># noqa: E501</span>
        <span class="s4">...</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">rowcount</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; int</span><span class="s4">: ...</span>

    <span class="s1">arraysize</span><span class="s4">: </span><span class="s1">int</span>

    <span class="s1">lastrowid</span><span class="s4">: </span><span class="s1">int</span>

    <span class="s3">def </span><span class="s1">close</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">: ...</span>

    <span class="s3">def </span><span class="s1">execute</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">operation</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
        <span class="s1">parameters</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_DBAPISingleExecuteParams</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; Any</span><span class="s4">: ...</span>

    <span class="s3">def </span><span class="s1">executemany</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">operation</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
        <span class="s1">parameters</span><span class="s4">: </span><span class="s1">_DBAPIMultiExecuteParams</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; Any</span><span class="s4">: ...</span>

    <span class="s3">def </span><span class="s1">fetchone</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Optional</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]: ...</span>

    <span class="s3">def </span><span class="s1">fetchmany</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">size</span><span class="s4">: </span><span class="s1">int </span><span class="s4">= ...) </span><span class="s1">-&gt; Sequence</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]: ...</span>

    <span class="s3">def </span><span class="s1">fetchall</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Sequence</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]: ...</span>

    <span class="s3">def </span><span class="s1">setinputsizes</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">sizes</span><span class="s4">: </span><span class="s1">Sequence</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">: ...</span>

    <span class="s3">def </span><span class="s1">setoutputsize</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">size</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">, </span><span class="s1">column</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">: ...</span>

    <span class="s3">def </span><span class="s1">callproc</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">procname</span><span class="s4">: </span><span class="s1">str</span><span class="s4">, </span><span class="s1">parameters</span><span class="s4">: </span><span class="s1">Sequence</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">] = ...</span>
    <span class="s4">) </span><span class="s1">-&gt; Any</span><span class="s4">: ...</span>

    <span class="s3">def </span><span class="s1">nextset</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Optional</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">]: ...</span>

    <span class="s3">def </span><span class="s1">__getattr__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">key</span><span class="s4">: </span><span class="s1">str</span><span class="s4">) </span><span class="s1">-&gt; Any</span><span class="s4">: ...</span>


<span class="s1">_CoreSingleExecuteParams </span><span class="s4">= </span><span class="s1">Mapping</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">Any</span><span class="s4">]</span>
<span class="s1">_MutableCoreSingleExecuteParams </span><span class="s4">= </span><span class="s1">MutableMapping</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">Any</span><span class="s4">]</span>
<span class="s1">_CoreMultiExecuteParams </span><span class="s4">= </span><span class="s1">Sequence</span><span class="s4">[</span><span class="s1">_CoreSingleExecuteParams</span><span class="s4">]</span>
<span class="s1">_CoreAnyExecuteParams </span><span class="s4">= </span><span class="s1">Union</span><span class="s4">[</span>
    <span class="s1">_CoreMultiExecuteParams</span><span class="s4">, </span><span class="s1">_CoreSingleExecuteParams</span>
<span class="s4">]</span>

<span class="s1">_DBAPISingleExecuteParams </span><span class="s4">= </span><span class="s1">Union</span><span class="s4">[</span><span class="s1">Sequence</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">], </span><span class="s1">_CoreSingleExecuteParams</span><span class="s4">]</span>

<span class="s1">_DBAPIMultiExecuteParams </span><span class="s4">= </span><span class="s1">Union</span><span class="s4">[</span>
    <span class="s1">Sequence</span><span class="s4">[</span><span class="s1">Sequence</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]], </span><span class="s1">_CoreMultiExecuteParams</span>
<span class="s4">]</span>
<span class="s1">_DBAPIAnyExecuteParams </span><span class="s4">= </span><span class="s1">Union</span><span class="s4">[</span>
    <span class="s1">_DBAPIMultiExecuteParams</span><span class="s4">, </span><span class="s1">_DBAPISingleExecuteParams</span>
<span class="s4">]</span>
<span class="s1">_DBAPICursorDescription </span><span class="s4">= </span><span class="s1">Sequence</span><span class="s4">[</span>
    <span class="s1">Tuple</span><span class="s4">[</span>
        <span class="s1">str</span><span class="s4">,</span>
        <span class="s5">&quot;DBAPIType&quot;</span><span class="s4">,</span>
        <span class="s1">Optional</span><span class="s4">[</span><span class="s1">int</span><span class="s4">],</span>
        <span class="s1">Optional</span><span class="s4">[</span><span class="s1">int</span><span class="s4">],</span>
        <span class="s1">Optional</span><span class="s4">[</span><span class="s1">int</span><span class="s4">],</span>
        <span class="s1">Optional</span><span class="s4">[</span><span class="s1">int</span><span class="s4">],</span>
        <span class="s1">Optional</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">],</span>
    <span class="s4">]</span>
<span class="s4">]</span>

<span class="s1">_AnySingleExecuteParams </span><span class="s4">= </span><span class="s1">_DBAPISingleExecuteParams</span>
<span class="s1">_AnyMultiExecuteParams </span><span class="s4">= </span><span class="s1">_DBAPIMultiExecuteParams</span>
<span class="s1">_AnyExecuteParams </span><span class="s4">= </span><span class="s1">_DBAPIAnyExecuteParams</span>

<span class="s1">CompiledCacheType </span><span class="s4">= </span><span class="s1">MutableMapping</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">, </span><span class="s5">&quot;Compiled&quot;</span><span class="s4">]</span>
<span class="s1">SchemaTranslateMapType </span><span class="s4">= </span><span class="s1">Mapping</span><span class="s4">[</span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">], </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]]</span>

<span class="s1">_ImmutableExecuteOptions </span><span class="s4">= </span><span class="s1">immutabledict</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">Any</span><span class="s4">]</span>

<span class="s1">_ParamStyle </span><span class="s4">= </span><span class="s1">Literal</span><span class="s4">[</span>
    <span class="s5">&quot;qmark&quot;</span><span class="s4">, </span><span class="s5">&quot;numeric&quot;</span><span class="s4">, </span><span class="s5">&quot;named&quot;</span><span class="s4">, </span><span class="s5">&quot;format&quot;</span><span class="s4">, </span><span class="s5">&quot;pyformat&quot;</span><span class="s4">, </span><span class="s5">&quot;numeric_dollar&quot;</span>
<span class="s4">]</span>

<span class="s1">_GenericSetInputSizesType </span><span class="s4">= </span><span class="s1">List</span><span class="s4">[</span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">Any</span><span class="s4">, </span><span class="s5">&quot;TypeEngine[Any]&quot;</span><span class="s4">]]</span>

<span class="s1">IsolationLevel </span><span class="s4">= </span><span class="s1">Literal</span><span class="s4">[</span>
    <span class="s5">&quot;SERIALIZABLE&quot;</span><span class="s4">,</span>
    <span class="s5">&quot;REPEATABLE READ&quot;</span><span class="s4">,</span>
    <span class="s5">&quot;READ COMMITTED&quot;</span><span class="s4">,</span>
    <span class="s5">&quot;READ UNCOMMITTED&quot;</span><span class="s4">,</span>
    <span class="s5">&quot;AUTOCOMMIT&quot;</span><span class="s4">,</span>
<span class="s4">]</span>


<span class="s3">class </span><span class="s1">_CoreKnownExecutionOptions</span><span class="s4">(</span><span class="s1">TypedDict</span><span class="s4">, </span><span class="s1">total</span><span class="s4">=</span><span class="s3">False</span><span class="s4">):</span>
    <span class="s1">compiled_cache</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">CompiledCacheType</span><span class="s4">]</span>
    <span class="s1">logging_token</span><span class="s4">: </span><span class="s1">str</span>
    <span class="s1">isolation_level</span><span class="s4">: </span><span class="s1">IsolationLevel</span>
    <span class="s1">no_parameters</span><span class="s4">: </span><span class="s1">bool</span>
    <span class="s1">stream_results</span><span class="s4">: </span><span class="s1">bool</span>
    <span class="s1">max_row_buffer</span><span class="s4">: </span><span class="s1">int</span>
    <span class="s1">yield_per</span><span class="s4">: </span><span class="s1">int</span>
    <span class="s1">insertmanyvalues_page_size</span><span class="s4">: </span><span class="s1">int</span>
    <span class="s1">schema_translate_map</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">SchemaTranslateMapType</span><span class="s4">]</span>
    <span class="s1">preserve_rowcount</span><span class="s4">: </span><span class="s1">bool</span>


<span class="s1">_ExecuteOptions </span><span class="s4">= </span><span class="s1">immutabledict</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">Any</span><span class="s4">]</span>
<span class="s1">CoreExecuteOptionsParameter </span><span class="s4">= </span><span class="s1">Union</span><span class="s4">[</span>
    <span class="s1">_CoreKnownExecutionOptions</span><span class="s4">, </span><span class="s1">Mapping</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">Any</span><span class="s4">]</span>
<span class="s4">]</span>


<span class="s3">class </span><span class="s1">ReflectedIdentity</span><span class="s4">(</span><span class="s1">TypedDict</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;represent the reflected IDENTITY structure of a column, corresponding 
    to the :class:`_schema.Identity` construct. 
 
    The :class:`.ReflectedIdentity` structure is part of the 
    :class:`.ReflectedColumn` structure, which is returned by the 
    :meth:`.Inspector.get_columns` method. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">always</span><span class="s4">: </span><span class="s1">bool</span>
    <span class="s5">&quot;&quot;&quot;type of identity column&quot;&quot;&quot;</span>

    <span class="s1">on_null</span><span class="s4">: </span><span class="s1">bool</span>
    <span class="s5">&quot;&quot;&quot;indicates ON NULL&quot;&quot;&quot;</span>

    <span class="s1">start</span><span class="s4">: </span><span class="s1">int</span>
    <span class="s5">&quot;&quot;&quot;starting index of the sequence&quot;&quot;&quot;</span>

    <span class="s1">increment</span><span class="s4">: </span><span class="s1">int</span>
    <span class="s5">&quot;&quot;&quot;increment value of the sequence&quot;&quot;&quot;</span>

    <span class="s1">minvalue</span><span class="s4">: </span><span class="s1">int</span>
    <span class="s5">&quot;&quot;&quot;the minimum value of the sequence.&quot;&quot;&quot;</span>

    <span class="s1">maxvalue</span><span class="s4">: </span><span class="s1">int</span>
    <span class="s5">&quot;&quot;&quot;the maximum value of the sequence.&quot;&quot;&quot;</span>

    <span class="s1">nominvalue</span><span class="s4">: </span><span class="s1">bool</span>
    <span class="s5">&quot;&quot;&quot;no minimum value of the sequence.&quot;&quot;&quot;</span>

    <span class="s1">nomaxvalue</span><span class="s4">: </span><span class="s1">bool</span>
    <span class="s5">&quot;&quot;&quot;no maximum value of the sequence.&quot;&quot;&quot;</span>

    <span class="s1">cycle</span><span class="s4">: </span><span class="s1">bool</span>
    <span class="s5">&quot;&quot;&quot;allows the sequence to wrap around when the maxvalue 
    or minvalue has been reached.&quot;&quot;&quot;</span>

    <span class="s1">cache</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">int</span><span class="s4">]</span>
    <span class="s5">&quot;&quot;&quot;number of future values in the 
    sequence which are calculated in advance.&quot;&quot;&quot;</span>

    <span class="s1">order</span><span class="s4">: </span><span class="s1">bool</span>
    <span class="s5">&quot;&quot;&quot;if true, renders the ORDER keyword.&quot;&quot;&quot;</span>


<span class="s3">class </span><span class="s1">ReflectedComputed</span><span class="s4">(</span><span class="s1">TypedDict</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Represent the reflected elements of a computed column, corresponding 
    to the :class:`_schema.Computed` construct. 
 
    The :class:`.ReflectedComputed` structure is part of the 
    :class:`.ReflectedColumn` structure, which is returned by the 
    :meth:`.Inspector.get_columns` method. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">sqltext</span><span class="s4">: </span><span class="s1">str</span>
    <span class="s5">&quot;&quot;&quot;the expression used to generate this column returned 
    as a string SQL expression&quot;&quot;&quot;</span>

    <span class="s1">persisted</span><span class="s4">: </span><span class="s1">NotRequired</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">]</span>
    <span class="s5">&quot;&quot;&quot;indicates if the value is stored in the table or computed on demand&quot;&quot;&quot;</span>


<span class="s3">class </span><span class="s1">ReflectedColumn</span><span class="s4">(</span><span class="s1">TypedDict</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Dictionary representing the reflected elements corresponding to 
    a :class:`_schema.Column` object. 
 
    The :class:`.ReflectedColumn` structure is returned by the 
    :class:`.Inspector.get_columns` method. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">name</span><span class="s4">: </span><span class="s1">str</span>
    <span class="s5">&quot;&quot;&quot;column name&quot;&quot;&quot;</span>

    <span class="s1">type</span><span class="s4">: </span><span class="s1">TypeEngine</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]</span>
    <span class="s5">&quot;&quot;&quot;column type represented as a :class:`.TypeEngine` instance.&quot;&quot;&quot;</span>

    <span class="s1">nullable</span><span class="s4">: </span><span class="s1">bool</span>
    <span class="s5">&quot;&quot;&quot;boolean flag if the column is NULL or NOT NULL&quot;&quot;&quot;</span>

    <span class="s1">default</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]</span>
    <span class="s5">&quot;&quot;&quot;column default expression as a SQL string&quot;&quot;&quot;</span>

    <span class="s1">autoincrement</span><span class="s4">: </span><span class="s1">NotRequired</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">]</span>
    <span class="s5">&quot;&quot;&quot;database-dependent autoincrement flag. 
 
    This flag indicates if the column has a database-side &quot;autoincrement&quot; 
    flag of some kind.   Within SQLAlchemy, other kinds of columns may 
    also act as an &quot;autoincrement&quot; column without necessarily having 
    such a flag on them. 
 
    See :paramref:`_schema.Column.autoincrement` for more background on 
    &quot;autoincrement&quot;. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">comment</span><span class="s4">: </span><span class="s1">NotRequired</span><span class="s4">[</span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]]</span>
    <span class="s5">&quot;&quot;&quot;comment for the column, if present. 
    Only some dialects return this key 
    &quot;&quot;&quot;</span>

    <span class="s1">computed</span><span class="s4">: </span><span class="s1">NotRequired</span><span class="s4">[</span><span class="s1">ReflectedComputed</span><span class="s4">]</span>
    <span class="s5">&quot;&quot;&quot;indicates that this column is computed by the database. 
    Only some dialects return this key. 
 
    .. versionadded:: 1.3.16 - added support for computed reflection. 
    &quot;&quot;&quot;</span>

    <span class="s1">identity</span><span class="s4">: </span><span class="s1">NotRequired</span><span class="s4">[</span><span class="s1">ReflectedIdentity</span><span class="s4">]</span>
    <span class="s5">&quot;&quot;&quot;indicates this column is an IDENTITY column. 
    Only some dialects return this key. 
 
    .. versionadded:: 1.4 - added support for identity column reflection. 
    &quot;&quot;&quot;</span>

    <span class="s1">dialect_options</span><span class="s4">: </span><span class="s1">NotRequired</span><span class="s4">[</span><span class="s1">Dict</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">Any</span><span class="s4">]]</span>
    <span class="s5">&quot;&quot;&quot;Additional dialect-specific options detected for this reflected 
    object&quot;&quot;&quot;</span>


<span class="s3">class </span><span class="s1">ReflectedConstraint</span><span class="s4">(</span><span class="s1">TypedDict</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Dictionary representing the reflected elements corresponding to 
    :class:`.Constraint` 
 
    A base class for all constraints 
    &quot;&quot;&quot;</span>

    <span class="s1">name</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]</span>
    <span class="s5">&quot;&quot;&quot;constraint name&quot;&quot;&quot;</span>

    <span class="s1">comment</span><span class="s4">: </span><span class="s1">NotRequired</span><span class="s4">[</span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]]</span>
    <span class="s5">&quot;&quot;&quot;comment for the constraint, if present&quot;&quot;&quot;</span>


<span class="s3">class </span><span class="s1">ReflectedCheckConstraint</span><span class="s4">(</span><span class="s1">ReflectedConstraint</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Dictionary representing the reflected elements corresponding to 
    :class:`.CheckConstraint`. 
 
    The :class:`.ReflectedCheckConstraint` structure is returned by the 
    :meth:`.Inspector.get_check_constraints` method. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">sqltext</span><span class="s4">: </span><span class="s1">str</span>
    <span class="s5">&quot;&quot;&quot;the check constraint's SQL expression&quot;&quot;&quot;</span>

    <span class="s1">dialect_options</span><span class="s4">: </span><span class="s1">NotRequired</span><span class="s4">[</span><span class="s1">Dict</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">Any</span><span class="s4">]]</span>
    <span class="s5">&quot;&quot;&quot;Additional dialect-specific options detected for this check constraint 
 
    .. versionadded:: 1.3.8 
    &quot;&quot;&quot;</span>


<span class="s3">class </span><span class="s1">ReflectedUniqueConstraint</span><span class="s4">(</span><span class="s1">ReflectedConstraint</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Dictionary representing the reflected elements corresponding to 
    :class:`.UniqueConstraint`. 
 
    The :class:`.ReflectedUniqueConstraint` structure is returned by the 
    :meth:`.Inspector.get_unique_constraints` method. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">column_names</span><span class="s4">: </span><span class="s1">List</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]</span>
    <span class="s5">&quot;&quot;&quot;column names which comprise the unique constraint&quot;&quot;&quot;</span>

    <span class="s1">duplicates_index</span><span class="s4">: </span><span class="s1">NotRequired</span><span class="s4">[</span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]]</span>
    <span class="s5">&quot;Indicates if this unique constraint duplicates an index with this name&quot;</span>

    <span class="s1">dialect_options</span><span class="s4">: </span><span class="s1">NotRequired</span><span class="s4">[</span><span class="s1">Dict</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">Any</span><span class="s4">]]</span>
    <span class="s5">&quot;&quot;&quot;Additional dialect-specific options detected for this unique 
    constraint&quot;&quot;&quot;</span>


<span class="s3">class </span><span class="s1">ReflectedPrimaryKeyConstraint</span><span class="s4">(</span><span class="s1">ReflectedConstraint</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Dictionary representing the reflected elements corresponding to 
    :class:`.PrimaryKeyConstraint`. 
 
    The :class:`.ReflectedPrimaryKeyConstraint` structure is returned by the 
    :meth:`.Inspector.get_pk_constraint` method. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">constrained_columns</span><span class="s4">: </span><span class="s1">List</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]</span>
    <span class="s5">&quot;&quot;&quot;column names which comprise the primary key&quot;&quot;&quot;</span>

    <span class="s1">dialect_options</span><span class="s4">: </span><span class="s1">NotRequired</span><span class="s4">[</span><span class="s1">Dict</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">Any</span><span class="s4">]]</span>
    <span class="s5">&quot;&quot;&quot;Additional dialect-specific options detected for this primary key&quot;&quot;&quot;</span>


<span class="s3">class </span><span class="s1">ReflectedForeignKeyConstraint</span><span class="s4">(</span><span class="s1">ReflectedConstraint</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Dictionary representing the reflected elements corresponding to 
    :class:`.ForeignKeyConstraint`. 
 
    The :class:`.ReflectedForeignKeyConstraint` structure is returned by 
    the :meth:`.Inspector.get_foreign_keys` method. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">constrained_columns</span><span class="s4">: </span><span class="s1">List</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]</span>
    <span class="s5">&quot;&quot;&quot;local column names which comprise the foreign key&quot;&quot;&quot;</span>

    <span class="s1">referred_schema</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]</span>
    <span class="s5">&quot;&quot;&quot;schema name of the table being referred&quot;&quot;&quot;</span>

    <span class="s1">referred_table</span><span class="s4">: </span><span class="s1">str</span>
    <span class="s5">&quot;&quot;&quot;name of the table being referred&quot;&quot;&quot;</span>

    <span class="s1">referred_columns</span><span class="s4">: </span><span class="s1">List</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]</span>
    <span class="s5">&quot;&quot;&quot;referred column names that correspond to ``constrained_columns``&quot;&quot;&quot;</span>

    <span class="s1">options</span><span class="s4">: </span><span class="s1">NotRequired</span><span class="s4">[</span><span class="s1">Dict</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">Any</span><span class="s4">]]</span>
    <span class="s5">&quot;&quot;&quot;Additional options detected for this foreign key constraint&quot;&quot;&quot;</span>


<span class="s3">class </span><span class="s1">ReflectedIndex</span><span class="s4">(</span><span class="s1">TypedDict</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Dictionary representing the reflected elements corresponding to 
    :class:`.Index`. 
 
    The :class:`.ReflectedIndex` structure is returned by the 
    :meth:`.Inspector.get_indexes` method. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">name</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]</span>
    <span class="s5">&quot;&quot;&quot;index name&quot;&quot;&quot;</span>

    <span class="s1">column_names</span><span class="s4">: </span><span class="s1">List</span><span class="s4">[</span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]]</span>
    <span class="s5">&quot;&quot;&quot;column names which the index references. 
    An element of this list is ``None`` if it's an expression and is 
    returned in the ``expressions`` list. 
    &quot;&quot;&quot;</span>

    <span class="s1">expressions</span><span class="s4">: </span><span class="s1">NotRequired</span><span class="s4">[</span><span class="s1">List</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]]</span>
    <span class="s5">&quot;&quot;&quot;Expressions that compose the index. This list, when present, contains 
    both plain column names (that are also in ``column_names``) and 
    expressions (that are ``None`` in ``column_names``). 
    &quot;&quot;&quot;</span>

    <span class="s1">unique</span><span class="s4">: </span><span class="s1">bool</span>
    <span class="s5">&quot;&quot;&quot;whether or not the index has a unique flag&quot;&quot;&quot;</span>

    <span class="s1">duplicates_constraint</span><span class="s4">: </span><span class="s1">NotRequired</span><span class="s4">[</span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]]</span>
    <span class="s5">&quot;Indicates if this index mirrors a constraint with this name&quot;</span>

    <span class="s1">include_columns</span><span class="s4">: </span><span class="s1">NotRequired</span><span class="s4">[</span><span class="s1">List</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]]</span>
    <span class="s5">&quot;&quot;&quot;columns to include in the INCLUDE clause for supporting databases. 
 
    .. deprecated:: 2.0 
 
        Legacy value, will be replaced with 
        ``index_dict[&quot;dialect_options&quot;][&quot;&lt;dialect name&gt;_include&quot;]`` 
 
    &quot;&quot;&quot;</span>

    <span class="s1">column_sorting</span><span class="s4">: </span><span class="s1">NotRequired</span><span class="s4">[</span><span class="s1">Dict</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]]]</span>
    <span class="s5">&quot;&quot;&quot;optional dict mapping column names or expressions to tuple of sort 
    keywords, which may include ``asc``, ``desc``, ``nulls_first``, 
    ``nulls_last``. 
 
    .. versionadded:: 1.3.5 
    &quot;&quot;&quot;</span>

    <span class="s1">dialect_options</span><span class="s4">: </span><span class="s1">NotRequired</span><span class="s4">[</span><span class="s1">Dict</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">Any</span><span class="s4">]]</span>
    <span class="s5">&quot;&quot;&quot;Additional dialect-specific options detected for this index&quot;&quot;&quot;</span>


<span class="s3">class </span><span class="s1">ReflectedTableComment</span><span class="s4">(</span><span class="s1">TypedDict</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Dictionary representing the reflected comment corresponding to 
    the :attr:`_schema.Table.comment` attribute. 
 
    The :class:`.ReflectedTableComment` structure is returned by the 
    :meth:`.Inspector.get_table_comment` method. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">text</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]</span>
    <span class="s5">&quot;&quot;&quot;text of the comment&quot;&quot;&quot;</span>


<span class="s3">class </span><span class="s1">BindTyping</span><span class="s4">(</span><span class="s1">Enum</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Define different methods of passing typing information for 
    bound parameters in a statement to the database driver. 
 
    .. versionadded:: 2.0 
 
    &quot;&quot;&quot;</span>

    <span class="s1">NONE </span><span class="s4">= </span><span class="s6">1</span>
    <span class="s5">&quot;&quot;&quot;No steps are taken to pass typing information to the database driver. 
 
    This is the default behavior for databases such as SQLite, MySQL / MariaDB, 
    SQL Server. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">SETINPUTSIZES </span><span class="s4">= </span><span class="s6">2</span>
    <span class="s5">&quot;&quot;&quot;Use the pep-249 setinputsizes method. 
 
    This is only implemented for DBAPIs that support this method and for which 
    the SQLAlchemy dialect has the appropriate infrastructure for that 
    dialect set up.   Current dialects include cx_Oracle as well as 
    optional support for SQL Server using pyodbc. 
 
    When using setinputsizes, dialects also have a means of only using the 
    method for certain datatypes using include/exclude lists. 
 
    When SETINPUTSIZES is used, the :meth:`.Dialect.do_set_input_sizes` method 
    is called for each statement executed which has bound parameters. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">RENDER_CASTS </span><span class="s4">= </span><span class="s6">3</span>
    <span class="s5">&quot;&quot;&quot;Render casts or other directives in the SQL string. 
 
    This method is used for all PostgreSQL dialects, including asyncpg, 
    pg8000, psycopg, psycopg2.   Dialects which implement this can choose 
    which kinds of datatypes are explicitly cast in SQL statements and which 
    aren't. 
 
    When RENDER_CASTS is used, the compiler will invoke the 
    :meth:`.SQLCompiler.render_bind_cast` method for the rendered 
    string representation of each :class:`.BindParameter` object whose 
    dialect-level type sets the :attr:`.TypeEngine.render_bind_cast` attribute. 
 
    The :meth:`.SQLCompiler.render_bind_cast` is also used to render casts 
    for one form of &quot;insertmanyvalues&quot; query, when both 
    :attr:`.InsertmanyvaluesSentinelOpts.USE_INSERT_FROM_SELECT` and 
    :attr:`.InsertmanyvaluesSentinelOpts.RENDER_SELECT_COL_CASTS` are set, 
    where the casts are applied to the intermediary columns e.g. 
    &quot;INSERT INTO t (a, b, c) SELECT p0::TYP, p1::TYP, p2::TYP &quot; 
    &quot;FROM (VALUES (?, ?), (?, ?), ...)&quot;. 
 
    .. versionadded:: 2.0.10 - :meth:`.SQLCompiler.render_bind_cast` is now 
       used within some elements of the &quot;insertmanyvalues&quot; implementation. 
 
 
    &quot;&quot;&quot;</span>


<span class="s1">VersionInfoType </span><span class="s4">= </span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">Union</span><span class="s4">[</span><span class="s1">int</span><span class="s4">, </span><span class="s1">str</span><span class="s4">], ...]</span>
<span class="s1">TableKey </span><span class="s4">= </span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">], </span><span class="s1">str</span><span class="s4">]</span>


<span class="s3">class </span><span class="s1">Dialect</span><span class="s4">(</span><span class="s1">EventTarget</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Define the behavior of a specific database and DB-API combination. 
 
    Any aspect of metadata definition, SQL query generation, 
    execution, result-set handling, or anything else which varies 
    between databases is defined under the general category of the 
    Dialect.  The Dialect acts as a factory for other 
    database-specific object implementations including 
    ExecutionContext, Compiled, DefaultGenerator, and TypeEngine. 
 
    .. note:: Third party dialects should not subclass :class:`.Dialect` 
       directly.  Instead, subclass :class:`.default.DefaultDialect` or 
       descendant class. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">CACHE_HIT </span><span class="s4">= </span><span class="s1">CacheStats</span><span class="s4">.</span><span class="s1">CACHE_HIT</span>
    <span class="s1">CACHE_MISS </span><span class="s4">= </span><span class="s1">CacheStats</span><span class="s4">.</span><span class="s1">CACHE_MISS</span>
    <span class="s1">CACHING_DISABLED </span><span class="s4">= </span><span class="s1">CacheStats</span><span class="s4">.</span><span class="s1">CACHING_DISABLED</span>
    <span class="s1">NO_CACHE_KEY </span><span class="s4">= </span><span class="s1">CacheStats</span><span class="s4">.</span><span class="s1">NO_CACHE_KEY</span>
    <span class="s1">NO_DIALECT_SUPPORT </span><span class="s4">= </span><span class="s1">CacheStats</span><span class="s4">.</span><span class="s1">NO_DIALECT_SUPPORT</span>

    <span class="s1">dispatch</span><span class="s4">: </span><span class="s1">dispatcher</span><span class="s4">[</span><span class="s1">Dialect</span><span class="s4">]</span>

    <span class="s1">name</span><span class="s4">: </span><span class="s1">str</span>
    <span class="s5">&quot;&quot;&quot;identifying name for the dialect from a DBAPI-neutral point of view 
      (i.e. 'sqlite') 
    &quot;&quot;&quot;</span>

    <span class="s1">driver</span><span class="s4">: </span><span class="s1">str</span>
    <span class="s5">&quot;&quot;&quot;identifying name for the dialect's DBAPI&quot;&quot;&quot;</span>

    <span class="s1">dialect_description</span><span class="s4">: </span><span class="s1">str</span>

    <span class="s1">dbapi</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">ModuleType</span><span class="s4">]</span>
    <span class="s5">&quot;&quot;&quot;A reference to the DBAPI module object itself. 
 
    SQLAlchemy dialects import DBAPI modules using the classmethod 
    :meth:`.Dialect.import_dbapi`. The rationale is so that any dialect 
    module can be imported and used to generate SQL statements without the 
    need for the actual DBAPI driver to be installed.  Only when an 
    :class:`.Engine` is constructed using :func:`.create_engine` does the 
    DBAPI get imported; at that point, the creation process will assign 
    the DBAPI module to this attribute. 
 
    Dialects should therefore implement :meth:`.Dialect.import_dbapi` 
    which will import the necessary module and return it, and then refer 
    to ``self.dbapi`` in dialect code in order to refer to the DBAPI module 
    contents. 
 
    .. versionchanged:: The :attr:`.Dialect.dbapi` attribute is exclusively 
       used as the per-:class:`.Dialect`-instance reference to the DBAPI 
       module.   The previous not-fully-documented ``.Dialect.dbapi()`` 
       classmethod is deprecated and replaced by :meth:`.Dialect.import_dbapi`. 
 
    &quot;&quot;&quot;</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">non_memoized_property</span>
    <span class="s3">def </span><span class="s1">loaded_dbapi</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; ModuleType</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;same as .dbapi, but is never None; will raise an error if no 
        DBAPI was set up. 
 
        .. versionadded:: 2.0 
 
        &quot;&quot;&quot;</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s1">positional</span><span class="s4">: </span><span class="s1">bool</span>
    <span class="s5">&quot;&quot;&quot;True if the paramstyle for this Dialect is positional.&quot;&quot;&quot;</span>

    <span class="s1">paramstyle</span><span class="s4">: </span><span class="s1">str</span>
    <span class="s5">&quot;&quot;&quot;the paramstyle to be used (some DB-APIs support multiple 
      paramstyles). 
    &quot;&quot;&quot;</span>

    <span class="s1">compiler_linting</span><span class="s4">: </span><span class="s1">Linting</span>

    <span class="s1">statement_compiler</span><span class="s4">: </span><span class="s1">Type</span><span class="s4">[</span><span class="s1">SQLCompiler</span><span class="s4">]</span>
    <span class="s5">&quot;&quot;&quot;a :class:`.Compiled` class used to compile SQL statements&quot;&quot;&quot;</span>

    <span class="s1">ddl_compiler</span><span class="s4">: </span><span class="s1">Type</span><span class="s4">[</span><span class="s1">DDLCompiler</span><span class="s4">]</span>
    <span class="s5">&quot;&quot;&quot;a :class:`.Compiled` class used to compile DDL statements&quot;&quot;&quot;</span>

    <span class="s1">type_compiler_cls</span><span class="s4">: </span><span class="s1">ClassVar</span><span class="s4">[</span><span class="s1">Type</span><span class="s4">[</span><span class="s1">TypeCompiler</span><span class="s4">]]</span>
    <span class="s5">&quot;&quot;&quot;a :class:`.Compiled` class used to compile SQL type objects 
 
    .. versionadded:: 2.0 
 
    &quot;&quot;&quot;</span>

    <span class="s1">type_compiler_instance</span><span class="s4">: </span><span class="s1">TypeCompiler</span>
    <span class="s5">&quot;&quot;&quot;instance of a :class:`.Compiled` class used to compile SQL type 
    objects 
 
    .. versionadded:: 2.0 
 
    &quot;&quot;&quot;</span>

    <span class="s1">type_compiler</span><span class="s4">: </span><span class="s1">Any</span>
    <span class="s5">&quot;&quot;&quot;legacy; this is a TypeCompiler class at the class level, a 
    TypeCompiler instance at the instance level. 
 
    Refer to type_compiler_instance instead. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">preparer</span><span class="s4">: </span><span class="s1">Type</span><span class="s4">[</span><span class="s1">IdentifierPreparer</span><span class="s4">]</span>
    <span class="s5">&quot;&quot;&quot;a :class:`.IdentifierPreparer` class used to 
    quote identifiers. 
    &quot;&quot;&quot;</span>

    <span class="s1">identifier_preparer</span><span class="s4">: </span><span class="s1">IdentifierPreparer</span>
    <span class="s5">&quot;&quot;&quot;This element will refer to an instance of :class:`.IdentifierPreparer` 
    once a :class:`.DefaultDialect` has been constructed. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">server_version_info</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">, ...]]</span>
    <span class="s5">&quot;&quot;&quot;a tuple containing a version number for the DB backend in use. 
 
    This value is only available for supporting dialects, and is 
    typically populated during the initial connection to the database. 
    &quot;&quot;&quot;</span>

    <span class="s1">default_schema_name</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]</span>
    <span class="s5">&quot;&quot;&quot;the name of the default schema.  This value is only available for 
    supporting dialects, and is typically populated during the 
    initial connection to the database. 
 
    &quot;&quot;&quot;</span>

    <span class="s0"># NOTE: this does not take into effect engine-level isolation level.</span>
    <span class="s0"># not clear if this should be changed, seems like it should</span>
    <span class="s1">default_isolation_level</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">IsolationLevel</span><span class="s4">]</span>
    <span class="s5">&quot;&quot;&quot;the isolation that is implicitly present on new connections&quot;&quot;&quot;</span>

    <span class="s0"># create_engine()  -&gt; isolation_level  currently goes here</span>
    <span class="s1">_on_connect_isolation_level</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">IsolationLevel</span><span class="s4">]</span>

    <span class="s1">execution_ctx_cls</span><span class="s4">: </span><span class="s1">Type</span><span class="s4">[</span><span class="s1">ExecutionContext</span><span class="s4">]</span>
    <span class="s5">&quot;&quot;&quot;a :class:`.ExecutionContext` class used to handle statement execution&quot;&quot;&quot;</span>

    <span class="s1">execute_sequence_format</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span>
        <span class="s1">Type</span><span class="s4">[</span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">, ...]], </span><span class="s1">Type</span><span class="s4">[</span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">List</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]]</span>
    <span class="s4">]</span>
    <span class="s5">&quot;&quot;&quot;either the 'tuple' or 'list' type, depending on what cursor.execute() 
    accepts for the second argument (they vary).&quot;&quot;&quot;</span>

    <span class="s1">supports_alter</span><span class="s4">: </span><span class="s1">bool</span>
    <span class="s5">&quot;&quot;&quot;``True`` if the database supports ``ALTER TABLE`` - used only for 
    generating foreign key constraints in certain circumstances 
    &quot;&quot;&quot;</span>

    <span class="s1">max_identifier_length</span><span class="s4">: </span><span class="s1">int</span>
    <span class="s5">&quot;&quot;&quot;The maximum length of identifier names.&quot;&quot;&quot;</span>

    <span class="s1">supports_server_side_cursors</span><span class="s4">: </span><span class="s1">bool</span>
    <span class="s5">&quot;&quot;&quot;indicates if the dialect supports server side cursors&quot;&quot;&quot;</span>

    <span class="s1">server_side_cursors</span><span class="s4">: </span><span class="s1">bool</span>
    <span class="s5">&quot;&quot;&quot;deprecated; indicates if the dialect should attempt to use server 
    side cursors by default&quot;&quot;&quot;</span>

    <span class="s1">supports_sane_rowcount</span><span class="s4">: </span><span class="s1">bool</span>
    <span class="s5">&quot;&quot;&quot;Indicate whether the dialect properly implements rowcount for 
      ``UPDATE`` and ``DELETE`` statements. 
    &quot;&quot;&quot;</span>

    <span class="s1">supports_sane_multi_rowcount</span><span class="s4">: </span><span class="s1">bool</span>
    <span class="s5">&quot;&quot;&quot;Indicate whether the dialect properly implements rowcount for 
      ``UPDATE`` and ``DELETE`` statements when executed via 
      executemany. 
    &quot;&quot;&quot;</span>

    <span class="s1">supports_empty_insert</span><span class="s4">: </span><span class="s1">bool</span>
    <span class="s5">&quot;&quot;&quot;dialect supports INSERT () VALUES (), i.e. a plain INSERT with no 
    columns in it. 
 
    This is not usually supported; an &quot;empty&quot; insert is typically 
    suited using either &quot;INSERT..DEFAULT VALUES&quot; or 
    &quot;INSERT ... (col) VALUES (DEFAULT)&quot;. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">supports_default_values</span><span class="s4">: </span><span class="s1">bool</span>
    <span class="s5">&quot;&quot;&quot;dialect supports INSERT... DEFAULT VALUES syntax&quot;&quot;&quot;</span>

    <span class="s1">supports_default_metavalue</span><span class="s4">: </span><span class="s1">bool</span>
    <span class="s5">&quot;&quot;&quot;dialect supports INSERT...(col) VALUES (DEFAULT) syntax. 
 
    Most databases support this in some way, e.g. SQLite supports it using 
    ``VALUES (NULL)``.    MS SQL Server supports the syntax also however 
    is the only included dialect where we have this disabled, as 
    MSSQL does not support the field for the IDENTITY column, which is 
    usually where we like to make use of the feature. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">default_metavalue_token</span><span class="s4">: </span><span class="s1">str </span><span class="s4">= </span><span class="s5">&quot;DEFAULT&quot;</span>
    <span class="s5">&quot;&quot;&quot;for INSERT... VALUES (DEFAULT) syntax, the token to put in the 
    parenthesis. 
 
    E.g. for SQLite this is the keyword &quot;NULL&quot;. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">supports_multivalues_insert</span><span class="s4">: </span><span class="s1">bool</span>
    <span class="s5">&quot;&quot;&quot;Target database supports INSERT...VALUES with multiple value 
    sets, i.e. INSERT INTO table (cols) VALUES (...), (...), (...), ... 
 
    &quot;&quot;&quot;</span>

    <span class="s1">insert_executemany_returning</span><span class="s4">: </span><span class="s1">bool</span>
    <span class="s5">&quot;&quot;&quot;dialect / driver / database supports some means of providing 
    INSERT...RETURNING support when dialect.do_executemany() is used. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">insert_executemany_returning_sort_by_parameter_order</span><span class="s4">: </span><span class="s1">bool</span>
    <span class="s5">&quot;&quot;&quot;dialect / driver / database supports some means of providing 
    INSERT...RETURNING support when dialect.do_executemany() is used 
    along with the :paramref:`_dml.Insert.returning.sort_by_parameter_order` 
    parameter being set. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">update_executemany_returning</span><span class="s4">: </span><span class="s1">bool</span>
    <span class="s5">&quot;&quot;&quot;dialect supports UPDATE..RETURNING with executemany.&quot;&quot;&quot;</span>

    <span class="s1">delete_executemany_returning</span><span class="s4">: </span><span class="s1">bool</span>
    <span class="s5">&quot;&quot;&quot;dialect supports DELETE..RETURNING with executemany.&quot;&quot;&quot;</span>

    <span class="s1">use_insertmanyvalues</span><span class="s4">: </span><span class="s1">bool</span>
    <span class="s5">&quot;&quot;&quot;if True, indicates &quot;insertmanyvalues&quot; functionality should be used 
    to allow for ``insert_executemany_returning`` behavior, if possible. 
 
    In practice, setting this to True means: 
 
    if ``supports_multivalues_insert``, ``insert_returning`` and 
    ``use_insertmanyvalues`` are all True, the SQL compiler will produce 
    an INSERT that will be interpreted by the :class:`.DefaultDialect` 
    as an :attr:`.ExecuteStyle.INSERTMANYVALUES` execution that allows 
    for INSERT of many rows with RETURNING by rewriting a single-row 
    INSERT statement to have multiple VALUES clauses, also executing 
    the statement multiple times for a series of batches when large numbers 
    of rows are given. 
 
    The parameter is False for the default dialect, and is set to 
    True for SQLAlchemy internal dialects SQLite, MySQL/MariaDB, PostgreSQL, 
    SQL Server.   It remains at False for Oracle, which provides native 
    &quot;executemany with RETURNING&quot; support and also does not support 
    ``supports_multivalues_insert``.    For MySQL/MariaDB, those MySQL 
    dialects that don't support RETURNING will not report 
    ``insert_executemany_returning`` as True. 
 
    .. versionadded:: 2.0 
 
    .. seealso:: 
 
        :ref:`engine_insertmanyvalues` 
 
    &quot;&quot;&quot;</span>

    <span class="s1">use_insertmanyvalues_wo_returning</span><span class="s4">: </span><span class="s1">bool</span>
    <span class="s5">&quot;&quot;&quot;if True, and use_insertmanyvalues is also True, INSERT statements 
    that don't include RETURNING will also use &quot;insertmanyvalues&quot;. 
 
    .. versionadded:: 2.0 
 
    .. seealso:: 
 
        :ref:`engine_insertmanyvalues` 
 
    &quot;&quot;&quot;</span>

    <span class="s1">insertmanyvalues_implicit_sentinel</span><span class="s4">: </span><span class="s1">InsertmanyvaluesSentinelOpts</span>
    <span class="s5">&quot;&quot;&quot;Options indicating the database supports a form of bulk INSERT where 
    the autoincrement integer primary key can be reliably used as an ordering 
    for INSERTed rows. 
 
    .. versionadded:: 2.0.10 
 
    .. seealso:: 
 
        :ref:`engine_insertmanyvalues_returning_order` 
 
    &quot;&quot;&quot;</span>

    <span class="s1">insertmanyvalues_page_size</span><span class="s4">: </span><span class="s1">int</span>
    <span class="s5">&quot;&quot;&quot;Number of rows to render into an individual INSERT..VALUES() statement 
    for :attr:`.ExecuteStyle.INSERTMANYVALUES` executions. 
 
    The default dialect defaults this to 1000. 
 
    .. versionadded:: 2.0 
 
    .. seealso:: 
 
        :paramref:`_engine.Connection.execution_options.insertmanyvalues_page_size` - 
        execution option available on :class:`_engine.Connection`, statements 
 
    &quot;&quot;&quot;  </span><span class="s0"># noqa: E501</span>

    <span class="s1">insertmanyvalues_max_parameters</span><span class="s4">: </span><span class="s1">int</span>
    <span class="s5">&quot;&quot;&quot;Alternate to insertmanyvalues_page_size, will additionally limit 
    page size based on number of parameters total in the statement. 
 
 
    &quot;&quot;&quot;</span>

    <span class="s1">preexecute_autoincrement_sequences</span><span class="s4">: </span><span class="s1">bool</span>
    <span class="s5">&quot;&quot;&quot;True if 'implicit' primary key functions must be executed separately 
      in order to get their value, if RETURNING is not used. 
 
      This is currently oriented towards PostgreSQL when the 
      ``implicit_returning=False`` parameter is used on a :class:`.Table` 
      object. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">insert_returning</span><span class="s4">: </span><span class="s1">bool</span>
    <span class="s5">&quot;&quot;&quot;if the dialect supports RETURNING with INSERT 
 
    .. versionadded:: 2.0 
 
    &quot;&quot;&quot;</span>

    <span class="s1">update_returning</span><span class="s4">: </span><span class="s1">bool</span>
    <span class="s5">&quot;&quot;&quot;if the dialect supports RETURNING with UPDATE 
 
    .. versionadded:: 2.0 
 
    &quot;&quot;&quot;</span>

    <span class="s1">update_returning_multifrom</span><span class="s4">: </span><span class="s1">bool</span>
    <span class="s5">&quot;&quot;&quot;if the dialect supports RETURNING with UPDATE..FROM 
 
    .. versionadded:: 2.0 
 
    &quot;&quot;&quot;</span>

    <span class="s1">delete_returning</span><span class="s4">: </span><span class="s1">bool</span>
    <span class="s5">&quot;&quot;&quot;if the dialect supports RETURNING with DELETE 
 
    .. versionadded:: 2.0 
 
    &quot;&quot;&quot;</span>

    <span class="s1">delete_returning_multifrom</span><span class="s4">: </span><span class="s1">bool</span>
    <span class="s5">&quot;&quot;&quot;if the dialect supports RETURNING with DELETE..FROM 
 
    .. versionadded:: 2.0 
 
    &quot;&quot;&quot;</span>

    <span class="s1">favor_returning_over_lastrowid</span><span class="s4">: </span><span class="s1">bool</span>
    <span class="s5">&quot;&quot;&quot;for backends that support both a lastrowid and a RETURNING insert 
    strategy, favor RETURNING for simple single-int pk inserts. 
 
    cursor.lastrowid tends to be more performant on most backends. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">supports_identity_columns</span><span class="s4">: </span><span class="s1">bool</span>
    <span class="s5">&quot;&quot;&quot;target database supports IDENTITY&quot;&quot;&quot;</span>

    <span class="s1">cte_follows_insert</span><span class="s4">: </span><span class="s1">bool</span>
    <span class="s5">&quot;&quot;&quot;target database, when given a CTE with an INSERT statement, needs 
    the CTE to be below the INSERT&quot;&quot;&quot;</span>

    <span class="s1">colspecs</span><span class="s4">: </span><span class="s1">MutableMapping</span><span class="s4">[</span><span class="s1">Type</span><span class="s4">[</span><span class="s1">TypeEngine</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]], </span><span class="s1">Type</span><span class="s4">[</span><span class="s1">TypeEngine</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]]</span>
    <span class="s5">&quot;&quot;&quot;A dictionary of TypeEngine classes from sqlalchemy.types mapped 
      to subclasses that are specific to the dialect class.  This 
      dictionary is class-level only and is not accessed from the 
      dialect instance itself. 
    &quot;&quot;&quot;</span>

    <span class="s1">supports_sequences</span><span class="s4">: </span><span class="s1">bool</span>
    <span class="s5">&quot;&quot;&quot;Indicates if the dialect supports CREATE SEQUENCE or similar.&quot;&quot;&quot;</span>

    <span class="s1">sequences_optional</span><span class="s4">: </span><span class="s1">bool</span>
    <span class="s5">&quot;&quot;&quot;If True, indicates if the :paramref:`_schema.Sequence.optional` 
      parameter on the :class:`_schema.Sequence` construct 
      should signal to not generate a CREATE SEQUENCE. Applies only to 
      dialects that support sequences. Currently used only to allow PostgreSQL 
      SERIAL to be used on a column that specifies Sequence() for usage on 
      other backends. 
    &quot;&quot;&quot;</span>

    <span class="s1">default_sequence_base</span><span class="s4">: </span><span class="s1">int</span>
    <span class="s5">&quot;&quot;&quot;the default value that will be rendered as the &quot;START WITH&quot; portion of 
    a CREATE SEQUENCE DDL statement. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">supports_native_enum</span><span class="s4">: </span><span class="s1">bool</span>
    <span class="s5">&quot;&quot;&quot;Indicates if the dialect supports a native ENUM construct. 
      This will prevent :class:`_types.Enum` from generating a CHECK 
      constraint when that type is used in &quot;native&quot; mode. 
    &quot;&quot;&quot;</span>

    <span class="s1">supports_native_boolean</span><span class="s4">: </span><span class="s1">bool</span>
    <span class="s5">&quot;&quot;&quot;Indicates if the dialect supports a native boolean construct. 
      This will prevent :class:`_types.Boolean` from generating a CHECK 
      constraint when that type is used. 
    &quot;&quot;&quot;</span>

    <span class="s1">supports_native_decimal</span><span class="s4">: </span><span class="s1">bool</span>
    <span class="s5">&quot;&quot;&quot;indicates if Decimal objects are handled and returned for precision 
    numeric types, or if floats are returned&quot;&quot;&quot;</span>

    <span class="s1">supports_native_uuid</span><span class="s4">: </span><span class="s1">bool</span>
    <span class="s5">&quot;&quot;&quot;indicates if Python UUID() objects are handled natively by the 
    driver for SQL UUID datatypes. 
 
    .. versionadded:: 2.0 
 
    &quot;&quot;&quot;</span>

    <span class="s1">returns_native_bytes</span><span class="s4">: </span><span class="s1">bool</span>
    <span class="s5">&quot;&quot;&quot;indicates if Python bytes() objects are returned natively by the 
    driver for SQL &quot;binary&quot; datatypes. 
 
    .. versionadded:: 2.0.11 
 
    &quot;&quot;&quot;</span>

    <span class="s1">construct_arguments</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span>
        <span class="s1">List</span><span class="s4">[</span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">Type</span><span class="s4">[</span><span class="s1">Union</span><span class="s4">[</span><span class="s1">SchemaItem</span><span class="s4">, </span><span class="s1">ClauseElement</span><span class="s4">]], </span><span class="s1">Mapping</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">Any</span><span class="s4">]]]</span>
    <span class="s4">] = </span><span class="s3">None</span>
    <span class="s5">&quot;&quot;&quot;Optional set of argument specifiers for various SQLAlchemy 
    constructs, typically schema items. 
 
    To implement, establish as a series of tuples, as in:: 
 
        construct_arguments = [ 
            (schema.Index, { 
                &quot;using&quot;: False, 
                &quot;where&quot;: None, 
                &quot;ops&quot;: None 
            }) 
        ] 
 
    If the above construct is established on the PostgreSQL dialect, 
    the :class:`.Index` construct will now accept the keyword arguments 
    ``postgresql_using``, ``postgresql_where``, nad ``postgresql_ops``. 
    Any other argument specified to the constructor of :class:`.Index` 
    which is prefixed with ``postgresql_`` will raise :class:`.ArgumentError`. 
 
    A dialect which does not include a ``construct_arguments`` member will 
    not participate in the argument validation system.  For such a dialect, 
    any argument name is accepted by all participating constructs, within 
    the namespace of arguments prefixed with that dialect name.  The rationale 
    here is so that third-party dialects that haven't yet implemented this 
    feature continue to function in the old way. 
 
    .. seealso:: 
 
        :class:`.DialectKWArgs` - implementing base class which consumes 
        :attr:`.DefaultDialect.construct_arguments` 
 
 
    &quot;&quot;&quot;</span>

    <span class="s1">reflection_options</span><span class="s4">: </span><span class="s1">Sequence</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = ()</span>
    <span class="s5">&quot;&quot;&quot;Sequence of string names indicating keyword arguments that can be 
    established on a :class:`.Table` object which will be passed as 
    &quot;reflection options&quot; when using :paramref:`.Table.autoload_with`. 
 
    Current example is &quot;oracle_resolve_synonyms&quot; in the Oracle dialect. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">dbapi_exception_translation_map</span><span class="s4">: </span><span class="s1">Mapping</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">str</span><span class="s4">] = </span><span class="s1">util</span><span class="s4">.</span><span class="s1">EMPTY_DICT</span>
    <span class="s5">&quot;&quot;&quot;A dictionary of names that will contain as values the names of 
       pep-249 exceptions (&quot;IntegrityError&quot;, &quot;OperationalError&quot;, etc) 
       keyed to alternate class names, to support the case where a 
       DBAPI has exception classes that aren't named as they are 
       referred to (e.g. IntegrityError = MyException).   In the vast 
       majority of cases this dictionary is empty. 
    &quot;&quot;&quot;</span>

    <span class="s1">supports_comments</span><span class="s4">: </span><span class="s1">bool</span>
    <span class="s5">&quot;&quot;&quot;Indicates the dialect supports comment DDL on tables and columns.&quot;&quot;&quot;</span>

    <span class="s1">inline_comments</span><span class="s4">: </span><span class="s1">bool</span>
    <span class="s5">&quot;&quot;&quot;Indicates the dialect supports comment DDL that's inline with the 
    definition of a Table or Column.  If False, this implies that ALTER must 
    be used to set table and column comments.&quot;&quot;&quot;</span>

    <span class="s1">supports_constraint_comments</span><span class="s4">: </span><span class="s1">bool</span>
    <span class="s5">&quot;&quot;&quot;Indicates if the dialect supports comment DDL on constraints. 
 
    .. versionadded: 2.0 
    &quot;&quot;&quot;</span>

    <span class="s1">_has_events </span><span class="s4">= </span><span class="s3">False</span>

    <span class="s1">supports_statement_cache</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">True</span>
    <span class="s5">&quot;&quot;&quot;indicates if this dialect supports caching. 
 
    All dialects that are compatible with statement caching should set this 
    flag to True directly on each dialect class and subclass that supports 
    it.  SQLAlchemy tests that this flag is locally present on each dialect 
    subclass before it will use statement caching.  This is to provide 
    safety for legacy or new dialects that are not yet fully tested to be 
    compliant with SQL statement caching. 
 
    .. versionadded:: 1.4.5 
 
    .. seealso:: 
 
        :ref:`engine_thirdparty_caching` 
 
    &quot;&quot;&quot;</span>

    <span class="s1">_supports_statement_cache</span><span class="s4">: </span><span class="s1">bool</span>
    <span class="s5">&quot;&quot;&quot;internal evaluation for supports_statement_cache&quot;&quot;&quot;</span>

    <span class="s1">bind_typing </span><span class="s4">= </span><span class="s1">BindTyping</span><span class="s4">.</span><span class="s1">NONE</span>
    <span class="s5">&quot;&quot;&quot;define a means of passing typing information to the database and/or 
    driver for bound parameters. 
 
    See :class:`.BindTyping` for values. 
 
    .. versionadded:: 2.0 
 
    &quot;&quot;&quot;</span>

    <span class="s1">is_async</span><span class="s4">: </span><span class="s1">bool</span>
    <span class="s5">&quot;&quot;&quot;Whether or not this dialect is intended for asyncio use.&quot;&quot;&quot;</span>

    <span class="s1">has_terminate</span><span class="s4">: </span><span class="s1">bool</span>
    <span class="s5">&quot;&quot;&quot;Whether or not this dialect has a separate &quot;terminate&quot; implementation 
    that does not block or require awaiting.&quot;&quot;&quot;</span>

    <span class="s1">engine_config_types</span><span class="s4">: </span><span class="s1">Mapping</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">Any</span><span class="s4">]</span>
    <span class="s5">&quot;&quot;&quot;a mapping of string keys that can be in an engine config linked to 
    type conversion functions. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">label_length</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">int</span><span class="s4">]</span>
    <span class="s5">&quot;&quot;&quot;optional user-defined max length for SQL labels&quot;&quot;&quot;</span>

    <span class="s1">include_set_input_sizes</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Set</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]</span>
    <span class="s5">&quot;&quot;&quot;set of DBAPI type objects that should be included in 
    automatic cursor.setinputsizes() calls. 
 
    This is only used if bind_typing is BindTyping.SET_INPUT_SIZES 
 
    &quot;&quot;&quot;</span>

    <span class="s1">exclude_set_input_sizes</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Set</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]</span>
    <span class="s5">&quot;&quot;&quot;set of DBAPI type objects that should be excluded in 
    automatic cursor.setinputsizes() calls. 
 
    This is only used if bind_typing is BindTyping.SET_INPUT_SIZES 
 
    &quot;&quot;&quot;</span>

    <span class="s1">supports_simple_order_by_label</span><span class="s4">: </span><span class="s1">bool</span>
    <span class="s5">&quot;&quot;&quot;target database supports ORDER BY &lt;labelname&gt;, where &lt;labelname&gt; 
    refers to a label in the columns clause of the SELECT&quot;&quot;&quot;</span>

    <span class="s1">div_is_floordiv</span><span class="s4">: </span><span class="s1">bool</span>
    <span class="s5">&quot;&quot;&quot;target database treats the / division operator as &quot;floor division&quot; &quot;&quot;&quot;</span>

    <span class="s1">tuple_in_values</span><span class="s4">: </span><span class="s1">bool</span>
    <span class="s5">&quot;&quot;&quot;target database supports tuple IN, i.e. (x, y) IN ((q, p), (r, z))&quot;&quot;&quot;</span>

    <span class="s1">_bind_typing_render_casts</span><span class="s4">: </span><span class="s1">bool</span>

    <span class="s1">_type_memos</span><span class="s4">: </span><span class="s1">MutableMapping</span><span class="s4">[</span><span class="s1">TypeEngine</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">], </span><span class="s1">_TypeMemoDict</span><span class="s4">]</span>

    <span class="s3">def </span><span class="s1">_builtin_onconnect</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Optional</span><span class="s4">[</span><span class="s1">_ListenerFnType</span><span class="s4">]:</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">create_connect_args</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">url</span><span class="s4">: </span><span class="s1">URL</span><span class="s4">) </span><span class="s1">-&gt; ConnectArgsType</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Build DB-API compatible connection arguments. 
 
        Given a :class:`.URL` object, returns a tuple 
        consisting of a ``(*args, **kwargs)`` suitable to send directly 
        to the dbapi's connect function.   The arguments are sent to the 
        :meth:`.Dialect.connect` method which then runs the DBAPI-level 
        ``connect()`` function. 
 
        The method typically makes use of the 
        :meth:`.URL.translate_connect_args` 
        method in order to generate a dictionary of options. 
 
        The default implementation is:: 
 
            def create_connect_args(self, url): 
                opts = url.translate_connect_args() 
                opts.update(url.query) 
                return ([], opts) 
 
        :param url: a :class:`.URL` object 
 
        :return: a tuple of ``(*args, **kwargs)`` which will be passed to the 
         :meth:`.Dialect.connect` method. 
 
        .. seealso:: 
 
            :meth:`.URL.translate_connect_args` 
 
        &quot;&quot;&quot;</span>

        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s4">@</span><span class="s1">classmethod</span>
    <span class="s3">def </span><span class="s1">import_dbapi</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">) </span><span class="s1">-&gt; ModuleType</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Import the DBAPI module that is used by this dialect. 
 
        The Python module object returned here will be assigned as an 
        instance variable to a constructed dialect under the name 
        ``.dbapi``. 
 
        .. versionchanged:: 2.0  The :meth:`.Dialect.import_dbapi` class 
           method is renamed from the previous method ``.Dialect.dbapi()``, 
           which would be replaced at dialect instantiation time by the 
           DBAPI module itself, thus using the same name in two different ways. 
           If a ``.Dialect.dbapi()`` classmethod is present on a third-party 
           dialect, it will be used and a deprecation warning will be emitted. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">type_descriptor</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">typeobj</span><span class="s4">: </span><span class="s1">TypeEngine</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]) </span><span class="s1">-&gt; TypeEngine</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;Transform a generic type to a dialect-specific type. 
 
        Dialect classes will usually use the 
        :func:`_types.adapt_type` function in the types module to 
        accomplish this. 
 
        The returned result is cached *per dialect class* so can 
        contain no dialect-instance state. 
 
        &quot;&quot;&quot;</span>

        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">initialize</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">connection</span><span class="s4">: </span><span class="s1">Connection</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Called during strategized creation of the dialect with a 
        connection. 
 
        Allows dialects to configure options based on server version info or 
        other properties. 
 
        The connection passed here is a SQLAlchemy Connection object, 
        with full capabilities. 
 
        The initialize() method of the base dialect should be called via 
        super(). 
 
        .. note:: as of SQLAlchemy 1.4, this method is called **before** 
           any :meth:`_engine.Dialect.on_connect` hooks are called. 
 
        &quot;&quot;&quot;</span>

        <span class="s3">pass</span>

    <span class="s3">if </span><span class="s1">TYPE_CHECKING</span><span class="s4">:</span>

        <span class="s3">def </span><span class="s1">_overrides_default</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">method_name</span><span class="s4">: </span><span class="s1">str</span><span class="s4">) </span><span class="s1">-&gt; bool</span><span class="s4">: ...</span>

    <span class="s3">def </span><span class="s1">get_columns</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">connection</span><span class="s4">: </span><span class="s1">Connection</span><span class="s4">,</span>
        <span class="s1">table_name</span><span class="s4">: </span><span class="s1">str</span><span class="s4">,</span>
        <span class="s1">schema</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s4">**</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; List</span><span class="s4">[</span><span class="s1">ReflectedColumn</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;Return information about columns in ``table_name``. 
 
        Given a :class:`_engine.Connection`, a string 
        ``table_name``, and an optional string ``schema``, return column 
        information as a list of dictionaries 
        corresponding to the :class:`.ReflectedColumn` dictionary. 
 
        This is an internal dialect method. Applications should use 
        :meth:`.Inspector.get_columns`. 
 
        &quot;&quot;&quot;</span>

        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">get_multi_columns</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">connection</span><span class="s4">: </span><span class="s1">Connection</span><span class="s4">,</span>
        <span class="s4">*,</span>
        <span class="s1">schema</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">filter_names</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Collection</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s4">**</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; Iterable</span><span class="s4">[</span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">TableKey</span><span class="s4">, </span><span class="s1">List</span><span class="s4">[</span><span class="s1">ReflectedColumn</span><span class="s4">]]]:</span>
        <span class="s2">&quot;&quot;&quot;Return information about columns in all tables in the 
        given ``schema``. 
 
        This is an internal dialect method. Applications should use 
        :meth:`.Inspector.get_multi_columns`. 
 
        .. note:: The :class:`_engine.DefaultDialect` provides a default 
          implementation that will call the single table method for 
          each object returned by :meth:`Dialect.get_table_names`, 
          :meth:`Dialect.get_view_names` or 
          :meth:`Dialect.get_materialized_view_names` depending on the 
          provided ``kind``. Dialects that want to support a faster 
          implementation should implement this method. 
 
        .. versionadded:: 2.0 
 
        &quot;&quot;&quot;</span>

        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">get_pk_constraint</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">connection</span><span class="s4">: </span><span class="s1">Connection</span><span class="s4">,</span>
        <span class="s1">table_name</span><span class="s4">: </span><span class="s1">str</span><span class="s4">,</span>
        <span class="s1">schema</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s4">**</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; ReflectedPrimaryKeyConstraint</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Return information about the primary key constraint on 
        table_name`. 
 
        Given a :class:`_engine.Connection`, a string 
        ``table_name``, and an optional string ``schema``, return primary 
        key information as a dictionary corresponding to the 
        :class:`.ReflectedPrimaryKeyConstraint` dictionary. 
 
        This is an internal dialect method. Applications should use 
        :meth:`.Inspector.get_pk_constraint`. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">get_multi_pk_constraint</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">connection</span><span class="s4">: </span><span class="s1">Connection</span><span class="s4">,</span>
        <span class="s4">*,</span>
        <span class="s1">schema</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">filter_names</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Collection</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s4">**</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; Iterable</span><span class="s4">[</span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">TableKey</span><span class="s4">, </span><span class="s1">ReflectedPrimaryKeyConstraint</span><span class="s4">]]:</span>
        <span class="s2">&quot;&quot;&quot;Return information about primary key constraints in 
        all tables in the given ``schema``. 
 
        This is an internal dialect method. Applications should use 
        :meth:`.Inspector.get_multi_pk_constraint`. 
 
        .. note:: The :class:`_engine.DefaultDialect` provides a default 
          implementation that will call the single table method for 
          each object returned by :meth:`Dialect.get_table_names`, 
          :meth:`Dialect.get_view_names` or 
          :meth:`Dialect.get_materialized_view_names` depending on the 
          provided ``kind``. Dialects that want to support a faster 
          implementation should implement this method. 
 
        .. versionadded:: 2.0 
 
        &quot;&quot;&quot;</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">get_foreign_keys</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">connection</span><span class="s4">: </span><span class="s1">Connection</span><span class="s4">,</span>
        <span class="s1">table_name</span><span class="s4">: </span><span class="s1">str</span><span class="s4">,</span>
        <span class="s1">schema</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s4">**</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; List</span><span class="s4">[</span><span class="s1">ReflectedForeignKeyConstraint</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;Return information about foreign_keys in ``table_name``. 
 
        Given a :class:`_engine.Connection`, a string 
        ``table_name``, and an optional string ``schema``, return foreign 
        key information as a list of dicts corresponding to the 
        :class:`.ReflectedForeignKeyConstraint` dictionary. 
 
        This is an internal dialect method. Applications should use 
        :meth:`_engine.Inspector.get_foreign_keys`. 
        &quot;&quot;&quot;</span>

        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">get_multi_foreign_keys</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">connection</span><span class="s4">: </span><span class="s1">Connection</span><span class="s4">,</span>
        <span class="s4">*,</span>
        <span class="s1">schema</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">filter_names</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Collection</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s4">**</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; Iterable</span><span class="s4">[</span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">TableKey</span><span class="s4">, </span><span class="s1">List</span><span class="s4">[</span><span class="s1">ReflectedForeignKeyConstraint</span><span class="s4">]]]:</span>
        <span class="s2">&quot;&quot;&quot;Return information about foreign_keys in all tables 
        in the given ``schema``. 
 
        This is an internal dialect method. Applications should use 
        :meth:`_engine.Inspector.get_multi_foreign_keys`. 
 
        .. note:: The :class:`_engine.DefaultDialect` provides a default 
          implementation that will call the single table method for 
          each object returned by :meth:`Dialect.get_table_names`, 
          :meth:`Dialect.get_view_names` or 
          :meth:`Dialect.get_materialized_view_names` depending on the 
          provided ``kind``. Dialects that want to support a faster 
          implementation should implement this method. 
 
        .. versionadded:: 2.0 
 
        &quot;&quot;&quot;</span>

        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">get_table_names</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">connection</span><span class="s4">: </span><span class="s1">Connection</span><span class="s4">, </span><span class="s1">schema</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span>
    <span class="s4">) </span><span class="s1">-&gt; List</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;Return a list of table names for ``schema``. 
 
        This is an internal dialect method. Applications should use 
        :meth:`_engine.Inspector.get_table_names`. 
 
        &quot;&quot;&quot;</span>

        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">get_temp_table_names</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">connection</span><span class="s4">: </span><span class="s1">Connection</span><span class="s4">, </span><span class="s1">schema</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span>
    <span class="s4">) </span><span class="s1">-&gt; List</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;Return a list of temporary table names on the given connection, 
        if supported by the underlying backend. 
 
        This is an internal dialect method. Applications should use 
        :meth:`_engine.Inspector.get_temp_table_names`. 
 
        &quot;&quot;&quot;</span>

        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">get_view_names</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">connection</span><span class="s4">: </span><span class="s1">Connection</span><span class="s4">, </span><span class="s1">schema</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span>
    <span class="s4">) </span><span class="s1">-&gt; List</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;Return a list of all non-materialized view names available in the 
        database. 
 
        This is an internal dialect method. Applications should use 
        :meth:`_engine.Inspector.get_view_names`. 
 
        :param schema: schema name to query, if not the default schema. 
 
        &quot;&quot;&quot;</span>

        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">get_materialized_view_names</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">connection</span><span class="s4">: </span><span class="s1">Connection</span><span class="s4">, </span><span class="s1">schema</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span>
    <span class="s4">) </span><span class="s1">-&gt; List</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;Return a list of all materialized view names available in the 
        database. 
 
        This is an internal dialect method. Applications should use 
        :meth:`_engine.Inspector.get_materialized_view_names`. 
 
        :param schema: schema name to query, if not the default schema. 
 
         .. versionadded:: 2.0 
 
        &quot;&quot;&quot;</span>

        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">get_sequence_names</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">connection</span><span class="s4">: </span><span class="s1">Connection</span><span class="s4">, </span><span class="s1">schema</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span>
    <span class="s4">) </span><span class="s1">-&gt; List</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;Return a list of all sequence names available in the database. 
 
        This is an internal dialect method. Applications should use 
        :meth:`_engine.Inspector.get_sequence_names`. 
 
        :param schema: schema name to query, if not the default schema. 
 
        .. versionadded:: 1.4 
        &quot;&quot;&quot;</span>

        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">get_temp_view_names</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">connection</span><span class="s4">: </span><span class="s1">Connection</span><span class="s4">, </span><span class="s1">schema</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span>
    <span class="s4">) </span><span class="s1">-&gt; List</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;Return a list of temporary view names on the given connection, 
        if supported by the underlying backend. 
 
        This is an internal dialect method. Applications should use 
        :meth:`_engine.Inspector.get_temp_view_names`. 
 
        &quot;&quot;&quot;</span>

        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">get_schema_names</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">connection</span><span class="s4">: </span><span class="s1">Connection</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; List</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;Return a list of all schema names available in the database. 
 
        This is an internal dialect method. Applications should use 
        :meth:`_engine.Inspector.get_schema_names`. 
        &quot;&quot;&quot;</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">get_view_definition</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">connection</span><span class="s4">: </span><span class="s1">Connection</span><span class="s4">,</span>
        <span class="s1">view_name</span><span class="s4">: </span><span class="s1">str</span><span class="s4">,</span>
        <span class="s1">schema</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s4">**</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; str</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Return plain or materialized view definition. 
 
        This is an internal dialect method. Applications should use 
        :meth:`_engine.Inspector.get_view_definition`. 
 
        Given a :class:`_engine.Connection`, a string 
        ``view_name``, and an optional string ``schema``, return the view 
        definition. 
        &quot;&quot;&quot;</span>

        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">get_indexes</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">connection</span><span class="s4">: </span><span class="s1">Connection</span><span class="s4">,</span>
        <span class="s1">table_name</span><span class="s4">: </span><span class="s1">str</span><span class="s4">,</span>
        <span class="s1">schema</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s4">**</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; List</span><span class="s4">[</span><span class="s1">ReflectedIndex</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;Return information about indexes in ``table_name``. 
 
        Given a :class:`_engine.Connection`, a string 
        ``table_name`` and an optional string ``schema``, return index 
        information as a list of dictionaries corresponding to the 
        :class:`.ReflectedIndex` dictionary. 
 
        This is an internal dialect method. Applications should use 
        :meth:`.Inspector.get_indexes`. 
        &quot;&quot;&quot;</span>

        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">get_multi_indexes</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">connection</span><span class="s4">: </span><span class="s1">Connection</span><span class="s4">,</span>
        <span class="s4">*,</span>
        <span class="s1">schema</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">filter_names</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Collection</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s4">**</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; Iterable</span><span class="s4">[</span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">TableKey</span><span class="s4">, </span><span class="s1">List</span><span class="s4">[</span><span class="s1">ReflectedIndex</span><span class="s4">]]]:</span>
        <span class="s2">&quot;&quot;&quot;Return information about indexes in in all tables 
        in the given ``schema``. 
 
        This is an internal dialect method. Applications should use 
        :meth:`.Inspector.get_multi_indexes`. 
 
        .. note:: The :class:`_engine.DefaultDialect` provides a default 
          implementation that will call the single table method for 
          each object returned by :meth:`Dialect.get_table_names`, 
          :meth:`Dialect.get_view_names` or 
          :meth:`Dialect.get_materialized_view_names` depending on the 
          provided ``kind``. Dialects that want to support a faster 
          implementation should implement this method. 
 
        .. versionadded:: 2.0 
 
        &quot;&quot;&quot;</span>

        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">get_unique_constraints</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">connection</span><span class="s4">: </span><span class="s1">Connection</span><span class="s4">,</span>
        <span class="s1">table_name</span><span class="s4">: </span><span class="s1">str</span><span class="s4">,</span>
        <span class="s1">schema</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s4">**</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; List</span><span class="s4">[</span><span class="s1">ReflectedUniqueConstraint</span><span class="s4">]:</span>
        <span class="s2">r&quot;&quot;&quot;Return information about unique constraints in ``table_name``. 
 
        Given a string ``table_name`` and an optional string ``schema``, return 
        unique constraint information as a list of dicts corresponding 
        to the :class:`.ReflectedUniqueConstraint` dictionary. 
 
        This is an internal dialect method. Applications should use 
        :meth:`.Inspector.get_unique_constraints`. 
        &quot;&quot;&quot;</span>

        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">get_multi_unique_constraints</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">connection</span><span class="s4">: </span><span class="s1">Connection</span><span class="s4">,</span>
        <span class="s4">*,</span>
        <span class="s1">schema</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">filter_names</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Collection</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s4">**</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; Iterable</span><span class="s4">[</span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">TableKey</span><span class="s4">, </span><span class="s1">List</span><span class="s4">[</span><span class="s1">ReflectedUniqueConstraint</span><span class="s4">]]]:</span>
        <span class="s2">&quot;&quot;&quot;Return information about unique constraints in all tables 
        in the given ``schema``. 
 
        This is an internal dialect method. Applications should use 
        :meth:`.Inspector.get_multi_unique_constraints`. 
 
        .. note:: The :class:`_engine.DefaultDialect` provides a default 
          implementation that will call the single table method for 
          each object returned by :meth:`Dialect.get_table_names`, 
          :meth:`Dialect.get_view_names` or 
          :meth:`Dialect.get_materialized_view_names` depending on the 
          provided ``kind``. Dialects that want to support a faster 
          implementation should implement this method. 
 
        .. versionadded:: 2.0 
 
        &quot;&quot;&quot;</span>

        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">get_check_constraints</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">connection</span><span class="s4">: </span><span class="s1">Connection</span><span class="s4">,</span>
        <span class="s1">table_name</span><span class="s4">: </span><span class="s1">str</span><span class="s4">,</span>
        <span class="s1">schema</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s4">**</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; List</span><span class="s4">[</span><span class="s1">ReflectedCheckConstraint</span><span class="s4">]:</span>
        <span class="s2">r&quot;&quot;&quot;Return information about check constraints in ``table_name``. 
 
        Given a string ``table_name`` and an optional string ``schema``, return 
        check constraint information as a list of dicts corresponding 
        to the :class:`.ReflectedCheckConstraint` dictionary. 
 
        This is an internal dialect method. Applications should use 
        :meth:`.Inspector.get_check_constraints`. 
 
        &quot;&quot;&quot;</span>

        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">get_multi_check_constraints</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">connection</span><span class="s4">: </span><span class="s1">Connection</span><span class="s4">,</span>
        <span class="s4">*,</span>
        <span class="s1">schema</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">filter_names</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Collection</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s4">**</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; Iterable</span><span class="s4">[</span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">TableKey</span><span class="s4">, </span><span class="s1">List</span><span class="s4">[</span><span class="s1">ReflectedCheckConstraint</span><span class="s4">]]]:</span>
        <span class="s2">&quot;&quot;&quot;Return information about check constraints in all tables 
        in the given ``schema``. 
 
        This is an internal dialect method. Applications should use 
        :meth:`.Inspector.get_multi_check_constraints`. 
 
        .. note:: The :class:`_engine.DefaultDialect` provides a default 
          implementation that will call the single table method for 
          each object returned by :meth:`Dialect.get_table_names`, 
          :meth:`Dialect.get_view_names` or 
          :meth:`Dialect.get_materialized_view_names` depending on the 
          provided ``kind``. Dialects that want to support a faster 
          implementation should implement this method. 
 
        .. versionadded:: 2.0 
 
        &quot;&quot;&quot;</span>

        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">get_table_options</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">connection</span><span class="s4">: </span><span class="s1">Connection</span><span class="s4">,</span>
        <span class="s1">table_name</span><span class="s4">: </span><span class="s1">str</span><span class="s4">,</span>
        <span class="s1">schema</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s4">**</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; Dict</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">Any</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;Return a dictionary of options specified when ``table_name`` 
        was created. 
 
        This is an internal dialect method. Applications should use 
        :meth:`_engine.Inspector.get_table_options`. 
        &quot;&quot;&quot;</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">get_multi_table_options</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">connection</span><span class="s4">: </span><span class="s1">Connection</span><span class="s4">,</span>
        <span class="s4">*,</span>
        <span class="s1">schema</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">filter_names</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Collection</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s4">**</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; Iterable</span><span class="s4">[</span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">TableKey</span><span class="s4">, </span><span class="s1">Dict</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">Any</span><span class="s4">]]]:</span>
        <span class="s2">&quot;&quot;&quot;Return a dictionary of options specified when the tables in the 
        given schema were created. 
 
        This is an internal dialect method. Applications should use 
        :meth:`_engine.Inspector.get_multi_table_options`. 
 
        .. note:: The :class:`_engine.DefaultDialect` provides a default 
          implementation that will call the single table method for 
          each object returned by :meth:`Dialect.get_table_names`, 
          :meth:`Dialect.get_view_names` or 
          :meth:`Dialect.get_materialized_view_names` depending on the 
          provided ``kind``. Dialects that want to support a faster 
          implementation should implement this method. 
 
        .. versionadded:: 2.0 
 
        &quot;&quot;&quot;</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">get_table_comment</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">connection</span><span class="s4">: </span><span class="s1">Connection</span><span class="s4">,</span>
        <span class="s1">table_name</span><span class="s4">: </span><span class="s1">str</span><span class="s4">,</span>
        <span class="s1">schema</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s4">**</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; ReflectedTableComment</span><span class="s4">:</span>
        <span class="s2">r&quot;&quot;&quot;Return the &quot;comment&quot; for the table identified by ``table_name``. 
 
        Given a string ``table_name`` and an optional string ``schema``, return 
        table comment information as a dictionary corresponding to the 
        :class:`.ReflectedTableComment` dictionary. 
 
        This is an internal dialect method. Applications should use 
        :meth:`.Inspector.get_table_comment`. 
 
        :raise: ``NotImplementedError`` for dialects that don't support 
         comments. 
 
        .. versionadded:: 1.2 
 
        &quot;&quot;&quot;</span>

        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">get_multi_table_comment</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">connection</span><span class="s4">: </span><span class="s1">Connection</span><span class="s4">,</span>
        <span class="s4">*,</span>
        <span class="s1">schema</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">filter_names</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Collection</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s4">**</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; Iterable</span><span class="s4">[</span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">TableKey</span><span class="s4">, </span><span class="s1">ReflectedTableComment</span><span class="s4">]]:</span>
        <span class="s2">&quot;&quot;&quot;Return information about the table comment in all tables 
        in the given ``schema``. 
 
        This is an internal dialect method. Applications should use 
        :meth:`_engine.Inspector.get_multi_table_comment`. 
 
        .. note:: The :class:`_engine.DefaultDialect` provides a default 
          implementation that will call the single table method for 
          each object returned by :meth:`Dialect.get_table_names`, 
          :meth:`Dialect.get_view_names` or 
          :meth:`Dialect.get_materialized_view_names` depending on the 
          provided ``kind``. Dialects that want to support a faster 
          implementation should implement this method. 
 
        .. versionadded:: 2.0 
 
        &quot;&quot;&quot;</span>

        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">normalize_name</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">name</span><span class="s4">: </span><span class="s1">str</span><span class="s4">) </span><span class="s1">-&gt; str</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;convert the given name to lowercase if it is detected as 
        case insensitive. 
 
        This method is only used if the dialect defines 
        requires_name_normalize=True. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">denormalize_name</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">name</span><span class="s4">: </span><span class="s1">str</span><span class="s4">) </span><span class="s1">-&gt; str</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;convert the given name to a case insensitive identifier 
        for the backend if it is an all-lowercase name. 
 
        This method is only used if the dialect defines 
        requires_name_normalize=True. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">has_table</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">connection</span><span class="s4">: </span><span class="s1">Connection</span><span class="s4">,</span>
        <span class="s1">table_name</span><span class="s4">: </span><span class="s1">str</span><span class="s4">,</span>
        <span class="s1">schema</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s4">**</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;For internal dialect use, check the existence of a particular table 
        or view in the database. 
 
        Given a :class:`_engine.Connection` object, a string table_name and 
        optional schema name, return True if the given table exists in the 
        database, False otherwise. 
 
        This method serves as the underlying implementation of the 
        public facing :meth:`.Inspector.has_table` method, and is also used 
        internally to implement the &quot;checkfirst&quot; behavior for methods like 
        :meth:`_schema.Table.create` and :meth:`_schema.MetaData.create_all`. 
 
        .. note:: This method is used internally by SQLAlchemy, and is 
           published so that third-party dialects may provide an 
           implementation. It is **not** the public API for checking for table 
           presence. Please use the :meth:`.Inspector.has_table` method. 
 
        .. versionchanged:: 2.0:: :meth:`_engine.Dialect.has_table` now 
           formally supports checking for additional table-like objects: 
 
           * any type of views (plain or materialized) 
           * temporary tables of any kind 
 
           Previously, these two checks were not formally specified and 
           different dialects would vary in their behavior.   The dialect 
           testing suite now includes tests for all of these object types, 
           and dialects to the degree that the backing database supports views 
           or temporary tables should seek to support locating these objects 
           for full compliance. 
 
        &quot;&quot;&quot;</span>

        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">has_index</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">connection</span><span class="s4">: </span><span class="s1">Connection</span><span class="s4">,</span>
        <span class="s1">table_name</span><span class="s4">: </span><span class="s1">str</span><span class="s4">,</span>
        <span class="s1">index_name</span><span class="s4">: </span><span class="s1">str</span><span class="s4">,</span>
        <span class="s1">schema</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s4">**</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Check the existence of a particular index name in the database. 
 
        Given a :class:`_engine.Connection` object, a string 
        ``table_name`` and string index name, return ``True`` if an index of 
        the given name on the given table exists, ``False`` otherwise. 
 
        The :class:`.DefaultDialect` implements this in terms of the 
        :meth:`.Dialect.has_table` and :meth:`.Dialect.get_indexes` methods, 
        however dialects can implement a more performant version. 
 
        This is an internal dialect method. Applications should use 
        :meth:`_engine.Inspector.has_index`. 
 
        .. versionadded:: 1.4 
 
        &quot;&quot;&quot;</span>

        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">has_sequence</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">connection</span><span class="s4">: </span><span class="s1">Connection</span><span class="s4">,</span>
        <span class="s1">sequence_name</span><span class="s4">: </span><span class="s1">str</span><span class="s4">,</span>
        <span class="s1">schema</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s4">**</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Check the existence of a particular sequence in the database. 
 
        Given a :class:`_engine.Connection` object and a string 
        `sequence_name`, return ``True`` if the given sequence exists in 
        the database, ``False`` otherwise. 
 
        This is an internal dialect method. Applications should use 
        :meth:`_engine.Inspector.has_sequence`. 
        &quot;&quot;&quot;</span>

        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">has_schema</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">connection</span><span class="s4">: </span><span class="s1">Connection</span><span class="s4">, </span><span class="s1">schema_name</span><span class="s4">: </span><span class="s1">str</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span>
    <span class="s4">) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Check the existence of a particular schema name in the database. 
 
        Given a :class:`_engine.Connection` object, a string 
        ``schema_name``, return ``True`` if a schema of the 
        given exists, ``False`` otherwise. 
 
        The :class:`.DefaultDialect` implements this by checking 
        the presence of ``schema_name`` among the schemas returned by 
        :meth:`.Dialect.get_schema_names`, 
        however dialects can implement a more performant version. 
 
        This is an internal dialect method. Applications should use 
        :meth:`_engine.Inspector.has_schema`. 
 
        .. versionadded:: 2.0 
 
        &quot;&quot;&quot;</span>

        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">_get_server_version_info</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">connection</span><span class="s4">: </span><span class="s1">Connection</span><span class="s4">) </span><span class="s1">-&gt; Any</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Retrieve the server version info from the given connection. 
 
        This is used by the default implementation to populate the 
        &quot;server_version_info&quot; attribute and is called exactly 
        once upon first connect. 
 
        &quot;&quot;&quot;</span>

        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">_get_default_schema_name</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">connection</span><span class="s4">: </span><span class="s1">Connection</span><span class="s4">) </span><span class="s1">-&gt; str</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Return the string name of the currently selected schema from 
        the given connection. 
 
        This is used by the default implementation to populate the 
        &quot;default_schema_name&quot; attribute and is called exactly 
        once upon first connect. 
 
        &quot;&quot;&quot;</span>

        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">do_begin</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">dbapi_connection</span><span class="s4">: </span><span class="s1">PoolProxiedConnection</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Provide an implementation of ``connection.begin()``, given a 
        DB-API connection. 
 
        The DBAPI has no dedicated &quot;begin&quot; method and it is expected 
        that transactions are implicit.  This hook is provided for those 
        DBAPIs that might need additional help in this area. 
 
        :param dbapi_connection: a DBAPI connection, typically 
         proxied within a :class:`.ConnectionFairy`. 
 
        &quot;&quot;&quot;</span>

        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">do_rollback</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">dbapi_connection</span><span class="s4">: </span><span class="s1">PoolProxiedConnection</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Provide an implementation of ``connection.rollback()``, given 
        a DB-API connection. 
 
        :param dbapi_connection: a DBAPI connection, typically 
         proxied within a :class:`.ConnectionFairy`. 
 
        &quot;&quot;&quot;</span>

        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">do_commit</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">dbapi_connection</span><span class="s4">: </span><span class="s1">PoolProxiedConnection</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Provide an implementation of ``connection.commit()``, given a 
        DB-API connection. 
 
        :param dbapi_connection: a DBAPI connection, typically 
         proxied within a :class:`.ConnectionFairy`. 
 
        &quot;&quot;&quot;</span>

        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">do_terminate</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">dbapi_connection</span><span class="s4">: </span><span class="s1">DBAPIConnection</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Provide an implementation of ``connection.close()`` that tries as 
        much as possible to not block, given a DBAPI 
        connection. 
 
        In the vast majority of cases this just calls .close(), however 
        for some asyncio dialects may call upon different API features. 
 
        This hook is called by the :class:`_pool.Pool` 
        when a connection is being recycled or has been invalidated. 
 
        .. versionadded:: 1.4.41 
 
        &quot;&quot;&quot;</span>

        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">do_close</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">dbapi_connection</span><span class="s4">: </span><span class="s1">DBAPIConnection</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Provide an implementation of ``connection.close()``, given a DBAPI 
        connection. 
 
        This hook is called by the :class:`_pool.Pool` 
        when a connection has been 
        detached from the pool, or is being returned beyond the normal 
        capacity of the pool. 
 
        &quot;&quot;&quot;</span>

        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">_do_ping_w_event</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">dbapi_connection</span><span class="s4">: </span><span class="s1">DBAPIConnection</span><span class="s4">) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">do_ping</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">dbapi_connection</span><span class="s4">: </span><span class="s1">DBAPIConnection</span><span class="s4">) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;ping the DBAPI connection and return True if the connection is 
        usable.&quot;&quot;&quot;</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">do_set_input_sizes</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">cursor</span><span class="s4">: </span><span class="s1">DBAPICursor</span><span class="s4">,</span>
        <span class="s1">list_of_tuples</span><span class="s4">: </span><span class="s1">_GenericSetInputSizesType</span><span class="s4">,</span>
        <span class="s1">context</span><span class="s4">: </span><span class="s1">ExecutionContext</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; Any</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;invoke the cursor.setinputsizes() method with appropriate arguments 
 
        This hook is called if the :attr:`.Dialect.bind_typing` attribute is 
        set to the 
        :attr:`.BindTyping.SETINPUTSIZES` value. 
        Parameter data is passed in a list of tuples (paramname, dbtype, 
        sqltype), where ``paramname`` is the key of the parameter in the 
        statement, ``dbtype`` is the DBAPI datatype and ``sqltype`` is the 
        SQLAlchemy type. The order of tuples is in the correct parameter order. 
 
        .. versionadded:: 1.4 
 
        .. versionchanged:: 2.0  - setinputsizes mode is now enabled by 
           setting :attr:`.Dialect.bind_typing` to 
           :attr:`.BindTyping.SETINPUTSIZES`.  Dialects which accept 
           a ``use_setinputsizes`` parameter should set this value 
           appropriately. 
 
 
        &quot;&quot;&quot;</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">create_xid</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Any</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Create a two-phase transaction ID. 
 
        This id will be passed to do_begin_twophase(), 
        do_rollback_twophase(), do_commit_twophase().  Its format is 
        unspecified. 
        &quot;&quot;&quot;</span>

        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">do_savepoint</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">connection</span><span class="s4">: </span><span class="s1">Connection</span><span class="s4">, </span><span class="s1">name</span><span class="s4">: </span><span class="s1">str</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Create a savepoint with the given name. 
 
        :param connection: a :class:`_engine.Connection`. 
        :param name: savepoint name. 
 
        &quot;&quot;&quot;</span>

        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">do_rollback_to_savepoint</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">connection</span><span class="s4">: </span><span class="s1">Connection</span><span class="s4">, </span><span class="s1">name</span><span class="s4">: </span><span class="s1">str</span>
    <span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Rollback a connection to the named savepoint. 
 
        :param connection: a :class:`_engine.Connection`. 
        :param name: savepoint name. 
 
        &quot;&quot;&quot;</span>

        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">do_release_savepoint</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">connection</span><span class="s4">: </span><span class="s1">Connection</span><span class="s4">, </span><span class="s1">name</span><span class="s4">: </span><span class="s1">str</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Release the named savepoint on a connection. 
 
        :param connection: a :class:`_engine.Connection`. 
        :param name: savepoint name. 
        &quot;&quot;&quot;</span>

        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">do_begin_twophase</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">connection</span><span class="s4">: </span><span class="s1">Connection</span><span class="s4">, </span><span class="s1">xid</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Begin a two phase transaction on the given connection. 
 
        :param connection: a :class:`_engine.Connection`. 
        :param xid: xid 
 
        &quot;&quot;&quot;</span>

        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">do_prepare_twophase</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">connection</span><span class="s4">: </span><span class="s1">Connection</span><span class="s4">, </span><span class="s1">xid</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Prepare a two phase transaction on the given connection. 
 
        :param connection: a :class:`_engine.Connection`. 
        :param xid: xid 
 
        &quot;&quot;&quot;</span>

        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">do_rollback_twophase</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">connection</span><span class="s4">: </span><span class="s1">Connection</span><span class="s4">,</span>
        <span class="s1">xid</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
        <span class="s1">is_prepared</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">True</span><span class="s4">,</span>
        <span class="s1">recover</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Rollback a two phase transaction on the given connection. 
 
        :param connection: a :class:`_engine.Connection`. 
        :param xid: xid 
        :param is_prepared: whether or not 
         :meth:`.TwoPhaseTransaction.prepare` was called. 
        :param recover: if the recover flag was passed. 
 
        &quot;&quot;&quot;</span>

        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">do_commit_twophase</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">connection</span><span class="s4">: </span><span class="s1">Connection</span><span class="s4">,</span>
        <span class="s1">xid</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
        <span class="s1">is_prepared</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">True</span><span class="s4">,</span>
        <span class="s1">recover</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Commit a two phase transaction on the given connection. 
 
 
        :param connection: a :class:`_engine.Connection`. 
        :param xid: xid 
        :param is_prepared: whether or not 
         :meth:`.TwoPhaseTransaction.prepare` was called. 
        :param recover: if the recover flag was passed. 
 
        &quot;&quot;&quot;</span>

        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">do_recover_twophase</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">connection</span><span class="s4">: </span><span class="s1">Connection</span><span class="s4">) </span><span class="s1">-&gt; List</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;Recover list of uncommitted prepared two phase transaction 
        identifiers on the given connection. 
 
        :param connection: a :class:`_engine.Connection`. 
 
        &quot;&quot;&quot;</span>

        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">_deliver_insertmanyvalues_batches</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">connection</span><span class="s4">: </span><span class="s1">Connection</span><span class="s4">,</span>
        <span class="s1">cursor</span><span class="s4">: </span><span class="s1">DBAPICursor</span><span class="s4">,</span>
        <span class="s1">statement</span><span class="s4">: </span><span class="s1">str</span><span class="s4">,</span>
        <span class="s1">parameters</span><span class="s4">: </span><span class="s1">_DBAPIMultiExecuteParams</span><span class="s4">,</span>
        <span class="s1">generic_setinputsizes</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_GenericSetInputSizesType</span><span class="s4">],</span>
        <span class="s1">context</span><span class="s4">: </span><span class="s1">ExecutionContext</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; Iterator</span><span class="s4">[</span><span class="s1">_InsertManyValuesBatch</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;convert executemany parameters for an INSERT into an iterator 
        of statement/single execute values, used by the insertmanyvalues 
        feature. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">do_executemany</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">cursor</span><span class="s4">: </span><span class="s1">DBAPICursor</span><span class="s4">,</span>
        <span class="s1">statement</span><span class="s4">: </span><span class="s1">str</span><span class="s4">,</span>
        <span class="s1">parameters</span><span class="s4">: </span><span class="s1">_DBAPIMultiExecuteParams</span><span class="s4">,</span>
        <span class="s1">context</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">ExecutionContext</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Provide an implementation of ``cursor.executemany(statement, 
        parameters)``.&quot;&quot;&quot;</span>

        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">do_execute</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">cursor</span><span class="s4">: </span><span class="s1">DBAPICursor</span><span class="s4">,</span>
        <span class="s1">statement</span><span class="s4">: </span><span class="s1">str</span><span class="s4">,</span>
        <span class="s1">parameters</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_DBAPISingleExecuteParams</span><span class="s4">],</span>
        <span class="s1">context</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">ExecutionContext</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Provide an implementation of ``cursor.execute(statement, 
        parameters)``.&quot;&quot;&quot;</span>

        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">do_execute_no_params</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">cursor</span><span class="s4">: </span><span class="s1">DBAPICursor</span><span class="s4">,</span>
        <span class="s1">statement</span><span class="s4">: </span><span class="s1">str</span><span class="s4">,</span>
        <span class="s1">context</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">ExecutionContext</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Provide an implementation of ``cursor.execute(statement)``. 
 
        The parameter collection should not be sent. 
 
        &quot;&quot;&quot;</span>

        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">is_disconnect</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">e</span><span class="s4">: </span><span class="s1">Exception</span><span class="s4">,</span>
        <span class="s1">connection</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Union</span><span class="s4">[</span><span class="s1">PoolProxiedConnection</span><span class="s4">, </span><span class="s1">DBAPIConnection</span><span class="s4">]],</span>
        <span class="s1">cursor</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">DBAPICursor</span><span class="s4">],</span>
    <span class="s4">) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Return True if the given DB-API error indicates an invalid 
        connection&quot;&quot;&quot;</span>

        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">connect</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, *</span><span class="s1">cargs</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">, **</span><span class="s1">cparams</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; DBAPIConnection</span><span class="s4">:</span>
        <span class="s2">r&quot;&quot;&quot;Establish a connection using this dialect's DBAPI. 
 
        The default implementation of this method is:: 
 
            def connect(self, *cargs, **cparams): 
                return self.dbapi.connect(*cargs, **cparams) 
 
        The ``*cargs, **cparams`` parameters are generated directly 
        from this dialect's :meth:`.Dialect.create_connect_args` method. 
 
        This method may be used for dialects that need to perform programmatic 
        per-connection steps when a new connection is procured from the 
        DBAPI. 
 
 
        :param \*cargs: positional parameters returned from the 
         :meth:`.Dialect.create_connect_args` method 
 
        :param \*\*cparams: keyword parameters returned from the 
         :meth:`.Dialect.create_connect_args` method. 
 
        :return: a DBAPI connection, typically from the :pep:`249` module 
         level ``.connect()`` function. 
 
        .. seealso:: 
 
            :meth:`.Dialect.create_connect_args` 
 
            :meth:`.Dialect.on_connect` 
 
        &quot;&quot;&quot;</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">on_connect_url</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">url</span><span class="s4">: </span><span class="s1">URL</span><span class="s4">) </span><span class="s1">-&gt; Optional</span><span class="s4">[</span><span class="s1">Callable</span><span class="s4">[[</span><span class="s1">Any</span><span class="s4">], </span><span class="s1">Any</span><span class="s4">]]:</span>
        <span class="s2">&quot;&quot;&quot;return a callable which sets up a newly created DBAPI connection. 
 
        This method is a new hook that supersedes the 
        :meth:`_engine.Dialect.on_connect` method when implemented by a 
        dialect.   When not implemented by a dialect, it invokes the 
        :meth:`_engine.Dialect.on_connect` method directly to maintain 
        compatibility with existing dialects.   There is no deprecation 
        for :meth:`_engine.Dialect.on_connect` expected. 
 
        The callable should accept a single argument &quot;conn&quot; which is the 
        DBAPI connection itself.  The inner callable has no 
        return value. 
 
        E.g.:: 
 
            class MyDialect(default.DefaultDialect): 
                # ... 
 
                def on_connect_url(self, url): 
                    def do_on_connect(connection): 
                        connection.execute(&quot;SET SPECIAL FLAGS etc&quot;) 
 
                    return do_on_connect 
 
        This is used to set dialect-wide per-connection options such as 
        isolation modes, Unicode modes, etc. 
 
        This method differs from :meth:`_engine.Dialect.on_connect` in that 
        it is passed the :class:`_engine.URL` object that's relevant to the 
        connect args.  Normally the only way to get this is from the 
        :meth:`_engine.Dialect.on_connect` hook is to look on the 
        :class:`_engine.Engine` itself, however this URL object may have been 
        replaced by plugins. 
 
        .. note:: 
 
            The default implementation of 
            :meth:`_engine.Dialect.on_connect_url` is to invoke the 
            :meth:`_engine.Dialect.on_connect` method. Therefore if a dialect 
            implements this method, the :meth:`_engine.Dialect.on_connect` 
            method **will not be called** unless the overriding dialect calls 
            it directly from here. 
 
        .. versionadded:: 1.4.3 added :meth:`_engine.Dialect.on_connect_url` 
           which normally calls into :meth:`_engine.Dialect.on_connect`. 
 
        :param url: a :class:`_engine.URL` object representing the 
         :class:`_engine.URL` that was passed to the 
         :meth:`_engine.Dialect.create_connect_args` method. 
 
        :return: a callable that accepts a single DBAPI connection as an 
         argument, or None. 
 
        .. seealso:: 
 
            :meth:`_engine.Dialect.on_connect` 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">on_connect</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">on_connect</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Optional</span><span class="s4">[</span><span class="s1">Callable</span><span class="s4">[[</span><span class="s1">Any</span><span class="s4">], </span><span class="s1">Any</span><span class="s4">]]:</span>
        <span class="s2">&quot;&quot;&quot;return a callable which sets up a newly created DBAPI connection. 
 
        The callable should accept a single argument &quot;conn&quot; which is the 
        DBAPI connection itself.  The inner callable has no 
        return value. 
 
        E.g.:: 
 
            class MyDialect(default.DefaultDialect): 
                # ... 
 
                def on_connect(self): 
                    def do_on_connect(connection): 
                        connection.execute(&quot;SET SPECIAL FLAGS etc&quot;) 
 
                    return do_on_connect 
 
        This is used to set dialect-wide per-connection options such as 
        isolation modes, Unicode modes, etc. 
 
        The &quot;do_on_connect&quot; callable is invoked by using the 
        :meth:`_events.PoolEvents.connect` event 
        hook, then unwrapping the DBAPI connection and passing it into the 
        callable. 
 
        .. versionchanged:: 1.4 the on_connect hook is no longer called twice 
           for the first connection of a dialect.  The on_connect hook is still 
           called before the :meth:`_engine.Dialect.initialize` method however. 
 
        .. versionchanged:: 1.4.3 the on_connect hook is invoked from a new 
           method on_connect_url that passes the URL that was used to create 
           the connect args.   Dialects can implement on_connect_url instead 
           of on_connect if they need the URL object that was used for the 
           connection in order to get additional context. 
 
        If None is returned, no event listener is generated. 
 
        :return: a callable that accepts a single DBAPI connection as an 
         argument, or None. 
 
        .. seealso:: 
 
            :meth:`.Dialect.connect` - allows the DBAPI ``connect()`` sequence 
            itself to be controlled. 
 
            :meth:`.Dialect.on_connect_url` - supersedes 
            :meth:`.Dialect.on_connect` to also receive the 
            :class:`_engine.URL` object in context. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return None</span>

    <span class="s3">def </span><span class="s1">reset_isolation_level</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">dbapi_connection</span><span class="s4">: </span><span class="s1">DBAPIConnection</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Given a DBAPI connection, revert its isolation to the default. 
 
        Note that this is a dialect-level method which is used as part 
        of the implementation of the :class:`_engine.Connection` and 
        :class:`_engine.Engine` 
        isolation level facilities; these APIs should be preferred for 
        most typical use cases. 
 
        .. seealso:: 
 
            :meth:`_engine.Connection.get_isolation_level` 
            - view current level 
 
            :attr:`_engine.Connection.default_isolation_level` 
            - view default level 
 
            :paramref:`.Connection.execution_options.isolation_level` - 
            set per :class:`_engine.Connection` isolation level 
 
            :paramref:`_sa.create_engine.isolation_level` - 
            set per :class:`_engine.Engine` isolation level 
 
        &quot;&quot;&quot;</span>

        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">set_isolation_level</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">dbapi_connection</span><span class="s4">: </span><span class="s1">DBAPIConnection</span><span class="s4">, </span><span class="s1">level</span><span class="s4">: </span><span class="s1">IsolationLevel</span>
    <span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Given a DBAPI connection, set its isolation level. 
 
        Note that this is a dialect-level method which is used as part 
        of the implementation of the :class:`_engine.Connection` and 
        :class:`_engine.Engine` 
        isolation level facilities; these APIs should be preferred for 
        most typical use cases. 
 
        If the dialect also implements the 
        :meth:`.Dialect.get_isolation_level_values` method, then the given 
        level is guaranteed to be one of the string names within that sequence, 
        and the method will not need to anticipate a lookup failure. 
 
        .. seealso:: 
 
            :meth:`_engine.Connection.get_isolation_level` 
            - view current level 
 
            :attr:`_engine.Connection.default_isolation_level` 
            - view default level 
 
            :paramref:`.Connection.execution_options.isolation_level` - 
            set per :class:`_engine.Connection` isolation level 
 
            :paramref:`_sa.create_engine.isolation_level` - 
            set per :class:`_engine.Engine` isolation level 
 
        &quot;&quot;&quot;</span>

        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">get_isolation_level</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">dbapi_connection</span><span class="s4">: </span><span class="s1">DBAPIConnection</span>
    <span class="s4">) </span><span class="s1">-&gt; IsolationLevel</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Given a DBAPI connection, return its isolation level. 
 
        When working with a :class:`_engine.Connection` object, 
        the corresponding 
        DBAPI connection may be procured using the 
        :attr:`_engine.Connection.connection` accessor. 
 
        Note that this is a dialect-level method which is used as part 
        of the implementation of the :class:`_engine.Connection` and 
        :class:`_engine.Engine` isolation level facilities; 
        these APIs should be preferred for most typical use cases. 
 
 
        .. seealso:: 
 
            :meth:`_engine.Connection.get_isolation_level` 
            - view current level 
 
            :attr:`_engine.Connection.default_isolation_level` 
            - view default level 
 
            :paramref:`.Connection.execution_options.isolation_level` - 
            set per :class:`_engine.Connection` isolation level 
 
            :paramref:`_sa.create_engine.isolation_level` - 
            set per :class:`_engine.Engine` isolation level 
 
 
        &quot;&quot;&quot;</span>

        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">get_default_isolation_level</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">dbapi_conn</span><span class="s4">: </span><span class="s1">DBAPIConnection</span>
    <span class="s4">) </span><span class="s1">-&gt; IsolationLevel</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Given a DBAPI connection, return its isolation level, or 
        a default isolation level if one cannot be retrieved. 
 
        This method may only raise NotImplementedError and 
        **must not raise any other exception**, as it is used implicitly upon 
        first connect. 
 
        The method **must return a value** for a dialect that supports 
        isolation level settings, as this level is what will be reverted 
        towards when a per-connection isolation level change is made. 
 
        The method defaults to using the :meth:`.Dialect.get_isolation_level` 
        method unless overridden by a dialect. 
 
        .. versionadded:: 1.3.22 
 
        &quot;&quot;&quot;</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">get_isolation_level_values</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">dbapi_conn</span><span class="s4">: </span><span class="s1">DBAPIConnection</span>
    <span class="s4">) </span><span class="s1">-&gt; List</span><span class="s4">[</span><span class="s1">IsolationLevel</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;return a sequence of string isolation level names that are accepted 
        by this dialect. 
 
        The available names should use the following conventions: 
 
        * use UPPERCASE names.   isolation level methods will accept lowercase 
          names but these are normalized into UPPERCASE before being passed 
          along to the dialect. 
        * separate words should be separated by spaces, not underscores, e.g. 
          ``REPEATABLE READ``.  isolation level names will have underscores 
          converted to spaces before being passed along to the dialect. 
        * The names for the four standard isolation names to the extent that 
          they are supported by the backend should be ``READ UNCOMMITTED`` 
          ``READ COMMITTED``, ``REPEATABLE READ``, ``SERIALIZABLE`` 
        * if the dialect supports an autocommit option it should be provided 
          using the isolation level name ``AUTOCOMMIT``. 
        * Other isolation modes may also be present, provided that they 
          are named in UPPERCASE and use spaces not underscores. 
 
        This function is used so that the default dialect can check that 
        a given isolation level parameter is valid, else raises an 
        :class:`_exc.ArgumentError`. 
 
        A DBAPI connection is passed to the method, in the unlikely event that 
        the dialect needs to interrogate the connection itself to determine 
        this list, however it is expected that most backends will return 
        a hardcoded list of values.  If the dialect supports &quot;AUTOCOMMIT&quot;, 
        that value should also be present in the sequence returned. 
 
        The method raises ``NotImplementedError`` by default.  If a dialect 
        does not implement this method, then the default dialect will not 
        perform any checking on a given isolation level value before passing 
        it onto the :meth:`.Dialect.set_isolation_level` method.  This is 
        to allow backwards-compatibility with third party dialects that may 
        not yet be implementing this method. 
 
        .. versionadded:: 2.0 
 
        &quot;&quot;&quot;</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">_assert_and_set_isolation_level</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">dbapi_conn</span><span class="s4">: </span><span class="s1">DBAPIConnection</span><span class="s4">, </span><span class="s1">level</span><span class="s4">: </span><span class="s1">IsolationLevel</span>
    <span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s4">@</span><span class="s1">classmethod</span>
    <span class="s3">def </span><span class="s1">get_dialect_cls</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">, </span><span class="s1">url</span><span class="s4">: </span><span class="s1">URL</span><span class="s4">) </span><span class="s1">-&gt; Type</span><span class="s4">[</span><span class="s1">Dialect</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;Given a URL, return the :class:`.Dialect` that will be used. 
 
        This is a hook that allows an external plugin to provide functionality 
        around an existing dialect, by allowing the plugin to be loaded 
        from the url based on an entrypoint, and then the plugin returns 
        the actual dialect to be used. 
 
        By default this just returns the cls. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">cls</span>

    <span class="s4">@</span><span class="s1">classmethod</span>
    <span class="s3">def </span><span class="s1">get_async_dialect_cls</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">, </span><span class="s1">url</span><span class="s4">: </span><span class="s1">URL</span><span class="s4">) </span><span class="s1">-&gt; Type</span><span class="s4">[</span><span class="s1">Dialect</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;Given a URL, return the :class:`.Dialect` that will be used by 
        an async engine. 
 
        By default this is an alias of :meth:`.Dialect.get_dialect_cls` and 
        just returns the cls. It may be used if a dialect provides 
        both a sync and async version under the same name, like the 
        ``psycopg`` driver. 
 
        .. versionadded:: 2 
 
        .. seealso:: 
 
            :meth:`.Dialect.get_dialect_cls` 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">cls</span><span class="s4">.</span><span class="s1">get_dialect_cls</span><span class="s4">(</span><span class="s1">url</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">classmethod</span>
    <span class="s3">def </span><span class="s1">load_provisioning</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;set up the provision.py module for this dialect. 
 
        For dialects that include a provision.py module that sets up 
        provisioning followers, this method should initiate that process. 
 
        A typical implementation would be:: 
 
            @classmethod 
            def load_provisioning(cls): 
                __import__(&quot;mydialect.provision&quot;) 
 
        The default method assumes a module named ``provision.py`` inside 
        the owning package of the current dialect, based on the ``__module__`` 
        attribute:: 
 
            @classmethod 
            def load_provisioning(cls): 
                package = &quot;.&quot;.join(cls.__module__.split(&quot;.&quot;)[0:-1]) 
                try: 
                    __import__(package + &quot;.provision&quot;) 
                except ImportError: 
                    pass 
 
        .. versionadded:: 1.3.14 
 
        &quot;&quot;&quot;</span>

    <span class="s4">@</span><span class="s1">classmethod</span>
    <span class="s3">def </span><span class="s1">engine_created</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">, </span><span class="s1">engine</span><span class="s4">: </span><span class="s1">Engine</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;A convenience hook called before returning the final 
        :class:`_engine.Engine`. 
 
        If the dialect returned a different class from the 
        :meth:`.get_dialect_cls` 
        method, then the hook is called on both classes, first on 
        the dialect class returned by the :meth:`.get_dialect_cls` method and 
        then on the class on which the method was called. 
 
        The hook should be used by dialects and/or wrappers to apply special 
        events to the engine or its components.   In particular, it allows 
        a dialect-wrapping class to apply dialect-level events. 
 
        &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">get_driver_connection</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">connection</span><span class="s4">: </span><span class="s1">DBAPIConnection</span><span class="s4">) </span><span class="s1">-&gt; Any</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Returns the connection object as returned by the external driver 
        package. 
 
        For normal dialects that use a DBAPI compliant driver this call 
        will just return the ``connection`` passed as argument. 
        For dialects that instead adapt a non DBAPI compliant driver, like 
        when adapting an asyncio driver, this call will return the 
        connection-like object as returned by the driver. 
 
        .. versionadded:: 1.4.24 
 
        &quot;&quot;&quot;</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">set_engine_execution_options</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">engine</span><span class="s4">: </span><span class="s1">Engine</span><span class="s4">, </span><span class="s1">opts</span><span class="s4">: </span><span class="s1">CoreExecuteOptionsParameter</span>
    <span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Establish execution options for a given engine. 
 
        This is implemented by :class:`.DefaultDialect` to establish 
        event hooks for new :class:`.Connection` instances created 
        by the given :class:`.Engine` which will then invoke the 
        :meth:`.Dialect.set_connection_execution_options` method for that 
        connection. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">set_connection_execution_options</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">connection</span><span class="s4">: </span><span class="s1">Connection</span><span class="s4">, </span><span class="s1">opts</span><span class="s4">: </span><span class="s1">CoreExecuteOptionsParameter</span>
    <span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Establish execution options for a given connection. 
 
        This is implemented by :class:`.DefaultDialect` in order to implement 
        the :paramref:`_engine.Connection.execution_options.isolation_level` 
        execution option.  Dialects can intercept various execution options 
        which may need to modify state on a particular DBAPI connection. 
 
        .. versionadded:: 1.4 
 
        &quot;&quot;&quot;</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">get_dialect_pool_class</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">url</span><span class="s4">: </span><span class="s1">URL</span><span class="s4">) </span><span class="s1">-&gt; Type</span><span class="s4">[</span><span class="s1">Pool</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;return a Pool class to use for a given URL&quot;&quot;&quot;</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>


<span class="s3">class </span><span class="s1">CreateEnginePlugin</span><span class="s4">:</span>
    <span class="s5">&quot;&quot;&quot;A set of hooks intended to augment the construction of an 
    :class:`_engine.Engine` object based on entrypoint names in a URL. 
 
    The purpose of :class:`_engine.CreateEnginePlugin` is to allow third-party 
    systems to apply engine, pool and dialect level event listeners without 
    the need for the target application to be modified; instead, the plugin 
    names can be added to the database URL.  Target applications for 
    :class:`_engine.CreateEnginePlugin` include: 
 
    * connection and SQL performance tools, e.g. which use events to track 
      number of checkouts and/or time spent with statements 
 
    * connectivity plugins such as proxies 
 
    A rudimentary :class:`_engine.CreateEnginePlugin` that attaches a logger 
    to an :class:`_engine.Engine` object might look like:: 
 
 
        import logging 
 
        from sqlalchemy.engine import CreateEnginePlugin 
        from sqlalchemy import event 
 
        class LogCursorEventsPlugin(CreateEnginePlugin): 
            def __init__(self, url, kwargs): 
                # consume the parameter &quot;log_cursor_logging_name&quot; from the 
                # URL query 
                logging_name = url.query.get(&quot;log_cursor_logging_name&quot;, &quot;log_cursor&quot;) 
 
                self.log = logging.getLogger(logging_name) 
 
            def update_url(self, url): 
                &quot;update the URL to one that no longer includes our parameters&quot; 
                return url.difference_update_query([&quot;log_cursor_logging_name&quot;]) 
 
            def engine_created(self, engine): 
                &quot;attach an event listener after the new Engine is constructed&quot; 
                event.listen(engine, &quot;before_cursor_execute&quot;, self._log_event) 
 
 
            def _log_event( 
                self, 
                conn, 
                cursor, 
                statement, 
                parameters, 
                context, 
                executemany): 
 
                self.log.info(&quot;Plugin logged cursor event: %s&quot;, statement) 
 
 
 
    Plugins are registered using entry points in a similar way as that 
    of dialects:: 
 
        entry_points={ 
            'sqlalchemy.plugins': [ 
                'log_cursor_plugin = myapp.plugins:LogCursorEventsPlugin' 
            ] 
 
    A plugin that uses the above names would be invoked from a database 
    URL as in:: 
 
        from sqlalchemy import create_engine 
 
        engine = create_engine( 
            &quot;mysql+pymysql://scott:tiger@localhost/test?&quot; 
            &quot;plugin=log_cursor_plugin&amp;log_cursor_logging_name=mylogger&quot; 
        ) 
 
    The ``plugin`` URL parameter supports multiple instances, so that a URL 
    may specify multiple plugins; they are loaded in the order stated 
    in the URL:: 
 
        engine = create_engine( 
          &quot;mysql+pymysql://scott:tiger@localhost/test?&quot; 
          &quot;plugin=plugin_one&amp;plugin=plugin_twp&amp;plugin=plugin_three&quot;) 
 
    The plugin names may also be passed directly to :func:`_sa.create_engine` 
    using the :paramref:`_sa.create_engine.plugins` argument:: 
 
        engine = create_engine( 
          &quot;mysql+pymysql://scott:tiger@localhost/test&quot;, 
          plugins=[&quot;myplugin&quot;]) 
 
    .. versionadded:: 1.2.3  plugin names can also be specified 
       to :func:`_sa.create_engine` as a list 
 
    A plugin may consume plugin-specific arguments from the 
    :class:`_engine.URL` object as well as the ``kwargs`` dictionary, which is 
    the dictionary of arguments passed to the :func:`_sa.create_engine` 
    call.  &quot;Consuming&quot; these arguments includes that they must be removed 
    when the plugin initializes, so that the arguments are not passed along 
    to the :class:`_engine.Dialect` constructor, where they will raise an 
    :class:`_exc.ArgumentError` because they are not known by the dialect. 
 
    As of version 1.4 of SQLAlchemy, arguments should continue to be consumed 
    from the ``kwargs`` dictionary directly, by removing the values with a 
    method such as ``dict.pop``. Arguments from the :class:`_engine.URL` object 
    should be consumed by implementing the 
    :meth:`_engine.CreateEnginePlugin.update_url` method, returning a new copy 
    of the :class:`_engine.URL` with plugin-specific parameters removed:: 
 
        class MyPlugin(CreateEnginePlugin): 
            def __init__(self, url, kwargs): 
                self.my_argument_one = url.query['my_argument_one'] 
                self.my_argument_two = url.query['my_argument_two'] 
                self.my_argument_three = kwargs.pop('my_argument_three', None) 
 
            def update_url(self, url): 
                return url.difference_update_query( 
                    [&quot;my_argument_one&quot;, &quot;my_argument_two&quot;] 
                ) 
 
    Arguments like those illustrated above would be consumed from a 
    :func:`_sa.create_engine` call such as:: 
 
        from sqlalchemy import create_engine 
 
        engine = create_engine( 
          &quot;mysql+pymysql://scott:tiger@localhost/test?&quot; 
          &quot;plugin=myplugin&amp;my_argument_one=foo&amp;my_argument_two=bar&quot;, 
          my_argument_three='bat' 
        ) 
 
    .. versionchanged:: 1.4 
 
        The :class:`_engine.URL` object is now immutable; a 
        :class:`_engine.CreateEnginePlugin` that needs to alter the 
        :class:`_engine.URL` should implement the newly added 
        :meth:`_engine.CreateEnginePlugin.update_url` method, which 
        is invoked after the plugin is constructed. 
 
        For migration, construct the plugin in the following way, checking 
        for the existence of the :meth:`_engine.CreateEnginePlugin.update_url` 
        method to detect which version is running:: 
 
            class MyPlugin(CreateEnginePlugin): 
                def __init__(self, url, kwargs): 
                    if hasattr(CreateEnginePlugin, &quot;update_url&quot;): 
                        # detect the 1.4 API 
                        self.my_argument_one = url.query['my_argument_one'] 
                        self.my_argument_two = url.query['my_argument_two'] 
                    else: 
                        # detect the 1.3 and earlier API - mutate the 
                        # URL directly 
                        self.my_argument_one = url.query.pop('my_argument_one') 
                        self.my_argument_two = url.query.pop('my_argument_two') 
 
                    self.my_argument_three = kwargs.pop('my_argument_three', None) 
 
                def update_url(self, url): 
                    # this method is only called in the 1.4 version 
                    return url.difference_update_query( 
                        [&quot;my_argument_one&quot;, &quot;my_argument_two&quot;] 
                    ) 
 
        .. seealso:: 
 
            :ref:`change_5526` - overview of the :class:`_engine.URL` change which 
            also includes notes regarding :class:`_engine.CreateEnginePlugin`. 
 
 
    When the engine creation process completes and produces the 
    :class:`_engine.Engine` object, it is again passed to the plugin via the 
    :meth:`_engine.CreateEnginePlugin.engine_created` hook.  In this hook, additional 
    changes can be made to the engine, most typically involving setup of 
    events (e.g. those defined in :ref:`core_event_toplevel`). 
 
    &quot;&quot;&quot;  </span><span class="s0"># noqa: E501</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">url</span><span class="s4">: </span><span class="s1">URL</span><span class="s4">, </span><span class="s1">kwargs</span><span class="s4">: </span><span class="s1">Dict</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">Any</span><span class="s4">]):</span>
        <span class="s2">&quot;&quot;&quot;Construct a new :class:`.CreateEnginePlugin`. 
 
        The plugin object is instantiated individually for each call 
        to :func:`_sa.create_engine`.  A single :class:`_engine. 
        Engine` will be 
        passed to the :meth:`.CreateEnginePlugin.engine_created` method 
        corresponding to this URL. 
 
        :param url: the :class:`_engine.URL` object.  The plugin may inspect 
         the :class:`_engine.URL` for arguments.  Arguments used by the 
         plugin should be removed, by returning an updated :class:`_engine.URL` 
         from the :meth:`_engine.CreateEnginePlugin.update_url` method. 
 
         .. versionchanged::  1.4 
 
            The :class:`_engine.URL` object is now immutable, so a 
            :class:`_engine.CreateEnginePlugin` that needs to alter the 
            :class:`_engine.URL` object should implement the 
            :meth:`_engine.CreateEnginePlugin.update_url` method. 
 
        :param kwargs: The keyword arguments passed to 
         :func:`_sa.create_engine`. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">url </span><span class="s4">= </span><span class="s1">url</span>

    <span class="s3">def </span><span class="s1">update_url</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">url</span><span class="s4">: </span><span class="s1">URL</span><span class="s4">) </span><span class="s1">-&gt; URL</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Update the :class:`_engine.URL`. 
 
        A new :class:`_engine.URL` should be returned.   This method is 
        typically used to consume configuration arguments from the 
        :class:`_engine.URL` which must be removed, as they will not be 
        recognized by the dialect.  The 
        :meth:`_engine.URL.difference_update_query` method is available 
        to remove these arguments.   See the docstring at 
        :class:`_engine.CreateEnginePlugin` for an example. 
 
 
        .. versionadded:: 1.4 
 
        &quot;&quot;&quot;</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">handle_dialect_kwargs</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">dialect_cls</span><span class="s4">: </span><span class="s1">Type</span><span class="s4">[</span><span class="s1">Dialect</span><span class="s4">], </span><span class="s1">dialect_args</span><span class="s4">: </span><span class="s1">Dict</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">Any</span><span class="s4">]</span>
    <span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;parse and modify dialect kwargs&quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">handle_pool_kwargs</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">pool_cls</span><span class="s4">: </span><span class="s1">Type</span><span class="s4">[</span><span class="s1">Pool</span><span class="s4">], </span><span class="s1">pool_args</span><span class="s4">: </span><span class="s1">Dict</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">Any</span><span class="s4">]</span>
    <span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;parse and modify pool kwargs&quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">engine_created</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">engine</span><span class="s4">: </span><span class="s1">Engine</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Receive the :class:`_engine.Engine` 
        object when it is fully constructed. 
 
        The plugin may make additional changes to the engine, such as 
        registering engine or connection pool events. 
 
        &quot;&quot;&quot;</span>


<span class="s3">class </span><span class="s1">ExecutionContext</span><span class="s4">:</span>
    <span class="s2">&quot;&quot;&quot;A messenger object for a Dialect that corresponds to a single 
    execution. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">engine</span><span class="s4">: </span><span class="s1">Engine</span>
    <span class="s5">&quot;&quot;&quot;engine which the Connection is associated with&quot;&quot;&quot;</span>

    <span class="s1">connection</span><span class="s4">: </span><span class="s1">Connection</span>
    <span class="s5">&quot;&quot;&quot;Connection object which can be freely used by default value 
      generators to execute SQL.  This Connection should reference the 
      same underlying connection/transactional resources of 
      root_connection.&quot;&quot;&quot;</span>

    <span class="s1">root_connection</span><span class="s4">: </span><span class="s1">Connection</span>
    <span class="s5">&quot;&quot;&quot;Connection object which is the source of this ExecutionContext.&quot;&quot;&quot;</span>

    <span class="s1">dialect</span><span class="s4">: </span><span class="s1">Dialect</span>
    <span class="s5">&quot;&quot;&quot;dialect which created this ExecutionContext.&quot;&quot;&quot;</span>

    <span class="s1">cursor</span><span class="s4">: </span><span class="s1">DBAPICursor</span>
    <span class="s5">&quot;&quot;&quot;DB-API cursor procured from the connection&quot;&quot;&quot;</span>

    <span class="s1">compiled</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Compiled</span><span class="s4">]</span>
    <span class="s5">&quot;&quot;&quot;if passed to constructor, sqlalchemy.engine.base.Compiled object 
      being executed&quot;&quot;&quot;</span>

    <span class="s1">statement</span><span class="s4">: </span><span class="s1">str</span>
    <span class="s5">&quot;&quot;&quot;string version of the statement to be executed.  Is either 
      passed to the constructor, or must be created from the 
      sql.Compiled object by the time pre_exec() has completed.&quot;&quot;&quot;</span>

    <span class="s1">invoked_statement</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Executable</span><span class="s4">]</span>
    <span class="s5">&quot;&quot;&quot;The Executable statement object that was given in the first place. 
 
    This should be structurally equivalent to compiled.statement, but not 
    necessarily the same object as in a caching scenario the compiled form 
    will have been extracted from the cache. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">parameters</span><span class="s4">: </span><span class="s1">_AnyMultiExecuteParams</span>
    <span class="s5">&quot;&quot;&quot;bind parameters passed to the execute() or exec_driver_sql() methods. 
 
    These are always stored as a list of parameter entries.  A single-element 
    list corresponds to a ``cursor.execute()`` call and a multiple-element 
    list corresponds to ``cursor.executemany()``, except in the case 
    of :attr:`.ExecuteStyle.INSERTMANYVALUES` which will use 
    ``cursor.execute()`` one or more times. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">no_parameters</span><span class="s4">: </span><span class="s1">bool</span>
    <span class="s5">&quot;&quot;&quot;True if the execution style does not use parameters&quot;&quot;&quot;</span>

    <span class="s1">isinsert</span><span class="s4">: </span><span class="s1">bool</span>
    <span class="s5">&quot;&quot;&quot;True if the statement is an INSERT.&quot;&quot;&quot;</span>

    <span class="s1">isupdate</span><span class="s4">: </span><span class="s1">bool</span>
    <span class="s5">&quot;&quot;&quot;True if the statement is an UPDATE.&quot;&quot;&quot;</span>

    <span class="s1">execute_style</span><span class="s4">: </span><span class="s1">ExecuteStyle</span>
    <span class="s5">&quot;&quot;&quot;the style of DBAPI cursor method that will be used to execute 
    a statement. 
 
    .. versionadded:: 2.0 
 
    &quot;&quot;&quot;</span>

    <span class="s1">executemany</span><span class="s4">: </span><span class="s1">bool</span>
    <span class="s5">&quot;&quot;&quot;True if the context has a list of more than one parameter set. 
 
    Historically this attribute links to whether ``cursor.execute()`` or 
    ``cursor.executemany()`` will be used.  It also can now mean that 
    &quot;insertmanyvalues&quot; may be used which indicates one or more 
    ``cursor.execute()`` calls. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">prefetch_cols</span><span class="s4">: </span><span class="s1">util</span><span class="s4">.</span><span class="s1">generic_fn_descriptor</span><span class="s4">[</span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Sequence</span><span class="s4">[</span><span class="s1">Column</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]]]</span>
    <span class="s5">&quot;&quot;&quot;a list of Column objects for which a client-side default 
      was fired off.  Applies to inserts and updates.&quot;&quot;&quot;</span>

    <span class="s1">postfetch_cols</span><span class="s4">: </span><span class="s1">util</span><span class="s4">.</span><span class="s1">generic_fn_descriptor</span><span class="s4">[</span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Sequence</span><span class="s4">[</span><span class="s1">Column</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]]]</span>
    <span class="s5">&quot;&quot;&quot;a list of Column objects for which a server-side default or 
      inline SQL expression value was fired off.  Applies to inserts 
      and updates.&quot;&quot;&quot;</span>

    <span class="s1">execution_options</span><span class="s4">: </span><span class="s1">_ExecuteOptions</span>
    <span class="s5">&quot;&quot;&quot;Execution options associated with the current statement execution&quot;&quot;&quot;</span>

    <span class="s4">@</span><span class="s1">classmethod</span>
    <span class="s3">def </span><span class="s1">_init_ddl</span><span class="s4">(</span>
        <span class="s1">cls</span><span class="s4">,</span>
        <span class="s1">dialect</span><span class="s4">: </span><span class="s1">Dialect</span><span class="s4">,</span>
        <span class="s1">connection</span><span class="s4">: </span><span class="s1">Connection</span><span class="s4">,</span>
        <span class="s1">dbapi_connection</span><span class="s4">: </span><span class="s1">PoolProxiedConnection</span><span class="s4">,</span>
        <span class="s1">execution_options</span><span class="s4">: </span><span class="s1">_ExecuteOptions</span><span class="s4">,</span>
        <span class="s1">compiled_ddl</span><span class="s4">: </span><span class="s1">DDLCompiler</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; ExecutionContext</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s4">@</span><span class="s1">classmethod</span>
    <span class="s3">def </span><span class="s1">_init_compiled</span><span class="s4">(</span>
        <span class="s1">cls</span><span class="s4">,</span>
        <span class="s1">dialect</span><span class="s4">: </span><span class="s1">Dialect</span><span class="s4">,</span>
        <span class="s1">connection</span><span class="s4">: </span><span class="s1">Connection</span><span class="s4">,</span>
        <span class="s1">dbapi_connection</span><span class="s4">: </span><span class="s1">PoolProxiedConnection</span><span class="s4">,</span>
        <span class="s1">execution_options</span><span class="s4">: </span><span class="s1">_ExecuteOptions</span><span class="s4">,</span>
        <span class="s1">compiled</span><span class="s4">: </span><span class="s1">SQLCompiler</span><span class="s4">,</span>
        <span class="s1">parameters</span><span class="s4">: </span><span class="s1">_CoreMultiExecuteParams</span><span class="s4">,</span>
        <span class="s1">invoked_statement</span><span class="s4">: </span><span class="s1">Executable</span><span class="s4">,</span>
        <span class="s1">extracted_parameters</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Sequence</span><span class="s4">[</span><span class="s1">BindParameter</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]],</span>
        <span class="s1">cache_hit</span><span class="s4">: </span><span class="s1">CacheStats </span><span class="s4">= </span><span class="s1">CacheStats</span><span class="s4">.</span><span class="s1">CACHING_DISABLED</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; ExecutionContext</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s4">@</span><span class="s1">classmethod</span>
    <span class="s3">def </span><span class="s1">_init_statement</span><span class="s4">(</span>
        <span class="s1">cls</span><span class="s4">,</span>
        <span class="s1">dialect</span><span class="s4">: </span><span class="s1">Dialect</span><span class="s4">,</span>
        <span class="s1">connection</span><span class="s4">: </span><span class="s1">Connection</span><span class="s4">,</span>
        <span class="s1">dbapi_connection</span><span class="s4">: </span><span class="s1">PoolProxiedConnection</span><span class="s4">,</span>
        <span class="s1">execution_options</span><span class="s4">: </span><span class="s1">_ExecuteOptions</span><span class="s4">,</span>
        <span class="s1">statement</span><span class="s4">: </span><span class="s1">str</span><span class="s4">,</span>
        <span class="s1">parameters</span><span class="s4">: </span><span class="s1">_DBAPIMultiExecuteParams</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; ExecutionContext</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s4">@</span><span class="s1">classmethod</span>
    <span class="s3">def </span><span class="s1">_init_default</span><span class="s4">(</span>
        <span class="s1">cls</span><span class="s4">,</span>
        <span class="s1">dialect</span><span class="s4">: </span><span class="s1">Dialect</span><span class="s4">,</span>
        <span class="s1">connection</span><span class="s4">: </span><span class="s1">Connection</span><span class="s4">,</span>
        <span class="s1">dbapi_connection</span><span class="s4">: </span><span class="s1">PoolProxiedConnection</span><span class="s4">,</span>
        <span class="s1">execution_options</span><span class="s4">: </span><span class="s1">_ExecuteOptions</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; ExecutionContext</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">_exec_default</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">column</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Column</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]],</span>
        <span class="s1">default</span><span class="s4">: </span><span class="s1">DefaultGenerator</span><span class="s4">,</span>
        <span class="s1">type_</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">TypeEngine</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]],</span>
    <span class="s4">) </span><span class="s1">-&gt; Any</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">_prepare_set_input_sizes</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; Optional</span><span class="s4">[</span><span class="s1">List</span><span class="s4">[</span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">Any</span><span class="s4">, </span><span class="s1">TypeEngine</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]]]:</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">_get_cache_stats</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; str</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">_setup_result_proxy</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; CursorResult</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]:</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">fire_sequence</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">seq</span><span class="s4">: </span><span class="s1">Sequence_SchemaItem</span><span class="s4">, </span><span class="s1">type_</span><span class="s4">: </span><span class="s1">Integer</span><span class="s4">) </span><span class="s1">-&gt; int</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;given a :class:`.Sequence`, invoke it and return the next int 
        value&quot;&quot;&quot;</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">create_cursor</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; DBAPICursor</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Return a new cursor generated from this ExecutionContext's 
        connection. 
 
        Some dialects may wish to change the behavior of 
        connection.cursor(), such as postgresql which may return a PG 
        &quot;server side&quot; cursor. 
        &quot;&quot;&quot;</span>

        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">pre_exec</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Called before an execution of a compiled statement. 
 
        If a compiled statement was passed to this ExecutionContext, 
        the `statement` and `parameters` datamembers must be 
        initialized after this statement is complete. 
        &quot;&quot;&quot;</span>

        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">get_out_parameter_values</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">out_param_names</span><span class="s4">: </span><span class="s1">Sequence</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]</span>
    <span class="s4">) </span><span class="s1">-&gt; Sequence</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;Return a sequence of OUT parameter values from a cursor. 
 
        For dialects that support OUT parameters, this method will be called 
        when there is a :class:`.SQLCompiler` object which has the 
        :attr:`.SQLCompiler.has_out_parameters` flag set.  This flag in turn 
        will be set to True if the statement itself has :class:`.BindParameter` 
        objects that have the ``.isoutparam`` flag set which are consumed by 
        the :meth:`.SQLCompiler.visit_bindparam` method.  If the dialect 
        compiler produces :class:`.BindParameter` objects with ``.isoutparam`` 
        set which are not handled by :meth:`.SQLCompiler.visit_bindparam`, it 
        should set this flag explicitly. 
 
        The list of names that were rendered for each bound parameter 
        is passed to the method.  The method should then return a sequence of 
        values corresponding to the list of parameter objects. Unlike in 
        previous SQLAlchemy versions, the values can be the **raw values** from 
        the DBAPI; the execution context will apply the appropriate type 
        handler based on what's present in self.compiled.binds and update the 
        values.  The processed dictionary will then be made available via the 
        ``.out_parameters`` collection on the result object.  Note that 
        SQLAlchemy 1.4 has multiple kinds of result object as part of the 2.0 
        transition. 
 
        .. versionadded:: 1.4 - added 
           :meth:`.ExecutionContext.get_out_parameter_values`, which is invoked 
           automatically by the :class:`.DefaultExecutionContext` when there 
           are :class:`.BindParameter` objects with the ``.isoutparam`` flag 
           set.  This replaces the practice of setting out parameters within 
           the now-removed ``get_result_proxy()`` method. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">post_exec</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Called after the execution of a compiled statement. 
 
        If a compiled statement was passed to this ExecutionContext, 
        the `last_insert_ids`, `last_inserted_params`, etc. 
        datamembers should be available after this method completes. 
        &quot;&quot;&quot;</span>

        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">handle_dbapi_exception</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">e</span><span class="s4">: </span><span class="s1">BaseException</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Receive a DBAPI exception which occurred upon execute, result 
        fetch, etc.&quot;&quot;&quot;</span>

        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">lastrow_has_defaults</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Return True if the last INSERT or UPDATE row contained 
        inlined or database-side defaults. 
        &quot;&quot;&quot;</span>

        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">get_rowcount</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Optional</span><span class="s4">[</span><span class="s1">int</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;Return the DBAPI ``cursor.rowcount`` value, or in some 
        cases an interpreted value. 
 
        See :attr:`_engine.CursorResult.rowcount` for details on this. 
 
        &quot;&quot;&quot;</span>

        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">fetchall_for_returning</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">cursor</span><span class="s4">: </span><span class="s1">DBAPICursor</span><span class="s4">) </span><span class="s1">-&gt; Sequence</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;For a RETURNING result, deliver cursor.fetchall() from the 
        DBAPI cursor. 
 
        This is a dialect-specific hook for dialects that have special 
        considerations when calling upon the rows delivered for a 
        &quot;RETURNING&quot; statement.   Default implementation is 
        ``cursor.fetchall()``. 
 
        This hook is currently used only by the :term:`insertmanyvalues` 
        feature.   Dialects that don't set ``use_insertmanyvalues=True`` 
        don't need to consider this hook. 
 
        .. versionadded:: 2.0.10 
 
        &quot;&quot;&quot;</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>


<span class="s3">class </span><span class="s1">ConnectionEventsTarget</span><span class="s4">(</span><span class="s1">EventTarget</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;An object which can accept events from :class:`.ConnectionEvents`. 
 
    Includes :class:`_engine.Connection` and :class:`_engine.Engine`. 
 
    .. versionadded:: 2.0 
 
    &quot;&quot;&quot;</span>

    <span class="s1">dispatch</span><span class="s4">: </span><span class="s1">dispatcher</span><span class="s4">[</span><span class="s1">ConnectionEventsTarget</span><span class="s4">]</span>


<span class="s1">Connectable </span><span class="s4">= </span><span class="s1">ConnectionEventsTarget</span>


<span class="s3">class </span><span class="s1">ExceptionContext</span><span class="s4">:</span>
    <span class="s2">&quot;&quot;&quot;Encapsulate information about an error condition in progress. 
 
    This object exists solely to be passed to the 
    :meth:`_events.DialectEvents.handle_error` event, 
    supporting an interface that 
    can be extended without backwards-incompatibility. 
 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__slots__ </span><span class="s4">= ()</span>

    <span class="s1">dialect</span><span class="s4">: </span><span class="s1">Dialect</span>
    <span class="s5">&quot;&quot;&quot;The :class:`_engine.Dialect` in use. 
 
    This member is present for all invocations of the event hook. 
 
    .. versionadded:: 2.0 
 
    &quot;&quot;&quot;</span>

    <span class="s1">connection</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Connection</span><span class="s4">]</span>
    <span class="s5">&quot;&quot;&quot;The :class:`_engine.Connection` in use during the exception. 
 
    This member is present, except in the case of a failure when 
    first connecting. 
 
    .. seealso:: 
 
        :attr:`.ExceptionContext.engine` 
 
 
    &quot;&quot;&quot;</span>

    <span class="s1">engine</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Engine</span><span class="s4">]</span>
    <span class="s5">&quot;&quot;&quot;The :class:`_engine.Engine` in use during the exception. 
 
    This member is present in all cases except for when handling an error 
    within the connection pool &quot;pre-ping&quot; process. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">cursor</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">DBAPICursor</span><span class="s4">]</span>
    <span class="s5">&quot;&quot;&quot;The DBAPI cursor object. 
 
    May be None. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">statement</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]</span>
    <span class="s5">&quot;&quot;&quot;String SQL statement that was emitted directly to the DBAPI. 
 
    May be None. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">parameters</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_DBAPIAnyExecuteParams</span><span class="s4">]</span>
    <span class="s5">&quot;&quot;&quot;Parameter collection that was emitted directly to the DBAPI. 
 
    May be None. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">original_exception</span><span class="s4">: </span><span class="s1">BaseException</span>
    <span class="s5">&quot;&quot;&quot;The exception object which was caught. 
 
    This member is always present. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">sqlalchemy_exception</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">StatementError</span><span class="s4">]</span>
    <span class="s5">&quot;&quot;&quot;The :class:`sqlalchemy.exc.StatementError` which wraps the original, 
    and will be raised if exception handling is not circumvented by the event. 
 
    May be None, as not all exception types are wrapped by SQLAlchemy. 
    For DBAPI-level exceptions that subclass the dbapi's Error class, this 
    field will always be present. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">chained_exception</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">BaseException</span><span class="s4">]</span>
    <span class="s5">&quot;&quot;&quot;The exception that was returned by the previous handler in the 
    exception chain, if any. 
 
    If present, this exception will be the one ultimately raised by 
    SQLAlchemy unless a subsequent handler replaces it. 
 
    May be None. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">execution_context</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">ExecutionContext</span><span class="s4">]</span>
    <span class="s5">&quot;&quot;&quot;The :class:`.ExecutionContext` corresponding to the execution 
    operation in progress. 
 
    This is present for statement execution operations, but not for 
    operations such as transaction begin/end.  It also is not present when 
    the exception was raised before the :class:`.ExecutionContext` 
    could be constructed. 
 
    Note that the :attr:`.ExceptionContext.statement` and 
    :attr:`.ExceptionContext.parameters` members may represent a 
    different value than that of the :class:`.ExecutionContext`, 
    potentially in the case where a 
    :meth:`_events.ConnectionEvents.before_cursor_execute` event or similar 
    modified the statement/parameters to be sent. 
 
    May be None. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">is_disconnect</span><span class="s4">: </span><span class="s1">bool</span>
    <span class="s5">&quot;&quot;&quot;Represent whether the exception as occurred represents a &quot;disconnect&quot; 
    condition. 
 
    This flag will always be True or False within the scope of the 
    :meth:`_events.DialectEvents.handle_error` handler. 
 
    SQLAlchemy will defer to this flag in order to determine whether or not 
    the connection should be invalidated subsequently.    That is, by 
    assigning to this flag, a &quot;disconnect&quot; event which then results in 
    a connection and pool invalidation can be invoked or prevented by 
    changing this flag. 
 
 
    .. note:: The pool &quot;pre_ping&quot; handler enabled using the 
        :paramref:`_sa.create_engine.pool_pre_ping` parameter does **not** 
        consult this event before deciding if the &quot;ping&quot; returned false, 
        as opposed to receiving an unhandled error.   For this use case, the 
        :ref:`legacy recipe based on engine_connect() may be used 
        &lt;pool_disconnects_pessimistic_custom&gt;`.  A future API allow more 
        comprehensive customization of the &quot;disconnect&quot; detection mechanism 
        across all functions. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">invalidate_pool_on_disconnect</span><span class="s4">: </span><span class="s1">bool</span>
    <span class="s5">&quot;&quot;&quot;Represent whether all connections in the pool should be invalidated 
    when a &quot;disconnect&quot; condition is in effect. 
 
    Setting this flag to False within the scope of the 
    :meth:`_events.DialectEvents.handle_error` 
    event will have the effect such 
    that the full collection of connections in the pool will not be 
    invalidated during a disconnect; only the current connection that is the 
    subject of the error will actually be invalidated. 
 
    The purpose of this flag is for custom disconnect-handling schemes where 
    the invalidation of other connections in the pool is to be performed 
    based on other conditions, or even on a per-connection basis. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">is_pre_ping</span><span class="s4">: </span><span class="s1">bool</span>
    <span class="s5">&quot;&quot;&quot;Indicates if this error is occurring within the &quot;pre-ping&quot; step 
    performed when :paramref:`_sa.create_engine.pool_pre_ping` is set to 
    ``True``.  In this mode, the :attr:`.ExceptionContext.engine` attribute 
    will be ``None``.  The dialect in use is accessible via the 
    :attr:`.ExceptionContext.dialect` attribute. 
 
    .. versionadded:: 2.0.5 
 
    &quot;&quot;&quot;</span>


<span class="s3">class </span><span class="s1">AdaptedConnection</span><span class="s4">:</span>
    <span class="s2">&quot;&quot;&quot;Interface of an adapted connection object to support the DBAPI protocol. 
 
    Used by asyncio dialects to provide a sync-style pep-249 facade on top 
    of the asyncio connection/cursor API provided by the driver. 
 
    .. versionadded:: 1.4.24 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__slots__ </span><span class="s4">= (</span><span class="s5">&quot;_connection&quot;</span><span class="s4">,)</span>

    <span class="s1">_connection</span><span class="s4">: </span><span class="s1">Any</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">driver_connection</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Any</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;The connection object as returned by the driver after a connect.&quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_connection</span>

    <span class="s3">def </span><span class="s1">run_async</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">fn</span><span class="s4">: </span><span class="s1">Callable</span><span class="s4">[[</span><span class="s1">Any</span><span class="s4">], </span><span class="s1">Awaitable</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]]) </span><span class="s1">-&gt; _T</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Run the awaitable returned by the given function, which is passed 
        the raw asyncio driver connection. 
 
        This is used to invoke awaitable-only methods on the driver connection 
        within the context of a &quot;synchronous&quot; method, like a connection 
        pool event handler. 
 
        E.g.:: 
 
            engine = create_async_engine(...) 
 
            @event.listens_for(engine.sync_engine, &quot;connect&quot;) 
            def register_custom_types(dbapi_connection, ...): 
                dbapi_connection.run_async( 
                    lambda connection: connection.set_type_codec( 
                        'MyCustomType', encoder, decoder, ... 
                    ) 
                ) 
 
        .. versionadded:: 1.4.30 
 
        .. seealso:: 
 
            :ref:`asyncio_events_run_async` 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">await_only</span><span class="s4">(</span><span class="s1">fn</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_connection</span><span class="s4">))</span>

    <span class="s3">def </span><span class="s1">__repr__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; str</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s5">&quot;&lt;AdaptedConnection %s&gt;&quot; </span><span class="s4">% </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_connection</span>
</pre>
</body>
</html>