<html>
<head>
<title>_dispatcher.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #5f826b; font-style: italic;}
.s4 { color: #6aab73;}
.s5 { color: #7a7e85;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_dispatcher.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">abc </span><span class="s0">import </span><span class="s1">abstractmethod</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">List</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">from </span><span class="s1">scipy</span><span class="s2">.</span><span class="s1">sparse </span><span class="s0">import </span><span class="s1">issparse</span>

<span class="s0">from </span><span class="s2">... </span><span class="s0">import </span><span class="s1">get_config</span>
<span class="s0">from </span><span class="s2">..</span><span class="s1">_dist_metrics </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">BOOL_METRICS</span><span class="s2">,</span>
    <span class="s1">METRIC_MAPPING64</span><span class="s2">,</span>
    <span class="s1">DistanceMetric</span><span class="s2">,</span>
<span class="s2">)</span>
<span class="s0">from </span><span class="s2">.</span><span class="s1">_argkmin </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">ArgKmin32</span><span class="s2">,</span>
    <span class="s1">ArgKmin64</span><span class="s2">,</span>
<span class="s2">)</span>
<span class="s0">from </span><span class="s2">.</span><span class="s1">_argkmin_classmode </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">ArgKminClassMode32</span><span class="s2">,</span>
    <span class="s1">ArgKminClassMode64</span><span class="s2">,</span>
<span class="s2">)</span>
<span class="s0">from </span><span class="s2">.</span><span class="s1">_base </span><span class="s0">import </span><span class="s1">_sqeuclidean_row_norms32</span><span class="s2">, </span><span class="s1">_sqeuclidean_row_norms64</span>
<span class="s0">from </span><span class="s2">.</span><span class="s1">_radius_neighbors </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">RadiusNeighbors32</span><span class="s2">,</span>
    <span class="s1">RadiusNeighbors64</span><span class="s2">,</span>
<span class="s2">)</span>
<span class="s0">from </span><span class="s2">.</span><span class="s1">_radius_neighbors_classmode </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">RadiusNeighborsClassMode32</span><span class="s2">,</span>
    <span class="s1">RadiusNeighborsClassMode64</span><span class="s2">,</span>
<span class="s2">)</span>


<span class="s0">def </span><span class="s1">sqeuclidean_row_norms</span><span class="s2">(</span><span class="s1">X</span><span class="s2">, </span><span class="s1">num_threads</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot;Compute the squared euclidean norm of the rows of X in parallel. 
 
    Parameters 
    ---------- 
    X : ndarray or CSR matrix of shape (n_samples, n_features) 
        Input data. Must be c-contiguous. 
 
    num_threads : int 
        The number of OpenMP threads to use. 
 
    Returns 
    ------- 
    sqeuclidean_row_norms : ndarray of shape (n_samples,) 
        Arrays containing the squared euclidean norm of each row of X. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">X</span><span class="s2">.</span><span class="s1">dtype </span><span class="s2">== </span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">_sqeuclidean_row_norms64</span><span class="s2">(</span><span class="s1">X</span><span class="s2">, </span><span class="s1">num_threads</span><span class="s2">))</span>
    <span class="s0">if </span><span class="s1">X</span><span class="s2">.</span><span class="s1">dtype </span><span class="s2">== </span><span class="s1">np</span><span class="s2">.</span><span class="s1">float32</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">_sqeuclidean_row_norms32</span><span class="s2">(</span><span class="s1">X</span><span class="s2">, </span><span class="s1">num_threads</span><span class="s2">))</span>

    <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
        <span class="s4">&quot;Only float64 or float32 datasets are supported at this time, &quot;</span>
        <span class="s4">f&quot;got: X.dtype=</span><span class="s0">{</span><span class="s1">X</span><span class="s2">.</span><span class="s1">dtype</span><span class="s0">}</span><span class="s4">.&quot;</span>
    <span class="s2">)</span>


<span class="s0">class </span><span class="s1">BaseDistancesReductionDispatcher</span><span class="s2">:</span>
    <span class="s3">&quot;&quot;&quot;Abstract base dispatcher for pairwise distance computation &amp; reduction. 
 
    Each dispatcher extending the base :class:`BaseDistancesReductionDispatcher` 
    dispatcher must implement the :meth:`compute` classmethod. 
    &quot;&quot;&quot;</span>

    <span class="s2">@</span><span class="s1">classmethod</span>
    <span class="s0">def </span><span class="s1">valid_metrics</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">) </span><span class="s1">-&gt; List</span><span class="s2">[</span><span class="s1">str</span><span class="s2">]:</span>
        <span class="s1">excluded </span><span class="s2">= {</span>
            <span class="s5"># PyFunc cannot be supported because it necessitates interacting with</span>
            <span class="s5"># the CPython interpreter to call user defined functions.</span>
            <span class="s4">&quot;pyfunc&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;mahalanobis&quot;</span><span class="s2">,  </span><span class="s5"># is numerically unstable</span>
            <span class="s5"># In order to support discrete distance metrics, we need to have a</span>
            <span class="s5"># stable simultaneous sort which preserves the order of the indices</span>
            <span class="s5"># because there generally is a lot of occurrences for a given values</span>
            <span class="s5"># of distances in this case.</span>
            <span class="s5"># TODO: implement a stable simultaneous_sort.</span>
            <span class="s4">&quot;hamming&quot;</span><span class="s2">,</span>
            <span class="s2">*</span><span class="s1">BOOL_METRICS</span><span class="s2">,</span>
        <span class="s2">}</span>
        <span class="s0">return </span><span class="s1">sorted</span><span class="s2">(({</span><span class="s4">&quot;sqeuclidean&quot;</span><span class="s2">} | </span><span class="s1">set</span><span class="s2">(</span><span class="s1">METRIC_MAPPING64</span><span class="s2">.</span><span class="s1">keys</span><span class="s2">())) - </span><span class="s1">excluded</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">classmethod</span>
    <span class="s0">def </span><span class="s1">is_usable_for</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">, </span><span class="s1">X</span><span class="s2">, </span><span class="s1">Y</span><span class="s2">, </span><span class="s1">metric</span><span class="s2">) </span><span class="s1">-&gt; bool</span><span class="s2">:</span>
        <span class="s3">&quot;&quot;&quot;Return True if the dispatcher can be used for the 
        given parameters. 
 
        Parameters 
        ---------- 
        X : {ndarray, sparse matrix} of shape (n_samples_X, n_features) 
            Input data. 
 
        Y : {ndarray, sparse matrix} of shape (n_samples_Y, n_features) 
            Input data. 
 
        metric : str, default='euclidean' 
            The distance metric to use. 
            For a list of available metrics, see the documentation of 
            :class:`~sklearn.metrics.DistanceMetric`. 
 
        Returns 
        ------- 
        True if the dispatcher can be used, else False. 
        &quot;&quot;&quot;</span>

        <span class="s5"># FIXME: the current Cython implementation is too slow for a large number of</span>
        <span class="s5"># features. We temporarily disable it to fallback on SciPy's implementation.</span>
        <span class="s5"># See: https://github.com/scikit-learn/scikit-learn/issues/28191</span>
        <span class="s0">if </span><span class="s2">(</span>
            <span class="s1">issparse</span><span class="s2">(</span><span class="s1">X</span><span class="s2">)</span>
            <span class="s0">and </span><span class="s1">issparse</span><span class="s2">(</span><span class="s1">Y</span><span class="s2">)</span>
            <span class="s0">and </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">metric</span><span class="s2">, </span><span class="s1">str</span><span class="s2">)</span>
            <span class="s0">and </span><span class="s4">&quot;euclidean&quot; </span><span class="s0">in </span><span class="s1">metric</span>
        <span class="s2">):</span>
            <span class="s0">return False</span>

        <span class="s0">def </span><span class="s1">is_numpy_c_ordered</span><span class="s2">(</span><span class="s1">X</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">X</span><span class="s2">, </span><span class="s4">&quot;flags&quot;</span><span class="s2">) </span><span class="s0">and </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">X</span><span class="s2">.</span><span class="s1">flags</span><span class="s2">, </span><span class="s4">&quot;c_contiguous&quot;</span><span class="s2">, </span><span class="s0">False</span><span class="s2">)</span>

        <span class="s0">def </span><span class="s1">is_valid_sparse_matrix</span><span class="s2">(</span><span class="s1">X</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s2">(</span>
                <span class="s1">issparse</span><span class="s2">(</span><span class="s1">X</span><span class="s2">)</span>
                <span class="s0">and </span><span class="s1">X</span><span class="s2">.</span><span class="s1">format </span><span class="s2">== </span><span class="s4">&quot;csr&quot;</span>
                <span class="s0">and</span>
                <span class="s5"># TODO: support CSR matrices without non-zeros elements</span>
                <span class="s1">X</span><span class="s2">.</span><span class="s1">nnz </span><span class="s2">&gt; </span><span class="s6">0</span>
                <span class="s0">and</span>
                <span class="s5"># TODO: support CSR matrices with int64 indices and indptr</span>
                <span class="s5"># See: https://github.com/scikit-learn/scikit-learn/issues/23653</span>
                <span class="s1">X</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">.</span><span class="s1">dtype </span><span class="s2">== </span><span class="s1">X</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">.</span><span class="s1">dtype </span><span class="s2">== </span><span class="s1">np</span><span class="s2">.</span><span class="s1">int32</span>
            <span class="s2">)</span>

        <span class="s1">is_usable </span><span class="s2">= (</span>
            <span class="s1">get_config</span><span class="s2">().</span><span class="s1">get</span><span class="s2">(</span><span class="s4">&quot;enable_cython_pairwise_dist&quot;</span><span class="s2">, </span><span class="s0">True</span><span class="s2">)</span>
            <span class="s0">and </span><span class="s2">(</span><span class="s1">is_numpy_c_ordered</span><span class="s2">(</span><span class="s1">X</span><span class="s2">) </span><span class="s0">or </span><span class="s1">is_valid_sparse_matrix</span><span class="s2">(</span><span class="s1">X</span><span class="s2">))</span>
            <span class="s0">and </span><span class="s2">(</span><span class="s1">is_numpy_c_ordered</span><span class="s2">(</span><span class="s1">Y</span><span class="s2">) </span><span class="s0">or </span><span class="s1">is_valid_sparse_matrix</span><span class="s2">(</span><span class="s1">Y</span><span class="s2">))</span>
            <span class="s0">and </span><span class="s1">X</span><span class="s2">.</span><span class="s1">dtype </span><span class="s2">== </span><span class="s1">Y</span><span class="s2">.</span><span class="s1">dtype</span>
            <span class="s0">and </span><span class="s1">X</span><span class="s2">.</span><span class="s1">dtype </span><span class="s0">in </span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float32</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">)</span>
            <span class="s0">and </span><span class="s2">(</span><span class="s1">metric </span><span class="s0">in </span><span class="s1">cls</span><span class="s2">.</span><span class="s1">valid_metrics</span><span class="s2">() </span><span class="s0">or </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">metric</span><span class="s2">, </span><span class="s1">DistanceMetric</span><span class="s2">))</span>
        <span class="s2">)</span>

        <span class="s0">return </span><span class="s1">is_usable</span>

    <span class="s2">@</span><span class="s1">classmethod</span>
    <span class="s2">@</span><span class="s1">abstractmethod</span>
    <span class="s0">def </span><span class="s1">compute</span><span class="s2">(</span>
        <span class="s1">cls</span><span class="s2">,</span>
        <span class="s1">X</span><span class="s2">,</span>
        <span class="s1">Y</span><span class="s2">,</span>
        <span class="s2">**</span><span class="s1">kwargs</span><span class="s2">,</span>
    <span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;Compute the reduction. 
 
        Parameters 
        ---------- 
        X : ndarray or CSR matrix of shape (n_samples_X, n_features) 
            Input data. 
 
        Y : ndarray or CSR matrix of shape (n_samples_Y, n_features) 
            Input data. 
 
        **kwargs : additional parameters for the reduction 
 
        Notes 
        ----- 
        This method is an abstract class method: it has to be implemented 
        for all subclasses. 
        &quot;&quot;&quot;</span>


<span class="s0">class </span><span class="s1">ArgKmin</span><span class="s2">(</span><span class="s1">BaseDistancesReductionDispatcher</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot;Compute the argkmin of row vectors of X on the ones of Y. 
 
    For each row vector of X, computes the indices of k first the rows 
    vectors of Y with the smallest distances. 
 
    ArgKmin is typically used to perform 
    bruteforce k-nearest neighbors queries. 
 
    This class is not meant to be instantiated, one should only use 
    its :meth:`compute` classmethod which handles allocation and 
    deallocation consistently. 
    &quot;&quot;&quot;</span>

    <span class="s2">@</span><span class="s1">classmethod</span>
    <span class="s0">def </span><span class="s1">compute</span><span class="s2">(</span>
        <span class="s1">cls</span><span class="s2">,</span>
        <span class="s1">X</span><span class="s2">,</span>
        <span class="s1">Y</span><span class="s2">,</span>
        <span class="s1">k</span><span class="s2">,</span>
        <span class="s1">metric</span><span class="s2">=</span><span class="s4">&quot;euclidean&quot;</span><span class="s2">,</span>
        <span class="s1">chunk_size</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">metric_kwargs</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">strategy</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">return_distance</span><span class="s2">=</span><span class="s0">False</span><span class="s2">,</span>
    <span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;Compute the argkmin reduction. 
 
        Parameters 
        ---------- 
        X : ndarray or CSR matrix of shape (n_samples_X, n_features) 
            Input data. 
 
        Y : ndarray or CSR matrix of shape (n_samples_Y, n_features) 
            Input data. 
 
        k : int 
            The k for the argkmin reduction. 
 
        metric : str, default='euclidean' 
            The distance metric to use for argkmin. 
            For a list of available metrics, see the documentation of 
            :class:`~sklearn.metrics.DistanceMetric`. 
 
        chunk_size : int, default=None, 
            The number of vectors per chunk. If None (default) looks-up in 
            scikit-learn configuration for `pairwise_dist_chunk_size`, 
            and use 256 if it is not set. 
 
        metric_kwargs : dict, default=None 
            Keyword arguments to pass to specified metric function. 
 
        strategy : str, {'auto', 'parallel_on_X', 'parallel_on_Y'}, default=None 
            The chunking strategy defining which dataset parallelization are made on. 
 
            For both strategies the computations happens with two nested loops, 
            respectively on chunks of X and chunks of Y. 
            Strategies differs on which loop (outer or inner) is made to run 
            in parallel with the Cython `prange` construct: 
 
              - 'parallel_on_X' dispatches chunks of X uniformly on threads. 
                Each thread then iterates on all the chunks of Y. This strategy is 
                embarrassingly parallel and comes with no datastructures 
                synchronisation. 
 
              - 'parallel_on_Y' dispatches chunks of Y uniformly on threads. 
                Each thread processes all the chunks of X in turn. This strategy is 
                a sequence of embarrassingly parallel subtasks (the inner loop on Y 
                chunks) with intermediate datastructures synchronisation at each 
                iteration of the sequential outer loop on X chunks. 
 
              - 'auto' relies on a simple heuristic to choose between 
                'parallel_on_X' and 'parallel_on_Y': when `X.shape[0]` is large enough, 
                'parallel_on_X' is usually the most efficient strategy. 
                When `X.shape[0]` is small but `Y.shape[0]` is large, 'parallel_on_Y' 
                brings more opportunity for parallelism and is therefore more efficient 
 
              - None (default) looks-up in scikit-learn configuration for 
                `pairwise_dist_parallel_strategy`, and use 'auto' if it is not set. 
 
        return_distance : boolean, default=False 
            Return distances between each X vector and its 
            argkmin if set to True. 
 
        Returns 
        ------- 
        If return_distance=False: 
          - argkmin_indices : ndarray of shape (n_samples_X, k) 
            Indices of the argkmin for each vector in X. 
 
        If return_distance=True: 
          - argkmin_distances : ndarray of shape (n_samples_X, k) 
            Distances to the argkmin for each vector in X. 
          - argkmin_indices : ndarray of shape (n_samples_X, k) 
            Indices of the argkmin for each vector in X. 
 
        Notes 
        ----- 
        This classmethod inspects the arguments values to dispatch to the 
        dtype-specialized implementation of :class:`ArgKmin`. 
 
        This allows decoupling the API entirely from the implementation details 
        whilst maintaining RAII: all temporarily allocated datastructures necessary 
        for the concrete implementation are therefore freed when this classmethod 
        returns. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">X</span><span class="s2">.</span><span class="s1">dtype </span><span class="s2">== </span><span class="s1">Y</span><span class="s2">.</span><span class="s1">dtype </span><span class="s2">== </span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">ArgKmin64</span><span class="s2">.</span><span class="s1">compute</span><span class="s2">(</span>
                <span class="s1">X</span><span class="s2">=</span><span class="s1">X</span><span class="s2">,</span>
                <span class="s1">Y</span><span class="s2">=</span><span class="s1">Y</span><span class="s2">,</span>
                <span class="s1">k</span><span class="s2">=</span><span class="s1">k</span><span class="s2">,</span>
                <span class="s1">metric</span><span class="s2">=</span><span class="s1">metric</span><span class="s2">,</span>
                <span class="s1">chunk_size</span><span class="s2">=</span><span class="s1">chunk_size</span><span class="s2">,</span>
                <span class="s1">metric_kwargs</span><span class="s2">=</span><span class="s1">metric_kwargs</span><span class="s2">,</span>
                <span class="s1">strategy</span><span class="s2">=</span><span class="s1">strategy</span><span class="s2">,</span>
                <span class="s1">return_distance</span><span class="s2">=</span><span class="s1">return_distance</span><span class="s2">,</span>
            <span class="s2">)</span>

        <span class="s0">if </span><span class="s1">X</span><span class="s2">.</span><span class="s1">dtype </span><span class="s2">== </span><span class="s1">Y</span><span class="s2">.</span><span class="s1">dtype </span><span class="s2">== </span><span class="s1">np</span><span class="s2">.</span><span class="s1">float32</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">ArgKmin32</span><span class="s2">.</span><span class="s1">compute</span><span class="s2">(</span>
                <span class="s1">X</span><span class="s2">=</span><span class="s1">X</span><span class="s2">,</span>
                <span class="s1">Y</span><span class="s2">=</span><span class="s1">Y</span><span class="s2">,</span>
                <span class="s1">k</span><span class="s2">=</span><span class="s1">k</span><span class="s2">,</span>
                <span class="s1">metric</span><span class="s2">=</span><span class="s1">metric</span><span class="s2">,</span>
                <span class="s1">chunk_size</span><span class="s2">=</span><span class="s1">chunk_size</span><span class="s2">,</span>
                <span class="s1">metric_kwargs</span><span class="s2">=</span><span class="s1">metric_kwargs</span><span class="s2">,</span>
                <span class="s1">strategy</span><span class="s2">=</span><span class="s1">strategy</span><span class="s2">,</span>
                <span class="s1">return_distance</span><span class="s2">=</span><span class="s1">return_distance</span><span class="s2">,</span>
            <span class="s2">)</span>

        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
            <span class="s4">&quot;Only float64 or float32 datasets pairs are supported at this time, &quot;</span>
            <span class="s4">f&quot;got: X.dtype=</span><span class="s0">{</span><span class="s1">X</span><span class="s2">.</span><span class="s1">dtype</span><span class="s0">} </span><span class="s4">and Y.dtype=</span><span class="s0">{</span><span class="s1">Y</span><span class="s2">.</span><span class="s1">dtype</span><span class="s0">}</span><span class="s4">.&quot;</span>
        <span class="s2">)</span>


<span class="s0">class </span><span class="s1">RadiusNeighbors</span><span class="s2">(</span><span class="s1">BaseDistancesReductionDispatcher</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot;Compute radius-based neighbors for two sets of vectors. 
 
    For each row-vector X[i] of the queries X, find all the indices j of 
    row-vectors in Y such that: 
 
                        dist(X[i], Y[j]) &lt;= radius 
 
    The distance function `dist` depends on the values of the `metric` 
    and `metric_kwargs` parameters. 
 
    This class is not meant to be instantiated, one should only use 
    its :meth:`compute` classmethod which handles allocation and 
    deallocation consistently. 
    &quot;&quot;&quot;</span>

    <span class="s2">@</span><span class="s1">classmethod</span>
    <span class="s0">def </span><span class="s1">compute</span><span class="s2">(</span>
        <span class="s1">cls</span><span class="s2">,</span>
        <span class="s1">X</span><span class="s2">,</span>
        <span class="s1">Y</span><span class="s2">,</span>
        <span class="s1">radius</span><span class="s2">,</span>
        <span class="s1">metric</span><span class="s2">=</span><span class="s4">&quot;euclidean&quot;</span><span class="s2">,</span>
        <span class="s1">chunk_size</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">metric_kwargs</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">strategy</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">return_distance</span><span class="s2">=</span><span class="s0">False</span><span class="s2">,</span>
        <span class="s1">sort_results</span><span class="s2">=</span><span class="s0">False</span><span class="s2">,</span>
    <span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;Return the results of the reduction for the given arguments. 
 
        Parameters 
        ---------- 
        X : ndarray or CSR matrix of shape (n_samples_X, n_features) 
            Input data. 
 
        Y : ndarray or CSR matrix of shape (n_samples_Y, n_features) 
            Input data. 
 
        radius : float 
            The radius defining the neighborhood. 
 
        metric : str, default='euclidean' 
            The distance metric to use. 
            For a list of available metrics, see the documentation of 
            :class:`~sklearn.metrics.DistanceMetric`. 
 
        chunk_size : int, default=None, 
            The number of vectors per chunk. If None (default) looks-up in 
            scikit-learn configuration for `pairwise_dist_chunk_size`, 
            and use 256 if it is not set. 
 
        metric_kwargs : dict, default=None 
            Keyword arguments to pass to specified metric function. 
 
        strategy : str, {'auto', 'parallel_on_X', 'parallel_on_Y'}, default=None 
            The chunking strategy defining which dataset parallelization are made on. 
 
            For both strategies the computations happens with two nested loops, 
            respectively on chunks of X and chunks of Y. 
            Strategies differs on which loop (outer or inner) is made to run 
            in parallel with the Cython `prange` construct: 
 
              - 'parallel_on_X' dispatches chunks of X uniformly on threads. 
                Each thread then iterates on all the chunks of Y. This strategy is 
                embarrassingly parallel and comes with no datastructures 
                synchronisation. 
 
              - 'parallel_on_Y' dispatches chunks of Y uniformly on threads. 
                Each thread processes all the chunks of X in turn. This strategy is 
                a sequence of embarrassingly parallel subtasks (the inner loop on Y 
                chunks) with intermediate datastructures synchronisation at each 
                iteration of the sequential outer loop on X chunks. 
 
              - 'auto' relies on a simple heuristic to choose between 
                'parallel_on_X' and 'parallel_on_Y': when `X.shape[0]` is large enough, 
                'parallel_on_X' is usually the most efficient strategy. 
                When `X.shape[0]` is small but `Y.shape[0]` is large, 'parallel_on_Y' 
                brings more opportunity for parallelism and is therefore more efficient 
                despite the synchronization step at each iteration of the outer loop 
                on chunks of `X`. 
 
              - None (default) looks-up in scikit-learn configuration for 
                `pairwise_dist_parallel_strategy`, and use 'auto' if it is not set. 
 
        return_distance : boolean, default=False 
            Return distances between each X vector and its neighbors if set to True. 
 
        sort_results : boolean, default=False 
            Sort results with respect to distances between each X vector and its 
            neighbors if set to True. 
 
        Returns 
        ------- 
        If return_distance=False: 
          - neighbors_indices : ndarray of n_samples_X ndarray 
            Indices of the neighbors for each vector in X. 
 
        If return_distance=True: 
          - neighbors_indices : ndarray of n_samples_X ndarray 
            Indices of the neighbors for each vector in X. 
          - neighbors_distances : ndarray of n_samples_X ndarray 
            Distances to the neighbors for each vector in X. 
 
        Notes 
        ----- 
        This classmethod inspects the arguments values to dispatch to the 
        dtype-specialized implementation of :class:`RadiusNeighbors`. 
 
        This allows decoupling the API entirely from the implementation details 
        whilst maintaining RAII: all temporarily allocated datastructures necessary 
        for the concrete implementation are therefore freed when this classmethod 
        returns. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">X</span><span class="s2">.</span><span class="s1">dtype </span><span class="s2">== </span><span class="s1">Y</span><span class="s2">.</span><span class="s1">dtype </span><span class="s2">== </span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">RadiusNeighbors64</span><span class="s2">.</span><span class="s1">compute</span><span class="s2">(</span>
                <span class="s1">X</span><span class="s2">=</span><span class="s1">X</span><span class="s2">,</span>
                <span class="s1">Y</span><span class="s2">=</span><span class="s1">Y</span><span class="s2">,</span>
                <span class="s1">radius</span><span class="s2">=</span><span class="s1">radius</span><span class="s2">,</span>
                <span class="s1">metric</span><span class="s2">=</span><span class="s1">metric</span><span class="s2">,</span>
                <span class="s1">chunk_size</span><span class="s2">=</span><span class="s1">chunk_size</span><span class="s2">,</span>
                <span class="s1">metric_kwargs</span><span class="s2">=</span><span class="s1">metric_kwargs</span><span class="s2">,</span>
                <span class="s1">strategy</span><span class="s2">=</span><span class="s1">strategy</span><span class="s2">,</span>
                <span class="s1">sort_results</span><span class="s2">=</span><span class="s1">sort_results</span><span class="s2">,</span>
                <span class="s1">return_distance</span><span class="s2">=</span><span class="s1">return_distance</span><span class="s2">,</span>
            <span class="s2">)</span>

        <span class="s0">if </span><span class="s1">X</span><span class="s2">.</span><span class="s1">dtype </span><span class="s2">== </span><span class="s1">Y</span><span class="s2">.</span><span class="s1">dtype </span><span class="s2">== </span><span class="s1">np</span><span class="s2">.</span><span class="s1">float32</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">RadiusNeighbors32</span><span class="s2">.</span><span class="s1">compute</span><span class="s2">(</span>
                <span class="s1">X</span><span class="s2">=</span><span class="s1">X</span><span class="s2">,</span>
                <span class="s1">Y</span><span class="s2">=</span><span class="s1">Y</span><span class="s2">,</span>
                <span class="s1">radius</span><span class="s2">=</span><span class="s1">radius</span><span class="s2">,</span>
                <span class="s1">metric</span><span class="s2">=</span><span class="s1">metric</span><span class="s2">,</span>
                <span class="s1">chunk_size</span><span class="s2">=</span><span class="s1">chunk_size</span><span class="s2">,</span>
                <span class="s1">metric_kwargs</span><span class="s2">=</span><span class="s1">metric_kwargs</span><span class="s2">,</span>
                <span class="s1">strategy</span><span class="s2">=</span><span class="s1">strategy</span><span class="s2">,</span>
                <span class="s1">sort_results</span><span class="s2">=</span><span class="s1">sort_results</span><span class="s2">,</span>
                <span class="s1">return_distance</span><span class="s2">=</span><span class="s1">return_distance</span><span class="s2">,</span>
            <span class="s2">)</span>

        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
            <span class="s4">&quot;Only float64 or float32 datasets pairs are supported at this time, &quot;</span>
            <span class="s4">f&quot;got: X.dtype=</span><span class="s0">{</span><span class="s1">X</span><span class="s2">.</span><span class="s1">dtype</span><span class="s0">} </span><span class="s4">and Y.dtype=</span><span class="s0">{</span><span class="s1">Y</span><span class="s2">.</span><span class="s1">dtype</span><span class="s0">}</span><span class="s4">.&quot;</span>
        <span class="s2">)</span>


<span class="s0">class </span><span class="s1">ArgKminClassMode</span><span class="s2">(</span><span class="s1">BaseDistancesReductionDispatcher</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot;Compute the argkmin of row vectors of X on the ones of Y with labels. 
 
    For each row vector of X, computes the indices of k first the rows 
    vectors of Y with the smallest distances. Computes weighted mode of labels. 
 
    ArgKminClassMode is typically used to perform bruteforce k-nearest neighbors 
    queries when the weighted mode of the labels for the k-nearest neighbors 
    are required, such as in `predict` methods. 
 
    This class is not meant to be instantiated, one should only use 
    its :meth:`compute` classmethod which handles allocation and 
    deallocation consistently. 
    &quot;&quot;&quot;</span>

    <span class="s2">@</span><span class="s1">classmethod</span>
    <span class="s0">def </span><span class="s1">valid_metrics</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">) </span><span class="s1">-&gt; List</span><span class="s2">[</span><span class="s1">str</span><span class="s2">]:</span>
        <span class="s1">excluded </span><span class="s2">= {</span>
            <span class="s5"># Euclidean is technically usable for ArgKminClassMode</span>
            <span class="s5"># but its current implementation would not be competitive.</span>
            <span class="s5"># TODO: implement Euclidean specialization using GEMM.</span>
            <span class="s4">&quot;euclidean&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;sqeuclidean&quot;</span><span class="s2">,</span>
        <span class="s2">}</span>
        <span class="s0">return </span><span class="s1">list</span><span class="s2">(</span><span class="s1">set</span><span class="s2">(</span><span class="s1">BaseDistancesReductionDispatcher</span><span class="s2">.</span><span class="s1">valid_metrics</span><span class="s2">()) - </span><span class="s1">excluded</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">classmethod</span>
    <span class="s0">def </span><span class="s1">compute</span><span class="s2">(</span>
        <span class="s1">cls</span><span class="s2">,</span>
        <span class="s1">X</span><span class="s2">,</span>
        <span class="s1">Y</span><span class="s2">,</span>
        <span class="s1">k</span><span class="s2">,</span>
        <span class="s1">weights</span><span class="s2">,</span>
        <span class="s1">Y_labels</span><span class="s2">,</span>
        <span class="s1">unique_Y_labels</span><span class="s2">,</span>
        <span class="s1">metric</span><span class="s2">=</span><span class="s4">&quot;euclidean&quot;</span><span class="s2">,</span>
        <span class="s1">chunk_size</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">metric_kwargs</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">strategy</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
    <span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;Compute the argkmin reduction. 
 
        Parameters 
        ---------- 
        X : ndarray of shape (n_samples_X, n_features) 
            The input array to be labelled. 
 
        Y : ndarray of shape (n_samples_Y, n_features) 
            The input array whose class membership are provided through the 
            `Y_labels` parameter. 
 
        k : int 
            The number of nearest neighbors to consider. 
 
        weights : ndarray 
            The weights applied over the `Y_labels` of `Y` when computing the 
            weighted mode of the labels. 
 
        Y_labels : ndarray 
            An array containing the index of the class membership of the 
            associated samples in `Y`. This is used in labeling `X`. 
 
        unique_Y_labels : ndarray 
            An array containing all unique indices contained in the 
            corresponding `Y_labels` array. 
 
        metric : str, default='euclidean' 
            The distance metric to use. For a list of available metrics, see 
            the documentation of :class:`~sklearn.metrics.DistanceMetric`. 
            Currently does not support `'precomputed'`. 
 
        chunk_size : int, default=None, 
            The number of vectors per chunk. If None (default) looks-up in 
            scikit-learn configuration for `pairwise_dist_chunk_size`, 
            and use 256 if it is not set. 
 
        metric_kwargs : dict, default=None 
            Keyword arguments to pass to specified metric function. 
 
        strategy : str, {'auto', 'parallel_on_X', 'parallel_on_Y'}, default=None 
            The chunking strategy defining which dataset parallelization are made on. 
 
            For both strategies the computations happens with two nested loops, 
            respectively on chunks of X and chunks of Y. 
            Strategies differs on which loop (outer or inner) is made to run 
            in parallel with the Cython `prange` construct: 
 
              - 'parallel_on_X' dispatches chunks of X uniformly on threads. 
                Each thread then iterates on all the chunks of Y. This strategy is 
                embarrassingly parallel and comes with no datastructures 
                synchronisation. 
 
              - 'parallel_on_Y' dispatches chunks of Y uniformly on threads. 
                Each thread processes all the chunks of X in turn. This strategy is 
                a sequence of embarrassingly parallel subtasks (the inner loop on Y 
                chunks) with intermediate datastructures synchronisation at each 
                iteration of the sequential outer loop on X chunks. 
 
              - 'auto' relies on a simple heuristic to choose between 
                'parallel_on_X' and 'parallel_on_Y': when `X.shape[0]` is large enough, 
                'parallel_on_X' is usually the most efficient strategy. 
                When `X.shape[0]` is small but `Y.shape[0]` is large, 'parallel_on_Y' 
                brings more opportunity for parallelism and is therefore more efficient 
                despite the synchronization step at each iteration of the outer loop 
                on chunks of `X`. 
 
              - None (default) looks-up in scikit-learn configuration for 
                `pairwise_dist_parallel_strategy`, and use 'auto' if it is not set. 
 
        Returns 
        ------- 
        probabilities : ndarray of shape (n_samples_X, n_classes) 
            An array containing the class probabilities for each sample. 
 
        Notes 
        ----- 
        This classmethod is responsible for introspecting the arguments 
        values to dispatch to the most appropriate implementation of 
        :class:`PairwiseDistancesArgKmin`. 
 
        This allows decoupling the API entirely from the implementation details 
        whilst maintaining RAII: all temporarily allocated datastructures necessary 
        for the concrete implementation are therefore freed when this classmethod 
        returns. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">weights </span><span class="s0">not in </span><span class="s2">{</span><span class="s4">&quot;uniform&quot;</span><span class="s2">, </span><span class="s4">&quot;distance&quot;</span><span class="s2">}:</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
                <span class="s4">&quot;Only the 'uniform' or 'distance' weights options are supported&quot;</span>
                <span class="s4">f&quot; at this time. Got: </span><span class="s0">{</span><span class="s1">weights</span><span class="s2">=</span><span class="s0">}</span><span class="s4">.&quot;</span>
            <span class="s2">)</span>
        <span class="s0">if </span><span class="s1">X</span><span class="s2">.</span><span class="s1">dtype </span><span class="s2">== </span><span class="s1">Y</span><span class="s2">.</span><span class="s1">dtype </span><span class="s2">== </span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">ArgKminClassMode64</span><span class="s2">.</span><span class="s1">compute</span><span class="s2">(</span>
                <span class="s1">X</span><span class="s2">=</span><span class="s1">X</span><span class="s2">,</span>
                <span class="s1">Y</span><span class="s2">=</span><span class="s1">Y</span><span class="s2">,</span>
                <span class="s1">k</span><span class="s2">=</span><span class="s1">k</span><span class="s2">,</span>
                <span class="s1">weights</span><span class="s2">=</span><span class="s1">weights</span><span class="s2">,</span>
                <span class="s1">Y_labels</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">(</span><span class="s1">Y_labels</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">intp</span><span class="s2">),</span>
                <span class="s1">unique_Y_labels</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">(</span><span class="s1">unique_Y_labels</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">intp</span><span class="s2">),</span>
                <span class="s1">metric</span><span class="s2">=</span><span class="s1">metric</span><span class="s2">,</span>
                <span class="s1">chunk_size</span><span class="s2">=</span><span class="s1">chunk_size</span><span class="s2">,</span>
                <span class="s1">metric_kwargs</span><span class="s2">=</span><span class="s1">metric_kwargs</span><span class="s2">,</span>
                <span class="s1">strategy</span><span class="s2">=</span><span class="s1">strategy</span><span class="s2">,</span>
            <span class="s2">)</span>

        <span class="s0">if </span><span class="s1">X</span><span class="s2">.</span><span class="s1">dtype </span><span class="s2">== </span><span class="s1">Y</span><span class="s2">.</span><span class="s1">dtype </span><span class="s2">== </span><span class="s1">np</span><span class="s2">.</span><span class="s1">float32</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">ArgKminClassMode32</span><span class="s2">.</span><span class="s1">compute</span><span class="s2">(</span>
                <span class="s1">X</span><span class="s2">=</span><span class="s1">X</span><span class="s2">,</span>
                <span class="s1">Y</span><span class="s2">=</span><span class="s1">Y</span><span class="s2">,</span>
                <span class="s1">k</span><span class="s2">=</span><span class="s1">k</span><span class="s2">,</span>
                <span class="s1">weights</span><span class="s2">=</span><span class="s1">weights</span><span class="s2">,</span>
                <span class="s1">Y_labels</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">(</span><span class="s1">Y_labels</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">intp</span><span class="s2">),</span>
                <span class="s1">unique_Y_labels</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">(</span><span class="s1">unique_Y_labels</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">intp</span><span class="s2">),</span>
                <span class="s1">metric</span><span class="s2">=</span><span class="s1">metric</span><span class="s2">,</span>
                <span class="s1">chunk_size</span><span class="s2">=</span><span class="s1">chunk_size</span><span class="s2">,</span>
                <span class="s1">metric_kwargs</span><span class="s2">=</span><span class="s1">metric_kwargs</span><span class="s2">,</span>
                <span class="s1">strategy</span><span class="s2">=</span><span class="s1">strategy</span><span class="s2">,</span>
            <span class="s2">)</span>

        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
            <span class="s4">&quot;Only float64 or float32 datasets pairs are supported at this time, &quot;</span>
            <span class="s4">f&quot;got: X.dtype=</span><span class="s0">{</span><span class="s1">X</span><span class="s2">.</span><span class="s1">dtype</span><span class="s0">} </span><span class="s4">and Y.dtype=</span><span class="s0">{</span><span class="s1">Y</span><span class="s2">.</span><span class="s1">dtype</span><span class="s0">}</span><span class="s4">.&quot;</span>
        <span class="s2">)</span>


<span class="s0">class </span><span class="s1">RadiusNeighborsClassMode</span><span class="s2">(</span><span class="s1">BaseDistancesReductionDispatcher</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot;Compute radius-based class modes of row vectors of X using the 
    those of Y. 
 
    For each row-vector X[i] of the queries X, find all the indices j of 
    row-vectors in Y such that: 
 
                        dist(X[i], Y[j]) &lt;= radius 
 
    RadiusNeighborsClassMode is typically used to perform bruteforce 
    radius neighbors queries when the weighted mode of the labels for 
    the nearest neighbors within the specified radius are required, 
    such as in `predict` methods. 
 
    This class is not meant to be instantiated, one should only use 
    its :meth:`compute` classmethod which handles allocation and 
    deallocation consistently. 
    &quot;&quot;&quot;</span>

    <span class="s2">@</span><span class="s1">classmethod</span>
    <span class="s0">def </span><span class="s1">valid_metrics</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">) </span><span class="s1">-&gt; List</span><span class="s2">[</span><span class="s1">str</span><span class="s2">]:</span>
        <span class="s1">excluded </span><span class="s2">= {</span>
            <span class="s5"># Euclidean is technically usable for RadiusNeighborsClassMode</span>
            <span class="s5"># but it would not be competitive.</span>
            <span class="s5"># TODO: implement Euclidean specialization using GEMM.</span>
            <span class="s4">&quot;euclidean&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;sqeuclidean&quot;</span><span class="s2">,</span>
        <span class="s2">}</span>
        <span class="s0">return </span><span class="s1">sorted</span><span class="s2">(</span><span class="s1">set</span><span class="s2">(</span><span class="s1">BaseDistancesReductionDispatcher</span><span class="s2">.</span><span class="s1">valid_metrics</span><span class="s2">()) - </span><span class="s1">excluded</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">classmethod</span>
    <span class="s0">def </span><span class="s1">compute</span><span class="s2">(</span>
        <span class="s1">cls</span><span class="s2">,</span>
        <span class="s1">X</span><span class="s2">,</span>
        <span class="s1">Y</span><span class="s2">,</span>
        <span class="s1">radius</span><span class="s2">,</span>
        <span class="s1">weights</span><span class="s2">,</span>
        <span class="s1">Y_labels</span><span class="s2">,</span>
        <span class="s1">unique_Y_labels</span><span class="s2">,</span>
        <span class="s1">outlier_label</span><span class="s2">,</span>
        <span class="s1">metric</span><span class="s2">=</span><span class="s4">&quot;euclidean&quot;</span><span class="s2">,</span>
        <span class="s1">chunk_size</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">metric_kwargs</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">strategy</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
    <span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;Return the results of the reduction for the given arguments. 
        Parameters 
        ---------- 
        X : ndarray of shape (n_samples_X, n_features) 
            The input array to be labelled. 
        Y : ndarray of shape (n_samples_Y, n_features) 
            The input array whose class membership is provided through 
            the `Y_labels` parameter. 
        radius : float 
            The radius defining the neighborhood. 
        weights : ndarray 
            The weights applied to the `Y_labels` when computing the 
            weighted mode of the labels. 
        Y_labels : ndarray 
            An array containing the index of the class membership of the 
            associated samples in `Y`. This is used in labeling `X`. 
        unique_Y_labels : ndarray 
            An array containing all unique class labels. 
        outlier_label : int, default=None 
            Label for outlier samples (samples with no neighbors in given 
            radius). In the default case when the value is None if any 
            outlier is detected, a ValueError will be raised. The outlier 
            label should be selected from among the unique 'Y' labels. If 
            it is specified with a different value a warning will be raised 
            and all class probabilities of outliers will be assigned to be 0. 
        metric : str, default='euclidean' 
            The distance metric to use. For a list of available metrics, see 
            the documentation of :class:`~sklearn.metrics.DistanceMetric`. 
            Currently does not support `'precomputed'`. 
        chunk_size : int, default=None, 
            The number of vectors per chunk. If None (default) looks-up in 
            scikit-learn configuration for `pairwise_dist_chunk_size`, 
            and use 256 if it is not set. 
        metric_kwargs : dict, default=None 
            Keyword arguments to pass to specified metric function. 
        strategy : str, {'auto', 'parallel_on_X', 'parallel_on_Y'}, default=None 
            The chunking strategy defining which dataset parallelization are made on. 
            For both strategies the computations happens with two nested loops, 
            respectively on chunks of X and chunks of Y. 
            Strategies differs on which loop (outer or inner) is made to run 
            in parallel with the Cython `prange` construct: 
              - 'parallel_on_X' dispatches chunks of X uniformly on threads. 
                Each thread then iterates on all the chunks of Y. This strategy is 
                embarrassingly parallel and comes with no datastructures 
                synchronisation. 
              - 'parallel_on_Y' dispatches chunks of Y uniformly on threads. 
                Each thread processes all the chunks of X in turn. This strategy is 
                a sequence of embarrassingly parallel subtasks (the inner loop on Y 
                chunks) with intermediate datastructures synchronisation at each 
                iteration of the sequential outer loop on X chunks. 
              - 'auto' relies on a simple heuristic to choose between 
                'parallel_on_X' and 'parallel_on_Y': when `X.shape[0]` is large enough, 
                'parallel_on_X' is usually the most efficient strategy. 
                When `X.shape[0]` is small but `Y.shape[0]` is large, 'parallel_on_Y' 
                brings more opportunity for parallelism and is therefore more efficient 
                despite the synchronization step at each iteration of the outer loop 
                on chunks of `X`. 
              - None (default) looks-up in scikit-learn configuration for 
                `pairwise_dist_parallel_strategy`, and use 'auto' if it is not set. 
        Returns 
        ------- 
        probabilities : ndarray of shape (n_samples_X, n_classes) 
            An array containing the class probabilities for each sample. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">weights </span><span class="s0">not in </span><span class="s2">{</span><span class="s4">&quot;uniform&quot;</span><span class="s2">, </span><span class="s4">&quot;distance&quot;</span><span class="s2">}:</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
                <span class="s4">&quot;Only the 'uniform' or 'distance' weights options are supported&quot;</span>
                <span class="s4">f&quot; at this time. Got: </span><span class="s0">{</span><span class="s1">weights</span><span class="s2">=</span><span class="s0">}</span><span class="s4">.&quot;</span>
            <span class="s2">)</span>
        <span class="s0">if </span><span class="s1">X</span><span class="s2">.</span><span class="s1">dtype </span><span class="s2">== </span><span class="s1">Y</span><span class="s2">.</span><span class="s1">dtype </span><span class="s2">== </span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">RadiusNeighborsClassMode64</span><span class="s2">.</span><span class="s1">compute</span><span class="s2">(</span>
                <span class="s1">X</span><span class="s2">=</span><span class="s1">X</span><span class="s2">,</span>
                <span class="s1">Y</span><span class="s2">=</span><span class="s1">Y</span><span class="s2">,</span>
                <span class="s1">radius</span><span class="s2">=</span><span class="s1">radius</span><span class="s2">,</span>
                <span class="s1">weights</span><span class="s2">=</span><span class="s1">weights</span><span class="s2">,</span>
                <span class="s1">Y_labels</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">(</span><span class="s1">Y_labels</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">intp</span><span class="s2">),</span>
                <span class="s1">unique_Y_labels</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">(</span><span class="s1">unique_Y_labels</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">intp</span><span class="s2">),</span>
                <span class="s1">outlier_label</span><span class="s2">=</span><span class="s1">outlier_label</span><span class="s2">,</span>
                <span class="s1">metric</span><span class="s2">=</span><span class="s1">metric</span><span class="s2">,</span>
                <span class="s1">chunk_size</span><span class="s2">=</span><span class="s1">chunk_size</span><span class="s2">,</span>
                <span class="s1">metric_kwargs</span><span class="s2">=</span><span class="s1">metric_kwargs</span><span class="s2">,</span>
                <span class="s1">strategy</span><span class="s2">=</span><span class="s1">strategy</span><span class="s2">,</span>
            <span class="s2">)</span>

        <span class="s0">if </span><span class="s1">X</span><span class="s2">.</span><span class="s1">dtype </span><span class="s2">== </span><span class="s1">Y</span><span class="s2">.</span><span class="s1">dtype </span><span class="s2">== </span><span class="s1">np</span><span class="s2">.</span><span class="s1">float32</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">RadiusNeighborsClassMode32</span><span class="s2">.</span><span class="s1">compute</span><span class="s2">(</span>
                <span class="s1">X</span><span class="s2">=</span><span class="s1">X</span><span class="s2">,</span>
                <span class="s1">Y</span><span class="s2">=</span><span class="s1">Y</span><span class="s2">,</span>
                <span class="s1">radius</span><span class="s2">=</span><span class="s1">radius</span><span class="s2">,</span>
                <span class="s1">weights</span><span class="s2">=</span><span class="s1">weights</span><span class="s2">,</span>
                <span class="s1">Y_labels</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">(</span><span class="s1">Y_labels</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">intp</span><span class="s2">),</span>
                <span class="s1">unique_Y_labels</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">(</span><span class="s1">unique_Y_labels</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">intp</span><span class="s2">),</span>
                <span class="s1">outlier_label</span><span class="s2">=</span><span class="s1">outlier_label</span><span class="s2">,</span>
                <span class="s1">metric</span><span class="s2">=</span><span class="s1">metric</span><span class="s2">,</span>
                <span class="s1">chunk_size</span><span class="s2">=</span><span class="s1">chunk_size</span><span class="s2">,</span>
                <span class="s1">metric_kwargs</span><span class="s2">=</span><span class="s1">metric_kwargs</span><span class="s2">,</span>
                <span class="s1">strategy</span><span class="s2">=</span><span class="s1">strategy</span><span class="s2">,</span>
            <span class="s2">)</span>

        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
            <span class="s4">&quot;Only float64 or float32 datasets pairs are supported at this time, &quot;</span>
            <span class="s4">f&quot;got: X.dtype=</span><span class="s0">{</span><span class="s1">X</span><span class="s2">.</span><span class="s1">dtype</span><span class="s0">} </span><span class="s4">and Y.dtype=</span><span class="s0">{</span><span class="s1">Y</span><span class="s2">.</span><span class="s1">dtype</span><span class="s0">}</span><span class="s4">.&quot;</span>
        <span class="s2">)</span>
</pre>
</body>
</html>