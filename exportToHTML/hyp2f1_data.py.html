<html>
<head>
<title>hyp2f1_data.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #2aacb8;}
.s5 { color: #7a7e85;}
.s6 { color: #6aab73;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
hyp2f1_data.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;This script evaluates scipy's implementation of hyp2f1 against mpmath's. 
 
Author: Albert Steppi 
 
This script is long running and generates a large output file. With default 
arguments, the generated file is roughly 700MB in size and it takes around 
40 minutes using an Intel(R) Core(TM) i5-8250U CPU with n_jobs set to 8 
(full utilization). There are optional arguments which can be used to restrict 
(or enlarge) the computations performed. These are described below. 
The output of this script can be analyzed to identify suitable test cases and 
to find parameter and argument regions where hyp2f1 needs to be improved. 
 
The script has one mandatory positional argument for specifying the path to 
the location where the output file is to be placed, and 4 optional arguments 
--n_jobs, --grid_size, --regions, and --parameter_groups. --n_jobs specifies 
the number of processes to use if running in parallel. The default value is 1. 
The other optional arguments are explained below. 
 
Produces a tab separated values file with 11 columns. The first four columns 
contain the parameters a, b, c and the argument z. The next two contain |z| and 
a region code for which region of the complex plane belongs to. The regions are 
 
    0) z == 1 
    1) |z| &lt; 0.9 and real(z) &gt;= 0 
    2) |z| &lt;= 1 and real(z) &lt; 0 
    3) 0.9 &lt;= |z| &lt;= 1 and |1 - z| &lt; 0.9: 
    4) 0.9 &lt;= |z| &lt;= 1 and |1 - z| &gt;= 0.9 and real(z) &gt;= 0: 
    5) 1 &lt; |z| &lt; 1.1 and |1 - z| &gt;= 0.9 and real(z) &gt;= 0 
    6) |z| &gt; 1 and not in 5) 
 
The --regions optional argument allows the user to specify a list of regions 
to which computation will be restricted. 
 
Parameters a, b, c are taken from a 10 * 10 * 10 grid with values at 
 
    -16, -8, -4, -2, -1, 1, 2, 4, 8, 16 
 
with random perturbations applied. 
 
There are 9 parameter groups handling the following cases. 
 
    1) A, B, C, B - A, C - A, C - B, C - A - B all non-integral. 
    2) B - A integral 
    3) C - A integral 
    4) C - B integral 
    5) C - A - B integral 
    6) A integral 
    7) B integral 
    8) C integral 
    9) Wider range with c - a - b &gt; 0. 
 
The seventh column of the output file is an integer between 1 and 8 specifying 
the parameter group as above. 
 
The --parameter_groups optional argument allows the user to specify a list of 
parameter groups to which computation will be restricted. 
 
The argument z is taken from a grid in the box 
    -box_size &lt;= real(z) &lt;= box_size, -box_size &lt;= imag(z) &lt;= box_size. 
with grid size specified using the optional command line argument --grid_size, 
and box_size specified with the command line argument --box_size. 
The default value of grid_size is 20 and the default value of box_size is 2.0, 
yielding a 20 * 20 grid in the box with corners -2-2j, -2+2j, 2-2j, 2+2j. 
 
The final four columns have the expected value of hyp2f1 for the given 
parameters and argument as calculated with mpmath, the observed value 
calculated with scipy's hyp2f1, the relative error, and the absolute error. 
 
As special cases of hyp2f1 are moved from the original Fortran implementation 
into Cython, this script can be used to ensure that no regressions occur and 
to point out where improvements are needed. 
&quot;&quot;&quot;</span>


<span class="s2">import </span><span class="s1">os</span>
<span class="s2">import </span><span class="s1">csv</span>
<span class="s2">import </span><span class="s1">argparse</span>
<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">from </span><span class="s1">itertools </span><span class="s2">import </span><span class="s1">product</span>
<span class="s2">from </span><span class="s1">multiprocessing </span><span class="s2">import </span><span class="s1">Pool</span>


<span class="s2">from </span><span class="s1">scipy</span><span class="s3">.</span><span class="s1">special </span><span class="s2">import </span><span class="s1">hyp2f1</span>
<span class="s2">from </span><span class="s1">scipy</span><span class="s3">.</span><span class="s1">special</span><span class="s3">.</span><span class="s1">tests</span><span class="s3">.</span><span class="s1">test_hyp2f1 </span><span class="s2">import </span><span class="s1">mp_hyp2f1</span>


<span class="s2">def </span><span class="s1">get_region</span><span class="s3">(</span><span class="s1">z</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Assign numbers for regions where hyp2f1 must be handled differently.&quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">z </span><span class="s3">== </span><span class="s4">1 </span><span class="s3">+ </span><span class="s4">0j</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s4">0</span>
    <span class="s2">elif </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">z</span><span class="s3">) &lt; </span><span class="s4">0.9 </span><span class="s2">and </span><span class="s1">z</span><span class="s3">.</span><span class="s1">real </span><span class="s3">&gt;= </span><span class="s4">0</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s4">1</span>
    <span class="s2">elif </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">z</span><span class="s3">) &lt;= </span><span class="s4">1 </span><span class="s2">and </span><span class="s1">z</span><span class="s3">.</span><span class="s1">real </span><span class="s3">&lt; </span><span class="s4">0</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s4">2</span>
    <span class="s2">elif </span><span class="s4">0.9 </span><span class="s3">&lt;= </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">z</span><span class="s3">) &lt;= </span><span class="s4">1 </span><span class="s2">and </span><span class="s1">abs</span><span class="s3">(</span><span class="s4">1 </span><span class="s3">- </span><span class="s1">z</span><span class="s3">) &lt; </span><span class="s4">0.9</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s4">3</span>
    <span class="s2">elif </span><span class="s4">0.9 </span><span class="s3">&lt;= </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">z</span><span class="s3">) &lt;= </span><span class="s4">1 </span><span class="s2">and </span><span class="s1">abs</span><span class="s3">(</span><span class="s4">1 </span><span class="s3">- </span><span class="s1">z</span><span class="s3">) &gt;= </span><span class="s4">0.9</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s4">4</span>
    <span class="s2">elif </span><span class="s4">1 </span><span class="s3">&lt; </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">z</span><span class="s3">) &lt; </span><span class="s4">1.1 </span><span class="s2">and </span><span class="s1">abs</span><span class="s3">(</span><span class="s4">1 </span><span class="s3">- </span><span class="s1">z</span><span class="s3">) &gt;= </span><span class="s4">0.9 </span><span class="s2">and </span><span class="s1">z</span><span class="s3">.</span><span class="s1">real </span><span class="s3">&gt;= </span><span class="s4">0</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s4">5</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s4">6</span>


<span class="s2">def </span><span class="s1">get_result</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">z</span><span class="s3">, </span><span class="s1">group</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Get results for given parameter and value combination.&quot;&quot;&quot;</span>
    <span class="s1">expected</span><span class="s3">, </span><span class="s1">observed </span><span class="s3">= </span><span class="s1">mp_hyp2f1</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">z</span><span class="s3">), </span><span class="s1">hyp2f1</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">z</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s3">(</span>
            <span class="s1">np</span><span class="s3">.</span><span class="s1">isnan</span><span class="s3">(</span><span class="s1">observed</span><span class="s3">) </span><span class="s2">and </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isnan</span><span class="s3">(</span><span class="s1">expected</span><span class="s3">) </span><span class="s2">or</span>
            <span class="s1">expected </span><span class="s3">== </span><span class="s1">observed</span>
    <span class="s3">):</span>
        <span class="s1">relative_error </span><span class="s3">= </span><span class="s4">0.0</span>
        <span class="s1">absolute_error </span><span class="s3">= </span><span class="s4">0.0</span>
    <span class="s2">elif </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isnan</span><span class="s3">(</span><span class="s1">observed</span><span class="s3">):</span>
        <span class="s5"># Set error to infinity if result is nan when not expected to be.</span>
        <span class="s5"># Makes results easier to interpret.</span>
        <span class="s1">relative_error </span><span class="s3">= </span><span class="s1">float</span><span class="s3">(</span><span class="s6">&quot;inf&quot;</span><span class="s3">)</span>
        <span class="s1">absolute_error </span><span class="s3">= </span><span class="s1">float</span><span class="s3">(</span><span class="s6">&quot;inf&quot;</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">absolute_error </span><span class="s3">= </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">expected </span><span class="s3">- </span><span class="s1">observed</span><span class="s3">)</span>
        <span class="s1">relative_error </span><span class="s3">= </span><span class="s1">absolute_error </span><span class="s3">/ </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">expected</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s3">(</span>
        <span class="s1">a</span><span class="s3">,</span>
        <span class="s1">b</span><span class="s3">,</span>
        <span class="s1">c</span><span class="s3">,</span>
        <span class="s1">z</span><span class="s3">,</span>
        <span class="s1">abs</span><span class="s3">(</span><span class="s1">z</span><span class="s3">),</span>
        <span class="s1">get_region</span><span class="s3">(</span><span class="s1">z</span><span class="s3">),</span>
        <span class="s1">group</span><span class="s3">,</span>
        <span class="s1">expected</span><span class="s3">,</span>
        <span class="s1">observed</span><span class="s3">,</span>
        <span class="s1">relative_error</span><span class="s3">,</span>
        <span class="s1">absolute_error</span><span class="s3">,</span>
    <span class="s3">)</span>


<span class="s2">def </span><span class="s1">get_result_no_mp</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">z</span><span class="s3">, </span><span class="s1">group</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Get results for given parameter and value combination.&quot;&quot;&quot;</span>
    <span class="s1">expected</span><span class="s3">, </span><span class="s1">observed </span><span class="s3">= </span><span class="s1">complex</span><span class="s3">(</span><span class="s6">'nan'</span><span class="s3">), </span><span class="s1">hyp2f1</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">z</span><span class="s3">)</span>
    <span class="s1">relative_error</span><span class="s3">, </span><span class="s1">absolute_error </span><span class="s3">= </span><span class="s1">float</span><span class="s3">(</span><span class="s6">'nan'</span><span class="s3">), </span><span class="s1">float</span><span class="s3">(</span><span class="s6">'nan'</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s3">(</span>
        <span class="s1">a</span><span class="s3">,</span>
        <span class="s1">b</span><span class="s3">,</span>
        <span class="s1">c</span><span class="s3">,</span>
        <span class="s1">z</span><span class="s3">,</span>
        <span class="s1">abs</span><span class="s3">(</span><span class="s1">z</span><span class="s3">),</span>
        <span class="s1">get_region</span><span class="s3">(</span><span class="s1">z</span><span class="s3">),</span>
        <span class="s1">group</span><span class="s3">,</span>
        <span class="s1">expected</span><span class="s3">,</span>
        <span class="s1">observed</span><span class="s3">,</span>
        <span class="s1">relative_error</span><span class="s3">,</span>
        <span class="s1">absolute_error</span><span class="s3">,</span>
    <span class="s3">)</span>


<span class="s2">def </span><span class="s1">get_results</span><span class="s3">(</span><span class="s1">params</span><span class="s3">, </span><span class="s1">Z</span><span class="s3">, </span><span class="s1">n_jobs</span><span class="s3">=</span><span class="s4">1</span><span class="s3">, </span><span class="s1">compute_mp</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Batch compute results for multiple parameter and argument values. 
 
    Parameters 
    ---------- 
    params : iterable 
        iterable of tuples of floats (a, b, c) specifying parameter values 
        a, b, c for hyp2f1 
    Z : iterable of complex 
        Arguments at which to evaluate hyp2f1 
    n_jobs : Optional[int] 
        Number of jobs for parallel execution. 
 
    Returns 
    ------- 
    list 
        List of tuples of results values. See return value in source code 
        of `get_result`. 
    &quot;&quot;&quot;</span>
    <span class="s1">input_ </span><span class="s3">= (</span>
        <span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">z</span><span class="s3">, </span><span class="s1">group</span><span class="s3">) </span><span class="s2">for </span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">group</span><span class="s3">), </span><span class="s1">z </span><span class="s2">in </span><span class="s1">product</span><span class="s3">(</span><span class="s1">params</span><span class="s3">, </span><span class="s1">Z</span><span class="s3">)</span>
    <span class="s3">)</span>

    <span class="s2">with </span><span class="s1">Pool</span><span class="s3">(</span><span class="s1">n_jobs</span><span class="s3">) </span><span class="s2">as </span><span class="s1">pool</span><span class="s3">:</span>
        <span class="s1">rows </span><span class="s3">= </span><span class="s1">pool</span><span class="s3">.</span><span class="s1">starmap</span><span class="s3">(</span>
            <span class="s1">get_result </span><span class="s2">if </span><span class="s1">compute_mp </span><span class="s2">else </span><span class="s1">get_result_no_mp</span><span class="s3">,</span>
            <span class="s1">input_</span>
        <span class="s3">)</span>
    <span class="s2">return </span><span class="s1">rows</span>


<span class="s2">def </span><span class="s1">_make_hyp2f1_test_case</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">z</span><span class="s3">, </span><span class="s1">rtol</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Generate string for single test case as used in test_hyp2f1.py.&quot;&quot;&quot;</span>
    <span class="s1">expected </span><span class="s3">= </span><span class="s1">mp_hyp2f1</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">z</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s3">(</span>
        <span class="s6">&quot;    pytest.param(</span><span class="s2">\n</span><span class="s6">&quot;</span>
        <span class="s6">&quot;        Hyp2f1TestCase(</span><span class="s2">\n</span><span class="s6">&quot;</span>
        <span class="s6">f&quot;            a=</span><span class="s2">{</span><span class="s1">a</span><span class="s2">}</span><span class="s6">,</span><span class="s2">\n</span><span class="s6">&quot;</span>
        <span class="s6">f&quot;            b=</span><span class="s2">{</span><span class="s1">b</span><span class="s2">}</span><span class="s6">,</span><span class="s2">\n</span><span class="s6">&quot;</span>
        <span class="s6">f&quot;            c=</span><span class="s2">{</span><span class="s1">c</span><span class="s2">}</span><span class="s6">,</span><span class="s2">\n</span><span class="s6">&quot;</span>
        <span class="s6">f&quot;            z=</span><span class="s2">{</span><span class="s1">z</span><span class="s2">}</span><span class="s6">,</span><span class="s2">\n</span><span class="s6">&quot;</span>
        <span class="s6">f&quot;            expected=</span><span class="s2">{</span><span class="s1">expected</span><span class="s2">}</span><span class="s6">,</span><span class="s2">\n</span><span class="s6">&quot;</span>
        <span class="s6">f&quot;            rtol=</span><span class="s2">{</span><span class="s1">rtol</span><span class="s2">}</span><span class="s6">,</span><span class="s2">\n</span><span class="s6">&quot;</span>
        <span class="s6">&quot;        ),</span><span class="s2">\n</span><span class="s6">&quot;</span>
        <span class="s6">&quot;    ),&quot;</span>
    <span class="s3">)</span>


<span class="s2">def </span><span class="s1">make_hyp2f1_test_cases</span><span class="s3">(</span><span class="s1">rows</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Generate string for a list of test cases for test_hyp2f1.py. 
 
    Parameters 
    ---------- 
    rows : list 
        List of lists of the form [a, b, c, z, rtol] where a, b, c, z are 
        parameters and the argument for hyp2f1 and rtol is an expected 
        relative error for the associated test case. 
 
    Returns 
    ------- 
    str 
        String for a list of test cases. The output string can be printed 
        or saved to a file and then copied into an argument for 
        `pytest.mark.parameterize` within `scipy.special.tests.test_hyp2f1.py`. 
    &quot;&quot;&quot;</span>
    <span class="s1">result </span><span class="s3">= </span><span class="s6">&quot;[</span><span class="s2">\n</span><span class="s6">&quot;</span>
    <span class="s1">result </span><span class="s3">+= </span><span class="s6">'</span><span class="s2">\n</span><span class="s6">'</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span>
        <span class="s1">_make_hyp2f1_test_case</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">z</span><span class="s3">, </span><span class="s1">rtol</span><span class="s3">)</span>
        <span class="s2">for </span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">z</span><span class="s3">, </span><span class="s1">rtol </span><span class="s2">in </span><span class="s1">rows</span>
    <span class="s3">)</span>
    <span class="s1">result </span><span class="s3">+= </span><span class="s6">&quot;</span><span class="s2">\n</span><span class="s6">]&quot;</span>
    <span class="s2">return </span><span class="s1">result</span>


<span class="s2">def </span><span class="s1">main</span><span class="s3">(</span>
        <span class="s1">outpath</span><span class="s3">,</span>
        <span class="s1">n_jobs</span><span class="s3">=</span><span class="s4">1</span><span class="s3">,</span>
        <span class="s1">box_size</span><span class="s3">=</span><span class="s4">2.0</span><span class="s3">,</span>
        <span class="s1">grid_size</span><span class="s3">=</span><span class="s4">20</span><span class="s3">,</span>
        <span class="s1">regions</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">parameter_groups</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">compute_mp</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
<span class="s3">):</span>
    <span class="s1">outpath </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">realpath</span><span class="s3">(</span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">expanduser</span><span class="s3">(</span><span class="s1">outpath</span><span class="s3">))</span>

    <span class="s1">random_state </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">RandomState</span><span class="s3">(</span><span class="s4">1234</span><span class="s3">)</span>
    <span class="s5"># Parameters a, b, c selected near these values.</span>
    <span class="s1">root_params </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span>
        <span class="s3">[-</span><span class="s4">16</span><span class="s3">, -</span><span class="s4">8</span><span class="s3">, -</span><span class="s4">4</span><span class="s3">, -</span><span class="s4">2</span><span class="s3">, -</span><span class="s4">1</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">4</span><span class="s3">, </span><span class="s4">8</span><span class="s3">, </span><span class="s4">16</span><span class="s3">]</span>
    <span class="s3">)</span>
    <span class="s5"># Perturbations to apply to root values.</span>
    <span class="s1">perturbations </span><span class="s3">= </span><span class="s4">0.1 </span><span class="s3">* </span><span class="s1">random_state</span><span class="s3">.</span><span class="s1">random_sample</span><span class="s3">(</span>
        <span class="s1">size</span><span class="s3">=(</span><span class="s4">3</span><span class="s3">, </span><span class="s1">len</span><span class="s3">(</span><span class="s1">root_params</span><span class="s3">))</span>
    <span class="s3">)</span>

    <span class="s1">params </span><span class="s3">= []</span>
    <span class="s5"># Parameter group 1</span>
    <span class="s5"># -----------------</span>
    <span class="s5"># No integer differences. This has been confirmed for the above seed.</span>
    <span class="s1">A </span><span class="s3">= </span><span class="s1">root_params </span><span class="s3">+ </span><span class="s1">perturbations</span><span class="s3">[</span><span class="s4">0</span><span class="s3">, :]</span>
    <span class="s1">B </span><span class="s3">= </span><span class="s1">root_params </span><span class="s3">+ </span><span class="s1">perturbations</span><span class="s3">[</span><span class="s4">1</span><span class="s3">, :]</span>
    <span class="s1">C </span><span class="s3">= </span><span class="s1">root_params </span><span class="s3">+ </span><span class="s1">perturbations</span><span class="s3">[</span><span class="s4">2</span><span class="s3">, :]</span>
    <span class="s1">params</span><span class="s3">.</span><span class="s1">extend</span><span class="s3">(</span>
        <span class="s1">sorted</span><span class="s3">(</span>
            <span class="s3">((</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s4">1</span><span class="s3">) </span><span class="s2">for </span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">c </span><span class="s2">in </span><span class="s1">product</span><span class="s3">(</span><span class="s1">A</span><span class="s3">, </span><span class="s1">B</span><span class="s3">, </span><span class="s1">C</span><span class="s3">)),</span>
            <span class="s1">key</span><span class="s3">=</span><span class="s2">lambda </span><span class="s1">x</span><span class="s3">: </span><span class="s1">max</span><span class="s3">(</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">x</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]), </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">x</span><span class="s3">[</span><span class="s4">1</span><span class="s3">])),</span>
        <span class="s3">)</span>
    <span class="s3">)</span>

    <span class="s5"># Parameter group 2</span>
    <span class="s5"># -----------------</span>
    <span class="s5"># B - A an integer</span>
    <span class="s1">A </span><span class="s3">= </span><span class="s1">root_params </span><span class="s3">+ </span><span class="s4">0.5</span>
    <span class="s1">B </span><span class="s3">= </span><span class="s1">root_params </span><span class="s3">+ </span><span class="s4">0.5</span>
    <span class="s1">C </span><span class="s3">= </span><span class="s1">root_params </span><span class="s3">+ </span><span class="s1">perturbations</span><span class="s3">[</span><span class="s4">1</span><span class="s3">, :]</span>
    <span class="s1">params</span><span class="s3">.</span><span class="s1">extend</span><span class="s3">(</span>
        <span class="s1">sorted</span><span class="s3">(</span>
            <span class="s3">((</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s4">2</span><span class="s3">) </span><span class="s2">for </span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">c </span><span class="s2">in </span><span class="s1">product</span><span class="s3">(</span><span class="s1">A</span><span class="s3">, </span><span class="s1">B</span><span class="s3">, </span><span class="s1">C</span><span class="s3">)),</span>
            <span class="s1">key</span><span class="s3">=</span><span class="s2">lambda </span><span class="s1">x</span><span class="s3">: </span><span class="s1">max</span><span class="s3">(</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">x</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]), </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">x</span><span class="s3">[</span><span class="s4">1</span><span class="s3">])),</span>
        <span class="s3">)</span>
    <span class="s3">)</span>

    <span class="s5"># Parameter group 3</span>
    <span class="s5"># -----------------</span>
    <span class="s5"># C - A an integer</span>
    <span class="s1">A </span><span class="s3">= </span><span class="s1">root_params </span><span class="s3">+ </span><span class="s4">0.5</span>
    <span class="s1">B </span><span class="s3">= </span><span class="s1">root_params </span><span class="s3">+ </span><span class="s1">perturbations</span><span class="s3">[</span><span class="s4">1</span><span class="s3">, :]</span>
    <span class="s1">C </span><span class="s3">= </span><span class="s1">root_params </span><span class="s3">+ </span><span class="s4">0.5</span>
    <span class="s1">params</span><span class="s3">.</span><span class="s1">extend</span><span class="s3">(</span>
        <span class="s1">sorted</span><span class="s3">(</span>
            <span class="s3">((</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s4">3</span><span class="s3">) </span><span class="s2">for </span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">c </span><span class="s2">in </span><span class="s1">product</span><span class="s3">(</span><span class="s1">A</span><span class="s3">, </span><span class="s1">B</span><span class="s3">, </span><span class="s1">C</span><span class="s3">)),</span>
            <span class="s1">key</span><span class="s3">=</span><span class="s2">lambda </span><span class="s1">x</span><span class="s3">: </span><span class="s1">max</span><span class="s3">(</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">x</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]), </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">x</span><span class="s3">[</span><span class="s4">1</span><span class="s3">])),</span>
        <span class="s3">)</span>
    <span class="s3">)</span>

    <span class="s5"># Parameter group 4</span>
    <span class="s5"># -----------------</span>
    <span class="s5"># C - B an integer</span>
    <span class="s1">A </span><span class="s3">= </span><span class="s1">root_params </span><span class="s3">+ </span><span class="s1">perturbations</span><span class="s3">[</span><span class="s4">0</span><span class="s3">, :]</span>
    <span class="s1">B </span><span class="s3">= </span><span class="s1">root_params </span><span class="s3">+ </span><span class="s4">0.5</span>
    <span class="s1">C </span><span class="s3">= </span><span class="s1">root_params </span><span class="s3">+ </span><span class="s4">0.5</span>
    <span class="s1">params</span><span class="s3">.</span><span class="s1">extend</span><span class="s3">(</span>
        <span class="s1">sorted</span><span class="s3">(</span>
            <span class="s3">((</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s4">4</span><span class="s3">) </span><span class="s2">for </span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">c </span><span class="s2">in </span><span class="s1">product</span><span class="s3">(</span><span class="s1">A</span><span class="s3">, </span><span class="s1">B</span><span class="s3">, </span><span class="s1">C</span><span class="s3">)),</span>
            <span class="s1">key</span><span class="s3">=</span><span class="s2">lambda </span><span class="s1">x</span><span class="s3">: </span><span class="s1">max</span><span class="s3">(</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">x</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]), </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">x</span><span class="s3">[</span><span class="s4">1</span><span class="s3">])),</span>
        <span class="s3">)</span>
    <span class="s3">)</span>

    <span class="s5"># Parameter group 5</span>
    <span class="s5"># -----------------</span>
    <span class="s5"># C - A - B an integer</span>
    <span class="s1">A </span><span class="s3">= </span><span class="s1">root_params </span><span class="s3">+ </span><span class="s4">0.25</span>
    <span class="s1">B </span><span class="s3">= </span><span class="s1">root_params </span><span class="s3">+ </span><span class="s4">0.25</span>
    <span class="s1">C </span><span class="s3">= </span><span class="s1">root_params </span><span class="s3">+ </span><span class="s4">0.5</span>
    <span class="s1">params</span><span class="s3">.</span><span class="s1">extend</span><span class="s3">(</span>
        <span class="s1">sorted</span><span class="s3">(</span>
            <span class="s3">((</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s4">5</span><span class="s3">) </span><span class="s2">for </span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">c </span><span class="s2">in </span><span class="s1">product</span><span class="s3">(</span><span class="s1">A</span><span class="s3">, </span><span class="s1">B</span><span class="s3">, </span><span class="s1">C</span><span class="s3">)),</span>
            <span class="s1">key</span><span class="s3">=</span><span class="s2">lambda </span><span class="s1">x</span><span class="s3">: </span><span class="s1">max</span><span class="s3">(</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">x</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]), </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">x</span><span class="s3">[</span><span class="s4">1</span><span class="s3">])),</span>
        <span class="s3">)</span>
    <span class="s3">)</span>

    <span class="s5"># Parameter group 6</span>
    <span class="s5"># -----------------</span>
    <span class="s5"># A an integer</span>
    <span class="s1">A </span><span class="s3">= </span><span class="s1">root_params</span>
    <span class="s1">B </span><span class="s3">= </span><span class="s1">root_params </span><span class="s3">+ </span><span class="s1">perturbations</span><span class="s3">[</span><span class="s4">0</span><span class="s3">, :]</span>
    <span class="s1">C </span><span class="s3">= </span><span class="s1">root_params </span><span class="s3">+ </span><span class="s1">perturbations</span><span class="s3">[</span><span class="s4">1</span><span class="s3">, :]</span>
    <span class="s1">params</span><span class="s3">.</span><span class="s1">extend</span><span class="s3">(</span>
        <span class="s1">sorted</span><span class="s3">(</span>
            <span class="s3">((</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s4">6</span><span class="s3">) </span><span class="s2">for </span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">c </span><span class="s2">in </span><span class="s1">product</span><span class="s3">(</span><span class="s1">A</span><span class="s3">, </span><span class="s1">B</span><span class="s3">, </span><span class="s1">C</span><span class="s3">)),</span>
            <span class="s1">key</span><span class="s3">=</span><span class="s2">lambda </span><span class="s1">x</span><span class="s3">: </span><span class="s1">max</span><span class="s3">(</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">x</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]), </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">x</span><span class="s3">[</span><span class="s4">1</span><span class="s3">])),</span>
        <span class="s3">)</span>
    <span class="s3">)</span>

    <span class="s5"># Parameter group 7</span>
    <span class="s5"># -----------------</span>
    <span class="s5"># B an integer</span>
    <span class="s1">A </span><span class="s3">= </span><span class="s1">root_params </span><span class="s3">+ </span><span class="s1">perturbations</span><span class="s3">[</span><span class="s4">0</span><span class="s3">, :]</span>
    <span class="s1">B </span><span class="s3">= </span><span class="s1">root_params</span>
    <span class="s1">C </span><span class="s3">= </span><span class="s1">root_params </span><span class="s3">+ </span><span class="s1">perturbations</span><span class="s3">[</span><span class="s4">1</span><span class="s3">, :]</span>
    <span class="s1">params</span><span class="s3">.</span><span class="s1">extend</span><span class="s3">(</span>
        <span class="s1">sorted</span><span class="s3">(</span>
            <span class="s3">((</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s4">7</span><span class="s3">) </span><span class="s2">for </span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">c </span><span class="s2">in </span><span class="s1">product</span><span class="s3">(</span><span class="s1">A</span><span class="s3">, </span><span class="s1">B</span><span class="s3">, </span><span class="s1">C</span><span class="s3">)),</span>
            <span class="s1">key</span><span class="s3">=</span><span class="s2">lambda </span><span class="s1">x</span><span class="s3">: </span><span class="s1">max</span><span class="s3">(</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">x</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]), </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">x</span><span class="s3">[</span><span class="s4">1</span><span class="s3">])),</span>
        <span class="s3">)</span>
    <span class="s3">)</span>

    <span class="s5"># Parameter group 8</span>
    <span class="s5"># -----------------</span>
    <span class="s5"># C an integer</span>
    <span class="s1">A </span><span class="s3">= </span><span class="s1">root_params </span><span class="s3">+ </span><span class="s1">perturbations</span><span class="s3">[</span><span class="s4">0</span><span class="s3">, :]</span>
    <span class="s1">B </span><span class="s3">= </span><span class="s1">root_params </span><span class="s3">+ </span><span class="s1">perturbations</span><span class="s3">[</span><span class="s4">1</span><span class="s3">, :]</span>
    <span class="s1">C </span><span class="s3">= </span><span class="s1">root_params</span>
    <span class="s1">params</span><span class="s3">.</span><span class="s1">extend</span><span class="s3">(</span>
        <span class="s1">sorted</span><span class="s3">(</span>
            <span class="s3">((</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s4">8</span><span class="s3">) </span><span class="s2">for </span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">c </span><span class="s2">in </span><span class="s1">product</span><span class="s3">(</span><span class="s1">A</span><span class="s3">, </span><span class="s1">B</span><span class="s3">, </span><span class="s1">C</span><span class="s3">)),</span>
            <span class="s1">key</span><span class="s3">=</span><span class="s2">lambda </span><span class="s1">x</span><span class="s3">: </span><span class="s1">max</span><span class="s3">(</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">x</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]), </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">x</span><span class="s3">[</span><span class="s4">1</span><span class="s3">])),</span>
        <span class="s3">)</span>
    <span class="s3">)</span>

    <span class="s5"># Parameter group 9</span>
    <span class="s5"># -----------------</span>
    <span class="s5"># Wide range of magnitudes, c - a - b &gt; 0.</span>
    <span class="s1">phi </span><span class="s3">= (</span><span class="s4">1 </span><span class="s3">+ </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s4">5</span><span class="s3">))/</span><span class="s4">2</span>
    <span class="s1">P </span><span class="s3">= </span><span class="s1">phi</span><span class="s3">**</span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s4">16</span><span class="s3">)</span>
    <span class="s1">P </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">hstack</span><span class="s3">([-</span><span class="s1">P</span><span class="s3">, </span><span class="s1">P</span><span class="s3">])</span>
    <span class="s1">group_9_params </span><span class="s3">= </span><span class="s1">sorted</span><span class="s3">(</span>
        <span class="s3">(</span>
            <span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s4">9</span><span class="s3">) </span><span class="s2">for </span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">c </span><span class="s2">in </span><span class="s1">product</span><span class="s3">(</span><span class="s1">P</span><span class="s3">, </span><span class="s1">P</span><span class="s3">, </span><span class="s1">P</span><span class="s3">) </span><span class="s2">if </span><span class="s1">c </span><span class="s3">- </span><span class="s1">a </span><span class="s3">- </span><span class="s1">b </span><span class="s3">&gt; </span><span class="s4">0</span>
        <span class="s3">),</span>
        <span class="s1">key</span><span class="s3">=</span><span class="s2">lambda </span><span class="s1">x</span><span class="s3">: </span><span class="s1">max</span><span class="s3">(</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">x</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]), </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">x</span><span class="s3">[</span><span class="s4">1</span><span class="s3">])),</span>
    <span class="s3">)</span>

    <span class="s2">if </span><span class="s1">parameter_groups </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s5"># Group 9 params only used if specified in arguments.</span>
        <span class="s1">params</span><span class="s3">.</span><span class="s1">extend</span><span class="s3">(</span><span class="s1">group_9_params</span><span class="s3">)</span>
        <span class="s1">params </span><span class="s3">= [</span>
            <span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">group</span><span class="s3">) </span><span class="s2">for </span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">group </span><span class="s2">in </span><span class="s1">params</span>
            <span class="s2">if </span><span class="s1">group </span><span class="s2">in </span><span class="s1">parameter_groups</span>
        <span class="s3">]</span>

    <span class="s5"># grid_size * grid_size grid in box with corners</span>
    <span class="s5"># -2 - 2j, -2 + 2j, 2 - 2j, 2 + 2j</span>
    <span class="s1">X</span><span class="s3">, </span><span class="s1">Y </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">meshgrid</span><span class="s3">(</span>
        <span class="s1">np</span><span class="s3">.</span><span class="s1">linspace</span><span class="s3">(-</span><span class="s1">box_size</span><span class="s3">, </span><span class="s1">box_size</span><span class="s3">, </span><span class="s1">grid_size</span><span class="s3">),</span>
        <span class="s1">np</span><span class="s3">.</span><span class="s1">linspace</span><span class="s3">(-</span><span class="s1">box_size</span><span class="s3">, </span><span class="s1">box_size</span><span class="s3">, </span><span class="s1">grid_size</span><span class="s3">)</span>
    <span class="s3">)</span>
    <span class="s1">Z </span><span class="s3">= </span><span class="s1">X </span><span class="s3">+ </span><span class="s1">Y </span><span class="s3">* </span><span class="s4">1j</span>
    <span class="s1">Z </span><span class="s3">= </span><span class="s1">Z</span><span class="s3">.</span><span class="s1">flatten</span><span class="s3">().</span><span class="s1">tolist</span><span class="s3">()</span>
    <span class="s5"># Add z = 1 + 0j (region 0).</span>
    <span class="s1">Z</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s4">1 </span><span class="s3">+ </span><span class="s4">0j</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">regions </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s1">Z </span><span class="s3">= [</span><span class="s1">z </span><span class="s2">for </span><span class="s1">z </span><span class="s2">in </span><span class="s1">Z </span><span class="s2">if </span><span class="s1">get_region</span><span class="s3">(</span><span class="s1">z</span><span class="s3">) </span><span class="s2">in </span><span class="s1">regions</span><span class="s3">]</span>

    <span class="s5"># Evaluate scipy and mpmath's hyp2f1 for all parameter combinations</span>
    <span class="s5"># above against all arguments in the grid Z</span>
    <span class="s1">rows </span><span class="s3">= </span><span class="s1">get_results</span><span class="s3">(</span><span class="s1">params</span><span class="s3">, </span><span class="s1">Z</span><span class="s3">, </span><span class="s1">n_jobs</span><span class="s3">=</span><span class="s1">n_jobs</span><span class="s3">, </span><span class="s1">compute_mp</span><span class="s3">=</span><span class="s1">compute_mp</span><span class="s3">)</span>

    <span class="s2">with </span><span class="s1">open</span><span class="s3">(</span><span class="s1">outpath</span><span class="s3">, </span><span class="s6">&quot;w&quot;</span><span class="s3">, </span><span class="s1">newline</span><span class="s3">=</span><span class="s6">&quot;&quot;</span><span class="s3">) </span><span class="s2">as </span><span class="s1">f</span><span class="s3">:</span>
        <span class="s1">writer </span><span class="s3">= </span><span class="s1">csv</span><span class="s3">.</span><span class="s1">writer</span><span class="s3">(</span><span class="s1">f</span><span class="s3">, </span><span class="s1">delimiter</span><span class="s3">=</span><span class="s6">&quot;</span><span class="s2">\t</span><span class="s6">&quot;</span><span class="s3">)</span>
        <span class="s1">writer</span><span class="s3">.</span><span class="s1">writerow</span><span class="s3">(</span>
            <span class="s3">[</span>
                <span class="s6">&quot;a&quot;</span><span class="s3">,</span>
                <span class="s6">&quot;b&quot;</span><span class="s3">,</span>
                <span class="s6">&quot;c&quot;</span><span class="s3">,</span>
                <span class="s6">&quot;z&quot;</span><span class="s3">,</span>
                <span class="s6">&quot;|z|&quot;</span><span class="s3">,</span>
                <span class="s6">&quot;region&quot;</span><span class="s3">,</span>
                <span class="s6">&quot;parameter_group&quot;</span><span class="s3">,</span>
                <span class="s6">&quot;expected&quot;</span><span class="s3">,  </span><span class="s5"># mpmath's hyp2f1</span>
                <span class="s6">&quot;observed&quot;</span><span class="s3">,  </span><span class="s5"># scipy's hyp2f1</span>
                <span class="s6">&quot;relative_error&quot;</span><span class="s3">,</span>
                <span class="s6">&quot;absolute_error&quot;</span><span class="s3">,</span>
            <span class="s3">]</span>
        <span class="s3">)</span>
        <span class="s2">for </span><span class="s1">row </span><span class="s2">in </span><span class="s1">rows</span><span class="s3">:</span>
            <span class="s1">writer</span><span class="s3">.</span><span class="s1">writerow</span><span class="s3">(</span><span class="s1">row</span><span class="s3">)</span>


<span class="s2">if </span><span class="s1">__name__ </span><span class="s3">== </span><span class="s6">&quot;__main__&quot;</span><span class="s3">:</span>
    <span class="s1">parser </span><span class="s3">= </span><span class="s1">argparse</span><span class="s3">.</span><span class="s1">ArgumentParser</span><span class="s3">(</span>
        <span class="s1">description</span><span class="s3">=</span><span class="s6">&quot;Test scipy's hyp2f1 against mpmath's on a grid in the&quot;</span>
        <span class="s6">&quot; complex plane over a grid of parameter values. Saves output to file&quot;</span>
        <span class="s6">&quot; specified in positional argument </span><span class="s2">\&quot;</span><span class="s6">outpath</span><span class="s2">\&quot;</span><span class="s6">.&quot;</span>
        <span class="s6">&quot; Caution: With default arguments, the generated output file is&quot;</span>
        <span class="s6">&quot; roughly 700MB in size. Script may take several hours to finish if&quot;</span>
        <span class="s6">&quot; </span><span class="s2">\&quot;</span><span class="s6">--n_jobs</span><span class="s2">\&quot; </span><span class="s6">is set to 1.&quot;</span>
    <span class="s3">)</span>
    <span class="s1">parser</span><span class="s3">.</span><span class="s1">add_argument</span><span class="s3">(</span>
        <span class="s6">&quot;outpath&quot;</span><span class="s3">, </span><span class="s1">type</span><span class="s3">=</span><span class="s1">str</span><span class="s3">, </span><span class="s1">help</span><span class="s3">=</span><span class="s6">&quot;Path to output tsv file.&quot;</span>
    <span class="s3">)</span>
    <span class="s1">parser</span><span class="s3">.</span><span class="s1">add_argument</span><span class="s3">(</span>
        <span class="s6">&quot;--n_jobs&quot;</span><span class="s3">,</span>
        <span class="s1">type</span><span class="s3">=</span><span class="s1">int</span><span class="s3">,</span>
        <span class="s1">default</span><span class="s3">=</span><span class="s4">1</span><span class="s3">,</span>
        <span class="s1">help</span><span class="s3">=</span><span class="s6">&quot;Number of jobs for multiprocessing.&quot;</span><span class="s3">,</span>
    <span class="s3">)</span>
    <span class="s1">parser</span><span class="s3">.</span><span class="s1">add_argument</span><span class="s3">(</span>
        <span class="s6">&quot;--box_size&quot;</span><span class="s3">,</span>
        <span class="s1">type</span><span class="s3">=</span><span class="s1">float</span><span class="s3">,</span>
        <span class="s1">default</span><span class="s3">=</span><span class="s4">2.0</span><span class="s3">,</span>
        <span class="s1">help</span><span class="s3">=</span><span class="s6">&quot;hyp2f1 is evaluated in box of side_length 2*box_size centered&quot;</span>
        <span class="s6">&quot; at the origin.&quot;</span>
    <span class="s3">)</span>
    <span class="s1">parser</span><span class="s3">.</span><span class="s1">add_argument</span><span class="s3">(</span>
        <span class="s6">&quot;--grid_size&quot;</span><span class="s3">,</span>
        <span class="s1">type</span><span class="s3">=</span><span class="s1">int</span><span class="s3">,</span>
        <span class="s1">default</span><span class="s3">=</span><span class="s4">20</span><span class="s3">,</span>
        <span class="s1">help</span><span class="s3">=</span><span class="s6">&quot;hyp2f1 is evaluated on grid_size * grid_size grid in box of side&quot;</span>
        <span class="s6">&quot; length 2*box_size centered at the origin.&quot;</span>
    <span class="s3">)</span>
    <span class="s1">parser</span><span class="s3">.</span><span class="s1">add_argument</span><span class="s3">(</span>
        <span class="s6">&quot;--parameter_groups&quot;</span><span class="s3">,</span>
        <span class="s1">type</span><span class="s3">=</span><span class="s1">int</span><span class="s3">,</span>
        <span class="s1">nargs</span><span class="s3">=</span><span class="s6">'+'</span><span class="s3">,</span>
        <span class="s1">default</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">help</span><span class="s3">=</span><span class="s6">&quot;Restrict to supplied parameter groups. See the Docstring for&quot;</span>
        <span class="s6">&quot; this module for more info on parameter groups. Calculate for all&quot;</span>
        <span class="s6">&quot; parameter groups by default.&quot;</span>
    <span class="s3">)</span>
    <span class="s1">parser</span><span class="s3">.</span><span class="s1">add_argument</span><span class="s3">(</span>
        <span class="s6">&quot;--regions&quot;</span><span class="s3">,</span>
        <span class="s1">type</span><span class="s3">=</span><span class="s1">int</span><span class="s3">,</span>
        <span class="s1">nargs</span><span class="s3">=</span><span class="s6">'+'</span><span class="s3">,</span>
        <span class="s1">default</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">help</span><span class="s3">=</span><span class="s6">&quot;Restrict to argument z only within the supplied regions. See&quot;</span>
        <span class="s6">&quot; the Docstring for this module for more info on regions. Calculate&quot;</span>
        <span class="s6">&quot; for all regions by default.&quot;</span>
    <span class="s3">)</span>
    <span class="s1">parser</span><span class="s3">.</span><span class="s1">add_argument</span><span class="s3">(</span>
        <span class="s6">&quot;--no_mp&quot;</span><span class="s3">,</span>
        <span class="s1">action</span><span class="s3">=</span><span class="s6">'store_true'</span><span class="s3">,</span>
        <span class="s1">help</span><span class="s3">=</span><span class="s6">&quot;If this flag is set, do not compute results with mpmath. Saves&quot;</span>
        <span class="s6">&quot; time if results have already been computed elsewhere. Fills in&quot;</span>
        <span class="s6">&quot; </span><span class="s2">\&quot;</span><span class="s6">expected</span><span class="s2">\&quot; </span><span class="s6">column with None values.&quot;</span>
    <span class="s3">)</span>
    <span class="s1">args </span><span class="s3">= </span><span class="s1">parser</span><span class="s3">.</span><span class="s1">parse_args</span><span class="s3">()</span>
    <span class="s1">compute_mp </span><span class="s3">= </span><span class="s2">not </span><span class="s1">args</span><span class="s3">.</span><span class="s1">no_mp</span>
    <span class="s1">print</span><span class="s3">(</span><span class="s1">args</span><span class="s3">.</span><span class="s1">parameter_groups</span><span class="s3">)</span>
    <span class="s1">main</span><span class="s3">(</span>
        <span class="s1">args</span><span class="s3">.</span><span class="s1">outpath</span><span class="s3">,</span>
        <span class="s1">n_jobs</span><span class="s3">=</span><span class="s1">args</span><span class="s3">.</span><span class="s1">n_jobs</span><span class="s3">,</span>
        <span class="s1">box_size</span><span class="s3">=</span><span class="s1">args</span><span class="s3">.</span><span class="s1">box_size</span><span class="s3">,</span>
        <span class="s1">grid_size</span><span class="s3">=</span><span class="s1">args</span><span class="s3">.</span><span class="s1">grid_size</span><span class="s3">,</span>
        <span class="s1">parameter_groups</span><span class="s3">=</span><span class="s1">args</span><span class="s3">.</span><span class="s1">parameter_groups</span><span class="s3">,</span>
        <span class="s1">regions</span><span class="s3">=</span><span class="s1">args</span><span class="s3">.</span><span class="s1">regions</span><span class="s3">,</span>
        <span class="s1">compute_mp</span><span class="s3">=</span><span class="s1">compute_mp</span><span class="s3">,</span>
    <span class="s3">)</span>
</pre>
</body>
</html>