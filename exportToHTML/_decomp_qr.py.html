<html>
<head>
<title>_decomp_qr.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #7a7e85;}
.s4 { color: #bcbec4;}
.s5 { color: #6aab73;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_decomp_qr.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;QR decomposition functions.&quot;&quot;&quot;</span>
<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>

<span class="s3"># Local imports</span>
<span class="s2">from </span><span class="s4">.</span><span class="s1">lapack </span><span class="s2">import </span><span class="s1">get_lapack_funcs</span>
<span class="s2">from </span><span class="s4">.</span><span class="s1">_misc </span><span class="s2">import </span><span class="s1">_datacopied</span>

<span class="s1">__all__ </span><span class="s4">= [</span><span class="s5">'qr'</span><span class="s4">, </span><span class="s5">'qr_multiply'</span><span class="s4">, </span><span class="s5">'rq'</span><span class="s4">]</span>


<span class="s2">def </span><span class="s1">safecall</span><span class="s4">(</span><span class="s1">f</span><span class="s4">, </span><span class="s1">name</span><span class="s4">, *</span><span class="s1">args</span><span class="s4">, **</span><span class="s1">kwargs</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Call a LAPACK routine, determining lwork automatically and handling 
    error return values&quot;&quot;&quot;</span>
    <span class="s1">lwork </span><span class="s4">= </span><span class="s1">kwargs</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s5">&quot;lwork&quot;</span><span class="s4">, </span><span class="s2">None</span><span class="s4">)</span>
    <span class="s2">if </span><span class="s1">lwork </span><span class="s2">in </span><span class="s4">(</span><span class="s2">None</span><span class="s4">, -</span><span class="s6">1</span><span class="s4">):</span>
        <span class="s1">kwargs</span><span class="s4">[</span><span class="s5">'lwork'</span><span class="s4">] = -</span><span class="s6">1</span>
        <span class="s1">ret </span><span class="s4">= </span><span class="s1">f</span><span class="s4">(*</span><span class="s1">args</span><span class="s4">, **</span><span class="s1">kwargs</span><span class="s4">)</span>
        <span class="s1">kwargs</span><span class="s4">[</span><span class="s5">'lwork'</span><span class="s4">] = </span><span class="s1">ret</span><span class="s4">[-</span><span class="s6">2</span><span class="s4">][</span><span class="s6">0</span><span class="s4">].</span><span class="s1">real</span><span class="s4">.</span><span class="s1">astype</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">int_</span><span class="s4">)</span>
    <span class="s1">ret </span><span class="s4">= </span><span class="s1">f</span><span class="s4">(*</span><span class="s1">args</span><span class="s4">, **</span><span class="s1">kwargs</span><span class="s4">)</span>
    <span class="s2">if </span><span class="s1">ret</span><span class="s4">[-</span><span class="s6">1</span><span class="s4">] &lt; </span><span class="s6">0</span><span class="s4">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;illegal value in %dth argument of internal %s&quot;</span>
                         <span class="s4">% (-</span><span class="s1">ret</span><span class="s4">[-</span><span class="s6">1</span><span class="s4">], </span><span class="s1">name</span><span class="s4">))</span>
    <span class="s2">return </span><span class="s1">ret</span><span class="s4">[:-</span><span class="s6">2</span><span class="s4">]</span>


<span class="s2">def </span><span class="s1">qr</span><span class="s4">(</span><span class="s1">a</span><span class="s4">, </span><span class="s1">overwrite_a</span><span class="s4">=</span><span class="s2">False</span><span class="s4">, </span><span class="s1">lwork</span><span class="s4">=</span><span class="s2">None</span><span class="s4">, </span><span class="s1">mode</span><span class="s4">=</span><span class="s5">'full'</span><span class="s4">, </span><span class="s1">pivoting</span><span class="s4">=</span><span class="s2">False</span><span class="s4">,</span>
       <span class="s1">check_finite</span><span class="s4">=</span><span class="s2">True</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Compute QR decomposition of a matrix. 
 
    Calculate the decomposition ``A = Q R`` where Q is unitary/orthogonal 
    and R upper triangular. 
 
    Parameters 
    ---------- 
    a : (M, N) array_like 
        Matrix to be decomposed 
    overwrite_a : bool, optional 
        Whether data in `a` is overwritten (may improve performance if 
        `overwrite_a` is set to True by reusing the existing input data 
        structure rather than creating a new one.) 
    lwork : int, optional 
        Work array size, lwork &gt;= a.shape[1]. If None or -1, an optimal size 
        is computed. 
    mode : {'full', 'r', 'economic', 'raw'}, optional 
        Determines what information is to be returned: either both Q and R 
        ('full', default), only R ('r') or both Q and R but computed in 
        economy-size ('economic', see Notes). The final option 'raw' 
        (added in SciPy 0.11) makes the function return two matrices 
        (Q, TAU) in the internal format used by LAPACK. 
    pivoting : bool, optional 
        Whether or not factorization should include pivoting for rank-revealing 
        qr decomposition. If pivoting, compute the decomposition 
        ``A[:, P] = Q @ R`` as above, but where P is chosen such that the  
        diagonal of R is non-increasing. 
    check_finite : bool, optional 
        Whether to check that the input matrix contains only finite numbers. 
        Disabling may give a performance gain, but may result in problems 
        (crashes, non-termination) if the inputs do contain infinities or NaNs. 
 
    Returns 
    ------- 
    Q : float or complex ndarray 
        Of shape (M, M), or (M, K) for ``mode='economic'``. Not returned 
        if ``mode='r'``. Replaced by tuple ``(Q, TAU)`` if ``mode='raw'``. 
    R : float or complex ndarray 
        Of shape (M, N), or (K, N) for ``mode in ['economic', 'raw']``. 
        ``K = min(M, N)``. 
    P : int ndarray 
        Of shape (N,) for ``pivoting=True``. Not returned if 
        ``pivoting=False``. 
 
    Raises 
    ------ 
    LinAlgError 
        Raised if decomposition fails 
 
    Notes 
    ----- 
    This is an interface to the LAPACK routines dgeqrf, zgeqrf, 
    dorgqr, zungqr, dgeqp3, and zgeqp3. 
 
    If ``mode=economic``, the shapes of Q and R are (M, K) and (K, N) instead 
    of (M,M) and (M,N), with ``K=min(M,N)``. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import linalg 
    &gt;&gt;&gt; rng = np.random.default_rng() 
    &gt;&gt;&gt; a = rng.standard_normal((9, 6)) 
 
    &gt;&gt;&gt; q, r = linalg.qr(a) 
    &gt;&gt;&gt; np.allclose(a, np.dot(q, r)) 
    True 
    &gt;&gt;&gt; q.shape, r.shape 
    ((9, 9), (9, 6)) 
 
    &gt;&gt;&gt; r2 = linalg.qr(a, mode='r') 
    &gt;&gt;&gt; np.allclose(r, r2) 
    True 
 
    &gt;&gt;&gt; q3, r3 = linalg.qr(a, mode='economic') 
    &gt;&gt;&gt; q3.shape, r3.shape 
    ((9, 6), (6, 6)) 
 
    &gt;&gt;&gt; q4, r4, p4 = linalg.qr(a, pivoting=True) 
    &gt;&gt;&gt; d = np.abs(np.diag(r4)) 
    &gt;&gt;&gt; np.all(d[1:] &lt;= d[:-1]) 
    True 
    &gt;&gt;&gt; np.allclose(a[:, p4], np.dot(q4, r4)) 
    True 
    &gt;&gt;&gt; q4.shape, r4.shape, p4.shape 
    ((9, 9), (9, 6), (6,)) 
 
    &gt;&gt;&gt; q5, r5, p5 = linalg.qr(a, mode='economic', pivoting=True) 
    &gt;&gt;&gt; q5.shape, r5.shape, p5.shape 
    ((9, 6), (6, 6), (6,)) 
 
    &quot;&quot;&quot;</span>
    <span class="s3"># 'qr' was the old default, equivalent to 'full'. Neither 'full' nor</span>
    <span class="s3"># 'qr' are used below.</span>
    <span class="s3"># 'raw' is used internally by qr_multiply</span>
    <span class="s2">if </span><span class="s1">mode </span><span class="s2">not in </span><span class="s4">[</span><span class="s5">'full'</span><span class="s4">, </span><span class="s5">'qr'</span><span class="s4">, </span><span class="s5">'r'</span><span class="s4">, </span><span class="s5">'economic'</span><span class="s4">, </span><span class="s5">'raw'</span><span class="s4">]:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;Mode argument should be one of ['full', 'r', &quot;</span>
                         <span class="s5">&quot;'economic', 'raw']&quot;</span><span class="s4">)</span>

    <span class="s2">if </span><span class="s1">check_finite</span><span class="s4">:</span>
        <span class="s1">a1 </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">asarray_chkfinite</span><span class="s4">(</span><span class="s1">a</span><span class="s4">)</span>
    <span class="s2">else</span><span class="s4">:</span>
        <span class="s1">a1 </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">(</span><span class="s1">a</span><span class="s4">)</span>
    <span class="s2">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">a1</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">) != </span><span class="s6">2</span><span class="s4">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;expected a 2-D array&quot;</span><span class="s4">)</span>

    <span class="s1">M</span><span class="s4">, </span><span class="s1">N </span><span class="s4">= </span><span class="s1">a1</span><span class="s4">.</span><span class="s1">shape</span>

    <span class="s3"># accommodate empty arrays</span>
    <span class="s2">if </span><span class="s1">a1</span><span class="s4">.</span><span class="s1">size </span><span class="s4">== </span><span class="s6">0</span><span class="s4">:</span>
        <span class="s1">K </span><span class="s4">= </span><span class="s1">min</span><span class="s4">(</span><span class="s1">M</span><span class="s4">, </span><span class="s1">N</span><span class="s4">)</span>

        <span class="s2">if </span><span class="s1">mode </span><span class="s2">not in </span><span class="s4">[</span><span class="s5">'economic'</span><span class="s4">, </span><span class="s5">'raw'</span><span class="s4">]:</span>
            <span class="s1">Q </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">empty_like</span><span class="s4">(</span><span class="s1">a1</span><span class="s4">, </span><span class="s1">shape</span><span class="s4">=(</span><span class="s1">M</span><span class="s4">, </span><span class="s1">M</span><span class="s4">))</span>
            <span class="s1">Q</span><span class="s4">[...] = </span><span class="s1">np</span><span class="s4">.</span><span class="s1">identity</span><span class="s4">(</span><span class="s1">M</span><span class="s4">)</span>
            <span class="s1">R </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">empty_like</span><span class="s4">(</span><span class="s1">a1</span><span class="s4">)</span>
        <span class="s2">else</span><span class="s4">:</span>
            <span class="s1">Q </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">empty_like</span><span class="s4">(</span><span class="s1">a1</span><span class="s4">, </span><span class="s1">shape</span><span class="s4">=(</span><span class="s1">M</span><span class="s4">, </span><span class="s1">K</span><span class="s4">))</span>
            <span class="s1">R </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">empty_like</span><span class="s4">(</span><span class="s1">a1</span><span class="s4">, </span><span class="s1">shape</span><span class="s4">=(</span><span class="s1">K</span><span class="s4">, </span><span class="s1">N</span><span class="s4">))</span>

        <span class="s2">if </span><span class="s1">pivoting</span><span class="s4">:</span>
            <span class="s1">Rj </span><span class="s4">= </span><span class="s1">R</span><span class="s4">, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">arange</span><span class="s4">(</span><span class="s1">N</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">np</span><span class="s4">.</span><span class="s1">int32</span><span class="s4">)</span>
        <span class="s2">else</span><span class="s4">:</span>
            <span class="s1">Rj </span><span class="s4">= </span><span class="s1">R</span><span class="s4">,</span>

        <span class="s2">if </span><span class="s1">mode </span><span class="s4">== </span><span class="s5">'r'</span><span class="s4">:</span>
            <span class="s2">return </span><span class="s1">Rj</span>
        <span class="s2">elif </span><span class="s1">mode </span><span class="s4">== </span><span class="s5">'raw'</span><span class="s4">:</span>
            <span class="s1">qr </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">empty_like</span><span class="s4">(</span><span class="s1">a1</span><span class="s4">, </span><span class="s1">shape</span><span class="s4">=(</span><span class="s1">M</span><span class="s4">, </span><span class="s1">N</span><span class="s4">))</span>
            <span class="s1">tau </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">zeros_like</span><span class="s4">(</span><span class="s1">a1</span><span class="s4">, </span><span class="s1">shape</span><span class="s4">=(</span><span class="s1">K</span><span class="s4">,))</span>
            <span class="s2">return </span><span class="s4">((</span><span class="s1">qr</span><span class="s4">, </span><span class="s1">tau</span><span class="s4">),) + </span><span class="s1">Rj</span>
        <span class="s2">return </span><span class="s4">(</span><span class="s1">Q</span><span class="s4">,) + </span><span class="s1">Rj</span>

    <span class="s1">overwrite_a </span><span class="s4">= </span><span class="s1">overwrite_a </span><span class="s2">or </span><span class="s4">(</span><span class="s1">_datacopied</span><span class="s4">(</span><span class="s1">a1</span><span class="s4">, </span><span class="s1">a</span><span class="s4">))</span>

    <span class="s2">if </span><span class="s1">pivoting</span><span class="s4">:</span>
        <span class="s1">geqp3</span><span class="s4">, = </span><span class="s1">get_lapack_funcs</span><span class="s4">((</span><span class="s5">'geqp3'</span><span class="s4">,), (</span><span class="s1">a1</span><span class="s4">,))</span>
        <span class="s1">qr</span><span class="s4">, </span><span class="s1">jpvt</span><span class="s4">, </span><span class="s1">tau </span><span class="s4">= </span><span class="s1">safecall</span><span class="s4">(</span><span class="s1">geqp3</span><span class="s4">, </span><span class="s5">&quot;geqp3&quot;</span><span class="s4">, </span><span class="s1">a1</span><span class="s4">, </span><span class="s1">overwrite_a</span><span class="s4">=</span><span class="s1">overwrite_a</span><span class="s4">)</span>
        <span class="s1">jpvt </span><span class="s4">-= </span><span class="s6">1  </span><span class="s3"># geqp3 returns a 1-based index array, so subtract 1</span>
    <span class="s2">else</span><span class="s4">:</span>
        <span class="s1">geqrf</span><span class="s4">, = </span><span class="s1">get_lapack_funcs</span><span class="s4">((</span><span class="s5">'geqrf'</span><span class="s4">,), (</span><span class="s1">a1</span><span class="s4">,))</span>
        <span class="s1">qr</span><span class="s4">, </span><span class="s1">tau </span><span class="s4">= </span><span class="s1">safecall</span><span class="s4">(</span><span class="s1">geqrf</span><span class="s4">, </span><span class="s5">&quot;geqrf&quot;</span><span class="s4">, </span><span class="s1">a1</span><span class="s4">, </span><span class="s1">lwork</span><span class="s4">=</span><span class="s1">lwork</span><span class="s4">,</span>
                           <span class="s1">overwrite_a</span><span class="s4">=</span><span class="s1">overwrite_a</span><span class="s4">)</span>

    <span class="s2">if </span><span class="s1">mode </span><span class="s2">not in </span><span class="s4">[</span><span class="s5">'economic'</span><span class="s4">, </span><span class="s5">'raw'</span><span class="s4">] </span><span class="s2">or </span><span class="s1">M </span><span class="s4">&lt; </span><span class="s1">N</span><span class="s4">:</span>
        <span class="s1">R </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">triu</span><span class="s4">(</span><span class="s1">qr</span><span class="s4">)</span>
    <span class="s2">else</span><span class="s4">:</span>
        <span class="s1">R </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">triu</span><span class="s4">(</span><span class="s1">qr</span><span class="s4">[:</span><span class="s1">N</span><span class="s4">, :])</span>

    <span class="s2">if </span><span class="s1">pivoting</span><span class="s4">:</span>
        <span class="s1">Rj </span><span class="s4">= </span><span class="s1">R</span><span class="s4">, </span><span class="s1">jpvt</span>
    <span class="s2">else</span><span class="s4">:</span>
        <span class="s1">Rj </span><span class="s4">= </span><span class="s1">R</span><span class="s4">,</span>

    <span class="s2">if </span><span class="s1">mode </span><span class="s4">== </span><span class="s5">'r'</span><span class="s4">:</span>
        <span class="s2">return </span><span class="s1">Rj</span>
    <span class="s2">elif </span><span class="s1">mode </span><span class="s4">== </span><span class="s5">'raw'</span><span class="s4">:</span>
        <span class="s2">return </span><span class="s4">((</span><span class="s1">qr</span><span class="s4">, </span><span class="s1">tau</span><span class="s4">),) + </span><span class="s1">Rj</span>

    <span class="s1">gor_un_gqr</span><span class="s4">, = </span><span class="s1">get_lapack_funcs</span><span class="s4">((</span><span class="s5">'orgqr'</span><span class="s4">,), (</span><span class="s1">qr</span><span class="s4">,))</span>

    <span class="s2">if </span><span class="s1">M </span><span class="s4">&lt; </span><span class="s1">N</span><span class="s4">:</span>
        <span class="s1">Q</span><span class="s4">, = </span><span class="s1">safecall</span><span class="s4">(</span><span class="s1">gor_un_gqr</span><span class="s4">, </span><span class="s5">&quot;gorgqr/gungqr&quot;</span><span class="s4">, </span><span class="s1">qr</span><span class="s4">[:, :</span><span class="s1">M</span><span class="s4">], </span><span class="s1">tau</span><span class="s4">,</span>
                      <span class="s1">lwork</span><span class="s4">=</span><span class="s1">lwork</span><span class="s4">, </span><span class="s1">overwrite_a</span><span class="s4">=</span><span class="s6">1</span><span class="s4">)</span>
    <span class="s2">elif </span><span class="s1">mode </span><span class="s4">== </span><span class="s5">'economic'</span><span class="s4">:</span>
        <span class="s1">Q</span><span class="s4">, = </span><span class="s1">safecall</span><span class="s4">(</span><span class="s1">gor_un_gqr</span><span class="s4">, </span><span class="s5">&quot;gorgqr/gungqr&quot;</span><span class="s4">, </span><span class="s1">qr</span><span class="s4">, </span><span class="s1">tau</span><span class="s4">, </span><span class="s1">lwork</span><span class="s4">=</span><span class="s1">lwork</span><span class="s4">,</span>
                      <span class="s1">overwrite_a</span><span class="s4">=</span><span class="s6">1</span><span class="s4">)</span>
    <span class="s2">else</span><span class="s4">:</span>
        <span class="s1">t </span><span class="s4">= </span><span class="s1">qr</span><span class="s4">.</span><span class="s1">dtype</span><span class="s4">.</span><span class="s1">char</span>
        <span class="s1">qqr </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">empty</span><span class="s4">((</span><span class="s1">M</span><span class="s4">, </span><span class="s1">M</span><span class="s4">), </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">t</span><span class="s4">)</span>
        <span class="s1">qqr</span><span class="s4">[:, :</span><span class="s1">N</span><span class="s4">] = </span><span class="s1">qr</span>
        <span class="s1">Q</span><span class="s4">, = </span><span class="s1">safecall</span><span class="s4">(</span><span class="s1">gor_un_gqr</span><span class="s4">, </span><span class="s5">&quot;gorgqr/gungqr&quot;</span><span class="s4">, </span><span class="s1">qqr</span><span class="s4">, </span><span class="s1">tau</span><span class="s4">, </span><span class="s1">lwork</span><span class="s4">=</span><span class="s1">lwork</span><span class="s4">,</span>
                      <span class="s1">overwrite_a</span><span class="s4">=</span><span class="s6">1</span><span class="s4">)</span>

    <span class="s2">return </span><span class="s4">(</span><span class="s1">Q</span><span class="s4">,) + </span><span class="s1">Rj</span>


<span class="s2">def </span><span class="s1">qr_multiply</span><span class="s4">(</span><span class="s1">a</span><span class="s4">, </span><span class="s1">c</span><span class="s4">, </span><span class="s1">mode</span><span class="s4">=</span><span class="s5">'right'</span><span class="s4">, </span><span class="s1">pivoting</span><span class="s4">=</span><span class="s2">False</span><span class="s4">, </span><span class="s1">conjugate</span><span class="s4">=</span><span class="s2">False</span><span class="s4">,</span>
                <span class="s1">overwrite_a</span><span class="s4">=</span><span class="s2">False</span><span class="s4">, </span><span class="s1">overwrite_c</span><span class="s4">=</span><span class="s2">False</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Calculate the QR decomposition and multiply Q with a matrix. 
 
    Calculate the decomposition ``A = Q R`` where Q is unitary/orthogonal 
    and R upper triangular. Multiply Q with a vector or a matrix c. 
 
    Parameters 
    ---------- 
    a : (M, N), array_like 
        Input array 
    c : array_like 
        Input array to be multiplied by ``q``. 
    mode : {'left', 'right'}, optional 
        ``Q @ c`` is returned if mode is 'left', ``c @ Q`` is returned if 
        mode is 'right'. 
        The shape of c must be appropriate for the matrix multiplications, 
        if mode is 'left', ``min(a.shape) == c.shape[0]``, 
        if mode is 'right', ``a.shape[0] == c.shape[1]``. 
    pivoting : bool, optional 
        Whether or not factorization should include pivoting for rank-revealing 
        qr decomposition, see the documentation of qr. 
    conjugate : bool, optional 
        Whether Q should be complex-conjugated. This might be faster 
        than explicit conjugation. 
    overwrite_a : bool, optional 
        Whether data in a is overwritten (may improve performance) 
    overwrite_c : bool, optional 
        Whether data in c is overwritten (may improve performance). 
        If this is used, c must be big enough to keep the result, 
        i.e. ``c.shape[0]`` = ``a.shape[0]`` if mode is 'left'. 
 
    Returns 
    ------- 
    CQ : ndarray 
        The product of ``Q`` and ``c``. 
    R : (K, N), ndarray 
        R array of the resulting QR factorization where ``K = min(M, N)``. 
    P : (N,) ndarray 
        Integer pivot array. Only returned when ``pivoting=True``. 
 
    Raises 
    ------ 
    LinAlgError 
        Raised if QR decomposition fails. 
 
    Notes 
    ----- 
    This is an interface to the LAPACK routines ``?GEQRF``, ``?ORMQR``, 
    ``?UNMQR``, and ``?GEQP3``. 
 
    .. versionadded:: 0.11.0 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.linalg import qr_multiply, qr 
    &gt;&gt;&gt; A = np.array([[1, 3, 3], [2, 3, 2], [2, 3, 3], [1, 3, 2]]) 
    &gt;&gt;&gt; qc, r1, piv1 = qr_multiply(A, 2*np.eye(4), pivoting=1) 
    &gt;&gt;&gt; qc 
    array([[-1.,  1., -1.], 
           [-1., -1.,  1.], 
           [-1., -1., -1.], 
           [-1.,  1.,  1.]]) 
    &gt;&gt;&gt; r1 
    array([[-6., -3., -5.            ], 
           [ 0., -1., -1.11022302e-16], 
           [ 0.,  0., -1.            ]]) 
    &gt;&gt;&gt; piv1 
    array([1, 0, 2], dtype=int32) 
    &gt;&gt;&gt; q2, r2, piv2 = qr(A, mode='economic', pivoting=1) 
    &gt;&gt;&gt; np.allclose(2*q2 - qc, np.zeros((4, 3))) 
    True 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">mode </span><span class="s2">not in </span><span class="s4">[</span><span class="s5">'left'</span><span class="s4">, </span><span class="s5">'right'</span><span class="s4">]:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;Mode argument can only be 'left' or 'right' but &quot;</span>
                         <span class="s5">f&quot;not '</span><span class="s2">{</span><span class="s1">mode</span><span class="s2">}</span><span class="s5">'&quot;</span><span class="s4">)</span>
    <span class="s1">c </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">asarray_chkfinite</span><span class="s4">(</span><span class="s1">c</span><span class="s4">)</span>
    <span class="s2">if </span><span class="s1">c</span><span class="s4">.</span><span class="s1">ndim </span><span class="s4">&lt; </span><span class="s6">2</span><span class="s4">:</span>
        <span class="s1">onedim </span><span class="s4">= </span><span class="s2">True</span>
        <span class="s1">c </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">atleast_2d</span><span class="s4">(</span><span class="s1">c</span><span class="s4">)</span>
        <span class="s2">if </span><span class="s1">mode </span><span class="s4">== </span><span class="s5">&quot;left&quot;</span><span class="s4">:</span>
            <span class="s1">c </span><span class="s4">= </span><span class="s1">c</span><span class="s4">.</span><span class="s1">T</span>
    <span class="s2">else</span><span class="s4">:</span>
        <span class="s1">onedim </span><span class="s4">= </span><span class="s2">False</span>

    <span class="s1">a </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">atleast_2d</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">(</span><span class="s1">a</span><span class="s4">))  </span><span class="s3"># chkfinite done in qr</span>
    <span class="s1">M</span><span class="s4">, </span><span class="s1">N </span><span class="s4">= </span><span class="s1">a</span><span class="s4">.</span><span class="s1">shape</span>

    <span class="s2">if </span><span class="s1">mode </span><span class="s4">== </span><span class="s5">'left'</span><span class="s4">:</span>
        <span class="s2">if </span><span class="s1">c</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">] != </span><span class="s1">min</span><span class="s4">(</span><span class="s1">M</span><span class="s4">, </span><span class="s1">N </span><span class="s4">+ </span><span class="s1">overwrite_c</span><span class="s4">*(</span><span class="s1">M</span><span class="s4">-</span><span class="s1">N</span><span class="s4">)):</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">'Array shapes are not compatible for Q @ c'</span>
                             <span class="s5">f' operation: </span><span class="s2">{</span><span class="s1">a</span><span class="s4">.</span><span class="s1">shape</span><span class="s2">} </span><span class="s5">vs </span><span class="s2">{</span><span class="s1">c</span><span class="s4">.</span><span class="s1">shape</span><span class="s2">}</span><span class="s5">'</span><span class="s4">)</span>
    <span class="s2">else</span><span class="s4">:</span>
        <span class="s2">if </span><span class="s1">M </span><span class="s4">!= </span><span class="s1">c</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">1</span><span class="s4">]:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">'Array shapes are not compatible for c @ Q'</span>
                             <span class="s5">f' operation: </span><span class="s2">{</span><span class="s1">c</span><span class="s4">.</span><span class="s1">shape</span><span class="s2">} </span><span class="s5">vs </span><span class="s2">{</span><span class="s1">a</span><span class="s4">.</span><span class="s1">shape</span><span class="s2">}</span><span class="s5">'</span><span class="s4">)</span>

    <span class="s1">raw </span><span class="s4">= </span><span class="s1">qr</span><span class="s4">(</span><span class="s1">a</span><span class="s4">, </span><span class="s1">overwrite_a</span><span class="s4">, </span><span class="s2">None</span><span class="s4">, </span><span class="s5">&quot;raw&quot;</span><span class="s4">, </span><span class="s1">pivoting</span><span class="s4">)</span>
    <span class="s1">Q</span><span class="s4">, </span><span class="s1">tau </span><span class="s4">= </span><span class="s1">raw</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]</span>

    <span class="s3"># accommodate empty arrays</span>
    <span class="s2">if </span><span class="s1">c</span><span class="s4">.</span><span class="s1">size </span><span class="s4">== </span><span class="s6">0</span><span class="s4">:</span>
        <span class="s2">return </span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">empty_like</span><span class="s4">(</span><span class="s1">c</span><span class="s4">),) + </span><span class="s1">raw</span><span class="s4">[</span><span class="s6">1</span><span class="s4">:]</span>

    <span class="s1">gor_un_mqr</span><span class="s4">, = </span><span class="s1">get_lapack_funcs</span><span class="s4">((</span><span class="s5">'ormqr'</span><span class="s4">,), (</span><span class="s1">Q</span><span class="s4">,))</span>
    <span class="s2">if </span><span class="s1">gor_un_mqr</span><span class="s4">.</span><span class="s1">typecode </span><span class="s2">in </span><span class="s4">(</span><span class="s5">'s'</span><span class="s4">, </span><span class="s5">'d'</span><span class="s4">):</span>
        <span class="s1">trans </span><span class="s4">= </span><span class="s5">&quot;T&quot;</span>
    <span class="s2">else</span><span class="s4">:</span>
        <span class="s1">trans </span><span class="s4">= </span><span class="s5">&quot;C&quot;</span>

    <span class="s1">Q </span><span class="s4">= </span><span class="s1">Q</span><span class="s4">[:, :</span><span class="s1">min</span><span class="s4">(</span><span class="s1">M</span><span class="s4">, </span><span class="s1">N</span><span class="s4">)]</span>
    <span class="s2">if </span><span class="s1">M </span><span class="s4">&gt; </span><span class="s1">N </span><span class="s2">and </span><span class="s1">mode </span><span class="s4">== </span><span class="s5">&quot;left&quot; </span><span class="s2">and not </span><span class="s1">overwrite_c</span><span class="s4">:</span>
        <span class="s2">if </span><span class="s1">conjugate</span><span class="s4">:</span>
            <span class="s1">cc </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">zeros</span><span class="s4">((</span><span class="s1">c</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">1</span><span class="s4">], </span><span class="s1">M</span><span class="s4">), </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">c</span><span class="s4">.</span><span class="s1">dtype</span><span class="s4">, </span><span class="s1">order</span><span class="s4">=</span><span class="s5">&quot;F&quot;</span><span class="s4">)</span>
            <span class="s1">cc</span><span class="s4">[:, :</span><span class="s1">N</span><span class="s4">] = </span><span class="s1">c</span><span class="s4">.</span><span class="s1">T</span>
        <span class="s2">else</span><span class="s4">:</span>
            <span class="s1">cc </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">zeros</span><span class="s4">((</span><span class="s1">M</span><span class="s4">, </span><span class="s1">c</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">1</span><span class="s4">]), </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">c</span><span class="s4">.</span><span class="s1">dtype</span><span class="s4">, </span><span class="s1">order</span><span class="s4">=</span><span class="s5">&quot;F&quot;</span><span class="s4">)</span>
            <span class="s1">cc</span><span class="s4">[:</span><span class="s1">N</span><span class="s4">, :] = </span><span class="s1">c</span>
            <span class="s1">trans </span><span class="s4">= </span><span class="s5">&quot;N&quot;</span>
        <span class="s2">if </span><span class="s1">conjugate</span><span class="s4">:</span>
            <span class="s1">lr </span><span class="s4">= </span><span class="s5">&quot;R&quot;</span>
        <span class="s2">else</span><span class="s4">:</span>
            <span class="s1">lr </span><span class="s4">= </span><span class="s5">&quot;L&quot;</span>
        <span class="s1">overwrite_c </span><span class="s4">= </span><span class="s2">True</span>
    <span class="s2">elif </span><span class="s1">c</span><span class="s4">.</span><span class="s1">flags</span><span class="s4">[</span><span class="s5">&quot;C_CONTIGUOUS&quot;</span><span class="s4">] </span><span class="s2">and </span><span class="s1">trans </span><span class="s4">== </span><span class="s5">&quot;T&quot; </span><span class="s2">or </span><span class="s1">conjugate</span><span class="s4">:</span>
        <span class="s1">cc </span><span class="s4">= </span><span class="s1">c</span><span class="s4">.</span><span class="s1">T</span>
        <span class="s2">if </span><span class="s1">mode </span><span class="s4">== </span><span class="s5">&quot;left&quot;</span><span class="s4">:</span>
            <span class="s1">lr </span><span class="s4">= </span><span class="s5">&quot;R&quot;</span>
        <span class="s2">else</span><span class="s4">:</span>
            <span class="s1">lr </span><span class="s4">= </span><span class="s5">&quot;L&quot;</span>
    <span class="s2">else</span><span class="s4">:</span>
        <span class="s1">trans </span><span class="s4">= </span><span class="s5">&quot;N&quot;</span>
        <span class="s1">cc </span><span class="s4">= </span><span class="s1">c</span>
        <span class="s2">if </span><span class="s1">mode </span><span class="s4">== </span><span class="s5">&quot;left&quot;</span><span class="s4">:</span>
            <span class="s1">lr </span><span class="s4">= </span><span class="s5">&quot;L&quot;</span>
        <span class="s2">else</span><span class="s4">:</span>
            <span class="s1">lr </span><span class="s4">= </span><span class="s5">&quot;R&quot;</span>
    <span class="s1">cQ</span><span class="s4">, = </span><span class="s1">safecall</span><span class="s4">(</span><span class="s1">gor_un_mqr</span><span class="s4">, </span><span class="s5">&quot;gormqr/gunmqr&quot;</span><span class="s4">, </span><span class="s1">lr</span><span class="s4">, </span><span class="s1">trans</span><span class="s4">, </span><span class="s1">Q</span><span class="s4">, </span><span class="s1">tau</span><span class="s4">, </span><span class="s1">cc</span><span class="s4">,</span>
                   <span class="s1">overwrite_c</span><span class="s4">=</span><span class="s1">overwrite_c</span><span class="s4">)</span>
    <span class="s2">if </span><span class="s1">trans </span><span class="s4">!= </span><span class="s5">&quot;N&quot;</span><span class="s4">:</span>
        <span class="s1">cQ </span><span class="s4">= </span><span class="s1">cQ</span><span class="s4">.</span><span class="s1">T</span>
    <span class="s2">if </span><span class="s1">mode </span><span class="s4">== </span><span class="s5">&quot;right&quot;</span><span class="s4">:</span>
        <span class="s1">cQ </span><span class="s4">= </span><span class="s1">cQ</span><span class="s4">[:, :</span><span class="s1">min</span><span class="s4">(</span><span class="s1">M</span><span class="s4">, </span><span class="s1">N</span><span class="s4">)]</span>
    <span class="s2">if </span><span class="s1">onedim</span><span class="s4">:</span>
        <span class="s1">cQ </span><span class="s4">= </span><span class="s1">cQ</span><span class="s4">.</span><span class="s1">ravel</span><span class="s4">()</span>

    <span class="s2">return </span><span class="s4">(</span><span class="s1">cQ</span><span class="s4">,) + </span><span class="s1">raw</span><span class="s4">[</span><span class="s6">1</span><span class="s4">:]</span>


<span class="s2">def </span><span class="s1">rq</span><span class="s4">(</span><span class="s1">a</span><span class="s4">, </span><span class="s1">overwrite_a</span><span class="s4">=</span><span class="s2">False</span><span class="s4">, </span><span class="s1">lwork</span><span class="s4">=</span><span class="s2">None</span><span class="s4">, </span><span class="s1">mode</span><span class="s4">=</span><span class="s5">'full'</span><span class="s4">, </span><span class="s1">check_finite</span><span class="s4">=</span><span class="s2">True</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Compute RQ decomposition of a matrix. 
 
    Calculate the decomposition ``A = R Q`` where Q is unitary/orthogonal 
    and R upper triangular. 
 
    Parameters 
    ---------- 
    a : (M, N) array_like 
        Matrix to be decomposed 
    overwrite_a : bool, optional 
        Whether data in a is overwritten (may improve performance) 
    lwork : int, optional 
        Work array size, lwork &gt;= a.shape[1]. If None or -1, an optimal size 
        is computed. 
    mode : {'full', 'r', 'economic'}, optional 
        Determines what information is to be returned: either both Q and R 
        ('full', default), only R ('r') or both Q and R but computed in 
        economy-size ('economic', see Notes). 
    check_finite : bool, optional 
        Whether to check that the input matrix contains only finite numbers. 
        Disabling may give a performance gain, but may result in problems 
        (crashes, non-termination) if the inputs do contain infinities or NaNs. 
 
    Returns 
    ------- 
    R : float or complex ndarray 
        Of shape (M, N) or (M, K) for ``mode='economic'``. ``K = min(M, N)``. 
    Q : float or complex ndarray 
        Of shape (N, N) or (K, N) for ``mode='economic'``. Not returned 
        if ``mode='r'``. 
 
    Raises 
    ------ 
    LinAlgError 
        If decomposition fails. 
 
    Notes 
    ----- 
    This is an interface to the LAPACK routines sgerqf, dgerqf, cgerqf, zgerqf, 
    sorgrq, dorgrq, cungrq and zungrq. 
 
    If ``mode=economic``, the shapes of Q and R are (K, N) and (M, K) instead 
    of (N,N) and (M,N), with ``K=min(M,N)``. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import linalg 
    &gt;&gt;&gt; rng = np.random.default_rng() 
    &gt;&gt;&gt; a = rng.standard_normal((6, 9)) 
    &gt;&gt;&gt; r, q = linalg.rq(a) 
    &gt;&gt;&gt; np.allclose(a, r @ q) 
    True 
    &gt;&gt;&gt; r.shape, q.shape 
    ((6, 9), (9, 9)) 
    &gt;&gt;&gt; r2 = linalg.rq(a, mode='r') 
    &gt;&gt;&gt; np.allclose(r, r2) 
    True 
    &gt;&gt;&gt; r3, q3 = linalg.rq(a, mode='economic') 
    &gt;&gt;&gt; r3.shape, q3.shape 
    ((6, 6), (6, 9)) 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">mode </span><span class="s2">not in </span><span class="s4">[</span><span class="s5">'full'</span><span class="s4">, </span><span class="s5">'r'</span><span class="s4">, </span><span class="s5">'economic'</span><span class="s4">]:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s4">(</span>
                 <span class="s5">&quot;Mode argument should be one of ['full', 'r', 'economic']&quot;</span><span class="s4">)</span>

    <span class="s2">if </span><span class="s1">check_finite</span><span class="s4">:</span>
        <span class="s1">a1 </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">asarray_chkfinite</span><span class="s4">(</span><span class="s1">a</span><span class="s4">)</span>
    <span class="s2">else</span><span class="s4">:</span>
        <span class="s1">a1 </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">(</span><span class="s1">a</span><span class="s4">)</span>
    <span class="s2">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">a1</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">) != </span><span class="s6">2</span><span class="s4">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">'expected matrix'</span><span class="s4">)</span>

    <span class="s1">M</span><span class="s4">, </span><span class="s1">N </span><span class="s4">= </span><span class="s1">a1</span><span class="s4">.</span><span class="s1">shape</span>

    <span class="s3"># accommodate empty arrays</span>
    <span class="s2">if </span><span class="s1">a1</span><span class="s4">.</span><span class="s1">size </span><span class="s4">== </span><span class="s6">0</span><span class="s4">:</span>
        <span class="s1">K </span><span class="s4">= </span><span class="s1">min</span><span class="s4">(</span><span class="s1">M</span><span class="s4">, </span><span class="s1">N</span><span class="s4">)</span>

        <span class="s2">if not </span><span class="s1">mode </span><span class="s4">== </span><span class="s5">'economic'</span><span class="s4">:</span>
            <span class="s1">R </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">empty_like</span><span class="s4">(</span><span class="s1">a1</span><span class="s4">)</span>
            <span class="s1">Q </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">empty_like</span><span class="s4">(</span><span class="s1">a1</span><span class="s4">, </span><span class="s1">shape</span><span class="s4">=(</span><span class="s1">N</span><span class="s4">, </span><span class="s1">N</span><span class="s4">))</span>
            <span class="s1">Q</span><span class="s4">[...] = </span><span class="s1">np</span><span class="s4">.</span><span class="s1">identity</span><span class="s4">(</span><span class="s1">N</span><span class="s4">)</span>
        <span class="s2">else</span><span class="s4">:</span>
            <span class="s1">R </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">empty_like</span><span class="s4">(</span><span class="s1">a1</span><span class="s4">, </span><span class="s1">shape</span><span class="s4">=(</span><span class="s1">M</span><span class="s4">, </span><span class="s1">K</span><span class="s4">))</span>
            <span class="s1">Q </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">empty_like</span><span class="s4">(</span><span class="s1">a1</span><span class="s4">, </span><span class="s1">shape</span><span class="s4">=(</span><span class="s1">K</span><span class="s4">, </span><span class="s1">N</span><span class="s4">))</span>

        <span class="s2">if </span><span class="s1">mode </span><span class="s4">== </span><span class="s5">'r'</span><span class="s4">:</span>
            <span class="s2">return </span><span class="s1">R</span>
        <span class="s2">return </span><span class="s1">R</span><span class="s4">, </span><span class="s1">Q</span>

    <span class="s1">overwrite_a </span><span class="s4">= </span><span class="s1">overwrite_a </span><span class="s2">or </span><span class="s4">(</span><span class="s1">_datacopied</span><span class="s4">(</span><span class="s1">a1</span><span class="s4">, </span><span class="s1">a</span><span class="s4">))</span>

    <span class="s1">gerqf</span><span class="s4">, = </span><span class="s1">get_lapack_funcs</span><span class="s4">((</span><span class="s5">'gerqf'</span><span class="s4">,), (</span><span class="s1">a1</span><span class="s4">,))</span>
    <span class="s1">rq</span><span class="s4">, </span><span class="s1">tau </span><span class="s4">= </span><span class="s1">safecall</span><span class="s4">(</span><span class="s1">gerqf</span><span class="s4">, </span><span class="s5">'gerqf'</span><span class="s4">, </span><span class="s1">a1</span><span class="s4">, </span><span class="s1">lwork</span><span class="s4">=</span><span class="s1">lwork</span><span class="s4">,</span>
                       <span class="s1">overwrite_a</span><span class="s4">=</span><span class="s1">overwrite_a</span><span class="s4">)</span>
    <span class="s2">if not </span><span class="s1">mode </span><span class="s4">== </span><span class="s5">'economic' </span><span class="s2">or </span><span class="s1">N </span><span class="s4">&lt; </span><span class="s1">M</span><span class="s4">:</span>
        <span class="s1">R </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">triu</span><span class="s4">(</span><span class="s1">rq</span><span class="s4">, </span><span class="s1">N</span><span class="s4">-</span><span class="s1">M</span><span class="s4">)</span>
    <span class="s2">else</span><span class="s4">:</span>
        <span class="s1">R </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">triu</span><span class="s4">(</span><span class="s1">rq</span><span class="s4">[-</span><span class="s1">M</span><span class="s4">:, -</span><span class="s1">M</span><span class="s4">:])</span>

    <span class="s2">if </span><span class="s1">mode </span><span class="s4">== </span><span class="s5">'r'</span><span class="s4">:</span>
        <span class="s2">return </span><span class="s1">R</span>

    <span class="s1">gor_un_grq</span><span class="s4">, = </span><span class="s1">get_lapack_funcs</span><span class="s4">((</span><span class="s5">'orgrq'</span><span class="s4">,), (</span><span class="s1">rq</span><span class="s4">,))</span>

    <span class="s2">if </span><span class="s1">N </span><span class="s4">&lt; </span><span class="s1">M</span><span class="s4">:</span>
        <span class="s1">Q</span><span class="s4">, = </span><span class="s1">safecall</span><span class="s4">(</span><span class="s1">gor_un_grq</span><span class="s4">, </span><span class="s5">&quot;gorgrq/gungrq&quot;</span><span class="s4">, </span><span class="s1">rq</span><span class="s4">[-</span><span class="s1">N</span><span class="s4">:], </span><span class="s1">tau</span><span class="s4">, </span><span class="s1">lwork</span><span class="s4">=</span><span class="s1">lwork</span><span class="s4">,</span>
                      <span class="s1">overwrite_a</span><span class="s4">=</span><span class="s6">1</span><span class="s4">)</span>
    <span class="s2">elif </span><span class="s1">mode </span><span class="s4">== </span><span class="s5">'economic'</span><span class="s4">:</span>
        <span class="s1">Q</span><span class="s4">, = </span><span class="s1">safecall</span><span class="s4">(</span><span class="s1">gor_un_grq</span><span class="s4">, </span><span class="s5">&quot;gorgrq/gungrq&quot;</span><span class="s4">, </span><span class="s1">rq</span><span class="s4">, </span><span class="s1">tau</span><span class="s4">, </span><span class="s1">lwork</span><span class="s4">=</span><span class="s1">lwork</span><span class="s4">,</span>
                      <span class="s1">overwrite_a</span><span class="s4">=</span><span class="s6">1</span><span class="s4">)</span>
    <span class="s2">else</span><span class="s4">:</span>
        <span class="s1">rq1 </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">empty</span><span class="s4">((</span><span class="s1">N</span><span class="s4">, </span><span class="s1">N</span><span class="s4">), </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">rq</span><span class="s4">.</span><span class="s1">dtype</span><span class="s4">)</span>
        <span class="s1">rq1</span><span class="s4">[-</span><span class="s1">M</span><span class="s4">:] = </span><span class="s1">rq</span>
        <span class="s1">Q</span><span class="s4">, = </span><span class="s1">safecall</span><span class="s4">(</span><span class="s1">gor_un_grq</span><span class="s4">, </span><span class="s5">&quot;gorgrq/gungrq&quot;</span><span class="s4">, </span><span class="s1">rq1</span><span class="s4">, </span><span class="s1">tau</span><span class="s4">, </span><span class="s1">lwork</span><span class="s4">=</span><span class="s1">lwork</span><span class="s4">,</span>
                      <span class="s1">overwrite_a</span><span class="s4">=</span><span class="s6">1</span><span class="s4">)</span>

    <span class="s2">return </span><span class="s1">R</span><span class="s4">, </span><span class="s1">Q</span>
</pre>
</body>
</html>