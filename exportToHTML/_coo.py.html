<html>
<head>
<title>_coo.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #6aab73;}
.s4 { color: #cf8e6d;}
.s5 { color: #2aacb8;}
.s6 { color: #7a7e85;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_coo.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; A sparse matrix in COOrdinate or 'triplet' format&quot;&quot;&quot;</span>

<span class="s1">__docformat__ </span><span class="s2">= </span><span class="s3">&quot;restructuredtext en&quot;</span>

<span class="s1">__all__ </span><span class="s2">= [</span><span class="s3">'coo_array'</span><span class="s2">, </span><span class="s3">'coo_matrix'</span><span class="s2">, </span><span class="s3">'isspmatrix_coo'</span><span class="s2">]</span>

<span class="s4">import </span><span class="s1">math</span>
<span class="s4">from </span><span class="s1">warnings </span><span class="s4">import </span><span class="s1">warn</span>

<span class="s4">import </span><span class="s1">numpy </span><span class="s4">as </span><span class="s1">np</span>

<span class="s4">from </span><span class="s2">..</span><span class="s1">_lib</span><span class="s2">.</span><span class="s1">_util </span><span class="s4">import </span><span class="s1">copy_if_needed</span>
<span class="s4">from </span><span class="s2">.</span><span class="s1">_matrix </span><span class="s4">import </span><span class="s1">spmatrix</span>
<span class="s4">from </span><span class="s2">.</span><span class="s1">_sparsetools </span><span class="s4">import </span><span class="s1">coo_tocsr</span><span class="s2">, </span><span class="s1">coo_todense</span><span class="s2">, </span><span class="s1">coo_matvec</span>
<span class="s4">from </span><span class="s2">.</span><span class="s1">_base </span><span class="s4">import </span><span class="s1">issparse</span><span class="s2">, </span><span class="s1">SparseEfficiencyWarning</span><span class="s2">, </span><span class="s1">_spbase</span><span class="s2">, </span><span class="s1">sparray</span>
<span class="s4">from </span><span class="s2">.</span><span class="s1">_data </span><span class="s4">import </span><span class="s1">_data_matrix</span><span class="s2">, </span><span class="s1">_minmax_mixin</span>
<span class="s4">from </span><span class="s2">.</span><span class="s1">_sputils </span><span class="s4">import </span><span class="s2">(</span><span class="s1">upcast_char</span><span class="s2">, </span><span class="s1">to_native</span><span class="s2">, </span><span class="s1">isshape</span><span class="s2">, </span><span class="s1">getdtype</span><span class="s2">,</span>
                       <span class="s1">getdata</span><span class="s2">, </span><span class="s1">downcast_intp_index</span><span class="s2">, </span><span class="s1">get_index_dtype</span><span class="s2">,</span>
                       <span class="s1">check_shape</span><span class="s2">, </span><span class="s1">check_reshape_kwargs</span><span class="s2">)</span>

<span class="s4">import </span><span class="s1">operator</span>


<span class="s4">class </span><span class="s1">_coo_base</span><span class="s2">(</span><span class="s1">_data_matrix</span><span class="s2">, </span><span class="s1">_minmax_mixin</span><span class="s2">):</span>
    <span class="s1">_format </span><span class="s2">= </span><span class="s3">'coo'</span>

    <span class="s4">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">arg1</span><span class="s2">, </span><span class="s1">shape</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s4">False</span><span class="s2">):</span>
        <span class="s1">_data_matrix</span><span class="s2">.</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">arg1</span><span class="s2">)</span>
        <span class="s1">is_array </span><span class="s2">= </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">sparray</span><span class="s2">)</span>
        <span class="s4">if not </span><span class="s1">copy</span><span class="s2">:</span>
            <span class="s1">copy </span><span class="s2">= </span><span class="s1">copy_if_needed</span>

        <span class="s4">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">arg1</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">):</span>
            <span class="s4">if </span><span class="s1">isshape</span><span class="s2">(</span><span class="s1">arg1</span><span class="s2">, </span><span class="s1">allow_1d</span><span class="s2">=</span><span class="s1">is_array</span><span class="s2">):</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">_shape </span><span class="s2">= </span><span class="s1">check_shape</span><span class="s2">(</span><span class="s1">arg1</span><span class="s2">, </span><span class="s1">allow_1d</span><span class="s2">=</span><span class="s1">is_array</span><span class="s2">)</span>
                <span class="s1">idx_dtype </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_get_index_dtype</span><span class="s2">(</span><span class="s1">maxval</span><span class="s2">=</span><span class="s1">max</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_shape</span><span class="s2">))</span>
                <span class="s1">data_dtype </span><span class="s2">= </span><span class="s1">getdtype</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">default</span><span class="s2">=</span><span class="s1">float</span><span class="s2">)</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">coords </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">idx_dtype</span><span class="s2">)</span>
                                     <span class="s4">for </span><span class="s1">_ </span><span class="s4">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_shape</span><span class="s2">)))</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">data </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">data_dtype</span><span class="s2">)</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">has_canonical_format </span><span class="s2">= </span><span class="s4">True</span>
            <span class="s4">else</span><span class="s2">:</span>
                <span class="s4">try</span><span class="s2">:</span>
                    <span class="s1">obj</span><span class="s2">, </span><span class="s1">coords </span><span class="s2">= </span><span class="s1">arg1</span>
                <span class="s4">except </span><span class="s2">(</span><span class="s1">TypeError</span><span class="s2">, </span><span class="s1">ValueError</span><span class="s2">) </span><span class="s4">as </span><span class="s1">e</span><span class="s2">:</span>
                    <span class="s4">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s3">'invalid input format'</span><span class="s2">) </span><span class="s4">from </span><span class="s1">e</span>

                <span class="s4">if </span><span class="s1">shape </span><span class="s4">is None</span><span class="s2">:</span>
                    <span class="s4">if </span><span class="s1">any</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">idx</span><span class="s2">) == </span><span class="s5">0 </span><span class="s4">for </span><span class="s1">idx </span><span class="s4">in </span><span class="s1">coords</span><span class="s2">):</span>
                        <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">'cannot infer dimensions from zero '</span>
                                         <span class="s3">'sized index arrays'</span><span class="s2">)</span>
                    <span class="s1">shape </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">operator</span><span class="s2">.</span><span class="s1">index</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">max</span><span class="s2">(</span><span class="s1">idx</span><span class="s2">)) + </span><span class="s5">1</span>
                                  <span class="s4">for </span><span class="s1">idx </span><span class="s4">in </span><span class="s1">coords</span><span class="s2">)</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">_shape </span><span class="s2">= </span><span class="s1">check_shape</span><span class="s2">(</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">allow_1d</span><span class="s2">=</span><span class="s1">is_array</span><span class="s2">)</span>

                <span class="s1">idx_dtype </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_get_index_dtype</span><span class="s2">(</span><span class="s1">coords</span><span class="s2">,</span>
                                                  <span class="s1">maxval</span><span class="s2">=</span><span class="s1">max</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">),</span>
                                                  <span class="s1">check_contents</span><span class="s2">=</span><span class="s4">True</span><span class="s2">)</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">coords </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">(</span><span class="s1">idx</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s1">copy</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">idx_dtype</span><span class="s2">)</span>
                                     <span class="s4">for </span><span class="s1">idx </span><span class="s4">in </span><span class="s1">coords</span><span class="s2">)</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">data </span><span class="s2">= </span><span class="s1">getdata</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s1">copy</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">)</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">has_canonical_format </span><span class="s2">= </span><span class="s4">False</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s4">if </span><span class="s1">issparse</span><span class="s2">(</span><span class="s1">arg1</span><span class="s2">):</span>
                <span class="s4">if </span><span class="s1">arg1</span><span class="s2">.</span><span class="s1">format </span><span class="s2">== </span><span class="s1">self</span><span class="s2">.</span><span class="s1">format </span><span class="s4">and </span><span class="s1">copy</span><span class="s2">:</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">coords </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">idx</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">() </span><span class="s4">for </span><span class="s1">idx </span><span class="s4">in </span><span class="s1">arg1</span><span class="s2">.</span><span class="s1">coords</span><span class="s2">)</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">data </span><span class="s2">= </span><span class="s1">arg1</span><span class="s2">.</span><span class="s1">data</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">_shape </span><span class="s2">= </span><span class="s1">check_shape</span><span class="s2">(</span><span class="s1">arg1</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">allow_1d</span><span class="s2">=</span><span class="s1">is_array</span><span class="s2">)</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">has_canonical_format </span><span class="s2">= </span><span class="s1">arg1</span><span class="s2">.</span><span class="s1">has_canonical_format</span>
                <span class="s4">else</span><span class="s2">:</span>
                    <span class="s1">coo </span><span class="s2">= </span><span class="s1">arg1</span><span class="s2">.</span><span class="s1">tocoo</span><span class="s2">()</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">coords </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">coo</span><span class="s2">.</span><span class="s1">coords</span><span class="s2">)</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">data </span><span class="s2">= </span><span class="s1">coo</span><span class="s2">.</span><span class="s1">data</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">_shape </span><span class="s2">= </span><span class="s1">check_shape</span><span class="s2">(</span><span class="s1">coo</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">allow_1d</span><span class="s2">=</span><span class="s1">is_array</span><span class="s2">)</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">has_canonical_format </span><span class="s2">= </span><span class="s4">False</span>
            <span class="s4">else</span><span class="s2">:</span>
                <span class="s6"># dense argument</span>
                <span class="s1">M </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">arg1</span><span class="s2">)</span>
                <span class="s4">if not </span><span class="s1">is_array</span><span class="s2">:</span>
                    <span class="s1">M </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">atleast_2d</span><span class="s2">(</span><span class="s1">M</span><span class="s2">)</span>
                    <span class="s4">if </span><span class="s1">M</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">!= </span><span class="s5">2</span><span class="s2">:</span>
                        <span class="s4">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s3">f'expected 2D array or matrix, not </span><span class="s4">{</span><span class="s1">M</span><span class="s2">.</span><span class="s1">ndim</span><span class="s4">}</span><span class="s3">D'</span><span class="s2">)</span>

                <span class="s1">self</span><span class="s2">.</span><span class="s1">_shape </span><span class="s2">= </span><span class="s1">check_shape</span><span class="s2">(</span><span class="s1">M</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">allow_1d</span><span class="s2">=</span><span class="s1">is_array</span><span class="s2">)</span>
                <span class="s4">if </span><span class="s1">shape </span><span class="s4">is not None</span><span class="s2">:</span>
                    <span class="s4">if </span><span class="s1">check_shape</span><span class="s2">(</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">allow_1d</span><span class="s2">=</span><span class="s1">is_array</span><span class="s2">) != </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_shape</span><span class="s2">:</span>
                        <span class="s1">message </span><span class="s2">= </span><span class="s3">f'inconsistent shapes: </span><span class="s4">{</span><span class="s1">shape</span><span class="s4">} </span><span class="s3">!= </span><span class="s4">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_shape</span><span class="s4">}</span><span class="s3">'</span>
                        <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s1">message</span><span class="s2">)</span>
                <span class="s1">index_dtype </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_get_index_dtype</span><span class="s2">(</span><span class="s1">maxval</span><span class="s2">=</span><span class="s1">max</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_shape</span><span class="s2">))</span>
                <span class="s1">coords </span><span class="s2">= </span><span class="s1">M</span><span class="s2">.</span><span class="s1">nonzero</span><span class="s2">()</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">coords </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">idx</span><span class="s2">.</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">index_dtype</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s4">False</span><span class="s2">)</span>
                                     <span class="s4">for </span><span class="s1">idx </span><span class="s4">in </span><span class="s1">coords</span><span class="s2">)</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">data </span><span class="s2">= </span><span class="s1">M</span><span class="s2">[</span><span class="s1">coords</span><span class="s2">]</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">has_canonical_format </span><span class="s2">= </span><span class="s4">True</span>

        <span class="s4">if </span><span class="s1">dtype </span><span class="s4">is not None</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">data </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">.</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s4">False</span><span class="s2">)</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">_check</span><span class="s2">()</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s4">def </span><span class="s1">row</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s4">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">&gt; </span><span class="s5">1</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">coords</span><span class="s2">[-</span><span class="s5">2</span><span class="s2">]</span>
        <span class="s1">result </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros_like</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">col</span><span class="s2">)</span>
        <span class="s1">result</span><span class="s2">.</span><span class="s1">setflags</span><span class="s2">(</span><span class="s1">write</span><span class="s2">=</span><span class="s4">False</span><span class="s2">)</span>
        <span class="s4">return </span><span class="s1">result</span>


    <span class="s2">@</span><span class="s1">row</span><span class="s2">.</span><span class="s1">setter</span>
    <span class="s4">def </span><span class="s1">row</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">new_row</span><span class="s2">):</span>
        <span class="s4">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">&lt; </span><span class="s5">2</span><span class="s2">:</span>
            <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">'cannot set row attribute of a 1-dimensional sparse array'</span><span class="s2">)</span>
        <span class="s1">new_row </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">new_row</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">coords</span><span class="s2">[-</span><span class="s5">2</span><span class="s2">].</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">coords </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">coords</span><span class="s2">[:-</span><span class="s5">2</span><span class="s2">] + (</span><span class="s1">new_row</span><span class="s2">,) + </span><span class="s1">self</span><span class="s2">.</span><span class="s1">coords</span><span class="s2">[-</span><span class="s5">1</span><span class="s2">:]</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s4">def </span><span class="s1">col</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">coords</span><span class="s2">[-</span><span class="s5">1</span><span class="s2">]</span>

    <span class="s2">@</span><span class="s1">col</span><span class="s2">.</span><span class="s1">setter</span>
    <span class="s4">def </span><span class="s1">col</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">new_col</span><span class="s2">):</span>
        <span class="s1">new_col </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">new_col</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">coords</span><span class="s2">[-</span><span class="s5">1</span><span class="s2">].</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">coords </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">coords</span><span class="s2">[:-</span><span class="s5">1</span><span class="s2">] + (</span><span class="s1">new_col</span><span class="s2">,)</span>

    <span class="s4">def </span><span class="s1">reshape</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
        <span class="s1">is_array </span><span class="s2">= </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">sparray</span><span class="s2">)</span>
        <span class="s1">shape </span><span class="s2">= </span><span class="s1">check_shape</span><span class="s2">(</span><span class="s1">args</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">allow_1d</span><span class="s2">=</span><span class="s1">is_array</span><span class="s2">)</span>
        <span class="s1">order</span><span class="s2">, </span><span class="s1">copy </span><span class="s2">= </span><span class="s1">check_reshape_kwargs</span><span class="s2">(</span><span class="s1">kwargs</span><span class="s2">)</span>

        <span class="s6"># Return early if reshape is not required</span>
        <span class="s4">if </span><span class="s1">shape </span><span class="s2">== </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">:</span>
            <span class="s4">if </span><span class="s1">copy</span><span class="s2">:</span>
                <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>
            <span class="s4">else</span><span class="s2">:</span>
                <span class="s4">return </span><span class="s1">self</span>

        <span class="s6"># When reducing the number of dimensions, we need to be careful about</span>
        <span class="s6"># index overflow. This is why we can't simply call</span>
        <span class="s6"># `np.ravel_multi_index()` followed by `np.unravel_index()` here.</span>
        <span class="s1">flat_coords </span><span class="s2">= </span><span class="s1">_ravel_coords</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">coords</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">order</span><span class="s2">=</span><span class="s1">order</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">shape</span><span class="s2">) == </span><span class="s5">2</span><span class="s2">:</span>
            <span class="s4">if </span><span class="s1">order </span><span class="s2">== </span><span class="s3">'C'</span><span class="s2">:</span>
                <span class="s1">new_coords </span><span class="s2">= </span><span class="s1">divmod</span><span class="s2">(</span><span class="s1">flat_coords</span><span class="s2">, </span><span class="s1">shape</span><span class="s2">[</span><span class="s5">1</span><span class="s2">])</span>
            <span class="s4">else</span><span class="s2">:</span>
                <span class="s1">new_coords </span><span class="s2">= </span><span class="s1">divmod</span><span class="s2">(</span><span class="s1">flat_coords</span><span class="s2">, </span><span class="s1">shape</span><span class="s2">[</span><span class="s5">0</span><span class="s2">])[::-</span><span class="s5">1</span><span class="s2">]</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">new_coords </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">unravel_index</span><span class="s2">(</span><span class="s1">flat_coords</span><span class="s2">, </span><span class="s1">shape</span><span class="s2">, </span><span class="s1">order</span><span class="s2">=</span><span class="s1">order</span><span class="s2">)</span>

        <span class="s6"># Handle copy here rather than passing on to the constructor so that no</span>
        <span class="s6"># copy will be made of `new_coords` regardless.</span>
        <span class="s4">if </span><span class="s1">copy</span><span class="s2">:</span>
            <span class="s1">new_data </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">new_data </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span>

        <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__class__</span><span class="s2">((</span><span class="s1">new_data</span><span class="s2">, </span><span class="s1">new_coords</span><span class="s2">), </span><span class="s1">shape</span><span class="s2">=</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s4">False</span><span class="s2">)</span>

    <span class="s1">reshape</span><span class="s2">.</span><span class="s1">__doc__ </span><span class="s2">= </span><span class="s1">_spbase</span><span class="s2">.</span><span class="s1">reshape</span><span class="s2">.</span><span class="s1">__doc__</span>

    <span class="s4">def </span><span class="s1">_getnnz</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s4">None</span><span class="s2">):</span>
        <span class="s4">if </span><span class="s1">axis </span><span class="s4">is None or </span><span class="s2">(</span><span class="s1">axis </span><span class="s2">== </span><span class="s5">0 </span><span class="s4">and </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s5">1</span><span class="s2">):</span>
            <span class="s1">nnz </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">)</span>
            <span class="s4">if </span><span class="s1">any</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">idx</span><span class="s2">) != </span><span class="s1">nnz </span><span class="s4">for </span><span class="s1">idx </span><span class="s4">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">coords</span><span class="s2">):</span>
                <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">'all index and data arrays must have the '</span>
                                 <span class="s3">'same length'</span><span class="s2">)</span>

            <span class="s4">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">!= </span><span class="s5">1 </span><span class="s4">or </span><span class="s1">any</span><span class="s2">(</span><span class="s1">idx</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">!= </span><span class="s5">1 </span><span class="s4">for </span><span class="s1">idx </span><span class="s4">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">coords</span><span class="s2">):</span>
                <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">'row, column, and data arrays must be 1-D'</span><span class="s2">)</span>

            <span class="s4">return </span><span class="s1">int</span><span class="s2">(</span><span class="s1">nnz</span><span class="s2">)</span>

        <span class="s4">if </span><span class="s1">axis </span><span class="s2">&lt; </span><span class="s5">0</span><span class="s2">:</span>
            <span class="s1">axis </span><span class="s2">+= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim</span>
        <span class="s4">if </span><span class="s1">axis </span><span class="s2">&gt;= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">:</span>
            <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">'axis out of bounds'</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">&gt; </span><span class="s5">2</span><span class="s2">:</span>
            <span class="s4">raise </span><span class="s1">NotImplementedError</span><span class="s2">(</span><span class="s3">'per-axis nnz for COO arrays with &gt;2 '</span>
                                      <span class="s3">'dimensions is not supported'</span><span class="s2">)</span>
        <span class="s4">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">bincount</span><span class="s2">(</span><span class="s1">downcast_intp_index</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">coords</span><span class="s2">[</span><span class="s5">1 </span><span class="s2">- </span><span class="s1">axis</span><span class="s2">]),</span>
                           <span class="s1">minlength</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">1 </span><span class="s2">- </span><span class="s1">axis</span><span class="s2">])</span>

    <span class="s1">_getnnz</span><span class="s2">.</span><span class="s1">__doc__ </span><span class="s2">= </span><span class="s1">_spbase</span><span class="s2">.</span><span class="s1">_getnnz</span><span class="s2">.</span><span class="s1">__doc__</span>

    <span class="s4">def </span><span class="s1">_check</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot; Checks data structure for consistency &quot;&quot;&quot;</span>
        <span class="s4">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">!= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">coords</span><span class="s2">):</span>
            <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">'mismatching number of index arrays for shape; '</span>
                             <span class="s3">f'got </span><span class="s4">{</span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">coords</span><span class="s2">)</span><span class="s4">}</span><span class="s3">, expected </span><span class="s4">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim</span><span class="s4">}</span><span class="s3">'</span><span class="s2">)</span>

        <span class="s6"># index arrays should have integer data types</span>
        <span class="s4">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">idx </span><span class="s4">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">coords</span><span class="s2">):</span>
            <span class="s4">if </span><span class="s1">idx</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">kind </span><span class="s2">!= </span><span class="s3">'i'</span><span class="s2">:</span>
                <span class="s1">warn</span><span class="s2">(</span><span class="s3">f'index array </span><span class="s4">{</span><span class="s1">i</span><span class="s4">} </span><span class="s3">has non-integer dtype (</span><span class="s4">{</span><span class="s1">idx</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">name</span><span class="s4">}</span><span class="s3">)'</span><span class="s2">,</span>
                     <span class="s1">stacklevel</span><span class="s2">=</span><span class="s5">3</span><span class="s2">)</span>

        <span class="s1">idx_dtype </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_get_index_dtype</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">coords</span><span class="s2">, </span><span class="s1">maxval</span><span class="s2">=</span><span class="s1">max</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">))</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">coords </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">idx</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">idx_dtype</span><span class="s2">)</span>
                             <span class="s4">for </span><span class="s1">idx </span><span class="s4">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">coords</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">data </span><span class="s2">= </span><span class="s1">to_native</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">)</span>

        <span class="s4">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">nnz </span><span class="s2">&gt; </span><span class="s5">0</span><span class="s2">:</span>
            <span class="s4">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">idx </span><span class="s4">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">coords</span><span class="s2">):</span>
                <span class="s4">if </span><span class="s1">idx</span><span class="s2">.</span><span class="s1">max</span><span class="s2">() &gt;= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s1">i</span><span class="s2">]:</span>
                    <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">f'axis </span><span class="s4">{</span><span class="s1">i</span><span class="s4">} </span><span class="s3">index </span><span class="s4">{</span><span class="s1">idx</span><span class="s2">.</span><span class="s1">max</span><span class="s2">()</span><span class="s4">} </span><span class="s3">exceeds '</span>
                                     <span class="s3">f'matrix dimension </span><span class="s4">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s1">i</span><span class="s2">]</span><span class="s4">}</span><span class="s3">'</span><span class="s2">)</span>
                <span class="s4">if </span><span class="s1">idx</span><span class="s2">.</span><span class="s1">min</span><span class="s2">() &lt; </span><span class="s5">0</span><span class="s2">:</span>
                    <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">f'negative axis </span><span class="s4">{</span><span class="s1">i</span><span class="s4">} </span><span class="s3">index: </span><span class="s4">{</span><span class="s1">idx</span><span class="s2">.</span><span class="s1">min</span><span class="s2">()</span><span class="s4">}</span><span class="s3">'</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">transpose</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">axes</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s4">False</span><span class="s2">):</span>
        <span class="s4">if </span><span class="s1">axes </span><span class="s4">is None</span><span class="s2">:</span>
            <span class="s1">axes </span><span class="s2">= </span><span class="s1">range</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">)[::-</span><span class="s5">1</span><span class="s2">]</span>
        <span class="s4">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">sparray</span><span class="s2">):</span>
            <span class="s4">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">axes</span><span class="s2">) != </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">:</span>
                <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;axes don't match matrix dimensions&quot;</span><span class="s2">)</span>
            <span class="s4">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">set</span><span class="s2">(</span><span class="s1">axes</span><span class="s2">)) != </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">:</span>
                <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;repeated axis in transpose&quot;</span><span class="s2">)</span>
        <span class="s4">elif </span><span class="s1">axes </span><span class="s2">!= (</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">):</span>
            <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;Sparse matrices do not support an 'axes' &quot;</span>
                             <span class="s3">&quot;parameter because swapping dimensions is the &quot;</span>
                             <span class="s3">&quot;only logical permutation.&quot;</span><span class="s2">)</span>

        <span class="s1">permuted_shape </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_shape</span><span class="s2">[</span><span class="s1">i</span><span class="s2">] </span><span class="s4">for </span><span class="s1">i </span><span class="s4">in </span><span class="s1">axes</span><span class="s2">)</span>
        <span class="s1">permuted_coords </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">coords</span><span class="s2">[</span><span class="s1">i</span><span class="s2">] </span><span class="s4">for </span><span class="s1">i </span><span class="s4">in </span><span class="s1">axes</span><span class="s2">)</span>
        <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__class__</span><span class="s2">((</span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">, </span><span class="s1">permuted_coords</span><span class="s2">),</span>
                              <span class="s1">shape</span><span class="s2">=</span><span class="s1">permuted_shape</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s1">copy</span><span class="s2">)</span>

    <span class="s1">transpose</span><span class="s2">.</span><span class="s1">__doc__ </span><span class="s2">= </span><span class="s1">_spbase</span><span class="s2">.</span><span class="s1">transpose</span><span class="s2">.</span><span class="s1">__doc__</span>

    <span class="s4">def </span><span class="s1">resize</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, *</span><span class="s1">shape</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s4">None</span><span class="s2">:</span>
        <span class="s1">is_array </span><span class="s2">= </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">sparray</span><span class="s2">)</span>
        <span class="s1">shape </span><span class="s2">= </span><span class="s1">check_shape</span><span class="s2">(</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">allow_1d</span><span class="s2">=</span><span class="s1">is_array</span><span class="s2">)</span>

        <span class="s6"># Check for added dimensions.</span>
        <span class="s4">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">shape</span><span class="s2">) &gt; </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">:</span>
            <span class="s1">flat_coords </span><span class="s2">= </span><span class="s1">_ravel_coords</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">coords</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">)</span>
            <span class="s1">max_size </span><span class="s2">= </span><span class="s1">math</span><span class="s2">.</span><span class="s1">prod</span><span class="s2">(</span><span class="s1">shape</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">coords </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">unravel_index</span><span class="s2">(</span><span class="s1">flat_coords</span><span class="s2">[:</span><span class="s1">max_size</span><span class="s2">], </span><span class="s1">shape</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">data </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">[:</span><span class="s1">max_size</span><span class="s2">]</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_shape </span><span class="s2">= </span><span class="s1">shape</span>
            <span class="s4">return</span>

        <span class="s6"># Check for removed dimensions.</span>
        <span class="s4">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">shape</span><span class="s2">) &lt; </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">:</span>
            <span class="s1">tmp_shape </span><span class="s2">= (</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">_shape</span><span class="s2">[:</span><span class="s1">len</span><span class="s2">(</span><span class="s1">shape</span><span class="s2">) - </span><span class="s5">1</span><span class="s2">]  </span><span class="s6"># Original shape without last axis</span>
                <span class="s2">+ (-</span><span class="s5">1</span><span class="s2">,)  </span><span class="s6"># Last axis is used to flatten the array</span>
                <span class="s2">+ (</span><span class="s5">1</span><span class="s2">,) * (</span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">- </span><span class="s1">len</span><span class="s2">(</span><span class="s1">shape</span><span class="s2">))  </span><span class="s6"># Pad with ones</span>
            <span class="s2">)</span>
            <span class="s1">tmp </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">reshape</span><span class="s2">(</span><span class="s1">tmp_shape</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">coords </span><span class="s2">= </span><span class="s1">tmp</span><span class="s2">.</span><span class="s1">coords</span><span class="s2">[:</span><span class="s1">len</span><span class="s2">(</span><span class="s1">shape</span><span class="s2">)]</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_shape </span><span class="s2">= </span><span class="s1">tmp</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[:</span><span class="s1">len</span><span class="s2">(</span><span class="s1">shape</span><span class="s2">)]</span>

        <span class="s6"># Handle truncation of existing dimensions.</span>
        <span class="s1">is_truncating </span><span class="s2">= </span><span class="s1">any</span><span class="s2">(</span><span class="s1">old </span><span class="s2">&gt; </span><span class="s1">new </span><span class="s4">for </span><span class="s1">old</span><span class="s2">, </span><span class="s1">new </span><span class="s4">in </span><span class="s1">zip</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">shape</span><span class="s2">))</span>
        <span class="s4">if </span><span class="s1">is_truncating</span><span class="s2">:</span>
            <span class="s1">mask </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">logical_and</span><span class="s2">.</span><span class="s1">reduce</span><span class="s2">([</span>
                <span class="s1">idx </span><span class="s2">&lt; </span><span class="s1">size </span><span class="s4">for </span><span class="s1">idx</span><span class="s2">, </span><span class="s1">size </span><span class="s4">in </span><span class="s1">zip</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">coords</span><span class="s2">, </span><span class="s1">shape</span><span class="s2">)</span>
            <span class="s2">])</span>
            <span class="s4">if not </span><span class="s1">mask</span><span class="s2">.</span><span class="s1">all</span><span class="s2">():</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">coords </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">idx</span><span class="s2">[</span><span class="s1">mask</span><span class="s2">] </span><span class="s4">for </span><span class="s1">idx </span><span class="s4">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">coords</span><span class="s2">)</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">data </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">[</span><span class="s1">mask</span><span class="s2">]</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">_shape </span><span class="s2">= </span><span class="s1">shape</span>

    <span class="s1">resize</span><span class="s2">.</span><span class="s1">__doc__ </span><span class="s2">= </span><span class="s1">_spbase</span><span class="s2">.</span><span class="s1">resize</span><span class="s2">.</span><span class="s1">__doc__</span>

    <span class="s4">def </span><span class="s1">toarray</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">order</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">out</span><span class="s2">=</span><span class="s4">None</span><span class="s2">):</span>
        <span class="s1">B </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_process_toarray_args</span><span class="s2">(</span><span class="s1">order</span><span class="s2">, </span><span class="s1">out</span><span class="s2">)</span>
        <span class="s1">fortran </span><span class="s2">= </span><span class="s1">int</span><span class="s2">(</span><span class="s1">B</span><span class="s2">.</span><span class="s1">flags</span><span class="s2">.</span><span class="s1">f_contiguous</span><span class="s2">)</span>
        <span class="s4">if not </span><span class="s1">fortran </span><span class="s4">and not </span><span class="s1">B</span><span class="s2">.</span><span class="s1">flags</span><span class="s2">.</span><span class="s1">c_contiguous</span><span class="s2">:</span>
            <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;Output array must be C or F contiguous&quot;</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">&gt; </span><span class="s5">2</span><span class="s2">:</span>
            <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;Cannot densify higher-rank sparse array&quot;</span><span class="s2">)</span>
        <span class="s6"># This handles both 0D and 1D cases correctly regardless of the</span>
        <span class="s6"># original shape.</span>
        <span class="s1">M</span><span class="s2">, </span><span class="s1">N </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_shape_as_2d</span>
        <span class="s1">coo_todense</span><span class="s2">(</span><span class="s1">M</span><span class="s2">, </span><span class="s1">N</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">nnz</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">row</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">col</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">,</span>
                    <span class="s1">B</span><span class="s2">.</span><span class="s1">ravel</span><span class="s2">(</span><span class="s3">'A'</span><span class="s2">), </span><span class="s1">fortran</span><span class="s2">)</span>
        <span class="s6"># Note: reshape() doesn't copy here, but does return a new array (view).</span>
        <span class="s4">return </span><span class="s1">B</span><span class="s2">.</span><span class="s1">reshape</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">)</span>

    <span class="s1">toarray</span><span class="s2">.</span><span class="s1">__doc__ </span><span class="s2">= </span><span class="s1">_spbase</span><span class="s2">.</span><span class="s1">toarray</span><span class="s2">.</span><span class="s1">__doc__</span>

    <span class="s4">def </span><span class="s1">tocsc</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s4">False</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;Convert this array/matrix to Compressed Sparse Column format 
 
        Duplicate entries will be summed together. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; from numpy import array 
        &gt;&gt;&gt; from scipy.sparse import coo_array 
        &gt;&gt;&gt; row  = array([0, 0, 1, 3, 1, 0, 0]) 
        &gt;&gt;&gt; col  = array([0, 2, 1, 3, 1, 0, 0]) 
        &gt;&gt;&gt; data = array([1, 1, 1, 1, 1, 1, 1]) 
        &gt;&gt;&gt; A = coo_array((data, (row, col)), shape=(4, 4)).tocsc() 
        &gt;&gt;&gt; A.toarray() 
        array([[3, 0, 1, 0], 
               [0, 2, 0, 0], 
               [0, 0, 0, 0], 
               [0, 0, 0, 1]]) 
 
        &quot;&quot;&quot;</span>
        <span class="s4">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">!= </span><span class="s5">2</span><span class="s2">:</span>
            <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;Cannot convert a 1d sparse array to csc format&quot;</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">nnz </span><span class="s2">== </span><span class="s5">0</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_csc_container</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s4">from </span><span class="s2">.</span><span class="s1">_csc </span><span class="s4">import </span><span class="s1">csc_array</span>
            <span class="s1">indptr</span><span class="s2">, </span><span class="s1">indices</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">shape </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_coo_to_compressed</span><span class="s2">(</span><span class="s1">csc_array</span><span class="s2">.</span><span class="s1">_swap</span><span class="s2">)</span>

            <span class="s1">x </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_csc_container</span><span class="s2">((</span><span class="s1">data</span><span class="s2">, </span><span class="s1">indices</span><span class="s2">, </span><span class="s1">indptr</span><span class="s2">), </span><span class="s1">shape</span><span class="s2">=</span><span class="s1">shape</span><span class="s2">)</span>
            <span class="s4">if not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">has_canonical_format</span><span class="s2">:</span>
                <span class="s1">x</span><span class="s2">.</span><span class="s1">sum_duplicates</span><span class="s2">()</span>
            <span class="s4">return </span><span class="s1">x</span>

    <span class="s4">def </span><span class="s1">tocsr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s4">False</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;Convert this array/matrix to Compressed Sparse Row format 
 
        Duplicate entries will be summed together. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; from numpy import array 
        &gt;&gt;&gt; from scipy.sparse import coo_array 
        &gt;&gt;&gt; row  = array([0, 0, 1, 3, 1, 0, 0]) 
        &gt;&gt;&gt; col  = array([0, 2, 1, 3, 1, 0, 0]) 
        &gt;&gt;&gt; data = array([1, 1, 1, 1, 1, 1, 1]) 
        &gt;&gt;&gt; A = coo_array((data, (row, col)), shape=(4, 4)).tocsr() 
        &gt;&gt;&gt; A.toarray() 
        array([[3, 0, 1, 0], 
               [0, 2, 0, 0], 
               [0, 0, 0, 0], 
               [0, 0, 0, 1]]) 
 
        &quot;&quot;&quot;</span>
        <span class="s4">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">nnz </span><span class="s2">== </span><span class="s5">0</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_csr_container</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s4">from </span><span class="s2">.</span><span class="s1">_csr </span><span class="s4">import </span><span class="s1">csr_array</span>
            <span class="s1">arrays </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_coo_to_compressed</span><span class="s2">(</span><span class="s1">csr_array</span><span class="s2">.</span><span class="s1">_swap</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s1">copy</span><span class="s2">)</span>
            <span class="s1">indptr</span><span class="s2">, </span><span class="s1">indices</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">shape </span><span class="s2">= </span><span class="s1">arrays</span>

            <span class="s1">x </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_csr_container</span><span class="s2">((</span><span class="s1">data</span><span class="s2">, </span><span class="s1">indices</span><span class="s2">, </span><span class="s1">indptr</span><span class="s2">), </span><span class="s1">shape</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">)</span>
            <span class="s4">if not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">has_canonical_format</span><span class="s2">:</span>
                <span class="s1">x</span><span class="s2">.</span><span class="s1">sum_duplicates</span><span class="s2">()</span>
            <span class="s4">return </span><span class="s1">x</span>

    <span class="s4">def </span><span class="s1">_coo_to_compressed</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">swap</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s4">False</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;convert (shape, coords, data) to (indptr, indices, data, shape)&quot;&quot;&quot;</span>
        <span class="s1">M</span><span class="s2">, </span><span class="s1">N </span><span class="s2">= </span><span class="s1">swap</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_shape_as_2d</span><span class="s2">)</span>
        <span class="s6"># convert idx_dtype intc to int32 for pythran.</span>
        <span class="s6"># tested in scipy/optimize/tests/test__numdiff.py::test_group_columns</span>
        <span class="s1">idx_dtype </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_get_index_dtype</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">coords</span><span class="s2">, </span><span class="s1">maxval</span><span class="s2">=</span><span class="s1">max</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">nnz</span><span class="s2">, </span><span class="s1">N</span><span class="s2">))</span>

        <span class="s4">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s5">1</span><span class="s2">:</span>
            <span class="s1">indices </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">coords</span><span class="s2">[</span><span class="s5">0</span><span class="s2">].</span><span class="s1">copy</span><span class="s2">() </span><span class="s4">if </span><span class="s1">copy </span><span class="s4">else </span><span class="s1">self</span><span class="s2">.</span><span class="s1">coords</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]</span>
            <span class="s1">nnz </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">indices</span><span class="s2">)</span>
            <span class="s1">indptr </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s5">0</span><span class="s2">, </span><span class="s1">nnz</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">idx_dtype</span><span class="s2">)</span>
            <span class="s1">data </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">() </span><span class="s4">if </span><span class="s1">copy </span><span class="s4">else </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span>
            <span class="s4">return </span><span class="s1">indptr</span><span class="s2">, </span><span class="s1">indices</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span>

        <span class="s6"># ndim == 2</span>
        <span class="s1">major</span><span class="s2">, </span><span class="s1">minor </span><span class="s2">= </span><span class="s1">swap</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">coords</span><span class="s2">)</span>
        <span class="s1">nnz </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">major</span><span class="s2">)</span>
        <span class="s1">major </span><span class="s2">= </span><span class="s1">major</span><span class="s2">.</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">idx_dtype</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s4">False</span><span class="s2">)</span>
        <span class="s1">minor </span><span class="s2">= </span><span class="s1">minor</span><span class="s2">.</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">idx_dtype</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s4">False</span><span class="s2">)</span>

        <span class="s1">indptr </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">(</span><span class="s1">M </span><span class="s2">+ </span><span class="s5">1</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">idx_dtype</span><span class="s2">)</span>
        <span class="s1">indices </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty_like</span><span class="s2">(</span><span class="s1">minor</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">idx_dtype</span><span class="s2">)</span>
        <span class="s1">data </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty_like</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>

        <span class="s1">coo_tocsr</span><span class="s2">(</span><span class="s1">M</span><span class="s2">, </span><span class="s1">N</span><span class="s2">, </span><span class="s1">nnz</span><span class="s2">, </span><span class="s1">major</span><span class="s2">, </span><span class="s1">minor</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">, </span><span class="s1">indptr</span><span class="s2">, </span><span class="s1">indices</span><span class="s2">, </span><span class="s1">data</span><span class="s2">)</span>
        <span class="s4">return </span><span class="s1">indptr</span><span class="s2">, </span><span class="s1">indices</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span>

    <span class="s4">def </span><span class="s1">tocoo</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s4">False</span><span class="s2">):</span>
        <span class="s4">if </span><span class="s1">copy</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s1">self</span>

    <span class="s1">tocoo</span><span class="s2">.</span><span class="s1">__doc__ </span><span class="s2">= </span><span class="s1">_spbase</span><span class="s2">.</span><span class="s1">tocoo</span><span class="s2">.</span><span class="s1">__doc__</span>

    <span class="s4">def </span><span class="s1">todia</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s4">False</span><span class="s2">):</span>
        <span class="s4">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">!= </span><span class="s5">2</span><span class="s2">:</span>
            <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;Cannot convert a 1d sparse array to dia format&quot;</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">sum_duplicates</span><span class="s2">()</span>
        <span class="s1">ks </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">col </span><span class="s2">- </span><span class="s1">self</span><span class="s2">.</span><span class="s1">row  </span><span class="s6"># the diagonal for each nonzero</span>
        <span class="s1">diags</span><span class="s2">, </span><span class="s1">diag_idx </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">unique</span><span class="s2">(</span><span class="s1">ks</span><span class="s2">, </span><span class="s1">return_inverse</span><span class="s2">=</span><span class="s4">True</span><span class="s2">)</span>

        <span class="s4">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">diags</span><span class="s2">) &gt; </span><span class="s5">100</span><span class="s2">:</span>
            <span class="s6"># probably undesired, should todia() have a maxdiags parameter?</span>
            <span class="s1">warn</span><span class="s2">(</span><span class="s3">&quot;Constructing a DIA matrix with %d diagonals &quot;</span>
                 <span class="s3">&quot;is inefficient&quot; </span><span class="s2">% </span><span class="s1">len</span><span class="s2">(</span><span class="s1">diags</span><span class="s2">),</span>
                 <span class="s1">SparseEfficiencyWarning</span><span class="s2">, </span><span class="s1">stacklevel</span><span class="s2">=</span><span class="s5">2</span><span class="s2">)</span>

        <span class="s6">#initialize and fill in data array</span>
        <span class="s4">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">.</span><span class="s1">size </span><span class="s2">== </span><span class="s5">0</span><span class="s2">:</span>
            <span class="s1">data </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">((</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">data </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">((</span><span class="s1">len</span><span class="s2">(</span><span class="s1">diags</span><span class="s2">), </span><span class="s1">self</span><span class="s2">.</span><span class="s1">col</span><span class="s2">.</span><span class="s1">max</span><span class="s2">()+</span><span class="s5">1</span><span class="s2">), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
            <span class="s1">data</span><span class="s2">[</span><span class="s1">diag_idx</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">col</span><span class="s2">] = </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span>

        <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_dia_container</span><span class="s2">((</span><span class="s1">data</span><span class="s2">, </span><span class="s1">diags</span><span class="s2">), </span><span class="s1">shape</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">)</span>

    <span class="s1">todia</span><span class="s2">.</span><span class="s1">__doc__ </span><span class="s2">= </span><span class="s1">_spbase</span><span class="s2">.</span><span class="s1">todia</span><span class="s2">.</span><span class="s1">__doc__</span>

    <span class="s4">def </span><span class="s1">todok</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s4">False</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">sum_duplicates</span><span class="s2">()</span>
        <span class="s1">dok </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_dok_container</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s6"># ensure that 1d coordinates are not tuples</span>
        <span class="s4">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s5">1</span><span class="s2">:</span>
            <span class="s1">coords </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">coords</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">coords </span><span class="s2">= </span><span class="s1">zip</span><span class="s2">(*</span><span class="s1">self</span><span class="s2">.</span><span class="s1">coords</span><span class="s2">)</span>

        <span class="s1">dok</span><span class="s2">.</span><span class="s1">_dict </span><span class="s2">= </span><span class="s1">dict</span><span class="s2">(</span><span class="s1">zip</span><span class="s2">(</span><span class="s1">coords</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">))</span>
        <span class="s4">return </span><span class="s1">dok</span>

    <span class="s1">todok</span><span class="s2">.</span><span class="s1">__doc__ </span><span class="s2">= </span><span class="s1">_spbase</span><span class="s2">.</span><span class="s1">todok</span><span class="s2">.</span><span class="s1">__doc__</span>

    <span class="s4">def </span><span class="s1">diagonal</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">k</span><span class="s2">=</span><span class="s5">0</span><span class="s2">):</span>
        <span class="s4">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">!= </span><span class="s5">2</span><span class="s2">:</span>
            <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;diagonal requires two dimensions&quot;</span><span class="s2">)</span>
        <span class="s1">rows</span><span class="s2">, </span><span class="s1">cols </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span>
        <span class="s4">if </span><span class="s1">k </span><span class="s2">&lt;= -</span><span class="s1">rows </span><span class="s4">or </span><span class="s1">k </span><span class="s2">&gt;= </span><span class="s1">cols</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s1">diag </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">(</span><span class="s1">min</span><span class="s2">(</span><span class="s1">rows </span><span class="s2">+ </span><span class="s1">min</span><span class="s2">(</span><span class="s1">k</span><span class="s2">, </span><span class="s5">0</span><span class="s2">), </span><span class="s1">cols </span><span class="s2">- </span><span class="s1">max</span><span class="s2">(</span><span class="s1">k</span><span class="s2">, </span><span class="s5">0</span><span class="s2">)),</span>
                        <span class="s1">dtype</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s1">diag_mask </span><span class="s2">= (</span><span class="s1">self</span><span class="s2">.</span><span class="s1">row </span><span class="s2">+ </span><span class="s1">k</span><span class="s2">) == </span><span class="s1">self</span><span class="s2">.</span><span class="s1">col</span>

        <span class="s4">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">has_canonical_format</span><span class="s2">:</span>
            <span class="s1">row </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">row</span><span class="s2">[</span><span class="s1">diag_mask</span><span class="s2">]</span>
            <span class="s1">data </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">[</span><span class="s1">diag_mask</span><span class="s2">]</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">inds </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">idx</span><span class="s2">[</span><span class="s1">diag_mask</span><span class="s2">] </span><span class="s4">for </span><span class="s1">idx </span><span class="s4">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">coords</span><span class="s2">)</span>
            <span class="s2">(</span><span class="s1">row</span><span class="s2">, </span><span class="s1">_</span><span class="s2">), </span><span class="s1">data </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_sum_duplicates</span><span class="s2">(</span><span class="s1">inds</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">[</span><span class="s1">diag_mask</span><span class="s2">])</span>
        <span class="s1">diag</span><span class="s2">[</span><span class="s1">row </span><span class="s2">+ </span><span class="s1">min</span><span class="s2">(</span><span class="s1">k</span><span class="s2">, </span><span class="s5">0</span><span class="s2">)] = </span><span class="s1">data</span>

        <span class="s4">return </span><span class="s1">diag</span>

    <span class="s1">diagonal</span><span class="s2">.</span><span class="s1">__doc__ </span><span class="s2">= </span><span class="s1">_data_matrix</span><span class="s2">.</span><span class="s1">diagonal</span><span class="s2">.</span><span class="s1">__doc__</span>

    <span class="s4">def </span><span class="s1">_setdiag</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">values</span><span class="s2">, </span><span class="s1">k</span><span class="s2">):</span>
        <span class="s4">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">!= </span><span class="s5">2</span><span class="s2">:</span>
            <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;setting a diagonal requires two dimensions&quot;</span><span class="s2">)</span>
        <span class="s1">M</span><span class="s2">, </span><span class="s1">N </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span>
        <span class="s4">if </span><span class="s1">values</span><span class="s2">.</span><span class="s1">ndim </span><span class="s4">and not </span><span class="s1">len</span><span class="s2">(</span><span class="s1">values</span><span class="s2">):</span>
            <span class="s4">return</span>
        <span class="s1">idx_dtype </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">row</span><span class="s2">.</span><span class="s1">dtype</span>

        <span class="s6"># Determine which triples to keep and where to put the new ones.</span>
        <span class="s1">full_keep </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">col </span><span class="s2">- </span><span class="s1">self</span><span class="s2">.</span><span class="s1">row </span><span class="s2">!= </span><span class="s1">k</span>
        <span class="s4">if </span><span class="s1">k </span><span class="s2">&lt; </span><span class="s5">0</span><span class="s2">:</span>
            <span class="s1">max_index </span><span class="s2">= </span><span class="s1">min</span><span class="s2">(</span><span class="s1">M</span><span class="s2">+</span><span class="s1">k</span><span class="s2">, </span><span class="s1">N</span><span class="s2">)</span>
            <span class="s4">if </span><span class="s1">values</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">:</span>
                <span class="s1">max_index </span><span class="s2">= </span><span class="s1">min</span><span class="s2">(</span><span class="s1">max_index</span><span class="s2">, </span><span class="s1">len</span><span class="s2">(</span><span class="s1">values</span><span class="s2">))</span>
            <span class="s1">keep </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">logical_or</span><span class="s2">(</span><span class="s1">full_keep</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">col </span><span class="s2">&gt;= </span><span class="s1">max_index</span><span class="s2">)</span>
            <span class="s1">new_row </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(-</span><span class="s1">k</span><span class="s2">, -</span><span class="s1">k </span><span class="s2">+ </span><span class="s1">max_index</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">idx_dtype</span><span class="s2">)</span>
            <span class="s1">new_col </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(</span><span class="s1">max_index</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">idx_dtype</span><span class="s2">)</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">max_index </span><span class="s2">= </span><span class="s1">min</span><span class="s2">(</span><span class="s1">M</span><span class="s2">, </span><span class="s1">N</span><span class="s2">-</span><span class="s1">k</span><span class="s2">)</span>
            <span class="s4">if </span><span class="s1">values</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">:</span>
                <span class="s1">max_index </span><span class="s2">= </span><span class="s1">min</span><span class="s2">(</span><span class="s1">max_index</span><span class="s2">, </span><span class="s1">len</span><span class="s2">(</span><span class="s1">values</span><span class="s2">))</span>
            <span class="s1">keep </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">logical_or</span><span class="s2">(</span><span class="s1">full_keep</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">row </span><span class="s2">&gt;= </span><span class="s1">max_index</span><span class="s2">)</span>
            <span class="s1">new_row </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(</span><span class="s1">max_index</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">idx_dtype</span><span class="s2">)</span>
            <span class="s1">new_col </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(</span><span class="s1">k</span><span class="s2">, </span><span class="s1">k </span><span class="s2">+ </span><span class="s1">max_index</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">idx_dtype</span><span class="s2">)</span>

        <span class="s6"># Define the array of data consisting of the entries to be added.</span>
        <span class="s4">if </span><span class="s1">values</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">:</span>
            <span class="s1">new_data </span><span class="s2">= </span><span class="s1">values</span><span class="s2">[:</span><span class="s1">max_index</span><span class="s2">]</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">new_data </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">(</span><span class="s1">max_index</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
            <span class="s1">new_data</span><span class="s2">[:] = </span><span class="s1">values</span>

        <span class="s6"># Update the internal structure.</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">coords </span><span class="s2">= (</span><span class="s1">np</span><span class="s2">.</span><span class="s1">concatenate</span><span class="s2">((</span><span class="s1">self</span><span class="s2">.</span><span class="s1">row</span><span class="s2">[</span><span class="s1">keep</span><span class="s2">], </span><span class="s1">new_row</span><span class="s2">)),</span>
                       <span class="s1">np</span><span class="s2">.</span><span class="s1">concatenate</span><span class="s2">((</span><span class="s1">self</span><span class="s2">.</span><span class="s1">col</span><span class="s2">[</span><span class="s1">keep</span><span class="s2">], </span><span class="s1">new_col</span><span class="s2">)))</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">data </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">concatenate</span><span class="s2">((</span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">[</span><span class="s1">keep</span><span class="s2">], </span><span class="s1">new_data</span><span class="s2">))</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">has_canonical_format </span><span class="s2">= </span><span class="s4">False</span>

    <span class="s6"># needed by _data_matrix</span>
    <span class="s4">def </span><span class="s1">_with_data</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s4">True</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;Returns a matrix with the same sparsity structure as self, 
        but with different data. By default the index arrays are copied. 
        &quot;&quot;&quot;</span>
        <span class="s4">if </span><span class="s1">copy</span><span class="s2">:</span>
            <span class="s1">coords </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">idx</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">() </span><span class="s4">for </span><span class="s1">idx </span><span class="s4">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">coords</span><span class="s2">)</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">coords </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">coords</span>
        <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__class__</span><span class="s2">((</span><span class="s1">data</span><span class="s2">, </span><span class="s1">coords</span><span class="s2">), </span><span class="s1">shape</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">data</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">sum_duplicates</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s4">None</span><span class="s2">:</span>
        <span class="s0">&quot;&quot;&quot;Eliminate duplicate entries by adding them together 
 
        This is an *in place* operation 
        &quot;&quot;&quot;</span>
        <span class="s4">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">has_canonical_format</span><span class="s2">:</span>
            <span class="s4">return</span>
        <span class="s1">summed </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_sum_duplicates</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">coords</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">coords</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data </span><span class="s2">= </span><span class="s1">summed</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">has_canonical_format </span><span class="s2">= </span><span class="s4">True</span>

    <span class="s4">def </span><span class="s1">_sum_duplicates</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">coords</span><span class="s2">, </span><span class="s1">data</span><span class="s2">):</span>
        <span class="s6"># Assumes coords not in canonical format.</span>
        <span class="s4">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">data</span><span class="s2">) == </span><span class="s5">0</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s1">coords</span><span class="s2">, </span><span class="s1">data</span>
        <span class="s6"># Sort coords w.r.t. rows, then cols. This corresponds to C-order,</span>
        <span class="s6"># which we rely on for argmin/argmax to return the first index in the</span>
        <span class="s6"># same way that numpy does (in the case of ties).</span>
        <span class="s1">order </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">lexsort</span><span class="s2">(</span><span class="s1">coords</span><span class="s2">[::-</span><span class="s5">1</span><span class="s2">])</span>
        <span class="s1">coords </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">idx</span><span class="s2">[</span><span class="s1">order</span><span class="s2">] </span><span class="s4">for </span><span class="s1">idx </span><span class="s4">in </span><span class="s1">coords</span><span class="s2">)</span>
        <span class="s1">data </span><span class="s2">= </span><span class="s1">data</span><span class="s2">[</span><span class="s1">order</span><span class="s2">]</span>
        <span class="s1">unique_mask </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">logical_or</span><span class="s2">.</span><span class="s1">reduce</span><span class="s2">([</span>
            <span class="s1">idx</span><span class="s2">[</span><span class="s5">1</span><span class="s2">:] != </span><span class="s1">idx</span><span class="s2">[:-</span><span class="s5">1</span><span class="s2">] </span><span class="s4">for </span><span class="s1">idx </span><span class="s4">in </span><span class="s1">coords</span>
        <span class="s2">])</span>
        <span class="s1">unique_mask </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s4">True</span><span class="s2">, </span><span class="s1">unique_mask</span><span class="s2">)</span>
        <span class="s1">coords </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">idx</span><span class="s2">[</span><span class="s1">unique_mask</span><span class="s2">] </span><span class="s4">for </span><span class="s1">idx </span><span class="s4">in </span><span class="s1">coords</span><span class="s2">)</span>
        <span class="s1">unique_inds</span><span class="s2">, = </span><span class="s1">np</span><span class="s2">.</span><span class="s1">nonzero</span><span class="s2">(</span><span class="s1">unique_mask</span><span class="s2">)</span>
        <span class="s1">data </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">add</span><span class="s2">.</span><span class="s1">reduceat</span><span class="s2">(</span><span class="s1">data</span><span class="s2">, </span><span class="s1">unique_inds</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s4">return </span><span class="s1">coords</span><span class="s2">, </span><span class="s1">data</span>

    <span class="s4">def </span><span class="s1">eliminate_zeros</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;Remove zero entries from the array/matrix 
 
        This is an *in place* operation 
        &quot;&quot;&quot;</span>
        <span class="s1">mask </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data </span><span class="s2">!= </span><span class="s5">0</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">data </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">[</span><span class="s1">mask</span><span class="s2">]</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">coords </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">idx</span><span class="s2">[</span><span class="s1">mask</span><span class="s2">] </span><span class="s4">for </span><span class="s1">idx </span><span class="s4">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">coords</span><span class="s2">)</span>

    <span class="s6">#######################</span>
    <span class="s6"># Arithmetic handlers #</span>
    <span class="s6">#######################</span>

    <span class="s4">def </span><span class="s1">_add_dense</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">):</span>
        <span class="s4">if </span><span class="s1">other</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">!= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">:</span>
            <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">f'Incompatible shapes (</span><span class="s4">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s4">} </span><span class="s3">and </span><span class="s4">{</span><span class="s1">other</span><span class="s2">.</span><span class="s1">shape</span><span class="s4">}</span><span class="s3">)'</span><span class="s2">)</span>
        <span class="s1">dtype </span><span class="s2">= </span><span class="s1">upcast_char</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">char</span><span class="s2">, </span><span class="s1">other</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">char</span><span class="s2">)</span>
        <span class="s1">result </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">(</span><span class="s1">other</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s4">True</span><span class="s2">)</span>
        <span class="s1">fortran </span><span class="s2">= </span><span class="s1">int</span><span class="s2">(</span><span class="s1">result</span><span class="s2">.</span><span class="s1">flags</span><span class="s2">.</span><span class="s1">f_contiguous</span><span class="s2">)</span>
        <span class="s1">M</span><span class="s2">, </span><span class="s1">N </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_shape_as_2d</span>
        <span class="s1">coo_todense</span><span class="s2">(</span><span class="s1">M</span><span class="s2">, </span><span class="s1">N</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">nnz</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">row</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">col</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">,</span>
                    <span class="s1">result</span><span class="s2">.</span><span class="s1">ravel</span><span class="s2">(</span><span class="s3">'A'</span><span class="s2">), </span><span class="s1">fortran</span><span class="s2">)</span>
        <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_container</span><span class="s2">(</span><span class="s1">result</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s4">False</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">_matmul_vector</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">):</span>
        <span class="s1">result_shape </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">0</span><span class="s2">] </span><span class="s4">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">&gt; </span><span class="s5">1 </span><span class="s4">else </span><span class="s5">1</span>
        <span class="s1">result </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">(</span><span class="s1">result_shape</span><span class="s2">,</span>
                          <span class="s1">dtype</span><span class="s2">=</span><span class="s1">upcast_char</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">char</span><span class="s2">, </span><span class="s1">other</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">char</span><span class="s2">))</span>

        <span class="s4">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s5">2</span><span class="s2">:</span>
            <span class="s1">col </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">col</span>
            <span class="s1">row </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">row</span>
        <span class="s4">elif </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s5">1</span><span class="s2">:</span>
            <span class="s1">col </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">coords</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]</span>
            <span class="s1">row </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros_like</span><span class="s2">(</span><span class="s1">col</span><span class="s2">)</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s4">raise </span><span class="s1">NotImplementedError</span><span class="s2">(</span>
                <span class="s3">f&quot;coo_matvec not implemented for ndim=</span><span class="s4">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim</span><span class="s4">}</span><span class="s3">&quot;</span><span class="s2">)</span>

        <span class="s1">coo_matvec</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">nnz</span><span class="s2">, </span><span class="s1">row</span><span class="s2">, </span><span class="s1">col</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">, </span><span class="s1">other</span><span class="s2">, </span><span class="s1">result</span><span class="s2">)</span>
        <span class="s6"># Array semantics return a scalar here, not a single-element array.</span>
        <span class="s4">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">sparray</span><span class="s2">) </span><span class="s4">and </span><span class="s1">result_shape </span><span class="s2">== </span><span class="s5">1</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s1">result</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]</span>
        <span class="s4">return </span><span class="s1">result</span>

    <span class="s4">def </span><span class="s1">_matmul_multivector</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">):</span>
        <span class="s1">result_dtype </span><span class="s2">= </span><span class="s1">upcast_char</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">char</span><span class="s2">, </span><span class="s1">other</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">char</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s5">2</span><span class="s2">:</span>
            <span class="s1">result_shape </span><span class="s2">= (</span><span class="s1">other</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">1</span><span class="s2">], </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">0</span><span class="s2">])</span>
            <span class="s1">col </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">col</span>
            <span class="s1">row </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">row</span>
        <span class="s4">elif </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s5">1</span><span class="s2">:</span>
            <span class="s1">result_shape </span><span class="s2">= (</span><span class="s1">other</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">1</span><span class="s2">],)</span>
            <span class="s1">col </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">coords</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]</span>
            <span class="s1">row </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros_like</span><span class="s2">(</span><span class="s1">col</span><span class="s2">)</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s4">raise </span><span class="s1">NotImplementedError</span><span class="s2">(</span>
                <span class="s3">f&quot;coo_matvec not implemented for ndim=</span><span class="s4">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim</span><span class="s4">}</span><span class="s3">&quot;</span><span class="s2">)</span>

        <span class="s1">result </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">(</span><span class="s1">result_shape</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">result_dtype</span><span class="s2">)</span>
        <span class="s4">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">other_col </span><span class="s4">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">other</span><span class="s2">.</span><span class="s1">T</span><span class="s2">):</span>
            <span class="s1">coo_matvec</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">nnz</span><span class="s2">, </span><span class="s1">row</span><span class="s2">, </span><span class="s1">col</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">, </span><span class="s1">other_col</span><span class="s2">, </span><span class="s1">result</span><span class="s2">[</span><span class="s1">i</span><span class="s2">:</span><span class="s1">i </span><span class="s2">+ </span><span class="s5">1</span><span class="s2">])</span>
        <span class="s4">return </span><span class="s1">result</span><span class="s2">.</span><span class="s1">T</span><span class="s2">.</span><span class="s1">view</span><span class="s2">(</span><span class="s1">type</span><span class="s2">=</span><span class="s1">type</span><span class="s2">(</span><span class="s1">other</span><span class="s2">))</span>


<span class="s4">def </span><span class="s1">_ravel_coords</span><span class="s2">(</span><span class="s1">coords</span><span class="s2">, </span><span class="s1">shape</span><span class="s2">, </span><span class="s1">order</span><span class="s2">=</span><span class="s3">'C'</span><span class="s2">):</span>
    <span class="s0">&quot;&quot;&quot;Like np.ravel_multi_index, but avoids some overflow issues.&quot;&quot;&quot;</span>
    <span class="s4">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">coords</span><span class="s2">) == </span><span class="s5">1</span><span class="s2">:</span>
        <span class="s4">return </span><span class="s1">coords</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]</span>
    <span class="s6"># Handle overflow as in https://github.com/scipy/scipy/pull/9132</span>
    <span class="s4">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">coords</span><span class="s2">) == </span><span class="s5">2</span><span class="s2">:</span>
        <span class="s1">nrows</span><span class="s2">, </span><span class="s1">ncols </span><span class="s2">= </span><span class="s1">shape</span>
        <span class="s1">row</span><span class="s2">, </span><span class="s1">col </span><span class="s2">= </span><span class="s1">coords</span>
        <span class="s4">if </span><span class="s1">order </span><span class="s2">== </span><span class="s3">'C'</span><span class="s2">:</span>
            <span class="s1">maxval </span><span class="s2">= (</span><span class="s1">ncols </span><span class="s2">* </span><span class="s1">max</span><span class="s2">(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">nrows </span><span class="s2">- </span><span class="s5">1</span><span class="s2">) + </span><span class="s1">max</span><span class="s2">(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">ncols </span><span class="s2">- </span><span class="s5">1</span><span class="s2">))</span>
            <span class="s1">idx_dtype </span><span class="s2">= </span><span class="s1">get_index_dtype</span><span class="s2">(</span><span class="s1">maxval</span><span class="s2">=</span><span class="s1">maxval</span><span class="s2">)</span>
            <span class="s4">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">multiply</span><span class="s2">(</span><span class="s1">ncols</span><span class="s2">, </span><span class="s1">row</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">idx_dtype</span><span class="s2">) + </span><span class="s1">col</span>
        <span class="s4">elif </span><span class="s1">order </span><span class="s2">== </span><span class="s3">'F'</span><span class="s2">:</span>
            <span class="s1">maxval </span><span class="s2">= (</span><span class="s1">nrows </span><span class="s2">* </span><span class="s1">max</span><span class="s2">(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">ncols </span><span class="s2">- </span><span class="s5">1</span><span class="s2">) + </span><span class="s1">max</span><span class="s2">(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">nrows </span><span class="s2">- </span><span class="s5">1</span><span class="s2">))</span>
            <span class="s1">idx_dtype </span><span class="s2">= </span><span class="s1">get_index_dtype</span><span class="s2">(</span><span class="s1">maxval</span><span class="s2">=</span><span class="s1">maxval</span><span class="s2">)</span>
            <span class="s4">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">multiply</span><span class="s2">(</span><span class="s1">nrows</span><span class="s2">, </span><span class="s1">col</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">idx_dtype</span><span class="s2">) + </span><span class="s1">row</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;'order' must be 'C' or 'F'&quot;</span><span class="s2">)</span>
    <span class="s4">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ravel_multi_index</span><span class="s2">(</span><span class="s1">coords</span><span class="s2">, </span><span class="s1">shape</span><span class="s2">, </span><span class="s1">order</span><span class="s2">=</span><span class="s1">order</span><span class="s2">)</span>


<span class="s4">def </span><span class="s1">isspmatrix_coo</span><span class="s2">(</span><span class="s1">x</span><span class="s2">):</span>
    <span class="s0">&quot;&quot;&quot;Is `x` of coo_matrix type? 
 
    Parameters 
    ---------- 
    x 
        object to check for being a coo matrix 
 
    Returns 
    ------- 
    bool 
        True if `x` is a coo matrix, False otherwise 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.sparse import coo_array, coo_matrix, csr_matrix, isspmatrix_coo 
    &gt;&gt;&gt; isspmatrix_coo(coo_matrix([[5]])) 
    True 
    &gt;&gt;&gt; isspmatrix_coo(coo_array([[5]])) 
    False 
    &gt;&gt;&gt; isspmatrix_coo(csr_matrix([[5]])) 
    False 
    &quot;&quot;&quot;</span>
    <span class="s4">return </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">coo_matrix</span><span class="s2">)</span>


<span class="s6"># This namespace class separates array from matrix with isinstance</span>
<span class="s4">class </span><span class="s1">coo_array</span><span class="s2">(</span><span class="s1">_coo_base</span><span class="s2">, </span><span class="s1">sparray</span><span class="s2">):</span>
    <span class="s0">&quot;&quot;&quot; 
    A sparse array in COOrdinate format. 
 
    Also known as the 'ijv' or 'triplet' format. 
 
    This can be instantiated in several ways: 
        coo_array(D) 
            where D is an ndarray 
 
        coo_array(S) 
            with another sparse array or matrix S (equivalent to S.tocoo()) 
 
        coo_array(shape, [dtype]) 
            to construct an empty sparse array with shape `shape` 
            dtype is optional, defaulting to dtype='d'. 
 
        coo_array((data, coords), [shape]) 
            to construct from existing data and index arrays: 
                1. data[:]       the entries of the sparse array, in any order 
                2. coords[i][:]  the axis-i coordinates of the data entries 
 
            Where ``A[coords] = data``, and coords is a tuple of index arrays. 
            When shape is not specified, it is inferred from the index arrays. 
 
    Attributes 
    ---------- 
    dtype : dtype 
        Data type of the sparse array 
    shape : tuple of integers 
        Shape of the sparse array 
    ndim : int 
        Number of dimensions of the sparse array 
    nnz 
    size 
    data 
        COO format data array of the sparse array 
    coords 
        COO format tuple of index arrays 
    has_canonical_format : bool 
        Whether the matrix has sorted coordinates and no duplicates 
    format 
    T 
 
    Notes 
    ----- 
 
    Sparse arrays can be used in arithmetic operations: they support 
    addition, subtraction, multiplication, division, and matrix power. 
 
    Advantages of the COO format 
        - facilitates fast conversion among sparse formats 
        - permits duplicate entries (see example) 
        - very fast conversion to and from CSR/CSC formats 
 
    Disadvantages of the COO format 
        - does not directly support: 
            + arithmetic operations 
            + slicing 
 
    Intended Usage 
        - COO is a fast format for constructing sparse arrays 
        - Once a COO array has been constructed, convert to CSR or 
          CSC format for fast arithmetic and matrix vector operations 
        - By default when converting to CSR or CSC format, duplicate (i,j) 
          entries will be summed together.  This facilitates efficient 
          construction of finite element matrices and the like. (see example) 
 
    Canonical format 
        - Entries and coordinates sorted by row, then column. 
        - There are no duplicate entries (i.e. duplicate (i,j) locations) 
        - Data arrays MAY have explicit zeros. 
 
    Examples 
    -------- 
 
    &gt;&gt;&gt; # Constructing an empty sparse array 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.sparse import coo_array 
    &gt;&gt;&gt; coo_array((3, 4), dtype=np.int8).toarray() 
    array([[0, 0, 0, 0], 
           [0, 0, 0, 0], 
           [0, 0, 0, 0]], dtype=int8) 
 
    &gt;&gt;&gt; # Constructing a sparse array using ijv format 
    &gt;&gt;&gt; row  = np.array([0, 3, 1, 0]) 
    &gt;&gt;&gt; col  = np.array([0, 3, 1, 2]) 
    &gt;&gt;&gt; data = np.array([4, 5, 7, 9]) 
    &gt;&gt;&gt; coo_array((data, (row, col)), shape=(4, 4)).toarray() 
    array([[4, 0, 9, 0], 
           [0, 7, 0, 0], 
           [0, 0, 0, 0], 
           [0, 0, 0, 5]]) 
 
    &gt;&gt;&gt; # Constructing a sparse array with duplicate coordinates 
    &gt;&gt;&gt; row  = np.array([0, 0, 1, 3, 1, 0, 0]) 
    &gt;&gt;&gt; col  = np.array([0, 2, 1, 3, 1, 0, 0]) 
    &gt;&gt;&gt; data = np.array([1, 1, 1, 1, 1, 1, 1]) 
    &gt;&gt;&gt; coo = coo_array((data, (row, col)), shape=(4, 4)) 
    &gt;&gt;&gt; # Duplicate coordinates are maintained until implicitly or explicitly summed 
    &gt;&gt;&gt; np.max(coo.data) 
    1 
    &gt;&gt;&gt; coo.toarray() 
    array([[3, 0, 1, 0], 
           [0, 2, 0, 0], 
           [0, 0, 0, 0], 
           [0, 0, 0, 1]]) 
 
    &quot;&quot;&quot;</span>


<span class="s4">class </span><span class="s1">coo_matrix</span><span class="s2">(</span><span class="s1">spmatrix</span><span class="s2">, </span><span class="s1">_coo_base</span><span class="s2">):</span>
    <span class="s0">&quot;&quot;&quot; 
    A sparse matrix in COOrdinate format. 
 
    Also known as the 'ijv' or 'triplet' format. 
 
    This can be instantiated in several ways: 
        coo_matrix(D) 
            where D is a 2-D ndarray 
 
        coo_matrix(S) 
            with another sparse array or matrix S (equivalent to S.tocoo()) 
 
        coo_matrix((M, N), [dtype]) 
            to construct an empty matrix with shape (M, N) 
            dtype is optional, defaulting to dtype='d'. 
 
        coo_matrix((data, (i, j)), [shape=(M, N)]) 
            to construct from three arrays: 
                1. data[:]   the entries of the matrix, in any order 
                2. i[:]      the row indices of the matrix entries 
                3. j[:]      the column indices of the matrix entries 
 
            Where ``A[i[k], j[k]] = data[k]``.  When shape is not 
            specified, it is inferred from the index arrays 
 
    Attributes 
    ---------- 
    dtype : dtype 
        Data type of the matrix 
    shape : 2-tuple 
        Shape of the matrix 
    ndim : int 
        Number of dimensions (this is always 2) 
    nnz 
    size 
    data 
        COO format data array of the matrix 
    row 
        COO format row index array of the matrix 
    col 
        COO format column index array of the matrix 
    has_canonical_format : bool 
        Whether the matrix has sorted indices and no duplicates 
    format 
    T 
 
    Notes 
    ----- 
 
    Sparse matrices can be used in arithmetic operations: they support 
    addition, subtraction, multiplication, division, and matrix power. 
 
    Advantages of the COO format 
        - facilitates fast conversion among sparse formats 
        - permits duplicate entries (see example) 
        - very fast conversion to and from CSR/CSC formats 
 
    Disadvantages of the COO format 
        - does not directly support: 
            + arithmetic operations 
            + slicing 
 
    Intended Usage 
        - COO is a fast format for constructing sparse matrices 
        - Once a COO matrix has been constructed, convert to CSR or 
          CSC format for fast arithmetic and matrix vector operations 
        - By default when converting to CSR or CSC format, duplicate (i,j) 
          entries will be summed together.  This facilitates efficient 
          construction of finite element matrices and the like. (see example) 
 
    Canonical format 
        - Entries and coordinates sorted by row, then column. 
        - There are no duplicate entries (i.e. duplicate (i,j) locations) 
        - Data arrays MAY have explicit zeros. 
 
    Examples 
    -------- 
 
    &gt;&gt;&gt; # Constructing an empty matrix 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.sparse import coo_matrix 
    &gt;&gt;&gt; coo_matrix((3, 4), dtype=np.int8).toarray() 
    array([[0, 0, 0, 0], 
           [0, 0, 0, 0], 
           [0, 0, 0, 0]], dtype=int8) 
 
    &gt;&gt;&gt; # Constructing a matrix using ijv format 
    &gt;&gt;&gt; row  = np.array([0, 3, 1, 0]) 
    &gt;&gt;&gt; col  = np.array([0, 3, 1, 2]) 
    &gt;&gt;&gt; data = np.array([4, 5, 7, 9]) 
    &gt;&gt;&gt; coo_matrix((data, (row, col)), shape=(4, 4)).toarray() 
    array([[4, 0, 9, 0], 
           [0, 7, 0, 0], 
           [0, 0, 0, 0], 
           [0, 0, 0, 5]]) 
 
    &gt;&gt;&gt; # Constructing a matrix with duplicate coordinates 
    &gt;&gt;&gt; row  = np.array([0, 0, 1, 3, 1, 0, 0]) 
    &gt;&gt;&gt; col  = np.array([0, 2, 1, 3, 1, 0, 0]) 
    &gt;&gt;&gt; data = np.array([1, 1, 1, 1, 1, 1, 1]) 
    &gt;&gt;&gt; coo = coo_matrix((data, (row, col)), shape=(4, 4)) 
    &gt;&gt;&gt; # Duplicate coordinates are maintained until implicitly or explicitly summed 
    &gt;&gt;&gt; np.max(coo.data) 
    1 
    &gt;&gt;&gt; coo.toarray() 
    array([[3, 0, 1, 0], 
           [0, 2, 0, 0], 
           [0, 0, 0, 0], 
           [0, 0, 0, 1]]) 
 
    &quot;&quot;&quot;</span>

    <span class="s4">def </span><span class="s1">__setstate__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">state</span><span class="s2">):</span>
        <span class="s4">if </span><span class="s3">'coords' </span><span class="s4">not in </span><span class="s1">state</span><span class="s2">:</span>
            <span class="s6"># For retro-compatibility with the previous attributes</span>
            <span class="s6"># storing nnz coordinates for 2D COO matrix.</span>
            <span class="s1">state</span><span class="s2">[</span><span class="s3">'coords'</span><span class="s2">] = (</span><span class="s1">state</span><span class="s2">.</span><span class="s1">pop</span><span class="s2">(</span><span class="s3">'row'</span><span class="s2">), </span><span class="s1">state</span><span class="s2">.</span><span class="s1">pop</span><span class="s2">(</span><span class="s3">'col'</span><span class="s2">))</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">__dict__</span><span class="s2">.</span><span class="s1">update</span><span class="s2">(</span><span class="s1">state</span><span class="s2">)</span>
</pre>
</body>
</html>