<html>
<head>
<title>test_slerp.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #2aacb8;}
.s4 { color: #7a7e85;}
.s5 { color: #6aab73;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_slerp.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">from </span><span class="s1">numpy</span><span class="s2">.</span><span class="s1">testing </span><span class="s0">import </span><span class="s1">assert_allclose</span>

<span class="s0">import </span><span class="s1">pytest</span>
<span class="s0">from </span><span class="s1">scipy</span><span class="s2">.</span><span class="s1">spatial </span><span class="s0">import </span><span class="s1">geometric_slerp</span>


<span class="s0">def </span><span class="s1">_generate_spherical_points</span><span class="s2">(</span><span class="s1">ndim</span><span class="s2">=</span><span class="s3">3</span><span class="s2">, </span><span class="s1">n_pts</span><span class="s2">=</span><span class="s3">2</span><span class="s2">):</span>
    <span class="s4"># generate uniform points on sphere</span>
    <span class="s4"># see: https://stackoverflow.com/a/23785326</span>
    <span class="s4"># tentatively extended to arbitrary dims</span>
    <span class="s4"># for 0-sphere it will always produce antipodes</span>
    <span class="s1">np</span><span class="s2">.</span><span class="s1">random</span><span class="s2">.</span><span class="s1">seed</span><span class="s2">(</span><span class="s3">123</span><span class="s2">)</span>
    <span class="s1">points </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">random</span><span class="s2">.</span><span class="s1">normal</span><span class="s2">(</span><span class="s1">size</span><span class="s2">=(</span><span class="s1">n_pts</span><span class="s2">, </span><span class="s1">ndim</span><span class="s2">))</span>
    <span class="s1">points </span><span class="s2">/= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">norm</span><span class="s2">(</span><span class="s1">points</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s3">1</span><span class="s2">)[:, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">newaxis</span><span class="s2">]</span>
    <span class="s0">return </span><span class="s1">points</span><span class="s2">[</span><span class="s3">0</span><span class="s2">], </span><span class="s1">points</span><span class="s2">[</span><span class="s3">1</span><span class="s2">]</span>


<span class="s0">class </span><span class="s1">TestGeometricSlerp</span><span class="s2">:</span>
    <span class="s4"># Test various properties of the geometric slerp code</span>

    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">parametrize</span><span class="s2">(</span><span class="s5">&quot;n_dims&quot;</span><span class="s2">, [</span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">5</span><span class="s2">, </span><span class="s3">7</span><span class="s2">, </span><span class="s3">9</span><span class="s2">])</span>
    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">parametrize</span><span class="s2">(</span><span class="s5">&quot;n_pts&quot;</span><span class="s2">, [</span><span class="s3">0</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">17</span><span class="s2">])</span>
    <span class="s0">def </span><span class="s1">test_shape_property</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">n_dims</span><span class="s2">, </span><span class="s1">n_pts</span><span class="s2">):</span>
        <span class="s4"># geometric_slerp output shape should match</span>
        <span class="s4"># input dimensionality &amp; requested number</span>
        <span class="s4"># of interpolation points</span>
        <span class="s1">start</span><span class="s2">, </span><span class="s1">end </span><span class="s2">= </span><span class="s1">_generate_spherical_points</span><span class="s2">(</span><span class="s1">n_dims</span><span class="s2">, </span><span class="s3">2</span><span class="s2">)</span>

        <span class="s1">actual </span><span class="s2">= </span><span class="s1">geometric_slerp</span><span class="s2">(</span><span class="s1">start</span><span class="s2">=</span><span class="s1">start</span><span class="s2">,</span>
                                 <span class="s1">end</span><span class="s2">=</span><span class="s1">end</span><span class="s2">,</span>
                                 <span class="s1">t</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">linspace</span><span class="s2">(</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s1">n_pts</span><span class="s2">))</span>

        <span class="s0">assert </span><span class="s1">actual</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">== (</span><span class="s1">n_pts</span><span class="s2">, </span><span class="s1">n_dims</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">parametrize</span><span class="s2">(</span><span class="s5">&quot;n_dims&quot;</span><span class="s2">, [</span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">5</span><span class="s2">, </span><span class="s3">7</span><span class="s2">, </span><span class="s3">9</span><span class="s2">])</span>
    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">parametrize</span><span class="s2">(</span><span class="s5">&quot;n_pts&quot;</span><span class="s2">, [</span><span class="s3">3</span><span class="s2">, </span><span class="s3">17</span><span class="s2">])</span>
    <span class="s0">def </span><span class="s1">test_include_ends</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">n_dims</span><span class="s2">, </span><span class="s1">n_pts</span><span class="s2">):</span>
        <span class="s4"># geometric_slerp should return a data structure</span>
        <span class="s4"># that includes the start and end coordinates</span>
        <span class="s4"># when t includes 0 and 1 ends</span>
        <span class="s4"># this is convenient for plotting surfaces represented</span>
        <span class="s4"># by interpolations for example</span>

        <span class="s4"># the generator doesn't work so well for the unit</span>
        <span class="s4"># sphere (it always produces antipodes), so use</span>
        <span class="s4"># custom values there</span>
        <span class="s1">start</span><span class="s2">, </span><span class="s1">end </span><span class="s2">= </span><span class="s1">_generate_spherical_points</span><span class="s2">(</span><span class="s1">n_dims</span><span class="s2">, </span><span class="s3">2</span><span class="s2">)</span>

        <span class="s1">actual </span><span class="s2">= </span><span class="s1">geometric_slerp</span><span class="s2">(</span><span class="s1">start</span><span class="s2">=</span><span class="s1">start</span><span class="s2">,</span>
                                 <span class="s1">end</span><span class="s2">=</span><span class="s1">end</span><span class="s2">,</span>
                                 <span class="s1">t</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">linspace</span><span class="s2">(</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s1">n_pts</span><span class="s2">))</span>

        <span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">actual</span><span class="s2">[</span><span class="s3">0</span><span class="s2">], </span><span class="s1">start</span><span class="s2">)</span>
        <span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">actual</span><span class="s2">[-</span><span class="s3">1</span><span class="s2">], </span><span class="s1">end</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">parametrize</span><span class="s2">(</span><span class="s5">&quot;start, end&quot;</span><span class="s2">, [</span>
        <span class="s4"># both arrays are not flat</span>
        <span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">((</span><span class="s3">1</span><span class="s2">, </span><span class="s3">3</span><span class="s2">)), </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">((</span><span class="s3">1</span><span class="s2">, </span><span class="s3">3</span><span class="s2">))),</span>
        <span class="s4"># only start array is not flat</span>
        <span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">((</span><span class="s3">1</span><span class="s2">, </span><span class="s3">3</span><span class="s2">)), </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">(</span><span class="s3">3</span><span class="s2">)),</span>
        <span class="s4"># only end array is not flat</span>
        <span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">(</span><span class="s3">1</span><span class="s2">), </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">((</span><span class="s3">3</span><span class="s2">, </span><span class="s3">1</span><span class="s2">))),</span>
        <span class="s2">])</span>
    <span class="s0">def </span><span class="s1">test_input_shape_flat</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">):</span>
        <span class="s4"># geometric_slerp should handle input arrays that are</span>
        <span class="s4"># not flat appropriately</span>
        <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">ValueError</span><span class="s2">, </span><span class="s1">match</span><span class="s2">=</span><span class="s5">'one-dimensional'</span><span class="s2">):</span>
            <span class="s1">geometric_slerp</span><span class="s2">(</span><span class="s1">start</span><span class="s2">=</span><span class="s1">start</span><span class="s2">,</span>
                            <span class="s1">end</span><span class="s2">=</span><span class="s1">end</span><span class="s2">,</span>
                            <span class="s1">t</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">linspace</span><span class="s2">(</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">10</span><span class="s2">))</span>

    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">parametrize</span><span class="s2">(</span><span class="s5">&quot;start, end&quot;</span><span class="s2">, [</span>
        <span class="s4"># 7-D and 3-D ends</span>
        <span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">(</span><span class="s3">7</span><span class="s2">), </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">(</span><span class="s3">3</span><span class="s2">)),</span>
        <span class="s4"># 2-D and 1-D ends</span>
        <span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">(</span><span class="s3">2</span><span class="s2">), </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">(</span><span class="s3">1</span><span class="s2">)),</span>
        <span class="s4"># empty, &quot;3D&quot; will also get caught this way</span>
        <span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([]), </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">(</span><span class="s3">3</span><span class="s2">)),</span>
        <span class="s2">])</span>
    <span class="s0">def </span><span class="s1">test_input_dim_mismatch</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">):</span>
        <span class="s4"># geometric_slerp must appropriately handle cases where</span>
        <span class="s4"># an interpolation is attempted across two different</span>
        <span class="s4"># dimensionalities</span>
        <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">ValueError</span><span class="s2">, </span><span class="s1">match</span><span class="s2">=</span><span class="s5">'dimensions'</span><span class="s2">):</span>
            <span class="s1">geometric_slerp</span><span class="s2">(</span><span class="s1">start</span><span class="s2">=</span><span class="s1">start</span><span class="s2">,</span>
                            <span class="s1">end</span><span class="s2">=</span><span class="s1">end</span><span class="s2">,</span>
                            <span class="s1">t</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">linspace</span><span class="s2">(</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">10</span><span class="s2">))</span>

    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">parametrize</span><span class="s2">(</span><span class="s5">&quot;start, end&quot;</span><span class="s2">, [</span>
        <span class="s4"># both empty</span>
        <span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([]), </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([])),</span>
        <span class="s2">])</span>
    <span class="s0">def </span><span class="s1">test_input_at_least1d</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">):</span>
        <span class="s4"># empty inputs to geometric_slerp must</span>
        <span class="s4"># be handled appropriately when not detected</span>
        <span class="s4"># by mismatch</span>
        <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">ValueError</span><span class="s2">, </span><span class="s1">match</span><span class="s2">=</span><span class="s5">'at least two-dim'</span><span class="s2">):</span>
            <span class="s1">geometric_slerp</span><span class="s2">(</span><span class="s1">start</span><span class="s2">=</span><span class="s1">start</span><span class="s2">,</span>
                            <span class="s1">end</span><span class="s2">=</span><span class="s1">end</span><span class="s2">,</span>
                            <span class="s1">t</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">linspace</span><span class="s2">(</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">10</span><span class="s2">))</span>

    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">parametrize</span><span class="s2">(</span><span class="s5">&quot;start, end, expected&quot;</span><span class="s2">, [</span>
        <span class="s4"># North and South Poles are definitely antipodes</span>
        <span class="s4"># but should be handled gracefully now</span>
        <span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">1.0</span><span class="s2">]), </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, -</span><span class="s3">1.0</span><span class="s2">]), </span><span class="s5">&quot;warning&quot;</span><span class="s2">),</span>
        <span class="s4"># this case will issue a warning &amp; be handled</span>
        <span class="s4"># gracefully as well;</span>
        <span class="s4"># North Pole was rotated very slightly</span>
        <span class="s4"># using r = R.from_euler('x', 0.035, degrees=True)</span>
        <span class="s4"># to achieve Euclidean distance offset from diameter by</span>
        <span class="s4"># 9.328908379124812e-08, within the default tol</span>
        <span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s3">0.00000000e+00</span><span class="s2">,</span>
                  <span class="s2">-</span><span class="s3">6.10865200e-04</span><span class="s2">,</span>
                  <span class="s3">9.99999813e-01</span><span class="s2">]), </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, -</span><span class="s3">1.0</span><span class="s2">]), </span><span class="s5">&quot;warning&quot;</span><span class="s2">),</span>
        <span class="s4"># this case should succeed without warning because a</span>
        <span class="s4"># sufficiently large</span>
        <span class="s4"># rotation was applied to North Pole point to shift it</span>
        <span class="s4"># to a Euclidean distance of 2.3036691931821451e-07</span>
        <span class="s4"># from South Pole, which is larger than tol</span>
        <span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s3">0.00000000e+00</span><span class="s2">,</span>
                  <span class="s2">-</span><span class="s3">9.59930941e-04</span><span class="s2">,</span>
                  <span class="s3">9.99999539e-01</span><span class="s2">]), </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, -</span><span class="s3">1.0</span><span class="s2">]), </span><span class="s5">&quot;success&quot;</span><span class="s2">),</span>
        <span class="s2">])</span>
    <span class="s0">def </span><span class="s1">test_handle_antipodes</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">):</span>
        <span class="s4"># antipodal points must be handled appropriately;</span>
        <span class="s4"># there are an infinite number of possible geodesic</span>
        <span class="s4"># interpolations between them in higher dims</span>
        <span class="s0">if </span><span class="s1">expected </span><span class="s2">== </span><span class="s5">&quot;warning&quot;</span><span class="s2">:</span>
            <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">warns</span><span class="s2">(</span><span class="s1">UserWarning</span><span class="s2">, </span><span class="s1">match</span><span class="s2">=</span><span class="s5">'antipodes'</span><span class="s2">):</span>
                <span class="s1">res </span><span class="s2">= </span><span class="s1">geometric_slerp</span><span class="s2">(</span><span class="s1">start</span><span class="s2">=</span><span class="s1">start</span><span class="s2">,</span>
                                      <span class="s1">end</span><span class="s2">=</span><span class="s1">end</span><span class="s2">,</span>
                                      <span class="s1">t</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">linspace</span><span class="s2">(</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">10</span><span class="s2">))</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">res </span><span class="s2">= </span><span class="s1">geometric_slerp</span><span class="s2">(</span><span class="s1">start</span><span class="s2">=</span><span class="s1">start</span><span class="s2">,</span>
                                  <span class="s1">end</span><span class="s2">=</span><span class="s1">end</span><span class="s2">,</span>
                                  <span class="s1">t</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">linspace</span><span class="s2">(</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">10</span><span class="s2">))</span>

        <span class="s4"># antipodes or near-antipodes should still produce</span>
        <span class="s4"># slerp paths on the surface of the sphere (but they</span>
        <span class="s4"># may be ambiguous):</span>
        <span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">norm</span><span class="s2">(</span><span class="s1">res</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s3">1</span><span class="s2">), </span><span class="s3">1.0</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">parametrize</span><span class="s2">(</span><span class="s5">&quot;start, end, expected&quot;</span><span class="s2">, [</span>
        <span class="s4"># 2-D with n_pts=4 (two new interpolation points)</span>
        <span class="s4"># this is an actual circle</span>
        <span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">]),</span>
         <span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">]),</span>
         <span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([[</span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">],</span>
                   <span class="s2">[</span><span class="s1">np</span><span class="s2">.</span><span class="s1">sqrt</span><span class="s2">(</span><span class="s3">3</span><span class="s2">) / </span><span class="s3">2</span><span class="s2">, </span><span class="s3">0.5</span><span class="s2">],  </span><span class="s4"># 30 deg on unit circle</span>
                   <span class="s2">[</span><span class="s3">0.5</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sqrt</span><span class="s2">(</span><span class="s3">3</span><span class="s2">) / </span><span class="s3">2</span><span class="s2">],  </span><span class="s4"># 60 deg on unit circle</span>
                   <span class="s2">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">]])),</span>
        <span class="s4"># likewise for 3-D (add z = 0 plane)</span>
        <span class="s4"># this is an ordinary sphere</span>
        <span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">]),</span>
         <span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">]),</span>
         <span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([[</span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">],</span>
                   <span class="s2">[</span><span class="s1">np</span><span class="s2">.</span><span class="s1">sqrt</span><span class="s2">(</span><span class="s3">3</span><span class="s2">) / </span><span class="s3">2</span><span class="s2">, </span><span class="s3">0.5</span><span class="s2">, </span><span class="s3">0</span><span class="s2">],</span>
                   <span class="s2">[</span><span class="s3">0.5</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sqrt</span><span class="s2">(</span><span class="s3">3</span><span class="s2">) / </span><span class="s3">2</span><span class="s2">, </span><span class="s3">0</span><span class="s2">],</span>
                   <span class="s2">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">]])),</span>
        <span class="s4"># for 5-D, pad more columns with constants</span>
        <span class="s4"># zeros are easiest--non-zero values on unit</span>
        <span class="s4"># circle are more difficult to reason about</span>
        <span class="s4"># at higher dims</span>
        <span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">]),</span>
         <span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">]),</span>
         <span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([[</span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">],</span>
                   <span class="s2">[</span><span class="s1">np</span><span class="s2">.</span><span class="s1">sqrt</span><span class="s2">(</span><span class="s3">3</span><span class="s2">) / </span><span class="s3">2</span><span class="s2">, </span><span class="s3">0.5</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">],</span>
                   <span class="s2">[</span><span class="s3">0.5</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sqrt</span><span class="s2">(</span><span class="s3">3</span><span class="s2">) / </span><span class="s3">2</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">],</span>
                   <span class="s2">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">]])),</span>

    <span class="s2">])</span>
    <span class="s0">def </span><span class="s1">test_straightforward_examples</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">):</span>
        <span class="s4"># some straightforward interpolation tests, sufficiently</span>
        <span class="s4"># simple to use the unit circle to deduce expected values;</span>
        <span class="s4"># for larger dimensions, pad with constants so that the</span>
        <span class="s4"># data is N-D but simpler to reason about</span>
        <span class="s1">actual </span><span class="s2">= </span><span class="s1">geometric_slerp</span><span class="s2">(</span><span class="s1">start</span><span class="s2">=</span><span class="s1">start</span><span class="s2">,</span>
                                 <span class="s1">end</span><span class="s2">=</span><span class="s1">end</span><span class="s2">,</span>
                                 <span class="s1">t</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">linspace</span><span class="s2">(</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">4</span><span class="s2">))</span>
        <span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">actual</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">atol</span><span class="s2">=</span><span class="s3">1e-16</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">parametrize</span><span class="s2">(</span><span class="s5">&quot;t&quot;</span><span class="s2">, [</span>
        <span class="s4"># both interval ends clearly violate limits</span>
        <span class="s1">np</span><span class="s2">.</span><span class="s1">linspace</span><span class="s2">(-</span><span class="s3">20</span><span class="s2">, </span><span class="s3">20</span><span class="s2">, </span><span class="s3">300</span><span class="s2">),</span>
        <span class="s4"># only one interval end violating limit slightly</span>
        <span class="s1">np</span><span class="s2">.</span><span class="s1">linspace</span><span class="s2">(-</span><span class="s3">0.0001</span><span class="s2">, </span><span class="s3">0.0001</span><span class="s2">, </span><span class="s3">17</span><span class="s2">),</span>
        <span class="s2">])</span>
    <span class="s0">def </span><span class="s1">test_t_values_limits</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">t</span><span class="s2">):</span>
        <span class="s4"># geometric_slerp() should appropriately handle</span>
        <span class="s4"># interpolation parameters &lt; 0 and &gt; 1</span>
        <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">ValueError</span><span class="s2">, </span><span class="s1">match</span><span class="s2">=</span><span class="s5">'interpolation parameter'</span><span class="s2">):</span>
            <span class="s1">_ </span><span class="s2">= </span><span class="s1">geometric_slerp</span><span class="s2">(</span><span class="s1">start</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">]),</span>
                                <span class="s1">end</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">]),</span>
                                <span class="s1">t</span><span class="s2">=</span><span class="s1">t</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">parametrize</span><span class="s2">(</span><span class="s5">&quot;start, end&quot;</span><span class="s2">, [</span>
        <span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s3">1</span><span class="s2">]),</span>
         <span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s3">0</span><span class="s2">])),</span>
        <span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s3">0</span><span class="s2">]),</span>
         <span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s3">1</span><span class="s2">])),</span>
        <span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([-</span><span class="s3">17.7</span><span class="s2">]),</span>
         <span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s3">165.9</span><span class="s2">])),</span>
     <span class="s2">])</span>
    <span class="s0">def </span><span class="s1">test_0_sphere_handling</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">):</span>
        <span class="s4"># it does not make sense to interpolate the set of</span>
        <span class="s4"># two points that is the 0-sphere</span>
        <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">ValueError</span><span class="s2">, </span><span class="s1">match</span><span class="s2">=</span><span class="s5">'at least two-dim'</span><span class="s2">):</span>
            <span class="s1">_ </span><span class="s2">= </span><span class="s1">geometric_slerp</span><span class="s2">(</span><span class="s1">start</span><span class="s2">=</span><span class="s1">start</span><span class="s2">,</span>
                                <span class="s1">end</span><span class="s2">=</span><span class="s1">end</span><span class="s2">,</span>
                                <span class="s1">t</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">linspace</span><span class="s2">(</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">4</span><span class="s2">))</span>

    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">parametrize</span><span class="s2">(</span><span class="s5">&quot;tol&quot;</span><span class="s2">, [</span>
        <span class="s4"># an integer currently raises</span>
        <span class="s3">5</span><span class="s2">,</span>
        <span class="s4"># string raises</span>
        <span class="s5">&quot;7&quot;</span><span class="s2">,</span>
        <span class="s4"># list and arrays also raise</span>
        <span class="s2">[</span><span class="s3">5</span><span class="s2">, </span><span class="s3">6</span><span class="s2">, </span><span class="s3">7</span><span class="s2">], </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">(</span><span class="s3">9.0</span><span class="s2">),</span>
        <span class="s2">])</span>
    <span class="s0">def </span><span class="s1">test_tol_type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">tol</span><span class="s2">):</span>
        <span class="s4"># geometric_slerp() should raise if tol is not</span>
        <span class="s4"># a suitable float type</span>
        <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">ValueError</span><span class="s2">, </span><span class="s1">match</span><span class="s2">=</span><span class="s5">'must be a float'</span><span class="s2">):</span>
            <span class="s1">_ </span><span class="s2">= </span><span class="s1">geometric_slerp</span><span class="s2">(</span><span class="s1">start</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">]),</span>
                                <span class="s1">end</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">]),</span>
                                <span class="s1">t</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">linspace</span><span class="s2">(</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">5</span><span class="s2">),</span>
                                <span class="s1">tol</span><span class="s2">=</span><span class="s1">tol</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">parametrize</span><span class="s2">(</span><span class="s5">&quot;tol&quot;</span><span class="s2">, [</span>
        <span class="s2">-</span><span class="s3">5e-6</span><span class="s2">,</span>
        <span class="s2">-</span><span class="s3">7e-10</span><span class="s2">,</span>
        <span class="s2">])</span>
    <span class="s0">def </span><span class="s1">test_tol_sign</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">tol</span><span class="s2">):</span>
        <span class="s4"># geometric_slerp() currently handles negative</span>
        <span class="s4"># tol values, as long as they are floats</span>
        <span class="s1">_ </span><span class="s2">= </span><span class="s1">geometric_slerp</span><span class="s2">(</span><span class="s1">start</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">]),</span>
                            <span class="s1">end</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">]),</span>
                            <span class="s1">t</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">linspace</span><span class="s2">(</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">5</span><span class="s2">),</span>
                            <span class="s1">tol</span><span class="s2">=</span><span class="s1">tol</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">parametrize</span><span class="s2">(</span><span class="s5">&quot;start, end&quot;</span><span class="s2">, [</span>
        <span class="s4"># 1-sphere (circle) with one point at origin</span>
        <span class="s4"># and the other on the circle</span>
        <span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">]), </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">])),</span>
        <span class="s4"># 2-sphere (normal sphere) with both points</span>
        <span class="s4"># just slightly off sphere by the same amount</span>
        <span class="s4"># in different directions</span>
        <span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s3">1 </span><span class="s2">+ </span><span class="s3">1e-6</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">]),</span>
         <span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1 </span><span class="s2">- </span><span class="s3">1e-6</span><span class="s2">, </span><span class="s3">0</span><span class="s2">])),</span>
        <span class="s4"># same thing in 4-D</span>
        <span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s3">1 </span><span class="s2">+ </span><span class="s3">1e-6</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">]),</span>
         <span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1 </span><span class="s2">- </span><span class="s3">1e-6</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">])),</span>
        <span class="s2">])</span>
    <span class="s0">def </span><span class="s1">test_unit_sphere_enforcement</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">):</span>
        <span class="s4"># geometric_slerp() should raise on input that clearly</span>
        <span class="s4"># cannot be on an n-sphere of radius 1</span>
        <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">ValueError</span><span class="s2">, </span><span class="s1">match</span><span class="s2">=</span><span class="s5">'unit n-sphere'</span><span class="s2">):</span>
            <span class="s1">geometric_slerp</span><span class="s2">(</span><span class="s1">start</span><span class="s2">=</span><span class="s1">start</span><span class="s2">,</span>
                            <span class="s1">end</span><span class="s2">=</span><span class="s1">end</span><span class="s2">,</span>
                            <span class="s1">t</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">linspace</span><span class="s2">(</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">5</span><span class="s2">))</span>

    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">parametrize</span><span class="s2">(</span><span class="s5">&quot;start, end&quot;</span><span class="s2">, [</span>
        <span class="s4"># 1-sphere 45 degree case</span>
        <span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">]),</span>
         <span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s1">np</span><span class="s2">.</span><span class="s1">sqrt</span><span class="s2">(</span><span class="s3">2</span><span class="s2">) / </span><span class="s3">2.</span><span class="s2">,</span>
                   <span class="s1">np</span><span class="s2">.</span><span class="s1">sqrt</span><span class="s2">(</span><span class="s3">2</span><span class="s2">) / </span><span class="s3">2.</span><span class="s2">])),</span>
        <span class="s4"># 2-sphere 135 degree case</span>
        <span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">]),</span>
         <span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([-</span><span class="s1">np</span><span class="s2">.</span><span class="s1">sqrt</span><span class="s2">(</span><span class="s3">2</span><span class="s2">) / </span><span class="s3">2.</span><span class="s2">,</span>
                   <span class="s1">np</span><span class="s2">.</span><span class="s1">sqrt</span><span class="s2">(</span><span class="s3">2</span><span class="s2">) / </span><span class="s3">2.</span><span class="s2">])),</span>
        <span class="s2">])</span>
    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">parametrize</span><span class="s2">(</span><span class="s5">&quot;t_func&quot;</span><span class="s2">, [</span>
        <span class="s1">np</span><span class="s2">.</span><span class="s1">linspace</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">logspace</span><span class="s2">])</span>
    <span class="s0">def </span><span class="s1">test_order_handling</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">t_func</span><span class="s2">):</span>
        <span class="s4"># geometric_slerp() should handle scenarios with</span>
        <span class="s4"># ascending and descending t value arrays gracefully;</span>
        <span class="s4"># results should simply be reversed</span>

        <span class="s4"># for scrambled / unsorted parameters, the same values</span>
        <span class="s4"># should be returned, just in scrambled order</span>

        <span class="s1">num_t_vals </span><span class="s2">= </span><span class="s3">20</span>
        <span class="s1">np</span><span class="s2">.</span><span class="s1">random</span><span class="s2">.</span><span class="s1">seed</span><span class="s2">(</span><span class="s3">789</span><span class="s2">)</span>
        <span class="s1">forward_t_vals </span><span class="s2">= </span><span class="s1">t_func</span><span class="s2">(</span><span class="s3">0</span><span class="s2">, </span><span class="s3">10</span><span class="s2">, </span><span class="s1">num_t_vals</span><span class="s2">)</span>
        <span class="s4"># normalize to max of 1</span>
        <span class="s1">forward_t_vals </span><span class="s2">/= </span><span class="s1">forward_t_vals</span><span class="s2">.</span><span class="s1">max</span><span class="s2">()</span>
        <span class="s1">reverse_t_vals </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">flipud</span><span class="s2">(</span><span class="s1">forward_t_vals</span><span class="s2">)</span>
        <span class="s1">shuffled_indices </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(</span><span class="s1">num_t_vals</span><span class="s2">)</span>
        <span class="s1">np</span><span class="s2">.</span><span class="s1">random</span><span class="s2">.</span><span class="s1">shuffle</span><span class="s2">(</span><span class="s1">shuffled_indices</span><span class="s2">)</span>
        <span class="s1">scramble_t_vals </span><span class="s2">= </span><span class="s1">forward_t_vals</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()[</span><span class="s1">shuffled_indices</span><span class="s2">]</span>

        <span class="s1">forward_results </span><span class="s2">= </span><span class="s1">geometric_slerp</span><span class="s2">(</span><span class="s1">start</span><span class="s2">=</span><span class="s1">start</span><span class="s2">,</span>
                                          <span class="s1">end</span><span class="s2">=</span><span class="s1">end</span><span class="s2">,</span>
                                          <span class="s1">t</span><span class="s2">=</span><span class="s1">forward_t_vals</span><span class="s2">)</span>
        <span class="s1">reverse_results </span><span class="s2">= </span><span class="s1">geometric_slerp</span><span class="s2">(</span><span class="s1">start</span><span class="s2">=</span><span class="s1">start</span><span class="s2">,</span>
                                          <span class="s1">end</span><span class="s2">=</span><span class="s1">end</span><span class="s2">,</span>
                                          <span class="s1">t</span><span class="s2">=</span><span class="s1">reverse_t_vals</span><span class="s2">)</span>
        <span class="s1">scrambled_results </span><span class="s2">= </span><span class="s1">geometric_slerp</span><span class="s2">(</span><span class="s1">start</span><span class="s2">=</span><span class="s1">start</span><span class="s2">,</span>
                                            <span class="s1">end</span><span class="s2">=</span><span class="s1">end</span><span class="s2">,</span>
                                            <span class="s1">t</span><span class="s2">=</span><span class="s1">scramble_t_vals</span><span class="s2">)</span>

        <span class="s4"># check fidelity to input order</span>
        <span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">forward_results</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">flipud</span><span class="s2">(</span><span class="s1">reverse_results</span><span class="s2">))</span>
        <span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">forward_results</span><span class="s2">[</span><span class="s1">shuffled_indices</span><span class="s2">],</span>
                        <span class="s1">scrambled_results</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">parametrize</span><span class="s2">(</span><span class="s5">&quot;t&quot;</span><span class="s2">, [</span>
        <span class="s4"># string:</span>
        <span class="s5">&quot;15, 5, 7&quot;</span><span class="s2">,</span>
        <span class="s4"># complex numbers currently produce a warning</span>
        <span class="s4"># but not sure we need to worry about it too much:</span>
        <span class="s4"># [3 + 1j, 5 + 2j],</span>
        <span class="s2">])</span>
    <span class="s0">def </span><span class="s1">test_t_values_conversion</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">t</span><span class="s2">):</span>
        <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">ValueError</span><span class="s2">):</span>
            <span class="s1">_ </span><span class="s2">= </span><span class="s1">geometric_slerp</span><span class="s2">(</span><span class="s1">start</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s3">1</span><span class="s2">]),</span>
                                <span class="s1">end</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s3">0</span><span class="s2">]),</span>
                                <span class="s1">t</span><span class="s2">=</span><span class="s1">t</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">test_accept_arraylike</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s4"># array-like support requested by reviewer</span>
        <span class="s4"># in gh-10380</span>
        <span class="s1">actual </span><span class="s2">= </span><span class="s1">geometric_slerp</span><span class="s2">([</span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">], [</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">], [</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">/</span><span class="s3">3</span><span class="s2">, </span><span class="s3">0.5</span><span class="s2">, </span><span class="s3">2</span><span class="s2">/</span><span class="s3">3</span><span class="s2">, </span><span class="s3">1</span><span class="s2">])</span>

        <span class="s4"># expected values are based on visual inspection</span>
        <span class="s4"># of the unit circle for the progressions along</span>
        <span class="s4"># the circumference provided in t</span>
        <span class="s1">expected </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([[</span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">],</span>
                             <span class="s2">[</span><span class="s1">np</span><span class="s2">.</span><span class="s1">sqrt</span><span class="s2">(</span><span class="s3">3</span><span class="s2">) / </span><span class="s3">2</span><span class="s2">, </span><span class="s3">0.5</span><span class="s2">],</span>
                             <span class="s2">[</span><span class="s1">np</span><span class="s2">.</span><span class="s1">sqrt</span><span class="s2">(</span><span class="s3">2</span><span class="s2">) / </span><span class="s3">2</span><span class="s2">,</span>
                              <span class="s1">np</span><span class="s2">.</span><span class="s1">sqrt</span><span class="s2">(</span><span class="s3">2</span><span class="s2">) / </span><span class="s3">2</span><span class="s2">],</span>
                             <span class="s2">[</span><span class="s3">0.5</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sqrt</span><span class="s2">(</span><span class="s3">3</span><span class="s2">) / </span><span class="s3">2</span><span class="s2">],</span>
                             <span class="s2">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">]], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">)</span>
        <span class="s4"># Tyler's original Cython implementation of geometric_slerp</span>
        <span class="s4"># can pass at atol=0 here, but on balance we will accept</span>
        <span class="s4"># 1e-16 for an implementation that avoids Cython and</span>
        <span class="s4"># makes up accuracy ground elsewhere</span>
        <span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">actual</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">atol</span><span class="s2">=</span><span class="s3">1e-16</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">test_scalar_t</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s4"># when t is a scalar, return value is a single</span>
        <span class="s4"># interpolated point of the appropriate dimensionality</span>
        <span class="s4"># requested by reviewer in gh-10380</span>
        <span class="s1">actual </span><span class="s2">= </span><span class="s1">geometric_slerp</span><span class="s2">([</span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">], [</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">], </span><span class="s3">0.5</span><span class="s2">)</span>
        <span class="s1">expected </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s1">np</span><span class="s2">.</span><span class="s1">sqrt</span><span class="s2">(</span><span class="s3">2</span><span class="s2">) / </span><span class="s3">2</span><span class="s2">,</span>
                             <span class="s1">np</span><span class="s2">.</span><span class="s1">sqrt</span><span class="s2">(</span><span class="s3">2</span><span class="s2">) / </span><span class="s3">2</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">)</span>
        <span class="s0">assert </span><span class="s1">actual</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">== (</span><span class="s3">2</span><span class="s2">,)</span>
        <span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">actual</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">parametrize</span><span class="s2">(</span><span class="s5">'start'</span><span class="s2">, [</span>
        <span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">]),</span>
        <span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">]),</span>
    <span class="s2">])</span>
    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">parametrize</span><span class="s2">(</span><span class="s5">'t'</span><span class="s2">, [</span>
        <span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">(</span><span class="s3">1</span><span class="s2">),</span>
        <span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s3">1</span><span class="s2">]),</span>
        <span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([[</span><span class="s3">1</span><span class="s2">]]),</span>
        <span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([[[</span><span class="s3">1</span><span class="s2">]]]),</span>
        <span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([]),</span>
        <span class="s1">np</span><span class="s2">.</span><span class="s1">linspace</span><span class="s2">(</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">5</span><span class="s2">),</span>
    <span class="s2">])</span>
    <span class="s0">def </span><span class="s1">test_degenerate_input</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">t</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">t</span><span class="s2">).</span><span class="s1">ndim </span><span class="s2">&gt; </span><span class="s3">1</span><span class="s2">:</span>
            <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">ValueError</span><span class="s2">):</span>
                <span class="s1">geometric_slerp</span><span class="s2">(</span><span class="s1">start</span><span class="s2">=</span><span class="s1">start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">=</span><span class="s1">start</span><span class="s2">, </span><span class="s1">t</span><span class="s2">=</span><span class="s1">t</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>

            <span class="s1">shape </span><span class="s2">= (</span><span class="s1">t</span><span class="s2">.</span><span class="s1">size</span><span class="s2">,) + </span><span class="s1">start</span><span class="s2">.</span><span class="s1">shape</span>
            <span class="s1">expected </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">full</span><span class="s2">(</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">start</span><span class="s2">)</span>

            <span class="s1">actual </span><span class="s2">= </span><span class="s1">geometric_slerp</span><span class="s2">(</span><span class="s1">start</span><span class="s2">=</span><span class="s1">start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">=</span><span class="s1">start</span><span class="s2">, </span><span class="s1">t</span><span class="s2">=</span><span class="s1">t</span><span class="s2">)</span>
            <span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">actual</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">)</span>

            <span class="s4"># Check that degenerate and non-degenerate</span>
            <span class="s4"># inputs yield the same size</span>
            <span class="s1">non_degenerate </span><span class="s2">= </span><span class="s1">geometric_slerp</span><span class="s2">(</span><span class="s1">start</span><span class="s2">=</span><span class="s1">start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">=</span><span class="s1">start</span><span class="s2">[::-</span><span class="s3">1</span><span class="s2">], </span><span class="s1">t</span><span class="s2">=</span><span class="s1">t</span><span class="s2">)</span>
            <span class="s0">assert </span><span class="s1">actual</span><span class="s2">.</span><span class="s1">size </span><span class="s2">== </span><span class="s1">non_degenerate</span><span class="s2">.</span><span class="s1">size</span>

    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">parametrize</span><span class="s2">(</span><span class="s5">'k'</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">logspace</span><span class="s2">(-</span><span class="s3">10</span><span class="s2">, -</span><span class="s3">1</span><span class="s2">, </span><span class="s3">10</span><span class="s2">))</span>
    <span class="s0">def </span><span class="s1">test_numerical_stability_pi</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">k</span><span class="s2">):</span>
        <span class="s4"># geometric_slerp should have excellent numerical</span>
        <span class="s4"># stability for angles approaching pi between</span>
        <span class="s4"># the start and end points</span>
        <span class="s1">angle </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">pi </span><span class="s2">- </span><span class="s1">k</span>
        <span class="s1">ts </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linspace</span><span class="s2">(</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">100</span><span class="s2">)</span>
        <span class="s1">P </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">])</span>
        <span class="s1">Q </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s1">np</span><span class="s2">.</span><span class="s1">cos</span><span class="s2">(</span><span class="s1">angle</span><span class="s2">), </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sin</span><span class="s2">(</span><span class="s1">angle</span><span class="s2">), </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">])</span>
        <span class="s4"># the test should only be enforced for cases where</span>
        <span class="s4"># geometric_slerp determines that the input is actually</span>
        <span class="s4"># on the unit sphere</span>
        <span class="s0">with </span><span class="s1">np</span><span class="s2">.</span><span class="s1">testing</span><span class="s2">.</span><span class="s1">suppress_warnings</span><span class="s2">() </span><span class="s0">as </span><span class="s1">sup</span><span class="s2">:</span>
            <span class="s1">sup</span><span class="s2">.</span><span class="s1">filter</span><span class="s2">(</span><span class="s1">UserWarning</span><span class="s2">)</span>
            <span class="s1">result </span><span class="s2">= </span><span class="s1">geometric_slerp</span><span class="s2">(</span><span class="s1">P</span><span class="s2">, </span><span class="s1">Q</span><span class="s2">, </span><span class="s1">ts</span><span class="s2">, </span><span class="s3">1e-18</span><span class="s2">)</span>
            <span class="s1">norms </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">norm</span><span class="s2">(</span><span class="s1">result</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s3">1</span><span class="s2">)</span>
            <span class="s1">error </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">max</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">norms </span><span class="s2">- </span><span class="s3">1</span><span class="s2">))</span>
            <span class="s0">assert </span><span class="s1">error </span><span class="s2">&lt; </span><span class="s3">4e-15</span>

    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">parametrize</span><span class="s2">(</span><span class="s5">'t'</span><span class="s2">, [</span>
     <span class="s2">[[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">0.5</span><span class="s2">]],</span>
     <span class="s2">[[[[[[[[[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">0.5</span><span class="s2">]]]]]]]]],</span>
    <span class="s2">])</span>
    <span class="s0">def </span><span class="s1">test_interpolation_param_ndim</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">t</span><span class="s2">):</span>
        <span class="s4"># regression test for gh-14465</span>
        <span class="s1">arr1 </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">])</span>
        <span class="s1">arr2 </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">])</span>

        <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">ValueError</span><span class="s2">):</span>
            <span class="s1">geometric_slerp</span><span class="s2">(</span><span class="s1">start</span><span class="s2">=</span><span class="s1">arr1</span><span class="s2">,</span>
                            <span class="s1">end</span><span class="s2">=</span><span class="s1">arr2</span><span class="s2">,</span>
                            <span class="s1">t</span><span class="s2">=</span><span class="s1">t</span><span class="s2">)</span>

        <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">ValueError</span><span class="s2">):</span>
            <span class="s1">geometric_slerp</span><span class="s2">(</span><span class="s1">start</span><span class="s2">=</span><span class="s1">arr1</span><span class="s2">,</span>
                            <span class="s1">end</span><span class="s2">=</span><span class="s1">arr1</span><span class="s2">,</span>
                            <span class="s1">t</span><span class="s2">=</span><span class="s1">t</span><span class="s2">)</span>
</pre>
</body>
</html>