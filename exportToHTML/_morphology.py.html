<html>
<head>
<title>_morphology.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #6aab73;}
.s5 { color: #2aacb8;}
.s6 { color: #5f826b; font-style: italic;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_morphology.py</font>
</center></td></tr></table>
<pre><span class="s0"># Copyright (C) 2003-2005 Peter J. Verveer</span>
<span class="s0">#</span>
<span class="s0"># Redistribution and use in source and binary forms, with or without</span>
<span class="s0"># modification, are permitted provided that the following conditions</span>
<span class="s0"># are met:</span>
<span class="s0">#</span>
<span class="s0"># 1. Redistributions of source code must retain the above copyright</span>
<span class="s0">#    notice, this list of conditions and the following disclaimer.</span>
<span class="s0">#</span>
<span class="s0"># 2. Redistributions in binary form must reproduce the above</span>
<span class="s0">#    copyright notice, this list of conditions and the following</span>
<span class="s0">#    disclaimer in the documentation and/or other materials provided</span>
<span class="s0">#    with the distribution.</span>
<span class="s0">#</span>
<span class="s0"># 3. The name of the author may not be used to endorse or promote</span>
<span class="s0">#    products derived from this software without specific prior</span>
<span class="s0">#    written permission.</span>
<span class="s0">#</span>
<span class="s0"># THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS</span>
<span class="s0"># OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED</span>
<span class="s0"># WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</span>
<span class="s0"># ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY</span>
<span class="s0"># DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</span>
<span class="s0"># DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE</span>
<span class="s0"># GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</span>
<span class="s0"># INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,</span>
<span class="s0"># WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING</span>
<span class="s0"># NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS</span>
<span class="s0"># SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>

<span class="s2">import </span><span class="s1">warnings</span>
<span class="s2">import </span><span class="s1">operator</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">from </span><span class="s3">. </span><span class="s2">import </span><span class="s1">_ni_support</span>
<span class="s2">from </span><span class="s3">. </span><span class="s2">import </span><span class="s1">_nd_image</span>
<span class="s2">from </span><span class="s3">. </span><span class="s2">import </span><span class="s1">_filters</span>

<span class="s1">__all__ </span><span class="s3">= [</span><span class="s4">'iterate_structure'</span><span class="s3">, </span><span class="s4">'generate_binary_structure'</span><span class="s3">, </span><span class="s4">'binary_erosion'</span><span class="s3">,</span>
           <span class="s4">'binary_dilation'</span><span class="s3">, </span><span class="s4">'binary_opening'</span><span class="s3">, </span><span class="s4">'binary_closing'</span><span class="s3">,</span>
           <span class="s4">'binary_hit_or_miss'</span><span class="s3">, </span><span class="s4">'binary_propagation'</span><span class="s3">, </span><span class="s4">'binary_fill_holes'</span><span class="s3">,</span>
           <span class="s4">'grey_erosion'</span><span class="s3">, </span><span class="s4">'grey_dilation'</span><span class="s3">, </span><span class="s4">'grey_opening'</span><span class="s3">, </span><span class="s4">'grey_closing'</span><span class="s3">,</span>
           <span class="s4">'morphological_gradient'</span><span class="s3">, </span><span class="s4">'morphological_laplace'</span><span class="s3">, </span><span class="s4">'white_tophat'</span><span class="s3">,</span>
           <span class="s4">'black_tophat'</span><span class="s3">, </span><span class="s4">'distance_transform_bf'</span><span class="s3">, </span><span class="s4">'distance_transform_cdt'</span><span class="s3">,</span>
           <span class="s4">'distance_transform_edt'</span><span class="s3">]</span>


<span class="s2">def </span><span class="s1">_center_is_true</span><span class="s3">(</span><span class="s1">structure</span><span class="s3">, </span><span class="s1">origin</span><span class="s3">):</span>
    <span class="s1">structure </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">structure</span><span class="s3">)</span>
    <span class="s1">coor </span><span class="s3">= </span><span class="s1">tuple</span><span class="s3">([</span><span class="s1">oo </span><span class="s3">+ </span><span class="s1">ss </span><span class="s3">// </span><span class="s5">2 </span><span class="s2">for </span><span class="s1">ss</span><span class="s3">, </span><span class="s1">oo </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">structure</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">,</span>
                                                 <span class="s1">origin</span><span class="s3">)])</span>
    <span class="s2">return </span><span class="s1">bool</span><span class="s3">(</span><span class="s1">structure</span><span class="s3">[</span><span class="s1">coor</span><span class="s3">])</span>


<span class="s2">def </span><span class="s1">iterate_structure</span><span class="s3">(</span><span class="s1">structure</span><span class="s3">, </span><span class="s1">iterations</span><span class="s3">, </span><span class="s1">origin</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Iterate a structure by dilating it with itself. 
 
    Parameters 
    ---------- 
    structure : array_like 
       Structuring element (an array of bools, for example), to be dilated with 
       itself. 
    iterations : int 
       number of dilations performed on the structure with itself 
    origin : optional 
        If origin is None, only the iterated structure is returned. If 
        not, a tuple of the iterated structure and the modified origin is 
        returned. 
 
    Returns 
    ------- 
    iterate_structure : ndarray of bools 
        A new structuring element obtained by dilating `structure` 
        (`iterations` - 1) times with itself. 
 
    See Also 
    -------- 
    generate_binary_structure 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy import ndimage 
    &gt;&gt;&gt; struct = ndimage.generate_binary_structure(2, 1) 
    &gt;&gt;&gt; struct.astype(int) 
    array([[0, 1, 0], 
           [1, 1, 1], 
           [0, 1, 0]]) 
    &gt;&gt;&gt; ndimage.iterate_structure(struct, 2).astype(int) 
    array([[0, 0, 1, 0, 0], 
           [0, 1, 1, 1, 0], 
           [1, 1, 1, 1, 1], 
           [0, 1, 1, 1, 0], 
           [0, 0, 1, 0, 0]]) 
    &gt;&gt;&gt; ndimage.iterate_structure(struct, 3).astype(int) 
    array([[0, 0, 0, 1, 0, 0, 0], 
           [0, 0, 1, 1, 1, 0, 0], 
           [0, 1, 1, 1, 1, 1, 0], 
           [1, 1, 1, 1, 1, 1, 1], 
           [0, 1, 1, 1, 1, 1, 0], 
           [0, 0, 1, 1, 1, 0, 0], 
           [0, 0, 0, 1, 0, 0, 0]]) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">structure </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">structure</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">iterations </span><span class="s3">&lt; </span><span class="s5">2</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">structure</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>
    <span class="s1">ni </span><span class="s3">= </span><span class="s1">iterations </span><span class="s3">- </span><span class="s5">1</span>
    <span class="s1">shape </span><span class="s3">= [</span><span class="s1">ii </span><span class="s3">+ </span><span class="s1">ni </span><span class="s3">* (</span><span class="s1">ii </span><span class="s3">- </span><span class="s5">1</span><span class="s3">) </span><span class="s2">for </span><span class="s1">ii </span><span class="s2">in </span><span class="s1">structure</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">]</span>
    <span class="s1">pos </span><span class="s3">= [</span><span class="s1">ni </span><span class="s3">* (</span><span class="s1">structure</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s1">ii</span><span class="s3">] // </span><span class="s5">2</span><span class="s3">) </span><span class="s2">for </span><span class="s1">ii </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">))]</span>
    <span class="s1">slc </span><span class="s3">= </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">slice</span><span class="s3">(</span><span class="s1">pos</span><span class="s3">[</span><span class="s1">ii</span><span class="s3">], </span><span class="s1">pos</span><span class="s3">[</span><span class="s1">ii</span><span class="s3">] + </span><span class="s1">structure</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s1">ii</span><span class="s3">], </span><span class="s2">None</span><span class="s3">)</span>
                <span class="s2">for </span><span class="s1">ii </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">)))</span>
    <span class="s1">out </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">bool</span><span class="s3">)</span>
    <span class="s1">out</span><span class="s3">[</span><span class="s1">slc</span><span class="s3">] = </span><span class="s1">structure </span><span class="s3">!= </span><span class="s5">0</span>
    <span class="s1">out </span><span class="s3">= </span><span class="s1">binary_dilation</span><span class="s3">(</span><span class="s1">out</span><span class="s3">, </span><span class="s1">structure</span><span class="s3">, </span><span class="s1">iterations</span><span class="s3">=</span><span class="s1">ni</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">origin </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">out</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">origin </span><span class="s3">= </span><span class="s1">_ni_support</span><span class="s3">.</span><span class="s1">_normalize_sequence</span><span class="s3">(</span><span class="s1">origin</span><span class="s3">, </span><span class="s1">structure</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">)</span>
        <span class="s1">origin </span><span class="s3">= [</span><span class="s1">iterations </span><span class="s3">* </span><span class="s1">o </span><span class="s2">for </span><span class="s1">o </span><span class="s2">in </span><span class="s1">origin</span><span class="s3">]</span>
        <span class="s2">return </span><span class="s1">out</span><span class="s3">, </span><span class="s1">origin</span>


<span class="s2">def </span><span class="s1">generate_binary_structure</span><span class="s3">(</span><span class="s1">rank</span><span class="s3">, </span><span class="s1">connectivity</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Generate a binary structure for binary morphological operations. 
 
    Parameters 
    ---------- 
    rank : int 
         Number of dimensions of the array to which the structuring element 
         will be applied, as returned by `np.ndim`. 
    connectivity : int 
         `connectivity` determines which elements of the output array belong 
         to the structure, i.e., are considered as neighbors of the central 
         element. Elements up to a squared distance of `connectivity` from 
         the center are considered neighbors. `connectivity` may range from 1 
         (no diagonal elements are neighbors) to `rank` (all elements are 
         neighbors). 
 
    Returns 
    ------- 
    output : ndarray of bools 
         Structuring element which may be used for binary morphological 
         operations, with `rank` dimensions and all dimensions equal to 3. 
 
    See Also 
    -------- 
    iterate_structure, binary_dilation, binary_erosion 
 
    Notes 
    ----- 
    `generate_binary_structure` can only create structuring elements with 
    dimensions equal to 3, i.e., minimal dimensions. For larger structuring 
    elements, that are useful e.g., for eroding large objects, one may either 
    use `iterate_structure`, or create directly custom arrays with 
    numpy functions such as `numpy.ones`. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy import ndimage 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; struct = ndimage.generate_binary_structure(2, 1) 
    &gt;&gt;&gt; struct 
    array([[False,  True, False], 
           [ True,  True,  True], 
           [False,  True, False]], dtype=bool) 
    &gt;&gt;&gt; a = np.zeros((5,5)) 
    &gt;&gt;&gt; a[2, 2] = 1 
    &gt;&gt;&gt; a 
    array([[ 0.,  0.,  0.,  0.,  0.], 
           [ 0.,  0.,  0.,  0.,  0.], 
           [ 0.,  0.,  1.,  0.,  0.], 
           [ 0.,  0.,  0.,  0.,  0.], 
           [ 0.,  0.,  0.,  0.,  0.]]) 
    &gt;&gt;&gt; b = ndimage.binary_dilation(a, structure=struct).astype(a.dtype) 
    &gt;&gt;&gt; b 
    array([[ 0.,  0.,  0.,  0.,  0.], 
           [ 0.,  0.,  1.,  0.,  0.], 
           [ 0.,  1.,  1.,  1.,  0.], 
           [ 0.,  0.,  1.,  0.,  0.], 
           [ 0.,  0.,  0.,  0.,  0.]]) 
    &gt;&gt;&gt; ndimage.binary_dilation(b, structure=struct).astype(a.dtype) 
    array([[ 0.,  0.,  1.,  0.,  0.], 
           [ 0.,  1.,  1.,  1.,  0.], 
           [ 1.,  1.,  1.,  1.,  1.], 
           [ 0.,  1.,  1.,  1.,  0.], 
           [ 0.,  0.,  1.,  0.,  0.]]) 
    &gt;&gt;&gt; struct = ndimage.generate_binary_structure(2, 2) 
    &gt;&gt;&gt; struct 
    array([[ True,  True,  True], 
           [ True,  True,  True], 
           [ True,  True,  True]], dtype=bool) 
    &gt;&gt;&gt; struct = ndimage.generate_binary_structure(3, 1) 
    &gt;&gt;&gt; struct # no diagonal elements 
    array([[[False, False, False], 
            [False,  True, False], 
            [False, False, False]], 
           [[False,  True, False], 
            [ True,  True,  True], 
            [False,  True, False]], 
           [[False, False, False], 
            [False,  True, False], 
            [False, False, False]]], dtype=bool) 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">connectivity </span><span class="s3">&lt; </span><span class="s5">1</span><span class="s3">:</span>
        <span class="s1">connectivity </span><span class="s3">= </span><span class="s5">1</span>
    <span class="s2">if </span><span class="s1">rank </span><span class="s3">&lt; </span><span class="s5">1</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s2">True</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">bool</span><span class="s3">)</span>
    <span class="s1">output </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">fabs</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">indices</span><span class="s3">([</span><span class="s5">3</span><span class="s3">] * </span><span class="s1">rank</span><span class="s3">) - </span><span class="s5">1</span><span class="s3">)</span>
    <span class="s1">output </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">add</span><span class="s3">.</span><span class="s1">reduce</span><span class="s3">(</span><span class="s1">output</span><span class="s3">, </span><span class="s5">0</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">output </span><span class="s3">&lt;= </span><span class="s1">connectivity</span>


<span class="s2">def </span><span class="s1">_binary_erosion</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">structure</span><span class="s3">, </span><span class="s1">iterations</span><span class="s3">, </span><span class="s1">mask</span><span class="s3">, </span><span class="s1">output</span><span class="s3">,</span>
                    <span class="s1">border_value</span><span class="s3">, </span><span class="s1">origin</span><span class="s3">, </span><span class="s1">invert</span><span class="s3">, </span><span class="s1">brute_force</span><span class="s3">):</span>
    <span class="s2">try</span><span class="s3">:</span>
        <span class="s1">iterations </span><span class="s3">= </span><span class="s1">operator</span><span class="s3">.</span><span class="s1">index</span><span class="s3">(</span><span class="s1">iterations</span><span class="s3">)</span>
    <span class="s2">except </span><span class="s1">TypeError </span><span class="s2">as </span><span class="s1">e</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s4">'iterations parameter should be an integer'</span><span class="s3">) </span><span class="s2">from </span><span class="s1">e</span>

    <span class="s1">input </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">input</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">iscomplexobj</span><span class="s3">(</span><span class="s1">input</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s4">'Complex type not supported'</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">structure </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">structure </span><span class="s3">= </span><span class="s1">generate_binary_structure</span><span class="s3">(</span><span class="s1">input</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">, </span><span class="s5">1</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">structure </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">structure</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">bool</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">structure</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">!= </span><span class="s1">input</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">RuntimeError</span><span class="s3">(</span><span class="s4">'structure and input must have same dimensionality'</span><span class="s3">)</span>
    <span class="s2">if not </span><span class="s1">structure</span><span class="s3">.</span><span class="s1">flags</span><span class="s3">.</span><span class="s1">contiguous</span><span class="s3">:</span>
        <span class="s1">structure </span><span class="s3">= </span><span class="s1">structure</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>
    <span class="s2">if </span><span class="s1">structure</span><span class="s3">.</span><span class="s1">size </span><span class="s3">&lt; </span><span class="s5">1</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">RuntimeError</span><span class="s3">(</span><span class="s4">'structure must not be empty'</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">mask </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s1">mask </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">mask</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">mask</span><span class="s3">.</span><span class="s1">shape </span><span class="s3">!= </span><span class="s1">input</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">RuntimeError</span><span class="s3">(</span><span class="s4">'mask and input must have equal sizes'</span><span class="s3">)</span>
    <span class="s1">origin </span><span class="s3">= </span><span class="s1">_ni_support</span><span class="s3">.</span><span class="s1">_normalize_sequence</span><span class="s3">(</span><span class="s1">origin</span><span class="s3">, </span><span class="s1">input</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">)</span>
    <span class="s1">cit </span><span class="s3">= </span><span class="s1">_center_is_true</span><span class="s3">(</span><span class="s1">structure</span><span class="s3">, </span><span class="s1">origin</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">output</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndarray</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">iscomplexobj</span><span class="s3">(</span><span class="s1">output</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s4">'Complex output type not supported'</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">output </span><span class="s3">= </span><span class="s1">bool</span>
    <span class="s1">output </span><span class="s3">= </span><span class="s1">_ni_support</span><span class="s3">.</span><span class="s1">_get_output</span><span class="s3">(</span><span class="s1">output</span><span class="s3">, </span><span class="s1">input</span><span class="s3">)</span>
    <span class="s1">temp_needed </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">may_share_memory</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">output</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">temp_needed</span><span class="s3">:</span>
        <span class="s0"># input and output arrays cannot share memory</span>
        <span class="s1">temp </span><span class="s3">= </span><span class="s1">output</span>
        <span class="s1">output </span><span class="s3">= </span><span class="s1">_ni_support</span><span class="s3">.</span><span class="s1">_get_output</span><span class="s3">(</span><span class="s1">output</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">input</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">iterations </span><span class="s3">== </span><span class="s5">1</span><span class="s3">:</span>
        <span class="s1">_nd_image</span><span class="s3">.</span><span class="s1">binary_erosion</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">structure</span><span class="s3">, </span><span class="s1">mask</span><span class="s3">, </span><span class="s1">output</span><span class="s3">,</span>
                                 <span class="s1">border_value</span><span class="s3">, </span><span class="s1">origin</span><span class="s3">, </span><span class="s1">invert</span><span class="s3">, </span><span class="s1">cit</span><span class="s3">, </span><span class="s5">0</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">cit </span><span class="s2">and not </span><span class="s1">brute_force</span><span class="s3">:</span>
        <span class="s1">changed</span><span class="s3">, </span><span class="s1">coordinate_list </span><span class="s3">= </span><span class="s1">_nd_image</span><span class="s3">.</span><span class="s1">binary_erosion</span><span class="s3">(</span>
            <span class="s1">input</span><span class="s3">, </span><span class="s1">structure</span><span class="s3">, </span><span class="s1">mask</span><span class="s3">, </span><span class="s1">output</span><span class="s3">,</span>
            <span class="s1">border_value</span><span class="s3">, </span><span class="s1">origin</span><span class="s3">, </span><span class="s1">invert</span><span class="s3">, </span><span class="s1">cit</span><span class="s3">, </span><span class="s5">1</span><span class="s3">)</span>
        <span class="s1">structure </span><span class="s3">= </span><span class="s1">structure</span><span class="s3">[</span><span class="s1">tuple</span><span class="s3">([</span><span class="s1">slice</span><span class="s3">(</span><span class="s2">None</span><span class="s3">, </span><span class="s2">None</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">)] *</span>
                                    <span class="s1">structure</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">)]</span>
        <span class="s2">for </span><span class="s1">ii </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">origin</span><span class="s3">)):</span>
            <span class="s1">origin</span><span class="s3">[</span><span class="s1">ii</span><span class="s3">] = -</span><span class="s1">origin</span><span class="s3">[</span><span class="s1">ii</span><span class="s3">]</span>
            <span class="s2">if not </span><span class="s1">structure</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s1">ii</span><span class="s3">] &amp; </span><span class="s5">1</span><span class="s3">:</span>
                <span class="s1">origin</span><span class="s3">[</span><span class="s1">ii</span><span class="s3">] -= </span><span class="s5">1</span>
        <span class="s2">if </span><span class="s1">mask </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s1">mask </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">mask</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">int8</span><span class="s3">)</span>
        <span class="s2">if not </span><span class="s1">structure</span><span class="s3">.</span><span class="s1">flags</span><span class="s3">.</span><span class="s1">contiguous</span><span class="s3">:</span>
            <span class="s1">structure </span><span class="s3">= </span><span class="s1">structure</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>
        <span class="s1">_nd_image</span><span class="s3">.</span><span class="s1">binary_erosion2</span><span class="s3">(</span><span class="s1">output</span><span class="s3">, </span><span class="s1">structure</span><span class="s3">, </span><span class="s1">mask</span><span class="s3">, </span><span class="s1">iterations </span><span class="s3">- </span><span class="s5">1</span><span class="s3">,</span>
                                  <span class="s1">origin</span><span class="s3">, </span><span class="s1">invert</span><span class="s3">, </span><span class="s1">coordinate_list</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">tmp_in </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty_like</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">bool</span><span class="s3">)</span>
        <span class="s1">tmp_out </span><span class="s3">= </span><span class="s1">output</span>
        <span class="s2">if </span><span class="s1">iterations </span><span class="s3">&gt;= </span><span class="s5">1 </span><span class="s2">and not </span><span class="s1">iterations </span><span class="s3">&amp; </span><span class="s5">1</span><span class="s3">:</span>
            <span class="s1">tmp_in</span><span class="s3">, </span><span class="s1">tmp_out </span><span class="s3">= </span><span class="s1">tmp_out</span><span class="s3">, </span><span class="s1">tmp_in</span>
        <span class="s1">changed </span><span class="s3">= </span><span class="s1">_nd_image</span><span class="s3">.</span><span class="s1">binary_erosion</span><span class="s3">(</span>
            <span class="s1">input</span><span class="s3">, </span><span class="s1">structure</span><span class="s3">, </span><span class="s1">mask</span><span class="s3">, </span><span class="s1">tmp_out</span><span class="s3">,</span>
            <span class="s1">border_value</span><span class="s3">, </span><span class="s1">origin</span><span class="s3">, </span><span class="s1">invert</span><span class="s3">, </span><span class="s1">cit</span><span class="s3">, </span><span class="s5">0</span><span class="s3">)</span>
        <span class="s1">ii </span><span class="s3">= </span><span class="s5">1</span>
        <span class="s2">while </span><span class="s1">ii </span><span class="s3">&lt; </span><span class="s1">iterations </span><span class="s2">or </span><span class="s3">(</span><span class="s1">iterations </span><span class="s3">&lt; </span><span class="s5">1 </span><span class="s2">and </span><span class="s1">changed</span><span class="s3">):</span>
            <span class="s1">tmp_in</span><span class="s3">, </span><span class="s1">tmp_out </span><span class="s3">= </span><span class="s1">tmp_out</span><span class="s3">, </span><span class="s1">tmp_in</span>
            <span class="s1">changed </span><span class="s3">= </span><span class="s1">_nd_image</span><span class="s3">.</span><span class="s1">binary_erosion</span><span class="s3">(</span>
                <span class="s1">tmp_in</span><span class="s3">, </span><span class="s1">structure</span><span class="s3">, </span><span class="s1">mask</span><span class="s3">, </span><span class="s1">tmp_out</span><span class="s3">,</span>
                <span class="s1">border_value</span><span class="s3">, </span><span class="s1">origin</span><span class="s3">, </span><span class="s1">invert</span><span class="s3">, </span><span class="s1">cit</span><span class="s3">, </span><span class="s5">0</span><span class="s3">)</span>
            <span class="s1">ii </span><span class="s3">+= </span><span class="s5">1</span>
    <span class="s2">if </span><span class="s1">temp_needed</span><span class="s3">:</span>
        <span class="s1">temp</span><span class="s3">[...] = </span><span class="s1">output</span>
        <span class="s1">output </span><span class="s3">= </span><span class="s1">temp</span>
    <span class="s2">return </span><span class="s1">output</span>


<span class="s2">def </span><span class="s1">binary_erosion</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">structure</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">iterations</span><span class="s3">=</span><span class="s5">1</span><span class="s3">, </span><span class="s1">mask</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">output</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
                   <span class="s1">border_value</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">origin</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">brute_force</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Multidimensional binary erosion with a given structuring element. 
 
    Binary erosion is a mathematical morphology operation used for image 
    processing. 
 
    Parameters 
    ---------- 
    input : array_like 
        Binary image to be eroded. Non-zero (True) elements form 
        the subset to be eroded. 
    structure : array_like, optional 
        Structuring element used for the erosion. Non-zero elements are 
        considered True. If no structuring element is provided, an element 
        is generated with a square connectivity equal to one. 
    iterations : int, optional 
        The erosion is repeated `iterations` times (one, by default). 
        If iterations is less than 1, the erosion is repeated until the 
        result does not change anymore. 
    mask : array_like, optional 
        If a mask is given, only those elements with a True value at 
        the corresponding mask element are modified at each iteration. 
    output : ndarray, optional 
        Array of the same shape as input, into which the output is placed. 
        By default, a new array is created. 
    border_value : int (cast to 0 or 1), optional 
        Value at the border in the output array. 
    origin : int or tuple of ints, optional 
        Placement of the filter, by default 0. 
    brute_force : boolean, optional 
        Memory condition: if False, only the pixels whose value was changed in 
        the last iteration are tracked as candidates to be updated (eroded) in 
        the current iteration; if True all pixels are considered as candidates 
        for erosion, regardless of what happened in the previous iteration. 
        False by default. 
 
    Returns 
    ------- 
    binary_erosion : ndarray of bools 
        Erosion of the input by the structuring element. 
 
    See Also 
    -------- 
    grey_erosion, binary_dilation, binary_closing, binary_opening, 
    generate_binary_structure 
 
    Notes 
    ----- 
    Erosion [1]_ is a mathematical morphology operation [2]_ that uses a 
    structuring element for shrinking the shapes in an image. The binary 
    erosion of an image by a structuring element is the locus of the points 
    where a superimposition of the structuring element centered on the point 
    is entirely contained in the set of non-zero elements of the image. 
 
    References 
    ---------- 
    .. [1] https://en.wikipedia.org/wiki/Erosion_%28morphology%29 
    .. [2] https://en.wikipedia.org/wiki/Mathematical_morphology 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy import ndimage 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; a = np.zeros((7,7), dtype=int) 
    &gt;&gt;&gt; a[1:6, 2:5] = 1 
    &gt;&gt;&gt; a 
    array([[0, 0, 0, 0, 0, 0, 0], 
           [0, 0, 1, 1, 1, 0, 0], 
           [0, 0, 1, 1, 1, 0, 0], 
           [0, 0, 1, 1, 1, 0, 0], 
           [0, 0, 1, 1, 1, 0, 0], 
           [0, 0, 1, 1, 1, 0, 0], 
           [0, 0, 0, 0, 0, 0, 0]]) 
    &gt;&gt;&gt; ndimage.binary_erosion(a).astype(a.dtype) 
    array([[0, 0, 0, 0, 0, 0, 0], 
           [0, 0, 0, 0, 0, 0, 0], 
           [0, 0, 0, 1, 0, 0, 0], 
           [0, 0, 0, 1, 0, 0, 0], 
           [0, 0, 0, 1, 0, 0, 0], 
           [0, 0, 0, 0, 0, 0, 0], 
           [0, 0, 0, 0, 0, 0, 0]]) 
    &gt;&gt;&gt; #Erosion removes objects smaller than the structure 
    &gt;&gt;&gt; ndimage.binary_erosion(a, structure=np.ones((5,5))).astype(a.dtype) 
    array([[0, 0, 0, 0, 0, 0, 0], 
           [0, 0, 0, 0, 0, 0, 0], 
           [0, 0, 0, 0, 0, 0, 0], 
           [0, 0, 0, 0, 0, 0, 0], 
           [0, 0, 0, 0, 0, 0, 0], 
           [0, 0, 0, 0, 0, 0, 0], 
           [0, 0, 0, 0, 0, 0, 0]]) 
 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_binary_erosion</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">structure</span><span class="s3">, </span><span class="s1">iterations</span><span class="s3">, </span><span class="s1">mask</span><span class="s3">,</span>
                           <span class="s1">output</span><span class="s3">, </span><span class="s1">border_value</span><span class="s3">, </span><span class="s1">origin</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s1">brute_force</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">binary_dilation</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">structure</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">iterations</span><span class="s3">=</span><span class="s5">1</span><span class="s3">, </span><span class="s1">mask</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
                    <span class="s1">output</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">border_value</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">origin</span><span class="s3">=</span><span class="s5">0</span><span class="s3">,</span>
                    <span class="s1">brute_force</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Multidimensional binary dilation with the given structuring element. 
 
    Parameters 
    ---------- 
    input : array_like 
        Binary array_like to be dilated. Non-zero (True) elements form 
        the subset to be dilated. 
    structure : array_like, optional 
        Structuring element used for the dilation. Non-zero elements are 
        considered True. If no structuring element is provided an element 
        is generated with a square connectivity equal to one. 
    iterations : int, optional 
        The dilation is repeated `iterations` times (one, by default). 
        If iterations is less than 1, the dilation is repeated until the 
        result does not change anymore. Only an integer of iterations is 
        accepted. 
    mask : array_like, optional 
        If a mask is given, only those elements with a True value at 
        the corresponding mask element are modified at each iteration. 
    output : ndarray, optional 
        Array of the same shape as input, into which the output is placed. 
        By default, a new array is created. 
    border_value : int (cast to 0 or 1), optional 
        Value at the border in the output array. 
    origin : int or tuple of ints, optional 
        Placement of the filter, by default 0. 
    brute_force : boolean, optional 
        Memory condition: if False, only the pixels whose value was changed in 
        the last iteration are tracked as candidates to be updated (dilated) 
        in the current iteration; if True all pixels are considered as 
        candidates for dilation, regardless of what happened in the previous 
        iteration. False by default. 
 
    Returns 
    ------- 
    binary_dilation : ndarray of bools 
        Dilation of the input by the structuring element. 
 
    See Also 
    -------- 
    grey_dilation, binary_erosion, binary_closing, binary_opening, 
    generate_binary_structure 
 
    Notes 
    ----- 
    Dilation [1]_ is a mathematical morphology operation [2]_ that uses a 
    structuring element for expanding the shapes in an image. The binary 
    dilation of an image by a structuring element is the locus of the points 
    covered by the structuring element, when its center lies within the 
    non-zero points of the image. 
 
    References 
    ---------- 
    .. [1] https://en.wikipedia.org/wiki/Dilation_%28morphology%29 
    .. [2] https://en.wikipedia.org/wiki/Mathematical_morphology 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy import ndimage 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; a = np.zeros((5, 5)) 
    &gt;&gt;&gt; a[2, 2] = 1 
    &gt;&gt;&gt; a 
    array([[ 0.,  0.,  0.,  0.,  0.], 
           [ 0.,  0.,  0.,  0.,  0.], 
           [ 0.,  0.,  1.,  0.,  0.], 
           [ 0.,  0.,  0.,  0.,  0.], 
           [ 0.,  0.,  0.,  0.,  0.]]) 
    &gt;&gt;&gt; ndimage.binary_dilation(a) 
    array([[False, False, False, False, False], 
           [False, False,  True, False, False], 
           [False,  True,  True,  True, False], 
           [False, False,  True, False, False], 
           [False, False, False, False, False]], dtype=bool) 
    &gt;&gt;&gt; ndimage.binary_dilation(a).astype(a.dtype) 
    array([[ 0.,  0.,  0.,  0.,  0.], 
           [ 0.,  0.,  1.,  0.,  0.], 
           [ 0.,  1.,  1.,  1.,  0.], 
           [ 0.,  0.,  1.,  0.,  0.], 
           [ 0.,  0.,  0.,  0.,  0.]]) 
    &gt;&gt;&gt; # 3x3 structuring element with connectivity 1, used by default 
    &gt;&gt;&gt; struct1 = ndimage.generate_binary_structure(2, 1) 
    &gt;&gt;&gt; struct1 
    array([[False,  True, False], 
           [ True,  True,  True], 
           [False,  True, False]], dtype=bool) 
    &gt;&gt;&gt; # 3x3 structuring element with connectivity 2 
    &gt;&gt;&gt; struct2 = ndimage.generate_binary_structure(2, 2) 
    &gt;&gt;&gt; struct2 
    array([[ True,  True,  True], 
           [ True,  True,  True], 
           [ True,  True,  True]], dtype=bool) 
    &gt;&gt;&gt; ndimage.binary_dilation(a, structure=struct1).astype(a.dtype) 
    array([[ 0.,  0.,  0.,  0.,  0.], 
           [ 0.,  0.,  1.,  0.,  0.], 
           [ 0.,  1.,  1.,  1.,  0.], 
           [ 0.,  0.,  1.,  0.,  0.], 
           [ 0.,  0.,  0.,  0.,  0.]]) 
    &gt;&gt;&gt; ndimage.binary_dilation(a, structure=struct2).astype(a.dtype) 
    array([[ 0.,  0.,  0.,  0.,  0.], 
           [ 0.,  1.,  1.,  1.,  0.], 
           [ 0.,  1.,  1.,  1.,  0.], 
           [ 0.,  1.,  1.,  1.,  0.], 
           [ 0.,  0.,  0.,  0.,  0.]]) 
    &gt;&gt;&gt; ndimage.binary_dilation(a, structure=struct1,\\ 
    ... iterations=2).astype(a.dtype) 
    array([[ 0.,  0.,  1.,  0.,  0.], 
           [ 0.,  1.,  1.,  1.,  0.], 
           [ 1.,  1.,  1.,  1.,  1.], 
           [ 0.,  1.,  1.,  1.,  0.], 
           [ 0.,  0.,  1.,  0.,  0.]]) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">input </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">input</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">structure </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">structure </span><span class="s3">= </span><span class="s1">generate_binary_structure</span><span class="s3">(</span><span class="s1">input</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">, </span><span class="s5">1</span><span class="s3">)</span>
    <span class="s1">origin </span><span class="s3">= </span><span class="s1">_ni_support</span><span class="s3">.</span><span class="s1">_normalize_sequence</span><span class="s3">(</span><span class="s1">origin</span><span class="s3">, </span><span class="s1">input</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">)</span>
    <span class="s1">structure </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">structure</span><span class="s3">)</span>
    <span class="s1">structure </span><span class="s3">= </span><span class="s1">structure</span><span class="s3">[</span><span class="s1">tuple</span><span class="s3">([</span><span class="s1">slice</span><span class="s3">(</span><span class="s2">None</span><span class="s3">, </span><span class="s2">None</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">)] *</span>
                                <span class="s1">structure</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">)]</span>
    <span class="s2">for </span><span class="s1">ii </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">origin</span><span class="s3">)):</span>
        <span class="s1">origin</span><span class="s3">[</span><span class="s1">ii</span><span class="s3">] = -</span><span class="s1">origin</span><span class="s3">[</span><span class="s1">ii</span><span class="s3">]</span>
        <span class="s2">if not </span><span class="s1">structure</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s1">ii</span><span class="s3">] &amp; </span><span class="s5">1</span><span class="s3">:</span>
            <span class="s1">origin</span><span class="s3">[</span><span class="s1">ii</span><span class="s3">] -= </span><span class="s5">1</span>

    <span class="s2">return </span><span class="s1">_binary_erosion</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">structure</span><span class="s3">, </span><span class="s1">iterations</span><span class="s3">, </span><span class="s1">mask</span><span class="s3">,</span>
                           <span class="s1">output</span><span class="s3">, </span><span class="s1">border_value</span><span class="s3">, </span><span class="s1">origin</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s1">brute_force</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">binary_opening</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">structure</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">iterations</span><span class="s3">=</span><span class="s5">1</span><span class="s3">, </span><span class="s1">output</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
                   <span class="s1">origin</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">mask</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">border_value</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">brute_force</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Multidimensional binary opening with the given structuring element. 
 
    The *opening* of an input image by a structuring element is the 
    *dilation* of the *erosion* of the image by the structuring element. 
 
    Parameters 
    ---------- 
    input : array_like 
        Binary array_like to be opened. Non-zero (True) elements form 
        the subset to be opened. 
    structure : array_like, optional 
        Structuring element used for the opening. Non-zero elements are 
        considered True. If no structuring element is provided an element 
        is generated with a square connectivity equal to one (i.e., only 
        nearest neighbors are connected to the center, diagonally-connected 
        elements are not considered neighbors). 
    iterations : int, optional 
        The erosion step of the opening, then the dilation step are each 
        repeated `iterations` times (one, by default). If `iterations` is 
        less than 1, each operation is repeated until the result does 
        not change anymore. Only an integer of iterations is accepted. 
    output : ndarray, optional 
        Array of the same shape as input, into which the output is placed. 
        By default, a new array is created. 
    origin : int or tuple of ints, optional 
        Placement of the filter, by default 0. 
    mask : array_like, optional 
        If a mask is given, only those elements with a True value at 
        the corresponding mask element are modified at each iteration. 
 
        .. versionadded:: 1.1.0 
    border_value : int (cast to 0 or 1), optional 
        Value at the border in the output array. 
 
        .. versionadded:: 1.1.0 
    brute_force : boolean, optional 
        Memory condition: if False, only the pixels whose value was changed in 
        the last iteration are tracked as candidates to be updated in the 
        current iteration; if true all pixels are considered as candidates for 
        update, regardless of what happened in the previous iteration. 
        False by default. 
 
        .. versionadded:: 1.1.0 
 
    Returns 
    ------- 
    binary_opening : ndarray of bools 
        Opening of the input by the structuring element. 
 
    See Also 
    -------- 
    grey_opening, binary_closing, binary_erosion, binary_dilation, 
    generate_binary_structure 
 
    Notes 
    ----- 
    *Opening* [1]_ is a mathematical morphology operation [2]_ that 
    consists in the succession of an erosion and a dilation of the 
    input with the same structuring element. Opening, therefore, removes 
    objects smaller than the structuring element. 
 
    Together with *closing* (`binary_closing`), opening can be used for 
    noise removal. 
 
    References 
    ---------- 
    .. [1] https://en.wikipedia.org/wiki/Opening_%28morphology%29 
    .. [2] https://en.wikipedia.org/wiki/Mathematical_morphology 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy import ndimage 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; a = np.zeros((5,5), dtype=int) 
    &gt;&gt;&gt; a[1:4, 1:4] = 1; a[4, 4] = 1 
    &gt;&gt;&gt; a 
    array([[0, 0, 0, 0, 0], 
           [0, 1, 1, 1, 0], 
           [0, 1, 1, 1, 0], 
           [0, 1, 1, 1, 0], 
           [0, 0, 0, 0, 1]]) 
    &gt;&gt;&gt; # Opening removes small objects 
    &gt;&gt;&gt; ndimage.binary_opening(a, structure=np.ones((3,3))).astype(int) 
    array([[0, 0, 0, 0, 0], 
           [0, 1, 1, 1, 0], 
           [0, 1, 1, 1, 0], 
           [0, 1, 1, 1, 0], 
           [0, 0, 0, 0, 0]]) 
    &gt;&gt;&gt; # Opening can also smooth corners 
    &gt;&gt;&gt; ndimage.binary_opening(a).astype(int) 
    array([[0, 0, 0, 0, 0], 
           [0, 0, 1, 0, 0], 
           [0, 1, 1, 1, 0], 
           [0, 0, 1, 0, 0], 
           [0, 0, 0, 0, 0]]) 
    &gt;&gt;&gt; # Opening is the dilation of the erosion of the input 
    &gt;&gt;&gt; ndimage.binary_erosion(a).astype(int) 
    array([[0, 0, 0, 0, 0], 
           [0, 0, 0, 0, 0], 
           [0, 0, 1, 0, 0], 
           [0, 0, 0, 0, 0], 
           [0, 0, 0, 0, 0]]) 
    &gt;&gt;&gt; ndimage.binary_dilation(ndimage.binary_erosion(a)).astype(int) 
    array([[0, 0, 0, 0, 0], 
           [0, 0, 1, 0, 0], 
           [0, 1, 1, 1, 0], 
           [0, 0, 1, 0, 0], 
           [0, 0, 0, 0, 0]]) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">input </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">input</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">structure </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">rank </span><span class="s3">= </span><span class="s1">input</span><span class="s3">.</span><span class="s1">ndim</span>
        <span class="s1">structure </span><span class="s3">= </span><span class="s1">generate_binary_structure</span><span class="s3">(</span><span class="s1">rank</span><span class="s3">, </span><span class="s5">1</span><span class="s3">)</span>

    <span class="s1">tmp </span><span class="s3">= </span><span class="s1">binary_erosion</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">structure</span><span class="s3">, </span><span class="s1">iterations</span><span class="s3">, </span><span class="s1">mask</span><span class="s3">, </span><span class="s2">None</span><span class="s3">,</span>
                         <span class="s1">border_value</span><span class="s3">, </span><span class="s1">origin</span><span class="s3">, </span><span class="s1">brute_force</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">binary_dilation</span><span class="s3">(</span><span class="s1">tmp</span><span class="s3">, </span><span class="s1">structure</span><span class="s3">, </span><span class="s1">iterations</span><span class="s3">, </span><span class="s1">mask</span><span class="s3">, </span><span class="s1">output</span><span class="s3">,</span>
                           <span class="s1">border_value</span><span class="s3">, </span><span class="s1">origin</span><span class="s3">, </span><span class="s1">brute_force</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">binary_closing</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">structure</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">iterations</span><span class="s3">=</span><span class="s5">1</span><span class="s3">, </span><span class="s1">output</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
                   <span class="s1">origin</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">mask</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">border_value</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">brute_force</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Multidimensional binary closing with the given structuring element. 
 
    The *closing* of an input image by a structuring element is the 
    *erosion* of the *dilation* of the image by the structuring element. 
 
    Parameters 
    ---------- 
    input : array_like 
        Binary array_like to be closed. Non-zero (True) elements form 
        the subset to be closed. 
    structure : array_like, optional 
        Structuring element used for the closing. Non-zero elements are 
        considered True. If no structuring element is provided an element 
        is generated with a square connectivity equal to one (i.e., only 
        nearest neighbors are connected to the center, diagonally-connected 
        elements are not considered neighbors). 
    iterations : int, optional 
        The dilation step of the closing, then the erosion step are each 
        repeated `iterations` times (one, by default). If iterations is 
        less than 1, each operations is repeated until the result does 
        not change anymore. Only an integer of iterations is accepted. 
    output : ndarray, optional 
        Array of the same shape as input, into which the output is placed. 
        By default, a new array is created. 
    origin : int or tuple of ints, optional 
        Placement of the filter, by default 0. 
    mask : array_like, optional 
        If a mask is given, only those elements with a True value at 
        the corresponding mask element are modified at each iteration. 
 
        .. versionadded:: 1.1.0 
    border_value : int (cast to 0 or 1), optional 
        Value at the border in the output array. 
 
        .. versionadded:: 1.1.0 
    brute_force : boolean, optional 
        Memory condition: if False, only the pixels whose value was changed in 
        the last iteration are tracked as candidates to be updated in the 
        current iteration; if true al pixels are considered as candidates for 
        update, regardless of what happened in the previous iteration. 
        False by default. 
 
        .. versionadded:: 1.1.0 
 
    Returns 
    ------- 
    binary_closing : ndarray of bools 
        Closing of the input by the structuring element. 
 
    See Also 
    -------- 
    grey_closing, binary_opening, binary_dilation, binary_erosion, 
    generate_binary_structure 
 
    Notes 
    ----- 
    *Closing* [1]_ is a mathematical morphology operation [2]_ that 
    consists in the succession of a dilation and an erosion of the 
    input with the same structuring element. Closing therefore fills 
    holes smaller than the structuring element. 
 
    Together with *opening* (`binary_opening`), closing can be used for 
    noise removal. 
 
    References 
    ---------- 
    .. [1] https://en.wikipedia.org/wiki/Closing_%28morphology%29 
    .. [2] https://en.wikipedia.org/wiki/Mathematical_morphology 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy import ndimage 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; a = np.zeros((5,5), dtype=int) 
    &gt;&gt;&gt; a[1:-1, 1:-1] = 1; a[2,2] = 0 
    &gt;&gt;&gt; a 
    array([[0, 0, 0, 0, 0], 
           [0, 1, 1, 1, 0], 
           [0, 1, 0, 1, 0], 
           [0, 1, 1, 1, 0], 
           [0, 0, 0, 0, 0]]) 
    &gt;&gt;&gt; # Closing removes small holes 
    &gt;&gt;&gt; ndimage.binary_closing(a).astype(int) 
    array([[0, 0, 0, 0, 0], 
           [0, 1, 1, 1, 0], 
           [0, 1, 1, 1, 0], 
           [0, 1, 1, 1, 0], 
           [0, 0, 0, 0, 0]]) 
    &gt;&gt;&gt; # Closing is the erosion of the dilation of the input 
    &gt;&gt;&gt; ndimage.binary_dilation(a).astype(int) 
    array([[0, 1, 1, 1, 0], 
           [1, 1, 1, 1, 1], 
           [1, 1, 1, 1, 1], 
           [1, 1, 1, 1, 1], 
           [0, 1, 1, 1, 0]]) 
    &gt;&gt;&gt; ndimage.binary_erosion(ndimage.binary_dilation(a)).astype(int) 
    array([[0, 0, 0, 0, 0], 
           [0, 1, 1, 1, 0], 
           [0, 1, 1, 1, 0], 
           [0, 1, 1, 1, 0], 
           [0, 0, 0, 0, 0]]) 
 
 
    &gt;&gt;&gt; a = np.zeros((7,7), dtype=int) 
    &gt;&gt;&gt; a[1:6, 2:5] = 1; a[1:3,3] = 0 
    &gt;&gt;&gt; a 
    array([[0, 0, 0, 0, 0, 0, 0], 
           [0, 0, 1, 0, 1, 0, 0], 
           [0, 0, 1, 0, 1, 0, 0], 
           [0, 0, 1, 1, 1, 0, 0], 
           [0, 0, 1, 1, 1, 0, 0], 
           [0, 0, 1, 1, 1, 0, 0], 
           [0, 0, 0, 0, 0, 0, 0]]) 
    &gt;&gt;&gt; # In addition to removing holes, closing can also 
    &gt;&gt;&gt; # coarsen boundaries with fine hollows. 
    &gt;&gt;&gt; ndimage.binary_closing(a).astype(int) 
    array([[0, 0, 0, 0, 0, 0, 0], 
           [0, 0, 1, 0, 1, 0, 0], 
           [0, 0, 1, 1, 1, 0, 0], 
           [0, 0, 1, 1, 1, 0, 0], 
           [0, 0, 1, 1, 1, 0, 0], 
           [0, 0, 1, 1, 1, 0, 0], 
           [0, 0, 0, 0, 0, 0, 0]]) 
    &gt;&gt;&gt; ndimage.binary_closing(a, structure=np.ones((2,2))).astype(int) 
    array([[0, 0, 0, 0, 0, 0, 0], 
           [0, 0, 1, 1, 1, 0, 0], 
           [0, 0, 1, 1, 1, 0, 0], 
           [0, 0, 1, 1, 1, 0, 0], 
           [0, 0, 1, 1, 1, 0, 0], 
           [0, 0, 1, 1, 1, 0, 0], 
           [0, 0, 0, 0, 0, 0, 0]]) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">input </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">input</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">structure </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">rank </span><span class="s3">= </span><span class="s1">input</span><span class="s3">.</span><span class="s1">ndim</span>
        <span class="s1">structure </span><span class="s3">= </span><span class="s1">generate_binary_structure</span><span class="s3">(</span><span class="s1">rank</span><span class="s3">, </span><span class="s5">1</span><span class="s3">)</span>

    <span class="s1">tmp </span><span class="s3">= </span><span class="s1">binary_dilation</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">structure</span><span class="s3">, </span><span class="s1">iterations</span><span class="s3">, </span><span class="s1">mask</span><span class="s3">, </span><span class="s2">None</span><span class="s3">,</span>
                          <span class="s1">border_value</span><span class="s3">, </span><span class="s1">origin</span><span class="s3">, </span><span class="s1">brute_force</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">binary_erosion</span><span class="s3">(</span><span class="s1">tmp</span><span class="s3">, </span><span class="s1">structure</span><span class="s3">, </span><span class="s1">iterations</span><span class="s3">, </span><span class="s1">mask</span><span class="s3">, </span><span class="s1">output</span><span class="s3">,</span>
                          <span class="s1">border_value</span><span class="s3">, </span><span class="s1">origin</span><span class="s3">, </span><span class="s1">brute_force</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">binary_hit_or_miss</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">structure1</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">structure2</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
                       <span class="s1">output</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">origin1</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">origin2</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Multidimensional binary hit-or-miss transform. 
 
    The hit-or-miss transform finds the locations of a given pattern 
    inside the input image. 
 
    Parameters 
    ---------- 
    input : array_like (cast to booleans) 
        Binary image where a pattern is to be detected. 
    structure1 : array_like (cast to booleans), optional 
        Part of the structuring element to be fitted to the foreground 
        (non-zero elements) of `input`. If no value is provided, a 
        structure of square connectivity 1 is chosen. 
    structure2 : array_like (cast to booleans), optional 
        Second part of the structuring element that has to miss completely 
        the foreground. If no value is provided, the complementary of 
        `structure1` is taken. 
    output : ndarray, optional 
        Array of the same shape as input, into which the output is placed. 
        By default, a new array is created. 
    origin1 : int or tuple of ints, optional 
        Placement of the first part of the structuring element `structure1`, 
        by default 0 for a centered structure. 
    origin2 : int or tuple of ints, optional 
        Placement of the second part of the structuring element `structure2`, 
        by default 0 for a centered structure. If a value is provided for 
        `origin1` and not for `origin2`, then `origin2` is set to `origin1`. 
 
    Returns 
    ------- 
    binary_hit_or_miss : ndarray 
        Hit-or-miss transform of `input` with the given structuring 
        element (`structure1`, `structure2`). 
 
    See Also 
    -------- 
    binary_erosion 
 
    References 
    ---------- 
    .. [1] https://en.wikipedia.org/wiki/Hit-or-miss_transform 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy import ndimage 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; a = np.zeros((7,7), dtype=int) 
    &gt;&gt;&gt; a[1, 1] = 1; a[2:4, 2:4] = 1; a[4:6, 4:6] = 1 
    &gt;&gt;&gt; a 
    array([[0, 0, 0, 0, 0, 0, 0], 
           [0, 1, 0, 0, 0, 0, 0], 
           [0, 0, 1, 1, 0, 0, 0], 
           [0, 0, 1, 1, 0, 0, 0], 
           [0, 0, 0, 0, 1, 1, 0], 
           [0, 0, 0, 0, 1, 1, 0], 
           [0, 0, 0, 0, 0, 0, 0]]) 
    &gt;&gt;&gt; structure1 = np.array([[1, 0, 0], [0, 1, 1], [0, 1, 1]]) 
    &gt;&gt;&gt; structure1 
    array([[1, 0, 0], 
           [0, 1, 1], 
           [0, 1, 1]]) 
    &gt;&gt;&gt; # Find the matches of structure1 in the array a 
    &gt;&gt;&gt; ndimage.binary_hit_or_miss(a, structure1=structure1).astype(int) 
    array([[0, 0, 0, 0, 0, 0, 0], 
           [0, 0, 0, 0, 0, 0, 0], 
           [0, 0, 1, 0, 0, 0, 0], 
           [0, 0, 0, 0, 0, 0, 0], 
           [0, 0, 0, 0, 1, 0, 0], 
           [0, 0, 0, 0, 0, 0, 0], 
           [0, 0, 0, 0, 0, 0, 0]]) 
    &gt;&gt;&gt; # Change the origin of the filter 
    &gt;&gt;&gt; # origin1=1 is equivalent to origin1=(1,1) here 
    &gt;&gt;&gt; ndimage.binary_hit_or_miss(a, structure1=structure1,\\ 
    ... origin1=1).astype(int) 
    array([[0, 0, 0, 0, 0, 0, 0], 
           [0, 0, 0, 0, 0, 0, 0], 
           [0, 0, 0, 0, 0, 0, 0], 
           [0, 0, 0, 1, 0, 0, 0], 
           [0, 0, 0, 0, 0, 0, 0], 
           [0, 0, 0, 0, 0, 1, 0], 
           [0, 0, 0, 0, 0, 0, 0]]) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">input </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">input</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">structure1 </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">structure1 </span><span class="s3">= </span><span class="s1">generate_binary_structure</span><span class="s3">(</span><span class="s1">input</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">, </span><span class="s5">1</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">structure2 </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">structure2 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">logical_not</span><span class="s3">(</span><span class="s1">structure1</span><span class="s3">)</span>
    <span class="s1">origin1 </span><span class="s3">= </span><span class="s1">_ni_support</span><span class="s3">.</span><span class="s1">_normalize_sequence</span><span class="s3">(</span><span class="s1">origin1</span><span class="s3">, </span><span class="s1">input</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">origin2 </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">origin2 </span><span class="s3">= </span><span class="s1">origin1</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">origin2 </span><span class="s3">= </span><span class="s1">_ni_support</span><span class="s3">.</span><span class="s1">_normalize_sequence</span><span class="s3">(</span><span class="s1">origin2</span><span class="s3">, </span><span class="s1">input</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">)</span>

    <span class="s1">tmp1 </span><span class="s3">= </span><span class="s1">_binary_erosion</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">structure1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s2">None</span><span class="s3">, </span><span class="s2">None</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s1">origin1</span><span class="s3">,</span>
                           <span class="s5">0</span><span class="s3">, </span><span class="s2">False</span><span class="s3">)</span>
    <span class="s1">inplace </span><span class="s3">= </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">output</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndarray</span><span class="s3">)</span>
    <span class="s1">result </span><span class="s3">= </span><span class="s1">_binary_erosion</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">structure2</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s2">None</span><span class="s3">, </span><span class="s1">output</span><span class="s3">, </span><span class="s5">0</span><span class="s3">,</span>
                             <span class="s1">origin2</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s2">False</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">inplace</span><span class="s3">:</span>
        <span class="s1">np</span><span class="s3">.</span><span class="s1">logical_not</span><span class="s3">(</span><span class="s1">output</span><span class="s3">, </span><span class="s1">output</span><span class="s3">)</span>
        <span class="s1">np</span><span class="s3">.</span><span class="s1">logical_and</span><span class="s3">(</span><span class="s1">tmp1</span><span class="s3">, </span><span class="s1">output</span><span class="s3">, </span><span class="s1">output</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">np</span><span class="s3">.</span><span class="s1">logical_not</span><span class="s3">(</span><span class="s1">result</span><span class="s3">, </span><span class="s1">result</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">logical_and</span><span class="s3">(</span><span class="s1">tmp1</span><span class="s3">, </span><span class="s1">result</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">binary_propagation</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">structure</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">mask</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
                       <span class="s1">output</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">border_value</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">origin</span><span class="s3">=</span><span class="s5">0</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Multidimensional binary propagation with the given structuring element. 
 
    Parameters 
    ---------- 
    input : array_like 
        Binary image to be propagated inside `mask`. 
    structure : array_like, optional 
        Structuring element used in the successive dilations. The output 
        may depend on the structuring element, especially if `mask` has 
        several connex components. If no structuring element is 
        provided, an element is generated with a squared connectivity equal 
        to one. 
    mask : array_like, optional 
        Binary mask defining the region into which `input` is allowed to 
        propagate. 
    output : ndarray, optional 
        Array of the same shape as input, into which the output is placed. 
        By default, a new array is created. 
    border_value : int (cast to 0 or 1), optional 
        Value at the border in the output array. 
    origin : int or tuple of ints, optional 
        Placement of the filter, by default 0. 
 
    Returns 
    ------- 
    binary_propagation : ndarray 
        Binary propagation of `input` inside `mask`. 
 
    Notes 
    ----- 
    This function is functionally equivalent to calling binary_dilation 
    with the number of iterations less than one: iterative dilation until 
    the result does not change anymore. 
 
    The succession of an erosion and propagation inside the original image 
    can be used instead of an *opening* for deleting small objects while 
    keeping the contours of larger objects untouched. 
 
    References 
    ---------- 
    .. [1] http://cmm.ensmp.fr/~serra/cours/pdf/en/ch6en.pdf, slide 15. 
    .. [2] I.T. Young, J.J. Gerbrands, and L.J. van Vliet, &quot;Fundamentals of 
        image processing&quot;, 1998 
        ftp://qiftp.tudelft.nl/DIPimage/docs/FIP2.3.pdf 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy import ndimage 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; input = np.zeros((8, 8), dtype=int) 
    &gt;&gt;&gt; input[2, 2] = 1 
    &gt;&gt;&gt; mask = np.zeros((8, 8), dtype=int) 
    &gt;&gt;&gt; mask[1:4, 1:4] = mask[4, 4]  = mask[6:8, 6:8] = 1 
    &gt;&gt;&gt; input 
    array([[0, 0, 0, 0, 0, 0, 0, 0], 
           [0, 0, 0, 0, 0, 0, 0, 0], 
           [0, 0, 1, 0, 0, 0, 0, 0], 
           [0, 0, 0, 0, 0, 0, 0, 0], 
           [0, 0, 0, 0, 0, 0, 0, 0], 
           [0, 0, 0, 0, 0, 0, 0, 0], 
           [0, 0, 0, 0, 0, 0, 0, 0], 
           [0, 0, 0, 0, 0, 0, 0, 0]]) 
    &gt;&gt;&gt; mask 
    array([[0, 0, 0, 0, 0, 0, 0, 0], 
           [0, 1, 1, 1, 0, 0, 0, 0], 
           [0, 1, 1, 1, 0, 0, 0, 0], 
           [0, 1, 1, 1, 0, 0, 0, 0], 
           [0, 0, 0, 0, 1, 0, 0, 0], 
           [0, 0, 0, 0, 0, 0, 0, 0], 
           [0, 0, 0, 0, 0, 0, 1, 1], 
           [0, 0, 0, 0, 0, 0, 1, 1]]) 
    &gt;&gt;&gt; ndimage.binary_propagation(input, mask=mask).astype(int) 
    array([[0, 0, 0, 0, 0, 0, 0, 0], 
           [0, 1, 1, 1, 0, 0, 0, 0], 
           [0, 1, 1, 1, 0, 0, 0, 0], 
           [0, 1, 1, 1, 0, 0, 0, 0], 
           [0, 0, 0, 0, 0, 0, 0, 0], 
           [0, 0, 0, 0, 0, 0, 0, 0], 
           [0, 0, 0, 0, 0, 0, 0, 0], 
           [0, 0, 0, 0, 0, 0, 0, 0]]) 
    &gt;&gt;&gt; ndimage.binary_propagation(input, mask=mask,\\ 
    ... structure=np.ones((3,3))).astype(int) 
    array([[0, 0, 0, 0, 0, 0, 0, 0], 
           [0, 1, 1, 1, 0, 0, 0, 0], 
           [0, 1, 1, 1, 0, 0, 0, 0], 
           [0, 1, 1, 1, 0, 0, 0, 0], 
           [0, 0, 0, 0, 1, 0, 0, 0], 
           [0, 0, 0, 0, 0, 0, 0, 0], 
           [0, 0, 0, 0, 0, 0, 0, 0], 
           [0, 0, 0, 0, 0, 0, 0, 0]]) 
 
    &gt;&gt;&gt; # Comparison between opening and erosion+propagation 
    &gt;&gt;&gt; a = np.zeros((6,6), dtype=int) 
    &gt;&gt;&gt; a[2:5, 2:5] = 1; a[0, 0] = 1; a[5, 5] = 1 
    &gt;&gt;&gt; a 
    array([[1, 0, 0, 0, 0, 0], 
           [0, 0, 0, 0, 0, 0], 
           [0, 0, 1, 1, 1, 0], 
           [0, 0, 1, 1, 1, 0], 
           [0, 0, 1, 1, 1, 0], 
           [0, 0, 0, 0, 0, 1]]) 
    &gt;&gt;&gt; ndimage.binary_opening(a).astype(int) 
    array([[0, 0, 0, 0, 0, 0], 
           [0, 0, 0, 0, 0, 0], 
           [0, 0, 0, 1, 0, 0], 
           [0, 0, 1, 1, 1, 0], 
           [0, 0, 0, 1, 0, 0], 
           [0, 0, 0, 0, 0, 0]]) 
    &gt;&gt;&gt; b = ndimage.binary_erosion(a) 
    &gt;&gt;&gt; b.astype(int) 
    array([[0, 0, 0, 0, 0, 0], 
           [0, 0, 0, 0, 0, 0], 
           [0, 0, 0, 0, 0, 0], 
           [0, 0, 0, 1, 0, 0], 
           [0, 0, 0, 0, 0, 0], 
           [0, 0, 0, 0, 0, 0]]) 
    &gt;&gt;&gt; ndimage.binary_propagation(b, mask=a).astype(int) 
    array([[0, 0, 0, 0, 0, 0], 
           [0, 0, 0, 0, 0, 0], 
           [0, 0, 1, 1, 1, 0], 
           [0, 0, 1, 1, 1, 0], 
           [0, 0, 1, 1, 1, 0], 
           [0, 0, 0, 0, 0, 0]]) 
 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">binary_dilation</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">structure</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">, </span><span class="s1">mask</span><span class="s3">, </span><span class="s1">output</span><span class="s3">,</span>
                           <span class="s1">border_value</span><span class="s3">, </span><span class="s1">origin</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">binary_fill_holes</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">structure</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">output</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">origin</span><span class="s3">=</span><span class="s5">0</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Fill the holes in binary objects. 
 
 
    Parameters 
    ---------- 
    input : array_like 
        N-D binary array with holes to be filled 
    structure : array_like, optional 
        Structuring element used in the computation; large-size elements 
        make computations faster but may miss holes separated from the 
        background by thin regions. The default element (with a square 
        connectivity equal to one) yields the intuitive result where all 
        holes in the input have been filled. 
    output : ndarray, optional 
        Array of the same shape as input, into which the output is placed. 
        By default, a new array is created. 
    origin : int, tuple of ints, optional 
        Position of the structuring element. 
 
    Returns 
    ------- 
    out : ndarray 
        Transformation of the initial image `input` where holes have been 
        filled. 
 
    See Also 
    -------- 
    binary_dilation, binary_propagation, label 
 
    Notes 
    ----- 
    The algorithm used in this function consists in invading the complementary 
    of the shapes in `input` from the outer boundary of the image, 
    using binary dilations. Holes are not connected to the boundary and are 
    therefore not invaded. The result is the complementary subset of the 
    invaded region. 
 
    References 
    ---------- 
    .. [1] https://en.wikipedia.org/wiki/Mathematical_morphology 
 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy import ndimage 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; a = np.zeros((5, 5), dtype=int) 
    &gt;&gt;&gt; a[1:4, 1:4] = 1 
    &gt;&gt;&gt; a[2,2] = 0 
    &gt;&gt;&gt; a 
    array([[0, 0, 0, 0, 0], 
           [0, 1, 1, 1, 0], 
           [0, 1, 0, 1, 0], 
           [0, 1, 1, 1, 0], 
           [0, 0, 0, 0, 0]]) 
    &gt;&gt;&gt; ndimage.binary_fill_holes(a).astype(int) 
    array([[0, 0, 0, 0, 0], 
           [0, 1, 1, 1, 0], 
           [0, 1, 1, 1, 0], 
           [0, 1, 1, 1, 0], 
           [0, 0, 0, 0, 0]]) 
    &gt;&gt;&gt; # Too big structuring element 
    &gt;&gt;&gt; ndimage.binary_fill_holes(a, structure=np.ones((5,5))).astype(int) 
    array([[0, 0, 0, 0, 0], 
           [0, 1, 1, 1, 0], 
           [0, 1, 0, 1, 0], 
           [0, 1, 1, 1, 0], 
           [0, 0, 0, 0, 0]]) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">mask </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">logical_not</span><span class="s3">(</span><span class="s1">input</span><span class="s3">)</span>
    <span class="s1">tmp </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">mask</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">bool</span><span class="s3">)</span>
    <span class="s1">inplace </span><span class="s3">= </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">output</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndarray</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">inplace</span><span class="s3">:</span>
        <span class="s1">binary_dilation</span><span class="s3">(</span><span class="s1">tmp</span><span class="s3">, </span><span class="s1">structure</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">, </span><span class="s1">mask</span><span class="s3">, </span><span class="s1">output</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s1">origin</span><span class="s3">)</span>
        <span class="s1">np</span><span class="s3">.</span><span class="s1">logical_not</span><span class="s3">(</span><span class="s1">output</span><span class="s3">, </span><span class="s1">output</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">output </span><span class="s3">= </span><span class="s1">binary_dilation</span><span class="s3">(</span><span class="s1">tmp</span><span class="s3">, </span><span class="s1">structure</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">, </span><span class="s1">mask</span><span class="s3">, </span><span class="s2">None</span><span class="s3">, </span><span class="s5">1</span><span class="s3">,</span>
                                 <span class="s1">origin</span><span class="s3">)</span>
        <span class="s1">np</span><span class="s3">.</span><span class="s1">logical_not</span><span class="s3">(</span><span class="s1">output</span><span class="s3">, </span><span class="s1">output</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">output</span>


<span class="s2">def </span><span class="s1">grey_erosion</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">footprint</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">structure</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
                 <span class="s1">output</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">=</span><span class="s4">&quot;reflect&quot;</span><span class="s3">, </span><span class="s1">cval</span><span class="s3">=</span><span class="s5">0.0</span><span class="s3">, </span><span class="s1">origin</span><span class="s3">=</span><span class="s5">0</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Calculate a greyscale erosion, using either a structuring element, 
    or a footprint corresponding to a flat structuring element. 
 
    Grayscale erosion is a mathematical morphology operation. For the 
    simple case of a full and flat structuring element, it can be viewed 
    as a minimum filter over a sliding window. 
 
    Parameters 
    ---------- 
    input : array_like 
        Array over which the grayscale erosion is to be computed. 
    size : tuple of ints 
        Shape of a flat and full structuring element used for the grayscale 
        erosion. Optional if `footprint` or `structure` is provided. 
    footprint : array of ints, optional 
        Positions of non-infinite elements of a flat structuring element 
        used for the grayscale erosion. Non-zero values give the set of 
        neighbors of the center over which the minimum is chosen. 
    structure : array of ints, optional 
        Structuring element used for the grayscale erosion. `structure` 
        may be a non-flat structuring element. The `structure` array applies a 
        subtractive offset for each pixel in the neighborhood. 
    output : array, optional 
        An array used for storing the output of the erosion may be provided. 
    mode : {'reflect','constant','nearest','mirror', 'wrap'}, optional 
        The `mode` parameter determines how the array borders are 
        handled, where `cval` is the value when mode is equal to 
        'constant'. Default is 'reflect' 
    cval : scalar, optional 
        Value to fill past edges of input if `mode` is 'constant'. Default 
        is 0.0. 
    origin : scalar, optional 
        The `origin` parameter controls the placement of the filter. 
        Default 0 
 
    Returns 
    ------- 
    output : ndarray 
        Grayscale erosion of `input`. 
 
    See Also 
    -------- 
    binary_erosion, grey_dilation, grey_opening, grey_closing 
    generate_binary_structure, minimum_filter 
 
    Notes 
    ----- 
    The grayscale erosion of an image input by a structuring element s defined 
    over a domain E is given by: 
 
    (input+s)(x) = min {input(y) - s(x-y), for y in E} 
 
    In particular, for structuring elements defined as 
    s(y) = 0 for y in E, the grayscale erosion computes the minimum of the 
    input image inside a sliding window defined by E. 
 
    Grayscale erosion [1]_ is a *mathematical morphology* operation [2]_. 
 
    References 
    ---------- 
    .. [1] https://en.wikipedia.org/wiki/Erosion_%28morphology%29 
    .. [2] https://en.wikipedia.org/wiki/Mathematical_morphology 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy import ndimage 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; a = np.zeros((7,7), dtype=int) 
    &gt;&gt;&gt; a[1:6, 1:6] = 3 
    &gt;&gt;&gt; a[4,4] = 2; a[2,3] = 1 
    &gt;&gt;&gt; a 
    array([[0, 0, 0, 0, 0, 0, 0], 
           [0, 3, 3, 3, 3, 3, 0], 
           [0, 3, 3, 1, 3, 3, 0], 
           [0, 3, 3, 3, 3, 3, 0], 
           [0, 3, 3, 3, 2, 3, 0], 
           [0, 3, 3, 3, 3, 3, 0], 
           [0, 0, 0, 0, 0, 0, 0]]) 
    &gt;&gt;&gt; ndimage.grey_erosion(a, size=(3,3)) 
    array([[0, 0, 0, 0, 0, 0, 0], 
           [0, 0, 0, 0, 0, 0, 0], 
           [0, 0, 1, 1, 1, 0, 0], 
           [0, 0, 1, 1, 1, 0, 0], 
           [0, 0, 3, 2, 2, 0, 0], 
           [0, 0, 0, 0, 0, 0, 0], 
           [0, 0, 0, 0, 0, 0, 0]]) 
    &gt;&gt;&gt; footprint = ndimage.generate_binary_structure(2, 1) 
    &gt;&gt;&gt; footprint 
    array([[False,  True, False], 
           [ True,  True,  True], 
           [False,  True, False]], dtype=bool) 
    &gt;&gt;&gt; # Diagonally-connected elements are not considered neighbors 
    &gt;&gt;&gt; ndimage.grey_erosion(a, footprint=footprint) 
    array([[0, 0, 0, 0, 0, 0, 0], 
           [0, 0, 0, 0, 0, 0, 0], 
           [0, 0, 1, 1, 1, 0, 0], 
           [0, 0, 3, 1, 2, 0, 0], 
           [0, 0, 3, 2, 2, 0, 0], 
           [0, 0, 0, 0, 0, 0, 0], 
           [0, 0, 0, 0, 0, 0, 0]]) 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">size </span><span class="s2">is None and </span><span class="s1">footprint </span><span class="s2">is None and </span><span class="s1">structure </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;size, footprint, or structure must be specified&quot;</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">_filters</span><span class="s3">.</span><span class="s1">_min_or_max_filter</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">size</span><span class="s3">, </span><span class="s1">footprint</span><span class="s3">, </span><span class="s1">structure</span><span class="s3">,</span>
                                       <span class="s1">output</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">, </span><span class="s1">cval</span><span class="s3">, </span><span class="s1">origin</span><span class="s3">, </span><span class="s5">1</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">grey_dilation</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">footprint</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">structure</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
                  <span class="s1">output</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">=</span><span class="s4">&quot;reflect&quot;</span><span class="s3">, </span><span class="s1">cval</span><span class="s3">=</span><span class="s5">0.0</span><span class="s3">, </span><span class="s1">origin</span><span class="s3">=</span><span class="s5">0</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Calculate a greyscale dilation, using either a structuring element, 
    or a footprint corresponding to a flat structuring element. 
 
    Grayscale dilation is a mathematical morphology operation. For the 
    simple case of a full and flat structuring element, it can be viewed 
    as a maximum filter over a sliding window. 
 
    Parameters 
    ---------- 
    input : array_like 
        Array over which the grayscale dilation is to be computed. 
    size : tuple of ints 
        Shape of a flat and full structuring element used for the grayscale 
        dilation. Optional if `footprint` or `structure` is provided. 
    footprint : array of ints, optional 
        Positions of non-infinite elements of a flat structuring element 
        used for the grayscale dilation. Non-zero values give the set of 
        neighbors of the center over which the maximum is chosen. 
    structure : array of ints, optional 
        Structuring element used for the grayscale dilation. `structure` 
        may be a non-flat structuring element. The `structure` array applies an 
        additive offset for each pixel in the neighborhood. 
    output : array, optional 
        An array used for storing the output of the dilation may be provided. 
    mode : {'reflect','constant','nearest','mirror', 'wrap'}, optional 
        The `mode` parameter determines how the array borders are 
        handled, where `cval` is the value when mode is equal to 
        'constant'. Default is 'reflect' 
    cval : scalar, optional 
        Value to fill past edges of input if `mode` is 'constant'. Default 
        is 0.0. 
    origin : scalar, optional 
        The `origin` parameter controls the placement of the filter. 
        Default 0 
 
    Returns 
    ------- 
    grey_dilation : ndarray 
        Grayscale dilation of `input`. 
 
    See Also 
    -------- 
    binary_dilation, grey_erosion, grey_closing, grey_opening 
    generate_binary_structure, maximum_filter 
 
    Notes 
    ----- 
    The grayscale dilation of an image input by a structuring element s defined 
    over a domain E is given by: 
 
    (input+s)(x) = max {input(y) + s(x-y), for y in E} 
 
    In particular, for structuring elements defined as 
    s(y) = 0 for y in E, the grayscale dilation computes the maximum of the 
    input image inside a sliding window defined by E. 
 
    Grayscale dilation [1]_ is a *mathematical morphology* operation [2]_. 
 
    References 
    ---------- 
    .. [1] https://en.wikipedia.org/wiki/Dilation_%28morphology%29 
    .. [2] https://en.wikipedia.org/wiki/Mathematical_morphology 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy import ndimage 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; a = np.zeros((7,7), dtype=int) 
    &gt;&gt;&gt; a[2:5, 2:5] = 1 
    &gt;&gt;&gt; a[4,4] = 2; a[2,3] = 3 
    &gt;&gt;&gt; a 
    array([[0, 0, 0, 0, 0, 0, 0], 
           [0, 0, 0, 0, 0, 0, 0], 
           [0, 0, 1, 3, 1, 0, 0], 
           [0, 0, 1, 1, 1, 0, 0], 
           [0, 0, 1, 1, 2, 0, 0], 
           [0, 0, 0, 0, 0, 0, 0], 
           [0, 0, 0, 0, 0, 0, 0]]) 
    &gt;&gt;&gt; ndimage.grey_dilation(a, size=(3,3)) 
    array([[0, 0, 0, 0, 0, 0, 0], 
           [0, 1, 3, 3, 3, 1, 0], 
           [0, 1, 3, 3, 3, 1, 0], 
           [0, 1, 3, 3, 3, 2, 0], 
           [0, 1, 1, 2, 2, 2, 0], 
           [0, 1, 1, 2, 2, 2, 0], 
           [0, 0, 0, 0, 0, 0, 0]]) 
    &gt;&gt;&gt; ndimage.grey_dilation(a, footprint=np.ones((3,3))) 
    array([[0, 0, 0, 0, 0, 0, 0], 
           [0, 1, 3, 3, 3, 1, 0], 
           [0, 1, 3, 3, 3, 1, 0], 
           [0, 1, 3, 3, 3, 2, 0], 
           [0, 1, 1, 2, 2, 2, 0], 
           [0, 1, 1, 2, 2, 2, 0], 
           [0, 0, 0, 0, 0, 0, 0]]) 
    &gt;&gt;&gt; s = ndimage.generate_binary_structure(2,1) 
    &gt;&gt;&gt; s 
    array([[False,  True, False], 
           [ True,  True,  True], 
           [False,  True, False]], dtype=bool) 
    &gt;&gt;&gt; ndimage.grey_dilation(a, footprint=s) 
    array([[0, 0, 0, 0, 0, 0, 0], 
           [0, 0, 1, 3, 1, 0, 0], 
           [0, 1, 3, 3, 3, 1, 0], 
           [0, 1, 1, 3, 2, 1, 0], 
           [0, 1, 1, 2, 2, 2, 0], 
           [0, 0, 1, 1, 2, 0, 0], 
           [0, 0, 0, 0, 0, 0, 0]]) 
    &gt;&gt;&gt; ndimage.grey_dilation(a, size=(3,3), structure=np.ones((3,3))) 
    array([[1, 1, 1, 1, 1, 1, 1], 
           [1, 2, 4, 4, 4, 2, 1], 
           [1, 2, 4, 4, 4, 2, 1], 
           [1, 2, 4, 4, 4, 3, 1], 
           [1, 2, 2, 3, 3, 3, 1], 
           [1, 2, 2, 3, 3, 3, 1], 
           [1, 1, 1, 1, 1, 1, 1]]) 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">size </span><span class="s2">is None and </span><span class="s1">footprint </span><span class="s2">is None and </span><span class="s1">structure </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;size, footprint, or structure must be specified&quot;</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">structure </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s1">structure </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">structure</span><span class="s3">)</span>
        <span class="s1">structure </span><span class="s3">= </span><span class="s1">structure</span><span class="s3">[</span><span class="s1">tuple</span><span class="s3">([</span><span class="s1">slice</span><span class="s3">(</span><span class="s2">None</span><span class="s3">, </span><span class="s2">None</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">)] *</span>
                                    <span class="s1">structure</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">)]</span>
    <span class="s2">if </span><span class="s1">footprint </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s1">footprint </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">footprint</span><span class="s3">)</span>
        <span class="s1">footprint </span><span class="s3">= </span><span class="s1">footprint</span><span class="s3">[</span><span class="s1">tuple</span><span class="s3">([</span><span class="s1">slice</span><span class="s3">(</span><span class="s2">None</span><span class="s3">, </span><span class="s2">None</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">)] *</span>
                                    <span class="s1">footprint</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">)]</span>

    <span class="s1">input </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">input</span><span class="s3">)</span>
    <span class="s1">origin </span><span class="s3">= </span><span class="s1">_ni_support</span><span class="s3">.</span><span class="s1">_normalize_sequence</span><span class="s3">(</span><span class="s1">origin</span><span class="s3">, </span><span class="s1">input</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">)</span>
    <span class="s2">for </span><span class="s1">ii </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">origin</span><span class="s3">)):</span>
        <span class="s1">origin</span><span class="s3">[</span><span class="s1">ii</span><span class="s3">] = -</span><span class="s1">origin</span><span class="s3">[</span><span class="s1">ii</span><span class="s3">]</span>
        <span class="s2">if </span><span class="s1">footprint </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s1">sz </span><span class="s3">= </span><span class="s1">footprint</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s1">ii</span><span class="s3">]</span>
        <span class="s2">elif </span><span class="s1">structure </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s1">sz </span><span class="s3">= </span><span class="s1">structure</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s1">ii</span><span class="s3">]</span>
        <span class="s2">elif </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isscalar</span><span class="s3">(</span><span class="s1">size</span><span class="s3">):</span>
            <span class="s1">sz </span><span class="s3">= </span><span class="s1">size</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">sz </span><span class="s3">= </span><span class="s1">size</span><span class="s3">[</span><span class="s1">ii</span><span class="s3">]</span>
        <span class="s2">if not </span><span class="s1">sz </span><span class="s3">&amp; </span><span class="s5">1</span><span class="s3">:</span>
            <span class="s1">origin</span><span class="s3">[</span><span class="s1">ii</span><span class="s3">] -= </span><span class="s5">1</span>

    <span class="s2">return </span><span class="s1">_filters</span><span class="s3">.</span><span class="s1">_min_or_max_filter</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">size</span><span class="s3">, </span><span class="s1">footprint</span><span class="s3">, </span><span class="s1">structure</span><span class="s3">,</span>
                                       <span class="s1">output</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">, </span><span class="s1">cval</span><span class="s3">, </span><span class="s1">origin</span><span class="s3">, </span><span class="s5">0</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">grey_opening</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">footprint</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">structure</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
                 <span class="s1">output</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">=</span><span class="s4">&quot;reflect&quot;</span><span class="s3">, </span><span class="s1">cval</span><span class="s3">=</span><span class="s5">0.0</span><span class="s3">, </span><span class="s1">origin</span><span class="s3">=</span><span class="s5">0</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Multidimensional grayscale opening. 
 
    A grayscale opening consists in the succession of a grayscale erosion, 
    and a grayscale dilation. 
 
    Parameters 
    ---------- 
    input : array_like 
        Array over which the grayscale opening is to be computed. 
    size : tuple of ints 
        Shape of a flat and full structuring element used for the grayscale 
        opening. Optional if `footprint` or `structure` is provided. 
    footprint : array of ints, optional 
        Positions of non-infinite elements of a flat structuring element 
        used for the grayscale opening. 
    structure : array of ints, optional 
        Structuring element used for the grayscale opening. `structure` 
        may be a non-flat structuring element. The `structure` array applies 
        offsets to the pixels in a neighborhood (the offset is additive during 
        dilation and subtractive during erosion). 
    output : array, optional 
        An array used for storing the output of the opening may be provided. 
    mode : {'reflect', 'constant', 'nearest', 'mirror', 'wrap'}, optional 
        The `mode` parameter determines how the array borders are 
        handled, where `cval` is the value when mode is equal to 
        'constant'. Default is 'reflect' 
    cval : scalar, optional 
        Value to fill past edges of input if `mode` is 'constant'. Default 
        is 0.0. 
    origin : scalar, optional 
        The `origin` parameter controls the placement of the filter. 
        Default 0 
 
    Returns 
    ------- 
    grey_opening : ndarray 
        Result of the grayscale opening of `input` with `structure`. 
 
    See Also 
    -------- 
    binary_opening, grey_dilation, grey_erosion, grey_closing 
    generate_binary_structure 
 
    Notes 
    ----- 
    The action of a grayscale opening with a flat structuring element amounts 
    to smoothen high local maxima, whereas binary opening erases small objects. 
 
    References 
    ---------- 
    .. [1] https://en.wikipedia.org/wiki/Mathematical_morphology 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy import ndimage 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; a = np.arange(36).reshape((6,6)) 
    &gt;&gt;&gt; a[3, 3] = 50 
    &gt;&gt;&gt; a 
    array([[ 0,  1,  2,  3,  4,  5], 
           [ 6,  7,  8,  9, 10, 11], 
           [12, 13, 14, 15, 16, 17], 
           [18, 19, 20, 50, 22, 23], 
           [24, 25, 26, 27, 28, 29], 
           [30, 31, 32, 33, 34, 35]]) 
    &gt;&gt;&gt; ndimage.grey_opening(a, size=(3,3)) 
    array([[ 0,  1,  2,  3,  4,  4], 
           [ 6,  7,  8,  9, 10, 10], 
           [12, 13, 14, 15, 16, 16], 
           [18, 19, 20, 22, 22, 22], 
           [24, 25, 26, 27, 28, 28], 
           [24, 25, 26, 27, 28, 28]]) 
    &gt;&gt;&gt; # Note that the local maximum a[3,3] has disappeared 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">size </span><span class="s2">is not None</span><span class="s3">) </span><span class="s2">and </span><span class="s3">(</span><span class="s1">footprint </span><span class="s2">is not None</span><span class="s3">):</span>
        <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span><span class="s4">&quot;ignoring size because footprint is set&quot;</span><span class="s3">,</span>
                      <span class="s1">UserWarning</span><span class="s3">, </span><span class="s1">stacklevel</span><span class="s3">=</span><span class="s5">2</span><span class="s3">)</span>
    <span class="s1">tmp </span><span class="s3">= </span><span class="s1">grey_erosion</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">size</span><span class="s3">, </span><span class="s1">footprint</span><span class="s3">, </span><span class="s1">structure</span><span class="s3">, </span><span class="s2">None</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">,</span>
                       <span class="s1">cval</span><span class="s3">, </span><span class="s1">origin</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">grey_dilation</span><span class="s3">(</span><span class="s1">tmp</span><span class="s3">, </span><span class="s1">size</span><span class="s3">, </span><span class="s1">footprint</span><span class="s3">, </span><span class="s1">structure</span><span class="s3">, </span><span class="s1">output</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">,</span>
                         <span class="s1">cval</span><span class="s3">, </span><span class="s1">origin</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">grey_closing</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">footprint</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">structure</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
                 <span class="s1">output</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">=</span><span class="s4">&quot;reflect&quot;</span><span class="s3">, </span><span class="s1">cval</span><span class="s3">=</span><span class="s5">0.0</span><span class="s3">, </span><span class="s1">origin</span><span class="s3">=</span><span class="s5">0</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Multidimensional grayscale closing. 
 
    A grayscale closing consists in the succession of a grayscale dilation, 
    and a grayscale erosion. 
 
    Parameters 
    ---------- 
    input : array_like 
        Array over which the grayscale closing is to be computed. 
    size : tuple of ints 
        Shape of a flat and full structuring element used for the grayscale 
        closing. Optional if `footprint` or `structure` is provided. 
    footprint : array of ints, optional 
        Positions of non-infinite elements of a flat structuring element 
        used for the grayscale closing. 
    structure : array of ints, optional 
        Structuring element used for the grayscale closing. `structure` 
        may be a non-flat structuring element. The `structure` array applies 
        offsets to the pixels in a neighborhood (the offset is additive during 
        dilation and subtractive during erosion) 
    output : array, optional 
        An array used for storing the output of the closing may be provided. 
    mode : {'reflect', 'constant', 'nearest', 'mirror', 'wrap'}, optional 
        The `mode` parameter determines how the array borders are 
        handled, where `cval` is the value when mode is equal to 
        'constant'. Default is 'reflect' 
    cval : scalar, optional 
        Value to fill past edges of input if `mode` is 'constant'. Default 
        is 0.0. 
    origin : scalar, optional 
        The `origin` parameter controls the placement of the filter. 
        Default 0 
 
    Returns 
    ------- 
    grey_closing : ndarray 
        Result of the grayscale closing of `input` with `structure`. 
 
    See Also 
    -------- 
    binary_closing, grey_dilation, grey_erosion, grey_opening, 
    generate_binary_structure 
 
    Notes 
    ----- 
    The action of a grayscale closing with a flat structuring element amounts 
    to smoothen deep local minima, whereas binary closing fills small holes. 
 
    References 
    ---------- 
    .. [1] https://en.wikipedia.org/wiki/Mathematical_morphology 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy import ndimage 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; a = np.arange(36).reshape((6,6)) 
    &gt;&gt;&gt; a[3,3] = 0 
    &gt;&gt;&gt; a 
    array([[ 0,  1,  2,  3,  4,  5], 
           [ 6,  7,  8,  9, 10, 11], 
           [12, 13, 14, 15, 16, 17], 
           [18, 19, 20,  0, 22, 23], 
           [24, 25, 26, 27, 28, 29], 
           [30, 31, 32, 33, 34, 35]]) 
    &gt;&gt;&gt; ndimage.grey_closing(a, size=(3,3)) 
    array([[ 7,  7,  8,  9, 10, 11], 
           [ 7,  7,  8,  9, 10, 11], 
           [13, 13, 14, 15, 16, 17], 
           [19, 19, 20, 20, 22, 23], 
           [25, 25, 26, 27, 28, 29], 
           [31, 31, 32, 33, 34, 35]]) 
    &gt;&gt;&gt; # Note that the local minimum a[3,3] has disappeared 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">size </span><span class="s2">is not None</span><span class="s3">) </span><span class="s2">and </span><span class="s3">(</span><span class="s1">footprint </span><span class="s2">is not None</span><span class="s3">):</span>
        <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span><span class="s4">&quot;ignoring size because footprint is set&quot;</span><span class="s3">,</span>
                      <span class="s1">UserWarning</span><span class="s3">, </span><span class="s1">stacklevel</span><span class="s3">=</span><span class="s5">2</span><span class="s3">)</span>
    <span class="s1">tmp </span><span class="s3">= </span><span class="s1">grey_dilation</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">size</span><span class="s3">, </span><span class="s1">footprint</span><span class="s3">, </span><span class="s1">structure</span><span class="s3">, </span><span class="s2">None</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">,</span>
                        <span class="s1">cval</span><span class="s3">, </span><span class="s1">origin</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">grey_erosion</span><span class="s3">(</span><span class="s1">tmp</span><span class="s3">, </span><span class="s1">size</span><span class="s3">, </span><span class="s1">footprint</span><span class="s3">, </span><span class="s1">structure</span><span class="s3">, </span><span class="s1">output</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">,</span>
                        <span class="s1">cval</span><span class="s3">, </span><span class="s1">origin</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">morphological_gradient</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">footprint</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">structure</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
                           <span class="s1">output</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">=</span><span class="s4">&quot;reflect&quot;</span><span class="s3">, </span><span class="s1">cval</span><span class="s3">=</span><span class="s5">0.0</span><span class="s3">, </span><span class="s1">origin</span><span class="s3">=</span><span class="s5">0</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Multidimensional morphological gradient. 
 
    The morphological gradient is calculated as the difference between a 
    dilation and an erosion of the input with a given structuring element. 
 
    Parameters 
    ---------- 
    input : array_like 
        Array over which to compute the morphlogical gradient. 
    size : tuple of ints 
        Shape of a flat and full structuring element used for the mathematical 
        morphology operations. Optional if `footprint` or `structure` is 
        provided. A larger `size` yields a more blurred gradient. 
    footprint : array of ints, optional 
        Positions of non-infinite elements of a flat structuring element 
        used for the morphology operations. Larger footprints 
        give a more blurred morphological gradient. 
    structure : array of ints, optional 
        Structuring element used for the morphology operations. `structure` may 
        be a non-flat structuring element. The `structure` array applies 
        offsets to the pixels in a neighborhood (the offset is additive during 
        dilation and subtractive during erosion) 
    output : array, optional 
        An array used for storing the output of the morphological gradient 
        may be provided. 
    mode : {'reflect', 'constant', 'nearest', 'mirror', 'wrap'}, optional 
        The `mode` parameter determines how the array borders are 
        handled, where `cval` is the value when mode is equal to 
        'constant'. Default is 'reflect' 
    cval : scalar, optional 
        Value to fill past edges of input if `mode` is 'constant'. Default 
        is 0.0. 
    origin : scalar, optional 
        The `origin` parameter controls the placement of the filter. 
        Default 0 
 
    Returns 
    ------- 
    morphological_gradient : ndarray 
        Morphological gradient of `input`. 
 
    See Also 
    -------- 
    grey_dilation, grey_erosion, gaussian_gradient_magnitude 
 
    Notes 
    ----- 
    For a flat structuring element, the morphological gradient 
    computed at a given point corresponds to the maximal difference 
    between elements of the input among the elements covered by the 
    structuring element centered on the point. 
 
    References 
    ---------- 
    .. [1] https://en.wikipedia.org/wiki/Mathematical_morphology 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy import ndimage 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; a = np.zeros((7,7), dtype=int) 
    &gt;&gt;&gt; a[2:5, 2:5] = 1 
    &gt;&gt;&gt; ndimage.morphological_gradient(a, size=(3,3)) 
    array([[0, 0, 0, 0, 0, 0, 0], 
           [0, 1, 1, 1, 1, 1, 0], 
           [0, 1, 1, 1, 1, 1, 0], 
           [0, 1, 1, 0, 1, 1, 0], 
           [0, 1, 1, 1, 1, 1, 0], 
           [0, 1, 1, 1, 1, 1, 0], 
           [0, 0, 0, 0, 0, 0, 0]]) 
    &gt;&gt;&gt; # The morphological gradient is computed as the difference 
    &gt;&gt;&gt; # between a dilation and an erosion 
    &gt;&gt;&gt; ndimage.grey_dilation(a, size=(3,3)) -\\ 
    ...  ndimage.grey_erosion(a, size=(3,3)) 
    array([[0, 0, 0, 0, 0, 0, 0], 
           [0, 1, 1, 1, 1, 1, 0], 
           [0, 1, 1, 1, 1, 1, 0], 
           [0, 1, 1, 0, 1, 1, 0], 
           [0, 1, 1, 1, 1, 1, 0], 
           [0, 1, 1, 1, 1, 1, 0], 
           [0, 0, 0, 0, 0, 0, 0]]) 
    &gt;&gt;&gt; a = np.zeros((7,7), dtype=int) 
    &gt;&gt;&gt; a[2:5, 2:5] = 1 
    &gt;&gt;&gt; a[4,4] = 2; a[2,3] = 3 
    &gt;&gt;&gt; a 
    array([[0, 0, 0, 0, 0, 0, 0], 
           [0, 0, 0, 0, 0, 0, 0], 
           [0, 0, 1, 3, 1, 0, 0], 
           [0, 0, 1, 1, 1, 0, 0], 
           [0, 0, 1, 1, 2, 0, 0], 
           [0, 0, 0, 0, 0, 0, 0], 
           [0, 0, 0, 0, 0, 0, 0]]) 
    &gt;&gt;&gt; ndimage.morphological_gradient(a, size=(3,3)) 
    array([[0, 0, 0, 0, 0, 0, 0], 
           [0, 1, 3, 3, 3, 1, 0], 
           [0, 1, 3, 3, 3, 1, 0], 
           [0, 1, 3, 2, 3, 2, 0], 
           [0, 1, 1, 2, 2, 2, 0], 
           [0, 1, 1, 2, 2, 2, 0], 
           [0, 0, 0, 0, 0, 0, 0]]) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">tmp </span><span class="s3">= </span><span class="s1">grey_dilation</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">size</span><span class="s3">, </span><span class="s1">footprint</span><span class="s3">, </span><span class="s1">structure</span><span class="s3">, </span><span class="s2">None</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">,</span>
                        <span class="s1">cval</span><span class="s3">, </span><span class="s1">origin</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">output</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndarray</span><span class="s3">):</span>
        <span class="s1">grey_erosion</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">size</span><span class="s3">, </span><span class="s1">footprint</span><span class="s3">, </span><span class="s1">structure</span><span class="s3">, </span><span class="s1">output</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">,</span>
                     <span class="s1">cval</span><span class="s3">, </span><span class="s1">origin</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">subtract</span><span class="s3">(</span><span class="s1">tmp</span><span class="s3">, </span><span class="s1">output</span><span class="s3">, </span><span class="s1">output</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s3">(</span><span class="s1">tmp </span><span class="s3">- </span><span class="s1">grey_erosion</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">size</span><span class="s3">, </span><span class="s1">footprint</span><span class="s3">, </span><span class="s1">structure</span><span class="s3">,</span>
                                   <span class="s2">None</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">, </span><span class="s1">cval</span><span class="s3">, </span><span class="s1">origin</span><span class="s3">))</span>


<span class="s2">def </span><span class="s1">morphological_laplace</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">footprint</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
                          <span class="s1">structure</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">output</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
                          <span class="s1">mode</span><span class="s3">=</span><span class="s4">&quot;reflect&quot;</span><span class="s3">, </span><span class="s1">cval</span><span class="s3">=</span><span class="s5">0.0</span><span class="s3">, </span><span class="s1">origin</span><span class="s3">=</span><span class="s5">0</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Multidimensional morphological laplace. 
 
    Parameters 
    ---------- 
    input : array_like 
        Input. 
    size : tuple of ints 
        Shape of a flat and full structuring element used for the mathematical 
        morphology operations. Optional if `footprint` or `structure` is 
        provided. 
    footprint : array of ints, optional 
        Positions of non-infinite elements of a flat structuring element 
        used for the morphology operations. 
    structure : array of ints, optional 
        Structuring element used for the morphology operations. `structure` may 
        be a non-flat structuring element. The `structure` array applies 
        offsets to the pixels in a neighborhood (the offset is additive during 
        dilation and subtractive during erosion) 
    output : ndarray, optional 
        An output array can optionally be provided. 
    mode : {'reflect','constant','nearest','mirror', 'wrap'}, optional 
        The mode parameter determines how the array borders are handled. 
        For 'constant' mode, values beyond borders are set to be `cval`. 
        Default is 'reflect'. 
    cval : scalar, optional 
        Value to fill past edges of input if mode is 'constant'. 
        Default is 0.0 
    origin : origin, optional 
        The origin parameter controls the placement of the filter. 
 
    Returns 
    ------- 
    morphological_laplace : ndarray 
        Output 
 
    &quot;&quot;&quot;</span>
    <span class="s1">tmp1 </span><span class="s3">= </span><span class="s1">grey_dilation</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">size</span><span class="s3">, </span><span class="s1">footprint</span><span class="s3">, </span><span class="s1">structure</span><span class="s3">, </span><span class="s2">None</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">,</span>
                         <span class="s1">cval</span><span class="s3">, </span><span class="s1">origin</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">output</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndarray</span><span class="s3">):</span>
        <span class="s1">grey_erosion</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">size</span><span class="s3">, </span><span class="s1">footprint</span><span class="s3">, </span><span class="s1">structure</span><span class="s3">, </span><span class="s1">output</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">,</span>
                     <span class="s1">cval</span><span class="s3">, </span><span class="s1">origin</span><span class="s3">)</span>
        <span class="s1">np</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">tmp1</span><span class="s3">, </span><span class="s1">output</span><span class="s3">, </span><span class="s1">output</span><span class="s3">)</span>
        <span class="s1">np</span><span class="s3">.</span><span class="s1">subtract</span><span class="s3">(</span><span class="s1">output</span><span class="s3">, </span><span class="s1">input</span><span class="s3">, </span><span class="s1">output</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">subtract</span><span class="s3">(</span><span class="s1">output</span><span class="s3">, </span><span class="s1">input</span><span class="s3">, </span><span class="s1">output</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">tmp2 </span><span class="s3">= </span><span class="s1">grey_erosion</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">size</span><span class="s3">, </span><span class="s1">footprint</span><span class="s3">, </span><span class="s1">structure</span><span class="s3">, </span><span class="s2">None</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">,</span>
                            <span class="s1">cval</span><span class="s3">, </span><span class="s1">origin</span><span class="s3">)</span>
        <span class="s1">np</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">tmp1</span><span class="s3">, </span><span class="s1">tmp2</span><span class="s3">, </span><span class="s1">tmp2</span><span class="s3">)</span>
        <span class="s1">np</span><span class="s3">.</span><span class="s1">subtract</span><span class="s3">(</span><span class="s1">tmp2</span><span class="s3">, </span><span class="s1">input</span><span class="s3">, </span><span class="s1">tmp2</span><span class="s3">)</span>
        <span class="s1">np</span><span class="s3">.</span><span class="s1">subtract</span><span class="s3">(</span><span class="s1">tmp2</span><span class="s3">, </span><span class="s1">input</span><span class="s3">, </span><span class="s1">tmp2</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">tmp2</span>


<span class="s2">def </span><span class="s1">white_tophat</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">footprint</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">structure</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
                 <span class="s1">output</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">=</span><span class="s4">&quot;reflect&quot;</span><span class="s3">, </span><span class="s1">cval</span><span class="s3">=</span><span class="s5">0.0</span><span class="s3">, </span><span class="s1">origin</span><span class="s3">=</span><span class="s5">0</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Multidimensional white tophat filter. 
 
    Parameters 
    ---------- 
    input : array_like 
        Input. 
    size : tuple of ints 
        Shape of a flat and full structuring element used for the filter. 
        Optional if `footprint` or `structure` is provided. 
    footprint : array of ints, optional 
        Positions of elements of a flat structuring element 
        used for the white tophat filter. 
    structure : array of ints, optional 
        Structuring element used for the filter. `structure` may be a non-flat 
        structuring element. The `structure` array applies offsets to the 
        pixels in a neighborhood (the offset is additive during dilation and 
        subtractive during erosion) 
    output : array, optional 
        An array used for storing the output of the filter may be provided. 
    mode : {'reflect', 'constant', 'nearest', 'mirror', 'wrap'}, optional 
        The `mode` parameter determines how the array borders are 
        handled, where `cval` is the value when mode is equal to 
        'constant'. Default is 'reflect' 
    cval : scalar, optional 
        Value to fill past edges of input if `mode` is 'constant'. 
        Default is 0.0. 
    origin : scalar, optional 
        The `origin` parameter controls the placement of the filter. 
        Default is 0. 
 
    Returns 
    ------- 
    output : ndarray 
        Result of the filter of `input` with `structure`. 
 
    See Also 
    -------- 
    black_tophat 
 
    Examples 
    -------- 
    Subtract gray background from a bright peak. 
 
    &gt;&gt;&gt; from scipy.ndimage import generate_binary_structure, white_tophat 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; square = generate_binary_structure(rank=2, connectivity=3) 
    &gt;&gt;&gt; bright_on_gray = np.array([[2, 3, 3, 3, 2], 
    ...                            [3, 4, 5, 4, 3], 
    ...                            [3, 5, 9, 5, 3], 
    ...                            [3, 4, 5, 4, 3], 
    ...                            [2, 3, 3, 3, 2]]) 
    &gt;&gt;&gt; white_tophat(input=bright_on_gray, structure=square) 
    array([[0, 0, 0, 0, 0], 
           [0, 0, 1, 0, 0], 
           [0, 1, 5, 1, 0], 
           [0, 0, 1, 0, 0], 
           [0, 0, 0, 0, 0]]) 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">size </span><span class="s2">is not None</span><span class="s3">) </span><span class="s2">and </span><span class="s3">(</span><span class="s1">footprint </span><span class="s2">is not None</span><span class="s3">):</span>
        <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span><span class="s4">&quot;ignoring size because footprint is set&quot;</span><span class="s3">,</span>
                      <span class="s1">UserWarning</span><span class="s3">, </span><span class="s1">stacklevel</span><span class="s3">=</span><span class="s5">2</span><span class="s3">)</span>
    <span class="s1">tmp </span><span class="s3">= </span><span class="s1">grey_erosion</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">size</span><span class="s3">, </span><span class="s1">footprint</span><span class="s3">, </span><span class="s1">structure</span><span class="s3">, </span><span class="s2">None</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">,</span>
                       <span class="s1">cval</span><span class="s3">, </span><span class="s1">origin</span><span class="s3">)</span>
    <span class="s1">tmp </span><span class="s3">= </span><span class="s1">grey_dilation</span><span class="s3">(</span><span class="s1">tmp</span><span class="s3">, </span><span class="s1">size</span><span class="s3">, </span><span class="s1">footprint</span><span class="s3">, </span><span class="s1">structure</span><span class="s3">, </span><span class="s1">output</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">,</span>
                        <span class="s1">cval</span><span class="s3">, </span><span class="s1">origin</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">tmp </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">tmp </span><span class="s3">= </span><span class="s1">output</span>

    <span class="s2">if </span><span class="s1">input</span><span class="s3">.</span><span class="s1">dtype </span><span class="s3">== </span><span class="s1">np</span><span class="s3">.</span><span class="s1">bool_ </span><span class="s2">and </span><span class="s1">tmp</span><span class="s3">.</span><span class="s1">dtype </span><span class="s3">== </span><span class="s1">np</span><span class="s3">.</span><span class="s1">bool_</span><span class="s3">:</span>
        <span class="s1">np</span><span class="s3">.</span><span class="s1">bitwise_xor</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">tmp</span><span class="s3">, </span><span class="s1">out</span><span class="s3">=</span><span class="s1">tmp</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">np</span><span class="s3">.</span><span class="s1">subtract</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">tmp</span><span class="s3">, </span><span class="s1">out</span><span class="s3">=</span><span class="s1">tmp</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">tmp</span>


<span class="s2">def </span><span class="s1">black_tophat</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">footprint</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
                 <span class="s1">structure</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">output</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">=</span><span class="s4">&quot;reflect&quot;</span><span class="s3">,</span>
                 <span class="s1">cval</span><span class="s3">=</span><span class="s5">0.0</span><span class="s3">, </span><span class="s1">origin</span><span class="s3">=</span><span class="s5">0</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Multidimensional black tophat filter. 
 
    Parameters 
    ---------- 
    input : array_like 
        Input. 
    size : tuple of ints, optional 
        Shape of a flat and full structuring element used for the filter. 
        Optional if `footprint` or `structure` is provided. 
    footprint : array of ints, optional 
        Positions of non-infinite elements of a flat structuring element 
        used for the black tophat filter. 
    structure : array of ints, optional 
        Structuring element used for the filter. `structure` may be a non-flat 
        structuring element. The `structure` array applies offsets to the 
        pixels in a neighborhood (the offset is additive during dilation and 
        subtractive during erosion) 
    output : array, optional 
        An array used for storing the output of the filter may be provided. 
    mode : {'reflect', 'constant', 'nearest', 'mirror', 'wrap'}, optional 
        The `mode` parameter determines how the array borders are 
        handled, where `cval` is the value when mode is equal to 
        'constant'. Default is 'reflect' 
    cval : scalar, optional 
        Value to fill past edges of input if `mode` is 'constant'. Default 
        is 0.0. 
    origin : scalar, optional 
        The `origin` parameter controls the placement of the filter. 
        Default 0 
 
    Returns 
    ------- 
    black_tophat : ndarray 
        Result of the filter of `input` with `structure`. 
 
    See Also 
    -------- 
    white_tophat, grey_opening, grey_closing 
 
    Examples 
    -------- 
    Change dark peak to bright peak and subtract background. 
 
    &gt;&gt;&gt; from scipy.ndimage import generate_binary_structure, black_tophat 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; square = generate_binary_structure(rank=2, connectivity=3) 
    &gt;&gt;&gt; dark_on_gray = np.array([[7, 6, 6, 6, 7], 
    ...                          [6, 5, 4, 5, 6], 
    ...                          [6, 4, 0, 4, 6], 
    ...                          [6, 5, 4, 5, 6], 
    ...                          [7, 6, 6, 6, 7]]) 
    &gt;&gt;&gt; black_tophat(input=dark_on_gray, structure=square) 
    array([[0, 0, 0, 0, 0], 
           [0, 0, 1, 0, 0], 
           [0, 1, 5, 1, 0], 
           [0, 0, 1, 0, 0], 
           [0, 0, 0, 0, 0]]) 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">size </span><span class="s2">is not None</span><span class="s3">) </span><span class="s2">and </span><span class="s3">(</span><span class="s1">footprint </span><span class="s2">is not None</span><span class="s3">):</span>
        <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span><span class="s4">&quot;ignoring size because footprint is set&quot;</span><span class="s3">,</span>
                      <span class="s1">UserWarning</span><span class="s3">, </span><span class="s1">stacklevel</span><span class="s3">=</span><span class="s5">2</span><span class="s3">)</span>
    <span class="s1">tmp </span><span class="s3">= </span><span class="s1">grey_dilation</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">size</span><span class="s3">, </span><span class="s1">footprint</span><span class="s3">, </span><span class="s1">structure</span><span class="s3">, </span><span class="s2">None</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">,</span>
                        <span class="s1">cval</span><span class="s3">, </span><span class="s1">origin</span><span class="s3">)</span>
    <span class="s1">tmp </span><span class="s3">= </span><span class="s1">grey_erosion</span><span class="s3">(</span><span class="s1">tmp</span><span class="s3">, </span><span class="s1">size</span><span class="s3">, </span><span class="s1">footprint</span><span class="s3">, </span><span class="s1">structure</span><span class="s3">, </span><span class="s1">output</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">,</span>
                       <span class="s1">cval</span><span class="s3">, </span><span class="s1">origin</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">tmp </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">tmp </span><span class="s3">= </span><span class="s1">output</span>

    <span class="s2">if </span><span class="s1">input</span><span class="s3">.</span><span class="s1">dtype </span><span class="s3">== </span><span class="s1">np</span><span class="s3">.</span><span class="s1">bool_ </span><span class="s2">and </span><span class="s1">tmp</span><span class="s3">.</span><span class="s1">dtype </span><span class="s3">== </span><span class="s1">np</span><span class="s3">.</span><span class="s1">bool_</span><span class="s3">:</span>
        <span class="s1">np</span><span class="s3">.</span><span class="s1">bitwise_xor</span><span class="s3">(</span><span class="s1">tmp</span><span class="s3">, </span><span class="s1">input</span><span class="s3">, </span><span class="s1">out</span><span class="s3">=</span><span class="s1">tmp</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">np</span><span class="s3">.</span><span class="s1">subtract</span><span class="s3">(</span><span class="s1">tmp</span><span class="s3">, </span><span class="s1">input</span><span class="s3">, </span><span class="s1">out</span><span class="s3">=</span><span class="s1">tmp</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">tmp</span>


<span class="s2">def </span><span class="s1">distance_transform_bf</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">metric</span><span class="s3">=</span><span class="s4">&quot;euclidean&quot;</span><span class="s3">, </span><span class="s1">sampling</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
                          <span class="s1">return_distances</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">return_indices</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
                          <span class="s1">distances</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Distance transform function by a brute force algorithm. 
 
    This function calculates the distance transform of the `input`, by 
    replacing each foreground (non-zero) element, with its 
    shortest distance to the background (any zero-valued element). 
 
    In addition to the distance transform, the feature transform can 
    be calculated. In this case the index of the closest background 
    element to each foreground element is returned in a separate array. 
 
    Parameters 
    ---------- 
    input : array_like 
        Input 
    metric : {'euclidean', 'taxicab', 'chessboard'}, optional 
        'cityblock' and 'manhattan' are also valid, and map to 'taxicab'. 
        The default is 'euclidean'. 
    sampling : float, or sequence of float, optional 
        This parameter is only used when `metric` is 'euclidean'. 
        Spacing of elements along each dimension. If a sequence, must be of 
        length equal to the input rank; if a single number, this is used for 
        all axes. If not specified, a grid spacing of unity is implied. 
    return_distances : bool, optional 
        Whether to calculate the distance transform. 
        Default is True. 
    return_indices : bool, optional 
        Whether to calculate the feature transform. 
        Default is False. 
    distances : ndarray, optional 
        An output array to store the calculated distance transform, instead of 
        returning it. 
        `return_distances` must be True. 
        It must be the same shape as `input`, and of type float64 if `metric` 
        is 'euclidean', uint32 otherwise. 
    indices : int32 ndarray, optional 
        An output array to store the calculated feature transform, instead of 
        returning it. 
        `return_indicies` must be True. 
        Its shape must be `(input.ndim,) + input.shape`. 
 
    Returns 
    ------- 
    distances : ndarray, optional 
        The calculated distance transform. Returned only when 
        `return_distances` is True and `distances` is not supplied. 
        It will have the same shape as the input array. 
    indices : int32 ndarray, optional 
        The calculated feature transform. It has an input-shaped array for each 
        dimension of the input. See distance_transform_edt documentation for an 
        example. 
        Returned only when `return_indices` is True and `indices` is not 
        supplied. 
 
    See Also 
    -------- 
    distance_transform_cdt : Faster distance transform for taxicab and 
                             chessboard metrics 
    distance_transform_edt : Faster distance transform for euclidean metric 
 
    Notes 
    ----- 
    This function employs a slow brute force algorithm. See also the 
    function `distance_transform_cdt` for more efficient taxicab [1]_ and 
    chessboard algorithms [2]_. 
 
    References 
    ---------- 
    .. [1] Taxicab distance. Wikipedia, 2023. 
           https://en.wikipedia.org/wiki/Taxicab_geometry 
    .. [2] Chessboard distance. Wikipedia, 2023. 
           https://en.wikipedia.org/wiki/Chebyshev_distance 
 
    Examples 
    -------- 
    Import the necessary modules. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.ndimage import distance_transform_bf 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; from mpl_toolkits.axes_grid1 import ImageGrid 
 
    First, we create a toy binary image. 
 
    &gt;&gt;&gt; def add_circle(center_x, center_y, radius, image, fillvalue=1): 
    ...     # fill circular area with 1 
    ...     xx, yy = np.mgrid[:image.shape[0], :image.shape[1]] 
    ...     circle = (xx - center_x) ** 2 + (yy - center_y) ** 2 
    ...     circle_shape = np.sqrt(circle) &lt; radius 
    ...     image[circle_shape] = fillvalue 
    ...     return image 
    &gt;&gt;&gt; image = np.zeros((100, 100), dtype=np.uint8) 
    &gt;&gt;&gt; image[35:65, 20:80] = 1 
    &gt;&gt;&gt; image = add_circle(28, 65, 10, image) 
    &gt;&gt;&gt; image = add_circle(37, 30, 10, image) 
    &gt;&gt;&gt; image = add_circle(70, 45, 20, image) 
    &gt;&gt;&gt; image = add_circle(45, 80, 10, image) 
 
    Next, we set up the figure. 
 
    &gt;&gt;&gt; fig = plt.figure(figsize=(8, 8))  # set up the figure structure 
    &gt;&gt;&gt; grid = ImageGrid(fig, 111, nrows_ncols=(2, 2), axes_pad=(0.4, 0.3), 
    ...                  label_mode=&quot;1&quot;, share_all=True, 
    ...                  cbar_location=&quot;right&quot;, cbar_mode=&quot;each&quot;, 
    ...                  cbar_size=&quot;7%&quot;, cbar_pad=&quot;2%&quot;) 
    &gt;&gt;&gt; for ax in grid: 
    ...     ax.axis('off')  # remove axes from images 
 
    The top left image is the original binary image. 
 
    &gt;&gt;&gt; binary_image = grid[0].imshow(image, cmap='gray') 
    &gt;&gt;&gt; cbar_binary_image = grid.cbar_axes[0].colorbar(binary_image) 
    &gt;&gt;&gt; cbar_binary_image.set_ticks([0, 1]) 
    &gt;&gt;&gt; grid[0].set_title(&quot;Binary image: foreground in white&quot;) 
 
    The distance transform calculates the distance between foreground pixels 
    and the image background according to a distance metric. Available metrics 
    in `distance_transform_bf` are: ``euclidean`` (default), ``taxicab`` 
    and ``chessboard``. The top right image contains the distance transform 
    based on the ``euclidean`` metric. 
 
    &gt;&gt;&gt; distance_transform_euclidean = distance_transform_bf(image) 
    &gt;&gt;&gt; euclidean_transform = grid[1].imshow(distance_transform_euclidean, 
    ...                                      cmap='gray') 
    &gt;&gt;&gt; cbar_euclidean = grid.cbar_axes[1].colorbar(euclidean_transform) 
    &gt;&gt;&gt; colorbar_ticks = [0, 10, 20] 
    &gt;&gt;&gt; cbar_euclidean.set_ticks(colorbar_ticks) 
    &gt;&gt;&gt; grid[1].set_title(&quot;Euclidean distance&quot;) 
 
    The lower left image contains the distance transform using the ``taxicab`` 
    metric. 
 
    &gt;&gt;&gt; distance_transform_taxicab = distance_transform_bf(image, 
    ...                                                    metric='taxicab') 
    &gt;&gt;&gt; taxicab_transformation = grid[2].imshow(distance_transform_taxicab, 
    ...                                         cmap='gray') 
    &gt;&gt;&gt; cbar_taxicab = grid.cbar_axes[2].colorbar(taxicab_transformation) 
    &gt;&gt;&gt; cbar_taxicab.set_ticks(colorbar_ticks) 
    &gt;&gt;&gt; grid[2].set_title(&quot;Taxicab distance&quot;) 
 
    Finally, the lower right image contains the distance transform using the 
    ``chessboard`` metric. 
 
    &gt;&gt;&gt; distance_transform_cb = distance_transform_bf(image, 
    ...                                               metric='chessboard') 
    &gt;&gt;&gt; chessboard_transformation = grid[3].imshow(distance_transform_cb, 
    ...                                            cmap='gray') 
    &gt;&gt;&gt; cbar_taxicab = grid.cbar_axes[3].colorbar(chessboard_transformation) 
    &gt;&gt;&gt; cbar_taxicab.set_ticks(colorbar_ticks) 
    &gt;&gt;&gt; grid[3].set_title(&quot;Chessboard distance&quot;) 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span>
    <span class="s1">ft_inplace </span><span class="s3">= </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">indices</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndarray</span><span class="s3">)</span>
    <span class="s1">dt_inplace </span><span class="s3">= </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">distances</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndarray</span><span class="s3">)</span>
    <span class="s1">_distance_tranform_arg_check</span><span class="s3">(</span>
        <span class="s1">dt_inplace</span><span class="s3">, </span><span class="s1">ft_inplace</span><span class="s3">, </span><span class="s1">return_distances</span><span class="s3">, </span><span class="s1">return_indices</span>
    <span class="s3">)</span>

    <span class="s1">tmp1 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">input</span><span class="s3">) != </span><span class="s5">0</span>
    <span class="s1">struct </span><span class="s3">= </span><span class="s1">generate_binary_structure</span><span class="s3">(</span><span class="s1">tmp1</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">, </span><span class="s1">tmp1</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">)</span>
    <span class="s1">tmp2 </span><span class="s3">= </span><span class="s1">binary_dilation</span><span class="s3">(</span><span class="s1">tmp1</span><span class="s3">, </span><span class="s1">struct</span><span class="s3">)</span>
    <span class="s1">tmp2 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">logical_xor</span><span class="s3">(</span><span class="s1">tmp1</span><span class="s3">, </span><span class="s1">tmp2</span><span class="s3">)</span>
    <span class="s1">tmp1 </span><span class="s3">= </span><span class="s1">tmp1</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">int8</span><span class="s3">) - </span><span class="s1">tmp2</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">int8</span><span class="s3">)</span>
    <span class="s1">metric </span><span class="s3">= </span><span class="s1">metric</span><span class="s3">.</span><span class="s1">lower</span><span class="s3">()</span>
    <span class="s2">if </span><span class="s1">metric </span><span class="s3">== </span><span class="s4">'euclidean'</span><span class="s3">:</span>
        <span class="s1">metric </span><span class="s3">= </span><span class="s5">1</span>
    <span class="s2">elif </span><span class="s1">metric </span><span class="s2">in </span><span class="s3">[</span><span class="s4">'taxicab'</span><span class="s3">, </span><span class="s4">'cityblock'</span><span class="s3">, </span><span class="s4">'manhattan'</span><span class="s3">]:</span>
        <span class="s1">metric </span><span class="s3">= </span><span class="s5">2</span>
    <span class="s2">elif </span><span class="s1">metric </span><span class="s3">== </span><span class="s4">'chessboard'</span><span class="s3">:</span>
        <span class="s1">metric </span><span class="s3">= </span><span class="s5">3</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">RuntimeError</span><span class="s3">(</span><span class="s4">'distance metric not supported'</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">sampling </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s1">sampling </span><span class="s3">= </span><span class="s1">_ni_support</span><span class="s3">.</span><span class="s1">_normalize_sequence</span><span class="s3">(</span><span class="s1">sampling</span><span class="s3">, </span><span class="s1">tmp1</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">)</span>
        <span class="s1">sampling </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">sampling</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">)</span>
        <span class="s2">if not </span><span class="s1">sampling</span><span class="s3">.</span><span class="s1">flags</span><span class="s3">.</span><span class="s1">contiguous</span><span class="s3">:</span>
            <span class="s1">sampling </span><span class="s3">= </span><span class="s1">sampling</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>
    <span class="s2">if </span><span class="s1">return_indices</span><span class="s3">:</span>
        <span class="s1">ft </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">tmp1</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">int32</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">ft </span><span class="s3">= </span><span class="s2">None</span>
    <span class="s2">if </span><span class="s1">return_distances</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">distances </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">metric </span><span class="s3">== </span><span class="s5">1</span><span class="s3">:</span>
                <span class="s1">dt </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">tmp1</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">dt </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">tmp1</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">uint32</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">distances</span><span class="s3">.</span><span class="s1">shape </span><span class="s3">!= </span><span class="s1">tmp1</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">RuntimeError</span><span class="s3">(</span><span class="s4">'distances array has wrong shape'</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">metric </span><span class="s3">== </span><span class="s5">1</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">distances</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">type </span><span class="s3">!= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">:</span>
                    <span class="s2">raise </span><span class="s1">RuntimeError</span><span class="s3">(</span><span class="s4">'distances array must be float64'</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">distances</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">type </span><span class="s3">!= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">uint32</span><span class="s3">:</span>
                    <span class="s2">raise </span><span class="s1">RuntimeError</span><span class="s3">(</span><span class="s4">'distances array must be uint32'</span><span class="s3">)</span>
            <span class="s1">dt </span><span class="s3">= </span><span class="s1">distances</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">dt </span><span class="s3">= </span><span class="s2">None</span>

    <span class="s1">_nd_image</span><span class="s3">.</span><span class="s1">distance_transform_bf</span><span class="s3">(</span><span class="s1">tmp1</span><span class="s3">, </span><span class="s1">metric</span><span class="s3">, </span><span class="s1">sampling</span><span class="s3">, </span><span class="s1">dt</span><span class="s3">, </span><span class="s1">ft</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">return_indices</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">indices</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndarray</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">indices</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">type </span><span class="s3">!= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">int32</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">RuntimeError</span><span class="s3">(</span><span class="s4">'indices array must be int32'</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">indices</span><span class="s3">.</span><span class="s1">shape </span><span class="s3">!= (</span><span class="s1">tmp1</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">,) + </span><span class="s1">tmp1</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">RuntimeError</span><span class="s3">(</span><span class="s4">'indices array has wrong shape'</span><span class="s3">)</span>
            <span class="s1">tmp2 </span><span class="s3">= </span><span class="s1">indices</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">tmp2 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">indices</span><span class="s3">(</span><span class="s1">tmp1</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">int32</span><span class="s3">)</span>
        <span class="s1">ft </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ravel</span><span class="s3">(</span><span class="s1">ft</span><span class="s3">)</span>
        <span class="s2">for </span><span class="s1">ii </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">tmp2</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]):</span>
            <span class="s1">rtmp </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ravel</span><span class="s3">(</span><span class="s1">tmp2</span><span class="s3">[</span><span class="s1">ii</span><span class="s3">, ...])[</span><span class="s1">ft</span><span class="s3">]</span>
            <span class="s1">rtmp</span><span class="s3">.</span><span class="s1">shape </span><span class="s3">= </span><span class="s1">tmp1</span><span class="s3">.</span><span class="s1">shape</span>
            <span class="s1">tmp2</span><span class="s3">[</span><span class="s1">ii</span><span class="s3">, ...] = </span><span class="s1">rtmp</span>
        <span class="s1">ft </span><span class="s3">= </span><span class="s1">tmp2</span>

    <span class="s0"># construct and return the result</span>
    <span class="s1">result </span><span class="s3">= []</span>
    <span class="s2">if </span><span class="s1">return_distances </span><span class="s2">and not </span><span class="s1">dt_inplace</span><span class="s3">:</span>
        <span class="s1">result</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">dt</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">return_indices </span><span class="s2">and not </span><span class="s1">ft_inplace</span><span class="s3">:</span>
        <span class="s1">result</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">ft</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">result</span><span class="s3">) == </span><span class="s5">2</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">result</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">len</span><span class="s3">(</span><span class="s1">result</span><span class="s3">) == </span><span class="s5">1</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">result</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">return None</span>


<span class="s2">def </span><span class="s1">distance_transform_cdt</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">metric</span><span class="s3">=</span><span class="s4">'chessboard'</span><span class="s3">, </span><span class="s1">return_distances</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
                           <span class="s1">return_indices</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">distances</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Distance transform for chamfer type of transforms. 
 
    This function calculates the distance transform of the `input`, by 
    replacing each foreground (non-zero) element, with its 
    shortest distance to the background (any zero-valued element). 
 
    In addition to the distance transform, the feature transform can 
    be calculated. In this case the index of the closest background 
    element to each foreground element is returned in a separate array. 
 
    Parameters 
    ---------- 
    input : array_like 
        Input. Values of 0 are treated as background. 
    metric : {'chessboard', 'taxicab'} or array_like, optional 
        The `metric` determines the type of chamfering that is done. If the 
        `metric` is equal to 'taxicab' a structure is generated using 
        `generate_binary_structure` with a squared distance equal to 1. If 
        the `metric` is equal to 'chessboard', a `metric` is generated 
        using `generate_binary_structure` with a squared distance equal to 
        the dimensionality of the array. These choices correspond to the 
        common interpretations of the 'taxicab' and the 'chessboard' 
        distance metrics in two dimensions. 
        A custom metric may be provided, in the form of a matrix where 
        each dimension has a length of three. 
        'cityblock' and 'manhattan' are also valid, and map to 'taxicab'. 
        The default is 'chessboard'. 
    return_distances : bool, optional 
        Whether to calculate the distance transform. 
        Default is True. 
    return_indices : bool, optional 
        Whether to calculate the feature transform. 
        Default is False. 
    distances : int32 ndarray, optional 
        An output array to store the calculated distance transform, instead of 
        returning it. 
        `return_distances` must be True. 
        It must be the same shape as `input`. 
    indices : int32 ndarray, optional 
        An output array to store the calculated feature transform, instead of 
        returning it. 
        `return_indicies` must be True. 
        Its shape must be `(input.ndim,) + input.shape`. 
 
    Returns 
    ------- 
    distances : int32 ndarray, optional 
        The calculated distance transform. Returned only when 
        `return_distances` is True, and `distances` is not supplied. 
        It will have the same shape as the input array. 
    indices : int32 ndarray, optional 
        The calculated feature transform. It has an input-shaped array for each 
        dimension of the input. See distance_transform_edt documentation for an 
        example. 
        Returned only when `return_indices` is True, and `indices` is not 
        supplied. 
 
    See Also 
    -------- 
    distance_transform_edt : Fast distance transform for euclidean metric 
    distance_transform_bf : Distance transform for different metrics using 
                            a slower brute force algorithm 
 
    Examples 
    -------- 
    Import the necessary modules. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.ndimage import distance_transform_cdt 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; from mpl_toolkits.axes_grid1 import ImageGrid 
 
    First, we create a toy binary image. 
 
    &gt;&gt;&gt; def add_circle(center_x, center_y, radius, image, fillvalue=1): 
    ...     # fill circular area with 1 
    ...     xx, yy = np.mgrid[:image.shape[0], :image.shape[1]] 
    ...     circle = (xx - center_x) ** 2 + (yy - center_y) ** 2 
    ...     circle_shape = np.sqrt(circle) &lt; radius 
    ...     image[circle_shape] = fillvalue 
    ...     return image 
    &gt;&gt;&gt; image = np.zeros((100, 100), dtype=np.uint8) 
    &gt;&gt;&gt; image[35:65, 20:80] = 1 
    &gt;&gt;&gt; image = add_circle(28, 65, 10, image) 
    &gt;&gt;&gt; image = add_circle(37, 30, 10, image) 
    &gt;&gt;&gt; image = add_circle(70, 45, 20, image) 
    &gt;&gt;&gt; image = add_circle(45, 80, 10, image) 
 
    Next, we set up the figure. 
 
    &gt;&gt;&gt; fig = plt.figure(figsize=(5, 15)) 
    &gt;&gt;&gt; grid = ImageGrid(fig, 111, nrows_ncols=(3, 1), axes_pad=(0.5, 0.3), 
    ...                  label_mode=&quot;1&quot;, share_all=True, 
    ...                  cbar_location=&quot;right&quot;, cbar_mode=&quot;each&quot;, 
    ...                  cbar_size=&quot;7%&quot;, cbar_pad=&quot;2%&quot;) 
    &gt;&gt;&gt; for ax in grid: 
    ...     ax.axis('off') 
    &gt;&gt;&gt; top, middle, bottom = grid 
    &gt;&gt;&gt; colorbar_ticks = [0, 10, 20] 
 
    The top image contains the original binary image. 
 
    &gt;&gt;&gt; binary_image = top.imshow(image, cmap='gray') 
    &gt;&gt;&gt; cbar_binary_image = top.cax.colorbar(binary_image) 
    &gt;&gt;&gt; cbar_binary_image.set_ticks([0, 1]) 
    &gt;&gt;&gt; top.set_title(&quot;Binary image: foreground in white&quot;) 
 
    The middle image contains the distance transform using the ``taxicab`` 
    metric. 
 
    &gt;&gt;&gt; distance_taxicab = distance_transform_cdt(image, metric=&quot;taxicab&quot;) 
    &gt;&gt;&gt; taxicab_transform = middle.imshow(distance_taxicab, cmap='gray') 
    &gt;&gt;&gt; cbar_taxicab = middle.cax.colorbar(taxicab_transform) 
    &gt;&gt;&gt; cbar_taxicab.set_ticks(colorbar_ticks) 
    &gt;&gt;&gt; middle.set_title(&quot;Taxicab metric&quot;) 
 
    The bottom image contains the distance transform using the ``chessboard`` 
    metric. 
 
    &gt;&gt;&gt; distance_chessboard = distance_transform_cdt(image, 
    ...                                              metric=&quot;chessboard&quot;) 
    &gt;&gt;&gt; chessboard_transform = bottom.imshow(distance_chessboard, cmap='gray') 
    &gt;&gt;&gt; cbar_chessboard = bottom.cax.colorbar(chessboard_transform) 
    &gt;&gt;&gt; cbar_chessboard.set_ticks(colorbar_ticks) 
    &gt;&gt;&gt; bottom.set_title(&quot;Chessboard metric&quot;) 
    &gt;&gt;&gt; plt.tight_layout() 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span>
    <span class="s1">ft_inplace </span><span class="s3">= </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">indices</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndarray</span><span class="s3">)</span>
    <span class="s1">dt_inplace </span><span class="s3">= </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">distances</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndarray</span><span class="s3">)</span>
    <span class="s1">_distance_tranform_arg_check</span><span class="s3">(</span>
        <span class="s1">dt_inplace</span><span class="s3">, </span><span class="s1">ft_inplace</span><span class="s3">, </span><span class="s1">return_distances</span><span class="s3">, </span><span class="s1">return_indices</span>
    <span class="s3">)</span>
    <span class="s1">input </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">input</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">metric</span><span class="s3">, </span><span class="s1">str</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">metric </span><span class="s2">in </span><span class="s3">[</span><span class="s4">'taxicab'</span><span class="s3">, </span><span class="s4">'cityblock'</span><span class="s3">, </span><span class="s4">'manhattan'</span><span class="s3">]:</span>
            <span class="s1">rank </span><span class="s3">= </span><span class="s1">input</span><span class="s3">.</span><span class="s1">ndim</span>
            <span class="s1">metric </span><span class="s3">= </span><span class="s1">generate_binary_structure</span><span class="s3">(</span><span class="s1">rank</span><span class="s3">, </span><span class="s5">1</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">metric </span><span class="s3">== </span><span class="s4">'chessboard'</span><span class="s3">:</span>
            <span class="s1">rank </span><span class="s3">= </span><span class="s1">input</span><span class="s3">.</span><span class="s1">ndim</span>
            <span class="s1">metric </span><span class="s3">= </span><span class="s1">generate_binary_structure</span><span class="s3">(</span><span class="s1">rank</span><span class="s3">, </span><span class="s1">rank</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'invalid metric provided'</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s1">metric </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">metric</span><span class="s3">)</span>
        <span class="s2">except </span><span class="s1">Exception </span><span class="s2">as </span><span class="s1">e</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'invalid metric provided'</span><span class="s3">) </span><span class="s2">from </span><span class="s1">e</span>
        <span class="s2">for </span><span class="s1">s </span><span class="s2">in </span><span class="s1">metric</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">s </span><span class="s3">!= </span><span class="s5">3</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'metric sizes must be equal to 3'</span><span class="s3">)</span>

    <span class="s2">if not </span><span class="s1">metric</span><span class="s3">.</span><span class="s1">flags</span><span class="s3">.</span><span class="s1">contiguous</span><span class="s3">:</span>
        <span class="s1">metric </span><span class="s3">= </span><span class="s1">metric</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>
    <span class="s2">if </span><span class="s1">dt_inplace</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">distances</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">type </span><span class="s3">!= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">int32</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'distances must be of int32 type'</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">distances</span><span class="s3">.</span><span class="s1">shape </span><span class="s3">!= </span><span class="s1">input</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'distances has wrong shape'</span><span class="s3">)</span>
        <span class="s1">dt </span><span class="s3">= </span><span class="s1">distances</span>
        <span class="s1">dt</span><span class="s3">[...] = </span><span class="s1">np</span><span class="s3">.</span><span class="s1">where</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s3">).</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">int32</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">dt </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">where</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s3">).</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">int32</span><span class="s3">)</span>

    <span class="s1">rank </span><span class="s3">= </span><span class="s1">dt</span><span class="s3">.</span><span class="s1">ndim</span>
    <span class="s2">if </span><span class="s1">return_indices</span><span class="s3">:</span>
        <span class="s1">ft </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s1">dt</span><span class="s3">.</span><span class="s1">size</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">int32</span><span class="s3">)</span>
        <span class="s1">ft</span><span class="s3">.</span><span class="s1">shape </span><span class="s3">= </span><span class="s1">dt</span><span class="s3">.</span><span class="s1">shape</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">ft </span><span class="s3">= </span><span class="s2">None</span>

    <span class="s1">_nd_image</span><span class="s3">.</span><span class="s1">distance_transform_op</span><span class="s3">(</span><span class="s1">metric</span><span class="s3">, </span><span class="s1">dt</span><span class="s3">, </span><span class="s1">ft</span><span class="s3">)</span>
    <span class="s1">dt </span><span class="s3">= </span><span class="s1">dt</span><span class="s3">[</span><span class="s1">tuple</span><span class="s3">([</span><span class="s1">slice</span><span class="s3">(</span><span class="s2">None</span><span class="s3">, </span><span class="s2">None</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">)] * </span><span class="s1">rank</span><span class="s3">)]</span>
    <span class="s2">if </span><span class="s1">return_indices</span><span class="s3">:</span>
        <span class="s1">ft </span><span class="s3">= </span><span class="s1">ft</span><span class="s3">[</span><span class="s1">tuple</span><span class="s3">([</span><span class="s1">slice</span><span class="s3">(</span><span class="s2">None</span><span class="s3">, </span><span class="s2">None</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">)] * </span><span class="s1">rank</span><span class="s3">)]</span>
    <span class="s1">_nd_image</span><span class="s3">.</span><span class="s1">distance_transform_op</span><span class="s3">(</span><span class="s1">metric</span><span class="s3">, </span><span class="s1">dt</span><span class="s3">, </span><span class="s1">ft</span><span class="s3">)</span>
    <span class="s1">dt </span><span class="s3">= </span><span class="s1">dt</span><span class="s3">[</span><span class="s1">tuple</span><span class="s3">([</span><span class="s1">slice</span><span class="s3">(</span><span class="s2">None</span><span class="s3">, </span><span class="s2">None</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">)] * </span><span class="s1">rank</span><span class="s3">)]</span>
    <span class="s2">if </span><span class="s1">return_indices</span><span class="s3">:</span>
        <span class="s1">ft </span><span class="s3">= </span><span class="s1">ft</span><span class="s3">[</span><span class="s1">tuple</span><span class="s3">([</span><span class="s1">slice</span><span class="s3">(</span><span class="s2">None</span><span class="s3">, </span><span class="s2">None</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">)] * </span><span class="s1">rank</span><span class="s3">)]</span>
        <span class="s1">ft </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ravel</span><span class="s3">(</span><span class="s1">ft</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">ft_inplace</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">indices</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">type </span><span class="s3">!= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">int32</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'indices array must be int32'</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">indices</span><span class="s3">.</span><span class="s1">shape </span><span class="s3">!= (</span><span class="s1">dt</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">,) + </span><span class="s1">dt</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'indices array has wrong shape'</span><span class="s3">)</span>
            <span class="s1">tmp </span><span class="s3">= </span><span class="s1">indices</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">tmp </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">indices</span><span class="s3">(</span><span class="s1">dt</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">int32</span><span class="s3">)</span>
        <span class="s2">for </span><span class="s1">ii </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">tmp</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]):</span>
            <span class="s1">rtmp </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ravel</span><span class="s3">(</span><span class="s1">tmp</span><span class="s3">[</span><span class="s1">ii</span><span class="s3">, ...])[</span><span class="s1">ft</span><span class="s3">]</span>
            <span class="s1">rtmp</span><span class="s3">.</span><span class="s1">shape </span><span class="s3">= </span><span class="s1">dt</span><span class="s3">.</span><span class="s1">shape</span>
            <span class="s1">tmp</span><span class="s3">[</span><span class="s1">ii</span><span class="s3">, ...] = </span><span class="s1">rtmp</span>
        <span class="s1">ft </span><span class="s3">= </span><span class="s1">tmp</span>

    <span class="s0"># construct and return the result</span>
    <span class="s1">result </span><span class="s3">= []</span>
    <span class="s2">if </span><span class="s1">return_distances </span><span class="s2">and not </span><span class="s1">dt_inplace</span><span class="s3">:</span>
        <span class="s1">result</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">dt</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">return_indices </span><span class="s2">and not </span><span class="s1">ft_inplace</span><span class="s3">:</span>
        <span class="s1">result</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">ft</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">result</span><span class="s3">) == </span><span class="s5">2</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">result</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">len</span><span class="s3">(</span><span class="s1">result</span><span class="s3">) == </span><span class="s5">1</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">result</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">return None</span>


<span class="s2">def </span><span class="s1">distance_transform_edt</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">sampling</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">return_distances</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
                           <span class="s1">return_indices</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">distances</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Exact Euclidean distance transform. 
 
    This function calculates the distance transform of the `input`, by 
    replacing each foreground (non-zero) element, with its 
    shortest distance to the background (any zero-valued element). 
 
    In addition to the distance transform, the feature transform can 
    be calculated. In this case the index of the closest background 
    element to each foreground element is returned in a separate array. 
 
    Parameters 
    ---------- 
    input : array_like 
        Input data to transform. Can be any type but will be converted 
        into binary: 1 wherever input equates to True, 0 elsewhere. 
    sampling : float, or sequence of float, optional 
        Spacing of elements along each dimension. If a sequence, must be of 
        length equal to the input rank; if a single number, this is used for 
        all axes. If not specified, a grid spacing of unity is implied. 
    return_distances : bool, optional 
        Whether to calculate the distance transform. 
        Default is True. 
    return_indices : bool, optional 
        Whether to calculate the feature transform. 
        Default is False. 
    distances : float64 ndarray, optional 
        An output array to store the calculated distance transform, instead of 
        returning it. 
        `return_distances` must be True. 
        It must be the same shape as `input`. 
    indices : int32 ndarray, optional 
        An output array to store the calculated feature transform, instead of 
        returning it. 
        `return_indicies` must be True. 
        Its shape must be `(input.ndim,) + input.shape`. 
 
    Returns 
    ------- 
    distances : float64 ndarray, optional 
        The calculated distance transform. Returned only when 
        `return_distances` is True and `distances` is not supplied. 
        It will have the same shape as the input array. 
    indices : int32 ndarray, optional 
        The calculated feature transform. It has an input-shaped array for each 
        dimension of the input. See example below. 
        Returned only when `return_indices` is True and `indices` is not 
        supplied. 
 
    Notes 
    ----- 
    The Euclidean distance transform gives values of the Euclidean 
    distance:: 
 
                    n 
      y_i = sqrt(sum (x[i]-b[i])**2) 
                    i 
 
    where b[i] is the background point (value 0) with the smallest 
    Euclidean distance to input points x[i], and n is the 
    number of dimensions. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy import ndimage 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; a = np.array(([0,1,1,1,1], 
    ...               [0,0,1,1,1], 
    ...               [0,1,1,1,1], 
    ...               [0,1,1,1,0], 
    ...               [0,1,1,0,0])) 
    &gt;&gt;&gt; ndimage.distance_transform_edt(a) 
    array([[ 0.    ,  1.    ,  1.4142,  2.2361,  3.    ], 
           [ 0.    ,  0.    ,  1.    ,  2.    ,  2.    ], 
           [ 0.    ,  1.    ,  1.4142,  1.4142,  1.    ], 
           [ 0.    ,  1.    ,  1.4142,  1.    ,  0.    ], 
           [ 0.    ,  1.    ,  1.    ,  0.    ,  0.    ]]) 
 
    With a sampling of 2 units along x, 1 along y: 
 
    &gt;&gt;&gt; ndimage.distance_transform_edt(a, sampling=[2,1]) 
    array([[ 0.    ,  1.    ,  2.    ,  2.8284,  3.6056], 
           [ 0.    ,  0.    ,  1.    ,  2.    ,  3.    ], 
           [ 0.    ,  1.    ,  2.    ,  2.2361,  2.    ], 
           [ 0.    ,  1.    ,  2.    ,  1.    ,  0.    ], 
           [ 0.    ,  1.    ,  1.    ,  0.    ,  0.    ]]) 
 
    Asking for indices as well: 
 
    &gt;&gt;&gt; edt, inds = ndimage.distance_transform_edt(a, return_indices=True) 
    &gt;&gt;&gt; inds 
    array([[[0, 0, 1, 1, 3], 
            [1, 1, 1, 1, 3], 
            [2, 2, 1, 3, 3], 
            [3, 3, 4, 4, 3], 
            [4, 4, 4, 4, 4]], 
           [[0, 0, 1, 1, 4], 
            [0, 1, 1, 1, 4], 
            [0, 0, 1, 4, 4], 
            [0, 0, 3, 3, 4], 
            [0, 0, 3, 3, 4]]]) 
 
    With arrays provided for inplace outputs: 
 
    &gt;&gt;&gt; indices = np.zeros(((np.ndim(a),) + a.shape), dtype=np.int32) 
    &gt;&gt;&gt; ndimage.distance_transform_edt(a, return_indices=True, indices=indices) 
    array([[ 0.    ,  1.    ,  1.4142,  2.2361,  3.    ], 
           [ 0.    ,  0.    ,  1.    ,  2.    ,  2.    ], 
           [ 0.    ,  1.    ,  1.4142,  1.4142,  1.    ], 
           [ 0.    ,  1.    ,  1.4142,  1.    ,  0.    ], 
           [ 0.    ,  1.    ,  1.    ,  0.    ,  0.    ]]) 
    &gt;&gt;&gt; indices 
    array([[[0, 0, 1, 1, 3], 
            [1, 1, 1, 1, 3], 
            [2, 2, 1, 3, 3], 
            [3, 3, 4, 4, 3], 
            [4, 4, 4, 4, 4]], 
           [[0, 0, 1, 1, 4], 
            [0, 1, 1, 1, 4], 
            [0, 0, 1, 4, 4], 
            [0, 0, 3, 3, 4], 
            [0, 0, 3, 3, 4]]]) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">ft_inplace </span><span class="s3">= </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">indices</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndarray</span><span class="s3">)</span>
    <span class="s1">dt_inplace </span><span class="s3">= </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">distances</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndarray</span><span class="s3">)</span>
    <span class="s1">_distance_tranform_arg_check</span><span class="s3">(</span>
        <span class="s1">dt_inplace</span><span class="s3">, </span><span class="s1">ft_inplace</span><span class="s3">, </span><span class="s1">return_distances</span><span class="s3">, </span><span class="s1">return_indices</span>
    <span class="s3">)</span>

    <span class="s0"># calculate the feature transform</span>
    <span class="s1">input </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">atleast_1d</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">where</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s3">).</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">int8</span><span class="s3">))</span>
    <span class="s2">if </span><span class="s1">sampling </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s1">sampling </span><span class="s3">= </span><span class="s1">_ni_support</span><span class="s3">.</span><span class="s1">_normalize_sequence</span><span class="s3">(</span><span class="s1">sampling</span><span class="s3">, </span><span class="s1">input</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">)</span>
        <span class="s1">sampling </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">sampling</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">)</span>
        <span class="s2">if not </span><span class="s1">sampling</span><span class="s3">.</span><span class="s1">flags</span><span class="s3">.</span><span class="s1">contiguous</span><span class="s3">:</span>
            <span class="s1">sampling </span><span class="s3">= </span><span class="s1">sampling</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>

    <span class="s2">if </span><span class="s1">ft_inplace</span><span class="s3">:</span>
        <span class="s1">ft </span><span class="s3">= </span><span class="s1">indices</span>
        <span class="s2">if </span><span class="s1">ft</span><span class="s3">.</span><span class="s1">shape </span><span class="s3">!= (</span><span class="s1">input</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">,) + </span><span class="s1">input</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">RuntimeError</span><span class="s3">(</span><span class="s4">'indices array has wrong shape'</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">ft</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">type </span><span class="s3">!= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">int32</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">RuntimeError</span><span class="s3">(</span><span class="s4">'indices array must be int32'</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">ft </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">((</span><span class="s1">input</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">,) + </span><span class="s1">input</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">int32</span><span class="s3">)</span>

    <span class="s1">_nd_image</span><span class="s3">.</span><span class="s1">euclidean_feature_transform</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">sampling</span><span class="s3">, </span><span class="s1">ft</span><span class="s3">)</span>
    <span class="s0"># if requested, calculate the distance transform</span>
    <span class="s2">if </span><span class="s1">return_distances</span><span class="s3">:</span>
        <span class="s1">dt </span><span class="s3">= </span><span class="s1">ft </span><span class="s3">- </span><span class="s1">np</span><span class="s3">.</span><span class="s1">indices</span><span class="s3">(</span><span class="s1">input</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">ft</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>
        <span class="s1">dt </span><span class="s3">= </span><span class="s1">dt</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">sampling </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s2">for </span><span class="s1">ii </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">sampling</span><span class="s3">)):</span>
                <span class="s1">dt</span><span class="s3">[</span><span class="s1">ii</span><span class="s3">, ...] *= </span><span class="s1">sampling</span><span class="s3">[</span><span class="s1">ii</span><span class="s3">]</span>
        <span class="s1">np</span><span class="s3">.</span><span class="s1">multiply</span><span class="s3">(</span><span class="s1">dt</span><span class="s3">, </span><span class="s1">dt</span><span class="s3">, </span><span class="s1">dt</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">dt_inplace</span><span class="s3">:</span>
            <span class="s1">dt </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">add</span><span class="s3">.</span><span class="s1">reduce</span><span class="s3">(</span><span class="s1">dt</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s5">0</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">distances</span><span class="s3">.</span><span class="s1">shape </span><span class="s3">!= </span><span class="s1">dt</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">RuntimeError</span><span class="s3">(</span><span class="s4">'distances array has wrong shape'</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">distances</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">type </span><span class="s3">!= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">RuntimeError</span><span class="s3">(</span><span class="s4">'distances array must be float64'</span><span class="s3">)</span>
            <span class="s1">np</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s1">dt</span><span class="s3">, </span><span class="s1">distances</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">dt </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">add</span><span class="s3">.</span><span class="s1">reduce</span><span class="s3">(</span><span class="s1">dt</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s5">0</span><span class="s3">)</span>
            <span class="s1">dt </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s1">dt</span><span class="s3">)</span>

    <span class="s0"># construct and return the result</span>
    <span class="s1">result </span><span class="s3">= []</span>
    <span class="s2">if </span><span class="s1">return_distances </span><span class="s2">and not </span><span class="s1">dt_inplace</span><span class="s3">:</span>
        <span class="s1">result</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">dt</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">return_indices </span><span class="s2">and not </span><span class="s1">ft_inplace</span><span class="s3">:</span>
        <span class="s1">result</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">ft</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">result</span><span class="s3">) == </span><span class="s5">2</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">result</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">len</span><span class="s3">(</span><span class="s1">result</span><span class="s3">) == </span><span class="s5">1</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">result</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">return None</span>


<span class="s2">def </span><span class="s1">_distance_tranform_arg_check</span><span class="s3">(</span><span class="s1">distances_out</span><span class="s3">, </span><span class="s1">indices_out</span><span class="s3">,</span>
                                 <span class="s1">return_distances</span><span class="s3">, </span><span class="s1">return_indices</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Raise a RuntimeError if the arguments are invalid&quot;&quot;&quot;</span>
    <span class="s1">error_msgs </span><span class="s3">= []</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s2">not </span><span class="s1">return_distances</span><span class="s3">) </span><span class="s2">and </span><span class="s3">(</span><span class="s2">not </span><span class="s1">return_indices</span><span class="s3">):</span>
        <span class="s1">error_msgs</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span>
            <span class="s4">'at least one of return_distances/return_indices must be True'</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">distances_out </span><span class="s2">and not </span><span class="s1">return_distances</span><span class="s3">:</span>
        <span class="s1">error_msgs</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span>
            <span class="s4">'return_distances must be True if distances is supplied'</span>
        <span class="s3">)</span>
    <span class="s2">if </span><span class="s1">indices_out </span><span class="s2">and not </span><span class="s1">return_indices</span><span class="s3">:</span>
        <span class="s1">error_msgs</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s4">'return_indices must be True if indices is supplied'</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">error_msgs</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">RuntimeError</span><span class="s3">(</span><span class="s4">', '</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">error_msgs</span><span class="s3">))</span>
</pre>
</body>
</html>