<html>
<head>
<title>PyGreenlet.cpp</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #6aab73;}
.s4 { color: #c77dbb;}
.s5 { color: #0da19e;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
PyGreenlet.cpp</font>
</center></td></tr></table>
<pre><span class="s0">/* -*- indent-tabs-mode: nil; tab-width: 4; -*- */</span>
<span class="s2">#ifndef </span><span class="s1">PYGREENLET_CPP</span>
<span class="s2">#define </span><span class="s1">PYGREENLET_CPP</span>
<span class="s0">/***************** 
The Python slot functions for TGreenlet. 
 */</span>


<span class="s2">#define </span><span class="s1">PY_SSIZE_T_CLEAN</span>
<span class="s2">#include </span><span class="s1">&lt;Python.h&gt;</span>
<span class="s2">#include </span><span class="s3">&quot;structmember.h&quot; </span><span class="s0">// PyMemberDef</span>

<span class="s2">#include </span><span class="s3">&quot;greenlet_internal.hpp&quot;</span>
<span class="s2">#include </span><span class="s3">&quot;TThreadStateDestroy.cpp&quot;</span>
<span class="s2">#include </span><span class="s3">&quot;TGreenlet.hpp&quot;</span>
<span class="s0">// #include &quot;TUserGreenlet.cpp&quot;</span>
<span class="s0">// #include &quot;TMainGreenlet.cpp&quot;</span>
<span class="s0">// #include &quot;TBrokenGreenlet.cpp&quot;</span>


<span class="s2">#include </span><span class="s3">&quot;greenlet_refs.hpp&quot;</span>
<span class="s2">#include </span><span class="s3">&quot;greenlet_slp_switch.hpp&quot;</span>

<span class="s2">#include </span><span class="s3">&quot;greenlet_thread_support.hpp&quot;</span>
<span class="s2">#include </span><span class="s3">&quot;TGreenlet.hpp&quot;</span>

<span class="s2">#include </span><span class="s3">&quot;TGreenletGlobals.cpp&quot;</span>
<span class="s2">#include </span><span class="s3">&quot;TThreadStateDestroy.cpp&quot;</span>
<span class="s2">#include </span><span class="s3">&quot;PyGreenlet.hpp&quot;</span>
<span class="s0">// #include &quot;TGreenlet.cpp&quot;</span>

<span class="s0">// #include &quot;TExceptionState.cpp&quot;</span>
<span class="s0">// #include &quot;TPythonState.cpp&quot;</span>
<span class="s0">// #include &quot;TStackState.cpp&quot;</span>

<span class="s4">using </span><span class="s1">greenlet::LockGuard;</span>
<span class="s4">using </span><span class="s1">greenlet::LockInitError;</span>
<span class="s4">using </span><span class="s1">greenlet::PyErrOccurred;</span>
<span class="s4">using </span><span class="s1">greenlet::Require;</span>

<span class="s4">using </span><span class="s1">greenlet::g_handle_exit;</span>
<span class="s4">using </span><span class="s1">greenlet::single_result;</span>

<span class="s4">using </span><span class="s1">greenlet::Greenlet;</span>
<span class="s4">using </span><span class="s1">greenlet::UserGreenlet;</span>
<span class="s4">using </span><span class="s1">greenlet::MainGreenlet;</span>
<span class="s4">using </span><span class="s1">greenlet::BrokenGreenlet;</span>
<span class="s4">using </span><span class="s1">greenlet::ThreadState;</span>
<span class="s4">using </span><span class="s1">greenlet::PythonState;</span>



<span class="s2">static </span><span class="s1">PyGreenlet*</span>
<span class="s1">green_new(PyTypeObject* type, PyObject* UNUSED(args), PyObject* UNUSED(kwds))</span>
<span class="s1">{</span>
    <span class="s1">PyGreenlet* o =</span>
        <span class="s1">(PyGreenlet*)PyBaseObject_Type.tp_new(type, mod_globs</span><span class="s5">-&gt;</span><span class="s1">empty_tuple, mod_globs</span><span class="s5">-&gt;</span><span class="s1">empty_dict);</span>
    <span class="s2">if </span><span class="s1">(o) {</span>
        <span class="s4">new </span><span class="s1">UserGreenlet(o, GET_THREAD_STATE().state().borrow_current());</span>
        <span class="s1">assert(Py_REFCNT(o) == </span><span class="s6">1</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">o;</span>
<span class="s1">}</span>


<span class="s0">// green_init is used in the tp_init slot. So it's important that</span>
<span class="s0">// it can be called directly from CPython. Thus, we don't use</span>
<span class="s0">// BorrowedGreenlet and BorrowedObject --- although in theory</span>
<span class="s0">// these should be binary layout compatible, that may not be</span>
<span class="s0">// guaranteed to be the case (32-bit linux ppc possibly).</span>
<span class="s2">static int</span>
<span class="s1">green_init(PyGreenlet* self, PyObject* args, PyObject* kwargs)</span>
<span class="s1">{</span>
    <span class="s1">PyArgParseParam run;</span>
    <span class="s1">PyArgParseParam nparent;</span>
    <span class="s2">static const char</span><span class="s1">* kwlist[] = {</span>
        <span class="s3">&quot;run&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;parent&quot;</span><span class="s1">,</span>
        <span class="s1">NULL</span>
    <span class="s1">};</span>

    <span class="s0">// recall: The O specifier does NOT increase the reference count.</span>
    <span class="s2">if </span><span class="s1">(!PyArg_ParseTupleAndKeywords(</span>
             <span class="s1">args, kwargs, </span><span class="s3">&quot;|OO:green&quot;</span><span class="s1">, (</span><span class="s2">char</span><span class="s1">**)kwlist, &amp;run, &amp;nparent)) {</span>
        <span class="s2">return </span><span class="s1">-</span><span class="s6">1</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(run) {</span>
        <span class="s2">if </span><span class="s1">(green_setrun(self, run, NULL)) {</span>
            <span class="s2">return </span><span class="s1">-</span><span class="s6">1</span><span class="s1">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(nparent &amp;&amp; !nparent.is_None()) {</span>
        <span class="s2">return </span><span class="s1">green_setparent(self, nparent, NULL);</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s6">0</span><span class="s1">;</span>
<span class="s1">}</span>



<span class="s2">static int</span>
<span class="s1">green_traverse(PyGreenlet* self, visitproc visit, </span><span class="s2">void</span><span class="s1">* arg)</span>
<span class="s1">{</span>
    <span class="s0">// We must only visit referenced objects, i.e. only objects</span>
    <span class="s0">// Py_INCREF'ed by this greenlet (directly or indirectly):</span>
    <span class="s0">//</span>
    <span class="s0">// - stack_prev is not visited: holds previous stack pointer, but it's not</span>
    <span class="s0">//    referenced</span>
    <span class="s0">// - frames are not visited as we don't strongly reference them;</span>
    <span class="s0">//    alive greenlets are not garbage collected</span>
    <span class="s0">//    anyway. This can be a problem, however, if this greenlet is</span>
    <span class="s0">//    never allowed to finish, and is referenced from the frame: we</span>
    <span class="s0">//    have an uncollectible cycle in that case. Note that the</span>
    <span class="s0">//    frame object itself is also frequently not even tracked by the GC</span>
    <span class="s0">//    starting with Python 3.7 (frames are allocated by the</span>
    <span class="s0">//    interpreter untracked, and only become tracked when their</span>
    <span class="s0">//    evaluation is finished if they have a refcount &gt; 1). All of</span>
    <span class="s0">//    this is to say that we should probably strongly reference</span>
    <span class="s0">//    the frame object. Doing so, while always allowing GC on a</span>
    <span class="s0">//    greenlet, solves several leaks for us.</span>

    <span class="s1">Py_VISIT(self</span><span class="s5">-&gt;</span><span class="s1">dict);</span>
    <span class="s2">if </span><span class="s1">(!self</span><span class="s5">-&gt;</span><span class="s1">pimpl) {</span>
        <span class="s0">// Hmm. I have seen this at interpreter shutdown time,</span>
        <span class="s0">// I think. That's very odd because this doesn't go away until</span>
        <span class="s0">// we're ``green_dealloc()``, at which point we shouldn't be</span>
        <span class="s0">// traversed anymore.</span>
        <span class="s2">return </span><span class="s6">0</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">self</span><span class="s5">-&gt;</span><span class="s1">pimpl</span><span class="s5">-&gt;</span><span class="s1">tp_traverse(visit, arg);</span>
<span class="s1">}</span>

<span class="s2">static int</span>
<span class="s1">green_is_gc(PyObject* _self)</span>
<span class="s1">{</span>
    <span class="s1">BorrowedGreenlet self(_self);</span>
    <span class="s2">int </span><span class="s1">result = </span><span class="s6">0</span><span class="s1">;</span>
    <span class="s0">/* Main greenlet can be garbage collected since it can only 
       become unreachable if the underlying thread exited. 
       Active greenlets --- including those that are suspended --- 
       cannot be garbage collected, however. 
    */</span>
    <span class="s2">if </span><span class="s1">(self</span><span class="s5">-&gt;</span><span class="s1">main() || !self</span><span class="s5">-&gt;</span><span class="s1">active()) {</span>
        <span class="s1">result = </span><span class="s6">1</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">// The main greenlet pointer will eventually go away after the thread dies.</span>
    <span class="s2">if </span><span class="s1">(self</span><span class="s5">-&gt;</span><span class="s1">was_running_in_dead_thread()) {</span>
        <span class="s0">// Our thread is dead! We can never run again. Might as well</span>
        <span class="s0">// GC us. Note that if a tuple containing only us and other</span>
        <span class="s0">// immutable objects had been scanned before this, when we</span>
        <span class="s0">// would have returned 0, the tuple will take itself out of GC</span>
        <span class="s0">// tracking and never be investigated again. So that could</span>
        <span class="s0">// result in both us and the tuple leaking due to an</span>
        <span class="s0">// unreachable/uncollectible reference. The same goes for</span>
        <span class="s0">// dictionaries.</span>
        <span class="s0">//</span>
        <span class="s0">// It's not a great idea to be changing our GC state on the</span>
        <span class="s0">// fly.</span>
        <span class="s1">result = </span><span class="s6">1</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">result;</span>
<span class="s1">}</span>


<span class="s2">static int</span>
<span class="s1">green_clear(PyGreenlet* self)</span>
<span class="s1">{</span>
    <span class="s0">/* Greenlet is only cleared if it is about to be collected. 
       Since active greenlets are not garbage collectable, we can 
       be sure that, even if they are deallocated during clear, 
       nothing they reference is in unreachable or finalizers, 
       so even if it switches we are relatively safe. */</span>
    <span class="s0">// XXX: Are we responsible for clearing weakrefs here?</span>
    <span class="s1">Py_CLEAR(self</span><span class="s5">-&gt;</span><span class="s1">dict);</span>
    <span class="s2">return </span><span class="s1">self</span><span class="s5">-&gt;</span><span class="s1">pimpl</span><span class="s5">-&gt;</span><span class="s1">tp_clear();</span>
<span class="s1">}</span>

<span class="s0">/** 
 * Returns 0 on failure (the object was resurrected) or 1 on success. 
 **/</span>
<span class="s2">static int</span>
<span class="s1">_green_dealloc_kill_started_non_main_greenlet(BorrowedGreenlet self)</span>
<span class="s1">{</span>
    <span class="s0">/* Hacks hacks hacks copied from instance_dealloc() */</span>
    <span class="s0">/* Temporarily resurrect the greenlet. */</span>
    <span class="s1">assert(self.REFCNT() == </span><span class="s6">0</span><span class="s1">);</span>
    <span class="s1">Py_SET_REFCNT(self.borrow(), </span><span class="s6">1</span><span class="s1">);</span>
    <span class="s0">/* Save the current exception, if any. */</span>
    <span class="s1">PyErrPieces saved_err;</span>
    <span class="s4">try </span><span class="s1">{</span>
        <span class="s0">// BY THE TIME WE GET HERE, the state may actually be going</span>
        <span class="s0">// away</span>
        <span class="s0">// if we're shutting down the interpreter and freeing thread</span>
        <span class="s0">// entries,</span>
        <span class="s0">// this could result in freeing greenlets that were leaked. So</span>
        <span class="s0">// we can't try to read the state.</span>
        <span class="s1">self</span><span class="s5">-&gt;</span><span class="s1">deallocing_greenlet_in_thread(</span>
              <span class="s1">self</span><span class="s5">-&gt;</span><span class="s1">thread_state()</span>
              <span class="s1">? </span><span class="s4">static_cast</span><span class="s1">&lt;ThreadState*&gt;(GET_THREAD_STATE())</span>
              <span class="s1">: nullptr);</span>
    <span class="s1">}</span>
    <span class="s4">catch </span><span class="s1">(</span><span class="s2">const </span><span class="s1">PyErrOccurred&amp;) {</span>
        <span class="s1">PyErr_WriteUnraisable(self.borrow_o());</span>
        <span class="s0">/* XXX what else should we do? */</span>
    <span class="s1">}</span>
    <span class="s0">/* Check for no resurrection must be done while we keep 
     * our internal reference, otherwise PyFile_WriteObject 
     * causes recursion if using Py_INCREF/Py_DECREF 
     */</span>
    <span class="s2">if </span><span class="s1">(self.REFCNT() == </span><span class="s6">1 </span><span class="s1">&amp;&amp; self</span><span class="s5">-&gt;</span><span class="s1">active()) {</span>
        <span class="s0">/* Not resurrected, but still not dead! 
           XXX what else should we do? we complain. */</span>
        <span class="s1">PyObject* f = PySys_GetObject(</span><span class="s3">&quot;stderr&quot;</span><span class="s1">);</span>
        <span class="s1">Py_INCREF(self.borrow_o()); </span><span class="s0">/* leak! */</span>
        <span class="s2">if </span><span class="s1">(f != NULL) {</span>
            <span class="s1">PyFile_WriteString(</span><span class="s3">&quot;GreenletExit did not kill &quot;</span><span class="s1">, f);</span>
            <span class="s1">PyFile_WriteObject(self.borrow_o(), f, </span><span class="s6">0</span><span class="s1">);</span>
            <span class="s1">PyFile_WriteString(</span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">, f);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s0">/* Restore the saved exception. */</span>
    <span class="s1">saved_err.PyErrRestore();</span>
    <span class="s0">/* Undo the temporary resurrection; can't use DECREF here, 
     * it would cause a recursive call. 
     */</span>
    <span class="s1">assert(self.REFCNT() &gt; </span><span class="s6">0</span><span class="s1">);</span>

    <span class="s1">Py_ssize_t refcnt = self.REFCNT() - </span><span class="s6">1</span><span class="s1">;</span>
    <span class="s1">Py_SET_REFCNT(self.borrow_o(), refcnt);</span>
    <span class="s2">if </span><span class="s1">(refcnt != </span><span class="s6">0</span><span class="s1">) {</span>
        <span class="s0">/* Resurrected! */</span>
        <span class="s1">_Py_NewReference(self.borrow_o());</span>
        <span class="s1">Py_SET_REFCNT(self.borrow_o(), refcnt);</span>
        <span class="s0">/* Better to use tp_finalizer slot (PEP 442) 
         * and call ``PyObject_CallFinalizerFromDealloc``, 
         * but that's only supported in Python 3.4+; see 
         * Modules/_io/iobase.c for an example. 
         * 
         * The following approach is copied from iobase.c in CPython 2.7. 
         * (along with much of this function in general). Here's their 
         * comment: 
         * 
         * When called from a heap type's dealloc, the type will be 
         * decref'ed on return (see e.g. subtype_dealloc in typeobject.c). */</span>
        <span class="s2">if </span><span class="s1">(PyType_HasFeature(self.TYPE(), Py_TPFLAGS_HEAPTYPE)) {</span>
            <span class="s1">Py_INCREF(self.TYPE());</span>
        <span class="s1">}</span>

        <span class="s1">PyObject_GC_Track((PyObject*)self);</span>

        <span class="s1">_Py_DEC_REFTOTAL;</span>
<span class="s2">#ifdef </span><span class="s1">COUNT_ALLOCS</span>
        <span class="s1">--Py_TYPE(self)</span><span class="s5">-&gt;</span><span class="s1">tp_frees;</span>
        <span class="s1">--Py_TYPE(self)</span><span class="s5">-&gt;</span><span class="s1">tp_allocs;</span>
<span class="s2">#endif </span><span class="s0">/* COUNT_ALLOCS */</span>
        <span class="s2">return </span><span class="s6">0</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s6">1</span><span class="s1">;</span>
<span class="s1">}</span>


<span class="s2">static void</span>
<span class="s1">green_dealloc(PyGreenlet* self)</span>
<span class="s1">{</span>
    <span class="s1">PyObject_GC_UnTrack(self);</span>
    <span class="s1">BorrowedGreenlet me(self);</span>
    <span class="s2">if </span><span class="s1">(me</span><span class="s5">-&gt;</span><span class="s1">active()</span>
        <span class="s1">&amp;&amp; me</span><span class="s5">-&gt;</span><span class="s1">started()</span>
        <span class="s1">&amp;&amp; !me</span><span class="s5">-&gt;</span><span class="s1">main()) {</span>
        <span class="s2">if </span><span class="s1">(!_green_dealloc_kill_started_non_main_greenlet(me)) {</span>
            <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(self</span><span class="s5">-&gt;</span><span class="s1">weakreflist != NULL) {</span>
        <span class="s1">PyObject_ClearWeakRefs((PyObject*)self);</span>
    <span class="s1">}</span>
    <span class="s1">Py_CLEAR(self</span><span class="s5">-&gt;</span><span class="s1">dict);</span>

    <span class="s2">if </span><span class="s1">(self</span><span class="s5">-&gt;</span><span class="s1">pimpl) {</span>
        <span class="s0">// In case deleting this, which frees some memory,</span>
        <span class="s0">// somehow winds up calling back into us. That's usually a</span>
        <span class="s0">//bug in our code.</span>
        <span class="s1">Greenlet* p = self</span><span class="s5">-&gt;</span><span class="s1">pimpl;</span>
        <span class="s1">self</span><span class="s5">-&gt;</span><span class="s1">pimpl = nullptr;</span>
        <span class="s2">delete </span><span class="s1">p;</span>
    <span class="s1">}</span>
    <span class="s0">// and finally we're done. self is now invalid.</span>
    <span class="s1">Py_TYPE(self)</span><span class="s5">-&gt;</span><span class="s1">tp_free((PyObject*)self);</span>
<span class="s1">}</span>



<span class="s2">static </span><span class="s1">OwnedObject</span>
<span class="s1">internal_green_throw(BorrowedGreenlet self, PyErrPieces&amp; err_pieces)</span>
<span class="s1">{</span>
    <span class="s1">PyObject* result = nullptr;</span>
    <span class="s1">err_pieces.PyErrRestore();</span>
    <span class="s1">assert(PyErr_Occurred());</span>
    <span class="s2">if </span><span class="s1">(self</span><span class="s5">-&gt;</span><span class="s1">started() &amp;&amp; !self</span><span class="s5">-&gt;</span><span class="s1">active()) {</span>
        <span class="s0">/* dead greenlet: turn GreenletExit into a regular return */</span>
        <span class="s1">result = g_handle_exit(OwnedObject()).relinquish_ownership();</span>
    <span class="s1">}</span>
    <span class="s1">self</span><span class="s5">-&gt;</span><span class="s1">args() &lt;&lt;= result;</span>

    <span class="s2">return </span><span class="s1">single_result(self</span><span class="s5">-&gt;</span><span class="s1">g_switch());</span>
<span class="s1">}</span>



<span class="s1">PyDoc_STRVAR(</span>
    <span class="s1">green_switch_doc,</span>
    <span class="s3">&quot;switch(*args, **kwargs)</span><span class="s2">\n</span><span class="s3">&quot;</span>
    <span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span>
    <span class="s3">&quot;Switch execution to this greenlet.</span><span class="s2">\n</span><span class="s3">&quot;</span>
    <span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span>
    <span class="s3">&quot;If this greenlet has never been run, then this greenlet</span><span class="s2">\n</span><span class="s3">&quot;</span>
    <span class="s3">&quot;will be switched to using the body of ``self.run(*args, **kwargs)``.</span><span class="s2">\n</span><span class="s3">&quot;</span>
    <span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span>
    <span class="s3">&quot;If the greenlet is active (has been run, but was switch()'ed</span><span class="s2">\n</span><span class="s3">&quot;</span>
    <span class="s3">&quot;out before leaving its run function), then this greenlet will</span><span class="s2">\n</span><span class="s3">&quot;</span>
    <span class="s3">&quot;be resumed and the return value to its switch call will be</span><span class="s2">\n</span><span class="s3">&quot;</span>
    <span class="s3">&quot;None if no arguments are given, the given argument if one</span><span class="s2">\n</span><span class="s3">&quot;</span>
    <span class="s3">&quot;argument is given, or the args tuple and keyword args dict if</span><span class="s2">\n</span><span class="s3">&quot;</span>
    <span class="s3">&quot;multiple arguments are given.</span><span class="s2">\n</span><span class="s3">&quot;</span>
    <span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span>
    <span class="s3">&quot;If the greenlet is dead, or is the current greenlet then this</span><span class="s2">\n</span><span class="s3">&quot;</span>
    <span class="s3">&quot;function will simply return the arguments using the same rules as</span><span class="s2">\n</span><span class="s3">&quot;</span>
    <span class="s3">&quot;above.</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">);</span>

<span class="s2">static </span><span class="s1">PyObject*</span>
<span class="s1">green_switch(PyGreenlet* self, PyObject* args, PyObject* kwargs)</span>
<span class="s1">{</span>
    <span class="s4">using </span><span class="s1">greenlet::SwitchingArgs;</span>
    <span class="s1">SwitchingArgs switch_args(OwnedObject::owning(args), OwnedObject::owning(kwargs));</span>
    <span class="s1">self</span><span class="s5">-&gt;</span><span class="s1">pimpl</span><span class="s5">-&gt;</span><span class="s1">may_switch_away();</span>
    <span class="s1">self</span><span class="s5">-&gt;</span><span class="s1">pimpl</span><span class="s5">-&gt;</span><span class="s1">args() &lt;&lt;= switch_args;</span>

    <span class="s0">// If we're switching out of a greenlet, and that switch is the</span>
    <span class="s0">// last thing the greenlet does, the greenlet ought to be able to</span>
    <span class="s0">// go ahead and die at that point. Currently, someone else must</span>
    <span class="s0">// manually switch back to the greenlet so that we &quot;fall off the</span>
    <span class="s0">// end&quot; and can perform cleanup. You'd think we'd be able to</span>
    <span class="s0">// figure out that this is happening using the frame's ``f_lasti``</span>
    <span class="s0">// member, which is supposed to be an index into</span>
    <span class="s0">// ``frame-&gt;f_code-&gt;co_code``, the bytecode string. However, in</span>
    <span class="s0">// recent interpreters, ``f_lasti`` tends not to be updated thanks</span>
    <span class="s0">// to things like the PREDICT() macros in ceval.c. So it doesn't</span>
    <span class="s0">// really work to do that in many cases. For example, the Python</span>
    <span class="s0">// code:</span>
    <span class="s0">//     def run():</span>
    <span class="s0">//         greenlet.getcurrent().parent.switch()</span>
    <span class="s0">// produces bytecode of len 16, with the actual call to switch()</span>
    <span class="s0">// being at index 10 (in Python 3.10). However, the reported</span>
    <span class="s0">// ``f_lasti`` we actually see is...5! (Which happens to be the</span>
    <span class="s0">// second byte of the CALL_METHOD op for ``getcurrent()``).</span>

    <span class="s4">try </span><span class="s1">{</span>
        <span class="s0">//OwnedObject result = single_result(self-&gt;pimpl-&gt;g_switch());</span>
        <span class="s1">OwnedObject result(single_result(self</span><span class="s5">-&gt;</span><span class="s1">pimpl</span><span class="s5">-&gt;</span><span class="s1">g_switch()));</span>
<span class="s2">#ifndef </span><span class="s1">NDEBUG</span>
        <span class="s0">// Note that the current greenlet isn't necessarily self. If self</span>
        <span class="s0">// finished, we went to one of its parents.</span>
        <span class="s1">assert(!self</span><span class="s5">-&gt;</span><span class="s1">pimpl</span><span class="s5">-&gt;</span><span class="s1">args());</span>

        <span class="s2">const </span><span class="s1">BorrowedGreenlet&amp; current = GET_THREAD_STATE().state().borrow_current();</span>
        <span class="s0">// It's possible it's never been switched to.</span>
        <span class="s1">assert(!current</span><span class="s5">-&gt;</span><span class="s1">args());</span>
<span class="s2">#endif</span>
        <span class="s1">PyObject* p = result.relinquish_ownership();</span>

        <span class="s2">if </span><span class="s1">(!p &amp;&amp; !PyErr_Occurred()) {</span>
            <span class="s0">// This shouldn't be happening anymore, so the asserts</span>
            <span class="s0">// are there for debug builds. Non-debug builds</span>
            <span class="s0">// crash &quot;gracefully&quot; in this case, although there is an</span>
            <span class="s0">// argument to be made for killing the process in all</span>
            <span class="s0">// cases --- for this to be the case, our switches</span>
            <span class="s0">// probably nested in an incorrect way, so the state is</span>
            <span class="s0">// suspicious. Nothing should be corrupt though, just</span>
            <span class="s0">// confused at the Python level. Letting this propagate is</span>
            <span class="s0">// probably good enough.</span>
            <span class="s1">assert(p || PyErr_Occurred());</span>
            <span class="s4">throw </span><span class="s1">PyErrOccurred(</span>
                <span class="s1">mod_globs</span><span class="s5">-&gt;</span><span class="s1">PyExc_GreenletError,</span>
                <span class="s3">&quot;Greenlet.switch() returned NULL without an exception set.&quot;</span>
            <span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">p;</span>
    <span class="s1">}</span>
    <span class="s4">catch</span><span class="s1">(</span><span class="s2">const </span><span class="s1">PyErrOccurred&amp;) {</span>
        <span class="s2">return </span><span class="s1">nullptr;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">PyDoc_STRVAR(</span>
    <span class="s1">green_throw_doc,</span>
    <span class="s3">&quot;Switches execution to this greenlet, but immediately raises the</span><span class="s2">\n</span><span class="s3">&quot;</span>
    <span class="s3">&quot;given exception in this greenlet.  If no argument is provided, the &quot;</span>
    <span class="s3">&quot;exception</span><span class="s2">\n</span><span class="s3">&quot;</span>
    <span class="s3">&quot;defaults to `greenlet.GreenletExit`.  The normal exception</span><span class="s2">\n</span><span class="s3">&quot;</span>
    <span class="s3">&quot;propagation rules apply, as described for `switch`.  Note that calling &quot;</span>
    <span class="s3">&quot;this</span><span class="s2">\n</span><span class="s3">&quot;</span>
    <span class="s3">&quot;method is almost equivalent to the following::</span><span class="s2">\n</span><span class="s3">&quot;</span>
    <span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span>
    <span class="s3">&quot;    def raiser():</span><span class="s2">\n</span><span class="s3">&quot;</span>
    <span class="s3">&quot;        raise typ, val, tb</span><span class="s2">\n</span><span class="s3">&quot;</span>
    <span class="s3">&quot;    g_raiser = greenlet(raiser, parent=g)</span><span class="s2">\n</span><span class="s3">&quot;</span>
    <span class="s3">&quot;    g_raiser.switch()</span><span class="s2">\n</span><span class="s3">&quot;</span>
    <span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span>
    <span class="s3">&quot;except that this trick does not work for the</span><span class="s2">\n</span><span class="s3">&quot;</span>
    <span class="s3">&quot;`greenlet.GreenletExit` exception, which would not propagate</span><span class="s2">\n</span><span class="s3">&quot;</span>
    <span class="s3">&quot;from ``g_raiser`` to ``g``.</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">);</span>

<span class="s2">static </span><span class="s1">PyObject*</span>
<span class="s1">green_throw(PyGreenlet* self, PyObject* args)</span>
<span class="s1">{</span>
    <span class="s1">PyArgParseParam typ(mod_globs</span><span class="s5">-&gt;</span><span class="s1">PyExc_GreenletExit);</span>
    <span class="s1">PyArgParseParam val;</span>
    <span class="s1">PyArgParseParam tb;</span>

    <span class="s2">if </span><span class="s1">(!PyArg_ParseTuple(args, </span><span class="s3">&quot;|OOO:throw&quot;</span><span class="s1">, &amp;typ, &amp;val, &amp;tb)) {</span>
        <span class="s2">return </span><span class="s1">nullptr;</span>
    <span class="s1">}</span>

    <span class="s1">assert(typ.borrow() || val.borrow());</span>

    <span class="s1">self</span><span class="s5">-&gt;</span><span class="s1">pimpl</span><span class="s5">-&gt;</span><span class="s1">may_switch_away();</span>
    <span class="s4">try </span><span class="s1">{</span>
        <span class="s0">// Both normalizing the error and the actual throw_greenlet</span>
        <span class="s0">// could throw PyErrOccurred.</span>
        <span class="s1">PyErrPieces err_pieces(typ.borrow(), val.borrow(), tb.borrow());</span>

        <span class="s2">return </span><span class="s1">internal_green_throw(self, err_pieces).relinquish_ownership();</span>
    <span class="s1">}</span>
    <span class="s4">catch </span><span class="s1">(</span><span class="s2">const </span><span class="s1">PyErrOccurred&amp;) {</span>
        <span class="s2">return </span><span class="s1">nullptr;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">static int</span>
<span class="s1">green_bool(PyGreenlet* self)</span>
<span class="s1">{</span>
    <span class="s2">return </span><span class="s1">self</span><span class="s5">-&gt;</span><span class="s1">pimpl</span><span class="s5">-&gt;</span><span class="s1">active();</span>
<span class="s1">}</span>

<span class="s0">/** 
 * CAUTION: Allocates memory, may run GC and arbitrary Python code. 
 */</span>
<span class="s2">static </span><span class="s1">PyObject*</span>
<span class="s1">green_getdict(PyGreenlet* self, </span><span class="s2">void</span><span class="s1">* UNUSED(context))</span>
<span class="s1">{</span>
    <span class="s2">if </span><span class="s1">(self</span><span class="s5">-&gt;</span><span class="s1">dict == NULL) {</span>
        <span class="s1">self</span><span class="s5">-&gt;</span><span class="s1">dict = PyDict_New();</span>
        <span class="s2">if </span><span class="s1">(self</span><span class="s5">-&gt;</span><span class="s1">dict == NULL) {</span>
            <span class="s2">return </span><span class="s1">NULL;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">Py_INCREF(self</span><span class="s5">-&gt;</span><span class="s1">dict);</span>
    <span class="s2">return </span><span class="s1">self</span><span class="s5">-&gt;</span><span class="s1">dict;</span>
<span class="s1">}</span>

<span class="s2">static int</span>
<span class="s1">green_setdict(PyGreenlet* self, PyObject* val, </span><span class="s2">void</span><span class="s1">* UNUSED(context))</span>
<span class="s1">{</span>
    <span class="s1">PyObject* tmp;</span>

    <span class="s2">if </span><span class="s1">(val == NULL) {</span>
        <span class="s1">PyErr_SetString(PyExc_TypeError, </span><span class="s3">&quot;__dict__ may not be deleted&quot;</span><span class="s1">);</span>
        <span class="s2">return </span><span class="s1">-</span><span class="s6">1</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(!PyDict_Check(val)) {</span>
        <span class="s1">PyErr_SetString(PyExc_TypeError, </span><span class="s3">&quot;__dict__ must be a dictionary&quot;</span><span class="s1">);</span>
        <span class="s2">return </span><span class="s1">-</span><span class="s6">1</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">tmp = self</span><span class="s5">-&gt;</span><span class="s1">dict;</span>
    <span class="s1">Py_INCREF(val);</span>
    <span class="s1">self</span><span class="s5">-&gt;</span><span class="s1">dict = val;</span>
    <span class="s1">Py_XDECREF(tmp);</span>
    <span class="s2">return </span><span class="s6">0</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">static bool</span>
<span class="s1">_green_not_dead(BorrowedGreenlet self)</span>
<span class="s1">{</span>
    <span class="s0">// XXX: Where else should we do this?</span>
    <span class="s0">// Probably on entry to most Python-facing functions?</span>
    <span class="s2">if </span><span class="s1">(self</span><span class="s5">-&gt;</span><span class="s1">was_running_in_dead_thread()) {</span>
        <span class="s1">self</span><span class="s5">-&gt;</span><span class="s1">deactivate_and_free();</span>
        <span class="s2">return false</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">self</span><span class="s5">-&gt;</span><span class="s1">active() || !self</span><span class="s5">-&gt;</span><span class="s1">started();</span>
<span class="s1">}</span>


<span class="s2">static </span><span class="s1">PyObject*</span>
<span class="s1">green_getdead(PyGreenlet* self, </span><span class="s2">void</span><span class="s1">* UNUSED(context))</span>
<span class="s1">{</span>
    <span class="s2">if </span><span class="s1">(_green_not_dead(self)) {</span>
        <span class="s1">Py_RETURN_FALSE;</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s1">Py_RETURN_TRUE;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">static </span><span class="s1">PyObject*</span>
<span class="s1">green_get_stack_saved(PyGreenlet* self, </span><span class="s2">void</span><span class="s1">* UNUSED(context))</span>
<span class="s1">{</span>
    <span class="s2">return </span><span class="s1">PyLong_FromSsize_t(self</span><span class="s5">-&gt;</span><span class="s1">pimpl</span><span class="s5">-&gt;</span><span class="s1">stack_saved());</span>
<span class="s1">}</span>


<span class="s2">static </span><span class="s1">PyObject*</span>
<span class="s1">green_getrun(PyGreenlet* self, </span><span class="s2">void</span><span class="s1">* UNUSED(context))</span>
<span class="s1">{</span>
    <span class="s4">try </span><span class="s1">{</span>
        <span class="s1">OwnedObject result(BorrowedGreenlet(self)</span><span class="s5">-&gt;</span><span class="s1">run());</span>
        <span class="s2">return </span><span class="s1">result.relinquish_ownership();</span>
    <span class="s1">}</span>
    <span class="s4">catch</span><span class="s1">(</span><span class="s2">const </span><span class="s1">PyErrOccurred&amp;) {</span>
        <span class="s2">return </span><span class="s1">nullptr;</span>
    <span class="s1">}</span>
<span class="s1">}</span>


<span class="s2">static int</span>
<span class="s1">green_setrun(PyGreenlet* self, PyObject* nrun, </span><span class="s2">void</span><span class="s1">* UNUSED(context))</span>
<span class="s1">{</span>
    <span class="s4">try </span><span class="s1">{</span>
        <span class="s1">BorrowedGreenlet(self)</span><span class="s5">-&gt;</span><span class="s1">run(nrun);</span>
        <span class="s2">return </span><span class="s6">0</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s4">catch</span><span class="s1">(</span><span class="s2">const </span><span class="s1">PyErrOccurred&amp;) {</span>
        <span class="s2">return </span><span class="s1">-</span><span class="s6">1</span><span class="s1">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">static </span><span class="s1">PyObject*</span>
<span class="s1">green_getparent(PyGreenlet* self, </span><span class="s2">void</span><span class="s1">* UNUSED(context))</span>
<span class="s1">{</span>
    <span class="s2">return </span><span class="s1">BorrowedGreenlet(self)</span><span class="s5">-&gt;</span><span class="s1">parent().acquire_or_None();</span>
<span class="s1">}</span>


<span class="s2">static int</span>
<span class="s1">green_setparent(PyGreenlet* self, PyObject* nparent, </span><span class="s2">void</span><span class="s1">* UNUSED(context))</span>
<span class="s1">{</span>
    <span class="s4">try </span><span class="s1">{</span>
        <span class="s1">BorrowedGreenlet(self)</span><span class="s5">-&gt;</span><span class="s1">parent(nparent);</span>
    <span class="s1">}</span>
    <span class="s4">catch</span><span class="s1">(</span><span class="s2">const </span><span class="s1">PyErrOccurred&amp;) {</span>
        <span class="s2">return </span><span class="s1">-</span><span class="s6">1</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s6">0</span><span class="s1">;</span>
<span class="s1">}</span>


<span class="s2">static </span><span class="s1">PyObject*</span>
<span class="s1">green_getcontext(</span><span class="s2">const </span><span class="s1">PyGreenlet* self, </span><span class="s2">void</span><span class="s1">* UNUSED(context))</span>
<span class="s1">{</span>
    <span class="s2">const </span><span class="s1">Greenlet *</span><span class="s2">const </span><span class="s1">g = self</span><span class="s5">-&gt;</span><span class="s1">pimpl;</span>
    <span class="s4">try </span><span class="s1">{</span>
        <span class="s1">OwnedObject result(g</span><span class="s5">-&gt;</span><span class="s1">context());</span>
        <span class="s2">return </span><span class="s1">result.relinquish_ownership();</span>
    <span class="s1">}</span>
    <span class="s4">catch</span><span class="s1">(</span><span class="s2">const </span><span class="s1">PyErrOccurred&amp;) {</span>
        <span class="s2">return </span><span class="s1">nullptr;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">static int</span>
<span class="s1">green_setcontext(PyGreenlet* self, PyObject* nctx, </span><span class="s2">void</span><span class="s1">* UNUSED(context))</span>
<span class="s1">{</span>
    <span class="s4">try </span><span class="s1">{</span>
        <span class="s1">BorrowedGreenlet(self)</span><span class="s5">-&gt;</span><span class="s1">context(nctx);</span>
        <span class="s2">return </span><span class="s6">0</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s4">catch</span><span class="s1">(</span><span class="s2">const </span><span class="s1">PyErrOccurred&amp;) {</span>
        <span class="s2">return </span><span class="s1">-</span><span class="s6">1</span><span class="s1">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>


<span class="s2">static </span><span class="s1">PyObject*</span>
<span class="s1">green_getframe(PyGreenlet* self, </span><span class="s2">void</span><span class="s1">* UNUSED(context))</span>
<span class="s1">{</span>
    <span class="s2">const </span><span class="s1">PythonState::OwnedFrame&amp; top_frame = BorrowedGreenlet(self)</span><span class="s5">-&gt;</span><span class="s1">top_frame();</span>
    <span class="s2">return </span><span class="s1">top_frame.acquire_or_None();</span>
<span class="s1">}</span>


<span class="s2">static </span><span class="s1">PyObject*</span>
<span class="s1">green_getstate(PyGreenlet* self)</span>
<span class="s1">{</span>
    <span class="s1">PyErr_Format(PyExc_TypeError,</span>
                 <span class="s3">&quot;cannot serialize '%s' object&quot;</span><span class="s1">,</span>
                 <span class="s1">Py_TYPE(self)</span><span class="s5">-&gt;</span><span class="s1">tp_name);</span>
    <span class="s2">return </span><span class="s1">nullptr;</span>
<span class="s1">}</span>

<span class="s2">static </span><span class="s1">PyObject*</span>
<span class="s1">green_repr(PyGreenlet* _self)</span>
<span class="s1">{</span>
    <span class="s1">BorrowedGreenlet self(_self);</span>
    <span class="s0">/* 
      Return a string like 
      &lt;greenlet.greenlet at 0xdeadbeef [current][active started]|dead main&gt; 
 
      The handling of greenlets across threads is not super good. 
      We mostly use the internal definitions of these terms, but they 
      generally should make sense to users as well. 
     */</span>
    <span class="s1">PyObject* result;</span>
    <span class="s2">int </span><span class="s1">never_started = !self</span><span class="s5">-&gt;</span><span class="s1">started() &amp;&amp; !self</span><span class="s5">-&gt;</span><span class="s1">active();</span>

    <span class="s2">const char</span><span class="s1">* </span><span class="s2">const </span><span class="s1">tp_name = Py_TYPE(self)</span><span class="s5">-&gt;</span><span class="s1">tp_name;</span>

    <span class="s2">if </span><span class="s1">(_green_not_dead(self)) {</span>
        <span class="s0">/* XXX: The otid= is almost useless because you can't correlate it to 
         any thread identifier exposed to Python. We could use 
         PyThreadState_GET()-&gt;thread_id, but we'd need to save that in the 
         greenlet, or save the whole PyThreadState object itself. 
 
         As it stands, its only useful for identifying greenlets from the same thread. 
        */</span>
        <span class="s2">const char</span><span class="s1">* state_in_thread;</span>
        <span class="s2">if </span><span class="s1">(self</span><span class="s5">-&gt;</span><span class="s1">was_running_in_dead_thread()) {</span>
            <span class="s0">// The thread it was running in is dead!</span>
            <span class="s0">// This can happen, especially at interpreter shut down.</span>
            <span class="s0">// It complicates debugging output because it may be</span>
            <span class="s0">// impossible to access the current thread state at that</span>
            <span class="s0">// time. Thus, don't access the current thread state.</span>
            <span class="s1">state_in_thread = </span><span class="s3">&quot; (thread exited)&quot;</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">state_in_thread = GET_THREAD_STATE().state().is_current(self)</span>
                <span class="s1">? </span><span class="s3">&quot; current&quot;</span>
                <span class="s1">: (self</span><span class="s5">-&gt;</span><span class="s1">started() ? </span><span class="s3">&quot; suspended&quot; </span><span class="s1">: </span><span class="s3">&quot;&quot;</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s1">result = PyUnicode_FromFormat(</span>
            <span class="s3">&quot;&lt;%s object at %p (otid=%p)%s%s%s%s&gt;&quot;</span><span class="s1">,</span>
            <span class="s1">tp_name,</span>
            <span class="s1">self.borrow_o(),</span>
            <span class="s1">self</span><span class="s5">-&gt;</span><span class="s1">thread_state(),</span>
            <span class="s1">state_in_thread,</span>
            <span class="s1">self</span><span class="s5">-&gt;</span><span class="s1">active() ? </span><span class="s3">&quot; active&quot; </span><span class="s1">: </span><span class="s3">&quot;&quot;</span><span class="s1">,</span>
            <span class="s1">never_started ? </span><span class="s3">&quot; pending&quot; </span><span class="s1">: </span><span class="s3">&quot; started&quot;</span><span class="s1">,</span>
            <span class="s1">self</span><span class="s5">-&gt;</span><span class="s1">main() ? </span><span class="s3">&quot; main&quot; </span><span class="s1">: </span><span class="s3">&quot;&quot;</span>
        <span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s1">result = PyUnicode_FromFormat(</span>
            <span class="s3">&quot;&lt;%s object at %p (otid=%p) %sdead&gt;&quot;</span><span class="s1">,</span>
            <span class="s1">tp_name,</span>
            <span class="s1">self.borrow_o(),</span>
            <span class="s1">self</span><span class="s5">-&gt;</span><span class="s1">thread_state(),</span>
            <span class="s1">self</span><span class="s5">-&gt;</span><span class="s1">was_running_in_dead_thread()</span>
            <span class="s1">? </span><span class="s3">&quot;(thread exited) &quot;</span>
            <span class="s1">: </span><span class="s3">&quot;&quot;</span>
            <span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">result;</span>
<span class="s1">}</span>


<span class="s2">static </span><span class="s1">PyMethodDef green_methods[] = {</span>
    <span class="s1">{</span>
      <span class="s1">.ml_name=</span><span class="s3">&quot;switch&quot;</span><span class="s1">,</span>
      <span class="s1">.ml_meth=</span><span class="s4">reinterpret_cast</span><span class="s1">&lt;PyCFunction&gt;(green_switch),</span>
      <span class="s1">.ml_flags=METH_VARARGS | METH_KEYWORDS,</span>
      <span class="s1">.ml_doc=green_switch_doc</span>
    <span class="s1">},</span>
    <span class="s1">{.ml_name=</span><span class="s3">&quot;throw&quot;</span><span class="s1">, .ml_meth=(PyCFunction)green_throw, .ml_flags=METH_VARARGS, .ml_doc=green_throw_doc},</span>
    <span class="s1">{.ml_name=</span><span class="s3">&quot;__getstate__&quot;</span><span class="s1">, .ml_meth=(PyCFunction)green_getstate, .ml_flags=METH_NOARGS, .ml_doc=NULL},</span>
    <span class="s1">{.ml_name=NULL, .ml_meth=NULL} </span><span class="s0">/* sentinel */</span>
<span class="s1">};</span>

<span class="s2">static </span><span class="s1">PyGetSetDef green_getsets[] = {</span>
    <span class="s0">/* name, getter, setter, doc, context pointer */</span>
    <span class="s1">{.name=</span><span class="s3">&quot;__dict__&quot;</span><span class="s1">, .get=(getter)green_getdict, .set=(setter)green_setdict},</span>
    <span class="s1">{.name=</span><span class="s3">&quot;run&quot;</span><span class="s1">, .get=(getter)green_getrun, .set=(setter)green_setrun},</span>
    <span class="s1">{.name=</span><span class="s3">&quot;parent&quot;</span><span class="s1">, .get=(getter)green_getparent, .set=(setter)green_setparent},</span>
    <span class="s1">{.name=</span><span class="s3">&quot;gr_frame&quot;</span><span class="s1">, .get=(getter)green_getframe },</span>
    <span class="s1">{</span>
      <span class="s1">.name=</span><span class="s3">&quot;gr_context&quot;</span><span class="s1">,</span>
      <span class="s1">.get=(getter)green_getcontext,</span>
      <span class="s1">.set=(setter)green_setcontext</span>
    <span class="s1">},</span>
    <span class="s1">{.name=</span><span class="s3">&quot;dead&quot;</span><span class="s1">, .get=(getter)green_getdead},</span>
    <span class="s1">{.name=</span><span class="s3">&quot;_stack_saved&quot;</span><span class="s1">, .get=(getter)green_get_stack_saved},</span>
    <span class="s1">{.name=NULL}</span>
<span class="s1">};</span>

<span class="s2">static </span><span class="s1">PyMemberDef green_members[] = {</span>
    <span class="s1">{.name=NULL}</span>
<span class="s1">};</span>

<span class="s2">static </span><span class="s1">PyNumberMethods green_as_number = {</span>
  <span class="s1">.nb_bool=(inquiry)green_bool,</span>
<span class="s1">};</span>


<span class="s1">PyTypeObject PyGreenlet_Type = {</span>
    <span class="s1">.ob_base=PyVarObject_HEAD_INIT(NULL, </span><span class="s6">0</span><span class="s1">)</span>
    <span class="s1">.tp_name=</span><span class="s3">&quot;greenlet.greenlet&quot;</span><span class="s1">, </span><span class="s0">/* tp_name */</span>
    <span class="s1">.tp_basicsize=</span><span class="s2">sizeof</span><span class="s1">(PyGreenlet),  </span><span class="s0">/* tp_basicsize */</span>
    <span class="s0">/* methods */</span>
    <span class="s1">.tp_dealloc=(destructor)green_dealloc, </span><span class="s0">/* tp_dealloc */</span>
    <span class="s1">.tp_repr=(reprfunc)green_repr,      </span><span class="s0">/* tp_repr */</span>
    <span class="s1">.tp_as_number=&amp;green_as_number,          </span><span class="s0">/* tp_as _number*/</span>
    <span class="s1">.tp_flags=G_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, </span><span class="s0">/* tp_flags */</span>
    <span class="s1">.tp_doc=</span><span class="s3">&quot;greenlet(run=None, parent=None) -&gt; greenlet</span><span class="s2">\n\n</span><span class="s3">&quot;</span>
    <span class="s3">&quot;Creates a new greenlet object (without running it).</span><span class="s2">\n\n</span><span class="s3">&quot;</span>
    <span class="s3">&quot; - *run* -- The callable to invoke.</span><span class="s2">\n</span><span class="s3">&quot;</span>
    <span class="s3">&quot; - *parent* -- The parent greenlet. The default is the current &quot;</span>
    <span class="s3">&quot;greenlet.&quot;</span><span class="s1">,                        </span><span class="s0">/* tp_doc */</span>
    <span class="s1">.tp_traverse=(traverseproc)green_traverse, </span><span class="s0">/* tp_traverse */</span>
    <span class="s1">.tp_clear=(inquiry)green_clear,         </span><span class="s0">/* tp_clear */</span>
    <span class="s1">.tp_weaklistoffset=offsetof(PyGreenlet, weakreflist),  </span><span class="s0">/* tp_weaklistoffset */</span>

    <span class="s1">.tp_methods=green_methods,                      </span><span class="s0">/* tp_methods */</span>
    <span class="s1">.tp_members=green_members,                      </span><span class="s0">/* tp_members */</span>
    <span class="s1">.tp_getset=green_getsets,                      </span><span class="s0">/* tp_getset */</span>
    <span class="s1">.tp_dictoffset=offsetof(PyGreenlet, dict),         </span><span class="s0">/* tp_dictoffset */</span>
    <span class="s1">.tp_init=(initproc)green_init,               </span><span class="s0">/* tp_init */</span>
    <span class="s1">.tp_alloc=PyType_GenericAlloc,                  </span><span class="s0">/* tp_alloc */</span>
    <span class="s1">.tp_new=(newfunc)green_new,                          </span><span class="s0">/* tp_new */</span>
    <span class="s1">.tp_free=PyObject_GC_Del,                   </span><span class="s0">/* tp_free */</span>
    <span class="s1">.tp_is_gc=(inquiry)green_is_gc,         </span><span class="s0">/* tp_is_gc */</span>
<span class="s1">};</span>

<span class="s2">#endif</span>

<span class="s0">// Local Variables:</span>
<span class="s0">// flycheck-clang-include-path: (&quot;/opt/local/Library/Frameworks/Python.framework/Versions/3.8/include/python3.8&quot;)</span>
<span class="s0">// End:</span>
</pre>
</body>
</html>