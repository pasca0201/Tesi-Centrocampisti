<html>
<head>
<title>TGreenlet.cpp</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #6aab73;}
.s4 { color: #c77dbb;}
.s5 { color: #0da19e;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
TGreenlet.cpp</font>
</center></td></tr></table>
<pre><span class="s0">/* -*- indent-tabs-mode: nil; tab-width: 4; -*- */</span>
<span class="s0">/** 
 * Implementation of greenlet::Greenlet. 
 * 
 * Format with: 
 *  clang-format -i --style=file src/greenlet/greenlet.c 
 * 
 * 
 * Fix missing braces with: 
 *   clang-tidy src/greenlet/greenlet.c -fix -checks=&quot;readability-braces-around-statements&quot; 
*/</span>
<span class="s2">#ifndef </span><span class="s1">TGREENLET_CPP</span>
<span class="s2">#define </span><span class="s1">TGREENLET_CPP</span>
<span class="s2">#include </span><span class="s3">&quot;greenlet_internal.hpp&quot;</span>
<span class="s2">#include </span><span class="s3">&quot;TGreenlet.hpp&quot;</span>


<span class="s2">#include </span><span class="s3">&quot;TGreenletGlobals.cpp&quot;</span>
<span class="s2">#include </span><span class="s3">&quot;TThreadStateDestroy.cpp&quot;</span>

<span class="s4">namespace </span><span class="s1">greenlet {</span>

<span class="s1">Greenlet::Greenlet(PyGreenlet* p)</span>
    <span class="s1">:  Greenlet(p, StackState())</span>
<span class="s1">{</span>
<span class="s1">}</span>

<span class="s1">Greenlet::Greenlet(PyGreenlet* p, </span><span class="s2">const </span><span class="s1">StackState&amp; initial_stack)</span>
    <span class="s1">:  _self(p), stack_state(initial_stack)</span>
<span class="s1">{</span>
    <span class="s1">assert(p</span><span class="s5">-&gt;</span><span class="s1">pimpl == nullptr);</span>
    <span class="s1">p</span><span class="s5">-&gt;</span><span class="s1">pimpl = </span><span class="s4">this</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s1">Greenlet::~Greenlet()</span>
<span class="s1">{</span>
    <span class="s0">// XXX: Can't do this. tp_clear is a virtual function, and by the</span>
    <span class="s0">// time we're here, we've sliced off our child classes.</span>
    <span class="s0">//this-&gt;tp_clear();</span>
    <span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">_self</span><span class="s5">-&gt;</span><span class="s1">pimpl = nullptr;</span>
<span class="s1">}</span>

<span class="s2">bool</span>
<span class="s1">Greenlet::force_slp_switch_error() </span><span class="s2">const </span><span class="s1">noexcept</span>
<span class="s1">{</span>
    <span class="s2">return false</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">void</span>
<span class="s1">Greenlet::release_args()</span>
<span class="s1">{</span>
    <span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">switch_args.CLEAR();</span>
<span class="s1">}</span>

<span class="s0">/** 
 * CAUTION: This will allocate memory and may trigger garbage 
 * collection and arbitrary Python code. 
 */</span>
<span class="s1">OwnedObject</span>
<span class="s1">Greenlet::throw_GreenletExit_during_dealloc(</span><span class="s2">const </span><span class="s1">ThreadState&amp; UNUSED(current_thread_state))</span>
<span class="s1">{</span>
    <span class="s0">// If we're killed because we lost all references in the</span>
    <span class="s0">// middle of a switch, that's ok. Don't reset the args/kwargs,</span>
    <span class="s0">// we still want to pass them to the parent.</span>
    <span class="s1">PyErr_SetString(mod_globs</span><span class="s5">-&gt;</span><span class="s1">PyExc_GreenletExit,</span>
                    <span class="s3">&quot;Killing the greenlet because all references have vanished.&quot;</span><span class="s1">);</span>
    <span class="s0">// To get here it had to have run before</span>
    <span class="s2">return </span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">g_switch();</span>
<span class="s1">}</span>

<span class="s4">inline </span><span class="s2">void</span>
<span class="s1">Greenlet::slp_restore_state() noexcept</span>
<span class="s1">{</span>
<span class="s2">#ifdef </span><span class="s1">SLP_BEFORE_RESTORE_STATE</span>
    <span class="s1">SLP_BEFORE_RESTORE_STATE();</span>
<span class="s2">#endif</span>
    <span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">stack_state.copy_heap_to_stack(</span>
           <span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">thread_state()</span><span class="s5">-&gt;</span><span class="s1">borrow_current()</span><span class="s5">-&gt;</span><span class="s1">stack_state);</span>
<span class="s1">}</span>


<span class="s4">inline </span><span class="s2">int</span>
<span class="s1">Greenlet::slp_save_state(</span><span class="s2">char </span><span class="s1">*</span><span class="s2">const </span><span class="s1">stackref) noexcept</span>
<span class="s1">{</span>
    <span class="s0">// XXX: This used to happen in the middle, before saving, but</span>
    <span class="s0">// after finding the next owner. Does that matter? This is</span>
    <span class="s0">// only defined for Sparc/GCC where it flushes register</span>
    <span class="s0">// windows to the stack (I think)</span>
<span class="s2">#ifdef </span><span class="s1">SLP_BEFORE_SAVE_STATE</span>
    <span class="s1">SLP_BEFORE_SAVE_STATE();</span>
<span class="s2">#endif</span>
    <span class="s2">return </span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">stack_state.copy_stack_to_heap(stackref,</span>
                                                <span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">thread_state()</span><span class="s5">-&gt;</span><span class="s1">borrow_current()</span><span class="s5">-&gt;</span><span class="s1">stack_state);</span>
<span class="s1">}</span>

<span class="s0">/** 
 * CAUTION: This will allocate memory and may trigger garbage 
 * collection and arbitrary Python code. 
 */</span>
<span class="s1">OwnedObject</span>
<span class="s1">Greenlet::on_switchstack_or_initialstub_failure(</span>
    <span class="s1">Greenlet* target,</span>
    <span class="s2">const </span><span class="s1">Greenlet::switchstack_result_t&amp; err,</span>
    <span class="s2">const bool </span><span class="s1">target_was_me,</span>
    <span class="s2">const bool </span><span class="s1">was_initial_stub)</span>
<span class="s1">{</span>
    <span class="s0">// If we get here, either g_initialstub()</span>
    <span class="s0">// failed, or g_switchstack() failed. Either one of those</span>
    <span class="s0">// cases SHOULD leave us in the original greenlet with a valid stack.</span>
    <span class="s2">if </span><span class="s1">(!PyErr_Occurred()) {</span>
        <span class="s1">PyErr_SetString(</span>
            <span class="s1">PyExc_SystemError,</span>
            <span class="s1">was_initial_stub</span>
            <span class="s1">? </span><span class="s3">&quot;Failed to switch stacks into a greenlet for the first time.&quot;</span>
            <span class="s1">: </span><span class="s3">&quot;Failed to switch stacks into a running greenlet.&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">release_args();</span>

    <span class="s2">if </span><span class="s1">(target &amp;&amp; !target_was_me) {</span>
        <span class="s1">target</span><span class="s5">-&gt;</span><span class="s1">murder_in_place();</span>
    <span class="s1">}</span>

    <span class="s1">assert(!err.the_new_current_greenlet);</span>
    <span class="s1">assert(!err.origin_greenlet);</span>
    <span class="s2">return </span><span class="s1">OwnedObject();</span>

<span class="s1">}</span>

<span class="s1">OwnedGreenlet</span>
<span class="s1">Greenlet::g_switchstack_success() noexcept</span>
<span class="s1">{</span>
    <span class="s1">PyThreadState* tstate = PyThreadState_GET();</span>
    <span class="s0">// restore the saved state</span>
    <span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">python_state &gt;&gt; tstate;</span>
    <span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">exception_state &gt;&gt; tstate;</span>

    <span class="s0">// The thread state hasn't been changed yet.</span>
    <span class="s1">ThreadState* thread_state = </span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">thread_state();</span>
    <span class="s1">OwnedGreenlet result(thread_state</span><span class="s5">-&gt;</span><span class="s1">get_current());</span>
    <span class="s1">thread_state</span><span class="s5">-&gt;</span><span class="s1">set_current(</span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">self());</span>
    <span class="s0">//assert(thread_state-&gt;borrow_current().borrow() == this-&gt;_self);</span>
    <span class="s2">return </span><span class="s1">result;</span>
<span class="s1">}</span>

<span class="s1">Greenlet::switchstack_result_t</span>
<span class="s1">Greenlet::g_switchstack(</span><span class="s2">void</span><span class="s1">)</span>
<span class="s1">{</span>
    <span class="s0">// if any of these assertions fail, it's likely because we</span>
    <span class="s0">// switched away and tried to switch back to us. Early stages of</span>
    <span class="s0">// switching are not reentrant because we re-use ``this-&gt;args()``.</span>
    <span class="s0">// Switching away would happen if we trigger a garbage collection</span>
    <span class="s0">// (by just using some Python APIs that happen to allocate Python</span>
    <span class="s0">// objects) and some garbage had weakref callbacks or __del__ that</span>
    <span class="s0">// switches (people don't write code like that by hand, but with</span>
    <span class="s0">// gevent it's possible without realizing it)</span>
    <span class="s1">assert(</span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">args() || PyErr_Occurred());</span>
    <span class="s1">{ </span><span class="s0">/* save state */</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">thread_state()</span><span class="s5">-&gt;</span><span class="s1">is_current(</span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">self())) {</span>
            <span class="s0">// Hmm, nothing to do.</span>
            <span class="s0">// TODO: Does this bypass trace events that are</span>
            <span class="s0">// important?</span>
            <span class="s2">return </span><span class="s1">switchstack_result_t(</span><span class="s6">0</span><span class="s1">,</span>
                                        <span class="s4">this</span><span class="s1">, </span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">thread_state()</span><span class="s5">-&gt;</span><span class="s1">borrow_current());</span>
        <span class="s1">}</span>
        <span class="s1">BorrowedGreenlet current = </span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">thread_state()</span><span class="s5">-&gt;</span><span class="s1">borrow_current();</span>
        <span class="s1">PyThreadState* tstate = PyThreadState_GET();</span>

        <span class="s1">current</span><span class="s5">-&gt;</span><span class="s1">python_state &lt;&lt; tstate;</span>
        <span class="s1">current</span><span class="s5">-&gt;</span><span class="s1">exception_state &lt;&lt; tstate;</span>
        <span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">python_state.will_switch_from(tstate);</span>
        <span class="s1">switching_thread_state = </span><span class="s4">this</span><span class="s1">;</span>
        <span class="s1">current</span><span class="s5">-&gt;</span><span class="s1">expose_frames();</span>
    <span class="s1">}</span>
    <span class="s1">assert(</span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">args() || PyErr_Occurred());</span>
    <span class="s0">// If this is the first switch into a greenlet, this will</span>
    <span class="s0">// return twice, once with 1 in the new greenlet, once with 0</span>
    <span class="s0">// in the origin.</span>
    <span class="s2">int </span><span class="s1">err;</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">force_slp_switch_error()) {</span>
        <span class="s1">err = -</span><span class="s6">1</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s1">err = slp_switch();</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(err &lt; </span><span class="s6">0</span><span class="s1">) { </span><span class="s0">/* error */</span>
        <span class="s0">// Tested by</span>
        <span class="s0">// test_greenlet.TestBrokenGreenlets.test_failed_to_slp_switch_into_running</span>
        <span class="s0">//</span>
        <span class="s0">// It's not clear if it's worth trying to clean up and</span>
        <span class="s0">// continue here. Failing to switch stacks is a big deal which</span>
        <span class="s0">// may not be recoverable (who knows what state the stack is in).</span>
        <span class="s0">// Also, we've stolen references in preparation for calling</span>
        <span class="s0">// ``g_switchstack_success()`` and we don't have a clean</span>
        <span class="s0">// mechanism for backing that all out.</span>
        <span class="s1">Py_FatalError(</span><span class="s3">&quot;greenlet: Failed low-level slp_switch(). The stack is probably corrupt.&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s0">// No stack-based variables are valid anymore.</span>

    <span class="s0">// But the global is volatile so we can reload it without the</span>
    <span class="s0">// compiler caching it from earlier.</span>
    <span class="s1">Greenlet* greenlet_that_switched_in = switching_thread_state; </span><span class="s0">// aka this</span>
    <span class="s1">switching_thread_state = nullptr;</span>
    <span class="s0">// except that no stack variables are valid, we would:</span>
    <span class="s0">// assert(this == greenlet_that_switched_in);</span>

    <span class="s0">// switchstack success is where we restore the exception state,</span>
    <span class="s0">// etc. It returns the origin greenlet because its convenient.</span>

    <span class="s1">OwnedGreenlet origin = greenlet_that_switched_in</span><span class="s5">-&gt;</span><span class="s1">g_switchstack_success();</span>
    <span class="s1">assert(greenlet_that_switched_in</span><span class="s5">-&gt;</span><span class="s1">args() || PyErr_Occurred());</span>
    <span class="s2">return </span><span class="s1">switchstack_result_t(err, greenlet_that_switched_in, origin);</span>
<span class="s1">}</span>


<span class="s4">inline </span><span class="s2">void</span>
<span class="s1">Greenlet::check_switch_allowed() </span><span class="s2">const</span>
<span class="s1">{</span>
    <span class="s0">// TODO: Make this take a parameter of the current greenlet,</span>
    <span class="s0">// or current main greenlet, to make the check for</span>
    <span class="s0">// cross-thread switching cheaper. Surely somewhere up the</span>
    <span class="s0">// call stack we've already accessed the thread local variable.</span>

    <span class="s0">// We expect to always have a main greenlet now; accessing the thread state</span>
    <span class="s0">// created it. However, if we get here and cleanup has already</span>
    <span class="s0">// begun because we're a greenlet that was running in a</span>
    <span class="s0">// (now dead) thread, these invariants will not hold true. In</span>
    <span class="s0">// fact, accessing `this-&gt;thread_state` may not even be possible.</span>

    <span class="s0">// If the thread this greenlet was running in is dead,</span>
    <span class="s0">// we'll still have a reference to a main greenlet, but the</span>
    <span class="s0">// thread state pointer we have is bogus.</span>
    <span class="s0">// TODO: Give the objects an API to determine if they belong</span>
    <span class="s0">// to a dead thread.</span>

    <span class="s2">const </span><span class="s1">BorrowedMainGreenlet main_greenlet = </span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">find_main_greenlet_in_lineage();</span>

    <span class="s2">if </span><span class="s1">(!main_greenlet) {</span>
        <span class="s4">throw </span><span class="s1">PyErrOccurred(mod_globs</span><span class="s5">-&gt;</span><span class="s1">PyExc_GreenletError,</span>
                            <span class="s3">&quot;cannot switch to a garbage collected greenlet&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(!main_greenlet</span><span class="s5">-&gt;</span><span class="s1">thread_state()) {</span>
        <span class="s4">throw </span><span class="s1">PyErrOccurred(mod_globs</span><span class="s5">-&gt;</span><span class="s1">PyExc_GreenletError,</span>
                            <span class="s3">&quot;cannot switch to a different thread (which happens to have exited)&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s0">// The main greenlet we found was from the .parent lineage.</span>
    <span class="s0">// That may or may not have any relationship to the main</span>
    <span class="s0">// greenlet of the running thread. We can't actually access</span>
    <span class="s0">// our this-&gt;thread_state members to try to check that,</span>
    <span class="s0">// because it could be in the process of getting destroyed,</span>
    <span class="s0">// but setting the main_greenlet-&gt;thread_state member to NULL</span>
    <span class="s0">// may not be visible yet. So we need to check against the</span>
    <span class="s0">// current thread state (once the cheaper checks are out of</span>
    <span class="s0">// the way)</span>
    <span class="s2">const </span><span class="s1">BorrowedMainGreenlet current_main_greenlet = GET_THREAD_STATE().state().borrow_main_greenlet();</span>
    <span class="s2">if </span><span class="s1">(</span>
        <span class="s0">// lineage main greenlet is not this thread's greenlet</span>
        <span class="s1">current_main_greenlet != main_greenlet</span>
        <span class="s1">|| (</span>
            <span class="s0">// atteched to some thread</span>
            <span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">main_greenlet()</span>
            <span class="s0">// XXX: Same condition as above. Was this supposed to be</span>
            <span class="s0">// this-&gt;main_greenlet()?</span>
            <span class="s1">&amp;&amp; current_main_greenlet != main_greenlet)</span>
        <span class="s0">// switching into a known dead thread (XXX: which, if we get here,</span>
        <span class="s0">// is bad, because we just accessed the thread state, which is</span>
        <span class="s0">// gone!)</span>
        <span class="s1">|| (!current_main_greenlet</span><span class="s5">-&gt;</span><span class="s1">thread_state())) {</span>
        <span class="s0">// CAUTION: This may trigger memory allocations, gc, and</span>
        <span class="s0">// arbitrary Python code.</span>
        <span class="s4">throw </span><span class="s1">PyErrOccurred(</span>
            <span class="s1">mod_globs</span><span class="s5">-&gt;</span><span class="s1">PyExc_GreenletError,</span>
            <span class="s3">&quot;Cannot switch to a different thread</span><span class="s2">\n\t</span><span class="s3">Current:  %R</span><span class="s2">\n\t</span><span class="s3">Expected: %R&quot;</span><span class="s1">,</span>
            <span class="s1">current_main_greenlet, main_greenlet);</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">OwnedObject</span>
<span class="s1">Greenlet::context() </span><span class="s2">const</span>
<span class="s1">{</span>
    <span class="s4">using </span><span class="s1">greenlet::PythonStateContext;</span>
    <span class="s1">OwnedObject result;</span>

    <span class="s2">if </span><span class="s1">(</span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">is_currently_running_in_some_thread()) {</span>
        <span class="s0">/* Currently running greenlet: context is stored in the thread state, 
           not the greenlet object. */</span>
        <span class="s2">if </span><span class="s1">(GET_THREAD_STATE().state().is_current(</span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">self())) {</span>
            <span class="s1">result = PythonStateContext::context(PyThreadState_GET());</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s4">throw </span><span class="s1">ValueError(</span>
                            <span class="s3">&quot;cannot get context of a &quot;</span>
                            <span class="s3">&quot;greenlet that is running in a different thread&quot;</span><span class="s1">);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s0">/* Greenlet is not running: just return context. */</span>
        <span class="s1">result = </span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">python_state.context();</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(!result) {</span>
        <span class="s1">result = OwnedObject::None();</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">result;</span>
<span class="s1">}</span>


<span class="s2">void</span>
<span class="s1">Greenlet::context(BorrowedObject given)</span>
<span class="s1">{</span>
    <span class="s4">using </span><span class="s1">greenlet::PythonStateContext;</span>
    <span class="s2">if </span><span class="s1">(!given) {</span>
        <span class="s4">throw </span><span class="s1">AttributeError(</span><span class="s3">&quot;can't delete context attribute&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(given.is_None()) {</span>
        <span class="s0">/* &quot;Empty context&quot; is stored as NULL, not None. */</span>
        <span class="s1">given = nullptr;</span>
    <span class="s1">}</span>

    <span class="s0">//checks type, incrs refcnt</span>
    <span class="s1">greenlet::refs::OwnedContext context(given);</span>
    <span class="s1">PyThreadState* tstate = PyThreadState_GET();</span>

    <span class="s2">if </span><span class="s1">(</span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">is_currently_running_in_some_thread()) {</span>
        <span class="s2">if </span><span class="s1">(!GET_THREAD_STATE().state().is_current(</span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">self())) {</span>
            <span class="s4">throw </span><span class="s1">ValueError(</span><span class="s3">&quot;cannot set context of a greenlet&quot;</span>
                             <span class="s3">&quot; that is running in a different thread&quot;</span><span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s0">/* Currently running greenlet: context is stored in the thread state, 
           not the greenlet object. */</span>
        <span class="s1">OwnedObject octx = OwnedObject::consuming(PythonStateContext::context(tstate));</span>
        <span class="s1">PythonStateContext::context(tstate, context.relinquish_ownership());</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s0">/* Greenlet is not running: just set context. Note that the 
           greenlet may be dead.*/</span>
        <span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">python_state.context() = context;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s0">/** 
 * CAUTION: May invoke arbitrary Python code. 
 * 
 * Figure out what the result of ``greenlet.switch(arg, kwargs)`` 
 * should be and transfers ownership of it to the left-hand-side. 
 * 
 * If switch() was just passed an arg tuple, then we'll just return that. 
 * If only keyword arguments were passed, then we'll pass the keyword 
 * argument dict. Otherwise, we'll create a tuple of (args, kwargs) and 
 * return both. 
 * 
 * CAUTION: This may allocate a new tuple object, which may 
 * cause the Python garbage collector to run, which in turn may 
 * run arbitrary Python code that switches. 
 */</span>
<span class="s1">OwnedObject&amp; </span><span class="s4">operator</span><span class="s1">&lt;&lt;=(OwnedObject&amp; lhs, greenlet::SwitchingArgs&amp; rhs) noexcept</span>
<span class="s1">{</span>
    <span class="s0">// Because this may invoke arbitrary Python code, which could</span>
    <span class="s0">// result in switching back to us, we need to get the</span>
    <span class="s0">// arguments locally on the stack.</span>
    <span class="s1">assert(rhs);</span>
    <span class="s1">OwnedObject args = rhs.args();</span>
    <span class="s1">OwnedObject kwargs = rhs.kwargs();</span>
    <span class="s1">rhs.CLEAR();</span>
    <span class="s0">// We shouldn't be called twice for the same switch.</span>
    <span class="s1">assert(args || kwargs);</span>
    <span class="s1">assert(!rhs);</span>

    <span class="s2">if </span><span class="s1">(!kwargs) {</span>
        <span class="s1">lhs = args;</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(!PyDict_Size(kwargs.borrow())) {</span>
        <span class="s1">lhs = args;</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(!PySequence_Length(args.borrow())) {</span>
        <span class="s1">lhs = kwargs;</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s0">// PyTuple_Pack allocates memory, may GC, may run arbitrary</span>
        <span class="s0">// Python code.</span>
        <span class="s1">lhs = OwnedObject::consuming(PyTuple_Pack(</span><span class="s6">2</span><span class="s1">, args.borrow(), kwargs.borrow()));</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">lhs;</span>
<span class="s1">}</span>

<span class="s2">static </span><span class="s1">OwnedObject</span>
<span class="s1">g_handle_exit(</span><span class="s2">const </span><span class="s1">OwnedObject&amp; greenlet_result)</span>
<span class="s1">{</span>
    <span class="s2">if </span><span class="s1">(!greenlet_result &amp;&amp; mod_globs</span><span class="s5">-&gt;</span><span class="s1">PyExc_GreenletExit.PyExceptionMatches()) {</span>
        <span class="s0">/* catch and ignore GreenletExit */</span>
        <span class="s1">PyErrFetchParam val;</span>
        <span class="s1">PyErr_Fetch(PyErrFetchParam(), val, PyErrFetchParam());</span>
        <span class="s2">if </span><span class="s1">(!val) {</span>
            <span class="s2">return </span><span class="s1">OwnedObject::None();</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">OwnedObject(val);</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(greenlet_result) {</span>
        <span class="s0">// package the result into a 1-tuple</span>
        <span class="s0">// PyTuple_Pack increments the reference of its arguments,</span>
        <span class="s0">// so we always need to decref the greenlet result;</span>
        <span class="s0">// the owner will do that.</span>
        <span class="s2">return </span><span class="s1">OwnedObject::consuming(PyTuple_Pack(</span><span class="s6">1</span><span class="s1">, greenlet_result.borrow()));</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">OwnedObject();</span>
<span class="s1">}</span>



<span class="s0">/** 
 * May run arbitrary Python code. 
 */</span>
<span class="s1">OwnedObject</span>
<span class="s1">Greenlet::g_switch_finish(</span><span class="s2">const </span><span class="s1">switchstack_result_t&amp; err)</span>
<span class="s1">{</span>
    <span class="s1">assert(err.the_new_current_greenlet == </span><span class="s4">this</span><span class="s1">);</span>

    <span class="s1">ThreadState&amp; state = *</span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">thread_state();</span>
    <span class="s0">// Because calling the trace function could do arbitrary things,</span>
    <span class="s0">// including switching away from this greenlet and then maybe</span>
    <span class="s0">// switching back, we need to capture the arguments now so that</span>
    <span class="s0">// they don't change.</span>
    <span class="s1">OwnedObject result;</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">args()) {</span>
        <span class="s1">result &lt;&lt;= </span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">args();</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s1">assert(PyErr_Occurred());</span>
    <span class="s1">}</span>
    <span class="s1">assert(!</span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">args());</span>
    <span class="s4">try </span><span class="s1">{</span>
        <span class="s0">// Our only caller handles the bad error case</span>
        <span class="s1">assert(err.status &gt;= </span><span class="s6">0</span><span class="s1">);</span>
        <span class="s1">assert(state.borrow_current() == </span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">self());</span>
        <span class="s2">if </span><span class="s1">(OwnedObject tracefunc = state.get_tracefunc()) {</span>
            <span class="s1">assert(result || PyErr_Occurred());</span>
            <span class="s1">g_calltrace(tracefunc,</span>
                        <span class="s1">result ? mod_globs</span><span class="s5">-&gt;</span><span class="s1">event_switch : mod_globs</span><span class="s5">-&gt;</span><span class="s1">event_throw,</span>
                        <span class="s1">err.origin_greenlet,</span>
                        <span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">self());</span>
        <span class="s1">}</span>
        <span class="s0">// The above could have invoked arbitrary Python code, but</span>
        <span class="s0">// it couldn't switch back to this object and *also*</span>
        <span class="s0">// throw an exception, so the args won't have changed.</span>

        <span class="s2">if </span><span class="s1">(PyErr_Occurred()) {</span>
            <span class="s0">// We get here if we fell of the end of the run() function</span>
            <span class="s0">// raising an exception. The switch itself was</span>
            <span class="s0">// successful, but the function raised.</span>
            <span class="s0">// valgrind reports that memory allocated here can still</span>
            <span class="s0">// be reached after a test run.</span>
            <span class="s4">throw </span><span class="s1">PyErrOccurred::from_current();</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">}</span>
    <span class="s4">catch </span><span class="s1">(</span><span class="s2">const </span><span class="s1">PyErrOccurred&amp;) {</span>
        <span class="s0">/* Turn switch errors into switch throws */</span>
        <span class="s0">/* Turn trace errors into switch throws */</span>
        <span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">release_args();</span>
        <span class="s4">throw</span><span class="s1">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">void</span>
<span class="s1">Greenlet::g_calltrace(</span><span class="s2">const </span><span class="s1">OwnedObject&amp; tracefunc,</span>
                      <span class="s2">const </span><span class="s1">greenlet::refs::ImmortalEventName&amp; event,</span>
                      <span class="s2">const </span><span class="s1">BorrowedGreenlet&amp; origin,</span>
                      <span class="s2">const </span><span class="s1">BorrowedGreenlet&amp; target)</span>
<span class="s1">{</span>
    <span class="s1">PyErrPieces saved_exc;</span>
    <span class="s4">try </span><span class="s1">{</span>
        <span class="s1">TracingGuard tracing_guard;</span>
        <span class="s0">// TODO: We have saved the active exception (if any) that's</span>
        <span class="s0">// about to be raised. In the 'throw' case, we could provide</span>
        <span class="s0">// the exception to the tracefunction, which seems very helpful.</span>
        <span class="s1">tracing_guard.CallTraceFunction(tracefunc, event, origin, target);</span>
    <span class="s1">}</span>
    <span class="s4">catch </span><span class="s1">(</span><span class="s2">const </span><span class="s1">PyErrOccurred&amp;) {</span>
        <span class="s0">// In case of exceptions trace function is removed,</span>
        <span class="s0">// and any existing exception is replaced with the tracing</span>
        <span class="s0">// exception.</span>
        <span class="s1">GET_THREAD_STATE().state().set_tracefunc(Py_None);</span>
        <span class="s4">throw</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">saved_exc.PyErrRestore();</span>
    <span class="s1">assert(</span>
        <span class="s1">(event == mod_globs</span><span class="s5">-&gt;</span><span class="s1">event_throw &amp;&amp; PyErr_Occurred())</span>
        <span class="s1">|| (event == mod_globs</span><span class="s5">-&gt;</span><span class="s1">event_switch &amp;&amp; !PyErr_Occurred())</span>
    <span class="s1">);</span>
<span class="s1">}</span>

<span class="s2">void</span>
<span class="s1">Greenlet::murder_in_place()</span>
<span class="s1">{</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">active()) {</span>
        <span class="s1">assert(!</span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">is_currently_running_in_some_thread());</span>
        <span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">deactivate_and_free();</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s4">inline </span><span class="s2">void</span>
<span class="s1">Greenlet::deactivate_and_free()</span>
<span class="s1">{</span>
    <span class="s2">if </span><span class="s1">(!</span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">active()) {</span>
        <span class="s2">return</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">// Throw away any saved stack.</span>
    <span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">stack_state = StackState();</span>
    <span class="s1">assert(!</span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">stack_state.active());</span>
    <span class="s0">// Throw away any Python references.</span>
    <span class="s0">// We're holding a borrowed reference to the last</span>
    <span class="s0">// frame we executed. Since we borrowed it, the</span>
    <span class="s0">// normal traversal, clear, and dealloc functions</span>
    <span class="s0">// ignore it, meaning it leaks. (The thread state</span>
    <span class="s0">// object can't find it to clear it when that's</span>
    <span class="s0">// deallocated either, because by definition if we</span>
    <span class="s0">// got an object on this list, it wasn't</span>
    <span class="s0">// running and the thread state doesn't have</span>
    <span class="s0">// this frame.)</span>
    <span class="s0">// So here, we *do* clear it.</span>
    <span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">python_state.tp_clear(</span><span class="s4">true</span><span class="s1">);</span>
<span class="s1">}</span>

<span class="s2">bool</span>
<span class="s1">Greenlet::belongs_to_thread(</span><span class="s2">const </span><span class="s1">ThreadState* thread_state) </span><span class="s2">const</span>
<span class="s1">{</span>
    <span class="s2">if </span><span class="s1">(!</span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">thread_state() </span><span class="s0">// not running anywhere, or thread</span>
                              <span class="s0">// exited</span>
        <span class="s1">|| !thread_state) { </span><span class="s0">// same, or there is no thread state.</span>
        <span class="s2">return false</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s4">true</span><span class="s1">;</span>
<span class="s1">}</span>


<span class="s2">void</span>
<span class="s1">Greenlet::deallocing_greenlet_in_thread(</span><span class="s2">const </span><span class="s1">ThreadState* current_thread_state)</span>
<span class="s1">{</span>
    <span class="s0">/* Cannot raise an exception to kill the greenlet if 
       it is not running in the same thread! */</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">belongs_to_thread(current_thread_state)) {</span>
        <span class="s1">assert(current_thread_state);</span>
        <span class="s0">// To get here it had to have run before</span>
        <span class="s0">/* Send the greenlet a GreenletExit exception. */</span>

        <span class="s0">// We don't care about the return value, only whether an</span>
        <span class="s0">// exception happened.</span>
        <span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">throw_GreenletExit_during_dealloc(*current_thread_state);</span>
        <span class="s2">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s0">// Not the same thread! Temporarily save the greenlet</span>
    <span class="s0">// into its thread's deleteme list, *if* it exists.</span>
    <span class="s0">// If that thread has already exited, and processed its pending</span>
    <span class="s0">// cleanup, we'll never be able to clean everything up: we won't</span>
    <span class="s0">// be able to raise an exception.</span>
    <span class="s0">// That's mostly OK! Since we can't add it to a list, our refcount</span>
    <span class="s0">// won't increase, and we'll go ahead with the DECREFs later.</span>
    <span class="s1">ThreadState *</span><span class="s2">const  </span><span class="s1">thread_state = </span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">thread_state();</span>
    <span class="s2">if </span><span class="s1">(thread_state) {</span>
        <span class="s1">thread_state</span><span class="s5">-&gt;</span><span class="s1">delete_when_thread_running(</span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">self());</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s0">// The thread is dead, we can't raise an exception.</span>
        <span class="s0">// We need to make it look non-active, though, so that dealloc</span>
        <span class="s0">// finishes killing it.</span>
        <span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">deactivate_and_free();</span>
    <span class="s1">}</span>
    <span class="s2">return</span><span class="s1">;</span>
<span class="s1">}</span>


<span class="s2">int</span>
<span class="s1">Greenlet::tp_traverse(visitproc visit, </span><span class="s2">void</span><span class="s1">* arg)</span>
<span class="s1">{</span>

    <span class="s2">int </span><span class="s1">result;</span>
    <span class="s2">if </span><span class="s1">((result = </span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">exception_state.tp_traverse(visit, arg)) != </span><span class="s6">0</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">}</span>
    <span class="s0">//XXX: This is ugly. But so is handling everything having to do</span>
    <span class="s0">//with the top frame.</span>
    <span class="s2">bool </span><span class="s1">visit_top_frame = </span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">was_running_in_dead_thread();</span>
    <span class="s0">// When true, the thread is dead. Our implicit weak reference to the</span>
    <span class="s0">// frame is now all that's left; we consider ourselves to</span>
    <span class="s0">// strongly own it now.</span>
    <span class="s2">if </span><span class="s1">((result = </span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">python_state.tp_traverse(visit, arg, visit_top_frame)) != </span><span class="s6">0</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s6">0</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">int</span>
<span class="s1">Greenlet::tp_clear()</span>
<span class="s1">{</span>
    <span class="s2">bool </span><span class="s1">own_top_frame = </span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">was_running_in_dead_thread();</span>
    <span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">exception_state.tp_clear();</span>
    <span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">python_state.tp_clear(own_top_frame);</span>
    <span class="s2">return </span><span class="s6">0</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">bool </span><span class="s1">Greenlet::is_currently_running_in_some_thread() </span><span class="s2">const</span>
<span class="s1">{</span>
    <span class="s2">return </span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">stack_state.active() &amp;&amp; !</span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">python_state.top_frame();</span>
<span class="s1">}</span>

<span class="s2">#if </span><span class="s1">GREENLET_PY312</span>
<span class="s2">void </span><span class="s1">GREENLET_NOINLINE(Greenlet::expose_frames)()</span>
<span class="s1">{</span>
    <span class="s2">if </span><span class="s1">(!</span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">python_state.top_frame()) {</span>
        <span class="s2">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s1">_PyInterpreterFrame* last_complete_iframe = nullptr;</span>
    <span class="s1">_PyInterpreterFrame* iframe = </span><span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">python_state.top_frame()</span><span class="s5">-&gt;</span><span class="s1">f_frame;</span>
    <span class="s2">while </span><span class="s1">(iframe) {</span>
        <span class="s0">// We must make a copy before looking at the iframe contents,</span>
        <span class="s0">// since iframe might point to a portion of the greenlet's C stack</span>
        <span class="s0">// that was spilled when switching greenlets.</span>
        <span class="s1">_PyInterpreterFrame iframe_copy;</span>
        <span class="s4">this</span><span class="s5">-&gt;</span><span class="s1">stack_state.copy_from_stack(&amp;iframe_copy, iframe, </span><span class="s2">sizeof</span><span class="s1">(*iframe));</span>
        <span class="s2">if </span><span class="s1">(!_PyFrame_IsIncomplete(&amp;iframe_copy)) {</span>
            <span class="s0">// If the iframe were OWNED_BY_CSTACK then it would always be</span>
            <span class="s0">// incomplete. Since it's not incomplete, it's not on the C stack</span>
            <span class="s0">// and we can access it through the original `iframe` pointer</span>
            <span class="s0">// directly.  This is important since GetFrameObject might</span>
            <span class="s0">// lazily _create_ the frame object and we don't want the</span>
            <span class="s0">// interpreter to lose track of it.</span>
            <span class="s1">assert(iframe_copy.owner != FRAME_OWNED_BY_CSTACK);</span>

            <span class="s0">// We really want to just write:</span>
            <span class="s0">//     PyFrameObject* frame = _PyFrame_GetFrameObject(iframe);</span>
            <span class="s0">// but _PyFrame_GetFrameObject calls _PyFrame_MakeAndSetFrameObject</span>
            <span class="s0">// which is not a visible symbol in libpython. The easiest</span>
            <span class="s0">// way to get a public function to call it is using</span>
            <span class="s0">// PyFrame_GetBack, which is defined as follows:</span>
            <span class="s0">//     assert(frame != NULL);</span>
            <span class="s0">//     assert(!_PyFrame_IsIncomplete(frame-&gt;f_frame));</span>
            <span class="s0">//     PyFrameObject *back = frame-&gt;f_back;</span>
            <span class="s0">//     if (back == NULL) {</span>
            <span class="s0">//         _PyInterpreterFrame *prev = frame-&gt;f_frame-&gt;previous;</span>
            <span class="s0">//         prev = _PyFrame_GetFirstComplete(prev);</span>
            <span class="s0">//         if (prev) {</span>
            <span class="s0">//             back = _PyFrame_GetFrameObject(prev);</span>
            <span class="s0">//         }</span>
            <span class="s0">//     }</span>
            <span class="s0">//     return (PyFrameObject*)Py_XNewRef(back);</span>
            <span class="s2">if </span><span class="s1">(!iframe</span><span class="s5">-&gt;</span><span class="s1">frame_obj) {</span>
                <span class="s1">PyFrameObject dummy_frame;</span>
                <span class="s1">_PyInterpreterFrame dummy_iframe;</span>
                <span class="s1">dummy_frame.f_back = nullptr;</span>
                <span class="s1">dummy_frame.f_frame = &amp;dummy_iframe;</span>
                <span class="s0">// force the iframe to be considered complete without</span>
                <span class="s0">// needing to check its code object:</span>
                <span class="s1">dummy_iframe.owner = FRAME_OWNED_BY_GENERATOR;</span>
                <span class="s1">dummy_iframe.previous = iframe;</span>
                <span class="s1">assert(!_PyFrame_IsIncomplete(&amp;dummy_iframe));</span>
                <span class="s0">// Drop the returned reference immediately; the iframe</span>
                <span class="s0">// continues to hold a strong reference</span>
                <span class="s1">Py_XDECREF(PyFrame_GetBack(&amp;dummy_frame));</span>
                <span class="s1">assert(iframe</span><span class="s5">-&gt;</span><span class="s1">frame_obj);</span>
            <span class="s1">}</span>

            <span class="s0">// This is a complete frame, so make the last one of those we saw</span>
            <span class="s0">// point at it, bypassing any incomplete frames (which may have</span>
            <span class="s0">// been on the C stack) in between the two. We're overwriting</span>
            <span class="s0">// last_complete_iframe-&gt;previous and need that to be reversible,</span>
            <span class="s0">// so we store the original previous ptr in the frame object</span>
            <span class="s0">// (which we must have created on a previous iteration through</span>
            <span class="s0">// this loop). The frame object has a bunch of storage that is</span>
            <span class="s0">// only used when its iframe is OWNED_BY_FRAME_OBJECT, which only</span>
            <span class="s0">// occurs when the frame object outlives the frame's execution,</span>
            <span class="s0">// which can't have happened yet because the frame is currently</span>
            <span class="s0">// executing as far as the interpreter is concerned. So, we can</span>
            <span class="s0">// reuse it for our own purposes.</span>
            <span class="s1">assert(iframe</span><span class="s5">-&gt;</span><span class="s1">owner == FRAME_OWNED_BY_THREAD</span>
                   <span class="s1">|| iframe</span><span class="s5">-&gt;</span><span class="s1">owner == FRAME_OWNED_BY_GENERATOR);</span>
            <span class="s2">if </span><span class="s1">(last_complete_iframe) {</span>
                <span class="s1">assert(last_complete_iframe</span><span class="s5">-&gt;</span><span class="s1">frame_obj);</span>
                <span class="s1">memcpy(&amp;last_complete_iframe</span><span class="s5">-&gt;</span><span class="s1">frame_obj</span><span class="s5">-&gt;</span><span class="s1">_f_frame_data[</span><span class="s6">0</span><span class="s1">],</span>
                       <span class="s1">&amp;last_complete_iframe</span><span class="s5">-&gt;</span><span class="s1">previous, </span><span class="s2">sizeof</span><span class="s1">(</span><span class="s2">void </span><span class="s1">*));</span>
                <span class="s1">last_complete_iframe</span><span class="s5">-&gt;</span><span class="s1">previous = iframe;</span>
            <span class="s1">}</span>
            <span class="s1">last_complete_iframe = iframe;</span>
        <span class="s1">}</span>
        <span class="s0">// Frames that are OWNED_BY_FRAME_OBJECT are linked via the</span>
        <span class="s0">// frame's f_back while all others are linked via the iframe's</span>
        <span class="s0">// previous ptr. Since all the frames we traverse are running</span>
        <span class="s0">// as far as the interpreter is concerned, we don't have to</span>
        <span class="s0">// worry about the OWNED_BY_FRAME_OBJECT case.</span>
        <span class="s1">iframe = iframe_copy.previous;</span>
    <span class="s1">}</span>

    <span class="s0">// Give the outermost complete iframe a null previous pointer to</span>
    <span class="s0">// account for any potential incomplete/C-stack iframes between it</span>
    <span class="s0">// and the actual top-of-stack</span>
    <span class="s2">if </span><span class="s1">(last_complete_iframe) {</span>
        <span class="s1">assert(last_complete_iframe</span><span class="s5">-&gt;</span><span class="s1">frame_obj);</span>
        <span class="s1">memcpy(&amp;last_complete_iframe</span><span class="s5">-&gt;</span><span class="s1">frame_obj</span><span class="s5">-&gt;</span><span class="s1">_f_frame_data[</span><span class="s6">0</span><span class="s1">],</span>
               <span class="s1">&amp;last_complete_iframe</span><span class="s5">-&gt;</span><span class="s1">previous, </span><span class="s2">sizeof</span><span class="s1">(</span><span class="s2">void </span><span class="s1">*));</span>
        <span class="s1">last_complete_iframe</span><span class="s5">-&gt;</span><span class="s1">previous = nullptr;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">#else</span>
<span class="s2">void </span><span class="s1">Greenlet::expose_frames()</span>
<span class="s1">{</span>

<span class="s1">}</span>
<span class="s2">#endif</span>

<span class="s1">}; </span><span class="s0">// namespace greenlet</span>
<span class="s2">#endif</span>
</pre>
</body>
</html>