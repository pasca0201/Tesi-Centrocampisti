<html>
<head>
<title>builder.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #7a7e85;}
.s5 { color: #6aab73;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
builder.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
colorLib.builder: Build COLR/CPAL tables from scratch 
 
&quot;&quot;&quot;</span>

<span class="s2">import </span><span class="s1">collections</span>
<span class="s2">import </span><span class="s1">copy</span>
<span class="s2">import </span><span class="s1">enum</span>
<span class="s2">from </span><span class="s1">functools </span><span class="s2">import </span><span class="s1">partial</span>
<span class="s2">from </span><span class="s1">math </span><span class="s2">import </span><span class="s1">ceil</span><span class="s3">, </span><span class="s1">log</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s3">(</span>
    <span class="s1">Any</span><span class="s3">,</span>
    <span class="s1">Dict</span><span class="s3">,</span>
    <span class="s1">Generator</span><span class="s3">,</span>
    <span class="s1">Iterable</span><span class="s3">,</span>
    <span class="s1">List</span><span class="s3">,</span>
    <span class="s1">Mapping</span><span class="s3">,</span>
    <span class="s1">Optional</span><span class="s3">,</span>
    <span class="s1">Sequence</span><span class="s3">,</span>
    <span class="s1">Tuple</span><span class="s3">,</span>
    <span class="s1">Type</span><span class="s3">,</span>
    <span class="s1">TypeVar</span><span class="s3">,</span>
    <span class="s1">Union</span><span class="s3">,</span>
<span class="s3">)</span>
<span class="s2">from </span><span class="s1">fontTools</span><span class="s3">.</span><span class="s1">misc</span><span class="s3">.</span><span class="s1">arrayTools </span><span class="s2">import </span><span class="s1">intRect</span>
<span class="s2">from </span><span class="s1">fontTools</span><span class="s3">.</span><span class="s1">misc</span><span class="s3">.</span><span class="s1">fixedTools </span><span class="s2">import </span><span class="s1">fixedToFloat</span>
<span class="s2">from </span><span class="s1">fontTools</span><span class="s3">.</span><span class="s1">misc</span><span class="s3">.</span><span class="s1">treeTools </span><span class="s2">import </span><span class="s1">build_n_ary_tree</span>
<span class="s2">from </span><span class="s1">fontTools</span><span class="s3">.</span><span class="s1">ttLib</span><span class="s3">.</span><span class="s1">tables </span><span class="s2">import </span><span class="s1">C_O_L_R_</span>
<span class="s2">from </span><span class="s1">fontTools</span><span class="s3">.</span><span class="s1">ttLib</span><span class="s3">.</span><span class="s1">tables </span><span class="s2">import </span><span class="s1">C_P_A_L_</span>
<span class="s2">from </span><span class="s1">fontTools</span><span class="s3">.</span><span class="s1">ttLib</span><span class="s3">.</span><span class="s1">tables </span><span class="s2">import </span><span class="s1">_n_a_m_e</span>
<span class="s2">from </span><span class="s1">fontTools</span><span class="s3">.</span><span class="s1">ttLib</span><span class="s3">.</span><span class="s1">tables </span><span class="s2">import </span><span class="s1">otTables </span><span class="s2">as </span><span class="s1">ot</span>
<span class="s2">from </span><span class="s1">fontTools</span><span class="s3">.</span><span class="s1">ttLib</span><span class="s3">.</span><span class="s1">tables</span><span class="s3">.</span><span class="s1">otTables </span><span class="s2">import </span><span class="s1">ExtendMode</span><span class="s3">, </span><span class="s1">CompositeMode</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">errors </span><span class="s2">import </span><span class="s1">ColorLibError</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">geometry </span><span class="s2">import </span><span class="s1">round_start_circle_stable_containment</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">table_builder </span><span class="s2">import </span><span class="s1">BuildCallback</span><span class="s3">, </span><span class="s1">TableBuilder</span>


<span class="s4"># TODO move type aliases to colorLib.types?</span>
<span class="s1">T </span><span class="s3">= </span><span class="s1">TypeVar</span><span class="s3">(</span><span class="s5">&quot;T&quot;</span><span class="s3">)</span>
<span class="s1">_Kwargs </span><span class="s3">= </span><span class="s1">Mapping</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">]</span>
<span class="s1">_PaintInput </span><span class="s3">= </span><span class="s1">Union</span><span class="s3">[</span><span class="s1">int</span><span class="s3">, </span><span class="s1">_Kwargs</span><span class="s3">, </span><span class="s1">ot</span><span class="s3">.</span><span class="s1">Paint</span><span class="s3">, </span><span class="s1">Tuple</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s5">&quot;_PaintInput&quot;</span><span class="s3">]]</span>
<span class="s1">_PaintInputList </span><span class="s3">= </span><span class="s1">Sequence</span><span class="s3">[</span><span class="s1">_PaintInput</span><span class="s3">]</span>
<span class="s1">_ColorGlyphsDict </span><span class="s3">= </span><span class="s1">Dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Union</span><span class="s3">[</span><span class="s1">_PaintInputList</span><span class="s3">, </span><span class="s1">_PaintInput</span><span class="s3">]]</span>
<span class="s1">_ColorGlyphsV0Dict </span><span class="s3">= </span><span class="s1">Dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Sequence</span><span class="s3">[</span><span class="s1">Tuple</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">int</span><span class="s3">]]]</span>
<span class="s1">_ClipBoxInput </span><span class="s3">= </span><span class="s1">Union</span><span class="s3">[</span>
    <span class="s1">Tuple</span><span class="s3">[</span><span class="s1">int</span><span class="s3">, </span><span class="s1">int</span><span class="s3">, </span><span class="s1">int</span><span class="s3">, </span><span class="s1">int</span><span class="s3">, </span><span class="s1">int</span><span class="s3">],  </span><span class="s4"># format 1, variable</span>
    <span class="s1">Tuple</span><span class="s3">[</span><span class="s1">int</span><span class="s3">, </span><span class="s1">int</span><span class="s3">, </span><span class="s1">int</span><span class="s3">, </span><span class="s1">int</span><span class="s3">],  </span><span class="s4"># format 0, non-variable</span>
    <span class="s1">ot</span><span class="s3">.</span><span class="s1">ClipBox</span><span class="s3">,</span>
<span class="s3">]</span>


<span class="s1">MAX_PAINT_COLR_LAYER_COUNT </span><span class="s3">= </span><span class="s6">255</span>
<span class="s1">_DEFAULT_ALPHA </span><span class="s3">= </span><span class="s6">1.0</span>
<span class="s1">_MAX_REUSE_LEN </span><span class="s3">= </span><span class="s6">32</span>


<span class="s2">def </span><span class="s1">_beforeBuildPaintRadialGradient</span><span class="s3">(</span><span class="s1">paint</span><span class="s3">, </span><span class="s1">source</span><span class="s3">):</span>
    <span class="s1">x0 </span><span class="s3">= </span><span class="s1">source</span><span class="s3">[</span><span class="s5">&quot;x0&quot;</span><span class="s3">]</span>
    <span class="s1">y0 </span><span class="s3">= </span><span class="s1">source</span><span class="s3">[</span><span class="s5">&quot;y0&quot;</span><span class="s3">]</span>
    <span class="s1">r0 </span><span class="s3">= </span><span class="s1">source</span><span class="s3">[</span><span class="s5">&quot;r0&quot;</span><span class="s3">]</span>
    <span class="s1">x1 </span><span class="s3">= </span><span class="s1">source</span><span class="s3">[</span><span class="s5">&quot;x1&quot;</span><span class="s3">]</span>
    <span class="s1">y1 </span><span class="s3">= </span><span class="s1">source</span><span class="s3">[</span><span class="s5">&quot;y1&quot;</span><span class="s3">]</span>
    <span class="s1">r1 </span><span class="s3">= </span><span class="s1">source</span><span class="s3">[</span><span class="s5">&quot;r1&quot;</span><span class="s3">]</span>

    <span class="s4"># TODO apparently no builder_test confirms this works (?)</span>

    <span class="s4"># avoid abrupt change after rounding when c0 is near c1's perimeter</span>
    <span class="s1">c </span><span class="s3">= </span><span class="s1">round_start_circle_stable_containment</span><span class="s3">((</span><span class="s1">x0</span><span class="s3">, </span><span class="s1">y0</span><span class="s3">), </span><span class="s1">r0</span><span class="s3">, (</span><span class="s1">x1</span><span class="s3">, </span><span class="s1">y1</span><span class="s3">), </span><span class="s1">r1</span><span class="s3">)</span>
    <span class="s1">x0</span><span class="s3">, </span><span class="s1">y0 </span><span class="s3">= </span><span class="s1">c</span><span class="s3">.</span><span class="s1">centre</span>
    <span class="s1">r0 </span><span class="s3">= </span><span class="s1">c</span><span class="s3">.</span><span class="s1">radius</span>

    <span class="s4"># update source to ensure paint is built with corrected values</span>
    <span class="s1">source</span><span class="s3">[</span><span class="s5">&quot;x0&quot;</span><span class="s3">] = </span><span class="s1">x0</span>
    <span class="s1">source</span><span class="s3">[</span><span class="s5">&quot;y0&quot;</span><span class="s3">] = </span><span class="s1">y0</span>
    <span class="s1">source</span><span class="s3">[</span><span class="s5">&quot;r0&quot;</span><span class="s3">] = </span><span class="s1">r0</span>
    <span class="s1">source</span><span class="s3">[</span><span class="s5">&quot;x1&quot;</span><span class="s3">] = </span><span class="s1">x1</span>
    <span class="s1">source</span><span class="s3">[</span><span class="s5">&quot;y1&quot;</span><span class="s3">] = </span><span class="s1">y1</span>
    <span class="s1">source</span><span class="s3">[</span><span class="s5">&quot;r1&quot;</span><span class="s3">] = </span><span class="s1">r1</span>

    <span class="s2">return </span><span class="s1">paint</span><span class="s3">, </span><span class="s1">source</span>


<span class="s2">def </span><span class="s1">_defaultColorStop</span><span class="s3">():</span>
    <span class="s1">colorStop </span><span class="s3">= </span><span class="s1">ot</span><span class="s3">.</span><span class="s1">ColorStop</span><span class="s3">()</span>
    <span class="s1">colorStop</span><span class="s3">.</span><span class="s1">Alpha </span><span class="s3">= </span><span class="s1">_DEFAULT_ALPHA</span>
    <span class="s2">return </span><span class="s1">colorStop</span>


<span class="s2">def </span><span class="s1">_defaultVarColorStop</span><span class="s3">():</span>
    <span class="s1">colorStop </span><span class="s3">= </span><span class="s1">ot</span><span class="s3">.</span><span class="s1">VarColorStop</span><span class="s3">()</span>
    <span class="s1">colorStop</span><span class="s3">.</span><span class="s1">Alpha </span><span class="s3">= </span><span class="s1">_DEFAULT_ALPHA</span>
    <span class="s2">return </span><span class="s1">colorStop</span>


<span class="s2">def </span><span class="s1">_defaultColorLine</span><span class="s3">():</span>
    <span class="s1">colorLine </span><span class="s3">= </span><span class="s1">ot</span><span class="s3">.</span><span class="s1">ColorLine</span><span class="s3">()</span>
    <span class="s1">colorLine</span><span class="s3">.</span><span class="s1">Extend </span><span class="s3">= </span><span class="s1">ExtendMode</span><span class="s3">.</span><span class="s1">PAD</span>
    <span class="s2">return </span><span class="s1">colorLine</span>


<span class="s2">def </span><span class="s1">_defaultVarColorLine</span><span class="s3">():</span>
    <span class="s1">colorLine </span><span class="s3">= </span><span class="s1">ot</span><span class="s3">.</span><span class="s1">VarColorLine</span><span class="s3">()</span>
    <span class="s1">colorLine</span><span class="s3">.</span><span class="s1">Extend </span><span class="s3">= </span><span class="s1">ExtendMode</span><span class="s3">.</span><span class="s1">PAD</span>
    <span class="s2">return </span><span class="s1">colorLine</span>


<span class="s2">def </span><span class="s1">_defaultPaintSolid</span><span class="s3">():</span>
    <span class="s1">paint </span><span class="s3">= </span><span class="s1">ot</span><span class="s3">.</span><span class="s1">Paint</span><span class="s3">()</span>
    <span class="s1">paint</span><span class="s3">.</span><span class="s1">Alpha </span><span class="s3">= </span><span class="s1">_DEFAULT_ALPHA</span>
    <span class="s2">return </span><span class="s1">paint</span>


<span class="s2">def </span><span class="s1">_buildPaintCallbacks</span><span class="s3">():</span>
    <span class="s2">return </span><span class="s3">{</span>
        <span class="s3">(</span>
            <span class="s1">BuildCallback</span><span class="s3">.</span><span class="s1">BEFORE_BUILD</span><span class="s3">,</span>
            <span class="s1">ot</span><span class="s3">.</span><span class="s1">Paint</span><span class="s3">,</span>
            <span class="s1">ot</span><span class="s3">.</span><span class="s1">PaintFormat</span><span class="s3">.</span><span class="s1">PaintRadialGradient</span><span class="s3">,</span>
        <span class="s3">): </span><span class="s1">_beforeBuildPaintRadialGradient</span><span class="s3">,</span>
        <span class="s3">(</span>
            <span class="s1">BuildCallback</span><span class="s3">.</span><span class="s1">BEFORE_BUILD</span><span class="s3">,</span>
            <span class="s1">ot</span><span class="s3">.</span><span class="s1">Paint</span><span class="s3">,</span>
            <span class="s1">ot</span><span class="s3">.</span><span class="s1">PaintFormat</span><span class="s3">.</span><span class="s1">PaintVarRadialGradient</span><span class="s3">,</span>
        <span class="s3">): </span><span class="s1">_beforeBuildPaintRadialGradient</span><span class="s3">,</span>
        <span class="s3">(</span><span class="s1">BuildCallback</span><span class="s3">.</span><span class="s1">CREATE_DEFAULT</span><span class="s3">, </span><span class="s1">ot</span><span class="s3">.</span><span class="s1">ColorStop</span><span class="s3">): </span><span class="s1">_defaultColorStop</span><span class="s3">,</span>
        <span class="s3">(</span><span class="s1">BuildCallback</span><span class="s3">.</span><span class="s1">CREATE_DEFAULT</span><span class="s3">, </span><span class="s1">ot</span><span class="s3">.</span><span class="s1">VarColorStop</span><span class="s3">): </span><span class="s1">_defaultVarColorStop</span><span class="s3">,</span>
        <span class="s3">(</span><span class="s1">BuildCallback</span><span class="s3">.</span><span class="s1">CREATE_DEFAULT</span><span class="s3">, </span><span class="s1">ot</span><span class="s3">.</span><span class="s1">ColorLine</span><span class="s3">): </span><span class="s1">_defaultColorLine</span><span class="s3">,</span>
        <span class="s3">(</span><span class="s1">BuildCallback</span><span class="s3">.</span><span class="s1">CREATE_DEFAULT</span><span class="s3">, </span><span class="s1">ot</span><span class="s3">.</span><span class="s1">VarColorLine</span><span class="s3">): </span><span class="s1">_defaultVarColorLine</span><span class="s3">,</span>
        <span class="s3">(</span>
            <span class="s1">BuildCallback</span><span class="s3">.</span><span class="s1">CREATE_DEFAULT</span><span class="s3">,</span>
            <span class="s1">ot</span><span class="s3">.</span><span class="s1">Paint</span><span class="s3">,</span>
            <span class="s1">ot</span><span class="s3">.</span><span class="s1">PaintFormat</span><span class="s3">.</span><span class="s1">PaintSolid</span><span class="s3">,</span>
        <span class="s3">): </span><span class="s1">_defaultPaintSolid</span><span class="s3">,</span>
        <span class="s3">(</span>
            <span class="s1">BuildCallback</span><span class="s3">.</span><span class="s1">CREATE_DEFAULT</span><span class="s3">,</span>
            <span class="s1">ot</span><span class="s3">.</span><span class="s1">Paint</span><span class="s3">,</span>
            <span class="s1">ot</span><span class="s3">.</span><span class="s1">PaintFormat</span><span class="s3">.</span><span class="s1">PaintVarSolid</span><span class="s3">,</span>
        <span class="s3">): </span><span class="s1">_defaultPaintSolid</span><span class="s3">,</span>
    <span class="s3">}</span>


<span class="s2">def </span><span class="s1">populateCOLRv0</span><span class="s3">(</span>
    <span class="s1">table</span><span class="s3">: </span><span class="s1">ot</span><span class="s3">.</span><span class="s1">COLR</span><span class="s3">,</span>
    <span class="s1">colorGlyphsV0</span><span class="s3">: </span><span class="s1">_ColorGlyphsV0Dict</span><span class="s3">,</span>
    <span class="s1">glyphMap</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">Mapping</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">int</span><span class="s3">]] = </span><span class="s2">None</span><span class="s3">,</span>
<span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Build v0 color layers and add to existing COLR table. 
 
    Args: 
        table: a raw ``otTables.COLR()`` object (not ttLib's ``table_C_O_L_R_``). 
        colorGlyphsV0: map of base glyph names to lists of (layer glyph names, 
            color palette index) tuples. Can be empty. 
        glyphMap: a map from glyph names to glyph indices, as returned from 
            ``TTFont.getReverseGlyphMap()``, to optionally sort base records by GID. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">glyphMap </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s1">colorGlyphItems </span><span class="s3">= </span><span class="s1">sorted</span><span class="s3">(</span>
            <span class="s1">colorGlyphsV0</span><span class="s3">.</span><span class="s1">items</span><span class="s3">(), </span><span class="s1">key</span><span class="s3">=</span><span class="s2">lambda </span><span class="s1">item</span><span class="s3">: </span><span class="s1">glyphMap</span><span class="s3">[</span><span class="s1">item</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]]</span>
        <span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">colorGlyphItems </span><span class="s3">= </span><span class="s1">colorGlyphsV0</span><span class="s3">.</span><span class="s1">items</span><span class="s3">()</span>
    <span class="s1">baseGlyphRecords </span><span class="s3">= []</span>
    <span class="s1">layerRecords </span><span class="s3">= []</span>
    <span class="s2">for </span><span class="s1">baseGlyph</span><span class="s3">, </span><span class="s1">layers </span><span class="s2">in </span><span class="s1">colorGlyphItems</span><span class="s3">:</span>
        <span class="s1">baseRec </span><span class="s3">= </span><span class="s1">ot</span><span class="s3">.</span><span class="s1">BaseGlyphRecord</span><span class="s3">()</span>
        <span class="s1">baseRec</span><span class="s3">.</span><span class="s1">BaseGlyph </span><span class="s3">= </span><span class="s1">baseGlyph</span>
        <span class="s1">baseRec</span><span class="s3">.</span><span class="s1">FirstLayerIndex </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">layerRecords</span><span class="s3">)</span>
        <span class="s1">baseRec</span><span class="s3">.</span><span class="s1">NumLayers </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">layers</span><span class="s3">)</span>
        <span class="s1">baseGlyphRecords</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">baseRec</span><span class="s3">)</span>

        <span class="s2">for </span><span class="s1">layerGlyph</span><span class="s3">, </span><span class="s1">paletteIndex </span><span class="s2">in </span><span class="s1">layers</span><span class="s3">:</span>
            <span class="s1">layerRec </span><span class="s3">= </span><span class="s1">ot</span><span class="s3">.</span><span class="s1">LayerRecord</span><span class="s3">()</span>
            <span class="s1">layerRec</span><span class="s3">.</span><span class="s1">LayerGlyph </span><span class="s3">= </span><span class="s1">layerGlyph</span>
            <span class="s1">layerRec</span><span class="s3">.</span><span class="s1">PaletteIndex </span><span class="s3">= </span><span class="s1">paletteIndex</span>
            <span class="s1">layerRecords</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">layerRec</span><span class="s3">)</span>

    <span class="s1">table</span><span class="s3">.</span><span class="s1">BaseGlyphRecordArray </span><span class="s3">= </span><span class="s1">table</span><span class="s3">.</span><span class="s1">LayerRecordArray </span><span class="s3">= </span><span class="s2">None</span>
    <span class="s2">if </span><span class="s1">baseGlyphRecords</span><span class="s3">:</span>
        <span class="s1">table</span><span class="s3">.</span><span class="s1">BaseGlyphRecordArray </span><span class="s3">= </span><span class="s1">ot</span><span class="s3">.</span><span class="s1">BaseGlyphRecordArray</span><span class="s3">()</span>
        <span class="s1">table</span><span class="s3">.</span><span class="s1">BaseGlyphRecordArray</span><span class="s3">.</span><span class="s1">BaseGlyphRecord </span><span class="s3">= </span><span class="s1">baseGlyphRecords</span>
    <span class="s2">if </span><span class="s1">layerRecords</span><span class="s3">:</span>
        <span class="s1">table</span><span class="s3">.</span><span class="s1">LayerRecordArray </span><span class="s3">= </span><span class="s1">ot</span><span class="s3">.</span><span class="s1">LayerRecordArray</span><span class="s3">()</span>
        <span class="s1">table</span><span class="s3">.</span><span class="s1">LayerRecordArray</span><span class="s3">.</span><span class="s1">LayerRecord </span><span class="s3">= </span><span class="s1">layerRecords</span>
    <span class="s1">table</span><span class="s3">.</span><span class="s1">BaseGlyphRecordCount </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">baseGlyphRecords</span><span class="s3">)</span>
    <span class="s1">table</span><span class="s3">.</span><span class="s1">LayerRecordCount </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">layerRecords</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">buildCOLR</span><span class="s3">(</span>
    <span class="s1">colorGlyphs</span><span class="s3">: </span><span class="s1">_ColorGlyphsDict</span><span class="s3">,</span>
    <span class="s1">version</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">int</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s3">*,</span>
    <span class="s1">glyphMap</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">Mapping</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">int</span><span class="s3">]] = </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">varStore</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">ot</span><span class="s3">.</span><span class="s1">VarStore</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">varIndexMap</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">ot</span><span class="s3">.</span><span class="s1">DeltaSetIndexMap</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">clipBoxes</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">Dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">_ClipBoxInput</span><span class="s3">]] = </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">allowLayerReuse</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">True</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; C_O_L_R_</span><span class="s3">.</span><span class="s1">table_C_O_L_R_</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot;Build COLR table from color layers mapping. 
 
    Args: 
 
        colorGlyphs: map of base glyph name to, either list of (layer glyph name, 
            color palette index) tuples for COLRv0; or a single ``Paint`` (dict) or 
            list of ``Paint`` for COLRv1. 
        version: the version of COLR table. If None, the version is determined 
            by the presence of COLRv1 paints or variation data (varStore), which 
            require version 1; otherwise, if all base glyphs use only simple color 
            layers, version 0 is used. 
        glyphMap: a map from glyph names to glyph indices, as returned from 
            TTFont.getReverseGlyphMap(), to optionally sort base records by GID. 
        varStore: Optional ItemVarationStore for deltas associated with v1 layer. 
        varIndexMap: Optional DeltaSetIndexMap for deltas associated with v1 layer. 
        clipBoxes: Optional map of base glyph name to clip box 4- or 5-tuples: 
            (xMin, yMin, xMax, yMax) or (xMin, yMin, xMax, yMax, varIndexBase). 
 
    Returns: 
        A new COLR table. 
    &quot;&quot;&quot;</span>
    <span class="s1">self </span><span class="s3">= </span><span class="s1">C_O_L_R_</span><span class="s3">.</span><span class="s1">table_C_O_L_R_</span><span class="s3">()</span>

    <span class="s2">if </span><span class="s1">varStore </span><span class="s2">is not None and </span><span class="s1">version </span><span class="s3">== </span><span class="s6">0</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s5">&quot;Can't add VarStore to COLRv0&quot;</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">version </span><span class="s2">in </span><span class="s3">(</span><span class="s2">None</span><span class="s3">, </span><span class="s6">0</span><span class="s3">) </span><span class="s2">and not </span><span class="s1">varStore</span><span class="s3">:</span>
        <span class="s4"># split color glyphs into v0 and v1 and encode separately</span>
        <span class="s1">colorGlyphsV0</span><span class="s3">, </span><span class="s1">colorGlyphsV1 </span><span class="s3">= </span><span class="s1">_split_color_glyphs_by_version</span><span class="s3">(</span><span class="s1">colorGlyphs</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">version </span><span class="s3">== </span><span class="s6">0 </span><span class="s2">and </span><span class="s1">colorGlyphsV1</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s5">&quot;Can't encode COLRv1 glyphs in COLRv0&quot;</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s4"># unless explicitly requested for v1 or have variations, in which case</span>
        <span class="s4"># we encode all color glyph as v1</span>
        <span class="s1">colorGlyphsV0</span><span class="s3">, </span><span class="s1">colorGlyphsV1 </span><span class="s3">= {}, </span><span class="s1">colorGlyphs</span>

    <span class="s1">colr </span><span class="s3">= </span><span class="s1">ot</span><span class="s3">.</span><span class="s1">COLR</span><span class="s3">()</span>

    <span class="s1">populateCOLRv0</span><span class="s3">(</span><span class="s1">colr</span><span class="s3">, </span><span class="s1">colorGlyphsV0</span><span class="s3">, </span><span class="s1">glyphMap</span><span class="s3">)</span>

    <span class="s1">colr</span><span class="s3">.</span><span class="s1">LayerList</span><span class="s3">, </span><span class="s1">colr</span><span class="s3">.</span><span class="s1">BaseGlyphList </span><span class="s3">= </span><span class="s1">buildColrV1</span><span class="s3">(</span>
        <span class="s1">colorGlyphsV1</span><span class="s3">,</span>
        <span class="s1">glyphMap</span><span class="s3">,</span>
        <span class="s1">allowLayerReuse</span><span class="s3">=</span><span class="s1">allowLayerReuse</span><span class="s3">,</span>
    <span class="s3">)</span>

    <span class="s2">if </span><span class="s1">version </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">version </span><span class="s3">= </span><span class="s6">1 </span><span class="s2">if </span><span class="s3">(</span><span class="s1">varStore </span><span class="s2">or </span><span class="s1">colorGlyphsV1</span><span class="s3">) </span><span class="s2">else </span><span class="s6">0</span>
    <span class="s2">elif </span><span class="s1">version </span><span class="s2">not in </span><span class="s3">(</span><span class="s6">0</span><span class="s3">, </span><span class="s6">1</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span><span class="s3">(</span><span class="s1">version</span><span class="s3">)</span>
    <span class="s1">self</span><span class="s3">.</span><span class="s1">version </span><span class="s3">= </span><span class="s1">colr</span><span class="s3">.</span><span class="s1">Version </span><span class="s3">= </span><span class="s1">version</span>

    <span class="s2">if </span><span class="s1">version </span><span class="s3">== </span><span class="s6">0</span><span class="s3">:</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">ColorLayers </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_decompileColorLayersV0</span><span class="s3">(</span><span class="s1">colr</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">colr</span><span class="s3">.</span><span class="s1">ClipList </span><span class="s3">= </span><span class="s1">buildClipList</span><span class="s3">(</span><span class="s1">clipBoxes</span><span class="s3">) </span><span class="s2">if </span><span class="s1">clipBoxes </span><span class="s2">else None</span>
        <span class="s1">colr</span><span class="s3">.</span><span class="s1">VarIndexMap </span><span class="s3">= </span><span class="s1">varIndexMap</span>
        <span class="s1">colr</span><span class="s3">.</span><span class="s1">VarStore </span><span class="s3">= </span><span class="s1">varStore</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">table </span><span class="s3">= </span><span class="s1">colr</span>

    <span class="s2">return </span><span class="s1">self</span>


<span class="s2">def </span><span class="s1">buildClipList</span><span class="s3">(</span><span class="s1">clipBoxes</span><span class="s3">: </span><span class="s1">Dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">_ClipBoxInput</span><span class="s3">]) </span><span class="s1">-&gt; ot</span><span class="s3">.</span><span class="s1">ClipList</span><span class="s3">:</span>
    <span class="s1">clipList </span><span class="s3">= </span><span class="s1">ot</span><span class="s3">.</span><span class="s1">ClipList</span><span class="s3">()</span>
    <span class="s1">clipList</span><span class="s3">.</span><span class="s1">Format </span><span class="s3">= </span><span class="s6">1</span>
    <span class="s1">clipList</span><span class="s3">.</span><span class="s1">clips </span><span class="s3">= {</span><span class="s1">name</span><span class="s3">: </span><span class="s1">buildClipBox</span><span class="s3">(</span><span class="s1">box</span><span class="s3">) </span><span class="s2">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">box </span><span class="s2">in </span><span class="s1">clipBoxes</span><span class="s3">.</span><span class="s1">items</span><span class="s3">()}</span>
    <span class="s2">return </span><span class="s1">clipList</span>


<span class="s2">def </span><span class="s1">buildClipBox</span><span class="s3">(</span><span class="s1">clipBox</span><span class="s3">: </span><span class="s1">_ClipBoxInput</span><span class="s3">) </span><span class="s1">-&gt; ot</span><span class="s3">.</span><span class="s1">ClipBox</span><span class="s3">:</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">clipBox</span><span class="s3">, </span><span class="s1">ot</span><span class="s3">.</span><span class="s1">ClipBox</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">clipBox</span>
    <span class="s1">n </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">clipBox</span><span class="s3">)</span>
    <span class="s1">clip </span><span class="s3">= </span><span class="s1">ot</span><span class="s3">.</span><span class="s1">ClipBox</span><span class="s3">()</span>
    <span class="s2">if </span><span class="s1">n </span><span class="s2">not in </span><span class="s3">(</span><span class="s6">4</span><span class="s3">, </span><span class="s6">5</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s5">f&quot;Invalid ClipBox: expected 4 or 5 values, found </span><span class="s2">{</span><span class="s1">n</span><span class="s2">}</span><span class="s5">&quot;</span><span class="s3">)</span>
    <span class="s1">clip</span><span class="s3">.</span><span class="s1">xMin</span><span class="s3">, </span><span class="s1">clip</span><span class="s3">.</span><span class="s1">yMin</span><span class="s3">, </span><span class="s1">clip</span><span class="s3">.</span><span class="s1">xMax</span><span class="s3">, </span><span class="s1">clip</span><span class="s3">.</span><span class="s1">yMax </span><span class="s3">= </span><span class="s1">intRect</span><span class="s3">(</span><span class="s1">clipBox</span><span class="s3">[:</span><span class="s6">4</span><span class="s3">])</span>
    <span class="s1">clip</span><span class="s3">.</span><span class="s1">Format </span><span class="s3">= </span><span class="s1">int</span><span class="s3">(</span><span class="s1">n </span><span class="s3">== </span><span class="s6">5</span><span class="s3">) + </span><span class="s6">1</span>
    <span class="s2">if </span><span class="s1">n </span><span class="s3">== </span><span class="s6">5</span><span class="s3">:</span>
        <span class="s1">clip</span><span class="s3">.</span><span class="s1">VarIndexBase </span><span class="s3">= </span><span class="s1">int</span><span class="s3">(</span><span class="s1">clipBox</span><span class="s3">[</span><span class="s6">4</span><span class="s3">])</span>
    <span class="s2">return </span><span class="s1">clip</span>


<span class="s2">class </span><span class="s1">ColorPaletteType</span><span class="s3">(</span><span class="s1">enum</span><span class="s3">.</span><span class="s1">IntFlag</span><span class="s3">):</span>
    <span class="s1">USABLE_WITH_LIGHT_BACKGROUND </span><span class="s3">= </span><span class="s6">0x0001</span>
    <span class="s1">USABLE_WITH_DARK_BACKGROUND </span><span class="s3">= </span><span class="s6">0x0002</span>

    <span class="s3">@</span><span class="s1">classmethod</span>
    <span class="s2">def </span><span class="s1">_missing_</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, </span><span class="s1">value</span><span class="s3">):</span>
        <span class="s4"># enforce reserved bits</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">int</span><span class="s3">) </span><span class="s2">and </span><span class="s3">(</span><span class="s1">value </span><span class="s3">&lt; </span><span class="s6">0 </span><span class="s2">or </span><span class="s1">value </span><span class="s3">&amp; </span><span class="s6">0xFFFC </span><span class="s3">!= </span><span class="s6">0</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s5">f&quot;</span><span class="s2">{</span><span class="s1">value</span><span class="s2">} </span><span class="s5">is not a valid </span><span class="s2">{</span><span class="s1">cls</span><span class="s3">.</span><span class="s1">__name__</span><span class="s2">}</span><span class="s5">&quot;</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">super</span><span class="s3">().</span><span class="s1">_missing_</span><span class="s3">(</span><span class="s1">value</span><span class="s3">)</span>


<span class="s4"># None, 'abc' or {'en': 'abc', 'de': 'xyz'}</span>
<span class="s1">_OptionalLocalizedString </span><span class="s3">= </span><span class="s1">Union</span><span class="s3">[</span><span class="s2">None</span><span class="s3">, </span><span class="s1">str</span><span class="s3">, </span><span class="s1">Dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">str</span><span class="s3">]]</span>


<span class="s2">def </span><span class="s1">buildPaletteLabels</span><span class="s3">(</span>
    <span class="s1">labels</span><span class="s3">: </span><span class="s1">Iterable</span><span class="s3">[</span><span class="s1">_OptionalLocalizedString</span><span class="s3">], </span><span class="s1">nameTable</span><span class="s3">: </span><span class="s1">_n_a_m_e</span><span class="s3">.</span><span class="s1">table__n_a_m_e</span>
<span class="s3">) </span><span class="s1">-&gt; List</span><span class="s3">[</span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">int</span><span class="s3">]]:</span>
    <span class="s2">return </span><span class="s3">[</span>
        <span class="s3">(</span>
            <span class="s1">nameTable</span><span class="s3">.</span><span class="s1">addMultilingualName</span><span class="s3">(</span><span class="s1">l</span><span class="s3">, </span><span class="s1">mac</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">l</span><span class="s3">, </span><span class="s1">dict</span><span class="s3">)</span>
            <span class="s2">else </span><span class="s3">(</span>
                <span class="s1">C_P_A_L_</span><span class="s3">.</span><span class="s1">table_C_P_A_L_</span><span class="s3">.</span><span class="s1">NO_NAME_ID</span>
                <span class="s2">if </span><span class="s1">l </span><span class="s2">is None</span>
                <span class="s2">else </span><span class="s1">nameTable</span><span class="s3">.</span><span class="s1">addMultilingualName</span><span class="s3">({</span><span class="s5">&quot;en&quot;</span><span class="s3">: </span><span class="s1">l</span><span class="s3">}, </span><span class="s1">mac</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
            <span class="s3">)</span>
        <span class="s3">)</span>
        <span class="s2">for </span><span class="s1">l </span><span class="s2">in </span><span class="s1">labels</span>
    <span class="s3">]</span>


<span class="s2">def </span><span class="s1">buildCPAL</span><span class="s3">(</span>
    <span class="s1">palettes</span><span class="s3">: </span><span class="s1">Sequence</span><span class="s3">[</span><span class="s1">Sequence</span><span class="s3">[</span><span class="s1">Tuple</span><span class="s3">[</span><span class="s1">float</span><span class="s3">, </span><span class="s1">float</span><span class="s3">, </span><span class="s1">float</span><span class="s3">, </span><span class="s1">float</span><span class="s3">]]],</span>
    <span class="s1">paletteTypes</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">Sequence</span><span class="s3">[</span><span class="s1">ColorPaletteType</span><span class="s3">]] = </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">paletteLabels</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">Sequence</span><span class="s3">[</span><span class="s1">_OptionalLocalizedString</span><span class="s3">]] = </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">paletteEntryLabels</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">Sequence</span><span class="s3">[</span><span class="s1">_OptionalLocalizedString</span><span class="s3">]] = </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">nameTable</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">_n_a_m_e</span><span class="s3">.</span><span class="s1">table__n_a_m_e</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; C_P_A_L_</span><span class="s3">.</span><span class="s1">table_C_P_A_L_</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot;Build CPAL table from list of color palettes. 
 
    Args: 
        palettes: list of lists of colors encoded as tuples of (R, G, B, A) floats 
            in the range [0..1]. 
        paletteTypes: optional list of ColorPaletteType, one for each palette. 
        paletteLabels: optional list of palette labels. Each lable can be either: 
            None (no label), a string (for for default English labels), or a 
            localized string (as a dict keyed with BCP47 language codes). 
        paletteEntryLabels: optional list of palette entry labels, one for each 
            palette entry (see paletteLabels). 
        nameTable: optional name table where to store palette and palette entry 
            labels. Required if either paletteLabels or paletteEntryLabels is set. 
 
    Return: 
        A new CPAL v0 or v1 table, if custom palette types or labels are specified. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">len</span><span class="s3">({</span><span class="s1">len</span><span class="s3">(</span><span class="s1">p</span><span class="s3">) </span><span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">palettes</span><span class="s3">}) != </span><span class="s6">1</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ColorLibError</span><span class="s3">(</span><span class="s5">&quot;color palettes have different lengths&quot;</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s3">(</span><span class="s1">paletteLabels </span><span class="s2">or </span><span class="s1">paletteEntryLabels</span><span class="s3">) </span><span class="s2">and not </span><span class="s1">nameTable</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span>
            <span class="s5">&quot;nameTable is required if palette or palette entries have labels&quot;</span>
        <span class="s3">)</span>

    <span class="s1">cpal </span><span class="s3">= </span><span class="s1">C_P_A_L_</span><span class="s3">.</span><span class="s1">table_C_P_A_L_</span><span class="s3">()</span>
    <span class="s1">cpal</span><span class="s3">.</span><span class="s1">numPaletteEntries </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">palettes</span><span class="s3">[</span><span class="s6">0</span><span class="s3">])</span>

    <span class="s1">cpal</span><span class="s3">.</span><span class="s1">palettes </span><span class="s3">= []</span>
    <span class="s2">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">palette </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">palettes</span><span class="s3">):</span>
        <span class="s1">colors </span><span class="s3">= []</span>
        <span class="s2">for </span><span class="s1">j</span><span class="s3">, </span><span class="s1">color </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">palette</span><span class="s3">):</span>
            <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">color</span><span class="s3">, </span><span class="s1">tuple</span><span class="s3">) </span><span class="s2">or </span><span class="s1">len</span><span class="s3">(</span><span class="s1">color</span><span class="s3">) != </span><span class="s6">4</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">ColorLibError</span><span class="s3">(</span>
                    <span class="s5">f&quot;In palette[</span><span class="s2">{</span><span class="s1">i</span><span class="s2">}</span><span class="s5">][</span><span class="s2">{</span><span class="s1">j</span><span class="s2">}</span><span class="s5">]: expected (R, G, B, A) tuple, got </span><span class="s2">{</span><span class="s1">color</span><span class="s2">!r}</span><span class="s5">&quot;</span>
                <span class="s3">)</span>
            <span class="s2">if </span><span class="s1">any</span><span class="s3">(</span><span class="s1">v </span><span class="s3">&gt; </span><span class="s6">1 </span><span class="s2">or </span><span class="s1">v </span><span class="s3">&lt; </span><span class="s6">0 </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">color</span><span class="s3">):</span>
                <span class="s2">raise </span><span class="s1">ColorLibError</span><span class="s3">(</span>
                    <span class="s5">f&quot;palette[</span><span class="s2">{</span><span class="s1">i</span><span class="s2">}</span><span class="s5">][</span><span class="s2">{</span><span class="s1">j</span><span class="s2">}</span><span class="s5">] has invalid out-of-range [0..1] color: </span><span class="s2">{</span><span class="s1">color</span><span class="s2">!r}</span><span class="s5">&quot;</span>
                <span class="s3">)</span>
            <span class="s4"># input colors are RGBA, CPAL encodes them as BGRA</span>
            <span class="s1">red</span><span class="s3">, </span><span class="s1">green</span><span class="s3">, </span><span class="s1">blue</span><span class="s3">, </span><span class="s1">alpha </span><span class="s3">= </span><span class="s1">color</span>
            <span class="s1">colors</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span>
                <span class="s1">C_P_A_L_</span><span class="s3">.</span><span class="s1">Color</span><span class="s3">(*(</span><span class="s1">round</span><span class="s3">(</span><span class="s1">v </span><span class="s3">* </span><span class="s6">255</span><span class="s3">) </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s3">(</span><span class="s1">blue</span><span class="s3">, </span><span class="s1">green</span><span class="s3">, </span><span class="s1">red</span><span class="s3">, </span><span class="s1">alpha</span><span class="s3">)))</span>
            <span class="s3">)</span>
        <span class="s1">cpal</span><span class="s3">.</span><span class="s1">palettes</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">colors</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">any</span><span class="s3">(</span><span class="s1">v </span><span class="s2">is not None for </span><span class="s1">v </span><span class="s2">in </span><span class="s3">(</span><span class="s1">paletteTypes</span><span class="s3">, </span><span class="s1">paletteLabels</span><span class="s3">, </span><span class="s1">paletteEntryLabels</span><span class="s3">)):</span>
        <span class="s1">cpal</span><span class="s3">.</span><span class="s1">version </span><span class="s3">= </span><span class="s6">1</span>

        <span class="s2">if </span><span class="s1">paletteTypes </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">paletteTypes</span><span class="s3">) != </span><span class="s1">len</span><span class="s3">(</span><span class="s1">palettes</span><span class="s3">):</span>
                <span class="s2">raise </span><span class="s1">ColorLibError</span><span class="s3">(</span>
                    <span class="s5">f&quot;Expected </span><span class="s2">{</span><span class="s1">len</span><span class="s3">(</span><span class="s1">palettes</span><span class="s3">)</span><span class="s2">} </span><span class="s5">paletteTypes, got </span><span class="s2">{</span><span class="s1">len</span><span class="s3">(</span><span class="s1">paletteTypes</span><span class="s3">)</span><span class="s2">}</span><span class="s5">&quot;</span>
                <span class="s3">)</span>
            <span class="s1">cpal</span><span class="s3">.</span><span class="s1">paletteTypes </span><span class="s3">= [</span><span class="s1">ColorPaletteType</span><span class="s3">(</span><span class="s1">t</span><span class="s3">).</span><span class="s1">value </span><span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">paletteTypes</span><span class="s3">]</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">cpal</span><span class="s3">.</span><span class="s1">paletteTypes </span><span class="s3">= [</span><span class="s1">C_P_A_L_</span><span class="s3">.</span><span class="s1">table_C_P_A_L_</span><span class="s3">.</span><span class="s1">DEFAULT_PALETTE_TYPE</span><span class="s3">] * </span><span class="s1">len</span><span class="s3">(</span>
                <span class="s1">palettes</span>
            <span class="s3">)</span>

        <span class="s2">if </span><span class="s1">paletteLabels </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">paletteLabels</span><span class="s3">) != </span><span class="s1">len</span><span class="s3">(</span><span class="s1">palettes</span><span class="s3">):</span>
                <span class="s2">raise </span><span class="s1">ColorLibError</span><span class="s3">(</span>
                    <span class="s5">f&quot;Expected </span><span class="s2">{</span><span class="s1">len</span><span class="s3">(</span><span class="s1">palettes</span><span class="s3">)</span><span class="s2">} </span><span class="s5">paletteLabels, got </span><span class="s2">{</span><span class="s1">len</span><span class="s3">(</span><span class="s1">paletteLabels</span><span class="s3">)</span><span class="s2">}</span><span class="s5">&quot;</span>
                <span class="s3">)</span>
            <span class="s1">cpal</span><span class="s3">.</span><span class="s1">paletteLabels </span><span class="s3">= </span><span class="s1">buildPaletteLabels</span><span class="s3">(</span><span class="s1">paletteLabels</span><span class="s3">, </span><span class="s1">nameTable</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">cpal</span><span class="s3">.</span><span class="s1">paletteLabels </span><span class="s3">= [</span><span class="s1">C_P_A_L_</span><span class="s3">.</span><span class="s1">table_C_P_A_L_</span><span class="s3">.</span><span class="s1">NO_NAME_ID</span><span class="s3">] * </span><span class="s1">len</span><span class="s3">(</span><span class="s1">palettes</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">paletteEntryLabels </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">paletteEntryLabels</span><span class="s3">) != </span><span class="s1">cpal</span><span class="s3">.</span><span class="s1">numPaletteEntries</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">ColorLibError</span><span class="s3">(</span>
                    <span class="s5">f&quot;Expected </span><span class="s2">{</span><span class="s1">cpal</span><span class="s3">.</span><span class="s1">numPaletteEntries</span><span class="s2">} </span><span class="s5">paletteEntryLabels, &quot;</span>
                    <span class="s5">f&quot;got </span><span class="s2">{</span><span class="s1">len</span><span class="s3">(</span><span class="s1">paletteEntryLabels</span><span class="s3">)</span><span class="s2">}</span><span class="s5">&quot;</span>
                <span class="s3">)</span>
            <span class="s1">cpal</span><span class="s3">.</span><span class="s1">paletteEntryLabels </span><span class="s3">= </span><span class="s1">buildPaletteLabels</span><span class="s3">(</span><span class="s1">paletteEntryLabels</span><span class="s3">, </span><span class="s1">nameTable</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">cpal</span><span class="s3">.</span><span class="s1">paletteEntryLabels </span><span class="s3">= [</span>
                <span class="s1">C_P_A_L_</span><span class="s3">.</span><span class="s1">table_C_P_A_L_</span><span class="s3">.</span><span class="s1">NO_NAME_ID</span>
            <span class="s3">] * </span><span class="s1">cpal</span><span class="s3">.</span><span class="s1">numPaletteEntries</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">cpal</span><span class="s3">.</span><span class="s1">version </span><span class="s3">= </span><span class="s6">0</span>

    <span class="s2">return </span><span class="s1">cpal</span>


<span class="s4"># COLR v1 tables</span>
<span class="s4"># See draft proposal at: https://github.com/googlefonts/colr-gradients-spec</span>


<span class="s2">def </span><span class="s1">_is_colrv0_layer</span><span class="s3">(</span><span class="s1">layer</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
    <span class="s4"># Consider as COLRv0 layer any sequence of length 2 (be it tuple or list) in which</span>
    <span class="s4"># the first element is a str (the layerGlyph) and the second element is an int</span>
    <span class="s4"># (CPAL paletteIndex).</span>
    <span class="s4"># https://github.com/googlefonts/ufo2ft/issues/426</span>
    <span class="s2">try</span><span class="s3">:</span>
        <span class="s1">layerGlyph</span><span class="s3">, </span><span class="s1">paletteIndex </span><span class="s3">= </span><span class="s1">layer</span>
    <span class="s2">except </span><span class="s3">(</span><span class="s1">TypeError</span><span class="s3">, </span><span class="s1">ValueError</span><span class="s3">):</span>
        <span class="s2">return False</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">layerGlyph</span><span class="s3">, </span><span class="s1">str</span><span class="s3">) </span><span class="s2">and </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">paletteIndex</span><span class="s3">, </span><span class="s1">int</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">_split_color_glyphs_by_version</span><span class="s3">(</span>
    <span class="s1">colorGlyphs</span><span class="s3">: </span><span class="s1">_ColorGlyphsDict</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; Tuple</span><span class="s3">[</span><span class="s1">_ColorGlyphsV0Dict</span><span class="s3">, </span><span class="s1">_ColorGlyphsDict</span><span class="s3">]:</span>
    <span class="s1">colorGlyphsV0 </span><span class="s3">= {}</span>
    <span class="s1">colorGlyphsV1 </span><span class="s3">= {}</span>
    <span class="s2">for </span><span class="s1">baseGlyph</span><span class="s3">, </span><span class="s1">layers </span><span class="s2">in </span><span class="s1">colorGlyphs</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
        <span class="s2">if </span><span class="s1">all</span><span class="s3">(</span><span class="s1">_is_colrv0_layer</span><span class="s3">(</span><span class="s1">l</span><span class="s3">) </span><span class="s2">for </span><span class="s1">l </span><span class="s2">in </span><span class="s1">layers</span><span class="s3">):</span>
            <span class="s1">colorGlyphsV0</span><span class="s3">[</span><span class="s1">baseGlyph</span><span class="s3">] = </span><span class="s1">layers</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">colorGlyphsV1</span><span class="s3">[</span><span class="s1">baseGlyph</span><span class="s3">] = </span><span class="s1">layers</span>

    <span class="s4"># sanity check</span>
    <span class="s2">assert </span><span class="s1">set</span><span class="s3">(</span><span class="s1">colorGlyphs</span><span class="s3">) == (</span><span class="s1">set</span><span class="s3">(</span><span class="s1">colorGlyphsV0</span><span class="s3">) | </span><span class="s1">set</span><span class="s3">(</span><span class="s1">colorGlyphsV1</span><span class="s3">))</span>

    <span class="s2">return </span><span class="s1">colorGlyphsV0</span><span class="s3">, </span><span class="s1">colorGlyphsV1</span>


<span class="s2">def </span><span class="s1">_reuse_ranges</span><span class="s3">(</span><span class="s1">num_layers</span><span class="s3">: </span><span class="s1">int</span><span class="s3">) </span><span class="s1">-&gt; Generator</span><span class="s3">[</span><span class="s1">Tuple</span><span class="s3">[</span><span class="s1">int</span><span class="s3">, </span><span class="s1">int</span><span class="s3">], </span><span class="s2">None</span><span class="s3">, </span><span class="s2">None</span><span class="s3">]:</span>
    <span class="s4"># TODO feels like something itertools might have already</span>
    <span class="s2">for </span><span class="s1">lbound </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">num_layers</span><span class="s3">):</span>
        <span class="s4"># Reuse of very large #s of layers is relatively unlikely</span>
        <span class="s4"># +2: we want sequences of at least 2</span>
        <span class="s4"># otData handles single-record duplication</span>
        <span class="s2">for </span><span class="s1">ubound </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span>
            <span class="s1">lbound </span><span class="s3">+ </span><span class="s6">2</span><span class="s3">, </span><span class="s1">min</span><span class="s3">(</span><span class="s1">num_layers </span><span class="s3">+ </span><span class="s6">1</span><span class="s3">, </span><span class="s1">lbound </span><span class="s3">+ </span><span class="s6">2 </span><span class="s3">+ </span><span class="s1">_MAX_REUSE_LEN</span><span class="s3">)</span>
        <span class="s3">):</span>
            <span class="s2">yield </span><span class="s3">(</span><span class="s1">lbound</span><span class="s3">, </span><span class="s1">ubound</span><span class="s3">)</span>


<span class="s2">class </span><span class="s1">LayerReuseCache</span><span class="s3">:</span>
    <span class="s1">reusePool</span><span class="s3">: </span><span class="s1">Mapping</span><span class="s3">[</span><span class="s1">Tuple</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">, ...], </span><span class="s1">int</span><span class="s3">]</span>
    <span class="s1">tuples</span><span class="s3">: </span><span class="s1">Mapping</span><span class="s3">[</span><span class="s1">int</span><span class="s3">, </span><span class="s1">Tuple</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">, ...]]</span>
    <span class="s1">keepAlive</span><span class="s3">: </span><span class="s1">List</span><span class="s3">[</span><span class="s1">ot</span><span class="s3">.</span><span class="s1">Paint</span><span class="s3">]  </span><span class="s4"># we need id to remain valid</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">reusePool </span><span class="s3">= {}</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">tuples </span><span class="s3">= {}</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">keepAlive </span><span class="s3">= []</span>

    <span class="s2">def </span><span class="s1">_paint_tuple</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">paint</span><span class="s3">: </span><span class="s1">ot</span><span class="s3">.</span><span class="s1">Paint</span><span class="s3">):</span>
        <span class="s4"># start simple, who even cares about cyclic graphs or interesting field types</span>
        <span class="s2">def </span><span class="s1">_tuple_safe</span><span class="s3">(</span><span class="s1">value</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">enum</span><span class="s3">.</span><span class="s1">Enum</span><span class="s3">):</span>
                <span class="s2">return </span><span class="s1">value</span>
            <span class="s2">elif </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s5">&quot;__dict__&quot;</span><span class="s3">):</span>
                <span class="s2">return </span><span class="s1">tuple</span><span class="s3">(</span>
                    <span class="s3">(</span><span class="s1">k</span><span class="s3">, </span><span class="s1">_tuple_safe</span><span class="s3">(</span><span class="s1">v</span><span class="s3">)) </span><span class="s2">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">sorted</span><span class="s3">(</span><span class="s1">value</span><span class="s3">.</span><span class="s1">__dict__</span><span class="s3">.</span><span class="s1">items</span><span class="s3">())</span>
                <span class="s3">)</span>
            <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">collections</span><span class="s3">.</span><span class="s1">abc</span><span class="s3">.</span><span class="s1">MutableSequence</span><span class="s3">):</span>
                <span class="s2">return </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">_tuple_safe</span><span class="s3">(</span><span class="s1">e</span><span class="s3">) </span><span class="s2">for </span><span class="s1">e </span><span class="s2">in </span><span class="s1">value</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">value</span>

        <span class="s4"># Cache the tuples for individual Paint instead of the whole sequence</span>
        <span class="s4"># because the seq could be a transient slice</span>
        <span class="s1">result </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">tuples</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">id</span><span class="s3">(</span><span class="s1">paint</span><span class="s3">), </span><span class="s2">None</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">result </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s1">result </span><span class="s3">= </span><span class="s1">_tuple_safe</span><span class="s3">(</span><span class="s1">paint</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">tuples</span><span class="s3">[</span><span class="s1">id</span><span class="s3">(</span><span class="s1">paint</span><span class="s3">)] = </span><span class="s1">result</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">keepAlive</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">paint</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">result</span>

    <span class="s2">def </span><span class="s1">_as_tuple</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">paints</span><span class="s3">: </span><span class="s1">Sequence</span><span class="s3">[</span><span class="s1">ot</span><span class="s3">.</span><span class="s1">Paint</span><span class="s3">]) </span><span class="s1">-&gt; Tuple</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">, ...]:</span>
        <span class="s2">return </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_paint_tuple</span><span class="s3">(</span><span class="s1">p</span><span class="s3">) </span><span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">paints</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">try_reuse</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">layers</span><span class="s3">: </span><span class="s1">List</span><span class="s3">[</span><span class="s1">ot</span><span class="s3">.</span><span class="s1">Paint</span><span class="s3">]) </span><span class="s1">-&gt; List</span><span class="s3">[</span><span class="s1">ot</span><span class="s3">.</span><span class="s1">Paint</span><span class="s3">]:</span>
        <span class="s1">found_reuse </span><span class="s3">= </span><span class="s2">True</span>
        <span class="s2">while </span><span class="s1">found_reuse</span><span class="s3">:</span>
            <span class="s1">found_reuse </span><span class="s3">= </span><span class="s2">False</span>

            <span class="s1">ranges </span><span class="s3">= </span><span class="s1">sorted</span><span class="s3">(</span>
                <span class="s1">_reuse_ranges</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">layers</span><span class="s3">)),</span>
                <span class="s1">key</span><span class="s3">=</span><span class="s2">lambda </span><span class="s1">t</span><span class="s3">: (</span><span class="s1">t</span><span class="s3">[</span><span class="s6">1</span><span class="s3">] - </span><span class="s1">t</span><span class="s3">[</span><span class="s6">0</span><span class="s3">], </span><span class="s1">t</span><span class="s3">[</span><span class="s6">1</span><span class="s3">], </span><span class="s1">t</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]),</span>
                <span class="s1">reverse</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
            <span class="s3">)</span>
            <span class="s2">for </span><span class="s1">lbound</span><span class="s3">, </span><span class="s1">ubound </span><span class="s2">in </span><span class="s1">ranges</span><span class="s3">:</span>
                <span class="s1">reuse_lbound </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">reusePool</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">_as_tuple</span><span class="s3">(</span><span class="s1">layers</span><span class="s3">[</span><span class="s1">lbound</span><span class="s3">:</span><span class="s1">ubound</span><span class="s3">]), -</span><span class="s6">1</span>
                <span class="s3">)</span>
                <span class="s2">if </span><span class="s1">reuse_lbound </span><span class="s3">== -</span><span class="s6">1</span><span class="s3">:</span>
                    <span class="s2">continue</span>
                <span class="s1">new_slice </span><span class="s3">= </span><span class="s1">ot</span><span class="s3">.</span><span class="s1">Paint</span><span class="s3">()</span>
                <span class="s1">new_slice</span><span class="s3">.</span><span class="s1">Format </span><span class="s3">= </span><span class="s1">int</span><span class="s3">(</span><span class="s1">ot</span><span class="s3">.</span><span class="s1">PaintFormat</span><span class="s3">.</span><span class="s1">PaintColrLayers</span><span class="s3">)</span>
                <span class="s1">new_slice</span><span class="s3">.</span><span class="s1">NumLayers </span><span class="s3">= </span><span class="s1">ubound </span><span class="s3">- </span><span class="s1">lbound</span>
                <span class="s1">new_slice</span><span class="s3">.</span><span class="s1">FirstLayerIndex </span><span class="s3">= </span><span class="s1">reuse_lbound</span>
                <span class="s1">layers </span><span class="s3">= </span><span class="s1">layers</span><span class="s3">[:</span><span class="s1">lbound</span><span class="s3">] + [</span><span class="s1">new_slice</span><span class="s3">] + </span><span class="s1">layers</span><span class="s3">[</span><span class="s1">ubound</span><span class="s3">:]</span>
                <span class="s1">found_reuse </span><span class="s3">= </span><span class="s2">True</span>
                <span class="s2">break</span>
        <span class="s2">return </span><span class="s1">layers</span>

    <span class="s2">def </span><span class="s1">add</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">layers</span><span class="s3">: </span><span class="s1">List</span><span class="s3">[</span><span class="s1">ot</span><span class="s3">.</span><span class="s1">Paint</span><span class="s3">], </span><span class="s1">first_layer_index</span><span class="s3">: </span><span class="s1">int</span><span class="s3">):</span>
        <span class="s2">for </span><span class="s1">lbound</span><span class="s3">, </span><span class="s1">ubound </span><span class="s2">in </span><span class="s1">_reuse_ranges</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">layers</span><span class="s3">)):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">reusePool</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_as_tuple</span><span class="s3">(</span><span class="s1">layers</span><span class="s3">[</span><span class="s1">lbound</span><span class="s3">:</span><span class="s1">ubound</span><span class="s3">])] = (</span>
                <span class="s1">lbound </span><span class="s3">+ </span><span class="s1">first_layer_index</span>
            <span class="s3">)</span>


<span class="s2">class </span><span class="s1">LayerListBuilder</span><span class="s3">:</span>
    <span class="s1">layers</span><span class="s3">: </span><span class="s1">List</span><span class="s3">[</span><span class="s1">ot</span><span class="s3">.</span><span class="s1">Paint</span><span class="s3">]</span>
    <span class="s1">cache</span><span class="s3">: </span><span class="s1">LayerReuseCache</span>
    <span class="s1">allowLayerReuse</span><span class="s3">: </span><span class="s1">bool</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, *, </span><span class="s1">allowLayerReuse</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">layers </span><span class="s3">= []</span>
        <span class="s2">if </span><span class="s1">allowLayerReuse</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">cache </span><span class="s3">= </span><span class="s1">LayerReuseCache</span><span class="s3">()</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">cache </span><span class="s3">= </span><span class="s2">None</span>

        <span class="s4"># We need to intercept construction of PaintColrLayers</span>
        <span class="s1">callbacks </span><span class="s3">= </span><span class="s1">_buildPaintCallbacks</span><span class="s3">()</span>
        <span class="s1">callbacks</span><span class="s3">[</span>
            <span class="s3">(</span>
                <span class="s1">BuildCallback</span><span class="s3">.</span><span class="s1">BEFORE_BUILD</span><span class="s3">,</span>
                <span class="s1">ot</span><span class="s3">.</span><span class="s1">Paint</span><span class="s3">,</span>
                <span class="s1">ot</span><span class="s3">.</span><span class="s1">PaintFormat</span><span class="s3">.</span><span class="s1">PaintColrLayers</span><span class="s3">,</span>
            <span class="s3">)</span>
        <span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_beforeBuildPaintColrLayers</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">tableBuilder </span><span class="s3">= </span><span class="s1">TableBuilder</span><span class="s3">(</span><span class="s1">callbacks</span><span class="s3">)</span>

    <span class="s4"># COLR layers is unusual in that it modifies shared state</span>
    <span class="s4"># so we need a callback into an object</span>
    <span class="s2">def </span><span class="s1">_beforeBuildPaintColrLayers</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">dest</span><span class="s3">, </span><span class="s1">source</span><span class="s3">):</span>
        <span class="s4"># Sketchy gymnastics: a sequence input will have dropped it's layers</span>
        <span class="s4"># into NumLayers; get it back</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">source</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s5">&quot;NumLayers&quot;</span><span class="s3">, </span><span class="s2">None</span><span class="s3">), </span><span class="s1">collections</span><span class="s3">.</span><span class="s1">abc</span><span class="s3">.</span><span class="s1">Sequence</span><span class="s3">):</span>
            <span class="s1">layers </span><span class="s3">= </span><span class="s1">source</span><span class="s3">[</span><span class="s5">&quot;NumLayers&quot;</span><span class="s3">]</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">layers </span><span class="s3">= </span><span class="s1">source</span><span class="s3">[</span><span class="s5">&quot;Layers&quot;</span><span class="s3">]</span>

        <span class="s4"># Convert maps seqs or whatever into typed objects</span>
        <span class="s1">layers </span><span class="s3">= [</span><span class="s1">self</span><span class="s3">.</span><span class="s1">buildPaint</span><span class="s3">(</span><span class="s1">l</span><span class="s3">) </span><span class="s2">for </span><span class="s1">l </span><span class="s2">in </span><span class="s1">layers</span><span class="s3">]</span>

        <span class="s4"># No reason to have a colr layers with just one entry</span>
        <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">layers</span><span class="s3">) == </span><span class="s6">1</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">layers</span><span class="s3">[</span><span class="s6">0</span><span class="s3">], {}</span>

        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">cache </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s4"># Look for reuse, with preference to longer sequences</span>
            <span class="s4"># This may make the layer list smaller</span>
            <span class="s1">layers </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">cache</span><span class="s3">.</span><span class="s1">try_reuse</span><span class="s3">(</span><span class="s1">layers</span><span class="s3">)</span>

        <span class="s4"># The layer list is now final; if it's too big we need to tree it</span>
        <span class="s1">is_tree </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">layers</span><span class="s3">) &gt; </span><span class="s1">MAX_PAINT_COLR_LAYER_COUNT</span>
        <span class="s1">layers </span><span class="s3">= </span><span class="s1">build_n_ary_tree</span><span class="s3">(</span><span class="s1">layers</span><span class="s3">, </span><span class="s1">n</span><span class="s3">=</span><span class="s1">MAX_PAINT_COLR_LAYER_COUNT</span><span class="s3">)</span>

        <span class="s4"># We now have a tree of sequences with Paint leaves.</span>
        <span class="s4"># Convert the sequences into PaintColrLayers.</span>
        <span class="s2">def </span><span class="s1">listToColrLayers</span><span class="s3">(</span><span class="s1">layer</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">layer</span><span class="s3">, </span><span class="s1">collections</span><span class="s3">.</span><span class="s1">abc</span><span class="s3">.</span><span class="s1">Sequence</span><span class="s3">):</span>
                <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">buildPaint</span><span class="s3">(</span>
                    <span class="s3">{</span>
                        <span class="s5">&quot;Format&quot;</span><span class="s3">: </span><span class="s1">ot</span><span class="s3">.</span><span class="s1">PaintFormat</span><span class="s3">.</span><span class="s1">PaintColrLayers</span><span class="s3">,</span>
                        <span class="s5">&quot;Layers&quot;</span><span class="s3">: [</span><span class="s1">listToColrLayers</span><span class="s3">(</span><span class="s1">l</span><span class="s3">) </span><span class="s2">for </span><span class="s1">l </span><span class="s2">in </span><span class="s1">layer</span><span class="s3">],</span>
                    <span class="s3">}</span>
                <span class="s3">)</span>
            <span class="s2">return </span><span class="s1">layer</span>

        <span class="s1">layers </span><span class="s3">= [</span><span class="s1">listToColrLayers</span><span class="s3">(</span><span class="s1">l</span><span class="s3">) </span><span class="s2">for </span><span class="s1">l </span><span class="s2">in </span><span class="s1">layers</span><span class="s3">]</span>

        <span class="s4"># No reason to have a colr layers with just one entry</span>
        <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">layers</span><span class="s3">) == </span><span class="s6">1</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">layers</span><span class="s3">[</span><span class="s6">0</span><span class="s3">], {}</span>

        <span class="s1">paint </span><span class="s3">= </span><span class="s1">ot</span><span class="s3">.</span><span class="s1">Paint</span><span class="s3">()</span>
        <span class="s1">paint</span><span class="s3">.</span><span class="s1">Format </span><span class="s3">= </span><span class="s1">int</span><span class="s3">(</span><span class="s1">ot</span><span class="s3">.</span><span class="s1">PaintFormat</span><span class="s3">.</span><span class="s1">PaintColrLayers</span><span class="s3">)</span>
        <span class="s1">paint</span><span class="s3">.</span><span class="s1">NumLayers </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">layers</span><span class="s3">)</span>
        <span class="s1">paint</span><span class="s3">.</span><span class="s1">FirstLayerIndex </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">layers</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">layers</span><span class="s3">.</span><span class="s1">extend</span><span class="s3">(</span><span class="s1">layers</span><span class="s3">)</span>

        <span class="s4"># Register our parts for reuse provided we aren't a tree</span>
        <span class="s4"># If we are a tree the leaves registered for reuse and that will suffice</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">cache </span><span class="s2">is not None and not </span><span class="s1">is_tree</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">cache</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">layers</span><span class="s3">, </span><span class="s1">paint</span><span class="s3">.</span><span class="s1">FirstLayerIndex</span><span class="s3">)</span>

        <span class="s4"># we've fully built dest; empty source prevents generalized build from kicking in</span>
        <span class="s2">return </span><span class="s1">paint</span><span class="s3">, {}</span>

    <span class="s2">def </span><span class="s1">buildPaint</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">paint</span><span class="s3">: </span><span class="s1">_PaintInput</span><span class="s3">) </span><span class="s1">-&gt; ot</span><span class="s3">.</span><span class="s1">Paint</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">tableBuilder</span><span class="s3">.</span><span class="s1">build</span><span class="s3">(</span><span class="s1">ot</span><span class="s3">.</span><span class="s1">Paint</span><span class="s3">, </span><span class="s1">paint</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">build</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; Optional</span><span class="s3">[</span><span class="s1">ot</span><span class="s3">.</span><span class="s1">LayerList</span><span class="s3">]:</span>
        <span class="s2">if not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">layers</span><span class="s3">:</span>
            <span class="s2">return None</span>
        <span class="s1">layers </span><span class="s3">= </span><span class="s1">ot</span><span class="s3">.</span><span class="s1">LayerList</span><span class="s3">()</span>
        <span class="s1">layers</span><span class="s3">.</span><span class="s1">LayerCount </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">layers</span><span class="s3">)</span>
        <span class="s1">layers</span><span class="s3">.</span><span class="s1">Paint </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">layers</span>
        <span class="s2">return </span><span class="s1">layers</span>


<span class="s2">def </span><span class="s1">buildBaseGlyphPaintRecord</span><span class="s3">(</span>
    <span class="s1">baseGlyph</span><span class="s3">: </span><span class="s1">str</span><span class="s3">, </span><span class="s1">layerBuilder</span><span class="s3">: </span><span class="s1">LayerListBuilder</span><span class="s3">, </span><span class="s1">paint</span><span class="s3">: </span><span class="s1">_PaintInput</span>
<span class="s3">) </span><span class="s1">-&gt; ot</span><span class="s3">.</span><span class="s1">BaseGlyphList</span><span class="s3">:</span>
    <span class="s1">self </span><span class="s3">= </span><span class="s1">ot</span><span class="s3">.</span><span class="s1">BaseGlyphPaintRecord</span><span class="s3">()</span>
    <span class="s1">self</span><span class="s3">.</span><span class="s1">BaseGlyph </span><span class="s3">= </span><span class="s1">baseGlyph</span>
    <span class="s1">self</span><span class="s3">.</span><span class="s1">Paint </span><span class="s3">= </span><span class="s1">layerBuilder</span><span class="s3">.</span><span class="s1">buildPaint</span><span class="s3">(</span><span class="s1">paint</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">self</span>


<span class="s2">def </span><span class="s1">_format_glyph_errors</span><span class="s3">(</span><span class="s1">errors</span><span class="s3">: </span><span class="s1">Mapping</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Exception</span><span class="s3">]) </span><span class="s1">-&gt; str</span><span class="s3">:</span>
    <span class="s1">lines </span><span class="s3">= []</span>
    <span class="s2">for </span><span class="s1">baseGlyph</span><span class="s3">, </span><span class="s1">error </span><span class="s2">in </span><span class="s1">sorted</span><span class="s3">(</span><span class="s1">errors</span><span class="s3">.</span><span class="s1">items</span><span class="s3">()):</span>
        <span class="s1">lines</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s5">f&quot;    </span><span class="s2">{</span><span class="s1">baseGlyph</span><span class="s2">} </span><span class="s5">=&gt; </span><span class="s2">{</span><span class="s1">type</span><span class="s3">(</span><span class="s1">error</span><span class="s3">).</span><span class="s1">__name__</span><span class="s2">}</span><span class="s5">: </span><span class="s2">{</span><span class="s1">error</span><span class="s2">}</span><span class="s5">&quot;</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s5">&quot;</span><span class="s2">\n</span><span class="s5">&quot;</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">lines</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">buildColrV1</span><span class="s3">(</span>
    <span class="s1">colorGlyphs</span><span class="s3">: </span><span class="s1">_ColorGlyphsDict</span><span class="s3">,</span>
    <span class="s1">glyphMap</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">Mapping</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">int</span><span class="s3">]] = </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s3">*,</span>
    <span class="s1">allowLayerReuse</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">True</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; Tuple</span><span class="s3">[</span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">ot</span><span class="s3">.</span><span class="s1">LayerList</span><span class="s3">], </span><span class="s1">ot</span><span class="s3">.</span><span class="s1">BaseGlyphList</span><span class="s3">]:</span>
    <span class="s2">if </span><span class="s1">glyphMap </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s1">colorGlyphItems </span><span class="s3">= </span><span class="s1">sorted</span><span class="s3">(</span>
            <span class="s1">colorGlyphs</span><span class="s3">.</span><span class="s1">items</span><span class="s3">(), </span><span class="s1">key</span><span class="s3">=</span><span class="s2">lambda </span><span class="s1">item</span><span class="s3">: </span><span class="s1">glyphMap</span><span class="s3">[</span><span class="s1">item</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]]</span>
        <span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">colorGlyphItems </span><span class="s3">= </span><span class="s1">colorGlyphs</span><span class="s3">.</span><span class="s1">items</span><span class="s3">()</span>

    <span class="s1">errors </span><span class="s3">= {}</span>
    <span class="s1">baseGlyphs </span><span class="s3">= []</span>
    <span class="s1">layerBuilder </span><span class="s3">= </span><span class="s1">LayerListBuilder</span><span class="s3">(</span><span class="s1">allowLayerReuse</span><span class="s3">=</span><span class="s1">allowLayerReuse</span><span class="s3">)</span>
    <span class="s2">for </span><span class="s1">baseGlyph</span><span class="s3">, </span><span class="s1">paint </span><span class="s2">in </span><span class="s1">colorGlyphItems</span><span class="s3">:</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s1">baseGlyphs</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">buildBaseGlyphPaintRecord</span><span class="s3">(</span><span class="s1">baseGlyph</span><span class="s3">, </span><span class="s1">layerBuilder</span><span class="s3">, </span><span class="s1">paint</span><span class="s3">))</span>

        <span class="s2">except </span><span class="s3">(</span><span class="s1">ColorLibError</span><span class="s3">, </span><span class="s1">OverflowError</span><span class="s3">, </span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">TypeError</span><span class="s3">) </span><span class="s2">as </span><span class="s1">e</span><span class="s3">:</span>
            <span class="s1">errors</span><span class="s3">[</span><span class="s1">baseGlyph</span><span class="s3">] = </span><span class="s1">e</span>

    <span class="s2">if </span><span class="s1">errors</span><span class="s3">:</span>
        <span class="s1">failed_glyphs </span><span class="s3">= </span><span class="s1">_format_glyph_errors</span><span class="s3">(</span><span class="s1">errors</span><span class="s3">)</span>
        <span class="s1">exc </span><span class="s3">= </span><span class="s1">ColorLibError</span><span class="s3">(</span><span class="s5">f&quot;Failed to build BaseGlyphList:</span><span class="s2">\n{</span><span class="s1">failed_glyphs</span><span class="s2">}</span><span class="s5">&quot;</span><span class="s3">)</span>
        <span class="s1">exc</span><span class="s3">.</span><span class="s1">errors </span><span class="s3">= </span><span class="s1">errors</span>
        <span class="s2">raise </span><span class="s1">exc </span><span class="s2">from </span><span class="s1">next</span><span class="s3">(</span><span class="s1">iter</span><span class="s3">(</span><span class="s1">errors</span><span class="s3">.</span><span class="s1">values</span><span class="s3">()))</span>

    <span class="s1">layers </span><span class="s3">= </span><span class="s1">layerBuilder</span><span class="s3">.</span><span class="s1">build</span><span class="s3">()</span>
    <span class="s1">glyphs </span><span class="s3">= </span><span class="s1">ot</span><span class="s3">.</span><span class="s1">BaseGlyphList</span><span class="s3">()</span>
    <span class="s1">glyphs</span><span class="s3">.</span><span class="s1">BaseGlyphCount </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">baseGlyphs</span><span class="s3">)</span>
    <span class="s1">glyphs</span><span class="s3">.</span><span class="s1">BaseGlyphPaintRecord </span><span class="s3">= </span><span class="s1">baseGlyphs</span>
    <span class="s2">return </span><span class="s3">(</span><span class="s1">layers</span><span class="s3">, </span><span class="s1">glyphs</span><span class="s3">)</span>
</pre>
</body>
</html>