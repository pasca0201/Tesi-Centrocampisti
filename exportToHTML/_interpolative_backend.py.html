<html>
<head>
<title>_interpolative_backend.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #5f826b; font-style: italic;}
.s3 { color: #cf8e6d;}
.s4 { color: #bcbec4;}
.s5 { color: #6aab73;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_interpolative_backend.py</font>
</center></td></tr></table>
<pre><span class="s0">#******************************************************************************</span>
<span class="s0">#   Copyright (C) 2013 Kenneth L. Ho</span>
<span class="s0">#</span>
<span class="s0">#   Redistribution and use in source and binary forms, with or without</span>
<span class="s0">#   modification, are permitted provided that the following conditions are met:</span>
<span class="s0">#</span>
<span class="s0">#   Redistributions of source code must retain the above copyright notice, this</span>
<span class="s0">#   list of conditions and the following disclaimer. Redistributions in binary</span>
<span class="s0">#   form must reproduce the above copyright notice, this list of conditions and</span>
<span class="s0">#   the following disclaimer in the documentation and/or other materials</span>
<span class="s0">#   provided with the distribution.</span>
<span class="s0">#</span>
<span class="s0">#   None of the names of the copyright holders may be used to endorse or</span>
<span class="s0">#   promote products derived from this software without specific prior written</span>
<span class="s0">#   permission.</span>
<span class="s0">#</span>
<span class="s0">#   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;</span>
<span class="s0">#   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</span>
<span class="s0">#   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</span>
<span class="s0">#   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE</span>
<span class="s0">#   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR</span>
<span class="s0">#   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF</span>
<span class="s0">#   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</span>
<span class="s0">#   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN</span>
<span class="s0">#   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)</span>
<span class="s0">#   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE</span>
<span class="s0">#   POSSIBILITY OF SUCH DAMAGE.</span>
<span class="s0">#******************************************************************************</span>

<span class="s2">&quot;&quot;&quot; 
Direct wrappers for Fortran `id_dist` backend. 
&quot;&quot;&quot;</span>

<span class="s3">import </span><span class="s1">scipy</span><span class="s4">.</span><span class="s1">linalg</span><span class="s4">.</span><span class="s1">_interpolative </span><span class="s3">as </span><span class="s1">_id</span>
<span class="s3">import </span><span class="s1">numpy </span><span class="s3">as </span><span class="s1">np</span>

<span class="s1">_RETCODE_ERROR </span><span class="s4">= </span><span class="s1">RuntimeError</span><span class="s4">(</span><span class="s5">&quot;nonzero return code&quot;</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">_asfortranarray_copy</span><span class="s4">(</span><span class="s1">A</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Same as np.asfortranarray, but ensure a copy 
    &quot;&quot;&quot;</span>
    <span class="s1">A </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">(</span><span class="s1">A</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">A</span><span class="s4">.</span><span class="s1">flags</span><span class="s4">.</span><span class="s1">f_contiguous</span><span class="s4">:</span>
        <span class="s1">A </span><span class="s4">= </span><span class="s1">A</span><span class="s4">.</span><span class="s1">copy</span><span class="s4">(</span><span class="s1">order</span><span class="s4">=</span><span class="s5">&quot;F&quot;</span><span class="s4">)</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">A </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">asfortranarray</span><span class="s4">(</span><span class="s1">A</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s1">A</span>


<span class="s0">#------------------------------------------------------------------------------</span>
<span class="s0"># id_rand.f</span>
<span class="s0">#------------------------------------------------------------------------------</span>

<span class="s3">def </span><span class="s1">id_srand</span><span class="s4">(</span><span class="s1">n</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Generate standard uniform pseudorandom numbers via a very efficient lagged 
    Fibonacci method. 
 
    :param n: 
        Number of pseudorandom numbers to generate. 
    :type n: int 
 
    :return: 
        Pseudorandom numbers. 
    :rtype: :class:`numpy.ndarray` 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">_id</span><span class="s4">.</span><span class="s1">id_srand</span><span class="s4">(</span><span class="s1">n</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">id_srandi</span><span class="s4">(</span><span class="s1">t</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Initialize seed values for :func:`id_srand` (any appropriately random 
    numbers will do). 
 
    :param t: 
        Array of 55 seed values. 
    :type t: :class:`numpy.ndarray` 
    &quot;&quot;&quot;</span>
    <span class="s1">t </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">asfortranarray</span><span class="s4">(</span><span class="s1">t</span><span class="s4">)</span>
    <span class="s1">_id</span><span class="s4">.</span><span class="s1">id_srandi</span><span class="s4">(</span><span class="s1">t</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">id_srando</span><span class="s4">():</span>
    <span class="s2">&quot;&quot;&quot; 
    Reset seed values to their original values. 
    &quot;&quot;&quot;</span>
    <span class="s1">_id</span><span class="s4">.</span><span class="s1">id_srando</span><span class="s4">()</span>


<span class="s0">#------------------------------------------------------------------------------</span>
<span class="s0"># idd_frm.f</span>
<span class="s0">#------------------------------------------------------------------------------</span>

<span class="s3">def </span><span class="s1">idd_frm</span><span class="s4">(</span><span class="s1">n</span><span class="s4">, </span><span class="s1">w</span><span class="s4">, </span><span class="s1">x</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Transform real vector via a composition of Rokhlin's random transform, 
    random subselection, and an FFT. 
 
    In contrast to :func:`idd_sfrm`, this routine works best when the length of 
    the transformed vector is the power-of-two integer output by 
    :func:`idd_frmi`, or when the length is not specified but instead 
    determined a posteriori from the output. The returned transformed vector is 
    randomly permuted. 
 
    :param n: 
        Greatest power-of-two integer satisfying `n &lt;= x.size` as obtained from 
        :func:`idd_frmi`; `n` is also the length of the output vector. 
    :type n: int 
    :param w: 
        Initialization array constructed by :func:`idd_frmi`. 
    :type w: :class:`numpy.ndarray` 
    :param x: 
        Vector to be transformed. 
    :type x: :class:`numpy.ndarray` 
 
    :return: 
        Transformed vector. 
    :rtype: :class:`numpy.ndarray` 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">_id</span><span class="s4">.</span><span class="s1">idd_frm</span><span class="s4">(</span><span class="s1">n</span><span class="s4">, </span><span class="s1">w</span><span class="s4">, </span><span class="s1">x</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">idd_sfrm</span><span class="s4">(</span><span class="s1">l</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">w</span><span class="s4">, </span><span class="s1">x</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Transform real vector via a composition of Rokhlin's random transform, 
    random subselection, and an FFT. 
 
    In contrast to :func:`idd_frm`, this routine works best when the length of 
    the transformed vector is known a priori. 
 
    :param l: 
        Length of transformed vector, satisfying `l &lt;= n`. 
    :type l: int 
    :param n: 
        Greatest power-of-two integer satisfying `n &lt;= x.size` as obtained from 
        :func:`idd_sfrmi`. 
    :type n: int 
    :param w: 
        Initialization array constructed by :func:`idd_sfrmi`. 
    :type w: :class:`numpy.ndarray` 
    :param x: 
        Vector to be transformed. 
    :type x: :class:`numpy.ndarray` 
 
    :return: 
        Transformed vector. 
    :rtype: :class:`numpy.ndarray` 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">_id</span><span class="s4">.</span><span class="s1">idd_sfrm</span><span class="s4">(</span><span class="s1">l</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">w</span><span class="s4">, </span><span class="s1">x</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">idd_frmi</span><span class="s4">(</span><span class="s1">m</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Initialize data for :func:`idd_frm`. 
 
    :param m: 
        Length of vector to be transformed. 
    :type m: int 
 
    :return: 
        Greatest power-of-two integer `n` satisfying `n &lt;= m`. 
    :rtype: int 
    :return: 
        Initialization array to be used by :func:`idd_frm`. 
    :rtype: :class:`numpy.ndarray` 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">_id</span><span class="s4">.</span><span class="s1">idd_frmi</span><span class="s4">(</span><span class="s1">m</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">idd_sfrmi</span><span class="s4">(</span><span class="s1">l</span><span class="s4">, </span><span class="s1">m</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Initialize data for :func:`idd_sfrm`. 
 
    :param l: 
        Length of output transformed vector. 
    :type l: int 
    :param m: 
        Length of the vector to be transformed. 
    :type m: int 
 
    :return: 
        Greatest power-of-two integer `n` satisfying `n &lt;= m`. 
    :rtype: int 
    :return: 
        Initialization array to be used by :func:`idd_sfrm`. 
    :rtype: :class:`numpy.ndarray` 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">_id</span><span class="s4">.</span><span class="s1">idd_sfrmi</span><span class="s4">(</span><span class="s1">l</span><span class="s4">, </span><span class="s1">m</span><span class="s4">)</span>


<span class="s0">#------------------------------------------------------------------------------</span>
<span class="s0"># idd_id.f</span>
<span class="s0">#------------------------------------------------------------------------------</span>

<span class="s3">def </span><span class="s1">iddp_id</span><span class="s4">(</span><span class="s1">eps</span><span class="s4">, </span><span class="s1">A</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Compute ID of a real matrix to a specified relative precision. 
 
    :param eps: 
        Relative precision. 
    :type eps: float 
    :param A: 
        Matrix. 
    :type A: :class:`numpy.ndarray` 
 
    :return: 
        Rank of ID. 
    :rtype: int 
    :return: 
        Column index array. 
    :rtype: :class:`numpy.ndarray` 
    :return: 
        Interpolation coefficients. 
    :rtype: :class:`numpy.ndarray` 
    &quot;&quot;&quot;</span>
    <span class="s1">A </span><span class="s4">= </span><span class="s1">_asfortranarray_copy</span><span class="s4">(</span><span class="s1">A</span><span class="s4">)</span>
    <span class="s1">k</span><span class="s4">, </span><span class="s1">idx</span><span class="s4">, </span><span class="s1">rnorms </span><span class="s4">= </span><span class="s1">_id</span><span class="s4">.</span><span class="s1">iddp_id</span><span class="s4">(</span><span class="s1">eps</span><span class="s4">, </span><span class="s1">A</span><span class="s4">)</span>
    <span class="s1">n </span><span class="s4">= </span><span class="s1">A</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">1</span><span class="s4">]</span>
    <span class="s1">proj </span><span class="s4">= </span><span class="s1">A</span><span class="s4">.</span><span class="s1">T</span><span class="s4">.</span><span class="s1">ravel</span><span class="s4">()[:</span><span class="s1">k</span><span class="s4">*(</span><span class="s1">n</span><span class="s4">-</span><span class="s1">k</span><span class="s4">)].</span><span class="s1">reshape</span><span class="s4">((</span><span class="s1">k</span><span class="s4">, </span><span class="s1">n</span><span class="s4">-</span><span class="s1">k</span><span class="s4">), </span><span class="s1">order</span><span class="s4">=</span><span class="s5">'F'</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s1">k</span><span class="s4">, </span><span class="s1">idx</span><span class="s4">, </span><span class="s1">proj</span>


<span class="s3">def </span><span class="s1">iddr_id</span><span class="s4">(</span><span class="s1">A</span><span class="s4">, </span><span class="s1">k</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Compute ID of a real matrix to a specified rank. 
 
    :param A: 
        Matrix. 
    :type A: :class:`numpy.ndarray` 
    :param k: 
        Rank of ID. 
    :type k: int 
 
    :return: 
        Column index array. 
    :rtype: :class:`numpy.ndarray` 
    :return: 
        Interpolation coefficients. 
    :rtype: :class:`numpy.ndarray` 
    &quot;&quot;&quot;</span>
    <span class="s1">A </span><span class="s4">= </span><span class="s1">_asfortranarray_copy</span><span class="s4">(</span><span class="s1">A</span><span class="s4">)</span>
    <span class="s1">idx</span><span class="s4">, </span><span class="s1">rnorms </span><span class="s4">= </span><span class="s1">_id</span><span class="s4">.</span><span class="s1">iddr_id</span><span class="s4">(</span><span class="s1">A</span><span class="s4">, </span><span class="s1">k</span><span class="s4">)</span>
    <span class="s1">n </span><span class="s4">= </span><span class="s1">A</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">1</span><span class="s4">]</span>
    <span class="s1">proj </span><span class="s4">= </span><span class="s1">A</span><span class="s4">.</span><span class="s1">T</span><span class="s4">.</span><span class="s1">ravel</span><span class="s4">()[:</span><span class="s1">k</span><span class="s4">*(</span><span class="s1">n</span><span class="s4">-</span><span class="s1">k</span><span class="s4">)].</span><span class="s1">reshape</span><span class="s4">((</span><span class="s1">k</span><span class="s4">, </span><span class="s1">n</span><span class="s4">-</span><span class="s1">k</span><span class="s4">), </span><span class="s1">order</span><span class="s4">=</span><span class="s5">'F'</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s1">idx</span><span class="s4">, </span><span class="s1">proj</span>


<span class="s3">def </span><span class="s1">idd_reconid</span><span class="s4">(</span><span class="s1">B</span><span class="s4">, </span><span class="s1">idx</span><span class="s4">, </span><span class="s1">proj</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Reconstruct matrix from real ID. 
 
    :param B: 
        Skeleton matrix. 
    :type B: :class:`numpy.ndarray` 
    :param idx: 
        Column index array. 
    :type idx: :class:`numpy.ndarray` 
    :param proj: 
        Interpolation coefficients. 
    :type proj: :class:`numpy.ndarray` 
 
    :return: 
        Reconstructed matrix. 
    :rtype: :class:`numpy.ndarray` 
    &quot;&quot;&quot;</span>
    <span class="s1">B </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">asfortranarray</span><span class="s4">(</span><span class="s1">B</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">proj</span><span class="s4">.</span><span class="s1">size </span><span class="s4">&gt; </span><span class="s6">0</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">_id</span><span class="s4">.</span><span class="s1">idd_reconid</span><span class="s4">(</span><span class="s1">B</span><span class="s4">, </span><span class="s1">idx</span><span class="s4">, </span><span class="s1">proj</span><span class="s4">)</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">B</span><span class="s4">[:, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">argsort</span><span class="s4">(</span><span class="s1">idx</span><span class="s4">)]</span>


<span class="s3">def </span><span class="s1">idd_reconint</span><span class="s4">(</span><span class="s1">idx</span><span class="s4">, </span><span class="s1">proj</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Reconstruct interpolation matrix from real ID. 
 
    :param idx: 
        Column index array. 
    :type idx: :class:`numpy.ndarray` 
    :param proj: 
        Interpolation coefficients. 
    :type proj: :class:`numpy.ndarray` 
 
    :return: 
        Interpolation matrix. 
    :rtype: :class:`numpy.ndarray` 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">_id</span><span class="s4">.</span><span class="s1">idd_reconint</span><span class="s4">(</span><span class="s1">idx</span><span class="s4">, </span><span class="s1">proj</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">idd_copycols</span><span class="s4">(</span><span class="s1">A</span><span class="s4">, </span><span class="s1">k</span><span class="s4">, </span><span class="s1">idx</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Reconstruct skeleton matrix from real ID. 
 
    :param A: 
        Original matrix. 
    :type A: :class:`numpy.ndarray` 
    :param k: 
        Rank of ID. 
    :type k: int 
    :param idx: 
        Column index array. 
    :type idx: :class:`numpy.ndarray` 
 
    :return: 
        Skeleton matrix. 
    :rtype: :class:`numpy.ndarray` 
    &quot;&quot;&quot;</span>
    <span class="s1">A </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">asfortranarray</span><span class="s4">(</span><span class="s1">A</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s1">_id</span><span class="s4">.</span><span class="s1">idd_copycols</span><span class="s4">(</span><span class="s1">A</span><span class="s4">, </span><span class="s1">k</span><span class="s4">, </span><span class="s1">idx</span><span class="s4">)</span>


<span class="s0">#------------------------------------------------------------------------------</span>
<span class="s0"># idd_id2svd.f</span>
<span class="s0">#------------------------------------------------------------------------------</span>

<span class="s3">def </span><span class="s1">idd_id2svd</span><span class="s4">(</span><span class="s1">B</span><span class="s4">, </span><span class="s1">idx</span><span class="s4">, </span><span class="s1">proj</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Convert real ID to SVD. 
 
    :param B: 
        Skeleton matrix. 
    :type B: :class:`numpy.ndarray` 
    :param idx: 
        Column index array. 
    :type idx: :class:`numpy.ndarray` 
    :param proj: 
        Interpolation coefficients. 
    :type proj: :class:`numpy.ndarray` 
 
    :return: 
        Left singular vectors. 
    :rtype: :class:`numpy.ndarray` 
    :return: 
        Right singular vectors. 
    :rtype: :class:`numpy.ndarray` 
    :return: 
        Singular values. 
    :rtype: :class:`numpy.ndarray` 
    &quot;&quot;&quot;</span>
    <span class="s1">B </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">asfortranarray</span><span class="s4">(</span><span class="s1">B</span><span class="s4">)</span>
    <span class="s1">U</span><span class="s4">, </span><span class="s1">V</span><span class="s4">, </span><span class="s1">S</span><span class="s4">, </span><span class="s1">ier </span><span class="s4">= </span><span class="s1">_id</span><span class="s4">.</span><span class="s1">idd_id2svd</span><span class="s4">(</span><span class="s1">B</span><span class="s4">, </span><span class="s1">idx</span><span class="s4">, </span><span class="s1">proj</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">ier</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">_RETCODE_ERROR</span>
    <span class="s3">return </span><span class="s1">U</span><span class="s4">, </span><span class="s1">V</span><span class="s4">, </span><span class="s1">S</span>


<span class="s0">#------------------------------------------------------------------------------</span>
<span class="s0"># idd_snorm.f</span>
<span class="s0">#------------------------------------------------------------------------------</span>

<span class="s3">def </span><span class="s1">idd_snorm</span><span class="s4">(</span><span class="s1">m</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">matvect</span><span class="s4">, </span><span class="s1">matvec</span><span class="s4">, </span><span class="s1">its</span><span class="s4">=</span><span class="s6">20</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Estimate spectral norm of a real matrix by the randomized power method. 
 
    :param m: 
        Matrix row dimension. 
    :type m: int 
    :param n: 
        Matrix column dimension. 
    :type n: int 
    :param matvect: 
        Function to apply the matrix transpose to a vector, with call signature 
        `y = matvect(x)`, where `x` and `y` are the input and output vectors, 
        respectively. 
    :type matvect: function 
    :param matvec: 
        Function to apply the matrix to a vector, with call signature 
        `y = matvec(x)`, where `x` and `y` are the input and output vectors, 
        respectively. 
    :type matvec: function 
    :param its: 
        Number of power method iterations. 
    :type its: int 
 
    :return: 
        Spectral norm estimate. 
    :rtype: float 
    &quot;&quot;&quot;</span>
    <span class="s1">snorm</span><span class="s4">, </span><span class="s1">v </span><span class="s4">= </span><span class="s1">_id</span><span class="s4">.</span><span class="s1">idd_snorm</span><span class="s4">(</span><span class="s1">m</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">matvect</span><span class="s4">, </span><span class="s1">matvec</span><span class="s4">, </span><span class="s1">its</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s1">snorm</span>


<span class="s3">def </span><span class="s1">idd_diffsnorm</span><span class="s4">(</span><span class="s1">m</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">matvect</span><span class="s4">, </span><span class="s1">matvect2</span><span class="s4">, </span><span class="s1">matvec</span><span class="s4">, </span><span class="s1">matvec2</span><span class="s4">, </span><span class="s1">its</span><span class="s4">=</span><span class="s6">20</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Estimate spectral norm of the difference of two real matrices by the 
    randomized power method. 
 
    :param m: 
        Matrix row dimension. 
    :type m: int 
    :param n: 
        Matrix column dimension. 
    :type n: int 
    :param matvect: 
        Function to apply the transpose of the first matrix to a vector, with 
        call signature `y = matvect(x)`, where `x` and `y` are the input and 
        output vectors, respectively. 
    :type matvect: function 
    :param matvect2: 
        Function to apply the transpose of the second matrix to a vector, with 
        call signature `y = matvect2(x)`, where `x` and `y` are the input and 
        output vectors, respectively. 
    :type matvect2: function 
    :param matvec: 
        Function to apply the first matrix to a vector, with call signature 
        `y = matvec(x)`, where `x` and `y` are the input and output vectors, 
        respectively. 
    :type matvec: function 
    :param matvec2: 
        Function to apply the second matrix to a vector, with call signature 
        `y = matvec2(x)`, where `x` and `y` are the input and output vectors, 
        respectively. 
    :type matvec2: function 
    :param its: 
        Number of power method iterations. 
    :type its: int 
 
    :return: 
        Spectral norm estimate of matrix difference. 
    :rtype: float 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">_id</span><span class="s4">.</span><span class="s1">idd_diffsnorm</span><span class="s4">(</span><span class="s1">m</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">matvect</span><span class="s4">, </span><span class="s1">matvect2</span><span class="s4">, </span><span class="s1">matvec</span><span class="s4">, </span><span class="s1">matvec2</span><span class="s4">, </span><span class="s1">its</span><span class="s4">)</span>


<span class="s0">#------------------------------------------------------------------------------</span>
<span class="s0"># idd_svd.f</span>
<span class="s0">#------------------------------------------------------------------------------</span>

<span class="s3">def </span><span class="s1">iddr_svd</span><span class="s4">(</span><span class="s1">A</span><span class="s4">, </span><span class="s1">k</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Compute SVD of a real matrix to a specified rank. 
 
    :param A: 
        Matrix. 
    :type A: :class:`numpy.ndarray` 
    :param k: 
        Rank of SVD. 
    :type k: int 
 
    :return: 
        Left singular vectors. 
    :rtype: :class:`numpy.ndarray` 
    :return: 
        Right singular vectors. 
    :rtype: :class:`numpy.ndarray` 
    :return: 
        Singular values. 
    :rtype: :class:`numpy.ndarray` 
    &quot;&quot;&quot;</span>
    <span class="s1">A </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">asfortranarray</span><span class="s4">(</span><span class="s1">A</span><span class="s4">)</span>
    <span class="s1">U</span><span class="s4">, </span><span class="s1">V</span><span class="s4">, </span><span class="s1">S</span><span class="s4">, </span><span class="s1">ier </span><span class="s4">= </span><span class="s1">_id</span><span class="s4">.</span><span class="s1">iddr_svd</span><span class="s4">(</span><span class="s1">A</span><span class="s4">, </span><span class="s1">k</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">ier</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">_RETCODE_ERROR</span>
    <span class="s3">return </span><span class="s1">U</span><span class="s4">, </span><span class="s1">V</span><span class="s4">, </span><span class="s1">S</span>


<span class="s3">def </span><span class="s1">iddp_svd</span><span class="s4">(</span><span class="s1">eps</span><span class="s4">, </span><span class="s1">A</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Compute SVD of a real matrix to a specified relative precision. 
 
    :param eps: 
        Relative precision. 
    :type eps: float 
    :param A: 
        Matrix. 
    :type A: :class:`numpy.ndarray` 
 
    :return: 
        Left singular vectors. 
    :rtype: :class:`numpy.ndarray` 
    :return: 
        Right singular vectors. 
    :rtype: :class:`numpy.ndarray` 
    :return: 
        Singular values. 
    :rtype: :class:`numpy.ndarray` 
    &quot;&quot;&quot;</span>
    <span class="s1">A </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">asfortranarray</span><span class="s4">(</span><span class="s1">A</span><span class="s4">)</span>
    <span class="s1">m</span><span class="s4">, </span><span class="s1">n </span><span class="s4">= </span><span class="s1">A</span><span class="s4">.</span><span class="s1">shape</span>
    <span class="s1">k</span><span class="s4">, </span><span class="s1">iU</span><span class="s4">, </span><span class="s1">iV</span><span class="s4">, </span><span class="s1">iS</span><span class="s4">, </span><span class="s1">w</span><span class="s4">, </span><span class="s1">ier </span><span class="s4">= </span><span class="s1">_id</span><span class="s4">.</span><span class="s1">iddp_svd</span><span class="s4">(</span><span class="s1">eps</span><span class="s4">, </span><span class="s1">A</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">ier</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">_RETCODE_ERROR</span>
    <span class="s1">U </span><span class="s4">= </span><span class="s1">w</span><span class="s4">[</span><span class="s1">iU</span><span class="s4">-</span><span class="s6">1</span><span class="s4">:</span><span class="s1">iU</span><span class="s4">+</span><span class="s1">m</span><span class="s4">*</span><span class="s1">k</span><span class="s4">-</span><span class="s6">1</span><span class="s4">].</span><span class="s1">reshape</span><span class="s4">((</span><span class="s1">m</span><span class="s4">, </span><span class="s1">k</span><span class="s4">), </span><span class="s1">order</span><span class="s4">=</span><span class="s5">'F'</span><span class="s4">)</span>
    <span class="s1">V </span><span class="s4">= </span><span class="s1">w</span><span class="s4">[</span><span class="s1">iV</span><span class="s4">-</span><span class="s6">1</span><span class="s4">:</span><span class="s1">iV</span><span class="s4">+</span><span class="s1">n</span><span class="s4">*</span><span class="s1">k</span><span class="s4">-</span><span class="s6">1</span><span class="s4">].</span><span class="s1">reshape</span><span class="s4">((</span><span class="s1">n</span><span class="s4">, </span><span class="s1">k</span><span class="s4">), </span><span class="s1">order</span><span class="s4">=</span><span class="s5">'F'</span><span class="s4">)</span>
    <span class="s1">S </span><span class="s4">= </span><span class="s1">w</span><span class="s4">[</span><span class="s1">iS</span><span class="s4">-</span><span class="s6">1</span><span class="s4">:</span><span class="s1">iS</span><span class="s4">+</span><span class="s1">k</span><span class="s4">-</span><span class="s6">1</span><span class="s4">]</span>
    <span class="s3">return </span><span class="s1">U</span><span class="s4">, </span><span class="s1">V</span><span class="s4">, </span><span class="s1">S</span>


<span class="s0">#------------------------------------------------------------------------------</span>
<span class="s0"># iddp_aid.f</span>
<span class="s0">#------------------------------------------------------------------------------</span>

<span class="s3">def </span><span class="s1">iddp_aid</span><span class="s4">(</span><span class="s1">eps</span><span class="s4">, </span><span class="s1">A</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Compute ID of a real matrix to a specified relative precision using random 
    sampling. 
 
    :param eps: 
        Relative precision. 
    :type eps: float 
    :param A: 
        Matrix. 
    :type A: :class:`numpy.ndarray` 
 
    :return: 
        Rank of ID. 
    :rtype: int 
    :return: 
        Column index array. 
    :rtype: :class:`numpy.ndarray` 
    :return: 
        Interpolation coefficients. 
    :rtype: :class:`numpy.ndarray` 
    &quot;&quot;&quot;</span>
    <span class="s1">A </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">asfortranarray</span><span class="s4">(</span><span class="s1">A</span><span class="s4">)</span>
    <span class="s1">m</span><span class="s4">, </span><span class="s1">n </span><span class="s4">= </span><span class="s1">A</span><span class="s4">.</span><span class="s1">shape</span>
    <span class="s1">n2</span><span class="s4">, </span><span class="s1">w </span><span class="s4">= </span><span class="s1">idd_frmi</span><span class="s4">(</span><span class="s1">m</span><span class="s4">)</span>
    <span class="s1">proj </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">empty</span><span class="s4">(</span><span class="s1">n</span><span class="s4">*(</span><span class="s6">2</span><span class="s4">*</span><span class="s1">n2 </span><span class="s4">+ </span><span class="s6">1</span><span class="s4">) + </span><span class="s1">n2 </span><span class="s4">+ </span><span class="s6">1</span><span class="s4">, </span><span class="s1">order</span><span class="s4">=</span><span class="s5">'F'</span><span class="s4">)</span>
    <span class="s1">k</span><span class="s4">, </span><span class="s1">idx</span><span class="s4">, </span><span class="s1">proj </span><span class="s4">= </span><span class="s1">_id</span><span class="s4">.</span><span class="s1">iddp_aid</span><span class="s4">(</span><span class="s1">eps</span><span class="s4">, </span><span class="s1">A</span><span class="s4">, </span><span class="s1">w</span><span class="s4">, </span><span class="s1">proj</span><span class="s4">)</span>
    <span class="s1">proj </span><span class="s4">= </span><span class="s1">proj</span><span class="s4">[:</span><span class="s1">k</span><span class="s4">*(</span><span class="s1">n</span><span class="s4">-</span><span class="s1">k</span><span class="s4">)].</span><span class="s1">reshape</span><span class="s4">((</span><span class="s1">k</span><span class="s4">, </span><span class="s1">n</span><span class="s4">-</span><span class="s1">k</span><span class="s4">), </span><span class="s1">order</span><span class="s4">=</span><span class="s5">'F'</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s1">k</span><span class="s4">, </span><span class="s1">idx</span><span class="s4">, </span><span class="s1">proj</span>


<span class="s3">def </span><span class="s1">idd_estrank</span><span class="s4">(</span><span class="s1">eps</span><span class="s4">, </span><span class="s1">A</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Estimate rank of a real matrix to a specified relative precision using 
    random sampling. 
 
    The output rank is typically about 8 higher than the actual rank. 
 
    :param eps: 
        Relative precision. 
    :type eps: float 
    :param A: 
        Matrix. 
    :type A: :class:`numpy.ndarray` 
 
    :return: 
        Rank estimate. 
    :rtype: int 
    &quot;&quot;&quot;</span>
    <span class="s1">A </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">asfortranarray</span><span class="s4">(</span><span class="s1">A</span><span class="s4">)</span>
    <span class="s1">m</span><span class="s4">, </span><span class="s1">n </span><span class="s4">= </span><span class="s1">A</span><span class="s4">.</span><span class="s1">shape</span>
    <span class="s1">n2</span><span class="s4">, </span><span class="s1">w </span><span class="s4">= </span><span class="s1">idd_frmi</span><span class="s4">(</span><span class="s1">m</span><span class="s4">)</span>
    <span class="s1">ra </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">empty</span><span class="s4">(</span><span class="s1">n</span><span class="s4">*</span><span class="s1">n2 </span><span class="s4">+ (</span><span class="s1">n </span><span class="s4">+ </span><span class="s6">1</span><span class="s4">)*(</span><span class="s1">n2 </span><span class="s4">+ </span><span class="s6">1</span><span class="s4">), </span><span class="s1">order</span><span class="s4">=</span><span class="s5">'F'</span><span class="s4">)</span>
    <span class="s1">k</span><span class="s4">, </span><span class="s1">ra </span><span class="s4">= </span><span class="s1">_id</span><span class="s4">.</span><span class="s1">idd_estrank</span><span class="s4">(</span><span class="s1">eps</span><span class="s4">, </span><span class="s1">A</span><span class="s4">, </span><span class="s1">w</span><span class="s4">, </span><span class="s1">ra</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s1">k</span>


<span class="s0">#------------------------------------------------------------------------------</span>
<span class="s0"># iddp_asvd.f</span>
<span class="s0">#------------------------------------------------------------------------------</span>

<span class="s3">def </span><span class="s1">iddp_asvd</span><span class="s4">(</span><span class="s1">eps</span><span class="s4">, </span><span class="s1">A</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Compute SVD of a real matrix to a specified relative precision using random 
    sampling. 
 
    :param eps: 
        Relative precision. 
    :type eps: float 
    :param A: 
        Matrix. 
    :type A: :class:`numpy.ndarray` 
 
    :return: 
        Left singular vectors. 
    :rtype: :class:`numpy.ndarray` 
    :return: 
        Right singular vectors. 
    :rtype: :class:`numpy.ndarray` 
    :return: 
        Singular values. 
    :rtype: :class:`numpy.ndarray` 
    &quot;&quot;&quot;</span>
    <span class="s1">A </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">asfortranarray</span><span class="s4">(</span><span class="s1">A</span><span class="s4">)</span>
    <span class="s1">m</span><span class="s4">, </span><span class="s1">n </span><span class="s4">= </span><span class="s1">A</span><span class="s4">.</span><span class="s1">shape</span>
    <span class="s1">n2</span><span class="s4">, </span><span class="s1">winit </span><span class="s4">= </span><span class="s1">_id</span><span class="s4">.</span><span class="s1">idd_frmi</span><span class="s4">(</span><span class="s1">m</span><span class="s4">)</span>
    <span class="s1">w </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">empty</span><span class="s4">(</span>
        <span class="s1">max</span><span class="s4">((</span><span class="s1">min</span><span class="s4">(</span><span class="s1">m</span><span class="s4">, </span><span class="s1">n</span><span class="s4">) + </span><span class="s6">1</span><span class="s4">)*(</span><span class="s6">3</span><span class="s4">*</span><span class="s1">m </span><span class="s4">+ </span><span class="s6">5</span><span class="s4">*</span><span class="s1">n </span><span class="s4">+ </span><span class="s6">1</span><span class="s4">) + </span><span class="s6">25</span><span class="s4">*</span><span class="s1">min</span><span class="s4">(</span><span class="s1">m</span><span class="s4">, </span><span class="s1">n</span><span class="s4">)**</span><span class="s6">2</span><span class="s4">,</span>
            <span class="s4">(</span><span class="s6">2</span><span class="s4">*</span><span class="s1">n </span><span class="s4">+ </span><span class="s6">1</span><span class="s4">)*(</span><span class="s1">n2 </span><span class="s4">+ </span><span class="s6">1</span><span class="s4">)),</span>
        <span class="s1">order</span><span class="s4">=</span><span class="s5">'F'</span><span class="s4">)</span>
    <span class="s1">k</span><span class="s4">, </span><span class="s1">iU</span><span class="s4">, </span><span class="s1">iV</span><span class="s4">, </span><span class="s1">iS</span><span class="s4">, </span><span class="s1">w</span><span class="s4">, </span><span class="s1">ier </span><span class="s4">= </span><span class="s1">_id</span><span class="s4">.</span><span class="s1">iddp_asvd</span><span class="s4">(</span><span class="s1">eps</span><span class="s4">, </span><span class="s1">A</span><span class="s4">, </span><span class="s1">winit</span><span class="s4">, </span><span class="s1">w</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">ier</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">_RETCODE_ERROR</span>
    <span class="s1">U </span><span class="s4">= </span><span class="s1">w</span><span class="s4">[</span><span class="s1">iU</span><span class="s4">-</span><span class="s6">1</span><span class="s4">:</span><span class="s1">iU</span><span class="s4">+</span><span class="s1">m</span><span class="s4">*</span><span class="s1">k</span><span class="s4">-</span><span class="s6">1</span><span class="s4">].</span><span class="s1">reshape</span><span class="s4">((</span><span class="s1">m</span><span class="s4">, </span><span class="s1">k</span><span class="s4">), </span><span class="s1">order</span><span class="s4">=</span><span class="s5">'F'</span><span class="s4">)</span>
    <span class="s1">V </span><span class="s4">= </span><span class="s1">w</span><span class="s4">[</span><span class="s1">iV</span><span class="s4">-</span><span class="s6">1</span><span class="s4">:</span><span class="s1">iV</span><span class="s4">+</span><span class="s1">n</span><span class="s4">*</span><span class="s1">k</span><span class="s4">-</span><span class="s6">1</span><span class="s4">].</span><span class="s1">reshape</span><span class="s4">((</span><span class="s1">n</span><span class="s4">, </span><span class="s1">k</span><span class="s4">), </span><span class="s1">order</span><span class="s4">=</span><span class="s5">'F'</span><span class="s4">)</span>
    <span class="s1">S </span><span class="s4">= </span><span class="s1">w</span><span class="s4">[</span><span class="s1">iS</span><span class="s4">-</span><span class="s6">1</span><span class="s4">:</span><span class="s1">iS</span><span class="s4">+</span><span class="s1">k</span><span class="s4">-</span><span class="s6">1</span><span class="s4">]</span>
    <span class="s3">return </span><span class="s1">U</span><span class="s4">, </span><span class="s1">V</span><span class="s4">, </span><span class="s1">S</span>


<span class="s0">#------------------------------------------------------------------------------</span>
<span class="s0"># iddp_rid.f</span>
<span class="s0">#------------------------------------------------------------------------------</span>

<span class="s3">def </span><span class="s1">iddp_rid</span><span class="s4">(</span><span class="s1">eps</span><span class="s4">, </span><span class="s1">m</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">matvect</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Compute ID of a real matrix to a specified relative precision using random 
    matrix-vector multiplication. 
 
    :param eps: 
        Relative precision. 
    :type eps: float 
    :param m: 
        Matrix row dimension. 
    :type m: int 
    :param n: 
        Matrix column dimension. 
    :type n: int 
    :param matvect: 
        Function to apply the matrix transpose to a vector, with call signature 
        `y = matvect(x)`, where `x` and `y` are the input and output vectors, 
        respectively. 
    :type matvect: function 
 
    :return: 
        Rank of ID. 
    :rtype: int 
    :return: 
        Column index array. 
    :rtype: :class:`numpy.ndarray` 
    :return: 
        Interpolation coefficients. 
    :rtype: :class:`numpy.ndarray` 
    &quot;&quot;&quot;</span>
    <span class="s1">proj </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">empty</span><span class="s4">(</span><span class="s1">m </span><span class="s4">+ </span><span class="s6">1 </span><span class="s4">+ </span><span class="s6">2</span><span class="s4">*</span><span class="s1">n</span><span class="s4">*(</span><span class="s1">min</span><span class="s4">(</span><span class="s1">m</span><span class="s4">, </span><span class="s1">n</span><span class="s4">) + </span><span class="s6">1</span><span class="s4">), </span><span class="s1">order</span><span class="s4">=</span><span class="s5">'F'</span><span class="s4">)</span>
    <span class="s1">k</span><span class="s4">, </span><span class="s1">idx</span><span class="s4">, </span><span class="s1">proj</span><span class="s4">, </span><span class="s1">ier </span><span class="s4">= </span><span class="s1">_id</span><span class="s4">.</span><span class="s1">iddp_rid</span><span class="s4">(</span><span class="s1">eps</span><span class="s4">, </span><span class="s1">m</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">matvect</span><span class="s4">, </span><span class="s1">proj</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">ier </span><span class="s4">!= </span><span class="s6">0</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">_RETCODE_ERROR</span>
    <span class="s1">proj </span><span class="s4">= </span><span class="s1">proj</span><span class="s4">[:</span><span class="s1">k</span><span class="s4">*(</span><span class="s1">n</span><span class="s4">-</span><span class="s1">k</span><span class="s4">)].</span><span class="s1">reshape</span><span class="s4">((</span><span class="s1">k</span><span class="s4">, </span><span class="s1">n</span><span class="s4">-</span><span class="s1">k</span><span class="s4">), </span><span class="s1">order</span><span class="s4">=</span><span class="s5">'F'</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s1">k</span><span class="s4">, </span><span class="s1">idx</span><span class="s4">, </span><span class="s1">proj</span>


<span class="s3">def </span><span class="s1">idd_findrank</span><span class="s4">(</span><span class="s1">eps</span><span class="s4">, </span><span class="s1">m</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">matvect</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Estimate rank of a real matrix to a specified relative precision using 
    random matrix-vector multiplication. 
 
    :param eps: 
        Relative precision. 
    :type eps: float 
    :param m: 
        Matrix row dimension. 
    :type m: int 
    :param n: 
        Matrix column dimension. 
    :type n: int 
    :param matvect: 
        Function to apply the matrix transpose to a vector, with call signature 
        `y = matvect(x)`, where `x` and `y` are the input and output vectors, 
        respectively. 
    :type matvect: function 
 
    :return: 
        Rank estimate. 
    :rtype: int 
    &quot;&quot;&quot;</span>
    <span class="s1">k</span><span class="s4">, </span><span class="s1">ra</span><span class="s4">, </span><span class="s1">ier </span><span class="s4">= </span><span class="s1">_id</span><span class="s4">.</span><span class="s1">idd_findrank</span><span class="s4">(</span><span class="s1">eps</span><span class="s4">, </span><span class="s1">m</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">matvect</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">ier</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">_RETCODE_ERROR</span>
    <span class="s3">return </span><span class="s1">k</span>


<span class="s0">#------------------------------------------------------------------------------</span>
<span class="s0"># iddp_rsvd.f</span>
<span class="s0">#------------------------------------------------------------------------------</span>

<span class="s3">def </span><span class="s1">iddp_rsvd</span><span class="s4">(</span><span class="s1">eps</span><span class="s4">, </span><span class="s1">m</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">matvect</span><span class="s4">, </span><span class="s1">matvec</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Compute SVD of a real matrix to a specified relative precision using random 
    matrix-vector multiplication. 
 
    :param eps: 
        Relative precision. 
    :type eps: float 
    :param m: 
        Matrix row dimension. 
    :type m: int 
    :param n: 
        Matrix column dimension. 
    :type n: int 
    :param matvect: 
        Function to apply the matrix transpose to a vector, with call signature 
        `y = matvect(x)`, where `x` and `y` are the input and output vectors, 
        respectively. 
    :type matvect: function 
    :param matvec: 
        Function to apply the matrix to a vector, with call signature 
        `y = matvec(x)`, where `x` and `y` are the input and output vectors, 
        respectively. 
    :type matvec: function 
 
    :return: 
        Left singular vectors. 
    :rtype: :class:`numpy.ndarray` 
    :return: 
        Right singular vectors. 
    :rtype: :class:`numpy.ndarray` 
    :return: 
        Singular values. 
    :rtype: :class:`numpy.ndarray` 
    &quot;&quot;&quot;</span>
    <span class="s1">k</span><span class="s4">, </span><span class="s1">iU</span><span class="s4">, </span><span class="s1">iV</span><span class="s4">, </span><span class="s1">iS</span><span class="s4">, </span><span class="s1">w</span><span class="s4">, </span><span class="s1">ier </span><span class="s4">= </span><span class="s1">_id</span><span class="s4">.</span><span class="s1">iddp_rsvd</span><span class="s4">(</span><span class="s1">eps</span><span class="s4">, </span><span class="s1">m</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">matvect</span><span class="s4">, </span><span class="s1">matvec</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">ier</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">_RETCODE_ERROR</span>
    <span class="s1">U </span><span class="s4">= </span><span class="s1">w</span><span class="s4">[</span><span class="s1">iU</span><span class="s4">-</span><span class="s6">1</span><span class="s4">:</span><span class="s1">iU</span><span class="s4">+</span><span class="s1">m</span><span class="s4">*</span><span class="s1">k</span><span class="s4">-</span><span class="s6">1</span><span class="s4">].</span><span class="s1">reshape</span><span class="s4">((</span><span class="s1">m</span><span class="s4">, </span><span class="s1">k</span><span class="s4">), </span><span class="s1">order</span><span class="s4">=</span><span class="s5">'F'</span><span class="s4">)</span>
    <span class="s1">V </span><span class="s4">= </span><span class="s1">w</span><span class="s4">[</span><span class="s1">iV</span><span class="s4">-</span><span class="s6">1</span><span class="s4">:</span><span class="s1">iV</span><span class="s4">+</span><span class="s1">n</span><span class="s4">*</span><span class="s1">k</span><span class="s4">-</span><span class="s6">1</span><span class="s4">].</span><span class="s1">reshape</span><span class="s4">((</span><span class="s1">n</span><span class="s4">, </span><span class="s1">k</span><span class="s4">), </span><span class="s1">order</span><span class="s4">=</span><span class="s5">'F'</span><span class="s4">)</span>
    <span class="s1">S </span><span class="s4">= </span><span class="s1">w</span><span class="s4">[</span><span class="s1">iS</span><span class="s4">-</span><span class="s6">1</span><span class="s4">:</span><span class="s1">iS</span><span class="s4">+</span><span class="s1">k</span><span class="s4">-</span><span class="s6">1</span><span class="s4">]</span>
    <span class="s3">return </span><span class="s1">U</span><span class="s4">, </span><span class="s1">V</span><span class="s4">, </span><span class="s1">S</span>


<span class="s0">#------------------------------------------------------------------------------</span>
<span class="s0"># iddr_aid.f</span>
<span class="s0">#------------------------------------------------------------------------------</span>

<span class="s3">def </span><span class="s1">iddr_aid</span><span class="s4">(</span><span class="s1">A</span><span class="s4">, </span><span class="s1">k</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Compute ID of a real matrix to a specified rank using random sampling. 
 
    :param A: 
        Matrix. 
    :type A: :class:`numpy.ndarray` 
    :param k: 
        Rank of ID. 
    :type k: int 
 
    :return: 
        Column index array. 
    :rtype: :class:`numpy.ndarray` 
    :return: 
        Interpolation coefficients. 
    :rtype: :class:`numpy.ndarray` 
    &quot;&quot;&quot;</span>
    <span class="s1">A </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">asfortranarray</span><span class="s4">(</span><span class="s1">A</span><span class="s4">)</span>
    <span class="s1">m</span><span class="s4">, </span><span class="s1">n </span><span class="s4">= </span><span class="s1">A</span><span class="s4">.</span><span class="s1">shape</span>
    <span class="s1">w </span><span class="s4">= </span><span class="s1">iddr_aidi</span><span class="s4">(</span><span class="s1">m</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">k</span><span class="s4">)</span>
    <span class="s1">idx</span><span class="s4">, </span><span class="s1">proj </span><span class="s4">= </span><span class="s1">_id</span><span class="s4">.</span><span class="s1">iddr_aid</span><span class="s4">(</span><span class="s1">A</span><span class="s4">, </span><span class="s1">k</span><span class="s4">, </span><span class="s1">w</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">k </span><span class="s4">== </span><span class="s1">n</span><span class="s4">:</span>
        <span class="s1">proj </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">empty</span><span class="s4">((</span><span class="s1">k</span><span class="s4">, </span><span class="s1">n</span><span class="s4">-</span><span class="s1">k</span><span class="s4">), </span><span class="s1">dtype</span><span class="s4">=</span><span class="s5">'float64'</span><span class="s4">, </span><span class="s1">order</span><span class="s4">=</span><span class="s5">'F'</span><span class="s4">)</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">proj </span><span class="s4">= </span><span class="s1">proj</span><span class="s4">.</span><span class="s1">reshape</span><span class="s4">((</span><span class="s1">k</span><span class="s4">, </span><span class="s1">n</span><span class="s4">-</span><span class="s1">k</span><span class="s4">), </span><span class="s1">order</span><span class="s4">=</span><span class="s5">'F'</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s1">idx</span><span class="s4">, </span><span class="s1">proj</span>


<span class="s3">def </span><span class="s1">iddr_aidi</span><span class="s4">(</span><span class="s1">m</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">k</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Initialize array for :func:`iddr_aid`. 
 
    :param m: 
        Matrix row dimension. 
    :type m: int 
    :param n: 
        Matrix column dimension. 
    :type n: int 
    :param k: 
        Rank of ID. 
    :type k: int 
 
    :return: 
        Initialization array to be used by :func:`iddr_aid`. 
    :rtype: :class:`numpy.ndarray` 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">_id</span><span class="s4">.</span><span class="s1">iddr_aidi</span><span class="s4">(</span><span class="s1">m</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">k</span><span class="s4">)</span>


<span class="s0">#------------------------------------------------------------------------------</span>
<span class="s0"># iddr_asvd.f</span>
<span class="s0">#------------------------------------------------------------------------------</span>

<span class="s3">def </span><span class="s1">iddr_asvd</span><span class="s4">(</span><span class="s1">A</span><span class="s4">, </span><span class="s1">k</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Compute SVD of a real matrix to a specified rank using random sampling. 
 
    :param A: 
        Matrix. 
    :type A: :class:`numpy.ndarray` 
    :param k: 
        Rank of SVD. 
    :type k: int 
 
    :return: 
        Left singular vectors. 
    :rtype: :class:`numpy.ndarray` 
    :return: 
        Right singular vectors. 
    :rtype: :class:`numpy.ndarray` 
    :return: 
        Singular values. 
    :rtype: :class:`numpy.ndarray` 
    &quot;&quot;&quot;</span>
    <span class="s1">A </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">asfortranarray</span><span class="s4">(</span><span class="s1">A</span><span class="s4">)</span>
    <span class="s1">m</span><span class="s4">, </span><span class="s1">n </span><span class="s4">= </span><span class="s1">A</span><span class="s4">.</span><span class="s1">shape</span>
    <span class="s1">w </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">empty</span><span class="s4">((</span><span class="s6">2</span><span class="s4">*</span><span class="s1">k </span><span class="s4">+ </span><span class="s6">28</span><span class="s4">)*</span><span class="s1">m </span><span class="s4">+ (</span><span class="s6">6</span><span class="s4">*</span><span class="s1">k </span><span class="s4">+ </span><span class="s6">21</span><span class="s4">)*</span><span class="s1">n </span><span class="s4">+ </span><span class="s6">25</span><span class="s4">*</span><span class="s1">k</span><span class="s4">**</span><span class="s6">2 </span><span class="s4">+ </span><span class="s6">100</span><span class="s4">, </span><span class="s1">order</span><span class="s4">=</span><span class="s5">'F'</span><span class="s4">)</span>
    <span class="s1">w_ </span><span class="s4">= </span><span class="s1">iddr_aidi</span><span class="s4">(</span><span class="s1">m</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">k</span><span class="s4">)</span>
    <span class="s1">w</span><span class="s4">[:</span><span class="s1">w_</span><span class="s4">.</span><span class="s1">size</span><span class="s4">] = </span><span class="s1">w_</span>
    <span class="s1">U</span><span class="s4">, </span><span class="s1">V</span><span class="s4">, </span><span class="s1">S</span><span class="s4">, </span><span class="s1">ier </span><span class="s4">= </span><span class="s1">_id</span><span class="s4">.</span><span class="s1">iddr_asvd</span><span class="s4">(</span><span class="s1">A</span><span class="s4">, </span><span class="s1">k</span><span class="s4">, </span><span class="s1">w</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">ier </span><span class="s4">!= </span><span class="s6">0</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">_RETCODE_ERROR</span>
    <span class="s3">return </span><span class="s1">U</span><span class="s4">, </span><span class="s1">V</span><span class="s4">, </span><span class="s1">S</span>


<span class="s0">#------------------------------------------------------------------------------</span>
<span class="s0"># iddr_rid.f</span>
<span class="s0">#------------------------------------------------------------------------------</span>

<span class="s3">def </span><span class="s1">iddr_rid</span><span class="s4">(</span><span class="s1">m</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">matvect</span><span class="s4">, </span><span class="s1">k</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Compute ID of a real matrix to a specified rank using random matrix-vector 
    multiplication. 
 
    :param m: 
        Matrix row dimension. 
    :type m: int 
    :param n: 
        Matrix column dimension. 
    :type n: int 
    :param matvect: 
        Function to apply the matrix transpose to a vector, with call signature 
        `y = matvect(x)`, where `x` and `y` are the input and output vectors, 
        respectively. 
    :type matvect: function 
    :param k: 
        Rank of ID. 
    :type k: int 
 
    :return: 
        Column index array. 
    :rtype: :class:`numpy.ndarray` 
    :return: 
        Interpolation coefficients. 
    :rtype: :class:`numpy.ndarray` 
    &quot;&quot;&quot;</span>
    <span class="s1">idx</span><span class="s4">, </span><span class="s1">proj </span><span class="s4">= </span><span class="s1">_id</span><span class="s4">.</span><span class="s1">iddr_rid</span><span class="s4">(</span><span class="s1">m</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">matvect</span><span class="s4">, </span><span class="s1">k</span><span class="s4">)</span>
    <span class="s1">proj </span><span class="s4">= </span><span class="s1">proj</span><span class="s4">[:</span><span class="s1">k</span><span class="s4">*(</span><span class="s1">n</span><span class="s4">-</span><span class="s1">k</span><span class="s4">)].</span><span class="s1">reshape</span><span class="s4">((</span><span class="s1">k</span><span class="s4">, </span><span class="s1">n</span><span class="s4">-</span><span class="s1">k</span><span class="s4">), </span><span class="s1">order</span><span class="s4">=</span><span class="s5">'F'</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s1">idx</span><span class="s4">, </span><span class="s1">proj</span>


<span class="s0">#------------------------------------------------------------------------------</span>
<span class="s0"># iddr_rsvd.f</span>
<span class="s0">#------------------------------------------------------------------------------</span>

<span class="s3">def </span><span class="s1">iddr_rsvd</span><span class="s4">(</span><span class="s1">m</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">matvect</span><span class="s4">, </span><span class="s1">matvec</span><span class="s4">, </span><span class="s1">k</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Compute SVD of a real matrix to a specified rank using random matrix-vector 
    multiplication. 
 
    :param m: 
        Matrix row dimension. 
    :type m: int 
    :param n: 
        Matrix column dimension. 
    :type n: int 
    :param matvect: 
        Function to apply the matrix transpose to a vector, with call signature 
        `y = matvect(x)`, where `x` and `y` are the input and output vectors, 
        respectively. 
    :type matvect: function 
    :param matvec: 
        Function to apply the matrix to a vector, with call signature 
        `y = matvec(x)`, where `x` and `y` are the input and output vectors, 
        respectively. 
    :type matvec: function 
    :param k: 
        Rank of SVD. 
    :type k: int 
 
    :return: 
        Left singular vectors. 
    :rtype: :class:`numpy.ndarray` 
    :return: 
        Right singular vectors. 
    :rtype: :class:`numpy.ndarray` 
    :return: 
        Singular values. 
    :rtype: :class:`numpy.ndarray` 
    &quot;&quot;&quot;</span>
    <span class="s1">U</span><span class="s4">, </span><span class="s1">V</span><span class="s4">, </span><span class="s1">S</span><span class="s4">, </span><span class="s1">ier </span><span class="s4">= </span><span class="s1">_id</span><span class="s4">.</span><span class="s1">iddr_rsvd</span><span class="s4">(</span><span class="s1">m</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">matvect</span><span class="s4">, </span><span class="s1">matvec</span><span class="s4">, </span><span class="s1">k</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">ier </span><span class="s4">!= </span><span class="s6">0</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">_RETCODE_ERROR</span>
    <span class="s3">return </span><span class="s1">U</span><span class="s4">, </span><span class="s1">V</span><span class="s4">, </span><span class="s1">S</span>


<span class="s0">#------------------------------------------------------------------------------</span>
<span class="s0"># idz_frm.f</span>
<span class="s0">#------------------------------------------------------------------------------</span>

<span class="s3">def </span><span class="s1">idz_frm</span><span class="s4">(</span><span class="s1">n</span><span class="s4">, </span><span class="s1">w</span><span class="s4">, </span><span class="s1">x</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Transform complex vector via a composition of Rokhlin's random transform, 
    random subselection, and an FFT. 
 
    In contrast to :func:`idz_sfrm`, this routine works best when the length of 
    the transformed vector is the power-of-two integer output by 
    :func:`idz_frmi`, or when the length is not specified but instead 
    determined a posteriori from the output. The returned transformed vector is 
    randomly permuted. 
 
    :param n: 
        Greatest power-of-two integer satisfying `n &lt;= x.size` as obtained from 
        :func:`idz_frmi`; `n` is also the length of the output vector. 
    :type n: int 
    :param w: 
        Initialization array constructed by :func:`idz_frmi`. 
    :type w: :class:`numpy.ndarray` 
    :param x: 
        Vector to be transformed. 
    :type x: :class:`numpy.ndarray` 
 
    :return: 
        Transformed vector. 
    :rtype: :class:`numpy.ndarray` 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">_id</span><span class="s4">.</span><span class="s1">idz_frm</span><span class="s4">(</span><span class="s1">n</span><span class="s4">, </span><span class="s1">w</span><span class="s4">, </span><span class="s1">x</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">idz_sfrm</span><span class="s4">(</span><span class="s1">l</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">w</span><span class="s4">, </span><span class="s1">x</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Transform complex vector via a composition of Rokhlin's random transform, 
    random subselection, and an FFT. 
 
    In contrast to :func:`idz_frm`, this routine works best when the length of 
    the transformed vector is known a priori. 
 
    :param l: 
        Length of transformed vector, satisfying `l &lt;= n`. 
    :type l: int 
    :param n: 
        Greatest power-of-two integer satisfying `n &lt;= x.size` as obtained from 
        :func:`idz_sfrmi`. 
    :type n: int 
    :param w: 
        Initialization array constructed by :func:`idd_sfrmi`. 
    :type w: :class:`numpy.ndarray` 
    :param x: 
        Vector to be transformed. 
    :type x: :class:`numpy.ndarray` 
 
    :return: 
        Transformed vector. 
    :rtype: :class:`numpy.ndarray` 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">_id</span><span class="s4">.</span><span class="s1">idz_sfrm</span><span class="s4">(</span><span class="s1">l</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">w</span><span class="s4">, </span><span class="s1">x</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">idz_frmi</span><span class="s4">(</span><span class="s1">m</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Initialize data for :func:`idz_frm`. 
 
    :param m: 
        Length of vector to be transformed. 
    :type m: int 
 
    :return: 
        Greatest power-of-two integer `n` satisfying `n &lt;= m`. 
    :rtype: int 
    :return: 
        Initialization array to be used by :func:`idz_frm`. 
    :rtype: :class:`numpy.ndarray` 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">_id</span><span class="s4">.</span><span class="s1">idz_frmi</span><span class="s4">(</span><span class="s1">m</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">idz_sfrmi</span><span class="s4">(</span><span class="s1">l</span><span class="s4">, </span><span class="s1">m</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Initialize data for :func:`idz_sfrm`. 
 
    :param l: 
        Length of output transformed vector. 
    :type l: int 
    :param m: 
        Length of the vector to be transformed. 
    :type m: int 
 
    :return: 
        Greatest power-of-two integer `n` satisfying `n &lt;= m`. 
    :rtype: int 
    :return: 
        Initialization array to be used by :func:`idz_sfrm`. 
    :rtype: :class:`numpy.ndarray` 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">_id</span><span class="s4">.</span><span class="s1">idz_sfrmi</span><span class="s4">(</span><span class="s1">l</span><span class="s4">, </span><span class="s1">m</span><span class="s4">)</span>


<span class="s0">#------------------------------------------------------------------------------</span>
<span class="s0"># idz_id.f</span>
<span class="s0">#------------------------------------------------------------------------------</span>

<span class="s3">def </span><span class="s1">idzp_id</span><span class="s4">(</span><span class="s1">eps</span><span class="s4">, </span><span class="s1">A</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Compute ID of a complex matrix to a specified relative precision. 
 
    :param eps: 
        Relative precision. 
    :type eps: float 
    :param A: 
        Matrix. 
    :type A: :class:`numpy.ndarray` 
 
    :return: 
        Rank of ID. 
    :rtype: int 
    :return: 
        Column index array. 
    :rtype: :class:`numpy.ndarray` 
    :return: 
        Interpolation coefficients. 
    :rtype: :class:`numpy.ndarray` 
    &quot;&quot;&quot;</span>
    <span class="s1">A </span><span class="s4">= </span><span class="s1">_asfortranarray_copy</span><span class="s4">(</span><span class="s1">A</span><span class="s4">)</span>
    <span class="s1">k</span><span class="s4">, </span><span class="s1">idx</span><span class="s4">, </span><span class="s1">rnorms </span><span class="s4">= </span><span class="s1">_id</span><span class="s4">.</span><span class="s1">idzp_id</span><span class="s4">(</span><span class="s1">eps</span><span class="s4">, </span><span class="s1">A</span><span class="s4">)</span>
    <span class="s1">n </span><span class="s4">= </span><span class="s1">A</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">1</span><span class="s4">]</span>
    <span class="s1">proj </span><span class="s4">= </span><span class="s1">A</span><span class="s4">.</span><span class="s1">T</span><span class="s4">.</span><span class="s1">ravel</span><span class="s4">()[:</span><span class="s1">k</span><span class="s4">*(</span><span class="s1">n</span><span class="s4">-</span><span class="s1">k</span><span class="s4">)].</span><span class="s1">reshape</span><span class="s4">((</span><span class="s1">k</span><span class="s4">, </span><span class="s1">n</span><span class="s4">-</span><span class="s1">k</span><span class="s4">), </span><span class="s1">order</span><span class="s4">=</span><span class="s5">'F'</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s1">k</span><span class="s4">, </span><span class="s1">idx</span><span class="s4">, </span><span class="s1">proj</span>


<span class="s3">def </span><span class="s1">idzr_id</span><span class="s4">(</span><span class="s1">A</span><span class="s4">, </span><span class="s1">k</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Compute ID of a complex matrix to a specified rank. 
 
    :param A: 
        Matrix. 
    :type A: :class:`numpy.ndarray` 
    :param k: 
        Rank of ID. 
    :type k: int 
 
    :return: 
        Column index array. 
    :rtype: :class:`numpy.ndarray` 
    :return: 
        Interpolation coefficients. 
    :rtype: :class:`numpy.ndarray` 
    &quot;&quot;&quot;</span>
    <span class="s1">A </span><span class="s4">= </span><span class="s1">_asfortranarray_copy</span><span class="s4">(</span><span class="s1">A</span><span class="s4">)</span>
    <span class="s1">idx</span><span class="s4">, </span><span class="s1">rnorms </span><span class="s4">= </span><span class="s1">_id</span><span class="s4">.</span><span class="s1">idzr_id</span><span class="s4">(</span><span class="s1">A</span><span class="s4">, </span><span class="s1">k</span><span class="s4">)</span>
    <span class="s1">n </span><span class="s4">= </span><span class="s1">A</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">1</span><span class="s4">]</span>
    <span class="s1">proj </span><span class="s4">= </span><span class="s1">A</span><span class="s4">.</span><span class="s1">T</span><span class="s4">.</span><span class="s1">ravel</span><span class="s4">()[:</span><span class="s1">k</span><span class="s4">*(</span><span class="s1">n</span><span class="s4">-</span><span class="s1">k</span><span class="s4">)].</span><span class="s1">reshape</span><span class="s4">((</span><span class="s1">k</span><span class="s4">, </span><span class="s1">n</span><span class="s4">-</span><span class="s1">k</span><span class="s4">), </span><span class="s1">order</span><span class="s4">=</span><span class="s5">'F'</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s1">idx</span><span class="s4">, </span><span class="s1">proj</span>


<span class="s3">def </span><span class="s1">idz_reconid</span><span class="s4">(</span><span class="s1">B</span><span class="s4">, </span><span class="s1">idx</span><span class="s4">, </span><span class="s1">proj</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Reconstruct matrix from complex ID. 
 
    :param B: 
        Skeleton matrix. 
    :type B: :class:`numpy.ndarray` 
    :param idx: 
        Column index array. 
    :type idx: :class:`numpy.ndarray` 
    :param proj: 
        Interpolation coefficients. 
    :type proj: :class:`numpy.ndarray` 
 
    :return: 
        Reconstructed matrix. 
    :rtype: :class:`numpy.ndarray` 
    &quot;&quot;&quot;</span>
    <span class="s1">B </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">asfortranarray</span><span class="s4">(</span><span class="s1">B</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">proj</span><span class="s4">.</span><span class="s1">size </span><span class="s4">&gt; </span><span class="s6">0</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">_id</span><span class="s4">.</span><span class="s1">idz_reconid</span><span class="s4">(</span><span class="s1">B</span><span class="s4">, </span><span class="s1">idx</span><span class="s4">, </span><span class="s1">proj</span><span class="s4">)</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">B</span><span class="s4">[:, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">argsort</span><span class="s4">(</span><span class="s1">idx</span><span class="s4">)]</span>


<span class="s3">def </span><span class="s1">idz_reconint</span><span class="s4">(</span><span class="s1">idx</span><span class="s4">, </span><span class="s1">proj</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Reconstruct interpolation matrix from complex ID. 
 
    :param idx: 
        Column index array. 
    :type idx: :class:`numpy.ndarray` 
    :param proj: 
        Interpolation coefficients. 
    :type proj: :class:`numpy.ndarray` 
 
    :return: 
        Interpolation matrix. 
    :rtype: :class:`numpy.ndarray` 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">_id</span><span class="s4">.</span><span class="s1">idz_reconint</span><span class="s4">(</span><span class="s1">idx</span><span class="s4">, </span><span class="s1">proj</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">idz_copycols</span><span class="s4">(</span><span class="s1">A</span><span class="s4">, </span><span class="s1">k</span><span class="s4">, </span><span class="s1">idx</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Reconstruct skeleton matrix from complex ID. 
 
    :param A: 
        Original matrix. 
    :type A: :class:`numpy.ndarray` 
    :param k: 
        Rank of ID. 
    :type k: int 
    :param idx: 
        Column index array. 
    :type idx: :class:`numpy.ndarray` 
 
    :return: 
        Skeleton matrix. 
    :rtype: :class:`numpy.ndarray` 
    &quot;&quot;&quot;</span>
    <span class="s1">A </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">asfortranarray</span><span class="s4">(</span><span class="s1">A</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s1">_id</span><span class="s4">.</span><span class="s1">idz_copycols</span><span class="s4">(</span><span class="s1">A</span><span class="s4">, </span><span class="s1">k</span><span class="s4">, </span><span class="s1">idx</span><span class="s4">)</span>


<span class="s0">#------------------------------------------------------------------------------</span>
<span class="s0"># idz_id2svd.f</span>
<span class="s0">#------------------------------------------------------------------------------</span>

<span class="s3">def </span><span class="s1">idz_id2svd</span><span class="s4">(</span><span class="s1">B</span><span class="s4">, </span><span class="s1">idx</span><span class="s4">, </span><span class="s1">proj</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Convert complex ID to SVD. 
 
    :param B: 
        Skeleton matrix. 
    :type B: :class:`numpy.ndarray` 
    :param idx: 
        Column index array. 
    :type idx: :class:`numpy.ndarray` 
    :param proj: 
        Interpolation coefficients. 
    :type proj: :class:`numpy.ndarray` 
 
    :return: 
        Left singular vectors. 
    :rtype: :class:`numpy.ndarray` 
    :return: 
        Right singular vectors. 
    :rtype: :class:`numpy.ndarray` 
    :return: 
        Singular values. 
    :rtype: :class:`numpy.ndarray` 
    &quot;&quot;&quot;</span>
    <span class="s1">B </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">asfortranarray</span><span class="s4">(</span><span class="s1">B</span><span class="s4">)</span>
    <span class="s1">U</span><span class="s4">, </span><span class="s1">V</span><span class="s4">, </span><span class="s1">S</span><span class="s4">, </span><span class="s1">ier </span><span class="s4">= </span><span class="s1">_id</span><span class="s4">.</span><span class="s1">idz_id2svd</span><span class="s4">(</span><span class="s1">B</span><span class="s4">, </span><span class="s1">idx</span><span class="s4">, </span><span class="s1">proj</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">ier</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">_RETCODE_ERROR</span>
    <span class="s3">return </span><span class="s1">U</span><span class="s4">, </span><span class="s1">V</span><span class="s4">, </span><span class="s1">S</span>


<span class="s0">#------------------------------------------------------------------------------</span>
<span class="s0"># idz_snorm.f</span>
<span class="s0">#------------------------------------------------------------------------------</span>

<span class="s3">def </span><span class="s1">idz_snorm</span><span class="s4">(</span><span class="s1">m</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">matveca</span><span class="s4">, </span><span class="s1">matvec</span><span class="s4">, </span><span class="s1">its</span><span class="s4">=</span><span class="s6">20</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Estimate spectral norm of a complex matrix by the randomized power method. 
 
    :param m: 
        Matrix row dimension. 
    :type m: int 
    :param n: 
        Matrix column dimension. 
    :type n: int 
    :param matveca: 
        Function to apply the matrix adjoint to a vector, with call signature 
        `y = matveca(x)`, where `x` and `y` are the input and output vectors, 
        respectively. 
    :type matveca: function 
    :param matvec: 
        Function to apply the matrix to a vector, with call signature 
        `y = matvec(x)`, where `x` and `y` are the input and output vectors, 
        respectively. 
    :type matvec: function 
    :param its: 
        Number of power method iterations. 
    :type its: int 
 
    :return: 
        Spectral norm estimate. 
    :rtype: float 
    &quot;&quot;&quot;</span>
    <span class="s1">snorm</span><span class="s4">, </span><span class="s1">v </span><span class="s4">= </span><span class="s1">_id</span><span class="s4">.</span><span class="s1">idz_snorm</span><span class="s4">(</span><span class="s1">m</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">matveca</span><span class="s4">, </span><span class="s1">matvec</span><span class="s4">, </span><span class="s1">its</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s1">snorm</span>


<span class="s3">def </span><span class="s1">idz_diffsnorm</span><span class="s4">(</span><span class="s1">m</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">matveca</span><span class="s4">, </span><span class="s1">matveca2</span><span class="s4">, </span><span class="s1">matvec</span><span class="s4">, </span><span class="s1">matvec2</span><span class="s4">, </span><span class="s1">its</span><span class="s4">=</span><span class="s6">20</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Estimate spectral norm of the difference of two complex matrices by the 
    randomized power method. 
 
    :param m: 
        Matrix row dimension. 
    :type m: int 
    :param n: 
        Matrix column dimension. 
    :type n: int 
    :param matveca: 
        Function to apply the adjoint of the first matrix to a vector, with 
        call signature `y = matveca(x)`, where `x` and `y` are the input and 
        output vectors, respectively. 
    :type matveca: function 
    :param matveca2: 
        Function to apply the adjoint of the second matrix to a vector, with 
        call signature `y = matveca2(x)`, where `x` and `y` are the input and 
        output vectors, respectively. 
    :type matveca2: function 
    :param matvec: 
        Function to apply the first matrix to a vector, with call signature 
        `y = matvec(x)`, where `x` and `y` are the input and output vectors, 
        respectively. 
    :type matvec: function 
    :param matvec2: 
        Function to apply the second matrix to a vector, with call signature 
        `y = matvec2(x)`, where `x` and `y` are the input and output vectors, 
        respectively. 
    :type matvec2: function 
    :param its: 
        Number of power method iterations. 
    :type its: int 
 
    :return: 
        Spectral norm estimate of matrix difference. 
    :rtype: float 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">_id</span><span class="s4">.</span><span class="s1">idz_diffsnorm</span><span class="s4">(</span><span class="s1">m</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">matveca</span><span class="s4">, </span><span class="s1">matveca2</span><span class="s4">, </span><span class="s1">matvec</span><span class="s4">, </span><span class="s1">matvec2</span><span class="s4">, </span><span class="s1">its</span><span class="s4">)</span>


<span class="s0">#------------------------------------------------------------------------------</span>
<span class="s0"># idz_svd.f</span>
<span class="s0">#------------------------------------------------------------------------------</span>

<span class="s3">def </span><span class="s1">idzr_svd</span><span class="s4">(</span><span class="s1">A</span><span class="s4">, </span><span class="s1">k</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Compute SVD of a complex matrix to a specified rank. 
 
    :param A: 
        Matrix. 
    :type A: :class:`numpy.ndarray` 
    :param k: 
        Rank of SVD. 
    :type k: int 
 
    :return: 
        Left singular vectors. 
    :rtype: :class:`numpy.ndarray` 
    :return: 
        Right singular vectors. 
    :rtype: :class:`numpy.ndarray` 
    :return: 
        Singular values. 
    :rtype: :class:`numpy.ndarray` 
    &quot;&quot;&quot;</span>
    <span class="s1">A </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">asfortranarray</span><span class="s4">(</span><span class="s1">A</span><span class="s4">)</span>
    <span class="s1">U</span><span class="s4">, </span><span class="s1">V</span><span class="s4">, </span><span class="s1">S</span><span class="s4">, </span><span class="s1">ier </span><span class="s4">= </span><span class="s1">_id</span><span class="s4">.</span><span class="s1">idzr_svd</span><span class="s4">(</span><span class="s1">A</span><span class="s4">, </span><span class="s1">k</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">ier</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">_RETCODE_ERROR</span>
    <span class="s3">return </span><span class="s1">U</span><span class="s4">, </span><span class="s1">V</span><span class="s4">, </span><span class="s1">S</span>


<span class="s3">def </span><span class="s1">idzp_svd</span><span class="s4">(</span><span class="s1">eps</span><span class="s4">, </span><span class="s1">A</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Compute SVD of a complex matrix to a specified relative precision. 
 
    :param eps: 
        Relative precision. 
    :type eps: float 
    :param A: 
        Matrix. 
    :type A: :class:`numpy.ndarray` 
 
    :return: 
        Left singular vectors. 
    :rtype: :class:`numpy.ndarray` 
    :return: 
        Right singular vectors. 
    :rtype: :class:`numpy.ndarray` 
    :return: 
        Singular values. 
    :rtype: :class:`numpy.ndarray` 
    &quot;&quot;&quot;</span>
    <span class="s1">A </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">asfortranarray</span><span class="s4">(</span><span class="s1">A</span><span class="s4">)</span>
    <span class="s1">m</span><span class="s4">, </span><span class="s1">n </span><span class="s4">= </span><span class="s1">A</span><span class="s4">.</span><span class="s1">shape</span>
    <span class="s1">k</span><span class="s4">, </span><span class="s1">iU</span><span class="s4">, </span><span class="s1">iV</span><span class="s4">, </span><span class="s1">iS</span><span class="s4">, </span><span class="s1">w</span><span class="s4">, </span><span class="s1">ier </span><span class="s4">= </span><span class="s1">_id</span><span class="s4">.</span><span class="s1">idzp_svd</span><span class="s4">(</span><span class="s1">eps</span><span class="s4">, </span><span class="s1">A</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">ier</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">_RETCODE_ERROR</span>
    <span class="s1">U </span><span class="s4">= </span><span class="s1">w</span><span class="s4">[</span><span class="s1">iU</span><span class="s4">-</span><span class="s6">1</span><span class="s4">:</span><span class="s1">iU</span><span class="s4">+</span><span class="s1">m</span><span class="s4">*</span><span class="s1">k</span><span class="s4">-</span><span class="s6">1</span><span class="s4">].</span><span class="s1">reshape</span><span class="s4">((</span><span class="s1">m</span><span class="s4">, </span><span class="s1">k</span><span class="s4">), </span><span class="s1">order</span><span class="s4">=</span><span class="s5">'F'</span><span class="s4">)</span>
    <span class="s1">V </span><span class="s4">= </span><span class="s1">w</span><span class="s4">[</span><span class="s1">iV</span><span class="s4">-</span><span class="s6">1</span><span class="s4">:</span><span class="s1">iV</span><span class="s4">+</span><span class="s1">n</span><span class="s4">*</span><span class="s1">k</span><span class="s4">-</span><span class="s6">1</span><span class="s4">].</span><span class="s1">reshape</span><span class="s4">((</span><span class="s1">n</span><span class="s4">, </span><span class="s1">k</span><span class="s4">), </span><span class="s1">order</span><span class="s4">=</span><span class="s5">'F'</span><span class="s4">)</span>
    <span class="s1">S </span><span class="s4">= </span><span class="s1">w</span><span class="s4">[</span><span class="s1">iS</span><span class="s4">-</span><span class="s6">1</span><span class="s4">:</span><span class="s1">iS</span><span class="s4">+</span><span class="s1">k</span><span class="s4">-</span><span class="s6">1</span><span class="s4">]</span>
    <span class="s3">return </span><span class="s1">U</span><span class="s4">, </span><span class="s1">V</span><span class="s4">, </span><span class="s1">S</span>


<span class="s0">#------------------------------------------------------------------------------</span>
<span class="s0"># idzp_aid.f</span>
<span class="s0">#------------------------------------------------------------------------------</span>

<span class="s3">def </span><span class="s1">idzp_aid</span><span class="s4">(</span><span class="s1">eps</span><span class="s4">, </span><span class="s1">A</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Compute ID of a complex matrix to a specified relative precision using 
    random sampling. 
 
    :param eps: 
        Relative precision. 
    :type eps: float 
    :param A: 
        Matrix. 
    :type A: :class:`numpy.ndarray` 
 
    :return: 
        Rank of ID. 
    :rtype: int 
    :return: 
        Column index array. 
    :rtype: :class:`numpy.ndarray` 
    :return: 
        Interpolation coefficients. 
    :rtype: :class:`numpy.ndarray` 
    &quot;&quot;&quot;</span>
    <span class="s1">A </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">asfortranarray</span><span class="s4">(</span><span class="s1">A</span><span class="s4">)</span>
    <span class="s1">m</span><span class="s4">, </span><span class="s1">n </span><span class="s4">= </span><span class="s1">A</span><span class="s4">.</span><span class="s1">shape</span>
    <span class="s1">n2</span><span class="s4">, </span><span class="s1">w </span><span class="s4">= </span><span class="s1">idz_frmi</span><span class="s4">(</span><span class="s1">m</span><span class="s4">)</span>
    <span class="s1">proj </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">empty</span><span class="s4">(</span><span class="s1">n</span><span class="s4">*(</span><span class="s6">2</span><span class="s4">*</span><span class="s1">n2 </span><span class="s4">+ </span><span class="s6">1</span><span class="s4">) + </span><span class="s1">n2 </span><span class="s4">+ </span><span class="s6">1</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s5">'complex128'</span><span class="s4">, </span><span class="s1">order</span><span class="s4">=</span><span class="s5">'F'</span><span class="s4">)</span>
    <span class="s1">k</span><span class="s4">, </span><span class="s1">idx</span><span class="s4">, </span><span class="s1">proj </span><span class="s4">= </span><span class="s1">_id</span><span class="s4">.</span><span class="s1">idzp_aid</span><span class="s4">(</span><span class="s1">eps</span><span class="s4">, </span><span class="s1">A</span><span class="s4">, </span><span class="s1">w</span><span class="s4">, </span><span class="s1">proj</span><span class="s4">)</span>
    <span class="s1">proj </span><span class="s4">= </span><span class="s1">proj</span><span class="s4">[:</span><span class="s1">k</span><span class="s4">*(</span><span class="s1">n</span><span class="s4">-</span><span class="s1">k</span><span class="s4">)].</span><span class="s1">reshape</span><span class="s4">((</span><span class="s1">k</span><span class="s4">, </span><span class="s1">n</span><span class="s4">-</span><span class="s1">k</span><span class="s4">), </span><span class="s1">order</span><span class="s4">=</span><span class="s5">'F'</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s1">k</span><span class="s4">, </span><span class="s1">idx</span><span class="s4">, </span><span class="s1">proj</span>


<span class="s3">def </span><span class="s1">idz_estrank</span><span class="s4">(</span><span class="s1">eps</span><span class="s4">, </span><span class="s1">A</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Estimate rank of a complex matrix to a specified relative precision using 
    random sampling. 
 
    The output rank is typically about 8 higher than the actual rank. 
 
    :param eps: 
        Relative precision. 
    :type eps: float 
    :param A: 
        Matrix. 
    :type A: :class:`numpy.ndarray` 
 
    :return: 
        Rank estimate. 
    :rtype: int 
    &quot;&quot;&quot;</span>
    <span class="s1">A </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">asfortranarray</span><span class="s4">(</span><span class="s1">A</span><span class="s4">)</span>
    <span class="s1">m</span><span class="s4">, </span><span class="s1">n </span><span class="s4">= </span><span class="s1">A</span><span class="s4">.</span><span class="s1">shape</span>
    <span class="s1">n2</span><span class="s4">, </span><span class="s1">w </span><span class="s4">= </span><span class="s1">idz_frmi</span><span class="s4">(</span><span class="s1">m</span><span class="s4">)</span>
    <span class="s1">ra </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">empty</span><span class="s4">(</span><span class="s1">n</span><span class="s4">*</span><span class="s1">n2 </span><span class="s4">+ (</span><span class="s1">n </span><span class="s4">+ </span><span class="s6">1</span><span class="s4">)*(</span><span class="s1">n2 </span><span class="s4">+ </span><span class="s6">1</span><span class="s4">), </span><span class="s1">dtype</span><span class="s4">=</span><span class="s5">'complex128'</span><span class="s4">, </span><span class="s1">order</span><span class="s4">=</span><span class="s5">'F'</span><span class="s4">)</span>
    <span class="s1">k</span><span class="s4">, </span><span class="s1">ra </span><span class="s4">= </span><span class="s1">_id</span><span class="s4">.</span><span class="s1">idz_estrank</span><span class="s4">(</span><span class="s1">eps</span><span class="s4">, </span><span class="s1">A</span><span class="s4">, </span><span class="s1">w</span><span class="s4">, </span><span class="s1">ra</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s1">k</span>


<span class="s0">#------------------------------------------------------------------------------</span>
<span class="s0"># idzp_asvd.f</span>
<span class="s0">#------------------------------------------------------------------------------</span>

<span class="s3">def </span><span class="s1">idzp_asvd</span><span class="s4">(</span><span class="s1">eps</span><span class="s4">, </span><span class="s1">A</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Compute SVD of a complex matrix to a specified relative precision using 
    random sampling. 
 
    :param eps: 
        Relative precision. 
    :type eps: float 
    :param A: 
        Matrix. 
    :type A: :class:`numpy.ndarray` 
 
    :return: 
        Left singular vectors. 
    :rtype: :class:`numpy.ndarray` 
    :return: 
        Right singular vectors. 
    :rtype: :class:`numpy.ndarray` 
    :return: 
        Singular values. 
    :rtype: :class:`numpy.ndarray` 
    &quot;&quot;&quot;</span>
    <span class="s1">A </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">asfortranarray</span><span class="s4">(</span><span class="s1">A</span><span class="s4">)</span>
    <span class="s1">m</span><span class="s4">, </span><span class="s1">n </span><span class="s4">= </span><span class="s1">A</span><span class="s4">.</span><span class="s1">shape</span>
    <span class="s1">n2</span><span class="s4">, </span><span class="s1">winit </span><span class="s4">= </span><span class="s1">_id</span><span class="s4">.</span><span class="s1">idz_frmi</span><span class="s4">(</span><span class="s1">m</span><span class="s4">)</span>
    <span class="s1">w </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">empty</span><span class="s4">(</span>
        <span class="s1">max</span><span class="s4">((</span><span class="s1">min</span><span class="s4">(</span><span class="s1">m</span><span class="s4">, </span><span class="s1">n</span><span class="s4">) + </span><span class="s6">1</span><span class="s4">)*(</span><span class="s6">3</span><span class="s4">*</span><span class="s1">m </span><span class="s4">+ </span><span class="s6">5</span><span class="s4">*</span><span class="s1">n </span><span class="s4">+ </span><span class="s6">11</span><span class="s4">) + </span><span class="s6">8</span><span class="s4">*</span><span class="s1">min</span><span class="s4">(</span><span class="s1">m</span><span class="s4">, </span><span class="s1">n</span><span class="s4">)**</span><span class="s6">2</span><span class="s4">,</span>
            <span class="s4">(</span><span class="s6">2</span><span class="s4">*</span><span class="s1">n </span><span class="s4">+ </span><span class="s6">1</span><span class="s4">)*(</span><span class="s1">n2 </span><span class="s4">+ </span><span class="s6">1</span><span class="s4">)),</span>
        <span class="s1">dtype</span><span class="s4">=</span><span class="s1">np</span><span class="s4">.</span><span class="s1">complex128</span><span class="s4">, </span><span class="s1">order</span><span class="s4">=</span><span class="s5">'F'</span><span class="s4">)</span>
    <span class="s1">k</span><span class="s4">, </span><span class="s1">iU</span><span class="s4">, </span><span class="s1">iV</span><span class="s4">, </span><span class="s1">iS</span><span class="s4">, </span><span class="s1">w</span><span class="s4">, </span><span class="s1">ier </span><span class="s4">= </span><span class="s1">_id</span><span class="s4">.</span><span class="s1">idzp_asvd</span><span class="s4">(</span><span class="s1">eps</span><span class="s4">, </span><span class="s1">A</span><span class="s4">, </span><span class="s1">winit</span><span class="s4">, </span><span class="s1">w</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">ier</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">_RETCODE_ERROR</span>
    <span class="s1">U </span><span class="s4">= </span><span class="s1">w</span><span class="s4">[</span><span class="s1">iU</span><span class="s4">-</span><span class="s6">1</span><span class="s4">:</span><span class="s1">iU</span><span class="s4">+</span><span class="s1">m</span><span class="s4">*</span><span class="s1">k</span><span class="s4">-</span><span class="s6">1</span><span class="s4">].</span><span class="s1">reshape</span><span class="s4">((</span><span class="s1">m</span><span class="s4">, </span><span class="s1">k</span><span class="s4">), </span><span class="s1">order</span><span class="s4">=</span><span class="s5">'F'</span><span class="s4">)</span>
    <span class="s1">V </span><span class="s4">= </span><span class="s1">w</span><span class="s4">[</span><span class="s1">iV</span><span class="s4">-</span><span class="s6">1</span><span class="s4">:</span><span class="s1">iV</span><span class="s4">+</span><span class="s1">n</span><span class="s4">*</span><span class="s1">k</span><span class="s4">-</span><span class="s6">1</span><span class="s4">].</span><span class="s1">reshape</span><span class="s4">((</span><span class="s1">n</span><span class="s4">, </span><span class="s1">k</span><span class="s4">), </span><span class="s1">order</span><span class="s4">=</span><span class="s5">'F'</span><span class="s4">)</span>
    <span class="s1">S </span><span class="s4">= </span><span class="s1">w</span><span class="s4">[</span><span class="s1">iS</span><span class="s4">-</span><span class="s6">1</span><span class="s4">:</span><span class="s1">iS</span><span class="s4">+</span><span class="s1">k</span><span class="s4">-</span><span class="s6">1</span><span class="s4">]</span>
    <span class="s3">return </span><span class="s1">U</span><span class="s4">, </span><span class="s1">V</span><span class="s4">, </span><span class="s1">S</span>


<span class="s0">#------------------------------------------------------------------------------</span>
<span class="s0"># idzp_rid.f</span>
<span class="s0">#------------------------------------------------------------------------------</span>

<span class="s3">def </span><span class="s1">idzp_rid</span><span class="s4">(</span><span class="s1">eps</span><span class="s4">, </span><span class="s1">m</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">matveca</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Compute ID of a complex matrix to a specified relative precision using 
    random matrix-vector multiplication. 
 
    :param eps: 
        Relative precision. 
    :type eps: float 
    :param m: 
        Matrix row dimension. 
    :type m: int 
    :param n: 
        Matrix column dimension. 
    :type n: int 
    :param matveca: 
        Function to apply the matrix adjoint to a vector, with call signature 
        `y = matveca(x)`, where `x` and `y` are the input and output vectors, 
        respectively. 
    :type matveca: function 
 
    :return: 
        Rank of ID. 
    :rtype: int 
    :return: 
        Column index array. 
    :rtype: :class:`numpy.ndarray` 
    :return: 
        Interpolation coefficients. 
    :rtype: :class:`numpy.ndarray` 
    &quot;&quot;&quot;</span>
    <span class="s1">proj </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">empty</span><span class="s4">(</span>
        <span class="s1">m </span><span class="s4">+ </span><span class="s6">1 </span><span class="s4">+ </span><span class="s6">2</span><span class="s4">*</span><span class="s1">n</span><span class="s4">*(</span><span class="s1">min</span><span class="s4">(</span><span class="s1">m</span><span class="s4">, </span><span class="s1">n</span><span class="s4">) + </span><span class="s6">1</span><span class="s4">),</span>
        <span class="s1">dtype</span><span class="s4">=</span><span class="s1">np</span><span class="s4">.</span><span class="s1">complex128</span><span class="s4">, </span><span class="s1">order</span><span class="s4">=</span><span class="s5">'F'</span><span class="s4">)</span>
    <span class="s1">k</span><span class="s4">, </span><span class="s1">idx</span><span class="s4">, </span><span class="s1">proj</span><span class="s4">, </span><span class="s1">ier </span><span class="s4">= </span><span class="s1">_id</span><span class="s4">.</span><span class="s1">idzp_rid</span><span class="s4">(</span><span class="s1">eps</span><span class="s4">, </span><span class="s1">m</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">matveca</span><span class="s4">, </span><span class="s1">proj</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">ier</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">_RETCODE_ERROR</span>
    <span class="s1">proj </span><span class="s4">= </span><span class="s1">proj</span><span class="s4">[:</span><span class="s1">k</span><span class="s4">*(</span><span class="s1">n</span><span class="s4">-</span><span class="s1">k</span><span class="s4">)].</span><span class="s1">reshape</span><span class="s4">((</span><span class="s1">k</span><span class="s4">, </span><span class="s1">n</span><span class="s4">-</span><span class="s1">k</span><span class="s4">), </span><span class="s1">order</span><span class="s4">=</span><span class="s5">'F'</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s1">k</span><span class="s4">, </span><span class="s1">idx</span><span class="s4">, </span><span class="s1">proj</span>


<span class="s3">def </span><span class="s1">idz_findrank</span><span class="s4">(</span><span class="s1">eps</span><span class="s4">, </span><span class="s1">m</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">matveca</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Estimate rank of a complex matrix to a specified relative precision using 
    random matrix-vector multiplication. 
 
    :param eps: 
        Relative precision. 
    :type eps: float 
    :param m: 
        Matrix row dimension. 
    :type m: int 
    :param n: 
        Matrix column dimension. 
    :type n: int 
    :param matveca: 
        Function to apply the matrix adjoint to a vector, with call signature 
        `y = matveca(x)`, where `x` and `y` are the input and output vectors, 
        respectively. 
    :type matveca: function 
 
    :return: 
        Rank estimate. 
    :rtype: int 
    &quot;&quot;&quot;</span>
    <span class="s1">k</span><span class="s4">, </span><span class="s1">ra</span><span class="s4">, </span><span class="s1">ier </span><span class="s4">= </span><span class="s1">_id</span><span class="s4">.</span><span class="s1">idz_findrank</span><span class="s4">(</span><span class="s1">eps</span><span class="s4">, </span><span class="s1">m</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">matveca</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">ier</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">_RETCODE_ERROR</span>
    <span class="s3">return </span><span class="s1">k</span>


<span class="s0">#------------------------------------------------------------------------------</span>
<span class="s0"># idzp_rsvd.f</span>
<span class="s0">#------------------------------------------------------------------------------</span>

<span class="s3">def </span><span class="s1">idzp_rsvd</span><span class="s4">(</span><span class="s1">eps</span><span class="s4">, </span><span class="s1">m</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">matveca</span><span class="s4">, </span><span class="s1">matvec</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Compute SVD of a complex matrix to a specified relative precision using 
    random matrix-vector multiplication. 
 
    :param eps: 
        Relative precision. 
    :type eps: float 
    :param m: 
        Matrix row dimension. 
    :type m: int 
    :param n: 
        Matrix column dimension. 
    :type n: int 
    :param matveca: 
        Function to apply the matrix adjoint to a vector, with call signature 
        `y = matveca(x)`, where `x` and `y` are the input and output vectors, 
        respectively. 
    :type matveca: function 
    :param matvec: 
        Function to apply the matrix to a vector, with call signature 
        `y = matvec(x)`, where `x` and `y` are the input and output vectors, 
        respectively. 
    :type matvec: function 
 
    :return: 
        Left singular vectors. 
    :rtype: :class:`numpy.ndarray` 
    :return: 
        Right singular vectors. 
    :rtype: :class:`numpy.ndarray` 
    :return: 
        Singular values. 
    :rtype: :class:`numpy.ndarray` 
    &quot;&quot;&quot;</span>
    <span class="s1">k</span><span class="s4">, </span><span class="s1">iU</span><span class="s4">, </span><span class="s1">iV</span><span class="s4">, </span><span class="s1">iS</span><span class="s4">, </span><span class="s1">w</span><span class="s4">, </span><span class="s1">ier </span><span class="s4">= </span><span class="s1">_id</span><span class="s4">.</span><span class="s1">idzp_rsvd</span><span class="s4">(</span><span class="s1">eps</span><span class="s4">, </span><span class="s1">m</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">matveca</span><span class="s4">, </span><span class="s1">matvec</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">ier</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">_RETCODE_ERROR</span>
    <span class="s1">U </span><span class="s4">= </span><span class="s1">w</span><span class="s4">[</span><span class="s1">iU</span><span class="s4">-</span><span class="s6">1</span><span class="s4">:</span><span class="s1">iU</span><span class="s4">+</span><span class="s1">m</span><span class="s4">*</span><span class="s1">k</span><span class="s4">-</span><span class="s6">1</span><span class="s4">].</span><span class="s1">reshape</span><span class="s4">((</span><span class="s1">m</span><span class="s4">, </span><span class="s1">k</span><span class="s4">), </span><span class="s1">order</span><span class="s4">=</span><span class="s5">'F'</span><span class="s4">)</span>
    <span class="s1">V </span><span class="s4">= </span><span class="s1">w</span><span class="s4">[</span><span class="s1">iV</span><span class="s4">-</span><span class="s6">1</span><span class="s4">:</span><span class="s1">iV</span><span class="s4">+</span><span class="s1">n</span><span class="s4">*</span><span class="s1">k</span><span class="s4">-</span><span class="s6">1</span><span class="s4">].</span><span class="s1">reshape</span><span class="s4">((</span><span class="s1">n</span><span class="s4">, </span><span class="s1">k</span><span class="s4">), </span><span class="s1">order</span><span class="s4">=</span><span class="s5">'F'</span><span class="s4">)</span>
    <span class="s1">S </span><span class="s4">= </span><span class="s1">w</span><span class="s4">[</span><span class="s1">iS</span><span class="s4">-</span><span class="s6">1</span><span class="s4">:</span><span class="s1">iS</span><span class="s4">+</span><span class="s1">k</span><span class="s4">-</span><span class="s6">1</span><span class="s4">]</span>
    <span class="s3">return </span><span class="s1">U</span><span class="s4">, </span><span class="s1">V</span><span class="s4">, </span><span class="s1">S</span>


<span class="s0">#------------------------------------------------------------------------------</span>
<span class="s0"># idzr_aid.f</span>
<span class="s0">#------------------------------------------------------------------------------</span>

<span class="s3">def </span><span class="s1">idzr_aid</span><span class="s4">(</span><span class="s1">A</span><span class="s4">, </span><span class="s1">k</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Compute ID of a complex matrix to a specified rank using random sampling. 
 
    :param A: 
        Matrix. 
    :type A: :class:`numpy.ndarray` 
    :param k: 
        Rank of ID. 
    :type k: int 
 
    :return: 
        Column index array. 
    :rtype: :class:`numpy.ndarray` 
    :return: 
        Interpolation coefficients. 
    :rtype: :class:`numpy.ndarray` 
    &quot;&quot;&quot;</span>
    <span class="s1">A </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">asfortranarray</span><span class="s4">(</span><span class="s1">A</span><span class="s4">)</span>
    <span class="s1">m</span><span class="s4">, </span><span class="s1">n </span><span class="s4">= </span><span class="s1">A</span><span class="s4">.</span><span class="s1">shape</span>
    <span class="s1">w </span><span class="s4">= </span><span class="s1">idzr_aidi</span><span class="s4">(</span><span class="s1">m</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">k</span><span class="s4">)</span>
    <span class="s1">idx</span><span class="s4">, </span><span class="s1">proj </span><span class="s4">= </span><span class="s1">_id</span><span class="s4">.</span><span class="s1">idzr_aid</span><span class="s4">(</span><span class="s1">A</span><span class="s4">, </span><span class="s1">k</span><span class="s4">, </span><span class="s1">w</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">k </span><span class="s4">== </span><span class="s1">n</span><span class="s4">:</span>
        <span class="s1">proj </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">empty</span><span class="s4">((</span><span class="s1">k</span><span class="s4">, </span><span class="s1">n</span><span class="s4">-</span><span class="s1">k</span><span class="s4">), </span><span class="s1">dtype</span><span class="s4">=</span><span class="s5">'complex128'</span><span class="s4">, </span><span class="s1">order</span><span class="s4">=</span><span class="s5">'F'</span><span class="s4">)</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">proj </span><span class="s4">= </span><span class="s1">proj</span><span class="s4">.</span><span class="s1">reshape</span><span class="s4">((</span><span class="s1">k</span><span class="s4">, </span><span class="s1">n</span><span class="s4">-</span><span class="s1">k</span><span class="s4">), </span><span class="s1">order</span><span class="s4">=</span><span class="s5">'F'</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s1">idx</span><span class="s4">, </span><span class="s1">proj</span>


<span class="s3">def </span><span class="s1">idzr_aidi</span><span class="s4">(</span><span class="s1">m</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">k</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Initialize array for :func:`idzr_aid`. 
 
    :param m: 
        Matrix row dimension. 
    :type m: int 
    :param n: 
        Matrix column dimension. 
    :type n: int 
    :param k: 
        Rank of ID. 
    :type k: int 
 
    :return: 
        Initialization array to be used by :func:`idzr_aid`. 
    :rtype: :class:`numpy.ndarray` 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">_id</span><span class="s4">.</span><span class="s1">idzr_aidi</span><span class="s4">(</span><span class="s1">m</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">k</span><span class="s4">)</span>


<span class="s0">#------------------------------------------------------------------------------</span>
<span class="s0"># idzr_asvd.f</span>
<span class="s0">#------------------------------------------------------------------------------</span>

<span class="s3">def </span><span class="s1">idzr_asvd</span><span class="s4">(</span><span class="s1">A</span><span class="s4">, </span><span class="s1">k</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Compute SVD of a complex matrix to a specified rank using random sampling. 
 
    :param A: 
        Matrix. 
    :type A: :class:`numpy.ndarray` 
    :param k: 
        Rank of SVD. 
    :type k: int 
 
    :return: 
        Left singular vectors. 
    :rtype: :class:`numpy.ndarray` 
    :return: 
        Right singular vectors. 
    :rtype: :class:`numpy.ndarray` 
    :return: 
        Singular values. 
    :rtype: :class:`numpy.ndarray` 
    &quot;&quot;&quot;</span>
    <span class="s1">A </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">asfortranarray</span><span class="s4">(</span><span class="s1">A</span><span class="s4">)</span>
    <span class="s1">m</span><span class="s4">, </span><span class="s1">n </span><span class="s4">= </span><span class="s1">A</span><span class="s4">.</span><span class="s1">shape</span>
    <span class="s1">w </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">empty</span><span class="s4">(</span>
        <span class="s4">(</span><span class="s6">2</span><span class="s4">*</span><span class="s1">k </span><span class="s4">+ </span><span class="s6">22</span><span class="s4">)*</span><span class="s1">m </span><span class="s4">+ (</span><span class="s6">6</span><span class="s4">*</span><span class="s1">k </span><span class="s4">+ </span><span class="s6">21</span><span class="s4">)*</span><span class="s1">n </span><span class="s4">+ </span><span class="s6">8</span><span class="s4">*</span><span class="s1">k</span><span class="s4">**</span><span class="s6">2 </span><span class="s4">+ </span><span class="s6">10</span><span class="s4">*</span><span class="s1">k </span><span class="s4">+ </span><span class="s6">90</span><span class="s4">,</span>
        <span class="s1">dtype</span><span class="s4">=</span><span class="s5">'complex128'</span><span class="s4">, </span><span class="s1">order</span><span class="s4">=</span><span class="s5">'F'</span><span class="s4">)</span>
    <span class="s1">w_ </span><span class="s4">= </span><span class="s1">idzr_aidi</span><span class="s4">(</span><span class="s1">m</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">k</span><span class="s4">)</span>
    <span class="s1">w</span><span class="s4">[:</span><span class="s1">w_</span><span class="s4">.</span><span class="s1">size</span><span class="s4">] = </span><span class="s1">w_</span>
    <span class="s1">U</span><span class="s4">, </span><span class="s1">V</span><span class="s4">, </span><span class="s1">S</span><span class="s4">, </span><span class="s1">ier </span><span class="s4">= </span><span class="s1">_id</span><span class="s4">.</span><span class="s1">idzr_asvd</span><span class="s4">(</span><span class="s1">A</span><span class="s4">, </span><span class="s1">k</span><span class="s4">, </span><span class="s1">w</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">ier</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">_RETCODE_ERROR</span>
    <span class="s3">return </span><span class="s1">U</span><span class="s4">, </span><span class="s1">V</span><span class="s4">, </span><span class="s1">S</span>


<span class="s0">#------------------------------------------------------------------------------</span>
<span class="s0"># idzr_rid.f</span>
<span class="s0">#------------------------------------------------------------------------------</span>

<span class="s3">def </span><span class="s1">idzr_rid</span><span class="s4">(</span><span class="s1">m</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">matveca</span><span class="s4">, </span><span class="s1">k</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Compute ID of a complex matrix to a specified rank using random 
    matrix-vector multiplication. 
 
    :param m: 
        Matrix row dimension. 
    :type m: int 
    :param n: 
        Matrix column dimension. 
    :type n: int 
    :param matveca: 
        Function to apply the matrix adjoint to a vector, with call signature 
        `y = matveca(x)`, where `x` and `y` are the input and output vectors, 
        respectively. 
    :type matveca: function 
    :param k: 
        Rank of ID. 
    :type k: int 
 
    :return: 
        Column index array. 
    :rtype: :class:`numpy.ndarray` 
    :return: 
        Interpolation coefficients. 
    :rtype: :class:`numpy.ndarray` 
    &quot;&quot;&quot;</span>
    <span class="s1">idx</span><span class="s4">, </span><span class="s1">proj </span><span class="s4">= </span><span class="s1">_id</span><span class="s4">.</span><span class="s1">idzr_rid</span><span class="s4">(</span><span class="s1">m</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">matveca</span><span class="s4">, </span><span class="s1">k</span><span class="s4">)</span>
    <span class="s1">proj </span><span class="s4">= </span><span class="s1">proj</span><span class="s4">[:</span><span class="s1">k</span><span class="s4">*(</span><span class="s1">n</span><span class="s4">-</span><span class="s1">k</span><span class="s4">)].</span><span class="s1">reshape</span><span class="s4">((</span><span class="s1">k</span><span class="s4">, </span><span class="s1">n</span><span class="s4">-</span><span class="s1">k</span><span class="s4">), </span><span class="s1">order</span><span class="s4">=</span><span class="s5">'F'</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s1">idx</span><span class="s4">, </span><span class="s1">proj</span>


<span class="s0">#------------------------------------------------------------------------------</span>
<span class="s0"># idzr_rsvd.f</span>
<span class="s0">#------------------------------------------------------------------------------</span>

<span class="s3">def </span><span class="s1">idzr_rsvd</span><span class="s4">(</span><span class="s1">m</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">matveca</span><span class="s4">, </span><span class="s1">matvec</span><span class="s4">, </span><span class="s1">k</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Compute SVD of a complex matrix to a specified rank using random 
    matrix-vector multiplication. 
 
    :param m: 
        Matrix row dimension. 
    :type m: int 
    :param n: 
        Matrix column dimension. 
    :type n: int 
    :param matveca: 
        Function to apply the matrix adjoint to a vector, with call signature 
        `y = matveca(x)`, where `x` and `y` are the input and output vectors, 
        respectively. 
    :type matveca: function 
    :param matvec: 
        Function to apply the matrix to a vector, with call signature 
        `y = matvec(x)`, where `x` and `y` are the input and output vectors, 
        respectively. 
    :type matvec: function 
    :param k: 
        Rank of SVD. 
    :type k: int 
 
    :return: 
        Left singular vectors. 
    :rtype: :class:`numpy.ndarray` 
    :return: 
        Right singular vectors. 
    :rtype: :class:`numpy.ndarray` 
    :return: 
        Singular values. 
    :rtype: :class:`numpy.ndarray` 
    &quot;&quot;&quot;</span>
    <span class="s1">U</span><span class="s4">, </span><span class="s1">V</span><span class="s4">, </span><span class="s1">S</span><span class="s4">, </span><span class="s1">ier </span><span class="s4">= </span><span class="s1">_id</span><span class="s4">.</span><span class="s1">idzr_rsvd</span><span class="s4">(</span><span class="s1">m</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">matveca</span><span class="s4">, </span><span class="s1">matvec</span><span class="s4">, </span><span class="s1">k</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">ier</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">_RETCODE_ERROR</span>
    <span class="s3">return </span><span class="s1">U</span><span class="s4">, </span><span class="s1">V</span><span class="s4">, </span><span class="s1">S</span>
</pre>
</body>
</html>