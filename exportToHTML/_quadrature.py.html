<html>
<head>
<title>_quadrature.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #6aab73;}
.s4 { color: #2aacb8;}
.s5 { color: #5f826b; font-style: italic;}
.s6 { color: #7a7e85;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_quadrature.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">__future__ </span><span class="s0">import </span><span class="s1">annotations</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">TYPE_CHECKING</span><span class="s2">, </span><span class="s1">Callable</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">, </span><span class="s1">cast</span>
<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">import </span><span class="s1">numpy</span><span class="s2">.</span><span class="s1">typing </span><span class="s0">as </span><span class="s1">npt</span>
<span class="s0">import </span><span class="s1">math</span>
<span class="s0">import </span><span class="s1">warnings</span>
<span class="s0">from </span><span class="s1">collections </span><span class="s0">import </span><span class="s1">namedtuple</span>

<span class="s0">from </span><span class="s1">scipy</span><span class="s2">.</span><span class="s1">special </span><span class="s0">import </span><span class="s1">roots_legendre</span>
<span class="s0">from </span><span class="s1">scipy</span><span class="s2">.</span><span class="s1">special </span><span class="s0">import </span><span class="s1">gammaln</span><span class="s2">, </span><span class="s1">logsumexp</span>
<span class="s0">from </span><span class="s1">scipy</span><span class="s2">.</span><span class="s1">_lib</span><span class="s2">.</span><span class="s1">_util </span><span class="s0">import </span><span class="s1">_rng_spawn</span>
<span class="s0">from </span><span class="s1">scipy</span><span class="s2">.</span><span class="s1">_lib</span><span class="s2">.</span><span class="s1">deprecation </span><span class="s0">import </span><span class="s1">_deprecated</span>


<span class="s1">__all__ </span><span class="s2">= [</span><span class="s3">'fixed_quad'</span><span class="s2">, </span><span class="s3">'quadrature'</span><span class="s2">, </span><span class="s3">'romberg'</span><span class="s2">, </span><span class="s3">'romb'</span><span class="s2">,</span>
           <span class="s3">'trapezoid'</span><span class="s2">, </span><span class="s3">'simpson'</span><span class="s2">,</span>
           <span class="s3">'cumulative_trapezoid'</span><span class="s2">, </span><span class="s3">'newton_cotes'</span><span class="s2">,</span>
           <span class="s3">'qmc_quad'</span><span class="s2">, </span><span class="s3">'AccuracyWarning'</span><span class="s2">, </span><span class="s3">'cumulative_simpson'</span><span class="s2">]</span>


<span class="s0">def </span><span class="s1">trapezoid</span><span class="s2">(</span><span class="s1">y</span><span class="s2">, </span><span class="s1">x</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">dx</span><span class="s2">=</span><span class="s4">1.0</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=-</span><span class="s4">1</span><span class="s2">):</span>
    <span class="s5">r&quot;&quot;&quot; 
    Integrate along the given axis using the composite trapezoidal rule. 
 
    If `x` is provided, the integration happens in sequence along its 
    elements - they are not sorted. 
 
    Integrate `y` (`x`) along each 1d slice on the given axis, compute 
    :math:`\int y(x) dx`. 
    When `x` is specified, this integrates along the parametric curve, 
    computing :math:`\int_t y(t) dt = 
    \int_t y(t) \left.\frac{dx}{dt}\right|_{x=x(t)} dt`. 
 
    Parameters 
    ---------- 
    y : array_like 
        Input array to integrate. 
    x : array_like, optional 
        The sample points corresponding to the `y` values. If `x` is None, 
        the sample points are assumed to be evenly spaced `dx` apart. The 
        default is None. 
    dx : scalar, optional 
        The spacing between sample points when `x` is None. The default is 1. 
    axis : int, optional 
        The axis along which to integrate. 
 
    Returns 
    ------- 
    trapezoid : float or ndarray 
        Definite integral of `y` = n-dimensional array as approximated along 
        a single axis by the trapezoidal rule. If `y` is a 1-dimensional array, 
        then the result is a float. If `n` is greater than 1, then the result 
        is an `n`-1 dimensional array. 
 
    See Also 
    -------- 
    cumulative_trapezoid, simpson, romb 
 
    Notes 
    ----- 
    Image [2]_ illustrates trapezoidal rule -- y-axis locations of points 
    will be taken from `y` array, by default x-axis distances between 
    points will be 1.0, alternatively they can be provided with `x` array 
    or with `dx` scalar.  Return value will be equal to combined area under 
    the red lines. 
 
    References 
    ---------- 
    .. [1] Wikipedia page: https://en.wikipedia.org/wiki/Trapezoidal_rule 
 
    .. [2] Illustration image: 
           https://en.wikipedia.org/wiki/File:Composite_trapezoidal_rule_illustration.png 
 
    Examples 
    -------- 
    Use the trapezoidal rule on evenly spaced points: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import integrate 
    &gt;&gt;&gt; integrate.trapezoid([1, 2, 3]) 
    4.0 
 
    The spacing between sample points can be selected by either the 
    ``x`` or ``dx`` arguments: 
 
    &gt;&gt;&gt; integrate.trapezoid([1, 2, 3], x=[4, 6, 8]) 
    8.0 
    &gt;&gt;&gt; integrate.trapezoid([1, 2, 3], dx=2) 
    8.0 
 
    Using a decreasing ``x`` corresponds to integrating in reverse: 
 
    &gt;&gt;&gt; integrate.trapezoid([1, 2, 3], x=[8, 6, 4]) 
    -8.0 
 
    More generally ``x`` is used to integrate along a parametric curve. We can 
    estimate the integral :math:`\int_0^1 x^2 = 1/3` using: 
 
    &gt;&gt;&gt; x = np.linspace(0, 1, num=50) 
    &gt;&gt;&gt; y = x**2 
    &gt;&gt;&gt; integrate.trapezoid(y, x) 
    0.33340274885464394 
 
    Or estimate the area of a circle, noting we repeat the sample which closes 
    the curve: 
 
    &gt;&gt;&gt; theta = np.linspace(0, 2 * np.pi, num=1000, endpoint=True) 
    &gt;&gt;&gt; integrate.trapezoid(np.cos(theta), x=np.sin(theta)) 
    3.141571941375841 
 
    ``trapezoid`` can be applied along a specified axis to do multiple 
    computations in one call: 
 
    &gt;&gt;&gt; a = np.arange(6).reshape(2, 3) 
    &gt;&gt;&gt; a 
    array([[0, 1, 2], 
           [3, 4, 5]]) 
    &gt;&gt;&gt; integrate.trapezoid(a, axis=0) 
    array([1.5, 2.5, 3.5]) 
    &gt;&gt;&gt; integrate.trapezoid(a, axis=1) 
    array([2.,  8.]) 
    &quot;&quot;&quot;</span>
    <span class="s1">y </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asanyarray</span><span class="s2">(</span><span class="s1">y</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">x </span><span class="s0">is None</span><span class="s2">:</span>
        <span class="s1">d </span><span class="s2">= </span><span class="s1">dx</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">x </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asanyarray</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">x</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s4">1</span><span class="s2">:</span>
            <span class="s1">d </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">diff</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)</span>
            <span class="s6"># reshape to correct shape</span>
            <span class="s1">shape </span><span class="s2">= [</span><span class="s4">1</span><span class="s2">]*</span><span class="s1">y</span><span class="s2">.</span><span class="s1">ndim</span>
            <span class="s1">shape</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">] = </span><span class="s1">d</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s4">0</span><span class="s2">]</span>
            <span class="s1">d </span><span class="s2">= </span><span class="s1">d</span><span class="s2">.</span><span class="s1">reshape</span><span class="s2">(</span><span class="s1">shape</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">d </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">diff</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s1">axis</span><span class="s2">)</span>
    <span class="s1">nd </span><span class="s2">= </span><span class="s1">y</span><span class="s2">.</span><span class="s1">ndim</span>
    <span class="s1">slice1 </span><span class="s2">= [</span><span class="s1">slice</span><span class="s2">(</span><span class="s0">None</span><span class="s2">)]*</span><span class="s1">nd</span>
    <span class="s1">slice2 </span><span class="s2">= [</span><span class="s1">slice</span><span class="s2">(</span><span class="s0">None</span><span class="s2">)]*</span><span class="s1">nd</span>
    <span class="s1">slice1</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">] = </span><span class="s1">slice</span><span class="s2">(</span><span class="s4">1</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>
    <span class="s1">slice2</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">] = </span><span class="s1">slice</span><span class="s2">(</span><span class="s0">None</span><span class="s2">, -</span><span class="s4">1</span><span class="s2">)</span>
    <span class="s0">try</span><span class="s2">:</span>
        <span class="s1">ret </span><span class="s2">= (</span><span class="s1">d </span><span class="s2">* (</span><span class="s1">y</span><span class="s2">[</span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">slice1</span><span class="s2">)] + </span><span class="s1">y</span><span class="s2">[</span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">slice2</span><span class="s2">)]) / </span><span class="s4">2.0</span><span class="s2">).</span><span class="s1">sum</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">)</span>
    <span class="s0">except </span><span class="s1">ValueError</span><span class="s2">:</span>
        <span class="s6"># Operations didn't work, cast to ndarray</span>
        <span class="s1">d </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">d</span><span class="s2">)</span>
        <span class="s1">y </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">y</span><span class="s2">)</span>
        <span class="s1">ret </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">add</span><span class="s2">.</span><span class="s1">reduce</span><span class="s2">(</span><span class="s1">d </span><span class="s2">* (</span><span class="s1">y</span><span class="s2">[</span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">slice1</span><span class="s2">)]+</span><span class="s1">y</span><span class="s2">[</span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">slice2</span><span class="s2">)])/</span><span class="s4">2.0</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">ret</span>


<span class="s0">class </span><span class="s1">AccuracyWarning</span><span class="s2">(</span><span class="s1">Warning</span><span class="s2">):</span>
    <span class="s0">pass</span>


<span class="s0">if </span><span class="s1">TYPE_CHECKING</span><span class="s2">:</span>
    <span class="s6"># workaround for mypy function attributes see:</span>
    <span class="s6"># https://github.com/python/mypy/issues/2087#issuecomment-462726600</span>
    <span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Protocol</span>

    <span class="s0">class </span><span class="s1">CacheAttributes</span><span class="s2">(</span><span class="s1">Protocol</span><span class="s2">):</span>
        <span class="s1">cache</span><span class="s2">: </span><span class="s1">dict</span><span class="s2">[</span><span class="s1">int</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">[</span><span class="s1">Any</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">]]</span>
<span class="s0">else</span><span class="s2">:</span>
    <span class="s1">CacheAttributes </span><span class="s2">= </span><span class="s1">Callable</span>


<span class="s0">def </span><span class="s1">cache_decorator</span><span class="s2">(</span><span class="s1">func</span><span class="s2">: </span><span class="s1">Callable</span><span class="s2">) </span><span class="s1">-&gt; CacheAttributes</span><span class="s2">:</span>
    <span class="s0">return </span><span class="s1">cast</span><span class="s2">(</span><span class="s1">CacheAttributes</span><span class="s2">, </span><span class="s1">func</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">cache_decorator</span>
<span class="s0">def </span><span class="s1">_cached_roots_legendre</span><span class="s2">(</span><span class="s1">n</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Cache roots_legendre results to speed up calls of the fixed_quad 
    function. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">n </span><span class="s0">in </span><span class="s1">_cached_roots_legendre</span><span class="s2">.</span><span class="s1">cache</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">_cached_roots_legendre</span><span class="s2">.</span><span class="s1">cache</span><span class="s2">[</span><span class="s1">n</span><span class="s2">]</span>

    <span class="s1">_cached_roots_legendre</span><span class="s2">.</span><span class="s1">cache</span><span class="s2">[</span><span class="s1">n</span><span class="s2">] = </span><span class="s1">roots_legendre</span><span class="s2">(</span><span class="s1">n</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">_cached_roots_legendre</span><span class="s2">.</span><span class="s1">cache</span><span class="s2">[</span><span class="s1">n</span><span class="s2">]</span>


<span class="s1">_cached_roots_legendre</span><span class="s2">.</span><span class="s1">cache </span><span class="s2">= </span><span class="s1">dict</span><span class="s2">()</span>


<span class="s0">def </span><span class="s1">fixed_quad</span><span class="s2">(</span><span class="s1">func</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">args</span><span class="s2">=(), </span><span class="s1">n</span><span class="s2">=</span><span class="s4">5</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Compute a definite integral using fixed-order Gaussian quadrature. 
 
    Integrate `func` from `a` to `b` using Gaussian quadrature of 
    order `n`. 
 
    Parameters 
    ---------- 
    func : callable 
        A Python function or method to integrate (must accept vector inputs). 
        If integrating a vector-valued function, the returned array must have 
        shape ``(..., len(x))``. 
    a : float 
        Lower limit of integration. 
    b : float 
        Upper limit of integration. 
    args : tuple, optional 
        Extra arguments to pass to function, if any. 
    n : int, optional 
        Order of quadrature integration. Default is 5. 
 
    Returns 
    ------- 
    val : float 
        Gaussian quadrature approximation to the integral 
    none : None 
        Statically returned value of None 
 
    See Also 
    -------- 
    quad : adaptive quadrature using QUADPACK 
    dblquad : double integrals 
    tplquad : triple integrals 
    romb : integrators for sampled data 
    simpson : integrators for sampled data 
    cumulative_trapezoid : cumulative integration for sampled data 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy import integrate 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; f = lambda x: x**8 
    &gt;&gt;&gt; integrate.fixed_quad(f, 0.0, 1.0, n=4) 
    (0.1110884353741496, None) 
    &gt;&gt;&gt; integrate.fixed_quad(f, 0.0, 1.0, n=5) 
    (0.11111111111111102, None) 
    &gt;&gt;&gt; print(1/9.0)  # analytical result 
    0.1111111111111111 
 
    &gt;&gt;&gt; integrate.fixed_quad(np.cos, 0.0, np.pi/2, n=4) 
    (0.9999999771971152, None) 
    &gt;&gt;&gt; integrate.fixed_quad(np.cos, 0.0, np.pi/2, n=5) 
    (1.000000000039565, None) 
    &gt;&gt;&gt; np.sin(np.pi/2)-np.sin(0)  # analytical result 
    1.0 
 
    &quot;&quot;&quot;</span>
    <span class="s1">x</span><span class="s2">, </span><span class="s1">w </span><span class="s2">= </span><span class="s1">_cached_roots_legendre</span><span class="s2">(</span><span class="s1">n</span><span class="s2">)</span>
    <span class="s1">x </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">real</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isinf</span><span class="s2">(</span><span class="s1">a</span><span class="s2">) </span><span class="s0">or </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isinf</span><span class="s2">(</span><span class="s1">b</span><span class="s2">):</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;Gaussian quadrature is only available for &quot;</span>
                         <span class="s3">&quot;finite limits.&quot;</span><span class="s2">)</span>
    <span class="s1">y </span><span class="s2">= (</span><span class="s1">b</span><span class="s2">-</span><span class="s1">a</span><span class="s2">)*(</span><span class="s1">x</span><span class="s2">+</span><span class="s4">1</span><span class="s2">)/</span><span class="s4">2.0 </span><span class="s2">+ </span><span class="s1">a</span>
    <span class="s0">return </span><span class="s2">(</span><span class="s1">b</span><span class="s2">-</span><span class="s1">a</span><span class="s2">)/</span><span class="s4">2.0 </span><span class="s2">* </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sum</span><span class="s2">(</span><span class="s1">w</span><span class="s2">*</span><span class="s1">func</span><span class="s2">(</span><span class="s1">y</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">), </span><span class="s1">axis</span><span class="s2">=-</span><span class="s4">1</span><span class="s2">), </span><span class="s0">None</span>


<span class="s0">def </span><span class="s1">vectorize1</span><span class="s2">(</span><span class="s1">func</span><span class="s2">, </span><span class="s1">args</span><span class="s2">=(), </span><span class="s1">vec_func</span><span class="s2">=</span><span class="s0">False</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot;Vectorize the call to a function. 
 
    This is an internal utility function used by `romberg` and 
    `quadrature` to create a vectorized version of a function. 
 
    If `vec_func` is True, the function `func` is assumed to take vector 
    arguments. 
 
    Parameters 
    ---------- 
    func : callable 
        User defined function. 
    args : tuple, optional 
        Extra arguments for the function. 
    vec_func : bool, optional 
        True if the function func takes vector arguments. 
 
    Returns 
    ------- 
    vfunc : callable 
        A function that will take a vector argument and return the 
        result. 
 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">vec_func</span><span class="s2">:</span>
        <span class="s0">def </span><span class="s1">vfunc</span><span class="s2">(</span><span class="s1">x</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">func</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">)</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s0">def </span><span class="s1">vfunc</span><span class="s2">(</span><span class="s1">x</span><span class="s2">):</span>
            <span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isscalar</span><span class="s2">(</span><span class="s1">x</span><span class="s2">):</span>
                <span class="s0">return </span><span class="s1">func</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">)</span>
            <span class="s1">x </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)</span>
            <span class="s6"># call with first point to get output type</span>
            <span class="s1">y0 </span><span class="s2">= </span><span class="s1">func</span><span class="s2">(</span><span class="s1">x</span><span class="s2">[</span><span class="s4">0</span><span class="s2">], *</span><span class="s1">args</span><span class="s2">)</span>
            <span class="s1">n </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)</span>
            <span class="s1">dtype </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">y0</span><span class="s2">, </span><span class="s3">'dtype'</span><span class="s2">, </span><span class="s1">type</span><span class="s2">(</span><span class="s1">y0</span><span class="s2">))</span>
            <span class="s1">output </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">((</span><span class="s1">n</span><span class="s2">,), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">)</span>
            <span class="s1">output</span><span class="s2">[</span><span class="s4">0</span><span class="s2">] = </span><span class="s1">y0</span>
            <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">n</span><span class="s2">):</span>
                <span class="s1">output</span><span class="s2">[</span><span class="s1">i</span><span class="s2">] = </span><span class="s1">func</span><span class="s2">(</span><span class="s1">x</span><span class="s2">[</span><span class="s1">i</span><span class="s2">], *</span><span class="s1">args</span><span class="s2">)</span>
            <span class="s0">return </span><span class="s1">output</span>
    <span class="s0">return </span><span class="s1">vfunc</span>


<span class="s2">@</span><span class="s1">_deprecated</span><span class="s2">(</span><span class="s3">&quot;`scipy.integrate.quadrature` is deprecated as of SciPy 1.12.0&quot;</span>
             <span class="s3">&quot;and will be removed in SciPy 1.15.0. Please use&quot;</span>
             <span class="s3">&quot;`scipy.integrate.quad` instead.&quot;</span><span class="s2">)</span>
<span class="s0">def </span><span class="s1">quadrature</span><span class="s2">(</span><span class="s1">func</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">args</span><span class="s2">=(), </span><span class="s1">tol</span><span class="s2">=</span><span class="s4">1.49e-8</span><span class="s2">, </span><span class="s1">rtol</span><span class="s2">=</span><span class="s4">1.49e-8</span><span class="s2">, </span><span class="s1">maxiter</span><span class="s2">=</span><span class="s4">50</span><span class="s2">,</span>
               <span class="s1">vec_func</span><span class="s2">=</span><span class="s0">True</span><span class="s2">, </span><span class="s1">miniter</span><span class="s2">=</span><span class="s4">1</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Compute a definite integral using fixed-tolerance Gaussian quadrature. 
 
    .. deprecated:: 1.12.0 
 
          This function is deprecated as of SciPy 1.12.0 and will be removed 
          in SciPy 1.15.0. Please use `scipy.integrate.quad` instead. 
 
    Integrate `func` from `a` to `b` using Gaussian quadrature 
    with absolute tolerance `tol`. 
 
    Parameters 
    ---------- 
    func : function 
        A Python function or method to integrate. 
    a : float 
        Lower limit of integration. 
    b : float 
        Upper limit of integration. 
    args : tuple, optional 
        Extra arguments to pass to function. 
    tol, rtol : float, optional 
        Iteration stops when error between last two iterates is less than 
        `tol` OR the relative change is less than `rtol`. 
    maxiter : int, optional 
        Maximum order of Gaussian quadrature. 
    vec_func : bool, optional 
        True or False if func handles arrays as arguments (is 
        a &quot;vector&quot; function). Default is True. 
    miniter : int, optional 
        Minimum order of Gaussian quadrature. 
 
    Returns 
    ------- 
    val : float 
        Gaussian quadrature approximation (within tolerance) to integral. 
    err : float 
        Difference between last two estimates of the integral. 
 
    See Also 
    -------- 
    fixed_quad : fixed-order Gaussian quadrature 
    quad : adaptive quadrature using QUADPACK 
    dblquad : double integrals 
    tplquad : triple integrals 
    romb : integrator for sampled data 
    simpson : integrator for sampled data 
    cumulative_trapezoid : cumulative integration for sampled data 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy import integrate 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; f = lambda x: x**8 
    &gt;&gt;&gt; integrate.quadrature(f, 0.0, 1.0) 
    (0.11111111111111106, 4.163336342344337e-17) 
    &gt;&gt;&gt; print(1/9.0)  # analytical result 
    0.1111111111111111 
 
    &gt;&gt;&gt; integrate.quadrature(np.cos, 0.0, np.pi/2) 
    (0.9999999999999536, 3.9611425250996035e-11) 
    &gt;&gt;&gt; np.sin(np.pi/2)-np.sin(0)  # analytical result 
    1.0 
 
    &quot;&quot;&quot;</span>
    <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">args</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">):</span>
        <span class="s1">args </span><span class="s2">= (</span><span class="s1">args</span><span class="s2">,)</span>
    <span class="s1">vfunc </span><span class="s2">= </span><span class="s1">vectorize1</span><span class="s2">(</span><span class="s1">func</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">vec_func</span><span class="s2">=</span><span class="s1">vec_func</span><span class="s2">)</span>
    <span class="s1">val </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span>
    <span class="s1">err </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span>
    <span class="s1">maxiter </span><span class="s2">= </span><span class="s1">max</span><span class="s2">(</span><span class="s1">miniter</span><span class="s2">+</span><span class="s4">1</span><span class="s2">, </span><span class="s1">maxiter</span><span class="s2">)</span>
    <span class="s0">for </span><span class="s1">n </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">miniter</span><span class="s2">, </span><span class="s1">maxiter</span><span class="s2">+</span><span class="s4">1</span><span class="s2">):</span>
        <span class="s1">newval </span><span class="s2">= </span><span class="s1">fixed_quad</span><span class="s2">(</span><span class="s1">vfunc</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, (), </span><span class="s1">n</span><span class="s2">)[</span><span class="s4">0</span><span class="s2">]</span>
        <span class="s1">err </span><span class="s2">= </span><span class="s1">abs</span><span class="s2">(</span><span class="s1">newval</span><span class="s2">-</span><span class="s1">val</span><span class="s2">)</span>
        <span class="s1">val </span><span class="s2">= </span><span class="s1">newval</span>

        <span class="s0">if </span><span class="s1">err </span><span class="s2">&lt; </span><span class="s1">tol </span><span class="s0">or </span><span class="s1">err </span><span class="s2">&lt; </span><span class="s1">rtol</span><span class="s2">*</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">val</span><span class="s2">):</span>
            <span class="s0">break</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span>
            <span class="s3">&quot;maxiter (%d) exceeded. Latest difference = %e&quot; </span><span class="s2">% (</span><span class="s1">maxiter</span><span class="s2">, </span><span class="s1">err</span><span class="s2">),</span>
            <span class="s1">AccuracyWarning</span><span class="s2">, </span><span class="s1">stacklevel</span><span class="s2">=</span><span class="s4">2</span>
        <span class="s2">)</span>
    <span class="s0">return </span><span class="s1">val</span><span class="s2">, </span><span class="s1">err</span>


<span class="s0">def </span><span class="s1">tupleset</span><span class="s2">(</span><span class="s1">t</span><span class="s2">, </span><span class="s1">i</span><span class="s2">, </span><span class="s1">value</span><span class="s2">):</span>
    <span class="s1">l </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">t</span><span class="s2">)</span>
    <span class="s1">l</span><span class="s2">[</span><span class="s1">i</span><span class="s2">] = </span><span class="s1">value</span>
    <span class="s0">return </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">l</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">cumulative_trapezoid</span><span class="s2">(</span><span class="s1">y</span><span class="s2">, </span><span class="s1">x</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">dx</span><span class="s2">=</span><span class="s4">1.0</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=-</span><span class="s4">1</span><span class="s2">, </span><span class="s1">initial</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Cumulatively integrate y(x) using the composite trapezoidal rule. 
 
    Parameters 
    ---------- 
    y : array_like 
        Values to integrate. 
    x : array_like, optional 
        The coordinate to integrate along. If None (default), use spacing `dx` 
        between consecutive elements in `y`. 
    dx : float, optional 
        Spacing between elements of `y`. Only used if `x` is None. 
    axis : int, optional 
        Specifies the axis to cumulate. Default is -1 (last axis). 
    initial : scalar, optional 
        If given, insert this value at the beginning of the returned result. 
        0 or None are the only values accepted. Default is None, which means 
        `res` has one element less than `y` along the axis of integration. 
 
        .. deprecated:: 1.12.0 
            The option for non-zero inputs for `initial` will be deprecated in 
            SciPy 1.15.0. After this time, a ValueError will be raised if 
            `initial` is not None or 0. 
 
    Returns 
    ------- 
    res : ndarray 
        The result of cumulative integration of `y` along `axis`. 
        If `initial` is None, the shape is such that the axis of integration 
        has one less value than `y`. If `initial` is given, the shape is equal 
        to that of `y`. 
 
    See Also 
    -------- 
    numpy.cumsum, numpy.cumprod 
    cumulative_simpson : cumulative integration using Simpson's 1/3 rule 
    quad : adaptive quadrature using QUADPACK 
    fixed_quad : fixed-order Gaussian quadrature 
    dblquad : double integrals 
    tplquad : triple integrals 
    romb : integrators for sampled data 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy import integrate 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
 
    &gt;&gt;&gt; x = np.linspace(-2, 2, num=20) 
    &gt;&gt;&gt; y = x 
    &gt;&gt;&gt; y_int = integrate.cumulative_trapezoid(y, x, initial=0) 
    &gt;&gt;&gt; plt.plot(x, y_int, 'ro', x, y[0] + 0.5 * x**2, 'b-') 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span>
    <span class="s1">y </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">y</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">y</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">] == </span><span class="s4">0</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;At least one point is required along `axis`.&quot;</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">x </span><span class="s0">is None</span><span class="s2">:</span>
        <span class="s1">d </span><span class="s2">= </span><span class="s1">dx</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">x </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">x</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s4">1</span><span class="s2">:</span>
            <span class="s1">d </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">diff</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)</span>
            <span class="s6"># reshape to correct shape</span>
            <span class="s1">shape </span><span class="s2">= [</span><span class="s4">1</span><span class="s2">] * </span><span class="s1">y</span><span class="s2">.</span><span class="s1">ndim</span>
            <span class="s1">shape</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">] = -</span><span class="s4">1</span>
            <span class="s1">d </span><span class="s2">= </span><span class="s1">d</span><span class="s2">.</span><span class="s1">reshape</span><span class="s2">(</span><span class="s1">shape</span><span class="s2">)</span>
        <span class="s0">elif </span><span class="s1">len</span><span class="s2">(</span><span class="s1">x</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">) != </span><span class="s1">len</span><span class="s2">(</span><span class="s1">y</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">):</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;If given, shape of x must be 1-D or the &quot;</span>
                             <span class="s3">&quot;same as y.&quot;</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">d </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">diff</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s1">axis</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">d</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">] != </span><span class="s1">y</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">] - </span><span class="s4">1</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;If given, length of x along axis must be the &quot;</span>
                             <span class="s3">&quot;same as y.&quot;</span><span class="s2">)</span>

    <span class="s1">nd </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">y</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">)</span>
    <span class="s1">slice1 </span><span class="s2">= </span><span class="s1">tupleset</span><span class="s2">((</span><span class="s1">slice</span><span class="s2">(</span><span class="s0">None</span><span class="s2">),)*</span><span class="s1">nd</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">slice</span><span class="s2">(</span><span class="s4">1</span><span class="s2">, </span><span class="s0">None</span><span class="s2">))</span>
    <span class="s1">slice2 </span><span class="s2">= </span><span class="s1">tupleset</span><span class="s2">((</span><span class="s1">slice</span><span class="s2">(</span><span class="s0">None</span><span class="s2">),)*</span><span class="s1">nd</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">slice</span><span class="s2">(</span><span class="s0">None</span><span class="s2">, -</span><span class="s4">1</span><span class="s2">))</span>
    <span class="s1">res </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">cumsum</span><span class="s2">(</span><span class="s1">d </span><span class="s2">* (</span><span class="s1">y</span><span class="s2">[</span><span class="s1">slice1</span><span class="s2">] + </span><span class="s1">y</span><span class="s2">[</span><span class="s1">slice2</span><span class="s2">]) / </span><span class="s4">2.0</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s1">axis</span><span class="s2">)</span>

    <span class="s0">if </span><span class="s1">initial </span><span class="s0">is not None</span><span class="s2">:</span>
        <span class="s0">if </span><span class="s1">initial </span><span class="s2">!= </span><span class="s4">0</span><span class="s2">:</span>
            <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span>
                <span class="s3">&quot;The option for values for `initial` other than None or 0 is &quot;</span>
                <span class="s3">&quot;deprecated as of SciPy 1.12.0 and will raise a value error in&quot;</span>
                <span class="s3">&quot; SciPy 1.15.0.&quot;</span><span class="s2">,</span>
                <span class="s1">DeprecationWarning</span><span class="s2">, </span><span class="s1">stacklevel</span><span class="s2">=</span><span class="s4">2</span>
            <span class="s2">)</span>
        <span class="s0">if not </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isscalar</span><span class="s2">(</span><span class="s1">initial</span><span class="s2">):</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;`initial` parameter should be a scalar.&quot;</span><span class="s2">)</span>

        <span class="s1">shape </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">res</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">)</span>
        <span class="s1">shape</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">] = </span><span class="s4">1</span>
        <span class="s1">res </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">concatenate</span><span class="s2">([</span><span class="s1">np</span><span class="s2">.</span><span class="s1">full</span><span class="s2">(</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">initial</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">res</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">), </span><span class="s1">res</span><span class="s2">],</span>
                             <span class="s1">axis</span><span class="s2">=</span><span class="s1">axis</span><span class="s2">)</span>

    <span class="s0">return </span><span class="s1">res</span>


<span class="s0">def </span><span class="s1">_basic_simpson</span><span class="s2">(</span><span class="s1">y</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">stop</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">dx</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">):</span>
    <span class="s1">nd </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">y</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">start </span><span class="s0">is None</span><span class="s2">:</span>
        <span class="s1">start </span><span class="s2">= </span><span class="s4">0</span>
    <span class="s1">step </span><span class="s2">= </span><span class="s4">2</span>
    <span class="s1">slice_all </span><span class="s2">= (</span><span class="s1">slice</span><span class="s2">(</span><span class="s0">None</span><span class="s2">),)*</span><span class="s1">nd</span>
    <span class="s1">slice0 </span><span class="s2">= </span><span class="s1">tupleset</span><span class="s2">(</span><span class="s1">slice_all</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">slice</span><span class="s2">(</span><span class="s1">start</span><span class="s2">, </span><span class="s1">stop</span><span class="s2">, </span><span class="s1">step</span><span class="s2">))</span>
    <span class="s1">slice1 </span><span class="s2">= </span><span class="s1">tupleset</span><span class="s2">(</span><span class="s1">slice_all</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">slice</span><span class="s2">(</span><span class="s1">start</span><span class="s2">+</span><span class="s4">1</span><span class="s2">, </span><span class="s1">stop</span><span class="s2">+</span><span class="s4">1</span><span class="s2">, </span><span class="s1">step</span><span class="s2">))</span>
    <span class="s1">slice2 </span><span class="s2">= </span><span class="s1">tupleset</span><span class="s2">(</span><span class="s1">slice_all</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">slice</span><span class="s2">(</span><span class="s1">start</span><span class="s2">+</span><span class="s4">2</span><span class="s2">, </span><span class="s1">stop</span><span class="s2">+</span><span class="s4">2</span><span class="s2">, </span><span class="s1">step</span><span class="s2">))</span>

    <span class="s0">if </span><span class="s1">x </span><span class="s0">is None</span><span class="s2">:  </span><span class="s6"># Even-spaced Simpson's rule.</span>
        <span class="s1">result </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sum</span><span class="s2">(</span><span class="s1">y</span><span class="s2">[</span><span class="s1">slice0</span><span class="s2">] + </span><span class="s4">4.0</span><span class="s2">*</span><span class="s1">y</span><span class="s2">[</span><span class="s1">slice1</span><span class="s2">] + </span><span class="s1">y</span><span class="s2">[</span><span class="s1">slice2</span><span class="s2">], </span><span class="s1">axis</span><span class="s2">=</span><span class="s1">axis</span><span class="s2">)</span>
        <span class="s1">result </span><span class="s2">*= </span><span class="s1">dx </span><span class="s2">/ </span><span class="s4">3.0</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s6"># Account for possibly different spacings.</span>
        <span class="s6">#    Simpson's rule changes a bit.</span>
        <span class="s1">h </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">diff</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s1">axis</span><span class="s2">)</span>
        <span class="s1">sl0 </span><span class="s2">= </span><span class="s1">tupleset</span><span class="s2">(</span><span class="s1">slice_all</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">slice</span><span class="s2">(</span><span class="s1">start</span><span class="s2">, </span><span class="s1">stop</span><span class="s2">, </span><span class="s1">step</span><span class="s2">))</span>
        <span class="s1">sl1 </span><span class="s2">= </span><span class="s1">tupleset</span><span class="s2">(</span><span class="s1">slice_all</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">slice</span><span class="s2">(</span><span class="s1">start</span><span class="s2">+</span><span class="s4">1</span><span class="s2">, </span><span class="s1">stop</span><span class="s2">+</span><span class="s4">1</span><span class="s2">, </span><span class="s1">step</span><span class="s2">))</span>
        <span class="s1">h0 </span><span class="s2">= </span><span class="s1">h</span><span class="s2">[</span><span class="s1">sl0</span><span class="s2">].</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">float</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>
        <span class="s1">h1 </span><span class="s2">= </span><span class="s1">h</span><span class="s2">[</span><span class="s1">sl1</span><span class="s2">].</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">float</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>
        <span class="s1">hsum </span><span class="s2">= </span><span class="s1">h0 </span><span class="s2">+ </span><span class="s1">h1</span>
        <span class="s1">hprod </span><span class="s2">= </span><span class="s1">h0 </span><span class="s2">* </span><span class="s1">h1</span>
        <span class="s1">h0divh1 </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">true_divide</span><span class="s2">(</span><span class="s1">h0</span><span class="s2">, </span><span class="s1">h1</span><span class="s2">, </span><span class="s1">out</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros_like</span><span class="s2">(</span><span class="s1">h0</span><span class="s2">), </span><span class="s1">where</span><span class="s2">=</span><span class="s1">h1 </span><span class="s2">!= </span><span class="s4">0</span><span class="s2">)</span>
        <span class="s1">tmp </span><span class="s2">= </span><span class="s1">hsum</span><span class="s2">/</span><span class="s4">6.0 </span><span class="s2">* (</span><span class="s1">y</span><span class="s2">[</span><span class="s1">slice0</span><span class="s2">] *</span>
                          <span class="s2">(</span><span class="s4">2.0 </span><span class="s2">- </span><span class="s1">np</span><span class="s2">.</span><span class="s1">true_divide</span><span class="s2">(</span><span class="s4">1.0</span><span class="s2">, </span><span class="s1">h0divh1</span><span class="s2">,</span>
                                                <span class="s1">out</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros_like</span><span class="s2">(</span><span class="s1">h0divh1</span><span class="s2">),</span>
                                                <span class="s1">where</span><span class="s2">=</span><span class="s1">h0divh1 </span><span class="s2">!= </span><span class="s4">0</span><span class="s2">)) +</span>
                          <span class="s1">y</span><span class="s2">[</span><span class="s1">slice1</span><span class="s2">] * (</span><span class="s1">hsum </span><span class="s2">*</span>
                                       <span class="s1">np</span><span class="s2">.</span><span class="s1">true_divide</span><span class="s2">(</span><span class="s1">hsum</span><span class="s2">, </span><span class="s1">hprod</span><span class="s2">,</span>
                                                      <span class="s1">out</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros_like</span><span class="s2">(</span><span class="s1">hsum</span><span class="s2">),</span>
                                                      <span class="s1">where</span><span class="s2">=</span><span class="s1">hprod </span><span class="s2">!= </span><span class="s4">0</span><span class="s2">)) +</span>
                          <span class="s1">y</span><span class="s2">[</span><span class="s1">slice2</span><span class="s2">] * (</span><span class="s4">2.0 </span><span class="s2">- </span><span class="s1">h0divh1</span><span class="s2">))</span>
        <span class="s1">result </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sum</span><span class="s2">(</span><span class="s1">tmp</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s1">axis</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">result</span>


<span class="s0">def </span><span class="s1">simpson</span><span class="s2">(</span><span class="s1">y</span><span class="s2">, *, </span><span class="s1">x</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">dx</span><span class="s2">=</span><span class="s4">1.0</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=-</span><span class="s4">1</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Integrate y(x) using samples along the given axis and the composite 
    Simpson's rule. If x is None, spacing of dx is assumed. 
 
    If there are an even number of samples, N, then there are an odd 
    number of intervals (N-1), but Simpson's rule requires an even number 
    of intervals. The parameter 'even' controls how this is handled. 
 
    Parameters 
    ---------- 
    y : array_like 
        Array to be integrated. 
    x : array_like, optional 
        If given, the points at which `y` is sampled. 
    dx : float, optional 
        Spacing of integration points along axis of `x`. Only used when 
        `x` is None. Default is 1. 
    axis : int, optional 
        Axis along which to integrate. Default is the last axis. 
 
    Returns 
    ------- 
    float 
        The estimated integral computed with the composite Simpson's rule. 
 
    See Also 
    -------- 
    quad : adaptive quadrature using QUADPACK 
    fixed_quad : fixed-order Gaussian quadrature 
    dblquad : double integrals 
    tplquad : triple integrals 
    romb : integrators for sampled data 
    cumulative_trapezoid : cumulative integration for sampled data 
    cumulative_simpson : cumulative integration using Simpson's 1/3 rule 
 
    Notes 
    ----- 
    For an odd number of samples that are equally spaced the result is 
    exact if the function is a polynomial of order 3 or less. If 
    the samples are not equally spaced, then the result is exact only 
    if the function is a polynomial of order 2 or less. 
 
    References 
    ---------- 
    .. [1] Cartwright, Kenneth V. Simpson's Rule Cumulative Integration with 
           MS Excel and Irregularly-spaced Data. Journal of Mathematical 
           Sciences and Mathematics Education. 12 (2): 1-9 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy import integrate 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; x = np.arange(0, 10) 
    &gt;&gt;&gt; y = np.arange(0, 10) 
 
    &gt;&gt;&gt; integrate.simpson(y, x=x) 
    40.5 
 
    &gt;&gt;&gt; y = np.power(x, 3) 
    &gt;&gt;&gt; integrate.simpson(y, x=x) 
    1640.5 
    &gt;&gt;&gt; integrate.quad(lambda x: x**3, 0, 9)[0] 
    1640.25 
 
    &quot;&quot;&quot;</span>
    <span class="s1">y </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">y</span><span class="s2">)</span>
    <span class="s1">nd </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">y</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">)</span>
    <span class="s1">N </span><span class="s2">= </span><span class="s1">y</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">]</span>
    <span class="s1">last_dx </span><span class="s2">= </span><span class="s1">dx</span>
    <span class="s1">returnshape </span><span class="s2">= </span><span class="s4">0</span>
    <span class="s0">if </span><span class="s1">x </span><span class="s0">is not None</span><span class="s2">:</span>
        <span class="s1">x </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">x</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">) == </span><span class="s4">1</span><span class="s2">:</span>
            <span class="s1">shapex </span><span class="s2">= [</span><span class="s4">1</span><span class="s2">] * </span><span class="s1">nd</span>
            <span class="s1">shapex</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">] = </span><span class="s1">x</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s4">0</span><span class="s2">]</span>
            <span class="s1">saveshape </span><span class="s2">= </span><span class="s1">x</span><span class="s2">.</span><span class="s1">shape</span>
            <span class="s1">returnshape </span><span class="s2">= </span><span class="s4">1</span>
            <span class="s1">x </span><span class="s2">= </span><span class="s1">x</span><span class="s2">.</span><span class="s1">reshape</span><span class="s2">(</span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">shapex</span><span class="s2">))</span>
        <span class="s0">elif </span><span class="s1">len</span><span class="s2">(</span><span class="s1">x</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">) != </span><span class="s1">len</span><span class="s2">(</span><span class="s1">y</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">):</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;If given, shape of x must be 1-D or the &quot;</span>
                             <span class="s3">&quot;same as y.&quot;</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">x</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">] != </span><span class="s1">N</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;If given, length of x along axis must be the &quot;</span>
                             <span class="s3">&quot;same as y.&quot;</span><span class="s2">)</span>

    <span class="s0">if </span><span class="s1">N </span><span class="s2">% </span><span class="s4">2 </span><span class="s2">== </span><span class="s4">0</span><span class="s2">:</span>
        <span class="s1">val </span><span class="s2">= </span><span class="s4">0.0</span>
        <span class="s1">result </span><span class="s2">= </span><span class="s4">0.0</span>
        <span class="s1">slice_all </span><span class="s2">= (</span><span class="s1">slice</span><span class="s2">(</span><span class="s0">None</span><span class="s2">),) * </span><span class="s1">nd</span>

        <span class="s0">if </span><span class="s1">N </span><span class="s2">== </span><span class="s4">2</span><span class="s2">:</span>
            <span class="s6"># need at least 3 points in integration axis to form parabolic</span>
            <span class="s6"># segment. If there are two points then any of 'avg', 'first',</span>
            <span class="s6"># 'last' should give the same result.</span>
            <span class="s1">slice1 </span><span class="s2">= </span><span class="s1">tupleset</span><span class="s2">(</span><span class="s1">slice_all</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, -</span><span class="s4">1</span><span class="s2">)</span>
            <span class="s1">slice2 </span><span class="s2">= </span><span class="s1">tupleset</span><span class="s2">(</span><span class="s1">slice_all</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, -</span><span class="s4">2</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">x </span><span class="s0">is not None</span><span class="s2">:</span>
                <span class="s1">last_dx </span><span class="s2">= </span><span class="s1">x</span><span class="s2">[</span><span class="s1">slice1</span><span class="s2">] - </span><span class="s1">x</span><span class="s2">[</span><span class="s1">slice2</span><span class="s2">]</span>
            <span class="s1">val </span><span class="s2">+= </span><span class="s4">0.5 </span><span class="s2">* </span><span class="s1">last_dx </span><span class="s2">* (</span><span class="s1">y</span><span class="s2">[</span><span class="s1">slice1</span><span class="s2">] + </span><span class="s1">y</span><span class="s2">[</span><span class="s1">slice2</span><span class="s2">])</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s6"># use Simpson's rule on first intervals</span>
            <span class="s1">result </span><span class="s2">= </span><span class="s1">_basic_simpson</span><span class="s2">(</span><span class="s1">y</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">N</span><span class="s2">-</span><span class="s4">3</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">dx</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">)</span>

            <span class="s1">slice1 </span><span class="s2">= </span><span class="s1">tupleset</span><span class="s2">(</span><span class="s1">slice_all</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, -</span><span class="s4">1</span><span class="s2">)</span>
            <span class="s1">slice2 </span><span class="s2">= </span><span class="s1">tupleset</span><span class="s2">(</span><span class="s1">slice_all</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, -</span><span class="s4">2</span><span class="s2">)</span>
            <span class="s1">slice3 </span><span class="s2">= </span><span class="s1">tupleset</span><span class="s2">(</span><span class="s1">slice_all</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, -</span><span class="s4">3</span><span class="s2">)</span>

            <span class="s1">h </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">([</span><span class="s1">dx</span><span class="s2">, </span><span class="s1">dx</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">x </span><span class="s0">is not None</span><span class="s2">:</span>
                <span class="s6"># grab the last two spacings from the appropriate axis</span>
                <span class="s1">hm2 </span><span class="s2">= </span><span class="s1">tupleset</span><span class="s2">(</span><span class="s1">slice_all</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">slice</span><span class="s2">(-</span><span class="s4">2</span><span class="s2">, -</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">))</span>
                <span class="s1">hm1 </span><span class="s2">= </span><span class="s1">tupleset</span><span class="s2">(</span><span class="s1">slice_all</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">slice</span><span class="s2">(-</span><span class="s4">1</span><span class="s2">, </span><span class="s0">None</span><span class="s2">, </span><span class="s4">1</span><span class="s2">))</span>

                <span class="s1">diffs </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">diff</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s1">axis</span><span class="s2">))</span>
                <span class="s1">h </span><span class="s2">= [</span><span class="s1">np</span><span class="s2">.</span><span class="s1">squeeze</span><span class="s2">(</span><span class="s1">diffs</span><span class="s2">[</span><span class="s1">hm2</span><span class="s2">], </span><span class="s1">axis</span><span class="s2">=</span><span class="s1">axis</span><span class="s2">),</span>
                     <span class="s1">np</span><span class="s2">.</span><span class="s1">squeeze</span><span class="s2">(</span><span class="s1">diffs</span><span class="s2">[</span><span class="s1">hm1</span><span class="s2">], </span><span class="s1">axis</span><span class="s2">=</span><span class="s1">axis</span><span class="s2">)]</span>

            <span class="s6"># This is the correction for the last interval according to</span>
            <span class="s6"># Cartwright.</span>
            <span class="s6"># However, I used the equations given at</span>
            <span class="s6"># https://en.wikipedia.org/wiki/Simpson%27s_rule#Composite_Simpson's_rule_for_irregularly_spaced_data</span>
            <span class="s6"># A footnote on Wikipedia says:</span>
            <span class="s6"># Cartwright 2017, Equation 8. The equation in Cartwright is</span>
            <span class="s6"># calculating the first interval whereas the equations in the</span>
            <span class="s6"># Wikipedia article are adjusting for the last integral. If the</span>
            <span class="s6"># proper algebraic substitutions are made, the equation results in</span>
            <span class="s6"># the values shown.</span>
            <span class="s1">num </span><span class="s2">= </span><span class="s4">2 </span><span class="s2">* </span><span class="s1">h</span><span class="s2">[</span><span class="s4">1</span><span class="s2">] ** </span><span class="s4">2 </span><span class="s2">+ </span><span class="s4">3 </span><span class="s2">* </span><span class="s1">h</span><span class="s2">[</span><span class="s4">0</span><span class="s2">] * </span><span class="s1">h</span><span class="s2">[</span><span class="s4">1</span><span class="s2">]</span>
            <span class="s1">den </span><span class="s2">= </span><span class="s4">6 </span><span class="s2">* (</span><span class="s1">h</span><span class="s2">[</span><span class="s4">1</span><span class="s2">] + </span><span class="s1">h</span><span class="s2">[</span><span class="s4">0</span><span class="s2">])</span>
            <span class="s1">alpha </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">true_divide</span><span class="s2">(</span>
                <span class="s1">num</span><span class="s2">,</span>
                <span class="s1">den</span><span class="s2">,</span>
                <span class="s1">out</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros_like</span><span class="s2">(</span><span class="s1">den</span><span class="s2">),</span>
                <span class="s1">where</span><span class="s2">=</span><span class="s1">den </span><span class="s2">!= </span><span class="s4">0</span>
            <span class="s2">)</span>

            <span class="s1">num </span><span class="s2">= </span><span class="s1">h</span><span class="s2">[</span><span class="s4">1</span><span class="s2">] ** </span><span class="s4">2 </span><span class="s2">+ </span><span class="s4">3.0 </span><span class="s2">* </span><span class="s1">h</span><span class="s2">[</span><span class="s4">0</span><span class="s2">] * </span><span class="s1">h</span><span class="s2">[</span><span class="s4">1</span><span class="s2">]</span>
            <span class="s1">den </span><span class="s2">= </span><span class="s4">6 </span><span class="s2">* </span><span class="s1">h</span><span class="s2">[</span><span class="s4">0</span><span class="s2">]</span>
            <span class="s1">beta </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">true_divide</span><span class="s2">(</span>
                <span class="s1">num</span><span class="s2">,</span>
                <span class="s1">den</span><span class="s2">,</span>
                <span class="s1">out</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros_like</span><span class="s2">(</span><span class="s1">den</span><span class="s2">),</span>
                <span class="s1">where</span><span class="s2">=</span><span class="s1">den </span><span class="s2">!= </span><span class="s4">0</span>
            <span class="s2">)</span>

            <span class="s1">num </span><span class="s2">= </span><span class="s4">1 </span><span class="s2">* </span><span class="s1">h</span><span class="s2">[</span><span class="s4">1</span><span class="s2">] ** </span><span class="s4">3</span>
            <span class="s1">den </span><span class="s2">= </span><span class="s4">6 </span><span class="s2">* </span><span class="s1">h</span><span class="s2">[</span><span class="s4">0</span><span class="s2">] * (</span><span class="s1">h</span><span class="s2">[</span><span class="s4">0</span><span class="s2">] + </span><span class="s1">h</span><span class="s2">[</span><span class="s4">1</span><span class="s2">])</span>
            <span class="s1">eta </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">true_divide</span><span class="s2">(</span>
                <span class="s1">num</span><span class="s2">,</span>
                <span class="s1">den</span><span class="s2">,</span>
                <span class="s1">out</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros_like</span><span class="s2">(</span><span class="s1">den</span><span class="s2">),</span>
                <span class="s1">where</span><span class="s2">=</span><span class="s1">den </span><span class="s2">!= </span><span class="s4">0</span>
            <span class="s2">)</span>

            <span class="s1">result </span><span class="s2">+= </span><span class="s1">alpha</span><span class="s2">*</span><span class="s1">y</span><span class="s2">[</span><span class="s1">slice1</span><span class="s2">] + </span><span class="s1">beta</span><span class="s2">*</span><span class="s1">y</span><span class="s2">[</span><span class="s1">slice2</span><span class="s2">] - </span><span class="s1">eta</span><span class="s2">*</span><span class="s1">y</span><span class="s2">[</span><span class="s1">slice3</span><span class="s2">]</span>

        <span class="s1">result </span><span class="s2">+= </span><span class="s1">val</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">result </span><span class="s2">= </span><span class="s1">_basic_simpson</span><span class="s2">(</span><span class="s1">y</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">N</span><span class="s2">-</span><span class="s4">2</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">dx</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">returnshape</span><span class="s2">:</span>
        <span class="s1">x </span><span class="s2">= </span><span class="s1">x</span><span class="s2">.</span><span class="s1">reshape</span><span class="s2">(</span><span class="s1">saveshape</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">result</span>


<span class="s0">def </span><span class="s1">_cumulatively_sum_simpson_integrals</span><span class="s2">(</span>
    <span class="s1">y</span><span class="s2">: </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">, </span>
    <span class="s1">dx</span><span class="s2">: </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">, </span>
    <span class="s1">integration_func</span><span class="s2">: </span><span class="s1">Callable</span><span class="s2">[[</span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">], </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">],</span>
<span class="s2">) </span><span class="s1">-&gt; np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">:</span>
    <span class="s5">&quot;&quot;&quot;Calculate cumulative sum of Simpson integrals. 
    Takes as input the integration function to be used.  
    The integration_func is assumed to return the cumulative sum using 
    composite Simpson's rule. Assumes the axis of summation is -1. 
    &quot;&quot;&quot;</span>
    <span class="s1">sub_integrals_h1 </span><span class="s2">= </span><span class="s1">integration_func</span><span class="s2">(</span><span class="s1">y</span><span class="s2">, </span><span class="s1">dx</span><span class="s2">)</span>
    <span class="s1">sub_integrals_h2 </span><span class="s2">= </span><span class="s1">integration_func</span><span class="s2">(</span><span class="s1">y</span><span class="s2">[..., ::-</span><span class="s4">1</span><span class="s2">], </span><span class="s1">dx</span><span class="s2">[..., ::-</span><span class="s4">1</span><span class="s2">])[..., ::-</span><span class="s4">1</span><span class="s2">]</span>
    
    <span class="s1">shape </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">sub_integrals_h1</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">)</span>
    <span class="s1">shape</span><span class="s2">[-</span><span class="s4">1</span><span class="s2">] += </span><span class="s4">1</span>
    <span class="s1">sub_integrals </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">(</span><span class="s1">shape</span><span class="s2">)</span>
    <span class="s1">sub_integrals</span><span class="s2">[..., :-</span><span class="s4">1</span><span class="s2">:</span><span class="s4">2</span><span class="s2">] = </span><span class="s1">sub_integrals_h1</span><span class="s2">[..., ::</span><span class="s4">2</span><span class="s2">]</span>
    <span class="s1">sub_integrals</span><span class="s2">[..., </span><span class="s4">1</span><span class="s2">::</span><span class="s4">2</span><span class="s2">] = </span><span class="s1">sub_integrals_h2</span><span class="s2">[..., ::</span><span class="s4">2</span><span class="s2">]</span>
    <span class="s6"># Integral over last subinterval can only be calculated from </span>
    <span class="s6"># formula for h2</span>
    <span class="s1">sub_integrals</span><span class="s2">[..., -</span><span class="s4">1</span><span class="s2">] = </span><span class="s1">sub_integrals_h2</span><span class="s2">[..., -</span><span class="s4">1</span><span class="s2">]</span>
    <span class="s1">res </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">cumsum</span><span class="s2">(</span><span class="s1">sub_integrals</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=-</span><span class="s4">1</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">res</span>


<span class="s0">def </span><span class="s1">_cumulative_simpson_equal_intervals</span><span class="s2">(</span><span class="s1">y</span><span class="s2">: </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">, </span><span class="s1">dx</span><span class="s2">: </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">) </span><span class="s1">-&gt; np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">:</span>
    <span class="s5">&quot;&quot;&quot;Calculate the Simpson integrals for all h1 intervals assuming equal interval 
    widths. The function can also be used to calculate the integral for all 
    h2 intervals by reversing the inputs, `y` and `dx`. 
    &quot;&quot;&quot;</span>
    <span class="s1">d </span><span class="s2">= </span><span class="s1">dx</span><span class="s2">[..., :-</span><span class="s4">1</span><span class="s2">]</span>
    <span class="s1">f1 </span><span class="s2">= </span><span class="s1">y</span><span class="s2">[..., :-</span><span class="s4">2</span><span class="s2">]</span>
    <span class="s1">f2 </span><span class="s2">= </span><span class="s1">y</span><span class="s2">[..., </span><span class="s4">1</span><span class="s2">:-</span><span class="s4">1</span><span class="s2">]</span>
    <span class="s1">f3 </span><span class="s2">= </span><span class="s1">y</span><span class="s2">[..., </span><span class="s4">2</span><span class="s2">:]</span>

    <span class="s6"># Calculate integral over the subintervals (eqn (10) of Reference [2])</span>
    <span class="s0">return </span><span class="s1">d </span><span class="s2">/ </span><span class="s4">3 </span><span class="s2">* (</span><span class="s4">5 </span><span class="s2">* </span><span class="s1">f1 </span><span class="s2">/ </span><span class="s4">4 </span><span class="s2">+ </span><span class="s4">2 </span><span class="s2">* </span><span class="s1">f2 </span><span class="s2">- </span><span class="s1">f3 </span><span class="s2">/ </span><span class="s4">4</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">_cumulative_simpson_unequal_intervals</span><span class="s2">(</span><span class="s1">y</span><span class="s2">: </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">, </span><span class="s1">dx</span><span class="s2">: </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">) </span><span class="s1">-&gt; np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">:</span>
    <span class="s5">&quot;&quot;&quot;Calculate the Simpson integrals for all h1 intervals assuming unequal interval 
    widths. The function can also be used to calculate the integral for all 
    h2 intervals by reversing the inputs, `y` and `dx`. 
    &quot;&quot;&quot;</span>
    <span class="s1">x21 </span><span class="s2">= </span><span class="s1">dx</span><span class="s2">[..., :-</span><span class="s4">1</span><span class="s2">]</span>
    <span class="s1">x32 </span><span class="s2">= </span><span class="s1">dx</span><span class="s2">[..., </span><span class="s4">1</span><span class="s2">:]</span>
    <span class="s1">f1 </span><span class="s2">= </span><span class="s1">y</span><span class="s2">[..., :-</span><span class="s4">2</span><span class="s2">]</span>
    <span class="s1">f2 </span><span class="s2">= </span><span class="s1">y</span><span class="s2">[..., </span><span class="s4">1</span><span class="s2">:-</span><span class="s4">1</span><span class="s2">]</span>
    <span class="s1">f3 </span><span class="s2">= </span><span class="s1">y</span><span class="s2">[..., </span><span class="s4">2</span><span class="s2">:]</span>

    <span class="s1">x31 </span><span class="s2">= </span><span class="s1">x21 </span><span class="s2">+ </span><span class="s1">x32</span>
    <span class="s1">x21_x31 </span><span class="s2">= </span><span class="s1">x21</span><span class="s2">/</span><span class="s1">x31</span>
    <span class="s1">x21_x32 </span><span class="s2">= </span><span class="s1">x21</span><span class="s2">/</span><span class="s1">x32</span>
    <span class="s1">x21x21_x31x32 </span><span class="s2">= </span><span class="s1">x21_x31 </span><span class="s2">* </span><span class="s1">x21_x32</span>

    <span class="s6"># Calculate integral over the subintervals (eqn (8) of Reference [2])</span>
    <span class="s1">coeff1 </span><span class="s2">= </span><span class="s4">3 </span><span class="s2">- </span><span class="s1">x21_x31</span>
    <span class="s1">coeff2 </span><span class="s2">= </span><span class="s4">3 </span><span class="s2">+ </span><span class="s1">x21x21_x31x32 </span><span class="s2">+ </span><span class="s1">x21_x31</span>
    <span class="s1">coeff3 </span><span class="s2">= -</span><span class="s1">x21x21_x31x32</span>

    <span class="s0">return </span><span class="s1">x21</span><span class="s2">/</span><span class="s4">6 </span><span class="s2">* (</span><span class="s1">coeff1</span><span class="s2">*</span><span class="s1">f1 </span><span class="s2">+ </span><span class="s1">coeff2</span><span class="s2">*</span><span class="s1">f2 </span><span class="s2">+ </span><span class="s1">coeff3</span><span class="s2">*</span><span class="s1">f3</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">_ensure_float_array</span><span class="s2">(</span><span class="s1">arr</span><span class="s2">: </span><span class="s1">npt</span><span class="s2">.</span><span class="s1">ArrayLike</span><span class="s2">) </span><span class="s1">-&gt; np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">:</span>
    <span class="s1">arr </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">arr</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">issubdtype</span><span class="s2">(</span><span class="s1">arr</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">integer</span><span class="s2">):</span>
        <span class="s1">arr </span><span class="s2">= </span><span class="s1">arr</span><span class="s2">.</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">float</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">arr</span>


<span class="s0">def </span><span class="s1">cumulative_simpson</span><span class="s2">(</span><span class="s1">y</span><span class="s2">, *, </span><span class="s1">x</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">dx</span><span class="s2">=</span><span class="s4">1.0</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=-</span><span class="s4">1</span><span class="s2">, </span><span class="s1">initial</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
    <span class="s5">r&quot;&quot;&quot; 
    Cumulatively integrate y(x) using the composite Simpson's 1/3 rule. 
    The integral of the samples at every point is calculated by assuming a  
    quadratic relationship between each point and the two adjacent points. 
 
    Parameters 
    ---------- 
    y : array_like 
        Values to integrate. Requires at least one point along `axis`. If two or fewer 
        points are provided along `axis`, Simpson's integration is not possible and the 
        result is calculated with `cumulative_trapezoid`. 
    x : array_like, optional 
        The coordinate to integrate along. Must have the same shape as `y` or 
        must be 1D with the same length as `y` along `axis`. `x` must also be 
        strictly increasing along `axis`. 
        If `x` is None (default), integration is performed using spacing `dx` 
        between consecutive elements in `y`. 
    dx : scalar or array_like, optional 
        Spacing between elements of `y`. Only used if `x` is None. Can either  
        be a float, or an array with the same shape as `y`, but of length one along 
        `axis`. Default is 1.0. 
    axis : int, optional 
        Specifies the axis to integrate along. Default is -1 (last axis). 
    initial : scalar or array_like, optional 
        If given, insert this value at the beginning of the returned result, 
        and add it to the rest of the result. Default is None, which means no 
        value at ``x[0]`` is returned and `res` has one element less than `y` 
        along the axis of integration. Can either be a float, or an array with 
        the same shape as `y`, but of length one along `axis`. 
 
    Returns 
    ------- 
    res : ndarray 
        The result of cumulative integration of `y` along `axis`. 
        If `initial` is None, the shape is such that the axis of integration 
        has one less value than `y`. If `initial` is given, the shape is equal 
        to that of `y`. 
 
    See Also 
    -------- 
    numpy.cumsum 
    cumulative_trapezoid : cumulative integration using the composite  
        trapezoidal rule 
    simpson : integrator for sampled data using the Composite Simpson's Rule 
 
    Notes 
    ----- 
 
    .. versionadded:: 1.12.0 
 
    The composite Simpson's 1/3 method can be used to approximate the definite  
    integral of a sampled input function :math:`y(x)` [1]_. The method assumes  
    a quadratic relationship over the interval containing any three consecutive 
    sampled points. 
 
    Consider three consecutive points:  
    :math:`(x_1, y_1), (x_2, y_2), (x_3, y_3)`. 
 
    Assuming a quadratic relationship over the three points, the integral over 
    the subinterval between :math:`x_1` and :math:`x_2` is given by formula 
    (8) of [2]_: 
     
    .. math:: 
        \int_{x_1}^{x_2} y(x) dx\ &amp;= \frac{x_2-x_1}{6}\left[\ 
        \left\{3-\frac{x_2-x_1}{x_3-x_1}\right\} y_1 + \ 
        \left\{3 + \frac{(x_2-x_1)^2}{(x_3-x_2)(x_3-x_1)} + \ 
        \frac{x_2-x_1}{x_3-x_1}\right\} y_2\\ 
        - \frac{(x_2-x_1)^2}{(x_3-x_2)(x_3-x_1)} y_3\right] 
 
    The integral between :math:`x_2` and :math:`x_3` is given by swapping 
    appearances of :math:`x_1` and :math:`x_3`. The integral is estimated 
    separately for each subinterval and then cumulatively summed to obtain 
    the final result. 
     
    For samples that are equally spaced, the result is exact if the function 
    is a polynomial of order three or less [1]_ and the number of subintervals 
    is even. Otherwise, the integral is exact for polynomials of order two or 
    less.  
 
    References 
    ---------- 
    .. [1] Wikipedia page: https://en.wikipedia.org/wiki/Simpson's_rule 
    .. [2] Cartwright, Kenneth V. Simpson's Rule Cumulative Integration with 
            MS Excel and Irregularly-spaced Data. Journal of Mathematical 
            Sciences and Mathematics Education. 12 (2): 1-9 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy import integrate 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; x = np.linspace(-2, 2, num=20) 
    &gt;&gt;&gt; y = x**2 
    &gt;&gt;&gt; y_int = integrate.cumulative_simpson(y, x=x, initial=0) 
    &gt;&gt;&gt; fig, ax = plt.subplots() 
    &gt;&gt;&gt; ax.plot(x, y_int, 'ro', x, x**3/3 - (x[0])**3/3, 'b-') 
    &gt;&gt;&gt; ax.grid() 
    &gt;&gt;&gt; plt.show() 
 
    The output of `cumulative_simpson` is similar to that of iteratively 
    calling `simpson` with successively higher upper limits of integration, but 
    not identical. 
 
    &gt;&gt;&gt; def cumulative_simpson_reference(y, x): 
    ...     return np.asarray([integrate.simpson(y[:i], x=x[:i]) 
    ...                        for i in range(2, len(y) + 1)]) 
    &gt;&gt;&gt; 
    &gt;&gt;&gt; rng = np.random.default_rng(354673834679465) 
    &gt;&gt;&gt; x, y = rng.random(size=(2, 10)) 
    &gt;&gt;&gt; x.sort() 
    &gt;&gt;&gt; 
    &gt;&gt;&gt; res = integrate.cumulative_simpson(y, x=x) 
    &gt;&gt;&gt; ref = cumulative_simpson_reference(y, x) 
    &gt;&gt;&gt; equal = np.abs(res - ref) &lt; 1e-15 
    &gt;&gt;&gt; equal  # not equal when `simpson` has even number of subintervals 
    array([False,  True, False,  True, False,  True, False,  True,  True]) 
 
    This is expected: because `cumulative_simpson` has access to more 
    information than `simpson`, it can typically produce more accurate 
    estimates of the underlying integral over subintervals. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">y </span><span class="s2">= </span><span class="s1">_ensure_float_array</span><span class="s2">(</span><span class="s1">y</span><span class="s2">)</span>

    <span class="s6"># validate `axis` and standardize to work along the last axis</span>
    <span class="s1">original_y </span><span class="s2">= </span><span class="s1">y</span>
    <span class="s1">original_shape </span><span class="s2">= </span><span class="s1">y</span><span class="s2">.</span><span class="s1">shape</span>
    <span class="s0">try</span><span class="s2">:</span>
        <span class="s1">y </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">swapaxes</span><span class="s2">(</span><span class="s1">y</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, -</span><span class="s4">1</span><span class="s2">)</span>
    <span class="s0">except </span><span class="s1">IndexError </span><span class="s0">as </span><span class="s1">e</span><span class="s2">:</span>
        <span class="s1">message </span><span class="s2">= </span><span class="s3">f&quot;`axis=</span><span class="s0">{</span><span class="s1">axis</span><span class="s0">}</span><span class="s3">` is not valid for `y` with `y.ndim=</span><span class="s0">{</span><span class="s1">y</span><span class="s2">.</span><span class="s1">ndim</span><span class="s0">}</span><span class="s3">`.&quot;</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s1">message</span><span class="s2">) </span><span class="s0">from </span><span class="s1">e</span>
    <span class="s0">if </span><span class="s1">y</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[-</span><span class="s4">1</span><span class="s2">] &lt; </span><span class="s4">3</span><span class="s2">:</span>
        <span class="s1">res </span><span class="s2">= </span><span class="s1">cumulative_trapezoid</span><span class="s2">(</span><span class="s1">original_y</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">dx</span><span class="s2">=</span><span class="s1">dx</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s1">axis</span><span class="s2">, </span><span class="s1">initial</span><span class="s2">=</span><span class="s0">None</span><span class="s2">)</span>
        <span class="s1">res </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">swapaxes</span><span class="s2">(</span><span class="s1">res</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, -</span><span class="s4">1</span><span class="s2">)</span>

    <span class="s0">elif </span><span class="s1">x </span><span class="s0">is not None</span><span class="s2">:</span>
        <span class="s1">x </span><span class="s2">= </span><span class="s1">_ensure_float_array</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)</span>
        <span class="s1">message </span><span class="s2">= (</span><span class="s3">&quot;If given, shape of `x` must be the same as `y` or 1-D with &quot;</span>
                   <span class="s3">&quot;the same length as `y` along `axis`.&quot;</span><span class="s2">)</span>
        <span class="s0">if not </span><span class="s2">(</span><span class="s1">x</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">== </span><span class="s1">original_shape</span>
                <span class="s0">or </span><span class="s2">(</span><span class="s1">x</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s4">1 </span><span class="s0">and </span><span class="s1">len</span><span class="s2">(</span><span class="s1">x</span><span class="s2">) == </span><span class="s1">original_shape</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">])):</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s1">message</span><span class="s2">)</span>

        <span class="s1">x </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">broadcast_to</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">) </span><span class="s0">if </span><span class="s1">x</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s4">1 </span><span class="s0">else </span><span class="s1">np</span><span class="s2">.</span><span class="s1">swapaxes</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, -</span><span class="s4">1</span><span class="s2">)</span>
        <span class="s1">dx </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">diff</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=-</span><span class="s4">1</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">any</span><span class="s2">(</span><span class="s1">dx </span><span class="s2">&lt;= </span><span class="s4">0</span><span class="s2">):</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;Input x must be strictly increasing.&quot;</span><span class="s2">)</span>
        <span class="s1">res </span><span class="s2">= </span><span class="s1">_cumulatively_sum_simpson_integrals</span><span class="s2">(</span>
            <span class="s1">y</span><span class="s2">, </span><span class="s1">dx</span><span class="s2">, </span><span class="s1">_cumulative_simpson_unequal_intervals</span>
        <span class="s2">)</span>

    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">dx </span><span class="s2">= </span><span class="s1">_ensure_float_array</span><span class="s2">(</span><span class="s1">dx</span><span class="s2">)</span>
        <span class="s1">final_dx_shape </span><span class="s2">= </span><span class="s1">tupleset</span><span class="s2">(</span><span class="s1">original_shape</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">original_shape</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">] - </span><span class="s4">1</span><span class="s2">)</span>
        <span class="s1">alt_input_dx_shape </span><span class="s2">= </span><span class="s1">tupleset</span><span class="s2">(</span><span class="s1">original_shape</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, </span><span class="s4">1</span><span class="s2">)</span>
        <span class="s1">message </span><span class="s2">= (</span><span class="s3">&quot;If provided, `dx` must either be a scalar or have the same &quot;</span>
                   <span class="s3">&quot;shape as `y` but with only 1 point along `axis`.&quot;</span><span class="s2">)</span>
        <span class="s0">if not </span><span class="s2">(</span><span class="s1">dx</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s4">0 </span><span class="s0">or </span><span class="s1">dx</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">== </span><span class="s1">alt_input_dx_shape</span><span class="s2">):</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s1">message</span><span class="s2">)</span>
        <span class="s1">dx </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">broadcast_to</span><span class="s2">(</span><span class="s1">dx</span><span class="s2">, </span><span class="s1">final_dx_shape</span><span class="s2">)</span>
        <span class="s1">dx </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">swapaxes</span><span class="s2">(</span><span class="s1">dx</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, -</span><span class="s4">1</span><span class="s2">)</span>
        <span class="s1">res </span><span class="s2">= </span><span class="s1">_cumulatively_sum_simpson_integrals</span><span class="s2">(</span>
            <span class="s1">y</span><span class="s2">, </span><span class="s1">dx</span><span class="s2">, </span><span class="s1">_cumulative_simpson_equal_intervals</span>
        <span class="s2">)</span>

    <span class="s0">if </span><span class="s1">initial </span><span class="s0">is not None</span><span class="s2">:</span>
        <span class="s1">initial </span><span class="s2">= </span><span class="s1">_ensure_float_array</span><span class="s2">(</span><span class="s1">initial</span><span class="s2">)</span>
        <span class="s1">alt_initial_input_shape </span><span class="s2">= </span><span class="s1">tupleset</span><span class="s2">(</span><span class="s1">original_shape</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, </span><span class="s4">1</span><span class="s2">)</span>
        <span class="s1">message </span><span class="s2">= (</span><span class="s3">&quot;If provided, `initial` must either be a scalar or have the &quot;</span>
                   <span class="s3">&quot;same shape as `y` but with only 1 point along `axis`.&quot;</span><span class="s2">)</span>
        <span class="s0">if not </span><span class="s2">(</span><span class="s1">initial</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s4">0 </span><span class="s0">or </span><span class="s1">initial</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">== </span><span class="s1">alt_initial_input_shape</span><span class="s2">):</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s1">message</span><span class="s2">)</span>
        <span class="s1">initial </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">broadcast_to</span><span class="s2">(</span><span class="s1">initial</span><span class="s2">, </span><span class="s1">alt_initial_input_shape</span><span class="s2">)</span>
        <span class="s1">initial </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">swapaxes</span><span class="s2">(</span><span class="s1">initial</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, -</span><span class="s4">1</span><span class="s2">)</span>

        <span class="s1">res </span><span class="s2">+= </span><span class="s1">initial</span>
        <span class="s1">res </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">concatenate</span><span class="s2">((</span><span class="s1">initial</span><span class="s2">, </span><span class="s1">res</span><span class="s2">), </span><span class="s1">axis</span><span class="s2">=-</span><span class="s4">1</span><span class="s2">)</span>

    <span class="s1">res </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">swapaxes</span><span class="s2">(</span><span class="s1">res</span><span class="s2">, -</span><span class="s4">1</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">res</span>


<span class="s0">def </span><span class="s1">romb</span><span class="s2">(</span><span class="s1">y</span><span class="s2">, </span><span class="s1">dx</span><span class="s2">=</span><span class="s4">1.0</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=-</span><span class="s4">1</span><span class="s2">, </span><span class="s1">show</span><span class="s2">=</span><span class="s0">False</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Romberg integration using samples of a function. 
 
    Parameters 
    ---------- 
    y : array_like 
        A vector of ``2**k + 1`` equally-spaced samples of a function. 
    dx : float, optional 
        The sample spacing. Default is 1. 
    axis : int, optional 
        The axis along which to integrate. Default is -1 (last axis). 
    show : bool, optional 
        When `y` is a single 1-D array, then if this argument is True 
        print the table showing Richardson extrapolation from the 
        samples. Default is False. 
 
    Returns 
    ------- 
    romb : ndarray 
        The integrated result for `axis`. 
 
    See Also 
    -------- 
    quad : adaptive quadrature using QUADPACK 
    fixed_quad : fixed-order Gaussian quadrature 
    dblquad : double integrals 
    tplquad : triple integrals 
    simpson : integrators for sampled data 
    cumulative_trapezoid : cumulative integration for sampled data 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy import integrate 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; x = np.arange(10, 14.25, 0.25) 
    &gt;&gt;&gt; y = np.arange(3, 12) 
 
    &gt;&gt;&gt; integrate.romb(y) 
    56.0 
 
    &gt;&gt;&gt; y = np.sin(np.power(x, 2.5)) 
    &gt;&gt;&gt; integrate.romb(y) 
    -0.742561336672229 
 
    &gt;&gt;&gt; integrate.romb(y, show=True) 
    Richardson Extrapolation Table for Romberg Integration 
    ====================================================== 
    -0.81576 
     4.63862  6.45674 
    -1.10581 -3.02062 -3.65245 
    -2.57379 -3.06311 -3.06595 -3.05664 
    -1.34093 -0.92997 -0.78776 -0.75160 -0.74256 
    ====================================================== 
    -0.742561336672229  # may vary 
 
    &quot;&quot;&quot;</span>
    <span class="s1">y </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">y</span><span class="s2">)</span>
    <span class="s1">nd </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">y</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">)</span>
    <span class="s1">Nsamps </span><span class="s2">= </span><span class="s1">y</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">]</span>
    <span class="s1">Ninterv </span><span class="s2">= </span><span class="s1">Nsamps</span><span class="s2">-</span><span class="s4">1</span>
    <span class="s1">n </span><span class="s2">= </span><span class="s4">1</span>
    <span class="s1">k </span><span class="s2">= </span><span class="s4">0</span>
    <span class="s0">while </span><span class="s1">n </span><span class="s2">&lt; </span><span class="s1">Ninterv</span><span class="s2">:</span>
        <span class="s1">n </span><span class="s2">&lt;&lt;= </span><span class="s4">1</span>
        <span class="s1">k </span><span class="s2">+= </span><span class="s4">1</span>
    <span class="s0">if </span><span class="s1">n </span><span class="s2">!= </span><span class="s1">Ninterv</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;Number of samples must be one plus a &quot;</span>
                         <span class="s3">&quot;non-negative power of 2.&quot;</span><span class="s2">)</span>

    <span class="s1">R </span><span class="s2">= {}</span>
    <span class="s1">slice_all </span><span class="s2">= (</span><span class="s1">slice</span><span class="s2">(</span><span class="s0">None</span><span class="s2">),) * </span><span class="s1">nd</span>
    <span class="s1">slice0 </span><span class="s2">= </span><span class="s1">tupleset</span><span class="s2">(</span><span class="s1">slice_all</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, </span><span class="s4">0</span><span class="s2">)</span>
    <span class="s1">slicem1 </span><span class="s2">= </span><span class="s1">tupleset</span><span class="s2">(</span><span class="s1">slice_all</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, -</span><span class="s4">1</span><span class="s2">)</span>
    <span class="s1">h </span><span class="s2">= </span><span class="s1">Ninterv </span><span class="s2">* </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">dx</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">float</span><span class="s2">)</span>
    <span class="s1">R</span><span class="s2">[(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">)] = (</span><span class="s1">y</span><span class="s2">[</span><span class="s1">slice0</span><span class="s2">] + </span><span class="s1">y</span><span class="s2">[</span><span class="s1">slicem1</span><span class="s2">])/</span><span class="s4">2.0</span><span class="s2">*</span><span class="s1">h</span>
    <span class="s1">slice_R </span><span class="s2">= </span><span class="s1">slice_all</span>
    <span class="s1">start </span><span class="s2">= </span><span class="s1">stop </span><span class="s2">= </span><span class="s1">step </span><span class="s2">= </span><span class="s1">Ninterv</span>
    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">k</span><span class="s2">+</span><span class="s4">1</span><span class="s2">):</span>
        <span class="s1">start </span><span class="s2">&gt;&gt;= </span><span class="s4">1</span>
        <span class="s1">slice_R </span><span class="s2">= </span><span class="s1">tupleset</span><span class="s2">(</span><span class="s1">slice_R</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">slice</span><span class="s2">(</span><span class="s1">start</span><span class="s2">, </span><span class="s1">stop</span><span class="s2">, </span><span class="s1">step</span><span class="s2">))</span>
        <span class="s1">step </span><span class="s2">&gt;&gt;= </span><span class="s4">1</span>
        <span class="s1">R</span><span class="s2">[(</span><span class="s1">i</span><span class="s2">, </span><span class="s4">0</span><span class="s2">)] = </span><span class="s4">0.5</span><span class="s2">*(</span><span class="s1">R</span><span class="s2">[(</span><span class="s1">i</span><span class="s2">-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">)] + </span><span class="s1">h</span><span class="s2">*</span><span class="s1">y</span><span class="s2">[</span><span class="s1">slice_R</span><span class="s2">].</span><span class="s1">sum</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">=</span><span class="s1">axis</span><span class="s2">))</span>
        <span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">i</span><span class="s2">+</span><span class="s4">1</span><span class="s2">):</span>
            <span class="s1">prev </span><span class="s2">= </span><span class="s1">R</span><span class="s2">[(</span><span class="s1">i</span><span class="s2">, </span><span class="s1">j</span><span class="s2">-</span><span class="s4">1</span><span class="s2">)]</span>
            <span class="s1">R</span><span class="s2">[(</span><span class="s1">i</span><span class="s2">, </span><span class="s1">j</span><span class="s2">)] = </span><span class="s1">prev </span><span class="s2">+ (</span><span class="s1">prev</span><span class="s2">-</span><span class="s1">R</span><span class="s2">[(</span><span class="s1">i</span><span class="s2">-</span><span class="s4">1</span><span class="s2">, </span><span class="s1">j</span><span class="s2">-</span><span class="s4">1</span><span class="s2">)]) / ((</span><span class="s4">1 </span><span class="s2">&lt;&lt; (</span><span class="s4">2</span><span class="s2">*</span><span class="s1">j</span><span class="s2">))-</span><span class="s4">1</span><span class="s2">)</span>
        <span class="s1">h </span><span class="s2">/= </span><span class="s4">2.0</span>

    <span class="s0">if </span><span class="s1">show</span><span class="s2">:</span>
        <span class="s0">if not </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isscalar</span><span class="s2">(</span><span class="s1">R</span><span class="s2">[(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">)]):</span>
            <span class="s1">print</span><span class="s2">(</span><span class="s3">&quot;*** Printing table only supported for integrals&quot; </span><span class="s2">+</span>
                  <span class="s3">&quot; of a single data set.&quot;</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">try</span><span class="s2">:</span>
                <span class="s1">precis </span><span class="s2">= </span><span class="s1">show</span><span class="s2">[</span><span class="s4">0</span><span class="s2">]</span>
            <span class="s0">except </span><span class="s2">(</span><span class="s1">TypeError</span><span class="s2">, </span><span class="s1">IndexError</span><span class="s2">):</span>
                <span class="s1">precis </span><span class="s2">= </span><span class="s4">5</span>
            <span class="s0">try</span><span class="s2">:</span>
                <span class="s1">width </span><span class="s2">= </span><span class="s1">show</span><span class="s2">[</span><span class="s4">1</span><span class="s2">]</span>
            <span class="s0">except </span><span class="s2">(</span><span class="s1">TypeError</span><span class="s2">, </span><span class="s1">IndexError</span><span class="s2">):</span>
                <span class="s1">width </span><span class="s2">= </span><span class="s4">8</span>
            <span class="s1">formstr </span><span class="s2">= </span><span class="s3">&quot;%%%d.%df&quot; </span><span class="s2">% (</span><span class="s1">width</span><span class="s2">, </span><span class="s1">precis</span><span class="s2">)</span>

            <span class="s1">title </span><span class="s2">= </span><span class="s3">&quot;Richardson Extrapolation Table for Romberg Integration&quot;</span>
            <span class="s1">print</span><span class="s2">(</span><span class="s1">title</span><span class="s2">, </span><span class="s3">&quot;=&quot; </span><span class="s2">* </span><span class="s1">len</span><span class="s2">(</span><span class="s1">title</span><span class="s2">), </span><span class="s1">sep</span><span class="s2">=</span><span class="s3">&quot;</span><span class="s0">\n</span><span class="s3">&quot;</span><span class="s2">, </span><span class="s1">end</span><span class="s2">=</span><span class="s3">&quot;</span><span class="s0">\n</span><span class="s3">&quot;</span><span class="s2">)</span>
            <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">k</span><span class="s2">+</span><span class="s4">1</span><span class="s2">):</span>
                <span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">i</span><span class="s2">+</span><span class="s4">1</span><span class="s2">):</span>
                    <span class="s1">print</span><span class="s2">(</span><span class="s1">formstr </span><span class="s2">% </span><span class="s1">R</span><span class="s2">[(</span><span class="s1">i</span><span class="s2">, </span><span class="s1">j</span><span class="s2">)], </span><span class="s1">end</span><span class="s2">=</span><span class="s3">&quot; &quot;</span><span class="s2">)</span>
                <span class="s1">print</span><span class="s2">()</span>
            <span class="s1">print</span><span class="s2">(</span><span class="s3">&quot;=&quot; </span><span class="s2">* </span><span class="s1">len</span><span class="s2">(</span><span class="s1">title</span><span class="s2">))</span>

    <span class="s0">return </span><span class="s1">R</span><span class="s2">[(</span><span class="s1">k</span><span class="s2">, </span><span class="s1">k</span><span class="s2">)]</span>

<span class="s6"># Romberg quadratures for numeric integration.</span>
<span class="s6">#</span>
<span class="s6"># Written by Scott M. Ransom &lt;ransom@cfa.harvard.edu&gt;</span>
<span class="s6"># last revision: 14 Nov 98</span>
<span class="s6">#</span>
<span class="s6"># Cosmetic changes by Konrad Hinsen &lt;hinsen@cnrs-orleans.fr&gt;</span>
<span class="s6"># last revision: 1999-7-21</span>
<span class="s6">#</span>
<span class="s6"># Adapted to SciPy by Travis Oliphant &lt;oliphant.travis@ieee.org&gt;</span>
<span class="s6"># last revision: Dec 2001</span>


<span class="s0">def </span><span class="s1">_difftrap</span><span class="s2">(</span><span class="s1">function</span><span class="s2">, </span><span class="s1">interval</span><span class="s2">, </span><span class="s1">numtraps</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Perform part of the trapezoidal rule to integrate a function. 
    Assume that we had called difftrap with all lower powers-of-2 
    starting with 1. Calling difftrap only returns the summation 
    of the new ordinates. It does _not_ multiply by the width 
    of the trapezoids. This must be performed by the caller. 
        'function' is the function to evaluate (must accept vector arguments). 
        'interval' is a sequence with lower and upper limits 
                   of integration. 
        'numtraps' is the number of trapezoids to use (must be a 
                   power-of-2). 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">numtraps </span><span class="s2">&lt;= </span><span class="s4">0</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;numtraps must be &gt; 0 in difftrap().&quot;</span><span class="s2">)</span>
    <span class="s0">elif </span><span class="s1">numtraps </span><span class="s2">== </span><span class="s4">1</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s4">0.5</span><span class="s2">*(</span><span class="s1">function</span><span class="s2">(</span><span class="s1">interval</span><span class="s2">[</span><span class="s4">0</span><span class="s2">])+</span><span class="s1">function</span><span class="s2">(</span><span class="s1">interval</span><span class="s2">[</span><span class="s4">1</span><span class="s2">]))</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">numtosum </span><span class="s2">= </span><span class="s1">numtraps</span><span class="s2">/</span><span class="s4">2</span>
        <span class="s1">h </span><span class="s2">= </span><span class="s1">float</span><span class="s2">(</span><span class="s1">interval</span><span class="s2">[</span><span class="s4">1</span><span class="s2">]-</span><span class="s1">interval</span><span class="s2">[</span><span class="s4">0</span><span class="s2">])/</span><span class="s1">numtosum</span>
        <span class="s1">lox </span><span class="s2">= </span><span class="s1">interval</span><span class="s2">[</span><span class="s4">0</span><span class="s2">] + </span><span class="s4">0.5 </span><span class="s2">* </span><span class="s1">h</span>
        <span class="s1">points </span><span class="s2">= </span><span class="s1">lox </span><span class="s2">+ </span><span class="s1">h </span><span class="s2">* </span><span class="s1">np</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(</span><span class="s1">numtosum</span><span class="s2">)</span>
        <span class="s1">s </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sum</span><span class="s2">(</span><span class="s1">function</span><span class="s2">(</span><span class="s1">points</span><span class="s2">), </span><span class="s1">axis</span><span class="s2">=</span><span class="s4">0</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">s</span>


<span class="s0">def </span><span class="s1">_romberg_diff</span><span class="s2">(</span><span class="s1">b</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">k</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Compute the differences for the Romberg quadrature corrections. 
    See Forman Acton's &quot;Real Computing Made Real,&quot; p 143. 
    &quot;&quot;&quot;</span>
    <span class="s1">tmp </span><span class="s2">= </span><span class="s4">4.0</span><span class="s2">**</span><span class="s1">k</span>
    <span class="s0">return </span><span class="s2">(</span><span class="s1">tmp </span><span class="s2">* </span><span class="s1">c </span><span class="s2">- </span><span class="s1">b</span><span class="s2">)/(</span><span class="s1">tmp </span><span class="s2">- </span><span class="s4">1.0</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">_printresmat</span><span class="s2">(</span><span class="s1">function</span><span class="s2">, </span><span class="s1">interval</span><span class="s2">, </span><span class="s1">resmat</span><span class="s2">):</span>
    <span class="s6"># Print the Romberg result matrix.</span>
    <span class="s1">i </span><span class="s2">= </span><span class="s1">j </span><span class="s2">= </span><span class="s4">0</span>
    <span class="s1">print</span><span class="s2">(</span><span class="s3">'Romberg integration of'</span><span class="s2">, </span><span class="s1">repr</span><span class="s2">(</span><span class="s1">function</span><span class="s2">), </span><span class="s1">end</span><span class="s2">=</span><span class="s3">' '</span><span class="s2">)</span>
    <span class="s1">print</span><span class="s2">(</span><span class="s3">'from'</span><span class="s2">, </span><span class="s1">interval</span><span class="s2">)</span>
    <span class="s1">print</span><span class="s2">(</span><span class="s3">''</span><span class="s2">)</span>
    <span class="s1">print</span><span class="s2">(</span><span class="s3">'%6s %9s %9s' </span><span class="s2">% (</span><span class="s3">'Steps'</span><span class="s2">, </span><span class="s3">'StepSize'</span><span class="s2">, </span><span class="s3">'Results'</span><span class="s2">))</span>
    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">resmat</span><span class="s2">)):</span>
        <span class="s1">print</span><span class="s2">(</span><span class="s3">'%6d %9f' </span><span class="s2">% (</span><span class="s4">2</span><span class="s2">**</span><span class="s1">i</span><span class="s2">, (</span><span class="s1">interval</span><span class="s2">[</span><span class="s4">1</span><span class="s2">]-</span><span class="s1">interval</span><span class="s2">[</span><span class="s4">0</span><span class="s2">])/(</span><span class="s4">2.</span><span class="s2">**</span><span class="s1">i</span><span class="s2">)), </span><span class="s1">end</span><span class="s2">=</span><span class="s3">' '</span><span class="s2">)</span>
        <span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">i</span><span class="s2">+</span><span class="s4">1</span><span class="s2">):</span>
            <span class="s1">print</span><span class="s2">(</span><span class="s3">'%9f' </span><span class="s2">% (</span><span class="s1">resmat</span><span class="s2">[</span><span class="s1">i</span><span class="s2">][</span><span class="s1">j</span><span class="s2">]), </span><span class="s1">end</span><span class="s2">=</span><span class="s3">' '</span><span class="s2">)</span>
        <span class="s1">print</span><span class="s2">(</span><span class="s3">''</span><span class="s2">)</span>
    <span class="s1">print</span><span class="s2">(</span><span class="s3">''</span><span class="s2">)</span>
    <span class="s1">print</span><span class="s2">(</span><span class="s3">'The final result is'</span><span class="s2">, </span><span class="s1">resmat</span><span class="s2">[</span><span class="s1">i</span><span class="s2">][</span><span class="s1">j</span><span class="s2">], </span><span class="s1">end</span><span class="s2">=</span><span class="s3">' '</span><span class="s2">)</span>
    <span class="s1">print</span><span class="s2">(</span><span class="s3">'after'</span><span class="s2">, </span><span class="s4">2</span><span class="s2">**(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">resmat</span><span class="s2">)-</span><span class="s4">1</span><span class="s2">)+</span><span class="s4">1</span><span class="s2">, </span><span class="s3">'function evaluations.'</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">_deprecated</span><span class="s2">(</span><span class="s3">&quot;`scipy.integrate.romberg` is deprecated as of SciPy 1.12.0&quot;</span>
             <span class="s3">&quot;and will be removed in SciPy 1.15.0. Please use&quot;</span>
             <span class="s3">&quot;`scipy.integrate.quad` instead.&quot;</span><span class="s2">)</span>
<span class="s0">def </span><span class="s1">romberg</span><span class="s2">(</span><span class="s1">function</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">args</span><span class="s2">=(), </span><span class="s1">tol</span><span class="s2">=</span><span class="s4">1.48e-8</span><span class="s2">, </span><span class="s1">rtol</span><span class="s2">=</span><span class="s4">1.48e-8</span><span class="s2">, </span><span class="s1">show</span><span class="s2">=</span><span class="s0">False</span><span class="s2">,</span>
            <span class="s1">divmax</span><span class="s2">=</span><span class="s4">10</span><span class="s2">, </span><span class="s1">vec_func</span><span class="s2">=</span><span class="s0">False</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Romberg integration of a callable function or method. 
 
    .. deprecated:: 1.12.0 
 
          This function is deprecated as of SciPy 1.12.0 and will be removed 
          in SciPy 1.15.0. Please use `scipy.integrate.quad` instead. 
 
    Returns the integral of `function` (a function of one variable) 
    over the interval (`a`, `b`). 
 
    If `show` is 1, the triangular array of the intermediate results 
    will be printed. If `vec_func` is True (default is False), then 
    `function` is assumed to support vector arguments. 
 
    Parameters 
    ---------- 
    function : callable 
        Function to be integrated. 
    a : float 
        Lower limit of integration. 
    b : float 
        Upper limit of integration. 
 
    Returns 
    ------- 
    results : float 
        Result of the integration. 
 
    Other Parameters 
    ---------------- 
    args : tuple, optional 
        Extra arguments to pass to function. Each element of `args` will 
        be passed as a single argument to `func`. Default is to pass no 
        extra arguments. 
    tol, rtol : float, optional 
        The desired absolute and relative tolerances. Defaults are 1.48e-8. 
    show : bool, optional 
        Whether to print the results. Default is False. 
    divmax : int, optional 
        Maximum order of extrapolation. Default is 10. 
    vec_func : bool, optional 
        Whether `func` handles arrays as arguments (i.e., whether it is a 
        &quot;vector&quot; function). Default is False. 
 
    See Also 
    -------- 
    fixed_quad : Fixed-order Gaussian quadrature. 
    quad : Adaptive quadrature using QUADPACK. 
    dblquad : Double integrals. 
    tplquad : Triple integrals. 
    romb : Integrators for sampled data. 
    simpson : Integrators for sampled data. 
    cumulative_trapezoid : Cumulative integration for sampled data. 
 
    References 
    ---------- 
    .. [1] 'Romberg's method' https://en.wikipedia.org/wiki/Romberg%27s_method 
 
    Examples 
    -------- 
    Integrate a gaussian from 0 to 1 and compare to the error function. 
 
    &gt;&gt;&gt; from scipy import integrate 
    &gt;&gt;&gt; from scipy.special import erf 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; gaussian = lambda x: 1/np.sqrt(np.pi) * np.exp(-x**2) 
    &gt;&gt;&gt; result = integrate.romberg(gaussian, 0, 1, show=True) 
    Romberg integration of &lt;function vfunc at ...&gt; from [0, 1] 
 
    :: 
 
       Steps  StepSize  Results 
           1  1.000000  0.385872 
           2  0.500000  0.412631  0.421551 
           4  0.250000  0.419184  0.421368  0.421356 
           8  0.125000  0.420810  0.421352  0.421350  0.421350 
          16  0.062500  0.421215  0.421350  0.421350  0.421350  0.421350 
          32  0.031250  0.421317  0.421350  0.421350  0.421350  0.421350  0.421350 
 
    The final result is 0.421350396475 after 33 function evaluations. 
 
    &gt;&gt;&gt; print(&quot;%g %g&quot; % (2*result, erf(1))) 
    0.842701 0.842701 
 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isinf</span><span class="s2">(</span><span class="s1">a</span><span class="s2">) </span><span class="s0">or </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isinf</span><span class="s2">(</span><span class="s1">b</span><span class="s2">):</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;Romberg integration only available &quot;</span>
                         <span class="s3">&quot;for finite limits.&quot;</span><span class="s2">)</span>
    <span class="s1">vfunc </span><span class="s2">= </span><span class="s1">vectorize1</span><span class="s2">(</span><span class="s1">function</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">vec_func</span><span class="s2">=</span><span class="s1">vec_func</span><span class="s2">)</span>
    <span class="s1">n </span><span class="s2">= </span><span class="s4">1</span>
    <span class="s1">interval </span><span class="s2">= [</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">]</span>
    <span class="s1">intrange </span><span class="s2">= </span><span class="s1">b </span><span class="s2">- </span><span class="s1">a</span>
    <span class="s1">ordsum </span><span class="s2">= </span><span class="s1">_difftrap</span><span class="s2">(</span><span class="s1">vfunc</span><span class="s2">, </span><span class="s1">interval</span><span class="s2">, </span><span class="s1">n</span><span class="s2">)</span>
    <span class="s1">result </span><span class="s2">= </span><span class="s1">intrange </span><span class="s2">* </span><span class="s1">ordsum</span>
    <span class="s1">resmat </span><span class="s2">= [[</span><span class="s1">result</span><span class="s2">]]</span>
    <span class="s1">err </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span>
    <span class="s1">last_row </span><span class="s2">= </span><span class="s1">resmat</span><span class="s2">[</span><span class="s4">0</span><span class="s2">]</span>
    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">divmax</span><span class="s2">+</span><span class="s4">1</span><span class="s2">):</span>
        <span class="s1">n </span><span class="s2">*= </span><span class="s4">2</span>
        <span class="s1">ordsum </span><span class="s2">+= </span><span class="s1">_difftrap</span><span class="s2">(</span><span class="s1">vfunc</span><span class="s2">, </span><span class="s1">interval</span><span class="s2">, </span><span class="s1">n</span><span class="s2">)</span>
        <span class="s1">row </span><span class="s2">= [</span><span class="s1">intrange </span><span class="s2">* </span><span class="s1">ordsum </span><span class="s2">/ </span><span class="s1">n</span><span class="s2">]</span>
        <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">i</span><span class="s2">):</span>
            <span class="s1">row</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">_romberg_diff</span><span class="s2">(</span><span class="s1">last_row</span><span class="s2">[</span><span class="s1">k</span><span class="s2">], </span><span class="s1">row</span><span class="s2">[</span><span class="s1">k</span><span class="s2">], </span><span class="s1">k</span><span class="s2">+</span><span class="s4">1</span><span class="s2">))</span>
        <span class="s1">result </span><span class="s2">= </span><span class="s1">row</span><span class="s2">[</span><span class="s1">i</span><span class="s2">]</span>
        <span class="s1">lastresult </span><span class="s2">= </span><span class="s1">last_row</span><span class="s2">[</span><span class="s1">i</span><span class="s2">-</span><span class="s4">1</span><span class="s2">]</span>
        <span class="s0">if </span><span class="s1">show</span><span class="s2">:</span>
            <span class="s1">resmat</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">row</span><span class="s2">)</span>
        <span class="s1">err </span><span class="s2">= </span><span class="s1">abs</span><span class="s2">(</span><span class="s1">result </span><span class="s2">- </span><span class="s1">lastresult</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">err </span><span class="s2">&lt; </span><span class="s1">tol </span><span class="s0">or </span><span class="s1">err </span><span class="s2">&lt; </span><span class="s1">rtol </span><span class="s2">* </span><span class="s1">abs</span><span class="s2">(</span><span class="s1">result</span><span class="s2">):</span>
            <span class="s0">break</span>
        <span class="s1">last_row </span><span class="s2">= </span><span class="s1">row</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span>
            <span class="s3">&quot;divmax (%d) exceeded. Latest difference = %e&quot; </span><span class="s2">% (</span><span class="s1">divmax</span><span class="s2">, </span><span class="s1">err</span><span class="s2">),</span>
            <span class="s1">AccuracyWarning</span><span class="s2">, </span><span class="s1">stacklevel</span><span class="s2">=</span><span class="s4">2</span><span class="s2">)</span>

    <span class="s0">if </span><span class="s1">show</span><span class="s2">:</span>
        <span class="s1">_printresmat</span><span class="s2">(</span><span class="s1">vfunc</span><span class="s2">, </span><span class="s1">interval</span><span class="s2">, </span><span class="s1">resmat</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">result</span>


<span class="s6"># Coefficients for Newton-Cotes quadrature</span>
<span class="s6">#</span>
<span class="s6"># These are the points being used</span>
<span class="s6">#  to construct the local interpolating polynomial</span>
<span class="s6">#  a are the weights for Newton-Cotes integration</span>
<span class="s6">#  B is the error coefficient.</span>
<span class="s6">#  error in these coefficients grows as N gets larger.</span>
<span class="s6">#  or as samples are closer and closer together</span>

<span class="s6"># You can use maxima to find these rational coefficients</span>
<span class="s6">#  for equally spaced data using the commands</span>
<span class="s6">#  a(i,N) := (integrate(product(r-j,j,0,i-1) * product(r-j,j,i+1,N),r,0,N)</span>
<span class="s6">#             / ((N-i)! * i!) * (-1)^(N-i));</span>
<span class="s6">#  Be(N) := N^(N+2)/(N+2)! * (N/(N+3) - sum((i/N)^(N+2)*a(i,N),i,0,N));</span>
<span class="s6">#  Bo(N) := N^(N+1)/(N+1)! * (N/(N+2) - sum((i/N)^(N+1)*a(i,N),i,0,N));</span>
<span class="s6">#  B(N) := (if (mod(N,2)=0) then Be(N) else Bo(N));</span>
<span class="s6">#</span>
<span class="s6"># pre-computed for equally-spaced weights</span>
<span class="s6">#</span>
<span class="s6"># num_a, den_a, int_a, num_B, den_B = _builtincoeffs[N]</span>
<span class="s6">#</span>
<span class="s6">#  a = num_a*array(int_a)/den_a</span>
<span class="s6">#  B = num_B*1.0 / den_B</span>
<span class="s6">#</span>
<span class="s6">#  integrate(f(x),x,x_0,x_N) = dx*sum(a*f(x_i)) + B*(dx)^(2k+3) f^(2k+2)(x*)</span>
<span class="s6">#    where k = N // 2</span>
<span class="s6">#</span>
<span class="s1">_builtincoeffs </span><span class="s2">= {</span>
    <span class="s4">1</span><span class="s2">: (</span><span class="s4">1</span><span class="s2">,</span><span class="s4">2</span><span class="s2">,[</span><span class="s4">1</span><span class="s2">,</span><span class="s4">1</span><span class="s2">],-</span><span class="s4">1</span><span class="s2">,</span><span class="s4">12</span><span class="s2">),</span>
    <span class="s4">2</span><span class="s2">: (</span><span class="s4">1</span><span class="s2">,</span><span class="s4">3</span><span class="s2">,[</span><span class="s4">1</span><span class="s2">,</span><span class="s4">4</span><span class="s2">,</span><span class="s4">1</span><span class="s2">],-</span><span class="s4">1</span><span class="s2">,</span><span class="s4">90</span><span class="s2">),</span>
    <span class="s4">3</span><span class="s2">: (</span><span class="s4">3</span><span class="s2">,</span><span class="s4">8</span><span class="s2">,[</span><span class="s4">1</span><span class="s2">,</span><span class="s4">3</span><span class="s2">,</span><span class="s4">3</span><span class="s2">,</span><span class="s4">1</span><span class="s2">],-</span><span class="s4">3</span><span class="s2">,</span><span class="s4">80</span><span class="s2">),</span>
    <span class="s4">4</span><span class="s2">: (</span><span class="s4">2</span><span class="s2">,</span><span class="s4">45</span><span class="s2">,[</span><span class="s4">7</span><span class="s2">,</span><span class="s4">32</span><span class="s2">,</span><span class="s4">12</span><span class="s2">,</span><span class="s4">32</span><span class="s2">,</span><span class="s4">7</span><span class="s2">],-</span><span class="s4">8</span><span class="s2">,</span><span class="s4">945</span><span class="s2">),</span>
    <span class="s4">5</span><span class="s2">: (</span><span class="s4">5</span><span class="s2">,</span><span class="s4">288</span><span class="s2">,[</span><span class="s4">19</span><span class="s2">,</span><span class="s4">75</span><span class="s2">,</span><span class="s4">50</span><span class="s2">,</span><span class="s4">50</span><span class="s2">,</span><span class="s4">75</span><span class="s2">,</span><span class="s4">19</span><span class="s2">],-</span><span class="s4">275</span><span class="s2">,</span><span class="s4">12096</span><span class="s2">),</span>
    <span class="s4">6</span><span class="s2">: (</span><span class="s4">1</span><span class="s2">,</span><span class="s4">140</span><span class="s2">,[</span><span class="s4">41</span><span class="s2">,</span><span class="s4">216</span><span class="s2">,</span><span class="s4">27</span><span class="s2">,</span><span class="s4">272</span><span class="s2">,</span><span class="s4">27</span><span class="s2">,</span><span class="s4">216</span><span class="s2">,</span><span class="s4">41</span><span class="s2">],-</span><span class="s4">9</span><span class="s2">,</span><span class="s4">1400</span><span class="s2">),</span>
    <span class="s4">7</span><span class="s2">: (</span><span class="s4">7</span><span class="s2">,</span><span class="s4">17280</span><span class="s2">,[</span><span class="s4">751</span><span class="s2">,</span><span class="s4">3577</span><span class="s2">,</span><span class="s4">1323</span><span class="s2">,</span><span class="s4">2989</span><span class="s2">,</span><span class="s4">2989</span><span class="s2">,</span><span class="s4">1323</span><span class="s2">,</span><span class="s4">3577</span><span class="s2">,</span><span class="s4">751</span><span class="s2">],-</span><span class="s4">8183</span><span class="s2">,</span><span class="s4">518400</span><span class="s2">),</span>
    <span class="s4">8</span><span class="s2">: (</span><span class="s4">4</span><span class="s2">,</span><span class="s4">14175</span><span class="s2">,[</span><span class="s4">989</span><span class="s2">,</span><span class="s4">5888</span><span class="s2">,-</span><span class="s4">928</span><span class="s2">,</span><span class="s4">10496</span><span class="s2">,-</span><span class="s4">4540</span><span class="s2">,</span><span class="s4">10496</span><span class="s2">,-</span><span class="s4">928</span><span class="s2">,</span><span class="s4">5888</span><span class="s2">,</span><span class="s4">989</span><span class="s2">],</span>
        <span class="s2">-</span><span class="s4">2368</span><span class="s2">,</span><span class="s4">467775</span><span class="s2">),</span>
    <span class="s4">9</span><span class="s2">: (</span><span class="s4">9</span><span class="s2">,</span><span class="s4">89600</span><span class="s2">,[</span><span class="s4">2857</span><span class="s2">,</span><span class="s4">15741</span><span class="s2">,</span><span class="s4">1080</span><span class="s2">,</span><span class="s4">19344</span><span class="s2">,</span><span class="s4">5778</span><span class="s2">,</span><span class="s4">5778</span><span class="s2">,</span><span class="s4">19344</span><span class="s2">,</span><span class="s4">1080</span><span class="s2">,</span>
                 <span class="s4">15741</span><span class="s2">,</span><span class="s4">2857</span><span class="s2">], -</span><span class="s4">4671</span><span class="s2">, </span><span class="s4">394240</span><span class="s2">),</span>
    <span class="s4">10</span><span class="s2">: (</span><span class="s4">5</span><span class="s2">,</span><span class="s4">299376</span><span class="s2">,[</span><span class="s4">16067</span><span class="s2">,</span><span class="s4">106300</span><span class="s2">,-</span><span class="s4">48525</span><span class="s2">,</span><span class="s4">272400</span><span class="s2">,-</span><span class="s4">260550</span><span class="s2">,</span><span class="s4">427368</span><span class="s2">,</span>
                   <span class="s2">-</span><span class="s4">260550</span><span class="s2">,</span><span class="s4">272400</span><span class="s2">,-</span><span class="s4">48525</span><span class="s2">,</span><span class="s4">106300</span><span class="s2">,</span><span class="s4">16067</span><span class="s2">],</span>
         <span class="s2">-</span><span class="s4">673175</span><span class="s2">, </span><span class="s4">163459296</span><span class="s2">),</span>
    <span class="s4">11</span><span class="s2">: (</span><span class="s4">11</span><span class="s2">,</span><span class="s4">87091200</span><span class="s2">,[</span><span class="s4">2171465</span><span class="s2">,</span><span class="s4">13486539</span><span class="s2">,-</span><span class="s4">3237113</span><span class="s2">, </span><span class="s4">25226685</span><span class="s2">,-</span><span class="s4">9595542</span><span class="s2">,</span>
                      <span class="s4">15493566</span><span class="s2">,</span><span class="s4">15493566</span><span class="s2">,-</span><span class="s4">9595542</span><span class="s2">,</span><span class="s4">25226685</span><span class="s2">,-</span><span class="s4">3237113</span><span class="s2">,</span>
                      <span class="s4">13486539</span><span class="s2">,</span><span class="s4">2171465</span><span class="s2">], -</span><span class="s4">2224234463</span><span class="s2">, </span><span class="s4">237758976000</span><span class="s2">),</span>
    <span class="s4">12</span><span class="s2">: (</span><span class="s4">1</span><span class="s2">, </span><span class="s4">5255250</span><span class="s2">, [</span><span class="s4">1364651</span><span class="s2">,</span><span class="s4">9903168</span><span class="s2">,-</span><span class="s4">7587864</span><span class="s2">,</span><span class="s4">35725120</span><span class="s2">,-</span><span class="s4">51491295</span><span class="s2">,</span>
                      <span class="s4">87516288</span><span class="s2">,-</span><span class="s4">87797136</span><span class="s2">,</span><span class="s4">87516288</span><span class="s2">,-</span><span class="s4">51491295</span><span class="s2">,</span><span class="s4">35725120</span><span class="s2">,</span>
                      <span class="s2">-</span><span class="s4">7587864</span><span class="s2">,</span><span class="s4">9903168</span><span class="s2">,</span><span class="s4">1364651</span><span class="s2">], -</span><span class="s4">3012</span><span class="s2">, </span><span class="s4">875875</span><span class="s2">),</span>
    <span class="s4">13</span><span class="s2">: (</span><span class="s4">13</span><span class="s2">, </span><span class="s4">402361344000</span><span class="s2">,[</span><span class="s4">8181904909</span><span class="s2">, </span><span class="s4">56280729661</span><span class="s2">, -</span><span class="s4">31268252574</span><span class="s2">,</span>
                           <span class="s4">156074417954</span><span class="s2">,-</span><span class="s4">151659573325</span><span class="s2">,</span><span class="s4">206683437987</span><span class="s2">,</span>
                           <span class="s2">-</span><span class="s4">43111992612</span><span class="s2">,-</span><span class="s4">43111992612</span><span class="s2">,</span><span class="s4">206683437987</span><span class="s2">,</span>
                           <span class="s2">-</span><span class="s4">151659573325</span><span class="s2">,</span><span class="s4">156074417954</span><span class="s2">,-</span><span class="s4">31268252574</span><span class="s2">,</span>
                           <span class="s4">56280729661</span><span class="s2">,</span><span class="s4">8181904909</span><span class="s2">], -</span><span class="s4">2639651053</span><span class="s2">,</span>
         <span class="s4">344881152000</span><span class="s2">),</span>
    <span class="s4">14</span><span class="s2">: (</span><span class="s4">7</span><span class="s2">, </span><span class="s4">2501928000</span><span class="s2">, [</span><span class="s4">90241897</span><span class="s2">,</span><span class="s4">710986864</span><span class="s2">,-</span><span class="s4">770720657</span><span class="s2">,</span><span class="s4">3501442784</span><span class="s2">,</span>
                         <span class="s2">-</span><span class="s4">6625093363</span><span class="s2">,</span><span class="s4">12630121616</span><span class="s2">,-</span><span class="s4">16802270373</span><span class="s2">,</span><span class="s4">19534438464</span><span class="s2">,</span>
                         <span class="s2">-</span><span class="s4">16802270373</span><span class="s2">,</span><span class="s4">12630121616</span><span class="s2">,-</span><span class="s4">6625093363</span><span class="s2">,</span><span class="s4">3501442784</span><span class="s2">,</span>
                         <span class="s2">-</span><span class="s4">770720657</span><span class="s2">,</span><span class="s4">710986864</span><span class="s2">,</span><span class="s4">90241897</span><span class="s2">], -</span><span class="s4">3740727473</span><span class="s2">,</span>
         <span class="s4">1275983280000</span><span class="s2">)</span>
    <span class="s2">}</span>


<span class="s0">def </span><span class="s1">newton_cotes</span><span class="s2">(</span><span class="s1">rn</span><span class="s2">, </span><span class="s1">equal</span><span class="s2">=</span><span class="s4">0</span><span class="s2">):</span>
    <span class="s5">r&quot;&quot;&quot; 
    Return weights and error coefficient for Newton-Cotes integration. 
 
    Suppose we have (N+1) samples of f at the positions 
    x_0, x_1, ..., x_N. Then an N-point Newton-Cotes formula for the 
    integral between x_0 and x_N is: 
 
    :math:`\int_{x_0}^{x_N} f(x)dx = \Delta x \sum_{i=0}^{N} a_i f(x_i) 
    + B_N (\Delta x)^{N+2} f^{N+1} (\xi)` 
 
    where :math:`\xi \in [x_0,x_N]` 
    and :math:`\Delta x = \frac{x_N-x_0}{N}` is the average samples spacing. 
 
    If the samples are equally-spaced and N is even, then the error 
    term is :math:`B_N (\Delta x)^{N+3} f^{N+2}(\xi)`. 
 
    Parameters 
    ---------- 
    rn : int 
        The integer order for equally-spaced data or the relative positions of 
        the samples with the first sample at 0 and the last at N, where N+1 is 
        the length of `rn`. N is the order of the Newton-Cotes integration. 
    equal : int, optional 
        Set to 1 to enforce equally spaced data. 
 
    Returns 
    ------- 
    an : ndarray 
        1-D array of weights to apply to the function at the provided sample 
        positions. 
    B : float 
        Error coefficient. 
 
    Notes 
    ----- 
    Normally, the Newton-Cotes rules are used on smaller integration 
    regions and a composite rule is used to return the total integral. 
 
    Examples 
    -------- 
    Compute the integral of sin(x) in [0, :math:`\pi`]: 
 
    &gt;&gt;&gt; from scipy.integrate import newton_cotes 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; def f(x): 
    ...     return np.sin(x) 
    &gt;&gt;&gt; a = 0 
    &gt;&gt;&gt; b = np.pi 
    &gt;&gt;&gt; exact = 2 
    &gt;&gt;&gt; for N in [2, 4, 6, 8, 10]: 
    ...     x = np.linspace(a, b, N + 1) 
    ...     an, B = newton_cotes(N, 1) 
    ...     dx = (b - a) / N 
    ...     quad = dx * np.sum(an * f(x)) 
    ...     error = abs(quad - exact) 
    ...     print('{:2d}  {:10.9f}  {:.5e}'.format(N, quad, error)) 
    ... 
     2   2.094395102   9.43951e-02 
     4   1.998570732   1.42927e-03 
     6   2.000017814   1.78136e-05 
     8   1.999999835   1.64725e-07 
    10   2.000000001   1.14677e-09 
 
    &quot;&quot;&quot;</span>
    <span class="s0">try</span><span class="s2">:</span>
        <span class="s1">N </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">rn</span><span class="s2">)-</span><span class="s4">1</span>
        <span class="s0">if </span><span class="s1">equal</span><span class="s2">:</span>
            <span class="s1">rn </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(</span><span class="s1">N</span><span class="s2">+</span><span class="s4">1</span><span class="s2">)</span>
        <span class="s0">elif </span><span class="s1">np</span><span class="s2">.</span><span class="s1">all</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">diff</span><span class="s2">(</span><span class="s1">rn</span><span class="s2">) == </span><span class="s4">1</span><span class="s2">):</span>
            <span class="s1">equal </span><span class="s2">= </span><span class="s4">1</span>
    <span class="s0">except </span><span class="s1">Exception</span><span class="s2">:</span>
        <span class="s1">N </span><span class="s2">= </span><span class="s1">rn</span>
        <span class="s1">rn </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(</span><span class="s1">N</span><span class="s2">+</span><span class="s4">1</span><span class="s2">)</span>
        <span class="s1">equal </span><span class="s2">= </span><span class="s4">1</span>

    <span class="s0">if </span><span class="s1">equal </span><span class="s0">and </span><span class="s1">N </span><span class="s0">in </span><span class="s1">_builtincoeffs</span><span class="s2">:</span>
        <span class="s1">na</span><span class="s2">, </span><span class="s1">da</span><span class="s2">, </span><span class="s1">vi</span><span class="s2">, </span><span class="s1">nb</span><span class="s2">, </span><span class="s1">db </span><span class="s2">= </span><span class="s1">_builtincoeffs</span><span class="s2">[</span><span class="s1">N</span><span class="s2">]</span>
        <span class="s1">an </span><span class="s2">= </span><span class="s1">na </span><span class="s2">* </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">(</span><span class="s1">vi</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">float</span><span class="s2">) / </span><span class="s1">da</span>
        <span class="s0">return </span><span class="s1">an</span><span class="s2">, </span><span class="s1">float</span><span class="s2">(</span><span class="s1">nb</span><span class="s2">)/</span><span class="s1">db</span>

    <span class="s0">if </span><span class="s2">(</span><span class="s1">rn</span><span class="s2">[</span><span class="s4">0</span><span class="s2">] != </span><span class="s4">0</span><span class="s2">) </span><span class="s0">or </span><span class="s2">(</span><span class="s1">rn</span><span class="s2">[-</span><span class="s4">1</span><span class="s2">] != </span><span class="s1">N</span><span class="s2">):</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;The sample positions must start at 0&quot;</span>
                         <span class="s3">&quot; and end at N&quot;</span><span class="s2">)</span>
    <span class="s1">yi </span><span class="s2">= </span><span class="s1">rn </span><span class="s2">/ </span><span class="s1">float</span><span class="s2">(</span><span class="s1">N</span><span class="s2">)</span>
    <span class="s1">ti </span><span class="s2">= </span><span class="s4">2 </span><span class="s2">* </span><span class="s1">yi </span><span class="s2">- </span><span class="s4">1</span>
    <span class="s1">nvec </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(</span><span class="s1">N</span><span class="s2">+</span><span class="s4">1</span><span class="s2">)</span>
    <span class="s1">C </span><span class="s2">= </span><span class="s1">ti </span><span class="s2">** </span><span class="s1">nvec</span><span class="s2">[:, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">newaxis</span><span class="s2">]</span>
    <span class="s1">Cinv </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">inv</span><span class="s2">(</span><span class="s1">C</span><span class="s2">)</span>
    <span class="s6"># improve precision of result</span>
    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s4">2</span><span class="s2">):</span>
        <span class="s1">Cinv </span><span class="s2">= </span><span class="s4">2</span><span class="s2">*</span><span class="s1">Cinv </span><span class="s2">- </span><span class="s1">Cinv</span><span class="s2">.</span><span class="s1">dot</span><span class="s2">(</span><span class="s1">C</span><span class="s2">).</span><span class="s1">dot</span><span class="s2">(</span><span class="s1">Cinv</span><span class="s2">)</span>
    <span class="s1">vec </span><span class="s2">= </span><span class="s4">2.0 </span><span class="s2">/ (</span><span class="s1">nvec</span><span class="s2">[::</span><span class="s4">2</span><span class="s2">]+</span><span class="s4">1</span><span class="s2">)</span>
    <span class="s1">ai </span><span class="s2">= </span><span class="s1">Cinv</span><span class="s2">[:, ::</span><span class="s4">2</span><span class="s2">].</span><span class="s1">dot</span><span class="s2">(</span><span class="s1">vec</span><span class="s2">) * (</span><span class="s1">N </span><span class="s2">/ </span><span class="s4">2.</span><span class="s2">)</span>

    <span class="s0">if </span><span class="s2">(</span><span class="s1">N </span><span class="s2">% </span><span class="s4">2 </span><span class="s2">== </span><span class="s4">0</span><span class="s2">) </span><span class="s0">and </span><span class="s1">equal</span><span class="s2">:</span>
        <span class="s1">BN </span><span class="s2">= </span><span class="s1">N</span><span class="s2">/(</span><span class="s1">N</span><span class="s2">+</span><span class="s4">3.</span><span class="s2">)</span>
        <span class="s1">power </span><span class="s2">= </span><span class="s1">N</span><span class="s2">+</span><span class="s4">2</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">BN </span><span class="s2">= </span><span class="s1">N</span><span class="s2">/(</span><span class="s1">N</span><span class="s2">+</span><span class="s4">2.</span><span class="s2">)</span>
        <span class="s1">power </span><span class="s2">= </span><span class="s1">N</span><span class="s2">+</span><span class="s4">1</span>

    <span class="s1">BN </span><span class="s2">= </span><span class="s1">BN </span><span class="s2">- </span><span class="s1">np</span><span class="s2">.</span><span class="s1">dot</span><span class="s2">(</span><span class="s1">yi</span><span class="s2">**</span><span class="s1">power</span><span class="s2">, </span><span class="s1">ai</span><span class="s2">)</span>
    <span class="s1">p1 </span><span class="s2">= </span><span class="s1">power</span><span class="s2">+</span><span class="s4">1</span>
    <span class="s1">fac </span><span class="s2">= </span><span class="s1">power</span><span class="s2">*</span><span class="s1">math</span><span class="s2">.</span><span class="s1">log</span><span class="s2">(</span><span class="s1">N</span><span class="s2">) - </span><span class="s1">gammaln</span><span class="s2">(</span><span class="s1">p1</span><span class="s2">)</span>
    <span class="s1">fac </span><span class="s2">= </span><span class="s1">math</span><span class="s2">.</span><span class="s1">exp</span><span class="s2">(</span><span class="s1">fac</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">ai</span><span class="s2">, </span><span class="s1">BN</span><span class="s2">*</span><span class="s1">fac</span>


<span class="s0">def </span><span class="s1">_qmc_quad_iv</span><span class="s2">(</span><span class="s1">func</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">n_points</span><span class="s2">, </span><span class="s1">n_estimates</span><span class="s2">, </span><span class="s1">qrng</span><span class="s2">, </span><span class="s1">log</span><span class="s2">):</span>

    <span class="s6"># lazy import to avoid issues with partially-initialized submodule</span>
    <span class="s0">if not </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">qmc_quad</span><span class="s2">, </span><span class="s3">'qmc'</span><span class="s2">):</span>
        <span class="s0">from </span><span class="s1">scipy </span><span class="s0">import </span><span class="s1">stats</span>
        <span class="s1">qmc_quad</span><span class="s2">.</span><span class="s1">stats </span><span class="s2">= </span><span class="s1">stats</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">stats </span><span class="s2">= </span><span class="s1">qmc_quad</span><span class="s2">.</span><span class="s1">stats</span>

    <span class="s0">if not </span><span class="s1">callable</span><span class="s2">(</span><span class="s1">func</span><span class="s2">):</span>
        <span class="s1">message </span><span class="s2">= </span><span class="s3">&quot;`func` must be callable.&quot;</span>
        <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s1">message</span><span class="s2">)</span>

    <span class="s6"># a, b will be modified, so copy. Oh well if it's copied twice.</span>
    <span class="s1">a </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">atleast_1d</span><span class="s2">(</span><span class="s1">a</span><span class="s2">).</span><span class="s1">copy</span><span class="s2">()</span>
    <span class="s1">b </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">atleast_1d</span><span class="s2">(</span><span class="s1">b</span><span class="s2">).</span><span class="s1">copy</span><span class="s2">()</span>
    <span class="s1">a</span><span class="s2">, </span><span class="s1">b </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">broadcast_arrays</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">)</span>
    <span class="s1">dim </span><span class="s2">= </span><span class="s1">a</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s4">0</span><span class="s2">]</span>

    <span class="s0">try</span><span class="s2">:</span>
        <span class="s1">func</span><span class="s2">((</span><span class="s1">a </span><span class="s2">+ </span><span class="s1">b</span><span class="s2">) / </span><span class="s4">2</span><span class="s2">)</span>
    <span class="s0">except </span><span class="s1">Exception </span><span class="s0">as </span><span class="s1">e</span><span class="s2">:</span>
        <span class="s1">message </span><span class="s2">= (</span><span class="s3">&quot;`func` must evaluate the integrand at points within &quot;</span>
                   <span class="s3">&quot;the integration range; e.g. `func( (a + b) / 2)` &quot;</span>
                   <span class="s3">&quot;must return the integrand at the centroid of the &quot;</span>
                   <span class="s3">&quot;integration volume.&quot;</span><span class="s2">)</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s1">message</span><span class="s2">) </span><span class="s0">from </span><span class="s1">e</span>

    <span class="s0">try</span><span class="s2">:</span>
        <span class="s1">func</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">]).</span><span class="s1">T</span><span class="s2">)</span>
        <span class="s1">vfunc </span><span class="s2">= </span><span class="s1">func</span>
    <span class="s0">except </span><span class="s1">Exception </span><span class="s0">as </span><span class="s1">e</span><span class="s2">:</span>
        <span class="s1">message </span><span class="s2">= (</span><span class="s3">&quot;Exception encountered when attempting vectorized call to &quot;</span>
                   <span class="s3">f&quot;`func`: </span><span class="s0">{</span><span class="s1">e</span><span class="s0">}</span><span class="s3">. For better performance, `func` should &quot;</span>
                   <span class="s3">&quot;accept two-dimensional array `x` with shape `(len(a), &quot;</span>
                   <span class="s3">&quot;n_points)` and return an array of the integrand value at &quot;</span>
                   <span class="s3">&quot;each of the `n_points.&quot;</span><span class="s2">)</span>
        <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span><span class="s1">message</span><span class="s2">, </span><span class="s1">stacklevel</span><span class="s2">=</span><span class="s4">3</span><span class="s2">)</span>

        <span class="s0">def </span><span class="s1">vfunc</span><span class="s2">(</span><span class="s1">x</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">apply_along_axis</span><span class="s2">(</span><span class="s1">func</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=-</span><span class="s4">1</span><span class="s2">, </span><span class="s1">arr</span><span class="s2">=</span><span class="s1">x</span><span class="s2">)</span>

    <span class="s1">n_points_int </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">int64</span><span class="s2">(</span><span class="s1">n_points</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">n_points </span><span class="s2">!= </span><span class="s1">n_points_int</span><span class="s2">:</span>
        <span class="s1">message </span><span class="s2">= </span><span class="s3">&quot;`n_points` must be an integer.&quot;</span>
        <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s1">message</span><span class="s2">)</span>

    <span class="s1">n_estimates_int </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">int64</span><span class="s2">(</span><span class="s1">n_estimates</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">n_estimates </span><span class="s2">!= </span><span class="s1">n_estimates_int</span><span class="s2">:</span>
        <span class="s1">message </span><span class="s2">= </span><span class="s3">&quot;`n_estimates` must be an integer.&quot;</span>
        <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s1">message</span><span class="s2">)</span>

    <span class="s0">if </span><span class="s1">qrng </span><span class="s0">is None</span><span class="s2">:</span>
        <span class="s1">qrng </span><span class="s2">= </span><span class="s1">stats</span><span class="s2">.</span><span class="s1">qmc</span><span class="s2">.</span><span class="s1">Halton</span><span class="s2">(</span><span class="s1">dim</span><span class="s2">)</span>
    <span class="s0">elif not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">qrng</span><span class="s2">, </span><span class="s1">stats</span><span class="s2">.</span><span class="s1">qmc</span><span class="s2">.</span><span class="s1">QMCEngine</span><span class="s2">):</span>
        <span class="s1">message </span><span class="s2">= </span><span class="s3">&quot;`qrng` must be an instance of scipy.stats.qmc.QMCEngine.&quot;</span>
        <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s1">message</span><span class="s2">)</span>

    <span class="s0">if </span><span class="s1">qrng</span><span class="s2">.</span><span class="s1">d </span><span class="s2">!= </span><span class="s1">a</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s4">0</span><span class="s2">]:</span>
        <span class="s1">message </span><span class="s2">= (</span><span class="s3">&quot;`qrng` must be initialized with dimensionality equal to &quot;</span>
                   <span class="s3">&quot;the number of variables in `a`, i.e., &quot;</span>
                   <span class="s3">&quot;`qrng.random().shape[-1]` must equal `a.shape[0]`.&quot;</span><span class="s2">)</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s1">message</span><span class="s2">)</span>

    <span class="s1">rng_seed </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">qrng</span><span class="s2">, </span><span class="s3">'rng_seed'</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>
    <span class="s1">rng </span><span class="s2">= </span><span class="s1">stats</span><span class="s2">.</span><span class="s1">_qmc</span><span class="s2">.</span><span class="s1">check_random_state</span><span class="s2">(</span><span class="s1">rng_seed</span><span class="s2">)</span>

    <span class="s0">if </span><span class="s1">log </span><span class="s0">not in </span><span class="s2">{</span><span class="s0">True</span><span class="s2">, </span><span class="s0">False</span><span class="s2">}:</span>
        <span class="s1">message </span><span class="s2">= </span><span class="s3">&quot;`log` must be boolean (`True` or `False`).&quot;</span>
        <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s1">message</span><span class="s2">)</span>

    <span class="s0">return </span><span class="s2">(</span><span class="s1">vfunc</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">n_points_int</span><span class="s2">, </span><span class="s1">n_estimates_int</span><span class="s2">, </span><span class="s1">qrng</span><span class="s2">, </span><span class="s1">rng</span><span class="s2">, </span><span class="s1">log</span><span class="s2">, </span><span class="s1">stats</span><span class="s2">)</span>


<span class="s1">QMCQuadResult </span><span class="s2">= </span><span class="s1">namedtuple</span><span class="s2">(</span><span class="s3">'QMCQuadResult'</span><span class="s2">, [</span><span class="s3">'integral'</span><span class="s2">, </span><span class="s3">'standard_error'</span><span class="s2">])</span>


<span class="s0">def </span><span class="s1">qmc_quad</span><span class="s2">(</span><span class="s1">func</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, *, </span><span class="s1">n_estimates</span><span class="s2">=</span><span class="s4">8</span><span class="s2">, </span><span class="s1">n_points</span><span class="s2">=</span><span class="s4">1024</span><span class="s2">, </span><span class="s1">qrng</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
             <span class="s1">log</span><span class="s2">=</span><span class="s0">False</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Compute an integral in N-dimensions using Quasi-Monte Carlo quadrature. 
 
    Parameters 
    ---------- 
    func : callable 
        The integrand. Must accept a single argument ``x``, an array which 
        specifies the point(s) at which to evaluate the scalar-valued 
        integrand, and return the value(s) of the integrand. 
        For efficiency, the function should be vectorized to accept an array of 
        shape ``(d, n_points)``, where ``d`` is the number of variables (i.e. 
        the dimensionality of the function domain) and `n_points` is the number 
        of quadrature points, and return an array of shape ``(n_points,)``, 
        the integrand at each quadrature point. 
    a, b : array-like 
        One-dimensional arrays specifying the lower and upper integration 
        limits, respectively, of each of the ``d`` variables. 
    n_estimates, n_points : int, optional 
        `n_estimates` (default: 8) statistically independent QMC samples, each 
        of `n_points` (default: 1024) points, will be generated by `qrng`. 
        The total number of points at which the integrand `func` will be 
        evaluated is ``n_points * n_estimates``. See Notes for details. 
    qrng : `~scipy.stats.qmc.QMCEngine`, optional 
        An instance of the QMCEngine from which to sample QMC points. 
        The QMCEngine must be initialized to a number of dimensions ``d`` 
        corresponding with the number of variables ``x1, ..., xd`` passed to 
        `func`. 
        The provided QMCEngine is used to produce the first integral estimate. 
        If `n_estimates` is greater than one, additional QMCEngines are 
        spawned from the first (with scrambling enabled, if it is an option.) 
        If a QMCEngine is not provided, the default `scipy.stats.qmc.Halton` 
        will be initialized with the number of dimensions determine from 
        the length of `a`. 
    log : boolean, default: False 
        When set to True, `func` returns the log of the integrand, and 
        the result object contains the log of the integral. 
 
    Returns 
    ------- 
    result : object 
        A result object with attributes: 
 
        integral : float 
            The estimate of the integral. 
        standard_error : 
            The error estimate. See Notes for interpretation. 
 
    Notes 
    ----- 
    Values of the integrand at each of the `n_points` points of a QMC sample 
    are used to produce an estimate of the integral. This estimate is drawn 
    from a population of possible estimates of the integral, the value of 
    which we obtain depends on the particular points at which the integral 
    was evaluated. We perform this process `n_estimates` times, each time 
    evaluating the integrand at different scrambled QMC points, effectively 
    drawing i.i.d. random samples from the population of integral estimates. 
    The sample mean :math:`m` of these integral estimates is an 
    unbiased estimator of the true value of the integral, and the standard 
    error of the mean :math:`s` of these estimates may be used to generate 
    confidence intervals using the t distribution with ``n_estimates - 1`` 
    degrees of freedom. Perhaps counter-intuitively, increasing `n_points` 
    while keeping the total number of function evaluation points 
    ``n_points * n_estimates`` fixed tends to reduce the actual error, whereas 
    increasing `n_estimates` tends to decrease the error estimate. 
 
    Examples 
    -------- 
    QMC quadrature is particularly useful for computing integrals in higher 
    dimensions. An example integrand is the probability density function 
    of a multivariate normal distribution. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import stats 
    &gt;&gt;&gt; dim = 8 
    &gt;&gt;&gt; mean = np.zeros(dim) 
    &gt;&gt;&gt; cov = np.eye(dim) 
    &gt;&gt;&gt; def func(x): 
    ...     # `multivariate_normal` expects the _last_ axis to correspond with 
    ...     # the dimensionality of the space, so `x` must be transposed 
    ...     return stats.multivariate_normal.pdf(x.T, mean, cov) 
 
    To compute the integral over the unit hypercube: 
 
    &gt;&gt;&gt; from scipy.integrate import qmc_quad 
    &gt;&gt;&gt; a = np.zeros(dim) 
    &gt;&gt;&gt; b = np.ones(dim) 
    &gt;&gt;&gt; rng = np.random.default_rng() 
    &gt;&gt;&gt; qrng = stats.qmc.Halton(d=dim, seed=rng) 
    &gt;&gt;&gt; n_estimates = 8 
    &gt;&gt;&gt; res = qmc_quad(func, a, b, n_estimates=n_estimates, qrng=qrng) 
    &gt;&gt;&gt; res.integral, res.standard_error 
    (0.00018429555666024108, 1.0389431116001344e-07) 
 
    A two-sided, 99% confidence interval for the integral may be estimated 
    as: 
 
    &gt;&gt;&gt; t = stats.t(df=n_estimates-1, loc=res.integral, 
    ...             scale=res.standard_error) 
    &gt;&gt;&gt; t.interval(0.99) 
    (0.0001839319802536469, 0.00018465913306683527) 
 
    Indeed, the value reported by `scipy.stats.multivariate_normal` is 
    within this range. 
 
    &gt;&gt;&gt; stats.multivariate_normal.cdf(b, mean, cov, lower_limit=a) 
    0.00018430867675187443 
 
    &quot;&quot;&quot;</span>
    <span class="s1">args </span><span class="s2">= </span><span class="s1">_qmc_quad_iv</span><span class="s2">(</span><span class="s1">func</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">n_points</span><span class="s2">, </span><span class="s1">n_estimates</span><span class="s2">, </span><span class="s1">qrng</span><span class="s2">, </span><span class="s1">log</span><span class="s2">)</span>
    <span class="s1">func</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">n_points</span><span class="s2">, </span><span class="s1">n_estimates</span><span class="s2">, </span><span class="s1">qrng</span><span class="s2">, </span><span class="s1">rng</span><span class="s2">, </span><span class="s1">log</span><span class="s2">, </span><span class="s1">stats </span><span class="s2">= </span><span class="s1">args</span>

    <span class="s0">def </span><span class="s1">sum_product</span><span class="s2">(</span><span class="s1">integrands</span><span class="s2">, </span><span class="s1">dA</span><span class="s2">, </span><span class="s1">log</span><span class="s2">=</span><span class="s0">False</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">log</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">logsumexp</span><span class="s2">(</span><span class="s1">integrands</span><span class="s2">) + </span><span class="s1">np</span><span class="s2">.</span><span class="s1">log</span><span class="s2">(</span><span class="s1">dA</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sum</span><span class="s2">(</span><span class="s1">integrands </span><span class="s2">* </span><span class="s1">dA</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">mean</span><span class="s2">(</span><span class="s1">estimates</span><span class="s2">, </span><span class="s1">log</span><span class="s2">=</span><span class="s0">False</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">log</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">logsumexp</span><span class="s2">(</span><span class="s1">estimates</span><span class="s2">) - </span><span class="s1">np</span><span class="s2">.</span><span class="s1">log</span><span class="s2">(</span><span class="s1">n_estimates</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">mean</span><span class="s2">(</span><span class="s1">estimates</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">std</span><span class="s2">(</span><span class="s1">estimates</span><span class="s2">, </span><span class="s1">m</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">ddof</span><span class="s2">=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">log</span><span class="s2">=</span><span class="s0">False</span><span class="s2">):</span>
        <span class="s1">m </span><span class="s2">= </span><span class="s1">m </span><span class="s0">or </span><span class="s1">mean</span><span class="s2">(</span><span class="s1">estimates</span><span class="s2">, </span><span class="s1">log</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">log</span><span class="s2">:</span>
            <span class="s1">estimates</span><span class="s2">, </span><span class="s1">m </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">broadcast_arrays</span><span class="s2">(</span><span class="s1">estimates</span><span class="s2">, </span><span class="s1">m</span><span class="s2">)</span>
            <span class="s1">temp </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">vstack</span><span class="s2">((</span><span class="s1">estimates</span><span class="s2">, </span><span class="s1">m </span><span class="s2">+ </span><span class="s1">np</span><span class="s2">.</span><span class="s1">pi </span><span class="s2">* </span><span class="s4">1j</span><span class="s2">))</span>
            <span class="s1">diff </span><span class="s2">= </span><span class="s1">logsumexp</span><span class="s2">(</span><span class="s1">temp</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s4">0</span><span class="s2">)</span>
            <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">real</span><span class="s2">(</span><span class="s4">0.5 </span><span class="s2">* (</span><span class="s1">logsumexp</span><span class="s2">(</span><span class="s4">2 </span><span class="s2">* </span><span class="s1">diff</span><span class="s2">)</span>
                                  <span class="s2">- </span><span class="s1">np</span><span class="s2">.</span><span class="s1">log</span><span class="s2">(</span><span class="s1">n_estimates </span><span class="s2">- </span><span class="s1">ddof</span><span class="s2">)))</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">std</span><span class="s2">(</span><span class="s1">estimates</span><span class="s2">, </span><span class="s1">ddof</span><span class="s2">=</span><span class="s1">ddof</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">sem</span><span class="s2">(</span><span class="s1">estimates</span><span class="s2">, </span><span class="s1">m</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">s</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">log</span><span class="s2">=</span><span class="s0">False</span><span class="s2">):</span>
        <span class="s1">m </span><span class="s2">= </span><span class="s1">m </span><span class="s0">or </span><span class="s1">mean</span><span class="s2">(</span><span class="s1">estimates</span><span class="s2">, </span><span class="s1">log</span><span class="s2">)</span>
        <span class="s1">s </span><span class="s2">= </span><span class="s1">s </span><span class="s0">or </span><span class="s1">std</span><span class="s2">(</span><span class="s1">estimates</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">ddof</span><span class="s2">=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">log</span><span class="s2">=</span><span class="s1">log</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">log</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">s </span><span class="s2">- </span><span class="s4">0.5</span><span class="s2">*</span><span class="s1">np</span><span class="s2">.</span><span class="s1">log</span><span class="s2">(</span><span class="s1">n_estimates</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">s </span><span class="s2">/ </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sqrt</span><span class="s2">(</span><span class="s1">n_estimates</span><span class="s2">)</span>

    <span class="s6"># The sign of the integral depends on the order of the limits. Fix this by</span>
    <span class="s6"># ensuring that lower bounds are indeed lower and setting sign of resulting</span>
    <span class="s6"># integral manually</span>
    <span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">any</span><span class="s2">(</span><span class="s1">a </span><span class="s2">== </span><span class="s1">b</span><span class="s2">):</span>
        <span class="s1">message </span><span class="s2">= (</span><span class="s3">&quot;A lower limit was equal to an upper limit, so the value &quot;</span>
                   <span class="s3">&quot;of the integral is zero by definition.&quot;</span><span class="s2">)</span>
        <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span><span class="s1">message</span><span class="s2">, </span><span class="s1">stacklevel</span><span class="s2">=</span><span class="s4">2</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">QMCQuadResult</span><span class="s2">(-</span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf </span><span class="s0">if </span><span class="s1">log </span><span class="s0">else </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">)</span>

    <span class="s1">i_swap </span><span class="s2">= </span><span class="s1">b </span><span class="s2">&lt; </span><span class="s1">a</span>
    <span class="s1">sign </span><span class="s2">= (-</span><span class="s4">1</span><span class="s2">)**(</span><span class="s1">i_swap</span><span class="s2">.</span><span class="s1">sum</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">=-</span><span class="s4">1</span><span class="s2">))  </span><span class="s6"># odd # of swaps -&gt; negative</span>
    <span class="s1">a</span><span class="s2">[</span><span class="s1">i_swap</span><span class="s2">], </span><span class="s1">b</span><span class="s2">[</span><span class="s1">i_swap</span><span class="s2">] = </span><span class="s1">b</span><span class="s2">[</span><span class="s1">i_swap</span><span class="s2">], </span><span class="s1">a</span><span class="s2">[</span><span class="s1">i_swap</span><span class="s2">]</span>

    <span class="s1">A </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">prod</span><span class="s2">(</span><span class="s1">b </span><span class="s2">- </span><span class="s1">a</span><span class="s2">)</span>
    <span class="s1">dA </span><span class="s2">= </span><span class="s1">A </span><span class="s2">/ </span><span class="s1">n_points</span>

    <span class="s1">estimates </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">(</span><span class="s1">n_estimates</span><span class="s2">)</span>
    <span class="s1">rngs </span><span class="s2">= </span><span class="s1">_rng_spawn</span><span class="s2">(</span><span class="s1">qrng</span><span class="s2">.</span><span class="s1">rng</span><span class="s2">, </span><span class="s1">n_estimates</span><span class="s2">)</span>
    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">n_estimates</span><span class="s2">):</span>
        <span class="s6"># Generate integral estimate</span>
        <span class="s1">sample </span><span class="s2">= </span><span class="s1">qrng</span><span class="s2">.</span><span class="s1">random</span><span class="s2">(</span><span class="s1">n_points</span><span class="s2">)</span>
        <span class="s6"># The rationale for transposing is that this allows users to easily</span>
        <span class="s6"># unpack `x` into separate variables, if desired. This is consistent</span>
        <span class="s6"># with the `xx` array passed into the `scipy.integrate.nquad` `func`.</span>
        <span class="s1">x </span><span class="s2">= </span><span class="s1">stats</span><span class="s2">.</span><span class="s1">qmc</span><span class="s2">.</span><span class="s1">scale</span><span class="s2">(</span><span class="s1">sample</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">).</span><span class="s1">T  </span><span class="s6"># (n_dim, n_points)</span>
        <span class="s1">integrands </span><span class="s2">= </span><span class="s1">func</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)</span>
        <span class="s1">estimates</span><span class="s2">[</span><span class="s1">i</span><span class="s2">] = </span><span class="s1">sum_product</span><span class="s2">(</span><span class="s1">integrands</span><span class="s2">, </span><span class="s1">dA</span><span class="s2">, </span><span class="s1">log</span><span class="s2">)</span>

        <span class="s6"># Get a new, independently-scrambled QRNG for next time</span>
        <span class="s1">qrng </span><span class="s2">= </span><span class="s1">type</span><span class="s2">(</span><span class="s1">qrng</span><span class="s2">)(</span><span class="s1">seed</span><span class="s2">=</span><span class="s1">rngs</span><span class="s2">[</span><span class="s1">i</span><span class="s2">], **</span><span class="s1">qrng</span><span class="s2">.</span><span class="s1">_init_quad</span><span class="s2">)</span>

    <span class="s1">integral </span><span class="s2">= </span><span class="s1">mean</span><span class="s2">(</span><span class="s1">estimates</span><span class="s2">, </span><span class="s1">log</span><span class="s2">)</span>
    <span class="s1">standard_error </span><span class="s2">= </span><span class="s1">sem</span><span class="s2">(</span><span class="s1">estimates</span><span class="s2">, </span><span class="s1">m</span><span class="s2">=</span><span class="s1">integral</span><span class="s2">, </span><span class="s1">log</span><span class="s2">=</span><span class="s1">log</span><span class="s2">)</span>
    <span class="s1">integral </span><span class="s2">= </span><span class="s1">integral </span><span class="s2">+ </span><span class="s1">np</span><span class="s2">.</span><span class="s1">pi</span><span class="s2">*</span><span class="s4">1j </span><span class="s0">if </span><span class="s2">(</span><span class="s1">log </span><span class="s0">and </span><span class="s1">sign </span><span class="s2">&lt; </span><span class="s4">0</span><span class="s2">) </span><span class="s0">else </span><span class="s1">integral</span><span class="s2">*</span><span class="s1">sign</span>
    <span class="s0">return </span><span class="s1">QMCQuadResult</span><span class="s2">(</span><span class="s1">integral</span><span class="s2">, </span><span class="s1">standard_error</span><span class="s2">)</span>
</pre>
</body>
</html>