<html>
<head>
<title>_bayesian_mixture.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #7a7e85;}
.s3 { color: #cf8e6d;}
.s4 { color: #bcbec4;}
.s5 { color: #2aacb8;}
.s6 { color: #6aab73;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_bayesian_mixture.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Bayesian Gaussian Mixture Model.&quot;&quot;&quot;</span>

<span class="s2"># Author: Wei Xue &lt;xuewei4d@gmail.com&gt;</span>
<span class="s2">#         Thierry Guillemot &lt;thierry.guillemot.work@gmail.com&gt;</span>
<span class="s2"># License: BSD 3 clause</span>

<span class="s3">import </span><span class="s1">math</span>
<span class="s3">from </span><span class="s1">numbers </span><span class="s3">import </span><span class="s1">Real</span>

<span class="s3">import </span><span class="s1">numpy </span><span class="s3">as </span><span class="s1">np</span>
<span class="s3">from </span><span class="s1">scipy</span><span class="s4">.</span><span class="s1">special </span><span class="s3">import </span><span class="s1">betaln</span><span class="s4">, </span><span class="s1">digamma</span><span class="s4">, </span><span class="s1">gammaln</span>

<span class="s3">from </span><span class="s4">..</span><span class="s1">utils </span><span class="s3">import </span><span class="s1">check_array</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">utils</span><span class="s4">.</span><span class="s1">_param_validation </span><span class="s3">import </span><span class="s1">Interval</span><span class="s4">, </span><span class="s1">StrOptions</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">_base </span><span class="s3">import </span><span class="s1">BaseMixture</span><span class="s4">, </span><span class="s1">_check_shape</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">_gaussian_mixture </span><span class="s3">import </span><span class="s4">(</span>
    <span class="s1">_check_precision_matrix</span><span class="s4">,</span>
    <span class="s1">_check_precision_positivity</span><span class="s4">,</span>
    <span class="s1">_compute_log_det_cholesky</span><span class="s4">,</span>
    <span class="s1">_compute_precision_cholesky</span><span class="s4">,</span>
    <span class="s1">_estimate_gaussian_parameters</span><span class="s4">,</span>
    <span class="s1">_estimate_log_gaussian_prob</span><span class="s4">,</span>
<span class="s4">)</span>


<span class="s3">def </span><span class="s1">_log_dirichlet_norm</span><span class="s4">(</span><span class="s1">dirichlet_concentration</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Compute the log of the Dirichlet distribution normalization term. 
 
    Parameters 
    ---------- 
    dirichlet_concentration : array-like of shape (n_samples,) 
        The parameters values of the Dirichlet distribution. 
 
    Returns 
    ------- 
    log_dirichlet_norm : float 
        The log normalization of the Dirichlet distribution. 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">gammaln</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">sum</span><span class="s4">(</span><span class="s1">dirichlet_concentration</span><span class="s4">)) - </span><span class="s1">np</span><span class="s4">.</span><span class="s1">sum</span><span class="s4">(</span>
        <span class="s1">gammaln</span><span class="s4">(</span><span class="s1">dirichlet_concentration</span><span class="s4">)</span>
    <span class="s4">)</span>


<span class="s3">def </span><span class="s1">_log_wishart_norm</span><span class="s4">(</span><span class="s1">degrees_of_freedom</span><span class="s4">, </span><span class="s1">log_det_precisions_chol</span><span class="s4">, </span><span class="s1">n_features</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Compute the log of the Wishart distribution normalization term. 
 
    Parameters 
    ---------- 
    degrees_of_freedom : array-like of shape (n_components,) 
        The number of degrees of freedom on the covariance Wishart 
        distributions. 
 
    log_det_precision_chol : array-like of shape (n_components,) 
         The determinant of the precision matrix for each component. 
 
    n_features : int 
        The number of features. 
 
    Return 
    ------ 
    log_wishart_norm : array-like of shape (n_components,) 
        The log normalization of the Wishart distribution. 
    &quot;&quot;&quot;</span>
    <span class="s2"># To simplify the computation we have removed the np.log(np.pi) term</span>
    <span class="s3">return </span><span class="s4">-(</span>
        <span class="s1">degrees_of_freedom </span><span class="s4">* </span><span class="s1">log_det_precisions_chol</span>
        <span class="s4">+ </span><span class="s1">degrees_of_freedom </span><span class="s4">* </span><span class="s1">n_features </span><span class="s4">* </span><span class="s5">0.5 </span><span class="s4">* </span><span class="s1">math</span><span class="s4">.</span><span class="s1">log</span><span class="s4">(</span><span class="s5">2.0</span><span class="s4">)</span>
        <span class="s4">+ </span><span class="s1">np</span><span class="s4">.</span><span class="s1">sum</span><span class="s4">(</span>
            <span class="s1">gammaln</span><span class="s4">(</span><span class="s5">0.5 </span><span class="s4">* (</span><span class="s1">degrees_of_freedom </span><span class="s4">- </span><span class="s1">np</span><span class="s4">.</span><span class="s1">arange</span><span class="s4">(</span><span class="s1">n_features</span><span class="s4">)[:, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">newaxis</span><span class="s4">])),</span>
            <span class="s5">0</span><span class="s4">,</span>
        <span class="s4">)</span>
    <span class="s4">)</span>


<span class="s3">class </span><span class="s1">BayesianGaussianMixture</span><span class="s4">(</span><span class="s1">BaseMixture</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Variational Bayesian estimation of a Gaussian mixture. 
 
    This class allows to infer an approximate posterior distribution over the 
    parameters of a Gaussian mixture distribution. The effective number of 
    components can be inferred from the data. 
 
    This class implements two types of prior for the weights distribution: a 
    finite mixture model with Dirichlet distribution and an infinite mixture 
    model with the Dirichlet Process. In practice Dirichlet Process inference 
    algorithm is approximated and uses a truncated distribution with a fixed 
    maximum number of components (called the Stick-breaking representation). 
    The number of components actually used almost always depends on the data. 
 
    .. versionadded:: 0.18 
 
    Read more in the :ref:`User Guide &lt;bgmm&gt;`. 
 
    Parameters 
    ---------- 
    n_components : int, default=1 
        The number of mixture components. Depending on the data and the value 
        of the `weight_concentration_prior` the model can decide to not use 
        all the components by setting some component `weights_` to values very 
        close to zero. The number of effective components is therefore smaller 
        than n_components. 
 
    covariance_type : {'full', 'tied', 'diag', 'spherical'}, default='full' 
        String describing the type of covariance parameters to use. 
        Must be one of:: 
 
            'full' (each component has its own general covariance matrix), 
            'tied' (all components share the same general covariance matrix), 
            'diag' (each component has its own diagonal covariance matrix), 
            'spherical' (each component has its own single variance). 
 
    tol : float, default=1e-3 
        The convergence threshold. EM iterations will stop when the 
        lower bound average gain on the likelihood (of the training data with 
        respect to the model) is below this threshold. 
 
    reg_covar : float, default=1e-6 
        Non-negative regularization added to the diagonal of covariance. 
        Allows to assure that the covariance matrices are all positive. 
 
    max_iter : int, default=100 
        The number of EM iterations to perform. 
 
    n_init : int, default=1 
        The number of initializations to perform. The result with the highest 
        lower bound value on the likelihood is kept. 
 
    init_params : {'kmeans', 'k-means++', 'random', 'random_from_data'}, \ 
    default='kmeans' 
        The method used to initialize the weights, the means and the 
        covariances. 
        String must be one of: 
 
            'kmeans' : responsibilities are initialized using kmeans. 
            'k-means++' : use the k-means++ method to initialize. 
            'random' : responsibilities are initialized randomly. 
            'random_from_data' : initial means are randomly selected data points. 
 
        .. versionchanged:: v1.1 
            `init_params` now accepts 'random_from_data' and 'k-means++' as 
            initialization methods. 
 
    weight_concentration_prior_type : {'dirichlet_process', 'dirichlet_distribution'}, \ 
            default='dirichlet_process' 
        String describing the type of the weight concentration prior. 
 
    weight_concentration_prior : float or None, default=None 
        The dirichlet concentration of each component on the weight 
        distribution (Dirichlet). This is commonly called gamma in the 
        literature. The higher concentration puts more mass in 
        the center and will lead to more components being active, while a lower 
        concentration parameter will lead to more mass at the edge of the 
        mixture weights simplex. The value of the parameter must be greater 
        than 0. If it is None, it's set to ``1. / n_components``. 
 
    mean_precision_prior : float or None, default=None 
        The precision prior on the mean distribution (Gaussian). 
        Controls the extent of where means can be placed. Larger 
        values concentrate the cluster means around `mean_prior`. 
        The value of the parameter must be greater than 0. 
        If it is None, it is set to 1. 
 
    mean_prior : array-like, shape (n_features,), default=None 
        The prior on the mean distribution (Gaussian). 
        If it is None, it is set to the mean of X. 
 
    degrees_of_freedom_prior : float or None, default=None 
        The prior of the number of degrees of freedom on the covariance 
        distributions (Wishart). If it is None, it's set to `n_features`. 
 
    covariance_prior : float or array-like, default=None 
        The prior on the covariance distribution (Wishart). 
        If it is None, the emiprical covariance prior is initialized using the 
        covariance of X. The shape depends on `covariance_type`:: 
 
                (n_features, n_features) if 'full', 
                (n_features, n_features) if 'tied', 
                (n_features)             if 'diag', 
                float                    if 'spherical' 
 
    random_state : int, RandomState instance or None, default=None 
        Controls the random seed given to the method chosen to initialize the 
        parameters (see `init_params`). 
        In addition, it controls the generation of random samples from the 
        fitted distribution (see the method `sample`). 
        Pass an int for reproducible output across multiple function calls. 
        See :term:`Glossary &lt;random_state&gt;`. 
 
    warm_start : bool, default=False 
        If 'warm_start' is True, the solution of the last fitting is used as 
        initialization for the next call of fit(). This can speed up 
        convergence when fit is called several times on similar problems. 
        See :term:`the Glossary &lt;warm_start&gt;`. 
 
    verbose : int, default=0 
        Enable verbose output. If 1 then it prints the current 
        initialization and each iteration step. If greater than 1 then 
        it prints also the log probability and the time needed 
        for each step. 
 
    verbose_interval : int, default=10 
        Number of iteration done before the next print. 
 
    Attributes 
    ---------- 
    weights_ : array-like of shape (n_components,) 
        The weights of each mixture components. 
 
    means_ : array-like of shape (n_components, n_features) 
        The mean of each mixture component. 
 
    covariances_ : array-like 
        The covariance of each mixture component. 
        The shape depends on `covariance_type`:: 
 
            (n_components,)                        if 'spherical', 
            (n_features, n_features)               if 'tied', 
            (n_components, n_features)             if 'diag', 
            (n_components, n_features, n_features) if 'full' 
 
    precisions_ : array-like 
        The precision matrices for each component in the mixture. A precision 
        matrix is the inverse of a covariance matrix. A covariance matrix is 
        symmetric positive definite so the mixture of Gaussian can be 
        equivalently parameterized by the precision matrices. Storing the 
        precision matrices instead of the covariance matrices makes it more 
        efficient to compute the log-likelihood of new samples at test time. 
        The shape depends on ``covariance_type``:: 
 
            (n_components,)                        if 'spherical', 
            (n_features, n_features)               if 'tied', 
            (n_components, n_features)             if 'diag', 
            (n_components, n_features, n_features) if 'full' 
 
    precisions_cholesky_ : array-like 
        The cholesky decomposition of the precision matrices of each mixture 
        component. A precision matrix is the inverse of a covariance matrix. 
        A covariance matrix is symmetric positive definite so the mixture of 
        Gaussian can be equivalently parameterized by the precision matrices. 
        Storing the precision matrices instead of the covariance matrices makes 
        it more efficient to compute the log-likelihood of new samples at test 
        time. The shape depends on ``covariance_type``:: 
 
            (n_components,)                        if 'spherical', 
            (n_features, n_features)               if 'tied', 
            (n_components, n_features)             if 'diag', 
            (n_components, n_features, n_features) if 'full' 
 
    converged_ : bool 
        True when convergence of the best fit of inference was reached, False otherwise. 
 
    n_iter_ : int 
        Number of step used by the best fit of inference to reach the 
        convergence. 
 
    lower_bound_ : float 
        Lower bound value on the model evidence (of the training data) of the 
        best fit of inference. 
 
    weight_concentration_prior_ : tuple or float 
        The dirichlet concentration of each component on the weight 
        distribution (Dirichlet). The type depends on 
        ``weight_concentration_prior_type``:: 
 
            (float, float) if 'dirichlet_process' (Beta parameters), 
            float          if 'dirichlet_distribution' (Dirichlet parameters). 
 
        The higher concentration puts more mass in 
        the center and will lead to more components being active, while a lower 
        concentration parameter will lead to more mass at the edge of the 
        simplex. 
 
    weight_concentration_ : array-like of shape (n_components,) 
        The dirichlet concentration of each component on the weight 
        distribution (Dirichlet). 
 
    mean_precision_prior_ : float 
        The precision prior on the mean distribution (Gaussian). 
        Controls the extent of where means can be placed. 
        Larger values concentrate the cluster means around `mean_prior`. 
        If mean_precision_prior is set to None, `mean_precision_prior_` is set 
        to 1. 
 
    mean_precision_ : array-like of shape (n_components,) 
        The precision of each components on the mean distribution (Gaussian). 
 
    mean_prior_ : array-like of shape (n_features,) 
        The prior on the mean distribution (Gaussian). 
 
    degrees_of_freedom_prior_ : float 
        The prior of the number of degrees of freedom on the covariance 
        distributions (Wishart). 
 
    degrees_of_freedom_ : array-like of shape (n_components,) 
        The number of degrees of freedom of each components in the model. 
 
    covariance_prior_ : float or array-like 
        The prior on the covariance distribution (Wishart). 
        The shape depends on `covariance_type`:: 
 
            (n_features, n_features) if 'full', 
            (n_features, n_features) if 'tied', 
            (n_features)             if 'diag', 
            float                    if 'spherical' 
 
    n_features_in_ : int 
        Number of features seen during :term:`fit`. 
 
        .. versionadded:: 0.24 
 
    feature_names_in_ : ndarray of shape (`n_features_in_`,) 
        Names of features seen during :term:`fit`. Defined only when `X` 
        has feature names that are all strings. 
 
        .. versionadded:: 1.0 
 
    See Also 
    -------- 
    GaussianMixture : Finite Gaussian mixture fit with EM. 
 
    References 
    ---------- 
 
    .. [1] `Bishop, Christopher M. (2006). &quot;Pattern recognition and machine 
       learning&quot;. Vol. 4 No. 4. New York: Springer. 
       &lt;https://www.springer.com/kr/book/9780387310732&gt;`_ 
 
    .. [2] `Hagai Attias. (2000). &quot;A Variational Bayesian Framework for 
       Graphical Models&quot;. In Advances in Neural Information Processing 
       Systems 12. 
       &lt;https://citeseerx.ist.psu.edu/doc_view/pid/ee844fd96db7041a9681b5a18bff008912052c7e&gt;`_ 
 
    .. [3] `Blei, David M. and Michael I. Jordan. (2006). &quot;Variational 
       inference for Dirichlet process mixtures&quot;. Bayesian analysis 1.1 
       &lt;https://www.cs.princeton.edu/courses/archive/fall11/cos597C/reading/BleiJordan2005.pdf&gt;`_ 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from sklearn.mixture import BayesianGaussianMixture 
    &gt;&gt;&gt; X = np.array([[1, 2], [1, 4], [1, 0], [4, 2], [12, 4], [10, 7]]) 
    &gt;&gt;&gt; bgm = BayesianGaussianMixture(n_components=2, random_state=42).fit(X) 
    &gt;&gt;&gt; bgm.means_ 
    array([[2.49... , 2.29...], 
           [8.45..., 4.52... ]]) 
    &gt;&gt;&gt; bgm.predict([[0, 0], [9, 3]]) 
    array([0, 1]) 
    &quot;&quot;&quot;</span>

    <span class="s1">_parameter_constraints</span><span class="s4">: </span><span class="s1">dict </span><span class="s4">= {</span>
        <span class="s4">**</span><span class="s1">BaseMixture</span><span class="s4">.</span><span class="s1">_parameter_constraints</span><span class="s4">,</span>
        <span class="s6">&quot;covariance_type&quot;</span><span class="s4">: [</span><span class="s1">StrOptions</span><span class="s4">({</span><span class="s6">&quot;spherical&quot;</span><span class="s4">, </span><span class="s6">&quot;tied&quot;</span><span class="s4">, </span><span class="s6">&quot;diag&quot;</span><span class="s4">, </span><span class="s6">&quot;full&quot;</span><span class="s4">})],</span>
        <span class="s6">&quot;weight_concentration_prior_type&quot;</span><span class="s4">: [</span>
            <span class="s1">StrOptions</span><span class="s4">({</span><span class="s6">&quot;dirichlet_process&quot;</span><span class="s4">, </span><span class="s6">&quot;dirichlet_distribution&quot;</span><span class="s4">})</span>
        <span class="s4">],</span>
        <span class="s6">&quot;weight_concentration_prior&quot;</span><span class="s4">: [</span>
            <span class="s3">None</span><span class="s4">,</span>
            <span class="s1">Interval</span><span class="s4">(</span><span class="s1">Real</span><span class="s4">, </span><span class="s5">0.0</span><span class="s4">, </span><span class="s3">None</span><span class="s4">, </span><span class="s1">closed</span><span class="s4">=</span><span class="s6">&quot;neither&quot;</span><span class="s4">),</span>
        <span class="s4">],</span>
        <span class="s6">&quot;mean_precision_prior&quot;</span><span class="s4">: [</span><span class="s3">None</span><span class="s4">, </span><span class="s1">Interval</span><span class="s4">(</span><span class="s1">Real</span><span class="s4">, </span><span class="s5">0.0</span><span class="s4">, </span><span class="s3">None</span><span class="s4">, </span><span class="s1">closed</span><span class="s4">=</span><span class="s6">&quot;neither&quot;</span><span class="s4">)],</span>
        <span class="s6">&quot;mean_prior&quot;</span><span class="s4">: [</span><span class="s3">None</span><span class="s4">, </span><span class="s6">&quot;array-like&quot;</span><span class="s4">],</span>
        <span class="s6">&quot;degrees_of_freedom_prior&quot;</span><span class="s4">: [</span><span class="s3">None</span><span class="s4">, </span><span class="s1">Interval</span><span class="s4">(</span><span class="s1">Real</span><span class="s4">, </span><span class="s5">0.0</span><span class="s4">, </span><span class="s3">None</span><span class="s4">, </span><span class="s1">closed</span><span class="s4">=</span><span class="s6">&quot;neither&quot;</span><span class="s4">)],</span>
        <span class="s6">&quot;covariance_prior&quot;</span><span class="s4">: [</span>
            <span class="s3">None</span><span class="s4">,</span>
            <span class="s6">&quot;array-like&quot;</span><span class="s4">,</span>
            <span class="s1">Interval</span><span class="s4">(</span><span class="s1">Real</span><span class="s4">, </span><span class="s5">0.0</span><span class="s4">, </span><span class="s3">None</span><span class="s4">, </span><span class="s1">closed</span><span class="s4">=</span><span class="s6">&quot;neither&quot;</span><span class="s4">),</span>
        <span class="s4">],</span>
    <span class="s4">}</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s4">*,</span>
        <span class="s1">n_components</span><span class="s4">=</span><span class="s5">1</span><span class="s4">,</span>
        <span class="s1">covariance_type</span><span class="s4">=</span><span class="s6">&quot;full&quot;</span><span class="s4">,</span>
        <span class="s1">tol</span><span class="s4">=</span><span class="s5">1e-3</span><span class="s4">,</span>
        <span class="s1">reg_covar</span><span class="s4">=</span><span class="s5">1e-6</span><span class="s4">,</span>
        <span class="s1">max_iter</span><span class="s4">=</span><span class="s5">100</span><span class="s4">,</span>
        <span class="s1">n_init</span><span class="s4">=</span><span class="s5">1</span><span class="s4">,</span>
        <span class="s1">init_params</span><span class="s4">=</span><span class="s6">&quot;kmeans&quot;</span><span class="s4">,</span>
        <span class="s1">weight_concentration_prior_type</span><span class="s4">=</span><span class="s6">&quot;dirichlet_process&quot;</span><span class="s4">,</span>
        <span class="s1">weight_concentration_prior</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">mean_precision_prior</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">mean_prior</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">degrees_of_freedom_prior</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">covariance_prior</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">random_state</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">warm_start</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
        <span class="s1">verbose</span><span class="s4">=</span><span class="s5">0</span><span class="s4">,</span>
        <span class="s1">verbose_interval</span><span class="s4">=</span><span class="s5">10</span><span class="s4">,</span>
    <span class="s4">):</span>
        <span class="s1">super</span><span class="s4">().</span><span class="s1">__init__</span><span class="s4">(</span>
            <span class="s1">n_components</span><span class="s4">=</span><span class="s1">n_components</span><span class="s4">,</span>
            <span class="s1">tol</span><span class="s4">=</span><span class="s1">tol</span><span class="s4">,</span>
            <span class="s1">reg_covar</span><span class="s4">=</span><span class="s1">reg_covar</span><span class="s4">,</span>
            <span class="s1">max_iter</span><span class="s4">=</span><span class="s1">max_iter</span><span class="s4">,</span>
            <span class="s1">n_init</span><span class="s4">=</span><span class="s1">n_init</span><span class="s4">,</span>
            <span class="s1">init_params</span><span class="s4">=</span><span class="s1">init_params</span><span class="s4">,</span>
            <span class="s1">random_state</span><span class="s4">=</span><span class="s1">random_state</span><span class="s4">,</span>
            <span class="s1">warm_start</span><span class="s4">=</span><span class="s1">warm_start</span><span class="s4">,</span>
            <span class="s1">verbose</span><span class="s4">=</span><span class="s1">verbose</span><span class="s4">,</span>
            <span class="s1">verbose_interval</span><span class="s4">=</span><span class="s1">verbose_interval</span><span class="s4">,</span>
        <span class="s4">)</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">covariance_type </span><span class="s4">= </span><span class="s1">covariance_type</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">weight_concentration_prior_type </span><span class="s4">= </span><span class="s1">weight_concentration_prior_type</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">weight_concentration_prior </span><span class="s4">= </span><span class="s1">weight_concentration_prior</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">mean_precision_prior </span><span class="s4">= </span><span class="s1">mean_precision_prior</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">mean_prior </span><span class="s4">= </span><span class="s1">mean_prior</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">degrees_of_freedom_prior </span><span class="s4">= </span><span class="s1">degrees_of_freedom_prior</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">covariance_prior </span><span class="s4">= </span><span class="s1">covariance_prior</span>

    <span class="s3">def </span><span class="s1">_check_parameters</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">X</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Check that the parameters are well defined. 
 
        Parameters 
        ---------- 
        X : array-like of shape (n_samples, n_features) 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_check_weights_parameters</span><span class="s4">()</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_check_means_parameters</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_check_precision_parameters</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_checkcovariance_prior_parameter</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_check_weights_parameters</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Check the parameter of the Dirichlet distribution.&quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">weight_concentration_prior </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">weight_concentration_prior_ </span><span class="s4">= </span><span class="s5">1.0 </span><span class="s4">/ </span><span class="s1">self</span><span class="s4">.</span><span class="s1">n_components</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">weight_concentration_prior_ </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">weight_concentration_prior</span>

    <span class="s3">def </span><span class="s1">_check_means_parameters</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">X</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Check the parameters of the Gaussian distribution. 
 
        Parameters 
        ---------- 
        X : array-like of shape (n_samples, n_features) 
        &quot;&quot;&quot;</span>
        <span class="s1">_</span><span class="s4">, </span><span class="s1">n_features </span><span class="s4">= </span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span>

        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">mean_precision_prior </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">mean_precision_prior_ </span><span class="s4">= </span><span class="s5">1.0</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">mean_precision_prior_ </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">mean_precision_prior</span>

        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">mean_prior </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">mean_prior_ </span><span class="s4">= </span><span class="s1">X</span><span class="s4">.</span><span class="s1">mean</span><span class="s4">(</span><span class="s1">axis</span><span class="s4">=</span><span class="s5">0</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">mean_prior_ </span><span class="s4">= </span><span class="s1">check_array</span><span class="s4">(</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">mean_prior</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=[</span><span class="s1">np</span><span class="s4">.</span><span class="s1">float64</span><span class="s4">, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">float32</span><span class="s4">], </span><span class="s1">ensure_2d</span><span class="s4">=</span><span class="s3">False</span>
            <span class="s4">)</span>
            <span class="s1">_check_shape</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">mean_prior_</span><span class="s4">, (</span><span class="s1">n_features</span><span class="s4">,), </span><span class="s6">&quot;means&quot;</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_check_precision_parameters</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">X</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Check the prior parameters of the precision distribution. 
 
        Parameters 
        ---------- 
        X : array-like of shape (n_samples, n_features) 
        &quot;&quot;&quot;</span>
        <span class="s1">_</span><span class="s4">, </span><span class="s1">n_features </span><span class="s4">= </span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span>

        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">degrees_of_freedom_prior </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">degrees_of_freedom_prior_ </span><span class="s4">= </span><span class="s1">n_features</span>
        <span class="s3">elif </span><span class="s1">self</span><span class="s4">.</span><span class="s1">degrees_of_freedom_prior </span><span class="s4">&gt; </span><span class="s1">n_features </span><span class="s4">- </span><span class="s5">1.0</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">degrees_of_freedom_prior_ </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">degrees_of_freedom_prior</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span>
                <span class="s6">&quot;The parameter 'degrees_of_freedom_prior' &quot;</span>
                <span class="s6">&quot;should be greater than %d, but got %.3f.&quot;</span>
                <span class="s4">% (</span><span class="s1">n_features </span><span class="s4">- </span><span class="s5">1</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">degrees_of_freedom_prior</span><span class="s4">)</span>
            <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_checkcovariance_prior_parameter</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">X</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Check the `covariance_prior_`. 
 
        Parameters 
        ---------- 
        X : array-like of shape (n_samples, n_features) 
        &quot;&quot;&quot;</span>
        <span class="s1">_</span><span class="s4">, </span><span class="s1">n_features </span><span class="s4">= </span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span>

        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">covariance_prior </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">covariance_prior_ </span><span class="s4">= {</span>
                <span class="s6">&quot;full&quot;</span><span class="s4">: </span><span class="s1">np</span><span class="s4">.</span><span class="s1">atleast_2d</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">cov</span><span class="s4">(</span><span class="s1">X</span><span class="s4">.</span><span class="s1">T</span><span class="s4">)),</span>
                <span class="s6">&quot;tied&quot;</span><span class="s4">: </span><span class="s1">np</span><span class="s4">.</span><span class="s1">atleast_2d</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">cov</span><span class="s4">(</span><span class="s1">X</span><span class="s4">.</span><span class="s1">T</span><span class="s4">)),</span>
                <span class="s6">&quot;diag&quot;</span><span class="s4">: </span><span class="s1">np</span><span class="s4">.</span><span class="s1">var</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">axis</span><span class="s4">=</span><span class="s5">0</span><span class="s4">, </span><span class="s1">ddof</span><span class="s4">=</span><span class="s5">1</span><span class="s4">),</span>
                <span class="s6">&quot;spherical&quot;</span><span class="s4">: </span><span class="s1">np</span><span class="s4">.</span><span class="s1">var</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">axis</span><span class="s4">=</span><span class="s5">0</span><span class="s4">, </span><span class="s1">ddof</span><span class="s4">=</span><span class="s5">1</span><span class="s4">).</span><span class="s1">mean</span><span class="s4">(),</span>
            <span class="s4">}[</span><span class="s1">self</span><span class="s4">.</span><span class="s1">covariance_type</span><span class="s4">]</span>

        <span class="s3">elif </span><span class="s1">self</span><span class="s4">.</span><span class="s1">covariance_type </span><span class="s3">in </span><span class="s4">[</span><span class="s6">&quot;full&quot;</span><span class="s4">, </span><span class="s6">&quot;tied&quot;</span><span class="s4">]:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">covariance_prior_ </span><span class="s4">= </span><span class="s1">check_array</span><span class="s4">(</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">covariance_prior</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=[</span><span class="s1">np</span><span class="s4">.</span><span class="s1">float64</span><span class="s4">, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">float32</span><span class="s4">], </span><span class="s1">ensure_2d</span><span class="s4">=</span><span class="s3">False</span>
            <span class="s4">)</span>
            <span class="s1">_check_shape</span><span class="s4">(</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">covariance_prior_</span><span class="s4">,</span>
                <span class="s4">(</span><span class="s1">n_features</span><span class="s4">, </span><span class="s1">n_features</span><span class="s4">),</span>
                <span class="s6">&quot;%s covariance_prior&quot; </span><span class="s4">% </span><span class="s1">self</span><span class="s4">.</span><span class="s1">covariance_type</span><span class="s4">,</span>
            <span class="s4">)</span>
            <span class="s1">_check_precision_matrix</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">covariance_prior_</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">covariance_type</span><span class="s4">)</span>
        <span class="s3">elif </span><span class="s1">self</span><span class="s4">.</span><span class="s1">covariance_type </span><span class="s4">== </span><span class="s6">&quot;diag&quot;</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">covariance_prior_ </span><span class="s4">= </span><span class="s1">check_array</span><span class="s4">(</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">covariance_prior</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=[</span><span class="s1">np</span><span class="s4">.</span><span class="s1">float64</span><span class="s4">, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">float32</span><span class="s4">], </span><span class="s1">ensure_2d</span><span class="s4">=</span><span class="s3">False</span>
            <span class="s4">)</span>
            <span class="s1">_check_shape</span><span class="s4">(</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">covariance_prior_</span><span class="s4">,</span>
                <span class="s4">(</span><span class="s1">n_features</span><span class="s4">,),</span>
                <span class="s6">&quot;%s covariance_prior&quot; </span><span class="s4">% </span><span class="s1">self</span><span class="s4">.</span><span class="s1">covariance_type</span><span class="s4">,</span>
            <span class="s4">)</span>
            <span class="s1">_check_precision_positivity</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">covariance_prior_</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">covariance_type</span><span class="s4">)</span>
        <span class="s2"># spherical case</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">covariance_prior_ </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">covariance_prior</span>

    <span class="s3">def </span><span class="s1">_initialize</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">X</span><span class="s4">, </span><span class="s1">resp</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Initialization of the mixture parameters. 
 
        Parameters 
        ---------- 
        X : array-like of shape (n_samples, n_features) 
 
        resp : array-like of shape (n_samples, n_components) 
        &quot;&quot;&quot;</span>
        <span class="s1">nk</span><span class="s4">, </span><span class="s1">xk</span><span class="s4">, </span><span class="s1">sk </span><span class="s4">= </span><span class="s1">_estimate_gaussian_parameters</span><span class="s4">(</span>
            <span class="s1">X</span><span class="s4">, </span><span class="s1">resp</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">reg_covar</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">covariance_type</span>
        <span class="s4">)</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">_estimate_weights</span><span class="s4">(</span><span class="s1">nk</span><span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_estimate_means</span><span class="s4">(</span><span class="s1">nk</span><span class="s4">, </span><span class="s1">xk</span><span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_estimate_precisions</span><span class="s4">(</span><span class="s1">nk</span><span class="s4">, </span><span class="s1">xk</span><span class="s4">, </span><span class="s1">sk</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_estimate_weights</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">nk</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Estimate the parameters of the Dirichlet distribution. 
 
        Parameters 
        ---------- 
        nk : array-like of shape (n_components,) 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">weight_concentration_prior_type </span><span class="s4">== </span><span class="s6">&quot;dirichlet_process&quot;</span><span class="s4">:</span>
            <span class="s2"># For dirichlet process weight_concentration will be a tuple</span>
            <span class="s2"># containing the two parameters of the beta distribution</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">weight_concentration_ </span><span class="s4">= (</span>
                <span class="s5">1.0 </span><span class="s4">+ </span><span class="s1">nk</span><span class="s4">,</span>
                <span class="s4">(</span>
                    <span class="s1">self</span><span class="s4">.</span><span class="s1">weight_concentration_prior_</span>
                    <span class="s4">+ </span><span class="s1">np</span><span class="s4">.</span><span class="s1">hstack</span><span class="s4">((</span><span class="s1">np</span><span class="s4">.</span><span class="s1">cumsum</span><span class="s4">(</span><span class="s1">nk</span><span class="s4">[::-</span><span class="s5">1</span><span class="s4">])[-</span><span class="s5">2</span><span class="s4">::-</span><span class="s5">1</span><span class="s4">], </span><span class="s5">0</span><span class="s4">))</span>
                <span class="s4">),</span>
            <span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s2"># case Variational Gaussian mixture with dirichlet distribution</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">weight_concentration_ </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">weight_concentration_prior_ </span><span class="s4">+ </span><span class="s1">nk</span>

    <span class="s3">def </span><span class="s1">_estimate_means</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">nk</span><span class="s4">, </span><span class="s1">xk</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Estimate the parameters of the Gaussian distribution. 
 
        Parameters 
        ---------- 
        nk : array-like of shape (n_components,) 
 
        xk : array-like of shape (n_components, n_features) 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">mean_precision_ </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">mean_precision_prior_ </span><span class="s4">+ </span><span class="s1">nk</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">means_ </span><span class="s4">= (</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">mean_precision_prior_ </span><span class="s4">* </span><span class="s1">self</span><span class="s4">.</span><span class="s1">mean_prior_ </span><span class="s4">+ </span><span class="s1">nk</span><span class="s4">[:, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">newaxis</span><span class="s4">] * </span><span class="s1">xk</span>
        <span class="s4">) / </span><span class="s1">self</span><span class="s4">.</span><span class="s1">mean_precision_</span><span class="s4">[:, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">newaxis</span><span class="s4">]</span>

    <span class="s3">def </span><span class="s1">_estimate_precisions</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">nk</span><span class="s4">, </span><span class="s1">xk</span><span class="s4">, </span><span class="s1">sk</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Estimate the precisions parameters of the precision distribution. 
 
        Parameters 
        ---------- 
        nk : array-like of shape (n_components,) 
 
        xk : array-like of shape (n_components, n_features) 
 
        sk : array-like 
            The shape depends of `covariance_type`: 
            'full' : (n_components, n_features, n_features) 
            'tied' : (n_features, n_features) 
            'diag' : (n_components, n_features) 
            'spherical' : (n_components,) 
        &quot;&quot;&quot;</span>
        <span class="s4">{</span>
            <span class="s6">&quot;full&quot;</span><span class="s4">: </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_estimate_wishart_full</span><span class="s4">,</span>
            <span class="s6">&quot;tied&quot;</span><span class="s4">: </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_estimate_wishart_tied</span><span class="s4">,</span>
            <span class="s6">&quot;diag&quot;</span><span class="s4">: </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_estimate_wishart_diag</span><span class="s4">,</span>
            <span class="s6">&quot;spherical&quot;</span><span class="s4">: </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_estimate_wishart_spherical</span><span class="s4">,</span>
        <span class="s4">}[</span><span class="s1">self</span><span class="s4">.</span><span class="s1">covariance_type</span><span class="s4">](</span><span class="s1">nk</span><span class="s4">, </span><span class="s1">xk</span><span class="s4">, </span><span class="s1">sk</span><span class="s4">)</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">precisions_cholesky_ </span><span class="s4">= </span><span class="s1">_compute_precision_cholesky</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">covariances_</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">covariance_type</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_estimate_wishart_full</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">nk</span><span class="s4">, </span><span class="s1">xk</span><span class="s4">, </span><span class="s1">sk</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Estimate the full Wishart distribution parameters. 
 
        Parameters 
        ---------- 
        X : array-like of shape (n_samples, n_features) 
 
        nk : array-like of shape (n_components,) 
 
        xk : array-like of shape (n_components, n_features) 
 
        sk : array-like of shape (n_components, n_features, n_features) 
        &quot;&quot;&quot;</span>
        <span class="s1">_</span><span class="s4">, </span><span class="s1">n_features </span><span class="s4">= </span><span class="s1">xk</span><span class="s4">.</span><span class="s1">shape</span>

        <span class="s2"># Warning : in some Bishop book, there is a typo on the formula 10.63</span>
        <span class="s2"># `degrees_of_freedom_k = degrees_of_freedom_0 + Nk` is</span>
        <span class="s2"># the correct formula</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">degrees_of_freedom_ </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">degrees_of_freedom_prior_ </span><span class="s4">+ </span><span class="s1">nk</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">covariances_ </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">empty</span><span class="s4">((</span><span class="s1">self</span><span class="s4">.</span><span class="s1">n_components</span><span class="s4">, </span><span class="s1">n_features</span><span class="s4">, </span><span class="s1">n_features</span><span class="s4">))</span>

        <span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">range</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">n_components</span><span class="s4">):</span>
            <span class="s1">diff </span><span class="s4">= </span><span class="s1">xk</span><span class="s4">[</span><span class="s1">k</span><span class="s4">] - </span><span class="s1">self</span><span class="s4">.</span><span class="s1">mean_prior_</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">covariances_</span><span class="s4">[</span><span class="s1">k</span><span class="s4">] = (</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">covariance_prior_</span>
                <span class="s4">+ </span><span class="s1">nk</span><span class="s4">[</span><span class="s1">k</span><span class="s4">] * </span><span class="s1">sk</span><span class="s4">[</span><span class="s1">k</span><span class="s4">]</span>
                <span class="s4">+ </span><span class="s1">nk</span><span class="s4">[</span><span class="s1">k</span><span class="s4">]</span>
                <span class="s4">* </span><span class="s1">self</span><span class="s4">.</span><span class="s1">mean_precision_prior_</span>
                <span class="s4">/ </span><span class="s1">self</span><span class="s4">.</span><span class="s1">mean_precision_</span><span class="s4">[</span><span class="s1">k</span><span class="s4">]</span>
                <span class="s4">* </span><span class="s1">np</span><span class="s4">.</span><span class="s1">outer</span><span class="s4">(</span><span class="s1">diff</span><span class="s4">, </span><span class="s1">diff</span><span class="s4">)</span>
            <span class="s4">)</span>

        <span class="s2"># Contrary to the original bishop book, we normalize the covariances</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">covariances_ </span><span class="s4">/= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">degrees_of_freedom_</span><span class="s4">[:, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">newaxis</span><span class="s4">, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">newaxis</span><span class="s4">]</span>

    <span class="s3">def </span><span class="s1">_estimate_wishart_tied</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">nk</span><span class="s4">, </span><span class="s1">xk</span><span class="s4">, </span><span class="s1">sk</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Estimate the tied Wishart distribution parameters. 
 
        Parameters 
        ---------- 
        X : array-like of shape (n_samples, n_features) 
 
        nk : array-like of shape (n_components,) 
 
        xk : array-like of shape (n_components, n_features) 
 
        sk : array-like of shape (n_features, n_features) 
        &quot;&quot;&quot;</span>
        <span class="s1">_</span><span class="s4">, </span><span class="s1">n_features </span><span class="s4">= </span><span class="s1">xk</span><span class="s4">.</span><span class="s1">shape</span>

        <span class="s2"># Warning : in some Bishop book, there is a typo on the formula 10.63</span>
        <span class="s2"># `degrees_of_freedom_k = degrees_of_freedom_0 + Nk`</span>
        <span class="s2"># is the correct formula</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">degrees_of_freedom_ </span><span class="s4">= (</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">degrees_of_freedom_prior_ </span><span class="s4">+ </span><span class="s1">nk</span><span class="s4">.</span><span class="s1">sum</span><span class="s4">() / </span><span class="s1">self</span><span class="s4">.</span><span class="s1">n_components</span>
        <span class="s4">)</span>

        <span class="s1">diff </span><span class="s4">= </span><span class="s1">xk </span><span class="s4">- </span><span class="s1">self</span><span class="s4">.</span><span class="s1">mean_prior_</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">covariances_ </span><span class="s4">= (</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">covariance_prior_</span>
            <span class="s4">+ </span><span class="s1">sk </span><span class="s4">* </span><span class="s1">nk</span><span class="s4">.</span><span class="s1">sum</span><span class="s4">() / </span><span class="s1">self</span><span class="s4">.</span><span class="s1">n_components</span>
            <span class="s4">+ </span><span class="s1">self</span><span class="s4">.</span><span class="s1">mean_precision_prior_</span>
            <span class="s4">/ </span><span class="s1">self</span><span class="s4">.</span><span class="s1">n_components</span>
            <span class="s4">* </span><span class="s1">np</span><span class="s4">.</span><span class="s1">dot</span><span class="s4">((</span><span class="s1">nk </span><span class="s4">/ </span><span class="s1">self</span><span class="s4">.</span><span class="s1">mean_precision_</span><span class="s4">) * </span><span class="s1">diff</span><span class="s4">.</span><span class="s1">T</span><span class="s4">, </span><span class="s1">diff</span><span class="s4">)</span>
        <span class="s4">)</span>

        <span class="s2"># Contrary to the original bishop book, we normalize the covariances</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">covariances_ </span><span class="s4">/= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">degrees_of_freedom_</span>

    <span class="s3">def </span><span class="s1">_estimate_wishart_diag</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">nk</span><span class="s4">, </span><span class="s1">xk</span><span class="s4">, </span><span class="s1">sk</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Estimate the diag Wishart distribution parameters. 
 
        Parameters 
        ---------- 
        X : array-like of shape (n_samples, n_features) 
 
        nk : array-like of shape (n_components,) 
 
        xk : array-like of shape (n_components, n_features) 
 
        sk : array-like of shape (n_components, n_features) 
        &quot;&quot;&quot;</span>
        <span class="s1">_</span><span class="s4">, </span><span class="s1">n_features </span><span class="s4">= </span><span class="s1">xk</span><span class="s4">.</span><span class="s1">shape</span>

        <span class="s2"># Warning : in some Bishop book, there is a typo on the formula 10.63</span>
        <span class="s2"># `degrees_of_freedom_k = degrees_of_freedom_0 + Nk`</span>
        <span class="s2"># is the correct formula</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">degrees_of_freedom_ </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">degrees_of_freedom_prior_ </span><span class="s4">+ </span><span class="s1">nk</span>

        <span class="s1">diff </span><span class="s4">= </span><span class="s1">xk </span><span class="s4">- </span><span class="s1">self</span><span class="s4">.</span><span class="s1">mean_prior_</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">covariances_ </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">covariance_prior_ </span><span class="s4">+ </span><span class="s1">nk</span><span class="s4">[:, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">newaxis</span><span class="s4">] * (</span>
            <span class="s1">sk</span>
            <span class="s4">+ (</span><span class="s1">self</span><span class="s4">.</span><span class="s1">mean_precision_prior_ </span><span class="s4">/ </span><span class="s1">self</span><span class="s4">.</span><span class="s1">mean_precision_</span><span class="s4">)[:, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">newaxis</span><span class="s4">]</span>
            <span class="s4">* </span><span class="s1">np</span><span class="s4">.</span><span class="s1">square</span><span class="s4">(</span><span class="s1">diff</span><span class="s4">)</span>
        <span class="s4">)</span>

        <span class="s2"># Contrary to the original bishop book, we normalize the covariances</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">covariances_ </span><span class="s4">/= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">degrees_of_freedom_</span><span class="s4">[:, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">newaxis</span><span class="s4">]</span>

    <span class="s3">def </span><span class="s1">_estimate_wishart_spherical</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">nk</span><span class="s4">, </span><span class="s1">xk</span><span class="s4">, </span><span class="s1">sk</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Estimate the spherical Wishart distribution parameters. 
 
        Parameters 
        ---------- 
        X : array-like of shape (n_samples, n_features) 
 
        nk : array-like of shape (n_components,) 
 
        xk : array-like of shape (n_components, n_features) 
 
        sk : array-like of shape (n_components,) 
        &quot;&quot;&quot;</span>
        <span class="s1">_</span><span class="s4">, </span><span class="s1">n_features </span><span class="s4">= </span><span class="s1">xk</span><span class="s4">.</span><span class="s1">shape</span>

        <span class="s2"># Warning : in some Bishop book, there is a typo on the formula 10.63</span>
        <span class="s2"># `degrees_of_freedom_k = degrees_of_freedom_0 + Nk`</span>
        <span class="s2"># is the correct formula</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">degrees_of_freedom_ </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">degrees_of_freedom_prior_ </span><span class="s4">+ </span><span class="s1">nk</span>

        <span class="s1">diff </span><span class="s4">= </span><span class="s1">xk </span><span class="s4">- </span><span class="s1">self</span><span class="s4">.</span><span class="s1">mean_prior_</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">covariances_ </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">covariance_prior_ </span><span class="s4">+ </span><span class="s1">nk </span><span class="s4">* (</span>
            <span class="s1">sk</span>
            <span class="s4">+ </span><span class="s1">self</span><span class="s4">.</span><span class="s1">mean_precision_prior_</span>
            <span class="s4">/ </span><span class="s1">self</span><span class="s4">.</span><span class="s1">mean_precision_</span>
            <span class="s4">* </span><span class="s1">np</span><span class="s4">.</span><span class="s1">mean</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">square</span><span class="s4">(</span><span class="s1">diff</span><span class="s4">), </span><span class="s5">1</span><span class="s4">)</span>
        <span class="s4">)</span>

        <span class="s2"># Contrary to the original bishop book, we normalize the covariances</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">covariances_ </span><span class="s4">/= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">degrees_of_freedom_</span>

    <span class="s3">def </span><span class="s1">_m_step</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">X</span><span class="s4">, </span><span class="s1">log_resp</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;M step. 
 
        Parameters 
        ---------- 
        X : array-like of shape (n_samples, n_features) 
 
        log_resp : array-like of shape (n_samples, n_components) 
            Logarithm of the posterior probabilities (or responsibilities) of 
            the point of each sample in X. 
        &quot;&quot;&quot;</span>
        <span class="s1">n_samples</span><span class="s4">, </span><span class="s1">_ </span><span class="s4">= </span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span>

        <span class="s1">nk</span><span class="s4">, </span><span class="s1">xk</span><span class="s4">, </span><span class="s1">sk </span><span class="s4">= </span><span class="s1">_estimate_gaussian_parameters</span><span class="s4">(</span>
            <span class="s1">X</span><span class="s4">, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">exp</span><span class="s4">(</span><span class="s1">log_resp</span><span class="s4">), </span><span class="s1">self</span><span class="s4">.</span><span class="s1">reg_covar</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">covariance_type</span>
        <span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_estimate_weights</span><span class="s4">(</span><span class="s1">nk</span><span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_estimate_means</span><span class="s4">(</span><span class="s1">nk</span><span class="s4">, </span><span class="s1">xk</span><span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_estimate_precisions</span><span class="s4">(</span><span class="s1">nk</span><span class="s4">, </span><span class="s1">xk</span><span class="s4">, </span><span class="s1">sk</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_estimate_log_weights</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">weight_concentration_prior_type </span><span class="s4">== </span><span class="s6">&quot;dirichlet_process&quot;</span><span class="s4">:</span>
            <span class="s1">digamma_sum </span><span class="s4">= </span><span class="s1">digamma</span><span class="s4">(</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">weight_concentration_</span><span class="s4">[</span><span class="s5">0</span><span class="s4">] + </span><span class="s1">self</span><span class="s4">.</span><span class="s1">weight_concentration_</span><span class="s4">[</span><span class="s5">1</span><span class="s4">]</span>
            <span class="s4">)</span>
            <span class="s1">digamma_a </span><span class="s4">= </span><span class="s1">digamma</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">weight_concentration_</span><span class="s4">[</span><span class="s5">0</span><span class="s4">])</span>
            <span class="s1">digamma_b </span><span class="s4">= </span><span class="s1">digamma</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">weight_concentration_</span><span class="s4">[</span><span class="s5">1</span><span class="s4">])</span>
            <span class="s3">return </span><span class="s4">(</span>
                <span class="s1">digamma_a</span>
                <span class="s4">- </span><span class="s1">digamma_sum</span>
                <span class="s4">+ </span><span class="s1">np</span><span class="s4">.</span><span class="s1">hstack</span><span class="s4">((</span><span class="s5">0</span><span class="s4">, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">cumsum</span><span class="s4">(</span><span class="s1">digamma_b </span><span class="s4">- </span><span class="s1">digamma_sum</span><span class="s4">)[:-</span><span class="s5">1</span><span class="s4">]))</span>
            <span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s2"># case Variational Gaussian mixture with dirichlet distribution</span>
            <span class="s3">return </span><span class="s1">digamma</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">weight_concentration_</span><span class="s4">) - </span><span class="s1">digamma</span><span class="s4">(</span>
                <span class="s1">np</span><span class="s4">.</span><span class="s1">sum</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">weight_concentration_</span><span class="s4">)</span>
            <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_estimate_log_prob</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">X</span><span class="s4">):</span>
        <span class="s1">_</span><span class="s4">, </span><span class="s1">n_features </span><span class="s4">= </span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span>
        <span class="s2"># We remove `n_features * np.log(self.degrees_of_freedom_)` because</span>
        <span class="s2"># the precision matrix is normalized</span>
        <span class="s1">log_gauss </span><span class="s4">= </span><span class="s1">_estimate_log_gaussian_prob</span><span class="s4">(</span>
            <span class="s1">X</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">means_</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">precisions_cholesky_</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">covariance_type</span>
        <span class="s4">) - </span><span class="s5">0.5 </span><span class="s4">* </span><span class="s1">n_features </span><span class="s4">* </span><span class="s1">np</span><span class="s4">.</span><span class="s1">log</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">degrees_of_freedom_</span><span class="s4">)</span>

        <span class="s1">log_lambda </span><span class="s4">= </span><span class="s1">n_features </span><span class="s4">* </span><span class="s1">np</span><span class="s4">.</span><span class="s1">log</span><span class="s4">(</span><span class="s5">2.0</span><span class="s4">) + </span><span class="s1">np</span><span class="s4">.</span><span class="s1">sum</span><span class="s4">(</span>
            <span class="s1">digamma</span><span class="s4">(</span>
                <span class="s5">0.5</span>
                <span class="s4">* (</span><span class="s1">self</span><span class="s4">.</span><span class="s1">degrees_of_freedom_ </span><span class="s4">- </span><span class="s1">np</span><span class="s4">.</span><span class="s1">arange</span><span class="s4">(</span><span class="s5">0</span><span class="s4">, </span><span class="s1">n_features</span><span class="s4">)[:, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">newaxis</span><span class="s4">])</span>
            <span class="s4">),</span>
            <span class="s5">0</span><span class="s4">,</span>
        <span class="s4">)</span>

        <span class="s3">return </span><span class="s1">log_gauss </span><span class="s4">+ </span><span class="s5">0.5 </span><span class="s4">* (</span><span class="s1">log_lambda </span><span class="s4">- </span><span class="s1">n_features </span><span class="s4">/ </span><span class="s1">self</span><span class="s4">.</span><span class="s1">mean_precision_</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_compute_lower_bound</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">log_resp</span><span class="s4">, </span><span class="s1">log_prob_norm</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Estimate the lower bound of the model. 
 
        The lower bound on the likelihood (of the training data with respect to 
        the model) is used to detect the convergence and has to increase at 
        each iteration. 
 
        Parameters 
        ---------- 
        X : array-like of shape (n_samples, n_features) 
 
        log_resp : array, shape (n_samples, n_components) 
            Logarithm of the posterior probabilities (or responsibilities) of 
            the point of each sample in X. 
 
        log_prob_norm : float 
            Logarithm of the probability of each sample in X. 
 
        Returns 
        ------- 
        lower_bound : float 
        &quot;&quot;&quot;</span>
        <span class="s2"># Contrary to the original formula, we have done some simplification</span>
        <span class="s2"># and removed all the constant terms.</span>
        <span class="s4">(</span><span class="s1">n_features</span><span class="s4">,) = </span><span class="s1">self</span><span class="s4">.</span><span class="s1">mean_prior_</span><span class="s4">.</span><span class="s1">shape</span>

        <span class="s2"># We removed `.5 * n_features * np.log(self.degrees_of_freedom_)`</span>
        <span class="s2"># because the precision matrix is normalized.</span>
        <span class="s1">log_det_precisions_chol </span><span class="s4">= </span><span class="s1">_compute_log_det_cholesky</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">precisions_cholesky_</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">covariance_type</span><span class="s4">, </span><span class="s1">n_features</span>
        <span class="s4">) - </span><span class="s5">0.5 </span><span class="s4">* </span><span class="s1">n_features </span><span class="s4">* </span><span class="s1">np</span><span class="s4">.</span><span class="s1">log</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">degrees_of_freedom_</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">covariance_type </span><span class="s4">== </span><span class="s6">&quot;tied&quot;</span><span class="s4">:</span>
            <span class="s1">log_wishart </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">n_components </span><span class="s4">* </span><span class="s1">np</span><span class="s4">.</span><span class="s1">float64</span><span class="s4">(</span>
                <span class="s1">_log_wishart_norm</span><span class="s4">(</span>
                    <span class="s1">self</span><span class="s4">.</span><span class="s1">degrees_of_freedom_</span><span class="s4">, </span><span class="s1">log_det_precisions_chol</span><span class="s4">, </span><span class="s1">n_features</span>
                <span class="s4">)</span>
            <span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">log_wishart </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">sum</span><span class="s4">(</span>
                <span class="s1">_log_wishart_norm</span><span class="s4">(</span>
                    <span class="s1">self</span><span class="s4">.</span><span class="s1">degrees_of_freedom_</span><span class="s4">, </span><span class="s1">log_det_precisions_chol</span><span class="s4">, </span><span class="s1">n_features</span>
                <span class="s4">)</span>
            <span class="s4">)</span>

        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">weight_concentration_prior_type </span><span class="s4">== </span><span class="s6">&quot;dirichlet_process&quot;</span><span class="s4">:</span>
            <span class="s1">log_norm_weight </span><span class="s4">= -</span><span class="s1">np</span><span class="s4">.</span><span class="s1">sum</span><span class="s4">(</span>
                <span class="s1">betaln</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">weight_concentration_</span><span class="s4">[</span><span class="s5">0</span><span class="s4">], </span><span class="s1">self</span><span class="s4">.</span><span class="s1">weight_concentration_</span><span class="s4">[</span><span class="s5">1</span><span class="s4">])</span>
            <span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">log_norm_weight </span><span class="s4">= </span><span class="s1">_log_dirichlet_norm</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">weight_concentration_</span><span class="s4">)</span>

        <span class="s3">return </span><span class="s4">(</span>
            <span class="s4">-</span><span class="s1">np</span><span class="s4">.</span><span class="s1">sum</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">exp</span><span class="s4">(</span><span class="s1">log_resp</span><span class="s4">) * </span><span class="s1">log_resp</span><span class="s4">)</span>
            <span class="s4">- </span><span class="s1">log_wishart</span>
            <span class="s4">- </span><span class="s1">log_norm_weight</span>
            <span class="s4">- </span><span class="s5">0.5 </span><span class="s4">* </span><span class="s1">n_features </span><span class="s4">* </span><span class="s1">np</span><span class="s4">.</span><span class="s1">sum</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">log</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">mean_precision_</span><span class="s4">))</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_get_parameters</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">weight_concentration_</span><span class="s4">,</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">mean_precision_</span><span class="s4">,</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">means_</span><span class="s4">,</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">degrees_of_freedom_</span><span class="s4">,</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">covariances_</span><span class="s4">,</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">precisions_cholesky_</span><span class="s4">,</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_set_parameters</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">params</span><span class="s4">):</span>
        <span class="s4">(</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">weight_concentration_</span><span class="s4">,</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">mean_precision_</span><span class="s4">,</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">means_</span><span class="s4">,</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">degrees_of_freedom_</span><span class="s4">,</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">covariances_</span><span class="s4">,</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">precisions_cholesky_</span><span class="s4">,</span>
        <span class="s4">) = </span><span class="s1">params</span>

        <span class="s2"># Weights computation</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">weight_concentration_prior_type </span><span class="s4">== </span><span class="s6">&quot;dirichlet_process&quot;</span><span class="s4">:</span>
            <span class="s1">weight_dirichlet_sum </span><span class="s4">= (</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">weight_concentration_</span><span class="s4">[</span><span class="s5">0</span><span class="s4">] + </span><span class="s1">self</span><span class="s4">.</span><span class="s1">weight_concentration_</span><span class="s4">[</span><span class="s5">1</span><span class="s4">]</span>
            <span class="s4">)</span>
            <span class="s1">tmp </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">weight_concentration_</span><span class="s4">[</span><span class="s5">1</span><span class="s4">] / </span><span class="s1">weight_dirichlet_sum</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">weights_ </span><span class="s4">= (</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">weight_concentration_</span><span class="s4">[</span><span class="s5">0</span><span class="s4">]</span>
                <span class="s4">/ </span><span class="s1">weight_dirichlet_sum</span>
                <span class="s4">* </span><span class="s1">np</span><span class="s4">.</span><span class="s1">hstack</span><span class="s4">((</span><span class="s5">1</span><span class="s4">, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">cumprod</span><span class="s4">(</span><span class="s1">tmp</span><span class="s4">[:-</span><span class="s5">1</span><span class="s4">])))</span>
            <span class="s4">)</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">weights_ </span><span class="s4">/= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">sum</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">weights_</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">weights_ </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">weight_concentration_ </span><span class="s4">/ </span><span class="s1">np</span><span class="s4">.</span><span class="s1">sum</span><span class="s4">(</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">weight_concentration_</span>
            <span class="s4">)</span>

        <span class="s2"># Precisions matrices computation</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">covariance_type </span><span class="s4">== </span><span class="s6">&quot;full&quot;</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">precisions_ </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">array</span><span class="s4">(</span>
                <span class="s4">[</span>
                    <span class="s1">np</span><span class="s4">.</span><span class="s1">dot</span><span class="s4">(</span><span class="s1">prec_chol</span><span class="s4">, </span><span class="s1">prec_chol</span><span class="s4">.</span><span class="s1">T</span><span class="s4">)</span>
                    <span class="s3">for </span><span class="s1">prec_chol </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">precisions_cholesky_</span>
                <span class="s4">]</span>
            <span class="s4">)</span>

        <span class="s3">elif </span><span class="s1">self</span><span class="s4">.</span><span class="s1">covariance_type </span><span class="s4">== </span><span class="s6">&quot;tied&quot;</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">precisions_ </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">dot</span><span class="s4">(</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">precisions_cholesky_</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">precisions_cholesky_</span><span class="s4">.</span><span class="s1">T</span>
            <span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">precisions_ </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">precisions_cholesky_</span><span class="s4">**</span><span class="s5">2</span>
</pre>
</body>
</html>