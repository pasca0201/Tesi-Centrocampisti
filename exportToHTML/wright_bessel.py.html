<html>
<head>
<title>wright_bessel.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #2aacb8;}
.s5 { color: #6aab73;}
.s6 { color: #7a7e85;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
wright_bessel.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Precompute coefficients of several series expansions 
of Wright's generalized Bessel function Phi(a, b, x). 
 
See https://dlmf.nist.gov/10.46.E1 with rho=a, beta=b, z=x. 
&quot;&quot;&quot;</span>
<span class="s2">from </span><span class="s1">argparse </span><span class="s2">import </span><span class="s1">ArgumentParser</span><span class="s3">, </span><span class="s1">RawTextHelpFormatter</span>
<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">from </span><span class="s1">scipy</span><span class="s3">.</span><span class="s1">integrate </span><span class="s2">import </span><span class="s1">quad</span>
<span class="s2">from </span><span class="s1">scipy</span><span class="s3">.</span><span class="s1">optimize </span><span class="s2">import </span><span class="s1">minimize_scalar</span><span class="s3">, </span><span class="s1">curve_fit</span>
<span class="s2">from </span><span class="s1">time </span><span class="s2">import </span><span class="s1">time</span>

<span class="s2">try</span><span class="s3">:</span>
    <span class="s2">import </span><span class="s1">sympy</span>
    <span class="s2">from </span><span class="s1">sympy </span><span class="s2">import </span><span class="s1">EulerGamma</span><span class="s3">, </span><span class="s1">Rational</span><span class="s3">, </span><span class="s1">S</span><span class="s3">, </span><span class="s1">Sum</span><span class="s3">, </span><span class="s1">\</span>
        <span class="s1">factorial</span><span class="s3">, </span><span class="s1">gamma</span><span class="s3">, </span><span class="s1">gammasimp</span><span class="s3">, </span><span class="s1">pi</span><span class="s3">, </span><span class="s1">polygamma</span><span class="s3">, </span><span class="s1">symbols</span><span class="s3">, </span><span class="s1">zeta</span>
    <span class="s2">from </span><span class="s1">sympy</span><span class="s3">.</span><span class="s1">polys</span><span class="s3">.</span><span class="s1">polyfuncs </span><span class="s2">import </span><span class="s1">horner</span>
<span class="s2">except </span><span class="s1">ImportError</span><span class="s3">:</span>
    <span class="s2">pass</span>


<span class="s2">def </span><span class="s1">series_small_a</span><span class="s3">():</span>
    <span class="s0">&quot;&quot;&quot;Tylor series expansion of Phi(a, b, x) in a=0 up to order 5. 
    &quot;&quot;&quot;</span>
    <span class="s1">order </span><span class="s3">= </span><span class="s4">5</span>
    <span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">k </span><span class="s3">= </span><span class="s1">symbols</span><span class="s3">(</span><span class="s5">&quot;a b x k&quot;</span><span class="s3">)</span>
    <span class="s1">A </span><span class="s3">= []  </span><span class="s6"># terms with a</span>
    <span class="s1">X </span><span class="s3">= []  </span><span class="s6"># terms with x</span>
    <span class="s1">B </span><span class="s3">= []  </span><span class="s6"># terms with b (polygammas)</span>
    <span class="s6"># Phi(a, b, x) = exp(x)/gamma(b) * sum(A[i] * X[i] * B[i])</span>
    <span class="s1">expression </span><span class="s3">= </span><span class="s1">Sum</span><span class="s3">(</span><span class="s1">x</span><span class="s3">**</span><span class="s1">k</span><span class="s3">/</span><span class="s1">factorial</span><span class="s3">(</span><span class="s1">k</span><span class="s3">)/</span><span class="s1">gamma</span><span class="s3">(</span><span class="s1">a</span><span class="s3">*</span><span class="s1">k</span><span class="s3">+</span><span class="s1">b</span><span class="s3">), (</span><span class="s1">k</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s1">S</span><span class="s3">.</span><span class="s1">Infinity</span><span class="s3">))</span>
    <span class="s1">expression </span><span class="s3">= </span><span class="s1">gamma</span><span class="s3">(</span><span class="s1">b</span><span class="s3">)/</span><span class="s1">sympy</span><span class="s3">.</span><span class="s1">exp</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) * </span><span class="s1">expression</span>

    <span class="s6"># nth term of taylor series in a=0: a^n/n! * (d^n Phi(a, b, x)/da^n at a=0)</span>
    <span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s4">0</span><span class="s3">, </span><span class="s1">order</span><span class="s3">+</span><span class="s4">1</span><span class="s3">):</span>
        <span class="s1">term </span><span class="s3">= </span><span class="s1">expression</span><span class="s3">.</span><span class="s1">diff</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">n</span><span class="s3">).</span><span class="s1">subs</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s4">0</span><span class="s3">).</span><span class="s1">simplify</span><span class="s3">().</span><span class="s1">doit</span><span class="s3">()</span>
        <span class="s6"># set the whole bracket involving polygammas to 1</span>
        <span class="s1">x_part </span><span class="s3">= (</span><span class="s1">term</span><span class="s3">.</span><span class="s1">subs</span><span class="s3">(</span><span class="s1">polygamma</span><span class="s3">(</span><span class="s4">0</span><span class="s3">, </span><span class="s1">b</span><span class="s3">), </span><span class="s4">1</span><span class="s3">)</span>
                  <span class="s3">.</span><span class="s1">replace</span><span class="s3">(</span><span class="s1">polygamma</span><span class="s3">, </span><span class="s2">lambda </span><span class="s3">*</span><span class="s1">args</span><span class="s3">: </span><span class="s4">0</span><span class="s3">))</span>
        <span class="s6"># sign convention: x part always positive</span>
        <span class="s1">x_part </span><span class="s3">*= (-</span><span class="s4">1</span><span class="s3">)**</span><span class="s1">n</span>

        <span class="s1">A</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">a</span><span class="s3">**</span><span class="s1">n</span><span class="s3">/</span><span class="s1">factorial</span><span class="s3">(</span><span class="s1">n</span><span class="s3">))</span>
        <span class="s1">X</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">horner</span><span class="s3">(</span><span class="s1">x_part</span><span class="s3">))</span>
        <span class="s1">B</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">horner</span><span class="s3">((</span><span class="s1">term</span><span class="s3">/</span><span class="s1">x_part</span><span class="s3">).</span><span class="s1">simplify</span><span class="s3">()))</span>

    <span class="s1">s </span><span class="s3">= </span><span class="s5">&quot;Tylor series expansion of Phi(a, b, x) in a=0 up to order 5.</span><span class="s2">\n</span><span class="s5">&quot;</span>
    <span class="s1">s </span><span class="s3">+= </span><span class="s5">&quot;Phi(a, b, x) = exp(x)/gamma(b) * sum(A[i] * X[i] * B[i], i=0..5)</span><span class="s2">\n</span><span class="s5">&quot;</span>
    <span class="s2">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">c </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">([</span><span class="s5">'A'</span><span class="s3">, </span><span class="s5">'X'</span><span class="s3">, </span><span class="s5">'B'</span><span class="s3">], [</span><span class="s1">A</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">B</span><span class="s3">]):</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">c</span><span class="s3">)):</span>
            <span class="s1">s </span><span class="s3">+= </span><span class="s5">f&quot;</span><span class="s2">\n{</span><span class="s1">name</span><span class="s2">}</span><span class="s5">[</span><span class="s2">{</span><span class="s1">i</span><span class="s2">}</span><span class="s5">] = &quot; </span><span class="s3">+ </span><span class="s1">str</span><span class="s3">(</span><span class="s1">c</span><span class="s3">[</span><span class="s1">i</span><span class="s3">])</span>
    <span class="s2">return </span><span class="s1">s</span>


<span class="s6"># expansion of digamma</span>
<span class="s2">def </span><span class="s1">dg_series</span><span class="s3">(</span><span class="s1">z</span><span class="s3">, </span><span class="s1">n</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Symbolic expansion of digamma(z) in z=0 to order n. 
 
    See https://dlmf.nist.gov/5.7.E4 and with https://dlmf.nist.gov/5.5.E2 
    &quot;&quot;&quot;</span>
    <span class="s1">k </span><span class="s3">= </span><span class="s1">symbols</span><span class="s3">(</span><span class="s5">&quot;k&quot;</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s3">-</span><span class="s4">1</span><span class="s3">/</span><span class="s1">z </span><span class="s3">- </span><span class="s1">EulerGamma </span><span class="s3">+ </span><span class="s1">\</span>
        <span class="s1">sympy</span><span class="s3">.</span><span class="s1">summation</span><span class="s3">((-</span><span class="s4">1</span><span class="s3">)**</span><span class="s1">k </span><span class="s3">* </span><span class="s1">zeta</span><span class="s3">(</span><span class="s1">k</span><span class="s3">) * </span><span class="s1">z</span><span class="s3">**(</span><span class="s1">k</span><span class="s3">-</span><span class="s4">1</span><span class="s3">), (</span><span class="s1">k</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s1">n</span><span class="s3">+</span><span class="s4">1</span><span class="s3">))</span>


<span class="s2">def </span><span class="s1">pg_series</span><span class="s3">(</span><span class="s1">k</span><span class="s3">, </span><span class="s1">z</span><span class="s3">, </span><span class="s1">n</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Symbolic expansion of polygamma(k, z) in z=0 to order n.&quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">sympy</span><span class="s3">.</span><span class="s1">diff</span><span class="s3">(</span><span class="s1">dg_series</span><span class="s3">(</span><span class="s1">z</span><span class="s3">, </span><span class="s1">n</span><span class="s3">+</span><span class="s1">k</span><span class="s3">), </span><span class="s1">z</span><span class="s3">, </span><span class="s1">k</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">series_small_a_small_b</span><span class="s3">():</span>
    <span class="s0">&quot;&quot;&quot;Tylor series expansion of Phi(a, b, x) in a=0 and b=0 up to order 5. 
 
    Be aware of cancellation of poles in b=0 of digamma(b)/Gamma(b) and 
    polygamma functions. 
 
    digamma(b)/Gamma(b) = -1 - 2*M_EG*b + O(b^2) 
    digamma(b)^2/Gamma(b) = 1/b + 3*M_EG + b*(-5/12*PI^2+7/2*M_EG^2) + O(b^2) 
    polygamma(1, b)/Gamma(b) = 1/b + M_EG + b*(1/12*PI^2 + 1/2*M_EG^2) + O(b^2) 
    and so on. 
    &quot;&quot;&quot;</span>
    <span class="s1">order </span><span class="s3">= </span><span class="s4">5</span>
    <span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">k </span><span class="s3">= </span><span class="s1">symbols</span><span class="s3">(</span><span class="s5">&quot;a b x k&quot;</span><span class="s3">)</span>
    <span class="s1">M_PI</span><span class="s3">, </span><span class="s1">M_EG</span><span class="s3">, </span><span class="s1">M_Z3 </span><span class="s3">= </span><span class="s1">symbols</span><span class="s3">(</span><span class="s5">&quot;M_PI M_EG M_Z3&quot;</span><span class="s3">)</span>
    <span class="s1">c_subs </span><span class="s3">= {</span><span class="s1">pi</span><span class="s3">: </span><span class="s1">M_PI</span><span class="s3">, </span><span class="s1">EulerGamma</span><span class="s3">: </span><span class="s1">M_EG</span><span class="s3">, </span><span class="s1">zeta</span><span class="s3">(</span><span class="s4">3</span><span class="s3">): </span><span class="s1">M_Z3</span><span class="s3">}</span>
    <span class="s1">A </span><span class="s3">= []  </span><span class="s6"># terms with a</span>
    <span class="s1">X </span><span class="s3">= []  </span><span class="s6"># terms with x</span>
    <span class="s1">B </span><span class="s3">= []  </span><span class="s6"># terms with b (polygammas expanded)</span>
    <span class="s1">C </span><span class="s3">= []  </span><span class="s6"># terms that generate B</span>
    <span class="s6"># Phi(a, b, x) = exp(x) * sum(A[i] * X[i] * B[i])</span>
    <span class="s6"># B[0] = 1</span>
    <span class="s6"># B[k] = sum(C[k] * b**k/k!, k=0..)</span>
    <span class="s6"># Note: C[k] can be obtained from a series expansion of 1/gamma(b).</span>
    <span class="s1">expression </span><span class="s3">= </span><span class="s1">gamma</span><span class="s3">(</span><span class="s1">b</span><span class="s3">)/</span><span class="s1">sympy</span><span class="s3">.</span><span class="s1">exp</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) * </span><span class="s1">\</span>
        <span class="s1">Sum</span><span class="s3">(</span><span class="s1">x</span><span class="s3">**</span><span class="s1">k</span><span class="s3">/</span><span class="s1">factorial</span><span class="s3">(</span><span class="s1">k</span><span class="s3">)/</span><span class="s1">gamma</span><span class="s3">(</span><span class="s1">a</span><span class="s3">*</span><span class="s1">k</span><span class="s3">+</span><span class="s1">b</span><span class="s3">), (</span><span class="s1">k</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s1">S</span><span class="s3">.</span><span class="s1">Infinity</span><span class="s3">))</span>

    <span class="s6"># nth term of taylor series in a=0: a^n/n! * (d^n Phi(a, b, x)/da^n at a=0)</span>
    <span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s4">0</span><span class="s3">, </span><span class="s1">order</span><span class="s3">+</span><span class="s4">1</span><span class="s3">):</span>
        <span class="s1">term </span><span class="s3">= </span><span class="s1">expression</span><span class="s3">.</span><span class="s1">diff</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">n</span><span class="s3">).</span><span class="s1">subs</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s4">0</span><span class="s3">).</span><span class="s1">simplify</span><span class="s3">().</span><span class="s1">doit</span><span class="s3">()</span>
        <span class="s6"># set the whole bracket involving polygammas to 1</span>
        <span class="s1">x_part </span><span class="s3">= (</span><span class="s1">term</span><span class="s3">.</span><span class="s1">subs</span><span class="s3">(</span><span class="s1">polygamma</span><span class="s3">(</span><span class="s4">0</span><span class="s3">, </span><span class="s1">b</span><span class="s3">), </span><span class="s4">1</span><span class="s3">)</span>
                  <span class="s3">.</span><span class="s1">replace</span><span class="s3">(</span><span class="s1">polygamma</span><span class="s3">, </span><span class="s2">lambda </span><span class="s3">*</span><span class="s1">args</span><span class="s3">: </span><span class="s4">0</span><span class="s3">))</span>
        <span class="s6"># sign convention: x part always positive</span>
        <span class="s1">x_part </span><span class="s3">*= (-</span><span class="s4">1</span><span class="s3">)**</span><span class="s1">n</span>
        <span class="s6"># expansion of polygamma part with 1/gamma(b)</span>
        <span class="s1">pg_part </span><span class="s3">= </span><span class="s1">term</span><span class="s3">/</span><span class="s1">x_part</span><span class="s3">/</span><span class="s1">gamma</span><span class="s3">(</span><span class="s1">b</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">n </span><span class="s3">&gt;= </span><span class="s4">1</span><span class="s3">:</span>
            <span class="s6"># Note: highest term is digamma^n</span>
            <span class="s1">pg_part </span><span class="s3">= </span><span class="s1">pg_part</span><span class="s3">.</span><span class="s1">replace</span><span class="s3">(</span><span class="s1">polygamma</span><span class="s3">,</span>
                                      <span class="s2">lambda </span><span class="s1">k</span><span class="s3">, </span><span class="s1">x</span><span class="s3">: </span><span class="s1">pg_series</span><span class="s3">(</span><span class="s1">k</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">order</span><span class="s3">+</span><span class="s4">1</span><span class="s3">+</span><span class="s1">n</span><span class="s3">))</span>
            <span class="s1">pg_part </span><span class="s3">= (</span><span class="s1">pg_part</span><span class="s3">.</span><span class="s1">series</span><span class="s3">(</span><span class="s1">b</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s1">n</span><span class="s3">=</span><span class="s1">order</span><span class="s3">+</span><span class="s4">1</span><span class="s3">-</span><span class="s1">n</span><span class="s3">)</span>
                       <span class="s3">.</span><span class="s1">removeO</span><span class="s3">()</span>
                       <span class="s3">.</span><span class="s1">subs</span><span class="s3">(</span><span class="s1">polygamma</span><span class="s3">(</span><span class="s4">2</span><span class="s3">, </span><span class="s4">1</span><span class="s3">), -</span><span class="s4">2</span><span class="s3">*</span><span class="s1">zeta</span><span class="s3">(</span><span class="s4">3</span><span class="s3">))</span>
                       <span class="s3">.</span><span class="s1">simplify</span><span class="s3">()</span>
                       <span class="s3">)</span>

        <span class="s1">A</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">a</span><span class="s3">**</span><span class="s1">n</span><span class="s3">/</span><span class="s1">factorial</span><span class="s3">(</span><span class="s1">n</span><span class="s3">))</span>
        <span class="s1">X</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">horner</span><span class="s3">(</span><span class="s1">x_part</span><span class="s3">))</span>
        <span class="s1">B</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">pg_part</span><span class="s3">)</span>

    <span class="s6"># Calculate C and put in the k!</span>
    <span class="s1">C </span><span class="s3">= </span><span class="s1">sympy</span><span class="s3">.</span><span class="s1">Poly</span><span class="s3">(</span><span class="s1">B</span><span class="s3">[</span><span class="s4">1</span><span class="s3">].</span><span class="s1">subs</span><span class="s3">(</span><span class="s1">c_subs</span><span class="s3">), </span><span class="s1">b</span><span class="s3">).</span><span class="s1">coeffs</span><span class="s3">()</span>
    <span class="s1">C</span><span class="s3">.</span><span class="s1">reverse</span><span class="s3">()</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">C</span><span class="s3">)):</span>
        <span class="s1">C</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = (</span><span class="s1">C</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] * </span><span class="s1">factorial</span><span class="s3">(</span><span class="s1">i</span><span class="s3">)).</span><span class="s1">simplify</span><span class="s3">()</span>

    <span class="s1">s </span><span class="s3">= </span><span class="s5">&quot;Tylor series expansion of Phi(a, b, x) in a=0 and b=0 up to order 5.&quot;</span>
    <span class="s1">s </span><span class="s3">+= </span><span class="s5">&quot;</span><span class="s2">\n</span><span class="s5">Phi(a, b, x) = exp(x) * sum(A[i] * X[i] * B[i], i=0..5)</span><span class="s2">\n</span><span class="s5">&quot;</span>
    <span class="s1">s </span><span class="s3">+= </span><span class="s5">&quot;B[0] = 1</span><span class="s2">\n</span><span class="s5">&quot;</span>
    <span class="s1">s </span><span class="s3">+= </span><span class="s5">&quot;B[i] = sum(C[k+i-1] * b**k/k!, k=0..)</span><span class="s2">\n</span><span class="s5">&quot;</span>
    <span class="s1">s </span><span class="s3">+= </span><span class="s5">&quot;</span><span class="s2">\n</span><span class="s5">M_PI = pi&quot;</span>
    <span class="s1">s </span><span class="s3">+= </span><span class="s5">&quot;</span><span class="s2">\n</span><span class="s5">M_EG = EulerGamma&quot;</span>
    <span class="s1">s </span><span class="s3">+= </span><span class="s5">&quot;</span><span class="s2">\n</span><span class="s5">M_Z3 = zeta(3)&quot;</span>
    <span class="s2">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">c </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">([</span><span class="s5">'A'</span><span class="s3">, </span><span class="s5">'X'</span><span class="s3">], [</span><span class="s1">A</span><span class="s3">, </span><span class="s1">X</span><span class="s3">]):</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">c</span><span class="s3">)):</span>
            <span class="s1">s </span><span class="s3">+= </span><span class="s5">f&quot;</span><span class="s2">\n{</span><span class="s1">name</span><span class="s2">}</span><span class="s5">[</span><span class="s2">{</span><span class="s1">i</span><span class="s2">}</span><span class="s5">] = &quot;</span>
            <span class="s1">s </span><span class="s3">+= </span><span class="s1">str</span><span class="s3">(</span><span class="s1">c</span><span class="s3">[</span><span class="s1">i</span><span class="s3">])</span>
    <span class="s6"># For C, do also compute the values numerically</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">C</span><span class="s3">)):</span>
        <span class="s1">s </span><span class="s3">+= </span><span class="s5">f&quot;</span><span class="s2">\n</span><span class="s5"># C[</span><span class="s2">{</span><span class="s1">i</span><span class="s2">}</span><span class="s5">] = &quot;</span>
        <span class="s1">s </span><span class="s3">+= </span><span class="s1">str</span><span class="s3">(</span><span class="s1">C</span><span class="s3">[</span><span class="s1">i</span><span class="s3">])</span>
        <span class="s1">s </span><span class="s3">+= </span><span class="s5">f&quot;</span><span class="s2">\n</span><span class="s5">C[</span><span class="s2">{</span><span class="s1">i</span><span class="s2">}</span><span class="s5">] = &quot;</span>
        <span class="s1">s </span><span class="s3">+= </span><span class="s1">str</span><span class="s3">(</span><span class="s1">C</span><span class="s3">[</span><span class="s1">i</span><span class="s3">].</span><span class="s1">subs</span><span class="s3">({</span><span class="s1">M_EG</span><span class="s3">: </span><span class="s1">EulerGamma</span><span class="s3">, </span><span class="s1">M_PI</span><span class="s3">: </span><span class="s1">pi</span><span class="s3">, </span><span class="s1">M_Z3</span><span class="s3">: </span><span class="s1">zeta</span><span class="s3">(</span><span class="s4">3</span><span class="s3">)})</span>
                 <span class="s3">.</span><span class="s1">evalf</span><span class="s3">(</span><span class="s4">17</span><span class="s3">))</span>

    <span class="s6"># Does B have the assumed structure?</span>
    <span class="s1">s </span><span class="s3">+= </span><span class="s5">&quot;</span><span class="s2">\n\n</span><span class="s5">Test if B[i] does have the assumed structure.&quot;</span>
    <span class="s1">s </span><span class="s3">+= </span><span class="s5">&quot;</span><span class="s2">\n</span><span class="s5">C[i] are derived from B[1] alone.&quot;</span>
    <span class="s1">s </span><span class="s3">+= </span><span class="s5">&quot;</span><span class="s2">\n</span><span class="s5">Test B[2] == C[1] + b*C[2] + b^2/2*C[3] + b^3/6*C[4] + ..&quot;</span>
    <span class="s1">test </span><span class="s3">= </span><span class="s1">sum</span><span class="s3">([</span><span class="s1">b</span><span class="s3">**</span><span class="s1">k</span><span class="s3">/</span><span class="s1">factorial</span><span class="s3">(</span><span class="s1">k</span><span class="s3">) * </span><span class="s1">C</span><span class="s3">[</span><span class="s1">k</span><span class="s3">+</span><span class="s4">1</span><span class="s3">] </span><span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">order</span><span class="s3">-</span><span class="s4">1</span><span class="s3">)])</span>
    <span class="s1">test </span><span class="s3">= (</span><span class="s1">test </span><span class="s3">- </span><span class="s1">B</span><span class="s3">[</span><span class="s4">2</span><span class="s3">].</span><span class="s1">subs</span><span class="s3">(</span><span class="s1">c_subs</span><span class="s3">)).</span><span class="s1">simplify</span><span class="s3">()</span>
    <span class="s1">s </span><span class="s3">+= </span><span class="s5">f&quot;</span><span class="s2">\n</span><span class="s5">test successful = </span><span class="s2">{</span><span class="s1">test</span><span class="s3">==</span><span class="s1">S</span><span class="s3">(</span><span class="s4">0</span><span class="s3">)</span><span class="s2">}</span><span class="s5">&quot;</span>
    <span class="s1">s </span><span class="s3">+= </span><span class="s5">&quot;</span><span class="s2">\n</span><span class="s5">Test B[3] == C[2] + b*C[3] + b^2/2*C[4] + ..&quot;</span>
    <span class="s1">test </span><span class="s3">= </span><span class="s1">sum</span><span class="s3">([</span><span class="s1">b</span><span class="s3">**</span><span class="s1">k</span><span class="s3">/</span><span class="s1">factorial</span><span class="s3">(</span><span class="s1">k</span><span class="s3">) * </span><span class="s1">C</span><span class="s3">[</span><span class="s1">k</span><span class="s3">+</span><span class="s4">2</span><span class="s3">] </span><span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">order</span><span class="s3">-</span><span class="s4">2</span><span class="s3">)])</span>
    <span class="s1">test </span><span class="s3">= (</span><span class="s1">test </span><span class="s3">- </span><span class="s1">B</span><span class="s3">[</span><span class="s4">3</span><span class="s3">].</span><span class="s1">subs</span><span class="s3">(</span><span class="s1">c_subs</span><span class="s3">)).</span><span class="s1">simplify</span><span class="s3">()</span>
    <span class="s1">s </span><span class="s3">+= </span><span class="s5">f&quot;</span><span class="s2">\n</span><span class="s5">test successful = </span><span class="s2">{</span><span class="s1">test</span><span class="s3">==</span><span class="s1">S</span><span class="s3">(</span><span class="s4">0</span><span class="s3">)</span><span class="s2">}</span><span class="s5">&quot;</span>
    <span class="s2">return </span><span class="s1">s</span>


<span class="s2">def </span><span class="s1">asymptotic_series</span><span class="s3">():</span>
    <span class="s0">&quot;&quot;&quot;Asymptotic expansion for large x. 
 
    Phi(a, b, x) ~ Z^(1/2-b) * exp((1+a)/a * Z) * sum_k (-1)^k * C_k / Z^k 
    Z = (a*x)^(1/(1+a)) 
 
    Wright (1935) lists the coefficients C_0 and C_1 (he calls them a_0 and 
    a_1). With slightly different notation, Paris (2017) lists coefficients 
    c_k up to order k=3. 
    Paris (2017) uses ZP = (1+a)/a * Z  (ZP = Z of Paris) and 
    C_k = C_0 * (-a/(1+a))^k * c_k 
    &quot;&quot;&quot;</span>
    <span class="s1">order </span><span class="s3">= </span><span class="s4">8</span>

    <span class="s2">class </span><span class="s1">g</span><span class="s3">(</span><span class="s1">sympy</span><span class="s3">.</span><span class="s1">Function</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Helper function g according to Wright (1935) 
 
        g(n, rho, v) = (1 + (rho+2)/3 * v + (rho+2)*(rho+3)/(2*3) * v^2 + ...) 
 
        Note: Wright (1935) uses square root of above definition. 
        &quot;&quot;&quot;</span>
        <span class="s1">nargs </span><span class="s3">= </span><span class="s4">3</span>

        <span class="s3">@</span><span class="s1">classmethod</span>
        <span class="s2">def </span><span class="s1">eval</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">rho</span><span class="s3">, </span><span class="s1">v</span><span class="s3">):</span>
            <span class="s2">if not </span><span class="s1">n </span><span class="s3">&gt;= </span><span class="s4">0</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s5">&quot;must have n &gt;= 0&quot;</span><span class="s3">)</span>
            <span class="s2">elif </span><span class="s1">n </span><span class="s3">== </span><span class="s4">0</span><span class="s3">:</span>
                <span class="s2">return </span><span class="s4">1</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s2">return </span><span class="s1">g</span><span class="s3">(</span><span class="s1">n</span><span class="s3">-</span><span class="s4">1</span><span class="s3">, </span><span class="s1">rho</span><span class="s3">, </span><span class="s1">v</span><span class="s3">) </span><span class="s1">\</span>
                    <span class="s3">+ </span><span class="s1">gammasimp</span><span class="s3">(</span><span class="s1">gamma</span><span class="s3">(</span><span class="s1">rho</span><span class="s3">+</span><span class="s4">2</span><span class="s3">+</span><span class="s1">n</span><span class="s3">)/</span><span class="s1">gamma</span><span class="s3">(</span><span class="s1">rho</span><span class="s3">+</span><span class="s4">2</span><span class="s3">)) </span><span class="s1">\</span>
                    <span class="s3">/ </span><span class="s1">gammasimp</span><span class="s3">(</span><span class="s1">gamma</span><span class="s3">(</span><span class="s4">3</span><span class="s3">+</span><span class="s1">n</span><span class="s3">)/</span><span class="s1">gamma</span><span class="s3">(</span><span class="s4">3</span><span class="s3">))*</span><span class="s1">v</span><span class="s3">**</span><span class="s1">n</span>

    <span class="s2">class </span><span class="s1">coef_C</span><span class="s3">(</span><span class="s1">sympy</span><span class="s3">.</span><span class="s1">Function</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Calculate coefficients C_m for integer m. 
 
        C_m is the coefficient of v^(2*m) in the Taylor expansion in v=0 of 
        Gamma(m+1/2)/(2*pi) * (2/(rho+1))^(m+1/2) * (1-v)^(-b) 
            * g(rho, v)^(-m-1/2) 
        &quot;&quot;&quot;</span>
        <span class="s1">nargs </span><span class="s3">= </span><span class="s4">3</span>

        <span class="s3">@</span><span class="s1">classmethod</span>
        <span class="s2">def </span><span class="s1">eval</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, </span><span class="s1">m</span><span class="s3">, </span><span class="s1">rho</span><span class="s3">, </span><span class="s1">beta</span><span class="s3">):</span>
            <span class="s2">if not </span><span class="s1">m </span><span class="s3">&gt;= </span><span class="s4">0</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s5">&quot;must have m &gt;= 0&quot;</span><span class="s3">)</span>

            <span class="s1">v </span><span class="s3">= </span><span class="s1">symbols</span><span class="s3">(</span><span class="s5">&quot;v&quot;</span><span class="s3">)</span>
            <span class="s1">expression </span><span class="s3">= (</span><span class="s4">1</span><span class="s3">-</span><span class="s1">v</span><span class="s3">)**(-</span><span class="s1">beta</span><span class="s3">) * </span><span class="s1">g</span><span class="s3">(</span><span class="s4">2</span><span class="s3">*</span><span class="s1">m</span><span class="s3">, </span><span class="s1">rho</span><span class="s3">, </span><span class="s1">v</span><span class="s3">)**(-</span><span class="s1">m</span><span class="s3">-</span><span class="s1">Rational</span><span class="s3">(</span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">))</span>
            <span class="s1">res </span><span class="s3">= </span><span class="s1">expression</span><span class="s3">.</span><span class="s1">diff</span><span class="s3">(</span><span class="s1">v</span><span class="s3">, </span><span class="s4">2</span><span class="s3">*</span><span class="s1">m</span><span class="s3">).</span><span class="s1">subs</span><span class="s3">(</span><span class="s1">v</span><span class="s3">, </span><span class="s4">0</span><span class="s3">) / </span><span class="s1">factorial</span><span class="s3">(</span><span class="s4">2</span><span class="s3">*</span><span class="s1">m</span><span class="s3">)</span>
            <span class="s1">res </span><span class="s3">= </span><span class="s1">res </span><span class="s3">* (</span><span class="s1">gamma</span><span class="s3">(</span><span class="s1">m </span><span class="s3">+ </span><span class="s1">Rational</span><span class="s3">(</span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">)) / (</span><span class="s4">2</span><span class="s3">*</span><span class="s1">pi</span><span class="s3">)</span>
                         <span class="s3">* (</span><span class="s4">2</span><span class="s3">/(</span><span class="s1">rho</span><span class="s3">+</span><span class="s4">1</span><span class="s3">))**(</span><span class="s1">m </span><span class="s3">+ </span><span class="s1">Rational</span><span class="s3">(</span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">)))</span>
            <span class="s2">return </span><span class="s1">res</span>

    <span class="s6"># in order to have nice ordering/sorting of expressions, we set a = xa.</span>
    <span class="s1">xa</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">xap1 </span><span class="s3">= </span><span class="s1">symbols</span><span class="s3">(</span><span class="s5">&quot;xa b xap1&quot;</span><span class="s3">)</span>
    <span class="s1">C0 </span><span class="s3">= </span><span class="s1">coef_C</span><span class="s3">(</span><span class="s4">0</span><span class="s3">, </span><span class="s1">xa</span><span class="s3">, </span><span class="s1">b</span><span class="s3">)</span>
    <span class="s6"># a1 = a(1, rho, beta)</span>
    <span class="s1">s </span><span class="s3">= </span><span class="s5">&quot;Asymptotic expansion for large x</span><span class="s2">\n</span><span class="s5">&quot;</span>
    <span class="s1">s </span><span class="s3">+= </span><span class="s5">&quot;Phi(a, b, x) = Z**(1/2-b) * exp((1+a)/a * Z) </span><span class="s2">\n</span><span class="s5">&quot;</span>
    <span class="s1">s </span><span class="s3">+= </span><span class="s5">&quot;               * sum((-1)**k * C[k]/Z**k, k=0..6)</span><span class="s2">\n\n</span><span class="s5">&quot;</span>
    <span class="s1">s </span><span class="s3">+= </span><span class="s5">&quot;Z      = pow(a * x, 1/(1+a))</span><span class="s2">\n</span><span class="s5">&quot;</span>
    <span class="s1">s </span><span class="s3">+= </span><span class="s5">&quot;A[k]   = pow(a, k)</span><span class="s2">\n</span><span class="s5">&quot;</span>
    <span class="s1">s </span><span class="s3">+= </span><span class="s5">&quot;B[k]   = pow(b, k)</span><span class="s2">\n</span><span class="s5">&quot;</span>
    <span class="s1">s </span><span class="s3">+= </span><span class="s5">&quot;Ap1[k] = pow(1+a, k)</span><span class="s2">\n\n</span><span class="s5">&quot;</span>
    <span class="s1">s </span><span class="s3">+= </span><span class="s5">&quot;C[0] = 1./sqrt(2. * M_PI * Ap1[1])</span><span class="s2">\n</span><span class="s5">&quot;</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s4">1</span><span class="s3">, </span><span class="s1">order</span><span class="s3">+</span><span class="s4">1</span><span class="s3">):</span>
        <span class="s1">expr </span><span class="s3">= (</span><span class="s1">coef_C</span><span class="s3">(</span><span class="s1">i</span><span class="s3">, </span><span class="s1">xa</span><span class="s3">, </span><span class="s1">b</span><span class="s3">) / (</span><span class="s1">C0</span><span class="s3">/(</span><span class="s4">1</span><span class="s3">+</span><span class="s1">xa</span><span class="s3">)**</span><span class="s1">i</span><span class="s3">)).</span><span class="s1">simplify</span><span class="s3">()</span>
        <span class="s1">factor </span><span class="s3">= [</span><span class="s1">x</span><span class="s3">.</span><span class="s1">denominator</span><span class="s3">() </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">sympy</span><span class="s3">.</span><span class="s1">Poly</span><span class="s3">(</span><span class="s1">expr</span><span class="s3">).</span><span class="s1">coeffs</span><span class="s3">()]</span>
        <span class="s1">factor </span><span class="s3">= </span><span class="s1">sympy</span><span class="s3">.</span><span class="s1">lcm</span><span class="s3">(</span><span class="s1">factor</span><span class="s3">)</span>
        <span class="s1">expr </span><span class="s3">= (</span><span class="s1">expr </span><span class="s3">* </span><span class="s1">factor</span><span class="s3">).</span><span class="s1">simplify</span><span class="s3">().</span><span class="s1">collect</span><span class="s3">(</span><span class="s1">b</span><span class="s3">, </span><span class="s1">sympy</span><span class="s3">.</span><span class="s1">factor</span><span class="s3">)</span>
        <span class="s1">expr </span><span class="s3">= </span><span class="s1">expr</span><span class="s3">.</span><span class="s1">xreplace</span><span class="s3">({</span><span class="s1">xa</span><span class="s3">+</span><span class="s4">1</span><span class="s3">: </span><span class="s1">xap1</span><span class="s3">})</span>
        <span class="s1">s </span><span class="s3">+= </span><span class="s5">f&quot;C[</span><span class="s2">{</span><span class="s1">i</span><span class="s2">}</span><span class="s5">] = C[0] / (</span><span class="s2">{</span><span class="s1">factor</span><span class="s2">} </span><span class="s5">* Ap1[</span><span class="s2">{</span><span class="s1">i</span><span class="s2">}</span><span class="s5">])</span><span class="s2">\n</span><span class="s5">&quot;</span>
        <span class="s1">s </span><span class="s3">+= </span><span class="s5">f&quot;C[</span><span class="s2">{</span><span class="s1">i</span><span class="s2">}</span><span class="s5">] *= </span><span class="s2">{</span><span class="s1">str</span><span class="s3">(</span><span class="s1">expr</span><span class="s3">)</span><span class="s2">}\n\n</span><span class="s5">&quot;</span>
    <span class="s2">import </span><span class="s1">re</span>
    <span class="s1">re_a </span><span class="s3">= </span><span class="s1">re</span><span class="s3">.</span><span class="s1">compile</span><span class="s3">(</span><span class="s5">r'xa\*\*(\d+)'</span><span class="s3">)</span>
    <span class="s1">s </span><span class="s3">= </span><span class="s1">re_a</span><span class="s3">.</span><span class="s1">sub</span><span class="s3">(</span><span class="s5">r'A[\1]'</span><span class="s3">, </span><span class="s1">s</span><span class="s3">)</span>
    <span class="s1">re_b </span><span class="s3">= </span><span class="s1">re</span><span class="s3">.</span><span class="s1">compile</span><span class="s3">(</span><span class="s5">r'b\*\*(\d+)'</span><span class="s3">)</span>
    <span class="s1">s </span><span class="s3">= </span><span class="s1">re_b</span><span class="s3">.</span><span class="s1">sub</span><span class="s3">(</span><span class="s5">r'B[\1]'</span><span class="s3">, </span><span class="s1">s</span><span class="s3">)</span>
    <span class="s1">s </span><span class="s3">= </span><span class="s1">s</span><span class="s3">.</span><span class="s1">replace</span><span class="s3">(</span><span class="s5">'xap1'</span><span class="s3">, </span><span class="s5">'Ap1[1]'</span><span class="s3">)</span>
    <span class="s1">s </span><span class="s3">= </span><span class="s1">s</span><span class="s3">.</span><span class="s1">replace</span><span class="s3">(</span><span class="s5">'xa'</span><span class="s3">, </span><span class="s5">'a'</span><span class="s3">)</span>
    <span class="s6"># max integer = 2^31-1 = 2,147,483,647. Solution: Put a point after 10</span>
    <span class="s6"># or more digits.</span>
    <span class="s1">re_digits </span><span class="s3">= </span><span class="s1">re</span><span class="s3">.</span><span class="s1">compile</span><span class="s3">(</span><span class="s5">r'(\d{10,})'</span><span class="s3">)</span>
    <span class="s1">s </span><span class="s3">= </span><span class="s1">re_digits</span><span class="s3">.</span><span class="s1">sub</span><span class="s3">(</span><span class="s5">r'\1.'</span><span class="s3">, </span><span class="s1">s</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">s</span>


<span class="s2">def </span><span class="s1">optimal_epsilon_integral</span><span class="s3">():</span>
    <span class="s0">&quot;&quot;&quot;Fit optimal choice of epsilon for integral representation. 
 
    The integrand of 
        int_0^pi P(eps, a, b, x, phi) * dphi 
    can exhibit oscillatory behaviour. It stems from the cosine of P and can be 
    minimized by minimizing the arc length of the argument 
        f(phi) = eps * sin(phi) - x * eps^(-a) * sin(a * phi) + (1 - b) * phi 
    of cos(f(phi)). 
    We minimize the arc length in eps for a grid of values (a, b, x) and fit a 
    parametric function to it. 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">fp</span><span class="s3">(</span><span class="s1">eps</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">phi</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Derivative of f w.r.t. phi.&quot;&quot;&quot;</span>
        <span class="s1">eps_a </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">power</span><span class="s3">(</span><span class="s4">1. </span><span class="s3">* </span><span class="s1">eps</span><span class="s3">, -</span><span class="s1">a</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">eps </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">cos</span><span class="s3">(</span><span class="s1">phi</span><span class="s3">) - </span><span class="s1">a </span><span class="s3">* </span><span class="s1">x </span><span class="s3">* </span><span class="s1">eps_a </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">cos</span><span class="s3">(</span><span class="s1">a </span><span class="s3">* </span><span class="s1">phi</span><span class="s3">) + </span><span class="s4">1 </span><span class="s3">- </span><span class="s1">b</span>

    <span class="s2">def </span><span class="s1">arclength</span><span class="s3">(</span><span class="s1">eps</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">epsrel</span><span class="s3">=</span><span class="s4">1e-2</span><span class="s3">, </span><span class="s1">limit</span><span class="s3">=</span><span class="s4">100</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Compute Arc length of f. 
 
        Note that the arc length of a function f from t0 to t1 is given by 
            int_t0^t1 sqrt(1 + f'(t)^2) dt 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">quad</span><span class="s3">(</span><span class="s2">lambda </span><span class="s1">phi</span><span class="s3">: </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s4">1 </span><span class="s3">+ </span><span class="s1">fp</span><span class="s3">(</span><span class="s1">eps</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">phi</span><span class="s3">)**</span><span class="s4">2</span><span class="s3">),</span>
                    <span class="s4">0</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">pi</span><span class="s3">,</span>
                    <span class="s1">epsrel</span><span class="s3">=</span><span class="s1">epsrel</span><span class="s3">, </span><span class="s1">limit</span><span class="s3">=</span><span class="s4">100</span><span class="s3">)[</span><span class="s4">0</span><span class="s3">]</span>

    <span class="s6"># grid of minimal arc length values</span>
    <span class="s1">data_a </span><span class="s3">= [</span><span class="s4">1e-3</span><span class="s3">, </span><span class="s4">0.1</span><span class="s3">, </span><span class="s4">0.5</span><span class="s3">, </span><span class="s4">0.9</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">4</span><span class="s3">, </span><span class="s4">5</span><span class="s3">, </span><span class="s4">6</span><span class="s3">, </span><span class="s4">8</span><span class="s3">]</span>
    <span class="s1">data_b </span><span class="s3">= [</span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">4</span><span class="s3">, </span><span class="s4">7</span><span class="s3">, </span><span class="s4">10</span><span class="s3">]</span>
    <span class="s1">data_x </span><span class="s3">= [</span><span class="s4">1</span><span class="s3">, </span><span class="s4">1.5</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">4</span><span class="s3">, </span><span class="s4">10</span><span class="s3">, </span><span class="s4">20</span><span class="s3">, </span><span class="s4">50</span><span class="s3">, </span><span class="s4">100</span><span class="s3">, </span><span class="s4">200</span><span class="s3">, </span><span class="s4">500</span><span class="s3">, </span><span class="s4">1e3</span><span class="s3">, </span><span class="s4">5e3</span><span class="s3">, </span><span class="s4">1e4</span><span class="s3">]</span>
    <span class="s1">data_a</span><span class="s3">, </span><span class="s1">data_b</span><span class="s3">, </span><span class="s1">data_x </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">meshgrid</span><span class="s3">(</span><span class="s1">data_a</span><span class="s3">, </span><span class="s1">data_b</span><span class="s3">, </span><span class="s1">data_x</span><span class="s3">)</span>
    <span class="s1">data_a</span><span class="s3">, </span><span class="s1">data_b</span><span class="s3">, </span><span class="s1">data_x </span><span class="s3">= (</span><span class="s1">data_a</span><span class="s3">.</span><span class="s1">flatten</span><span class="s3">(), </span><span class="s1">data_b</span><span class="s3">.</span><span class="s1">flatten</span><span class="s3">(),</span>
                              <span class="s1">data_x</span><span class="s3">.</span><span class="s1">flatten</span><span class="s3">())</span>
    <span class="s1">best_eps </span><span class="s3">= []</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">data_x</span><span class="s3">.</span><span class="s1">size</span><span class="s3">):</span>
        <span class="s1">best_eps</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span>
            <span class="s1">minimize_scalar</span><span class="s3">(</span><span class="s2">lambda </span><span class="s1">eps</span><span class="s3">: </span><span class="s1">arclength</span><span class="s3">(</span><span class="s1">eps</span><span class="s3">, </span><span class="s1">data_a</span><span class="s3">[</span><span class="s1">i</span><span class="s3">], </span><span class="s1">data_b</span><span class="s3">[</span><span class="s1">i</span><span class="s3">],</span>
                                                  <span class="s1">data_x</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]),</span>
                            <span class="s1">bounds</span><span class="s3">=(</span><span class="s4">1e-3</span><span class="s3">, </span><span class="s4">1000</span><span class="s3">),</span>
                            <span class="s1">method</span><span class="s3">=</span><span class="s5">'Bounded'</span><span class="s3">, </span><span class="s1">options</span><span class="s3">={</span><span class="s5">'xatol'</span><span class="s3">: </span><span class="s4">1e-3</span><span class="s3">}).</span><span class="s1">x</span>
        <span class="s3">)</span>
    <span class="s1">best_eps </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">best_eps</span><span class="s3">)</span>
    <span class="s6"># pandas would be nice, but here a dictionary is enough</span>
    <span class="s1">df </span><span class="s3">= {</span><span class="s5">'a'</span><span class="s3">: </span><span class="s1">data_a</span><span class="s3">,</span>
          <span class="s5">'b'</span><span class="s3">: </span><span class="s1">data_b</span><span class="s3">,</span>
          <span class="s5">'x'</span><span class="s3">: </span><span class="s1">data_x</span><span class="s3">,</span>
          <span class="s5">'eps'</span><span class="s3">: </span><span class="s1">best_eps</span><span class="s3">,</span>
          <span class="s3">}</span>

    <span class="s2">def </span><span class="s1">func</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">A0</span><span class="s3">, </span><span class="s1">A1</span><span class="s3">, </span><span class="s1">A2</span><span class="s3">, </span><span class="s1">A3</span><span class="s3">, </span><span class="s1">A4</span><span class="s3">, </span><span class="s1">A5</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Compute parametric function to fit.&quot;&quot;&quot;</span>
        <span class="s1">a </span><span class="s3">= </span><span class="s1">data</span><span class="s3">[</span><span class="s5">'a'</span><span class="s3">]</span>
        <span class="s1">b </span><span class="s3">= </span><span class="s1">data</span><span class="s3">[</span><span class="s5">'b'</span><span class="s3">]</span>
        <span class="s1">x </span><span class="s3">= </span><span class="s1">data</span><span class="s3">[</span><span class="s5">'x'</span><span class="s3">]</span>
        <span class="s2">return </span><span class="s3">(</span><span class="s1">A0 </span><span class="s3">* </span><span class="s1">b </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">exp</span><span class="s3">(-</span><span class="s4">0.5 </span><span class="s3">* </span><span class="s1">a</span><span class="s3">)</span>
                <span class="s3">+ </span><span class="s1">np</span><span class="s3">.</span><span class="s1">exp</span><span class="s3">(</span><span class="s1">A1 </span><span class="s3">+ </span><span class="s4">1 </span><span class="s3">/ (</span><span class="s4">1 </span><span class="s3">+ </span><span class="s1">a</span><span class="s3">) * </span><span class="s1">np</span><span class="s3">.</span><span class="s1">log</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) - </span><span class="s1">A2 </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">exp</span><span class="s3">(-</span><span class="s1">A3 </span><span class="s3">* </span><span class="s1">a</span><span class="s3">)</span>
                         <span class="s3">+ </span><span class="s1">A4 </span><span class="s3">/ (</span><span class="s4">1 </span><span class="s3">+ </span><span class="s1">np</span><span class="s3">.</span><span class="s1">exp</span><span class="s3">(</span><span class="s1">A5 </span><span class="s3">* </span><span class="s1">a</span><span class="s3">))))</span>

    <span class="s1">func_params </span><span class="s3">= </span><span class="s1">list</span><span class="s3">(</span><span class="s1">curve_fit</span><span class="s3">(</span><span class="s1">func</span><span class="s3">, </span><span class="s1">df</span><span class="s3">, </span><span class="s1">df</span><span class="s3">[</span><span class="s5">'eps'</span><span class="s3">], </span><span class="s1">method</span><span class="s3">=</span><span class="s5">'trf'</span><span class="s3">)[</span><span class="s4">0</span><span class="s3">])</span>

    <span class="s1">s </span><span class="s3">= </span><span class="s5">&quot;Fit optimal eps for integrand P via minimal arc length</span><span class="s2">\n</span><span class="s5">&quot;</span>
    <span class="s1">s </span><span class="s3">+= </span><span class="s5">&quot;with parametric function:</span><span class="s2">\n</span><span class="s5">&quot;</span>
    <span class="s1">s </span><span class="s3">+= </span><span class="s5">&quot;optimal_eps = (A0 * b * exp(-a/2) + exp(A1 + 1 / (1 + a) * log(x)</span><span class="s2">\n</span><span class="s5">&quot;</span>
    <span class="s1">s </span><span class="s3">+= </span><span class="s5">&quot;              - A2 * exp(-A3 * a) + A4 / (1 + exp(A5 * a)))</span><span class="s2">\n\n</span><span class="s5">&quot;</span>
    <span class="s1">s </span><span class="s3">+= </span><span class="s5">&quot;Fitted parameters A0 to A5 are:</span><span class="s2">\n</span><span class="s5">&quot;</span>
    <span class="s1">s </span><span class="s3">+= </span><span class="s5">', '</span><span class="s3">.</span><span class="s1">join</span><span class="s3">([</span><span class="s5">f'</span><span class="s2">{</span><span class="s1">x</span><span class="s2">:</span><span class="s5">.5g</span><span class="s2">}</span><span class="s5">' </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">func_params</span><span class="s3">])</span>
    <span class="s2">return </span><span class="s1">s</span>


<span class="s2">def </span><span class="s1">main</span><span class="s3">():</span>
    <span class="s1">t0 </span><span class="s3">= </span><span class="s1">time</span><span class="s3">()</span>
    <span class="s1">parser </span><span class="s3">= </span><span class="s1">ArgumentParser</span><span class="s3">(</span><span class="s1">description</span><span class="s3">=</span><span class="s1">__doc__</span><span class="s3">,</span>
                            <span class="s1">formatter_class</span><span class="s3">=</span><span class="s1">RawTextHelpFormatter</span><span class="s3">)</span>
    <span class="s1">parser</span><span class="s3">.</span><span class="s1">add_argument</span><span class="s3">(</span><span class="s5">'action'</span><span class="s3">, </span><span class="s1">type</span><span class="s3">=</span><span class="s1">int</span><span class="s3">, </span><span class="s1">choices</span><span class="s3">=[</span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s4">4</span><span class="s3">],</span>
                        <span class="s1">help</span><span class="s3">=</span><span class="s5">'chose what expansion to precompute</span><span class="s2">\n</span><span class="s5">'</span>
                             <span class="s5">'1 : Series for small a</span><span class="s2">\n</span><span class="s5">'</span>
                             <span class="s5">'2 : Series for small a and small b</span><span class="s2">\n</span><span class="s5">'</span>
                             <span class="s5">'3 : Asymptotic series for large x</span><span class="s2">\n</span><span class="s5">'</span>
                             <span class="s5">'    This may take some time (&gt;4h).</span><span class="s2">\n</span><span class="s5">'</span>
                             <span class="s5">'4 : Fit optimal eps for integral representation.'</span>
                        <span class="s3">)</span>
    <span class="s1">args </span><span class="s3">= </span><span class="s1">parser</span><span class="s3">.</span><span class="s1">parse_args</span><span class="s3">()</span>

    <span class="s1">switch </span><span class="s3">= {</span><span class="s4">1</span><span class="s3">: </span><span class="s2">lambda</span><span class="s3">: </span><span class="s1">print</span><span class="s3">(</span><span class="s1">series_small_a</span><span class="s3">()),</span>
              <span class="s4">2</span><span class="s3">: </span><span class="s2">lambda</span><span class="s3">: </span><span class="s1">print</span><span class="s3">(</span><span class="s1">series_small_a_small_b</span><span class="s3">()),</span>
              <span class="s4">3</span><span class="s3">: </span><span class="s2">lambda</span><span class="s3">: </span><span class="s1">print</span><span class="s3">(</span><span class="s1">asymptotic_series</span><span class="s3">()),</span>
              <span class="s4">4</span><span class="s3">: </span><span class="s2">lambda</span><span class="s3">: </span><span class="s1">print</span><span class="s3">(</span><span class="s1">optimal_epsilon_integral</span><span class="s3">())</span>
              <span class="s3">}</span>
    <span class="s1">switch</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">args</span><span class="s3">.</span><span class="s1">action</span><span class="s3">, </span><span class="s2">lambda</span><span class="s3">: </span><span class="s1">print</span><span class="s3">(</span><span class="s5">&quot;Invalid input.&quot;</span><span class="s3">))()</span>
    <span class="s1">print</span><span class="s3">(</span><span class="s5">f&quot;</span><span class="s2">\n{</span><span class="s3">(</span><span class="s1">time</span><span class="s3">() - </span><span class="s1">t0</span><span class="s3">)/</span><span class="s4">60</span><span class="s2">:</span><span class="s5">.1f</span><span class="s2">} </span><span class="s5">minutes elapsed.</span><span class="s2">\n</span><span class="s5">&quot;</span><span class="s3">)</span>


<span class="s2">if </span><span class="s1">__name__ </span><span class="s3">== </span><span class="s5">'__main__'</span><span class="s3">:</span>
    <span class="s1">main</span><span class="s3">()</span>
</pre>
</body>
</html>