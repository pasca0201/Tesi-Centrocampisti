<html>
<head>
<title>_vertex.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #5f826b; font-style: italic;}
.s4 { color: #7a7e85;}
.s5 { color: #6aab73;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_vertex.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">collections</span>
<span class="s0">from </span><span class="s1">abc </span><span class="s0">import </span><span class="s1">ABC</span><span class="s2">, </span><span class="s1">abstractmethod</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>

<span class="s0">from </span><span class="s1">scipy</span><span class="s2">.</span><span class="s1">_lib</span><span class="s2">.</span><span class="s1">_util </span><span class="s0">import </span><span class="s1">MapWrapper</span>


<span class="s0">class </span><span class="s1">VertexBase</span><span class="s2">(</span><span class="s1">ABC</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot; 
    Base class for a vertex. 
    &quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">nn</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">index</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Initiation of a vertex object. 
 
        Parameters 
        ---------- 
        x : tuple or vector 
            The geometric location (domain). 
        nn : list, optional 
            Nearest neighbour list. 
        index : int, optional 
            Index of vertex. 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">x </span><span class="s2">= </span><span class="s1">x</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">hash </span><span class="s2">= </span><span class="s1">hash</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">x</span><span class="s2">)  </span><span class="s4"># Save precomputed hash</span>

        <span class="s0">if </span><span class="s1">nn </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">nn </span><span class="s2">= </span><span class="s1">set</span><span class="s2">(</span><span class="s1">nn</span><span class="s2">)  </span><span class="s4"># can use .indexupdate to add a new list</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">nn </span><span class="s2">= </span><span class="s1">set</span><span class="s2">()</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">index </span><span class="s2">= </span><span class="s1">index</span>

    <span class="s0">def </span><span class="s1">__hash__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">hash</span>

    <span class="s0">def </span><span class="s1">__getattr__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">item</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">item </span><span class="s0">not in </span><span class="s2">[</span><span class="s5">'x_a'</span><span class="s2">]:</span>
            <span class="s0">raise </span><span class="s1">AttributeError</span><span class="s2">(</span><span class="s5">f&quot;</span><span class="s0">{</span><span class="s1">type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span><span class="s0">} </span><span class="s5">object has no attribute &quot;</span>
                                 <span class="s5">f&quot;'</span><span class="s0">{</span><span class="s1">item</span><span class="s0">}</span><span class="s5">'&quot;</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">item </span><span class="s2">== </span><span class="s5">'x_a'</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">x_a </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">x</span><span class="s2">)</span>
            <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">x_a</span>

    <span class="s2">@</span><span class="s1">abstractmethod</span>
    <span class="s0">def </span><span class="s1">connect</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">v</span><span class="s2">):</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError</span><span class="s2">(</span><span class="s5">&quot;This method is only implemented with an &quot;</span>
                                  <span class="s5">&quot;associated child of the base class.&quot;</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">abstractmethod</span>
    <span class="s0">def </span><span class="s1">disconnect</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">v</span><span class="s2">):</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError</span><span class="s2">(</span><span class="s5">&quot;This method is only implemented with an &quot;</span>
                                  <span class="s5">&quot;associated child of the base class.&quot;</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">star</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;Returns the star domain ``st(v)`` of the vertex. 
 
        Parameters 
        ---------- 
        v : 
            The vertex ``v`` in ``st(v)`` 
 
        Returns 
        ------- 
        st : set 
            A set containing all the vertices in ``st(v)`` 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">st </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">nn</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">st</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">st</span>


<span class="s0">class </span><span class="s1">VertexScalarField</span><span class="s2">(</span><span class="s1">VertexBase</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot; 
    Add homology properties of a scalar field f: R^n --&gt; R associated with 
    the geometry built from the VertexBase class 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">field</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">nn</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">index</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">field_args</span><span class="s2">=(),</span>
                 <span class="s1">g_cons</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">g_cons_args</span><span class="s2">=()):</span>
        <span class="s3">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        x : tuple, 
            vector of vertex coordinates 
        field : callable, optional 
            a scalar field f: R^n --&gt; R associated with the geometry 
        nn : list, optional 
            list of nearest neighbours 
        index : int, optional 
            index of the vertex 
        field_args : tuple, optional 
            additional arguments to be passed to field 
        g_cons : callable, optional 
            constraints on the vertex 
        g_cons_args : tuple, optional 
            additional arguments to be passed to g_cons 
 
        &quot;&quot;&quot;</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">nn</span><span class="s2">=</span><span class="s1">nn</span><span class="s2">, </span><span class="s1">index</span><span class="s2">=</span><span class="s1">index</span><span class="s2">)</span>

        <span class="s4"># Note Vertex is only initiated once for all x so only</span>
        <span class="s4"># evaluated once</span>
        <span class="s4"># self.feasible = None</span>

        <span class="s4"># self.f is externally defined by the cache to allow parallel</span>
        <span class="s4"># processing</span>
        <span class="s4"># None type that will break arithmetic operations unless defined</span>
        <span class="s4"># self.f = None</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">check_min </span><span class="s2">= </span><span class="s0">True</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">check_max </span><span class="s2">= </span><span class="s0">True</span>

    <span class="s0">def </span><span class="s1">connect</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">v</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;Connects self to another vertex object v. 
 
        Parameters 
        ---------- 
        v : VertexBase or VertexScalarField object 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">v </span><span class="s0">is not </span><span class="s1">self </span><span class="s0">and </span><span class="s1">v </span><span class="s0">not in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">nn</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">nn</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">v</span><span class="s2">)</span>
            <span class="s1">v</span><span class="s2">.</span><span class="s1">nn</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>

            <span class="s4"># Flags for checking homology properties:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">check_min </span><span class="s2">= </span><span class="s0">True</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">check_max </span><span class="s2">= </span><span class="s0">True</span>
            <span class="s1">v</span><span class="s2">.</span><span class="s1">check_min </span><span class="s2">= </span><span class="s0">True</span>
            <span class="s1">v</span><span class="s2">.</span><span class="s1">check_max </span><span class="s2">= </span><span class="s0">True</span>

    <span class="s0">def </span><span class="s1">disconnect</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">v</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">v </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">nn</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">nn</span><span class="s2">.</span><span class="s1">remove</span><span class="s2">(</span><span class="s1">v</span><span class="s2">)</span>
            <span class="s1">v</span><span class="s2">.</span><span class="s1">nn</span><span class="s2">.</span><span class="s1">remove</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>

            <span class="s4"># Flags for checking homology properties:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">check_min </span><span class="s2">= </span><span class="s0">True</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">check_max </span><span class="s2">= </span><span class="s0">True</span>
            <span class="s1">v</span><span class="s2">.</span><span class="s1">check_min </span><span class="s2">= </span><span class="s0">True</span>
            <span class="s1">v</span><span class="s2">.</span><span class="s1">check_max </span><span class="s2">= </span><span class="s0">True</span>

    <span class="s0">def </span><span class="s1">minimiser</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;Check whether this vertex is strictly less than all its 
           neighbours&quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">check_min</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_min </span><span class="s2">= </span><span class="s1">all</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">f </span><span class="s2">&lt; </span><span class="s1">v</span><span class="s2">.</span><span class="s1">f </span><span class="s0">for </span><span class="s1">v </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">nn</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">check_min </span><span class="s2">= </span><span class="s0">False</span>

        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_min</span>

    <span class="s0">def </span><span class="s1">maximiser</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Check whether this vertex is strictly greater than all its 
        neighbours. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">check_max</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_max </span><span class="s2">= </span><span class="s1">all</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">f </span><span class="s2">&gt; </span><span class="s1">v</span><span class="s2">.</span><span class="s1">f </span><span class="s0">for </span><span class="s1">v </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">nn</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">check_max </span><span class="s2">= </span><span class="s0">False</span>

        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_max</span>


<span class="s0">class </span><span class="s1">VertexVectorField</span><span class="s2">(</span><span class="s1">VertexBase</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot; 
    Add homology properties of a scalar field f: R^n --&gt; R^m associated with 
    the geometry built from the VertexBase class. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">sfield</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">vfield</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">field_args</span><span class="s2">=(),</span>
                 <span class="s1">vfield_args</span><span class="s2">=(), </span><span class="s1">g_cons</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
                 <span class="s1">g_cons_args</span><span class="s2">=(), </span><span class="s1">nn</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">index</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">nn</span><span class="s2">=</span><span class="s1">nn</span><span class="s2">, </span><span class="s1">index</span><span class="s2">=</span><span class="s1">index</span><span class="s2">)</span>

        <span class="s0">raise </span><span class="s1">NotImplementedError</span><span class="s2">(</span><span class="s5">&quot;This class is still a work in progress&quot;</span><span class="s2">)</span>


<span class="s0">class </span><span class="s1">VertexCacheBase</span><span class="s2">:</span>
    <span class="s3">&quot;&quot;&quot;Base class for a vertex cache for a simplicial complex.&quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">cache </span><span class="s2">= </span><span class="s1">collections</span><span class="s2">.</span><span class="s1">OrderedDict</span><span class="s2">()</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">nfev </span><span class="s2">= </span><span class="s6">0  </span><span class="s4"># Feasible points</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">index </span><span class="s2">= -</span><span class="s6">1</span>

    <span class="s0">def </span><span class="s1">__iter__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">for </span><span class="s1">v </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">cache</span><span class="s2">:</span>
            <span class="s0">yield </span><span class="s1">self</span><span class="s2">.</span><span class="s1">cache</span><span class="s2">[</span><span class="s1">v</span><span class="s2">]</span>
        <span class="s0">return</span>

    <span class="s0">def </span><span class="s1">size</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;Returns the size of the vertex cache.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">index </span><span class="s2">+ </span><span class="s6">1</span>

    <span class="s0">def </span><span class="s1">print_out</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">headlen </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s5">f&quot;Vertex cache of size: </span><span class="s0">{</span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">cache</span><span class="s2">)</span><span class="s0">}</span><span class="s5">:&quot;</span><span class="s2">)</span>
        <span class="s1">print</span><span class="s2">(</span><span class="s5">'=' </span><span class="s2">* </span><span class="s1">headlen</span><span class="s2">)</span>
        <span class="s1">print</span><span class="s2">(</span><span class="s5">f&quot;Vertex cache of size: </span><span class="s0">{</span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">cache</span><span class="s2">)</span><span class="s0">}</span><span class="s5">:&quot;</span><span class="s2">)</span>
        <span class="s1">print</span><span class="s2">(</span><span class="s5">'=' </span><span class="s2">* </span><span class="s1">headlen</span><span class="s2">)</span>
        <span class="s0">for </span><span class="s1">v </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">cache</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">cache</span><span class="s2">[</span><span class="s1">v</span><span class="s2">].</span><span class="s1">print_out</span><span class="s2">()</span>


<span class="s0">class </span><span class="s1">VertexCube</span><span class="s2">(</span><span class="s1">VertexBase</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot;Vertex class to be used for a pure simplicial complex with no associated 
    differential geometry (single level domain that exists in R^n)&quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">nn</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">index</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">nn</span><span class="s2">=</span><span class="s1">nn</span><span class="s2">, </span><span class="s1">index</span><span class="s2">=</span><span class="s1">index</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">connect</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">v</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">v </span><span class="s0">is not </span><span class="s1">self </span><span class="s0">and </span><span class="s1">v </span><span class="s0">not in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">nn</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">nn</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">v</span><span class="s2">)</span>
            <span class="s1">v</span><span class="s2">.</span><span class="s1">nn</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">disconnect</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">v</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">v </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">nn</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">nn</span><span class="s2">.</span><span class="s1">remove</span><span class="s2">(</span><span class="s1">v</span><span class="s2">)</span>
            <span class="s1">v</span><span class="s2">.</span><span class="s1">nn</span><span class="s2">.</span><span class="s1">remove</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>


<span class="s0">class </span><span class="s1">VertexCacheIndex</span><span class="s2">(</span><span class="s1">VertexCacheBase</span><span class="s2">):</span>
    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Class for a vertex cache for a simplicial complex without an associated 
        field. Useful only for building and visualising a domain complex. 
 
        Parameters 
        ---------- 
        &quot;&quot;&quot;</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">__init__</span><span class="s2">()</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">Vertex </span><span class="s2">= </span><span class="s1">VertexCube</span>

    <span class="s0">def </span><span class="s1">__getitem__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">nn</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">cache</span><span class="s2">[</span><span class="s1">x</span><span class="s2">]</span>
        <span class="s0">except </span><span class="s1">KeyError</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">index </span><span class="s2">+= </span><span class="s6">1</span>
            <span class="s1">xval </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">Vertex</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">index</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">index</span><span class="s2">)</span>
            <span class="s4"># logging.info(&quot;New generated vertex at x = {}&quot;.format(x))</span>
            <span class="s4"># NOTE: Surprisingly high performance increase if logging</span>
            <span class="s4"># is commented out</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">cache</span><span class="s2">[</span><span class="s1">x</span><span class="s2">] = </span><span class="s1">xval</span>
            <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">cache</span><span class="s2">[</span><span class="s1">x</span><span class="s2">]</span>


<span class="s0">class </span><span class="s1">VertexCacheField</span><span class="s2">(</span><span class="s1">VertexCacheBase</span><span class="s2">):</span>
    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">field</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">field_args</span><span class="s2">=(), </span><span class="s1">g_cons</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">g_cons_args</span><span class="s2">=(),</span>
                 <span class="s1">workers</span><span class="s2">=</span><span class="s6">1</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Class for a vertex cache for a simplicial complex with an associated 
        field. 
 
        Parameters 
        ---------- 
        field : callable 
            Scalar or vector field callable. 
        field_args : tuple, optional 
            Any additional fixed parameters needed to completely specify the 
            field function 
        g_cons : dict or sequence of dict, optional 
            Constraints definition. 
            Function(s) ``R**n`` in the form:: 
        g_cons_args : tuple, optional 
            Any additional fixed parameters needed to completely specify the 
            constraint functions 
        workers : int  optional 
            Uses `multiprocessing.Pool &lt;multiprocessing&gt;`) to compute the field 
             functions in parallel. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">__init__</span><span class="s2">()</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">index </span><span class="s2">= -</span><span class="s6">1</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">Vertex </span><span class="s2">= </span><span class="s1">VertexScalarField</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">field </span><span class="s2">= </span><span class="s1">field</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">field_args </span><span class="s2">= </span><span class="s1">field_args</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">wfield </span><span class="s2">= </span><span class="s1">FieldWrapper</span><span class="s2">(</span><span class="s1">field</span><span class="s2">, </span><span class="s1">field_args</span><span class="s2">)  </span><span class="s4"># if workers is not 1</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">g_cons </span><span class="s2">= </span><span class="s1">g_cons</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">g_cons_args </span><span class="s2">= </span><span class="s1">g_cons_args</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">wgcons </span><span class="s2">= </span><span class="s1">ConstraintWrapper</span><span class="s2">(</span><span class="s1">g_cons</span><span class="s2">, </span><span class="s1">g_cons_args</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">gpool </span><span class="s2">= </span><span class="s1">set</span><span class="s2">()  </span><span class="s4"># A set of tuples to process for feasibility</span>

        <span class="s4"># Field processing objects</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">fpool </span><span class="s2">= </span><span class="s1">set</span><span class="s2">()  </span><span class="s4"># A set of tuples to process for scalar function</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">sfc_lock </span><span class="s2">= </span><span class="s0">False  </span><span class="s4"># True if self.fpool is non-Empty</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">workers </span><span class="s2">= </span><span class="s1">workers</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_mapwrapper </span><span class="s2">= </span><span class="s1">MapWrapper</span><span class="s2">(</span><span class="s1">workers</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">workers </span><span class="s2">== </span><span class="s6">1</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">process_gpool </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">proc_gpool</span>
            <span class="s0">if </span><span class="s1">g_cons </span><span class="s0">is None</span><span class="s2">:</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">process_fpool </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">proc_fpool_nog</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">process_fpool </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">proc_fpool_g</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">process_gpool </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">pproc_gpool</span>
            <span class="s0">if </span><span class="s1">g_cons </span><span class="s0">is None</span><span class="s2">:</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">process_fpool </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">pproc_fpool_nog</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">process_fpool </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">pproc_fpool_g</span>

    <span class="s0">def </span><span class="s1">__getitem__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">nn</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">cache</span><span class="s2">[</span><span class="s1">x</span><span class="s2">]</span>
        <span class="s0">except </span><span class="s1">KeyError</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">index </span><span class="s2">+= </span><span class="s6">1</span>
            <span class="s1">xval </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">Vertex</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">field</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">field</span><span class="s2">, </span><span class="s1">nn</span><span class="s2">=</span><span class="s1">nn</span><span class="s2">, </span><span class="s1">index</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">index</span><span class="s2">,</span>
                               <span class="s1">field_args</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">field_args</span><span class="s2">,</span>
                               <span class="s1">g_cons</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">g_cons</span><span class="s2">,</span>
                               <span class="s1">g_cons_args</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">g_cons_args</span><span class="s2">)</span>

            <span class="s1">self</span><span class="s2">.</span><span class="s1">cache</span><span class="s2">[</span><span class="s1">x</span><span class="s2">] = </span><span class="s1">xval  </span><span class="s4"># Define in cache</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">gpool</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">xval</span><span class="s2">)  </span><span class="s4"># Add to pool for processing feasibility</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">fpool</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">xval</span><span class="s2">)  </span><span class="s4"># Add to pool for processing field values</span>
            <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">cache</span><span class="s2">[</span><span class="s1">x</span><span class="s2">]</span>

    <span class="s0">def </span><span class="s1">__getstate__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">self_dict </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__dict__</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>
        <span class="s0">del </span><span class="s1">self_dict</span><span class="s2">[</span><span class="s5">'pool'</span><span class="s2">]</span>
        <span class="s0">return </span><span class="s1">self_dict</span>

    <span class="s0">def </span><span class="s1">process_pools</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">g_cons </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">process_gpool</span><span class="s2">()</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">process_fpool</span><span class="s2">()</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">proc_minimisers</span><span class="s2">()</span>

    <span class="s0">def </span><span class="s1">feasibility_check</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">v</span><span class="s2">):</span>
        <span class="s1">v</span><span class="s2">.</span><span class="s1">feasible </span><span class="s2">= </span><span class="s0">True</span>
        <span class="s0">for </span><span class="s1">g</span><span class="s2">, </span><span class="s1">args </span><span class="s0">in </span><span class="s1">zip</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">g_cons</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">g_cons_args</span><span class="s2">):</span>
            <span class="s4"># constraint may return more than 1 value.</span>
            <span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">any</span><span class="s2">(</span><span class="s1">g</span><span class="s2">(</span><span class="s1">v</span><span class="s2">.</span><span class="s1">x_a</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">) &lt; </span><span class="s6">0.0</span><span class="s2">):</span>
                <span class="s1">v</span><span class="s2">.</span><span class="s1">f </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span>
                <span class="s1">v</span><span class="s2">.</span><span class="s1">feasible </span><span class="s2">= </span><span class="s0">False</span>
                <span class="s0">break</span>

    <span class="s0">def </span><span class="s1">compute_sfield</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">v</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;Compute the scalar field values of a vertex object `v`. 
 
        Parameters 
        ---------- 
        v : VertexBase or VertexScalarField object 
        &quot;&quot;&quot;</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s1">v</span><span class="s2">.</span><span class="s1">f </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">field</span><span class="s2">(</span><span class="s1">v</span><span class="s2">.</span><span class="s1">x_a</span><span class="s2">, *</span><span class="s1">self</span><span class="s2">.</span><span class="s1">field_args</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">nfev </span><span class="s2">+= </span><span class="s6">1</span>
        <span class="s0">except </span><span class="s1">AttributeError</span><span class="s2">:</span>
            <span class="s1">v</span><span class="s2">.</span><span class="s1">f </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span>
            <span class="s4"># logging.warning(f&quot;Field function not found at x = {self.x_a}&quot;)</span>
        <span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isnan</span><span class="s2">(</span><span class="s1">v</span><span class="s2">.</span><span class="s1">f</span><span class="s2">):</span>
            <span class="s1">v</span><span class="s2">.</span><span class="s1">f </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span>

    <span class="s0">def </span><span class="s1">proc_gpool</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;Process all constraints.&quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">g_cons </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s0">for </span><span class="s1">v </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">gpool</span><span class="s2">:</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">feasibility_check</span><span class="s2">(</span><span class="s1">v</span><span class="s2">)</span>
        <span class="s4"># Clean the pool</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">gpool </span><span class="s2">= </span><span class="s1">set</span><span class="s2">()</span>

    <span class="s0">def </span><span class="s1">pproc_gpool</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;Process all constraints in parallel.&quot;&quot;&quot;</span>
        <span class="s1">gpool_l </span><span class="s2">= []</span>
        <span class="s0">for </span><span class="s1">v </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">gpool</span><span class="s2">:</span>
            <span class="s1">gpool_l</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">v</span><span class="s2">.</span><span class="s1">x_a</span><span class="s2">)</span>

        <span class="s1">G </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_mapwrapper</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">wgcons</span><span class="s2">.</span><span class="s1">gcons</span><span class="s2">, </span><span class="s1">gpool_l</span><span class="s2">)</span>
        <span class="s0">for </span><span class="s1">v</span><span class="s2">, </span><span class="s1">g </span><span class="s0">in </span><span class="s1">zip</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">gpool</span><span class="s2">, </span><span class="s1">G</span><span class="s2">):</span>
            <span class="s1">v</span><span class="s2">.</span><span class="s1">feasible </span><span class="s2">= </span><span class="s1">g  </span><span class="s4"># set vertex object attribute v.feasible = g (bool)</span>

    <span class="s0">def </span><span class="s1">proc_fpool_g</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;Process all field functions with constraints supplied.&quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">v </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">fpool</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">v</span><span class="s2">.</span><span class="s1">feasible</span><span class="s2">:</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">compute_sfield</span><span class="s2">(</span><span class="s1">v</span><span class="s2">)</span>
        <span class="s4"># Clean the pool</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">fpool </span><span class="s2">= </span><span class="s1">set</span><span class="s2">()</span>

    <span class="s0">def </span><span class="s1">proc_fpool_nog</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;Process all field functions with no constraints supplied.&quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">v </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">fpool</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">compute_sfield</span><span class="s2">(</span><span class="s1">v</span><span class="s2">)</span>
        <span class="s4"># Clean the pool</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">fpool </span><span class="s2">= </span><span class="s1">set</span><span class="s2">()</span>

    <span class="s0">def </span><span class="s1">pproc_fpool_g</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Process all field functions with constraints supplied in parallel. 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">wfield</span><span class="s2">.</span><span class="s1">func</span>
        <span class="s1">fpool_l </span><span class="s2">= []</span>
        <span class="s0">for </span><span class="s1">v </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">fpool</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">v</span><span class="s2">.</span><span class="s1">feasible</span><span class="s2">:</span>
                <span class="s1">fpool_l</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">v</span><span class="s2">.</span><span class="s1">x_a</span><span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">v</span><span class="s2">.</span><span class="s1">f </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span>
        <span class="s1">F </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_mapwrapper</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">wfield</span><span class="s2">.</span><span class="s1">func</span><span class="s2">, </span><span class="s1">fpool_l</span><span class="s2">)</span>
        <span class="s0">for </span><span class="s1">va</span><span class="s2">, </span><span class="s1">f </span><span class="s0">in </span><span class="s1">zip</span><span class="s2">(</span><span class="s1">fpool_l</span><span class="s2">, </span><span class="s1">F</span><span class="s2">):</span>
            <span class="s1">vt </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">va</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">[</span><span class="s1">vt</span><span class="s2">].</span><span class="s1">f </span><span class="s2">= </span><span class="s1">f  </span><span class="s4"># set vertex object attribute v.f = f</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">nfev </span><span class="s2">+= </span><span class="s6">1</span>
        <span class="s4"># Clean the pool</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">fpool </span><span class="s2">= </span><span class="s1">set</span><span class="s2">()</span>

    <span class="s0">def </span><span class="s1">pproc_fpool_nog</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Process all field functions with no constraints supplied in parallel. 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">wfield</span><span class="s2">.</span><span class="s1">func</span>
        <span class="s1">fpool_l </span><span class="s2">= []</span>
        <span class="s0">for </span><span class="s1">v </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">fpool</span><span class="s2">:</span>
            <span class="s1">fpool_l</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">v</span><span class="s2">.</span><span class="s1">x_a</span><span class="s2">)</span>
        <span class="s1">F </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_mapwrapper</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">wfield</span><span class="s2">.</span><span class="s1">func</span><span class="s2">, </span><span class="s1">fpool_l</span><span class="s2">)</span>
        <span class="s0">for </span><span class="s1">va</span><span class="s2">, </span><span class="s1">f </span><span class="s0">in </span><span class="s1">zip</span><span class="s2">(</span><span class="s1">fpool_l</span><span class="s2">, </span><span class="s1">F</span><span class="s2">):</span>
            <span class="s1">vt </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">va</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">[</span><span class="s1">vt</span><span class="s2">].</span><span class="s1">f </span><span class="s2">= </span><span class="s1">f  </span><span class="s4"># set vertex object attribute v.f = f</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">nfev </span><span class="s2">+= </span><span class="s6">1</span>
        <span class="s4"># Clean the pool</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">fpool </span><span class="s2">= </span><span class="s1">set</span><span class="s2">()</span>

    <span class="s0">def </span><span class="s1">proc_minimisers</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;Check for minimisers.&quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">v </span><span class="s0">in </span><span class="s1">self</span><span class="s2">:</span>
            <span class="s1">v</span><span class="s2">.</span><span class="s1">minimiser</span><span class="s2">()</span>
            <span class="s1">v</span><span class="s2">.</span><span class="s1">maximiser</span><span class="s2">()</span>


<span class="s0">class </span><span class="s1">ConstraintWrapper</span><span class="s2">:</span>
    <span class="s3">&quot;&quot;&quot;Object to wrap constraints to pass to `multiprocessing.Pool`.&quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">g_cons</span><span class="s2">, </span><span class="s1">g_cons_args</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">g_cons </span><span class="s2">= </span><span class="s1">g_cons</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">g_cons_args </span><span class="s2">= </span><span class="s1">g_cons_args</span>

    <span class="s0">def </span><span class="s1">gcons</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">v_x_a</span><span class="s2">):</span>
        <span class="s1">vfeasible </span><span class="s2">= </span><span class="s0">True</span>
        <span class="s0">for </span><span class="s1">g</span><span class="s2">, </span><span class="s1">args </span><span class="s0">in </span><span class="s1">zip</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">g_cons</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">g_cons_args</span><span class="s2">):</span>
            <span class="s4"># constraint may return more than 1 value.</span>
            <span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">any</span><span class="s2">(</span><span class="s1">g</span><span class="s2">(</span><span class="s1">v_x_a</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">) &lt; </span><span class="s6">0.0</span><span class="s2">):</span>
                <span class="s1">vfeasible </span><span class="s2">= </span><span class="s0">False</span>
                <span class="s0">break</span>
        <span class="s0">return </span><span class="s1">vfeasible</span>


<span class="s0">class </span><span class="s1">FieldWrapper</span><span class="s2">:</span>
    <span class="s3">&quot;&quot;&quot;Object to wrap field to pass to `multiprocessing.Pool`.&quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">field</span><span class="s2">, </span><span class="s1">field_args</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">field </span><span class="s2">= </span><span class="s1">field</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">field_args </span><span class="s2">= </span><span class="s1">field_args</span>

    <span class="s0">def </span><span class="s1">func</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">v_x_a</span><span class="s2">):</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s1">v_f </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">field</span><span class="s2">(</span><span class="s1">v_x_a</span><span class="s2">, *</span><span class="s1">self</span><span class="s2">.</span><span class="s1">field_args</span><span class="s2">)</span>
        <span class="s0">except </span><span class="s1">Exception</span><span class="s2">:</span>
            <span class="s1">v_f </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span>
        <span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isnan</span><span class="s2">(</span><span class="s1">v_f</span><span class="s2">):</span>
            <span class="s1">v_f </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span>

        <span class="s0">return </span><span class="s1">v_f</span>
</pre>
</body>
</html>