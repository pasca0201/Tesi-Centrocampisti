<html>
<head>
<title>test_splitting.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #6aab73;}
.s4 { color: #2aacb8;}
.s5 { color: #7a7e85;}
.s6 { color: #5f826b; font-style: italic;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_splitting.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">import </span><span class="s1">pytest</span>
<span class="s0">from </span><span class="s1">numpy</span><span class="s2">.</span><span class="s1">testing </span><span class="s0">import </span><span class="s1">assert_array_equal</span>

<span class="s0">from </span><span class="s1">sklearn</span><span class="s2">.</span><span class="s1">ensemble</span><span class="s2">.</span><span class="s1">_hist_gradient_boosting</span><span class="s2">.</span><span class="s1">common </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">G_H_DTYPE</span><span class="s2">,</span>
    <span class="s1">HISTOGRAM_DTYPE</span><span class="s2">,</span>
    <span class="s1">X_BINNED_DTYPE</span><span class="s2">,</span>
    <span class="s1">MonotonicConstraint</span><span class="s2">,</span>
<span class="s2">)</span>
<span class="s0">from </span><span class="s1">sklearn</span><span class="s2">.</span><span class="s1">ensemble</span><span class="s2">.</span><span class="s1">_hist_gradient_boosting</span><span class="s2">.</span><span class="s1">histogram </span><span class="s0">import </span><span class="s1">HistogramBuilder</span>
<span class="s0">from </span><span class="s1">sklearn</span><span class="s2">.</span><span class="s1">ensemble</span><span class="s2">.</span><span class="s1">_hist_gradient_boosting</span><span class="s2">.</span><span class="s1">splitting </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">Splitter</span><span class="s2">,</span>
    <span class="s1">compute_node_value</span><span class="s2">,</span>
<span class="s2">)</span>
<span class="s0">from </span><span class="s1">sklearn</span><span class="s2">.</span><span class="s1">utils</span><span class="s2">.</span><span class="s1">_openmp_helpers </span><span class="s0">import </span><span class="s1">_openmp_effective_n_threads</span>
<span class="s0">from </span><span class="s1">sklearn</span><span class="s2">.</span><span class="s1">utils</span><span class="s2">.</span><span class="s1">_testing </span><span class="s0">import </span><span class="s1">skip_if_32bit</span>

<span class="s1">n_threads </span><span class="s2">= </span><span class="s1">_openmp_effective_n_threads</span><span class="s2">()</span>


<span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">parametrize</span><span class="s2">(</span><span class="s3">&quot;n_bins&quot;</span><span class="s2">, [</span><span class="s4">3</span><span class="s2">, </span><span class="s4">32</span><span class="s2">, </span><span class="s4">256</span><span class="s2">])</span>
<span class="s0">def </span><span class="s1">test_histogram_split</span><span class="s2">(</span><span class="s1">n_bins</span><span class="s2">):</span>
    <span class="s1">rng </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">random</span><span class="s2">.</span><span class="s1">RandomState</span><span class="s2">(</span><span class="s4">42</span><span class="s2">)</span>
    <span class="s1">feature_idx </span><span class="s2">= </span><span class="s4">0</span>
    <span class="s1">l2_regularization </span><span class="s2">= </span><span class="s4">0</span>
    <span class="s1">min_hessian_to_split </span><span class="s2">= </span><span class="s4">1e-3</span>
    <span class="s1">min_samples_leaf </span><span class="s2">= </span><span class="s4">1</span>
    <span class="s1">min_gain_to_split </span><span class="s2">= </span><span class="s4">0.0</span>
    <span class="s1">X_binned </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asfortranarray</span><span class="s2">(</span>
        <span class="s1">rng</span><span class="s2">.</span><span class="s1">randint</span><span class="s2">(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">n_bins </span><span class="s2">- </span><span class="s4">1</span><span class="s2">, </span><span class="s1">size</span><span class="s2">=(</span><span class="s1">int</span><span class="s2">(</span><span class="s4">1e4</span><span class="s2">), </span><span class="s4">1</span><span class="s2">)), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">X_BINNED_DTYPE</span>
    <span class="s2">)</span>
    <span class="s1">binned_feature </span><span class="s2">= </span><span class="s1">X_binned</span><span class="s2">.</span><span class="s1">T</span><span class="s2">[</span><span class="s1">feature_idx</span><span class="s2">]</span>
    <span class="s1">sample_indices </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(</span><span class="s1">binned_feature</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s4">0</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">uint32</span><span class="s2">)</span>
    <span class="s1">ordered_hessians </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones_like</span><span class="s2">(</span><span class="s1">binned_feature</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">G_H_DTYPE</span><span class="s2">)</span>
    <span class="s1">all_hessians </span><span class="s2">= </span><span class="s1">ordered_hessians</span>
    <span class="s1">sum_hessians </span><span class="s2">= </span><span class="s1">all_hessians</span><span class="s2">.</span><span class="s1">sum</span><span class="s2">()</span>
    <span class="s1">hessians_are_constant </span><span class="s2">= </span><span class="s0">False</span>

    <span class="s0">for </span><span class="s1">true_bin </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">n_bins </span><span class="s2">- </span><span class="s4">2</span><span class="s2">):</span>
        <span class="s0">for </span><span class="s1">sign </span><span class="s0">in </span><span class="s2">[-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">]:</span>
            <span class="s1">ordered_gradients </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">full_like</span><span class="s2">(</span><span class="s1">binned_feature</span><span class="s2">, </span><span class="s1">sign</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">G_H_DTYPE</span><span class="s2">)</span>
            <span class="s1">ordered_gradients</span><span class="s2">[</span><span class="s1">binned_feature </span><span class="s2">&lt;= </span><span class="s1">true_bin</span><span class="s2">] *= -</span><span class="s4">1</span>
            <span class="s1">all_gradients </span><span class="s2">= </span><span class="s1">ordered_gradients</span>
            <span class="s1">sum_gradients </span><span class="s2">= </span><span class="s1">all_gradients</span><span class="s2">.</span><span class="s1">sum</span><span class="s2">()</span>

            <span class="s1">builder </span><span class="s2">= </span><span class="s1">HistogramBuilder</span><span class="s2">(</span>
                <span class="s1">X_binned</span><span class="s2">,</span>
                <span class="s1">n_bins</span><span class="s2">,</span>
                <span class="s1">all_gradients</span><span class="s2">,</span>
                <span class="s1">all_hessians</span><span class="s2">,</span>
                <span class="s1">hessians_are_constant</span><span class="s2">,</span>
                <span class="s1">n_threads</span><span class="s2">,</span>
            <span class="s2">)</span>
            <span class="s1">n_bins_non_missing </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">(</span>
                <span class="s2">[</span><span class="s1">n_bins </span><span class="s2">- </span><span class="s4">1</span><span class="s2">] * </span><span class="s1">X_binned</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s4">1</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">uint32</span>
            <span class="s2">)</span>
            <span class="s1">has_missing_values </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s0">False</span><span class="s2">] * </span><span class="s1">X_binned</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s4">1</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">uint8</span><span class="s2">)</span>
            <span class="s1">monotonic_cst </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">(</span>
                <span class="s2">[</span><span class="s1">MonotonicConstraint</span><span class="s2">.</span><span class="s1">NO_CST</span><span class="s2">] * </span><span class="s1">X_binned</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s4">1</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">int8</span>
            <span class="s2">)</span>
            <span class="s1">is_categorical </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros_like</span><span class="s2">(</span><span class="s1">monotonic_cst</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">uint8</span><span class="s2">)</span>
            <span class="s1">missing_values_bin_idx </span><span class="s2">= </span><span class="s1">n_bins </span><span class="s2">- </span><span class="s4">1</span>
            <span class="s1">splitter </span><span class="s2">= </span><span class="s1">Splitter</span><span class="s2">(</span>
                <span class="s1">X_binned</span><span class="s2">,</span>
                <span class="s1">n_bins_non_missing</span><span class="s2">,</span>
                <span class="s1">missing_values_bin_idx</span><span class="s2">,</span>
                <span class="s1">has_missing_values</span><span class="s2">,</span>
                <span class="s1">is_categorical</span><span class="s2">,</span>
                <span class="s1">monotonic_cst</span><span class="s2">,</span>
                <span class="s1">l2_regularization</span><span class="s2">,</span>
                <span class="s1">min_hessian_to_split</span><span class="s2">,</span>
                <span class="s1">min_samples_leaf</span><span class="s2">,</span>
                <span class="s1">min_gain_to_split</span><span class="s2">,</span>
                <span class="s1">hessians_are_constant</span><span class="s2">,</span>
            <span class="s2">)</span>

            <span class="s1">histograms </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">compute_histograms_brute</span><span class="s2">(</span><span class="s1">sample_indices</span><span class="s2">)</span>
            <span class="s1">value </span><span class="s2">= </span><span class="s1">compute_node_value</span><span class="s2">(</span>
                <span class="s1">sum_gradients</span><span class="s2">, </span><span class="s1">sum_hessians</span><span class="s2">, -</span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span><span class="s2">, </span><span class="s1">l2_regularization</span>
            <span class="s2">)</span>
            <span class="s1">split_info </span><span class="s2">= </span><span class="s1">splitter</span><span class="s2">.</span><span class="s1">find_node_split</span><span class="s2">(</span>
                <span class="s1">sample_indices</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s4">0</span><span class="s2">], </span><span class="s1">histograms</span><span class="s2">, </span><span class="s1">sum_gradients</span><span class="s2">, </span><span class="s1">sum_hessians</span><span class="s2">, </span><span class="s1">value</span>
            <span class="s2">)</span>

            <span class="s0">assert </span><span class="s1">split_info</span><span class="s2">.</span><span class="s1">bin_idx </span><span class="s2">== </span><span class="s1">true_bin</span>
            <span class="s0">assert </span><span class="s1">split_info</span><span class="s2">.</span><span class="s1">gain </span><span class="s2">&gt;= </span><span class="s4">0</span>
            <span class="s0">assert </span><span class="s1">split_info</span><span class="s2">.</span><span class="s1">feature_idx </span><span class="s2">== </span><span class="s1">feature_idx</span>
            <span class="s0">assert </span><span class="s2">(</span>
                <span class="s1">split_info</span><span class="s2">.</span><span class="s1">n_samples_left </span><span class="s2">+ </span><span class="s1">split_info</span><span class="s2">.</span><span class="s1">n_samples_right</span>
                <span class="s2">== </span><span class="s1">sample_indices</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s4">0</span><span class="s2">]</span>
            <span class="s2">)</span>
            <span class="s5"># Constant hessian: 1. per sample.</span>
            <span class="s0">assert </span><span class="s1">split_info</span><span class="s2">.</span><span class="s1">n_samples_left </span><span class="s2">== </span><span class="s1">split_info</span><span class="s2">.</span><span class="s1">sum_hessian_left</span>


<span class="s2">@</span><span class="s1">skip_if_32bit</span>
<span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">parametrize</span><span class="s2">(</span><span class="s3">&quot;constant_hessian&quot;</span><span class="s2">, [</span><span class="s0">True</span><span class="s2">, </span><span class="s0">False</span><span class="s2">])</span>
<span class="s0">def </span><span class="s1">test_gradient_and_hessian_sanity</span><span class="s2">(</span><span class="s1">constant_hessian</span><span class="s2">):</span>
    <span class="s5"># This test checks that the values of gradients and hessians are</span>
    <span class="s5"># consistent in different places:</span>
    <span class="s5"># - in split_info: si.sum_gradient_left + si.sum_gradient_right must be</span>
    <span class="s5">#   equal to the gradient at the node. Same for hessians.</span>
    <span class="s5"># - in the histograms: summing 'sum_gradients' over the bins must be</span>
    <span class="s5">#   constant across all features, and those sums must be equal to the</span>
    <span class="s5">#   node's gradient. Same for hessians.</span>

    <span class="s1">rng </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">random</span><span class="s2">.</span><span class="s1">RandomState</span><span class="s2">(</span><span class="s4">42</span><span class="s2">)</span>

    <span class="s1">n_bins </span><span class="s2">= </span><span class="s4">10</span>
    <span class="s1">n_features </span><span class="s2">= </span><span class="s4">20</span>
    <span class="s1">n_samples </span><span class="s2">= </span><span class="s4">500</span>
    <span class="s1">l2_regularization </span><span class="s2">= </span><span class="s4">0.0</span>
    <span class="s1">min_hessian_to_split </span><span class="s2">= </span><span class="s4">1e-3</span>
    <span class="s1">min_samples_leaf </span><span class="s2">= </span><span class="s4">1</span>
    <span class="s1">min_gain_to_split </span><span class="s2">= </span><span class="s4">0.0</span>

    <span class="s1">X_binned </span><span class="s2">= </span><span class="s1">rng</span><span class="s2">.</span><span class="s1">randint</span><span class="s2">(</span>
        <span class="s4">0</span><span class="s2">, </span><span class="s1">n_bins</span><span class="s2">, </span><span class="s1">size</span><span class="s2">=(</span><span class="s1">n_samples</span><span class="s2">, </span><span class="s1">n_features</span><span class="s2">), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">X_BINNED_DTYPE</span>
    <span class="s2">)</span>
    <span class="s1">X_binned </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asfortranarray</span><span class="s2">(</span><span class="s1">X_binned</span><span class="s2">)</span>
    <span class="s1">sample_indices </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(</span><span class="s1">n_samples</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">uint32</span><span class="s2">)</span>
    <span class="s1">all_gradients </span><span class="s2">= </span><span class="s1">rng</span><span class="s2">.</span><span class="s1">randn</span><span class="s2">(</span><span class="s1">n_samples</span><span class="s2">).</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">G_H_DTYPE</span><span class="s2">)</span>
    <span class="s1">sum_gradients </span><span class="s2">= </span><span class="s1">all_gradients</span><span class="s2">.</span><span class="s1">sum</span><span class="s2">()</span>
    <span class="s0">if </span><span class="s1">constant_hessian</span><span class="s2">:</span>
        <span class="s1">all_hessians </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">G_H_DTYPE</span><span class="s2">)</span>
        <span class="s1">sum_hessians </span><span class="s2">= </span><span class="s4">1 </span><span class="s2">* </span><span class="s1">n_samples</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">all_hessians </span><span class="s2">= </span><span class="s1">rng</span><span class="s2">.</span><span class="s1">lognormal</span><span class="s2">(</span><span class="s1">size</span><span class="s2">=</span><span class="s1">n_samples</span><span class="s2">).</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">G_H_DTYPE</span><span class="s2">)</span>
        <span class="s1">sum_hessians </span><span class="s2">= </span><span class="s1">all_hessians</span><span class="s2">.</span><span class="s1">sum</span><span class="s2">()</span>

    <span class="s1">builder </span><span class="s2">= </span><span class="s1">HistogramBuilder</span><span class="s2">(</span>
        <span class="s1">X_binned</span><span class="s2">, </span><span class="s1">n_bins</span><span class="s2">, </span><span class="s1">all_gradients</span><span class="s2">, </span><span class="s1">all_hessians</span><span class="s2">, </span><span class="s1">constant_hessian</span><span class="s2">, </span><span class="s1">n_threads</span>
    <span class="s2">)</span>
    <span class="s1">n_bins_non_missing </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s1">n_bins </span><span class="s2">- </span><span class="s4">1</span><span class="s2">] * </span><span class="s1">X_binned</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s4">1</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">uint32</span><span class="s2">)</span>
    <span class="s1">has_missing_values </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s0">False</span><span class="s2">] * </span><span class="s1">X_binned</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s4">1</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">uint8</span><span class="s2">)</span>
    <span class="s1">monotonic_cst </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">(</span>
        <span class="s2">[</span><span class="s1">MonotonicConstraint</span><span class="s2">.</span><span class="s1">NO_CST</span><span class="s2">] * </span><span class="s1">X_binned</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s4">1</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">int8</span>
    <span class="s2">)</span>
    <span class="s1">is_categorical </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros_like</span><span class="s2">(</span><span class="s1">monotonic_cst</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">uint8</span><span class="s2">)</span>
    <span class="s1">missing_values_bin_idx </span><span class="s2">= </span><span class="s1">n_bins </span><span class="s2">- </span><span class="s4">1</span>
    <span class="s1">splitter </span><span class="s2">= </span><span class="s1">Splitter</span><span class="s2">(</span>
        <span class="s1">X_binned</span><span class="s2">,</span>
        <span class="s1">n_bins_non_missing</span><span class="s2">,</span>
        <span class="s1">missing_values_bin_idx</span><span class="s2">,</span>
        <span class="s1">has_missing_values</span><span class="s2">,</span>
        <span class="s1">is_categorical</span><span class="s2">,</span>
        <span class="s1">monotonic_cst</span><span class="s2">,</span>
        <span class="s1">l2_regularization</span><span class="s2">,</span>
        <span class="s1">min_hessian_to_split</span><span class="s2">,</span>
        <span class="s1">min_samples_leaf</span><span class="s2">,</span>
        <span class="s1">min_gain_to_split</span><span class="s2">,</span>
        <span class="s1">constant_hessian</span><span class="s2">,</span>
    <span class="s2">)</span>

    <span class="s1">hists_parent </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">compute_histograms_brute</span><span class="s2">(</span><span class="s1">sample_indices</span><span class="s2">)</span>
    <span class="s1">value_parent </span><span class="s2">= </span><span class="s1">compute_node_value</span><span class="s2">(</span>
        <span class="s1">sum_gradients</span><span class="s2">, </span><span class="s1">sum_hessians</span><span class="s2">, -</span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span><span class="s2">, </span><span class="s1">l2_regularization</span>
    <span class="s2">)</span>
    <span class="s1">si_parent </span><span class="s2">= </span><span class="s1">splitter</span><span class="s2">.</span><span class="s1">find_node_split</span><span class="s2">(</span>
        <span class="s1">n_samples</span><span class="s2">, </span><span class="s1">hists_parent</span><span class="s2">, </span><span class="s1">sum_gradients</span><span class="s2">, </span><span class="s1">sum_hessians</span><span class="s2">, </span><span class="s1">value_parent</span>
    <span class="s2">)</span>
    <span class="s1">sample_indices_left</span><span class="s2">, </span><span class="s1">sample_indices_right</span><span class="s2">, </span><span class="s1">_ </span><span class="s2">= </span><span class="s1">splitter</span><span class="s2">.</span><span class="s1">split_indices</span><span class="s2">(</span>
        <span class="s1">si_parent</span><span class="s2">, </span><span class="s1">sample_indices</span>
    <span class="s2">)</span>

    <span class="s1">hists_left </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">compute_histograms_brute</span><span class="s2">(</span><span class="s1">sample_indices_left</span><span class="s2">)</span>
    <span class="s1">value_left </span><span class="s2">= </span><span class="s1">compute_node_value</span><span class="s2">(</span>
        <span class="s1">si_parent</span><span class="s2">.</span><span class="s1">sum_gradient_left</span><span class="s2">,</span>
        <span class="s1">si_parent</span><span class="s2">.</span><span class="s1">sum_hessian_left</span><span class="s2">,</span>
        <span class="s2">-</span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span><span class="s2">,</span>
        <span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span><span class="s2">,</span>
        <span class="s1">l2_regularization</span><span class="s2">,</span>
    <span class="s2">)</span>
    <span class="s1">hists_right </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">compute_histograms_brute</span><span class="s2">(</span><span class="s1">sample_indices_right</span><span class="s2">)</span>
    <span class="s1">value_right </span><span class="s2">= </span><span class="s1">compute_node_value</span><span class="s2">(</span>
        <span class="s1">si_parent</span><span class="s2">.</span><span class="s1">sum_gradient_right</span><span class="s2">,</span>
        <span class="s1">si_parent</span><span class="s2">.</span><span class="s1">sum_hessian_right</span><span class="s2">,</span>
        <span class="s2">-</span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span><span class="s2">,</span>
        <span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span><span class="s2">,</span>
        <span class="s1">l2_regularization</span><span class="s2">,</span>
    <span class="s2">)</span>
    <span class="s1">si_left </span><span class="s2">= </span><span class="s1">splitter</span><span class="s2">.</span><span class="s1">find_node_split</span><span class="s2">(</span>
        <span class="s1">n_samples</span><span class="s2">,</span>
        <span class="s1">hists_left</span><span class="s2">,</span>
        <span class="s1">si_parent</span><span class="s2">.</span><span class="s1">sum_gradient_left</span><span class="s2">,</span>
        <span class="s1">si_parent</span><span class="s2">.</span><span class="s1">sum_hessian_left</span><span class="s2">,</span>
        <span class="s1">value_left</span><span class="s2">,</span>
    <span class="s2">)</span>
    <span class="s1">si_right </span><span class="s2">= </span><span class="s1">splitter</span><span class="s2">.</span><span class="s1">find_node_split</span><span class="s2">(</span>
        <span class="s1">n_samples</span><span class="s2">,</span>
        <span class="s1">hists_right</span><span class="s2">,</span>
        <span class="s1">si_parent</span><span class="s2">.</span><span class="s1">sum_gradient_right</span><span class="s2">,</span>
        <span class="s1">si_parent</span><span class="s2">.</span><span class="s1">sum_hessian_right</span><span class="s2">,</span>
        <span class="s1">value_right</span><span class="s2">,</span>
    <span class="s2">)</span>

    <span class="s5"># make sure that si.sum_gradient_left + si.sum_gradient_right have their</span>
    <span class="s5"># expected value, same for hessians</span>
    <span class="s0">for </span><span class="s1">si</span><span class="s2">, </span><span class="s1">indices </span><span class="s0">in </span><span class="s2">(</span>
        <span class="s2">(</span><span class="s1">si_parent</span><span class="s2">, </span><span class="s1">sample_indices</span><span class="s2">),</span>
        <span class="s2">(</span><span class="s1">si_left</span><span class="s2">, </span><span class="s1">sample_indices_left</span><span class="s2">),</span>
        <span class="s2">(</span><span class="s1">si_right</span><span class="s2">, </span><span class="s1">sample_indices_right</span><span class="s2">),</span>
    <span class="s2">):</span>
        <span class="s1">gradient </span><span class="s2">= </span><span class="s1">si</span><span class="s2">.</span><span class="s1">sum_gradient_right </span><span class="s2">+ </span><span class="s1">si</span><span class="s2">.</span><span class="s1">sum_gradient_left</span>
        <span class="s1">expected_gradient </span><span class="s2">= </span><span class="s1">all_gradients</span><span class="s2">[</span><span class="s1">indices</span><span class="s2">].</span><span class="s1">sum</span><span class="s2">()</span>
        <span class="s1">hessian </span><span class="s2">= </span><span class="s1">si</span><span class="s2">.</span><span class="s1">sum_hessian_right </span><span class="s2">+ </span><span class="s1">si</span><span class="s2">.</span><span class="s1">sum_hessian_left</span>
        <span class="s0">if </span><span class="s1">constant_hessian</span><span class="s2">:</span>
            <span class="s1">expected_hessian </span><span class="s2">= </span><span class="s1">indices</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s4">0</span><span class="s2">] * </span><span class="s1">all_hessians</span><span class="s2">[</span><span class="s4">0</span><span class="s2">]</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">expected_hessian </span><span class="s2">= </span><span class="s1">all_hessians</span><span class="s2">[</span><span class="s1">indices</span><span class="s2">].</span><span class="s1">sum</span><span class="s2">()</span>

        <span class="s0">assert </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isclose</span><span class="s2">(</span><span class="s1">gradient</span><span class="s2">, </span><span class="s1">expected_gradient</span><span class="s2">)</span>
        <span class="s0">assert </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isclose</span><span class="s2">(</span><span class="s1">hessian</span><span class="s2">, </span><span class="s1">expected_hessian</span><span class="s2">)</span>

    <span class="s5"># make sure sum of gradients in histograms are the same for all features,</span>
    <span class="s5"># and make sure they're equal to their expected value</span>
    <span class="s1">hists_parent </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">hists_parent</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">HISTOGRAM_DTYPE</span><span class="s2">)</span>
    <span class="s1">hists_left </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">hists_left</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">HISTOGRAM_DTYPE</span><span class="s2">)</span>
    <span class="s1">hists_right </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">hists_right</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">HISTOGRAM_DTYPE</span><span class="s2">)</span>
    <span class="s0">for </span><span class="s1">hists</span><span class="s2">, </span><span class="s1">indices </span><span class="s0">in </span><span class="s2">(</span>
        <span class="s2">(</span><span class="s1">hists_parent</span><span class="s2">, </span><span class="s1">sample_indices</span><span class="s2">),</span>
        <span class="s2">(</span><span class="s1">hists_left</span><span class="s2">, </span><span class="s1">sample_indices_left</span><span class="s2">),</span>
        <span class="s2">(</span><span class="s1">hists_right</span><span class="s2">, </span><span class="s1">sample_indices_right</span><span class="s2">),</span>
    <span class="s2">):</span>
        <span class="s5"># note: gradients and hessians have shape (n_features,),</span>
        <span class="s5"># we're comparing them to *scalars*. This has the benefit of also</span>
        <span class="s5"># making sure that all the entries are equal across features.</span>
        <span class="s1">gradients </span><span class="s2">= </span><span class="s1">hists</span><span class="s2">[</span><span class="s3">&quot;sum_gradients&quot;</span><span class="s2">].</span><span class="s1">sum</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">=</span><span class="s4">1</span><span class="s2">)  </span><span class="s5"># shape = (n_features,)</span>
        <span class="s1">expected_gradient </span><span class="s2">= </span><span class="s1">all_gradients</span><span class="s2">[</span><span class="s1">indices</span><span class="s2">].</span><span class="s1">sum</span><span class="s2">()  </span><span class="s5"># scalar</span>
        <span class="s1">hessians </span><span class="s2">= </span><span class="s1">hists</span><span class="s2">[</span><span class="s3">&quot;sum_hessians&quot;</span><span class="s2">].</span><span class="s1">sum</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">=</span><span class="s4">1</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">constant_hessian</span><span class="s2">:</span>
            <span class="s5"># 0 is not the actual hessian, but it's not computed in this case</span>
            <span class="s1">expected_hessian </span><span class="s2">= </span><span class="s4">0.0</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">expected_hessian </span><span class="s2">= </span><span class="s1">all_hessians</span><span class="s2">[</span><span class="s1">indices</span><span class="s2">].</span><span class="s1">sum</span><span class="s2">()</span>

        <span class="s0">assert </span><span class="s1">np</span><span class="s2">.</span><span class="s1">allclose</span><span class="s2">(</span><span class="s1">gradients</span><span class="s2">, </span><span class="s1">expected_gradient</span><span class="s2">)</span>
        <span class="s0">assert </span><span class="s1">np</span><span class="s2">.</span><span class="s1">allclose</span><span class="s2">(</span><span class="s1">hessians</span><span class="s2">, </span><span class="s1">expected_hessian</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">test_split_indices</span><span class="s2">():</span>
    <span class="s5"># Check that split_indices returns the correct splits and that</span>
    <span class="s5"># splitter.partition is consistent with what is returned.</span>
    <span class="s1">rng </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">random</span><span class="s2">.</span><span class="s1">RandomState</span><span class="s2">(</span><span class="s4">421</span><span class="s2">)</span>

    <span class="s1">n_bins </span><span class="s2">= </span><span class="s4">5</span>
    <span class="s1">n_samples </span><span class="s2">= </span><span class="s4">10</span>
    <span class="s1">l2_regularization </span><span class="s2">= </span><span class="s4">0.0</span>
    <span class="s1">min_hessian_to_split </span><span class="s2">= </span><span class="s4">1e-3</span>
    <span class="s1">min_samples_leaf </span><span class="s2">= </span><span class="s4">1</span>
    <span class="s1">min_gain_to_split </span><span class="s2">= </span><span class="s4">0.0</span>

    <span class="s5"># split will happen on feature 1 and on bin 3</span>
    <span class="s1">X_binned </span><span class="s2">= [</span>
        <span class="s2">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">],</span>
        <span class="s2">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">3</span><span class="s2">],</span>
        <span class="s2">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">4</span><span class="s2">],</span>
        <span class="s2">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">],</span>
        <span class="s2">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">],</span>
        <span class="s2">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">],</span>
        <span class="s2">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">],</span>
        <span class="s2">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">4</span><span class="s2">],</span>
        <span class="s2">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">],</span>
        <span class="s2">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">4</span><span class="s2">],</span>
    <span class="s2">]</span>
    <span class="s1">X_binned </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asfortranarray</span><span class="s2">(</span><span class="s1">X_binned</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">X_BINNED_DTYPE</span><span class="s2">)</span>
    <span class="s1">sample_indices </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(</span><span class="s1">n_samples</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">uint32</span><span class="s2">)</span>
    <span class="s1">all_gradients </span><span class="s2">= </span><span class="s1">rng</span><span class="s2">.</span><span class="s1">randn</span><span class="s2">(</span><span class="s1">n_samples</span><span class="s2">).</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">G_H_DTYPE</span><span class="s2">)</span>
    <span class="s1">all_hessians </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">G_H_DTYPE</span><span class="s2">)</span>
    <span class="s1">sum_gradients </span><span class="s2">= </span><span class="s1">all_gradients</span><span class="s2">.</span><span class="s1">sum</span><span class="s2">()</span>
    <span class="s1">sum_hessians </span><span class="s2">= </span><span class="s4">1 </span><span class="s2">* </span><span class="s1">n_samples</span>
    <span class="s1">hessians_are_constant </span><span class="s2">= </span><span class="s0">True</span>

    <span class="s1">builder </span><span class="s2">= </span><span class="s1">HistogramBuilder</span><span class="s2">(</span>
        <span class="s1">X_binned</span><span class="s2">, </span><span class="s1">n_bins</span><span class="s2">, </span><span class="s1">all_gradients</span><span class="s2">, </span><span class="s1">all_hessians</span><span class="s2">, </span><span class="s1">hessians_are_constant</span><span class="s2">, </span><span class="s1">n_threads</span>
    <span class="s2">)</span>
    <span class="s1">n_bins_non_missing </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s1">n_bins</span><span class="s2">] * </span><span class="s1">X_binned</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s4">1</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">uint32</span><span class="s2">)</span>
    <span class="s1">has_missing_values </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s0">False</span><span class="s2">] * </span><span class="s1">X_binned</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s4">1</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">uint8</span><span class="s2">)</span>
    <span class="s1">monotonic_cst </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">(</span>
        <span class="s2">[</span><span class="s1">MonotonicConstraint</span><span class="s2">.</span><span class="s1">NO_CST</span><span class="s2">] * </span><span class="s1">X_binned</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s4">1</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">int8</span>
    <span class="s2">)</span>
    <span class="s1">is_categorical </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros_like</span><span class="s2">(</span><span class="s1">monotonic_cst</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">uint8</span><span class="s2">)</span>
    <span class="s1">missing_values_bin_idx </span><span class="s2">= </span><span class="s1">n_bins </span><span class="s2">- </span><span class="s4">1</span>
    <span class="s1">splitter </span><span class="s2">= </span><span class="s1">Splitter</span><span class="s2">(</span>
        <span class="s1">X_binned</span><span class="s2">,</span>
        <span class="s1">n_bins_non_missing</span><span class="s2">,</span>
        <span class="s1">missing_values_bin_idx</span><span class="s2">,</span>
        <span class="s1">has_missing_values</span><span class="s2">,</span>
        <span class="s1">is_categorical</span><span class="s2">,</span>
        <span class="s1">monotonic_cst</span><span class="s2">,</span>
        <span class="s1">l2_regularization</span><span class="s2">,</span>
        <span class="s1">min_hessian_to_split</span><span class="s2">,</span>
        <span class="s1">min_samples_leaf</span><span class="s2">,</span>
        <span class="s1">min_gain_to_split</span><span class="s2">,</span>
        <span class="s1">hessians_are_constant</span><span class="s2">,</span>
    <span class="s2">)</span>

    <span class="s0">assert </span><span class="s1">np</span><span class="s2">.</span><span class="s1">all</span><span class="s2">(</span><span class="s1">sample_indices </span><span class="s2">== </span><span class="s1">splitter</span><span class="s2">.</span><span class="s1">partition</span><span class="s2">)</span>

    <span class="s1">histograms </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">compute_histograms_brute</span><span class="s2">(</span><span class="s1">sample_indices</span><span class="s2">)</span>
    <span class="s1">value </span><span class="s2">= </span><span class="s1">compute_node_value</span><span class="s2">(</span>
        <span class="s1">sum_gradients</span><span class="s2">, </span><span class="s1">sum_hessians</span><span class="s2">, -</span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span><span class="s2">, </span><span class="s1">l2_regularization</span>
    <span class="s2">)</span>
    <span class="s1">si_root </span><span class="s2">= </span><span class="s1">splitter</span><span class="s2">.</span><span class="s1">find_node_split</span><span class="s2">(</span>
        <span class="s1">n_samples</span><span class="s2">, </span><span class="s1">histograms</span><span class="s2">, </span><span class="s1">sum_gradients</span><span class="s2">, </span><span class="s1">sum_hessians</span><span class="s2">, </span><span class="s1">value</span>
    <span class="s2">)</span>

    <span class="s5"># sanity checks for best split</span>
    <span class="s0">assert </span><span class="s1">si_root</span><span class="s2">.</span><span class="s1">feature_idx </span><span class="s2">== </span><span class="s4">1</span>
    <span class="s0">assert </span><span class="s1">si_root</span><span class="s2">.</span><span class="s1">bin_idx </span><span class="s2">== </span><span class="s4">3</span>

    <span class="s1">samples_left</span><span class="s2">, </span><span class="s1">samples_right</span><span class="s2">, </span><span class="s1">position_right </span><span class="s2">= </span><span class="s1">splitter</span><span class="s2">.</span><span class="s1">split_indices</span><span class="s2">(</span>
        <span class="s1">si_root</span><span class="s2">, </span><span class="s1">splitter</span><span class="s2">.</span><span class="s1">partition</span>
    <span class="s2">)</span>
    <span class="s0">assert </span><span class="s1">set</span><span class="s2">(</span><span class="s1">samples_left</span><span class="s2">) == </span><span class="s1">set</span><span class="s2">([</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">6</span><span class="s2">, </span><span class="s4">8</span><span class="s2">])</span>
    <span class="s0">assert </span><span class="s1">set</span><span class="s2">(</span><span class="s1">samples_right</span><span class="s2">) == </span><span class="s1">set</span><span class="s2">([</span><span class="s4">2</span><span class="s2">, </span><span class="s4">7</span><span class="s2">, </span><span class="s4">9</span><span class="s2">])</span>

    <span class="s0">assert </span><span class="s1">list</span><span class="s2">(</span><span class="s1">samples_left</span><span class="s2">) == </span><span class="s1">list</span><span class="s2">(</span><span class="s1">splitter</span><span class="s2">.</span><span class="s1">partition</span><span class="s2">[:</span><span class="s1">position_right</span><span class="s2">])</span>
    <span class="s0">assert </span><span class="s1">list</span><span class="s2">(</span><span class="s1">samples_right</span><span class="s2">) == </span><span class="s1">list</span><span class="s2">(</span><span class="s1">splitter</span><span class="s2">.</span><span class="s1">partition</span><span class="s2">[</span><span class="s1">position_right</span><span class="s2">:])</span>

    <span class="s5"># Check that the resulting split indices sizes are consistent with the</span>
    <span class="s5"># count statistics anticipated when looking for the best split.</span>
    <span class="s0">assert </span><span class="s1">samples_left</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s4">0</span><span class="s2">] == </span><span class="s1">si_root</span><span class="s2">.</span><span class="s1">n_samples_left</span>
    <span class="s0">assert </span><span class="s1">samples_right</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s4">0</span><span class="s2">] == </span><span class="s1">si_root</span><span class="s2">.</span><span class="s1">n_samples_right</span>


<span class="s0">def </span><span class="s1">test_min_gain_to_split</span><span class="s2">():</span>
    <span class="s5"># Try to split a pure node (all gradients are equal, same for hessians)</span>
    <span class="s5"># with min_gain_to_split = 0 and make sure that the node is not split (best</span>
    <span class="s5"># possible gain = -1). Note: before the strict inequality comparison, this</span>
    <span class="s5"># test would fail because the node would be split with a gain of 0.</span>
    <span class="s1">rng </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">random</span><span class="s2">.</span><span class="s1">RandomState</span><span class="s2">(</span><span class="s4">42</span><span class="s2">)</span>
    <span class="s1">l2_regularization </span><span class="s2">= </span><span class="s4">0</span>
    <span class="s1">min_hessian_to_split </span><span class="s2">= </span><span class="s4">0</span>
    <span class="s1">min_samples_leaf </span><span class="s2">= </span><span class="s4">1</span>
    <span class="s1">min_gain_to_split </span><span class="s2">= </span><span class="s4">0.0</span>
    <span class="s1">n_bins </span><span class="s2">= </span><span class="s4">255</span>
    <span class="s1">n_samples </span><span class="s2">= </span><span class="s4">100</span>
    <span class="s1">X_binned </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asfortranarray</span><span class="s2">(</span>
        <span class="s1">rng</span><span class="s2">.</span><span class="s1">randint</span><span class="s2">(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">n_bins</span><span class="s2">, </span><span class="s1">size</span><span class="s2">=(</span><span class="s1">n_samples</span><span class="s2">, </span><span class="s4">1</span><span class="s2">)), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">X_BINNED_DTYPE</span>
    <span class="s2">)</span>
    <span class="s1">binned_feature </span><span class="s2">= </span><span class="s1">X_binned</span><span class="s2">[:, </span><span class="s4">0</span><span class="s2">]</span>
    <span class="s1">sample_indices </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(</span><span class="s1">n_samples</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">uint32</span><span class="s2">)</span>
    <span class="s1">all_hessians </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones_like</span><span class="s2">(</span><span class="s1">binned_feature</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">G_H_DTYPE</span><span class="s2">)</span>
    <span class="s1">all_gradients </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones_like</span><span class="s2">(</span><span class="s1">binned_feature</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">G_H_DTYPE</span><span class="s2">)</span>
    <span class="s1">sum_gradients </span><span class="s2">= </span><span class="s1">all_gradients</span><span class="s2">.</span><span class="s1">sum</span><span class="s2">()</span>
    <span class="s1">sum_hessians </span><span class="s2">= </span><span class="s1">all_hessians</span><span class="s2">.</span><span class="s1">sum</span><span class="s2">()</span>
    <span class="s1">hessians_are_constant </span><span class="s2">= </span><span class="s0">False</span>

    <span class="s1">builder </span><span class="s2">= </span><span class="s1">HistogramBuilder</span><span class="s2">(</span>
        <span class="s1">X_binned</span><span class="s2">, </span><span class="s1">n_bins</span><span class="s2">, </span><span class="s1">all_gradients</span><span class="s2">, </span><span class="s1">all_hessians</span><span class="s2">, </span><span class="s1">hessians_are_constant</span><span class="s2">, </span><span class="s1">n_threads</span>
    <span class="s2">)</span>
    <span class="s1">n_bins_non_missing </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s1">n_bins </span><span class="s2">- </span><span class="s4">1</span><span class="s2">] * </span><span class="s1">X_binned</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s4">1</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">uint32</span><span class="s2">)</span>
    <span class="s1">has_missing_values </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s0">False</span><span class="s2">] * </span><span class="s1">X_binned</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s4">1</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">uint8</span><span class="s2">)</span>
    <span class="s1">monotonic_cst </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">(</span>
        <span class="s2">[</span><span class="s1">MonotonicConstraint</span><span class="s2">.</span><span class="s1">NO_CST</span><span class="s2">] * </span><span class="s1">X_binned</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s4">1</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">int8</span>
    <span class="s2">)</span>
    <span class="s1">is_categorical </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros_like</span><span class="s2">(</span><span class="s1">monotonic_cst</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">uint8</span><span class="s2">)</span>
    <span class="s1">missing_values_bin_idx </span><span class="s2">= </span><span class="s1">n_bins </span><span class="s2">- </span><span class="s4">1</span>
    <span class="s1">splitter </span><span class="s2">= </span><span class="s1">Splitter</span><span class="s2">(</span>
        <span class="s1">X_binned</span><span class="s2">,</span>
        <span class="s1">n_bins_non_missing</span><span class="s2">,</span>
        <span class="s1">missing_values_bin_idx</span><span class="s2">,</span>
        <span class="s1">has_missing_values</span><span class="s2">,</span>
        <span class="s1">is_categorical</span><span class="s2">,</span>
        <span class="s1">monotonic_cst</span><span class="s2">,</span>
        <span class="s1">l2_regularization</span><span class="s2">,</span>
        <span class="s1">min_hessian_to_split</span><span class="s2">,</span>
        <span class="s1">min_samples_leaf</span><span class="s2">,</span>
        <span class="s1">min_gain_to_split</span><span class="s2">,</span>
        <span class="s1">hessians_are_constant</span><span class="s2">,</span>
    <span class="s2">)</span>

    <span class="s1">histograms </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">compute_histograms_brute</span><span class="s2">(</span><span class="s1">sample_indices</span><span class="s2">)</span>
    <span class="s1">value </span><span class="s2">= </span><span class="s1">compute_node_value</span><span class="s2">(</span>
        <span class="s1">sum_gradients</span><span class="s2">, </span><span class="s1">sum_hessians</span><span class="s2">, -</span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span><span class="s2">, </span><span class="s1">l2_regularization</span>
    <span class="s2">)</span>
    <span class="s1">split_info </span><span class="s2">= </span><span class="s1">splitter</span><span class="s2">.</span><span class="s1">find_node_split</span><span class="s2">(</span>
        <span class="s1">n_samples</span><span class="s2">, </span><span class="s1">histograms</span><span class="s2">, </span><span class="s1">sum_gradients</span><span class="s2">, </span><span class="s1">sum_hessians</span><span class="s2">, </span><span class="s1">value</span>
    <span class="s2">)</span>
    <span class="s0">assert </span><span class="s1">split_info</span><span class="s2">.</span><span class="s1">gain </span><span class="s2">== -</span><span class="s4">1</span>


<span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">parametrize</span><span class="s2">(</span>
    <span class="s2">(</span>
        <span class="s3">&quot;X_binned, all_gradients, has_missing_values, n_bins_non_missing, &quot;</span>
        <span class="s3">&quot; expected_split_on_nan, expected_bin_idx, expected_go_to_left&quot;</span>
    <span class="s2">),</span>
    <span class="s2">[</span>
        <span class="s5"># basic sanity check with no missing values: given the gradient</span>
        <span class="s5"># values, the split must occur on bin_idx=3</span>
        <span class="s2">(</span>
            <span class="s2">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">6</span><span class="s2">, </span><span class="s4">7</span><span class="s2">, </span><span class="s4">8</span><span class="s2">, </span><span class="s4">9</span><span class="s2">],  </span><span class="s5"># X_binned</span>
            <span class="s2">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">5</span><span class="s2">],  </span><span class="s5"># gradients</span>
            <span class="s0">False</span><span class="s2">,  </span><span class="s5"># no missing values</span>
            <span class="s4">10</span><span class="s2">,  </span><span class="s5"># n_bins_non_missing</span>
            <span class="s0">False</span><span class="s2">,  </span><span class="s5"># don't split on nans</span>
            <span class="s4">3</span><span class="s2">,  </span><span class="s5"># expected_bin_idx</span>
            <span class="s3">&quot;not_applicable&quot;</span><span class="s2">,</span>
        <span class="s2">),</span>
        <span class="s5"># We replace 2 samples by NaNs (bin_idx=8)</span>
        <span class="s5"># These 2 samples were mapped to the left node before, so they should</span>
        <span class="s5"># be mapped to left node again</span>
        <span class="s5"># Notice how the bin_idx threshold changes from 3 to 1.</span>
        <span class="s2">(</span>
            <span class="s2">[</span><span class="s4">8</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">8</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">6</span><span class="s2">, </span><span class="s4">7</span><span class="s2">],  </span><span class="s5"># 8 &lt;=&gt; missing</span>
            <span class="s2">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">5</span><span class="s2">],</span>
            <span class="s0">True</span><span class="s2">,  </span><span class="s5"># missing values</span>
            <span class="s4">8</span><span class="s2">,  </span><span class="s5"># n_bins_non_missing</span>
            <span class="s0">False</span><span class="s2">,  </span><span class="s5"># don't split on nans</span>
            <span class="s4">1</span><span class="s2">,  </span><span class="s5"># cut on bin_idx=1</span>
            <span class="s0">True</span><span class="s2">,</span>
        <span class="s2">),  </span><span class="s5"># missing values go to left</span>
        <span class="s5"># same as above, but with non-consecutive missing_values_bin</span>
        <span class="s2">(</span>
            <span class="s2">[</span><span class="s4">9</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">9</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">6</span><span class="s2">, </span><span class="s4">7</span><span class="s2">],  </span><span class="s5"># 9 &lt;=&gt; missing</span>
            <span class="s2">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">5</span><span class="s2">],</span>
            <span class="s0">True</span><span class="s2">,  </span><span class="s5"># missing values</span>
            <span class="s4">8</span><span class="s2">,  </span><span class="s5"># n_bins_non_missing</span>
            <span class="s0">False</span><span class="s2">,  </span><span class="s5"># don't split on nans</span>
            <span class="s4">1</span><span class="s2">,  </span><span class="s5"># cut on bin_idx=1</span>
            <span class="s0">True</span><span class="s2">,</span>
        <span class="s2">),  </span><span class="s5"># missing values go to left</span>
        <span class="s5"># this time replacing 2 samples that were on the right.</span>
        <span class="s2">(</span>
            <span class="s2">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">8</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">8</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">6</span><span class="s2">, </span><span class="s4">7</span><span class="s2">],  </span><span class="s5"># 8 &lt;=&gt; missing</span>
            <span class="s2">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">5</span><span class="s2">],</span>
            <span class="s0">True</span><span class="s2">,  </span><span class="s5"># missing values</span>
            <span class="s4">8</span><span class="s2">,  </span><span class="s5"># n_bins_non_missing</span>
            <span class="s0">False</span><span class="s2">,  </span><span class="s5"># don't split on nans</span>
            <span class="s4">3</span><span class="s2">,  </span><span class="s5"># cut on bin_idx=3 (like in first case)</span>
            <span class="s0">False</span><span class="s2">,</span>
        <span class="s2">),  </span><span class="s5"># missing values go to right</span>
        <span class="s5"># same as above, but with non-consecutive missing_values_bin</span>
        <span class="s2">(</span>
            <span class="s2">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">9</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">9</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">6</span><span class="s2">, </span><span class="s4">7</span><span class="s2">],  </span><span class="s5"># 9 &lt;=&gt; missing</span>
            <span class="s2">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">5</span><span class="s2">],</span>
            <span class="s0">True</span><span class="s2">,  </span><span class="s5"># missing values</span>
            <span class="s4">8</span><span class="s2">,  </span><span class="s5"># n_bins_non_missing</span>
            <span class="s0">False</span><span class="s2">,  </span><span class="s5"># don't split on nans</span>
            <span class="s4">3</span><span class="s2">,  </span><span class="s5"># cut on bin_idx=3 (like in first case)</span>
            <span class="s0">False</span><span class="s2">,</span>
        <span class="s2">),  </span><span class="s5"># missing values go to right</span>
        <span class="s5"># For the following cases, split_on_nans is True (we replace all of</span>
        <span class="s5"># the samples with nans, instead of just 2).</span>
        <span class="s2">(</span>
            <span class="s2">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">4</span><span class="s2">],  </span><span class="s5"># 4 &lt;=&gt; missing</span>
            <span class="s2">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">5</span><span class="s2">],</span>
            <span class="s0">True</span><span class="s2">,  </span><span class="s5"># missing values</span>
            <span class="s4">4</span><span class="s2">,  </span><span class="s5"># n_bins_non_missing</span>
            <span class="s0">True</span><span class="s2">,  </span><span class="s5"># split on nans</span>
            <span class="s4">3</span><span class="s2">,  </span><span class="s5"># cut on bin_idx=3</span>
            <span class="s0">False</span><span class="s2">,</span>
        <span class="s2">),  </span><span class="s5"># missing values go to right</span>
        <span class="s5"># same as above, but with non-consecutive missing_values_bin</span>
        <span class="s2">(</span>
            <span class="s2">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">9</span><span class="s2">, </span><span class="s4">9</span><span class="s2">, </span><span class="s4">9</span><span class="s2">, </span><span class="s4">9</span><span class="s2">, </span><span class="s4">9</span><span class="s2">, </span><span class="s4">9</span><span class="s2">],  </span><span class="s5"># 9 &lt;=&gt; missing</span>
            <span class="s2">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">5</span><span class="s2">],</span>
            <span class="s0">True</span><span class="s2">,  </span><span class="s5"># missing values</span>
            <span class="s4">4</span><span class="s2">,  </span><span class="s5"># n_bins_non_missing</span>
            <span class="s0">True</span><span class="s2">,  </span><span class="s5"># split on nans</span>
            <span class="s4">3</span><span class="s2">,  </span><span class="s5"># cut on bin_idx=3</span>
            <span class="s0">False</span><span class="s2">,</span>
        <span class="s2">),  </span><span class="s5"># missing values go to right</span>
        <span class="s2">(</span>
            <span class="s2">[</span><span class="s4">6</span><span class="s2">, </span><span class="s4">6</span><span class="s2">, </span><span class="s4">6</span><span class="s2">, </span><span class="s4">6</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s2">],  </span><span class="s5"># 6 &lt;=&gt; missing</span>
            <span class="s2">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">5</span><span class="s2">],</span>
            <span class="s0">True</span><span class="s2">,  </span><span class="s5"># missing values</span>
            <span class="s4">6</span><span class="s2">,  </span><span class="s5"># n_bins_non_missing</span>
            <span class="s0">True</span><span class="s2">,  </span><span class="s5"># split on nans</span>
            <span class="s4">5</span><span class="s2">,  </span><span class="s5"># cut on bin_idx=5</span>
            <span class="s0">False</span><span class="s2">,</span>
        <span class="s2">),  </span><span class="s5"># missing values go to right</span>
        <span class="s5"># same as above, but with non-consecutive missing_values_bin</span>
        <span class="s2">(</span>
            <span class="s2">[</span><span class="s4">9</span><span class="s2">, </span><span class="s4">9</span><span class="s2">, </span><span class="s4">9</span><span class="s2">, </span><span class="s4">9</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s2">],  </span><span class="s5"># 9 &lt;=&gt; missing</span>
            <span class="s2">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">5</span><span class="s2">],</span>
            <span class="s0">True</span><span class="s2">,  </span><span class="s5"># missing values</span>
            <span class="s4">6</span><span class="s2">,  </span><span class="s5"># n_bins_non_missing</span>
            <span class="s0">True</span><span class="s2">,  </span><span class="s5"># split on nans</span>
            <span class="s4">5</span><span class="s2">,  </span><span class="s5"># cut on bin_idx=5</span>
            <span class="s0">False</span><span class="s2">,</span>
        <span class="s2">),  </span><span class="s5"># missing values go to right</span>
    <span class="s2">],</span>
<span class="s2">)</span>
<span class="s0">def </span><span class="s1">test_splitting_missing_values</span><span class="s2">(</span>
    <span class="s1">X_binned</span><span class="s2">,</span>
    <span class="s1">all_gradients</span><span class="s2">,</span>
    <span class="s1">has_missing_values</span><span class="s2">,</span>
    <span class="s1">n_bins_non_missing</span><span class="s2">,</span>
    <span class="s1">expected_split_on_nan</span><span class="s2">,</span>
    <span class="s1">expected_bin_idx</span><span class="s2">,</span>
    <span class="s1">expected_go_to_left</span><span class="s2">,</span>
<span class="s2">):</span>
    <span class="s5"># Make sure missing values are properly supported.</span>
    <span class="s5"># we build an artificial example with gradients such that the best split</span>
    <span class="s5"># is on bin_idx=3, when there are no missing values.</span>
    <span class="s5"># Then we introduce missing values and:</span>
    <span class="s5">#   - make sure the chosen bin is correct (find_best_bin()): it's</span>
    <span class="s5">#     still the same split, even though the index of the bin may change</span>
    <span class="s5">#   - make sure the missing values are mapped to the correct child</span>
    <span class="s5">#     (split_indices())</span>

    <span class="s1">n_bins </span><span class="s2">= </span><span class="s1">max</span><span class="s2">(</span><span class="s1">X_binned</span><span class="s2">) + </span><span class="s4">1</span>
    <span class="s1">n_samples </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">X_binned</span><span class="s2">)</span>
    <span class="s1">l2_regularization </span><span class="s2">= </span><span class="s4">0.0</span>
    <span class="s1">min_hessian_to_split </span><span class="s2">= </span><span class="s4">1e-3</span>
    <span class="s1">min_samples_leaf </span><span class="s2">= </span><span class="s4">1</span>
    <span class="s1">min_gain_to_split </span><span class="s2">= </span><span class="s4">0.0</span>

    <span class="s1">sample_indices </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(</span><span class="s1">n_samples</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">uint32</span><span class="s2">)</span>
    <span class="s1">X_binned </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">(</span><span class="s1">X_binned</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">X_BINNED_DTYPE</span><span class="s2">).</span><span class="s1">reshape</span><span class="s2">(-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">)</span>
    <span class="s1">X_binned </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asfortranarray</span><span class="s2">(</span><span class="s1">X_binned</span><span class="s2">)</span>
    <span class="s1">all_gradients </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">(</span><span class="s1">all_gradients</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">G_H_DTYPE</span><span class="s2">)</span>
    <span class="s1">has_missing_values </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s1">has_missing_values</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">uint8</span><span class="s2">)</span>
    <span class="s1">all_hessians </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">G_H_DTYPE</span><span class="s2">)</span>
    <span class="s1">sum_gradients </span><span class="s2">= </span><span class="s1">all_gradients</span><span class="s2">.</span><span class="s1">sum</span><span class="s2">()</span>
    <span class="s1">sum_hessians </span><span class="s2">= </span><span class="s4">1 </span><span class="s2">* </span><span class="s1">n_samples</span>
    <span class="s1">hessians_are_constant </span><span class="s2">= </span><span class="s0">True</span>

    <span class="s1">builder </span><span class="s2">= </span><span class="s1">HistogramBuilder</span><span class="s2">(</span>
        <span class="s1">X_binned</span><span class="s2">, </span><span class="s1">n_bins</span><span class="s2">, </span><span class="s1">all_gradients</span><span class="s2">, </span><span class="s1">all_hessians</span><span class="s2">, </span><span class="s1">hessians_are_constant</span><span class="s2">, </span><span class="s1">n_threads</span>
    <span class="s2">)</span>

    <span class="s1">n_bins_non_missing </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s1">n_bins_non_missing</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">uint32</span><span class="s2">)</span>
    <span class="s1">monotonic_cst </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">(</span>
        <span class="s2">[</span><span class="s1">MonotonicConstraint</span><span class="s2">.</span><span class="s1">NO_CST</span><span class="s2">] * </span><span class="s1">X_binned</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s4">1</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">int8</span>
    <span class="s2">)</span>
    <span class="s1">is_categorical </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros_like</span><span class="s2">(</span><span class="s1">monotonic_cst</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">uint8</span><span class="s2">)</span>
    <span class="s1">missing_values_bin_idx </span><span class="s2">= </span><span class="s1">n_bins </span><span class="s2">- </span><span class="s4">1</span>
    <span class="s1">splitter </span><span class="s2">= </span><span class="s1">Splitter</span><span class="s2">(</span>
        <span class="s1">X_binned</span><span class="s2">,</span>
        <span class="s1">n_bins_non_missing</span><span class="s2">,</span>
        <span class="s1">missing_values_bin_idx</span><span class="s2">,</span>
        <span class="s1">has_missing_values</span><span class="s2">,</span>
        <span class="s1">is_categorical</span><span class="s2">,</span>
        <span class="s1">monotonic_cst</span><span class="s2">,</span>
        <span class="s1">l2_regularization</span><span class="s2">,</span>
        <span class="s1">min_hessian_to_split</span><span class="s2">,</span>
        <span class="s1">min_samples_leaf</span><span class="s2">,</span>
        <span class="s1">min_gain_to_split</span><span class="s2">,</span>
        <span class="s1">hessians_are_constant</span><span class="s2">,</span>
    <span class="s2">)</span>

    <span class="s1">histograms </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">compute_histograms_brute</span><span class="s2">(</span><span class="s1">sample_indices</span><span class="s2">)</span>
    <span class="s1">value </span><span class="s2">= </span><span class="s1">compute_node_value</span><span class="s2">(</span>
        <span class="s1">sum_gradients</span><span class="s2">, </span><span class="s1">sum_hessians</span><span class="s2">, -</span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span><span class="s2">, </span><span class="s1">l2_regularization</span>
    <span class="s2">)</span>
    <span class="s1">split_info </span><span class="s2">= </span><span class="s1">splitter</span><span class="s2">.</span><span class="s1">find_node_split</span><span class="s2">(</span>
        <span class="s1">n_samples</span><span class="s2">, </span><span class="s1">histograms</span><span class="s2">, </span><span class="s1">sum_gradients</span><span class="s2">, </span><span class="s1">sum_hessians</span><span class="s2">, </span><span class="s1">value</span>
    <span class="s2">)</span>

    <span class="s0">assert </span><span class="s1">split_info</span><span class="s2">.</span><span class="s1">bin_idx </span><span class="s2">== </span><span class="s1">expected_bin_idx</span>
    <span class="s0">if </span><span class="s1">has_missing_values</span><span class="s2">:</span>
        <span class="s0">assert </span><span class="s1">split_info</span><span class="s2">.</span><span class="s1">missing_go_to_left </span><span class="s2">== </span><span class="s1">expected_go_to_left</span>

    <span class="s1">split_on_nan </span><span class="s2">= </span><span class="s1">split_info</span><span class="s2">.</span><span class="s1">bin_idx </span><span class="s2">== </span><span class="s1">n_bins_non_missing</span><span class="s2">[</span><span class="s4">0</span><span class="s2">] - </span><span class="s4">1</span>
    <span class="s0">assert </span><span class="s1">split_on_nan </span><span class="s2">== </span><span class="s1">expected_split_on_nan</span>

    <span class="s5"># Make sure the split is properly computed.</span>
    <span class="s5"># This also make sure missing values are properly assigned to the correct</span>
    <span class="s5"># child in split_indices()</span>
    <span class="s1">samples_left</span><span class="s2">, </span><span class="s1">samples_right</span><span class="s2">, </span><span class="s1">_ </span><span class="s2">= </span><span class="s1">splitter</span><span class="s2">.</span><span class="s1">split_indices</span><span class="s2">(</span>
        <span class="s1">split_info</span><span class="s2">, </span><span class="s1">splitter</span><span class="s2">.</span><span class="s1">partition</span>
    <span class="s2">)</span>

    <span class="s0">if not </span><span class="s1">expected_split_on_nan</span><span class="s2">:</span>
        <span class="s5"># When we don't split on nans, the split should always be the same.</span>
        <span class="s0">assert </span><span class="s1">set</span><span class="s2">(</span><span class="s1">samples_left</span><span class="s2">) == </span><span class="s1">set</span><span class="s2">([</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">])</span>
        <span class="s0">assert </span><span class="s1">set</span><span class="s2">(</span><span class="s1">samples_right</span><span class="s2">) == </span><span class="s1">set</span><span class="s2">([</span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">6</span><span class="s2">, </span><span class="s4">7</span><span class="s2">, </span><span class="s4">8</span><span class="s2">, </span><span class="s4">9</span><span class="s2">])</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s5"># When we split on nans, samples with missing values are always mapped</span>
        <span class="s5"># to the right child.</span>
        <span class="s1">missing_samples_indices </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">flatnonzero</span><span class="s2">(</span>
            <span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">(</span><span class="s1">X_binned</span><span class="s2">) == </span><span class="s1">missing_values_bin_idx</span>
        <span class="s2">)</span>
        <span class="s1">non_missing_samples_indices </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">flatnonzero</span><span class="s2">(</span>
            <span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">(</span><span class="s1">X_binned</span><span class="s2">) != </span><span class="s1">missing_values_bin_idx</span>
        <span class="s2">)</span>

        <span class="s0">assert </span><span class="s1">set</span><span class="s2">(</span><span class="s1">samples_right</span><span class="s2">) == </span><span class="s1">set</span><span class="s2">(</span><span class="s1">missing_samples_indices</span><span class="s2">)</span>
        <span class="s0">assert </span><span class="s1">set</span><span class="s2">(</span><span class="s1">samples_left</span><span class="s2">) == </span><span class="s1">set</span><span class="s2">(</span><span class="s1">non_missing_samples_indices</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">parametrize</span><span class="s2">(</span>
    <span class="s3">&quot;X_binned, has_missing_values, n_bins_non_missing, &quot;</span><span class="s2">,</span>
    <span class="s2">[</span>
        <span class="s5"># one category</span>
        <span class="s2">([</span><span class="s4">0</span><span class="s2">] * </span><span class="s4">20</span><span class="s2">, </span><span class="s0">False</span><span class="s2">, </span><span class="s4">1</span><span class="s2">),</span>
        <span class="s5"># all categories appear less than MIN_CAT_SUPPORT (hardcoded to 10)</span>
        <span class="s2">([</span><span class="s4">0</span><span class="s2">] * </span><span class="s4">9 </span><span class="s2">+ [</span><span class="s4">1</span><span class="s2">] * </span><span class="s4">8</span><span class="s2">, </span><span class="s0">False</span><span class="s2">, </span><span class="s4">2</span><span class="s2">),</span>
        <span class="s5"># only one category appears more than MIN_CAT_SUPPORT</span>
        <span class="s2">([</span><span class="s4">0</span><span class="s2">] * </span><span class="s4">12 </span><span class="s2">+ [</span><span class="s4">1</span><span class="s2">] * </span><span class="s4">8</span><span class="s2">, </span><span class="s0">False</span><span class="s2">, </span><span class="s4">2</span><span class="s2">),</span>
        <span class="s5"># missing values + category appear less than MIN_CAT_SUPPORT</span>
        <span class="s5"># 9 is missing</span>
        <span class="s2">([</span><span class="s4">0</span><span class="s2">] * </span><span class="s4">9 </span><span class="s2">+ [</span><span class="s4">1</span><span class="s2">] * </span><span class="s4">8 </span><span class="s2">+ [</span><span class="s4">9</span><span class="s2">] * </span><span class="s4">4</span><span class="s2">, </span><span class="s0">True</span><span class="s2">, </span><span class="s4">2</span><span class="s2">),</span>
        <span class="s5"># no non-missing category</span>
        <span class="s2">([</span><span class="s4">9</span><span class="s2">] * </span><span class="s4">11</span><span class="s2">, </span><span class="s0">True</span><span class="s2">, </span><span class="s4">0</span><span class="s2">),</span>
    <span class="s2">],</span>
<span class="s2">)</span>
<span class="s0">def </span><span class="s1">test_splitting_categorical_cat_smooth</span><span class="s2">(</span>
    <span class="s1">X_binned</span><span class="s2">, </span><span class="s1">has_missing_values</span><span class="s2">, </span><span class="s1">n_bins_non_missing</span>
<span class="s2">):</span>
    <span class="s5"># Checks categorical splits are correct when the MIN_CAT_SUPPORT constraint</span>
    <span class="s5"># isn't respected: there are no splits</span>

    <span class="s1">n_bins </span><span class="s2">= </span><span class="s1">max</span><span class="s2">(</span><span class="s1">X_binned</span><span class="s2">) + </span><span class="s4">1</span>
    <span class="s1">n_samples </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">X_binned</span><span class="s2">)</span>
    <span class="s1">X_binned </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s1">X_binned</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">X_BINNED_DTYPE</span><span class="s2">).</span><span class="s1">T</span>
    <span class="s1">X_binned </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asfortranarray</span><span class="s2">(</span><span class="s1">X_binned</span><span class="s2">)</span>

    <span class="s1">l2_regularization </span><span class="s2">= </span><span class="s4">0.0</span>
    <span class="s1">min_hessian_to_split </span><span class="s2">= </span><span class="s4">1e-3</span>
    <span class="s1">min_samples_leaf </span><span class="s2">= </span><span class="s4">1</span>
    <span class="s1">min_gain_to_split </span><span class="s2">= </span><span class="s4">0.0</span>

    <span class="s1">sample_indices </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(</span><span class="s1">n_samples</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">uint32</span><span class="s2">)</span>
    <span class="s1">all_gradients </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">(</span><span class="s1">n_samples</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">G_H_DTYPE</span><span class="s2">)</span>
    <span class="s1">has_missing_values </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s1">has_missing_values</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">uint8</span><span class="s2">)</span>
    <span class="s1">all_hessians </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">G_H_DTYPE</span><span class="s2">)</span>
    <span class="s1">sum_gradients </span><span class="s2">= </span><span class="s1">all_gradients</span><span class="s2">.</span><span class="s1">sum</span><span class="s2">()</span>
    <span class="s1">sum_hessians </span><span class="s2">= </span><span class="s1">n_samples</span>
    <span class="s1">hessians_are_constant </span><span class="s2">= </span><span class="s0">True</span>

    <span class="s1">builder </span><span class="s2">= </span><span class="s1">HistogramBuilder</span><span class="s2">(</span>
        <span class="s1">X_binned</span><span class="s2">, </span><span class="s1">n_bins</span><span class="s2">, </span><span class="s1">all_gradients</span><span class="s2">, </span><span class="s1">all_hessians</span><span class="s2">, </span><span class="s1">hessians_are_constant</span><span class="s2">, </span><span class="s1">n_threads</span>
    <span class="s2">)</span>

    <span class="s1">n_bins_non_missing </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s1">n_bins_non_missing</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">uint32</span><span class="s2">)</span>
    <span class="s1">monotonic_cst </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">(</span>
        <span class="s2">[</span><span class="s1">MonotonicConstraint</span><span class="s2">.</span><span class="s1">NO_CST</span><span class="s2">] * </span><span class="s1">X_binned</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s4">1</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">int8</span>
    <span class="s2">)</span>
    <span class="s1">is_categorical </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones_like</span><span class="s2">(</span><span class="s1">monotonic_cst</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">uint8</span><span class="s2">)</span>
    <span class="s1">missing_values_bin_idx </span><span class="s2">= </span><span class="s1">n_bins </span><span class="s2">- </span><span class="s4">1</span>

    <span class="s1">splitter </span><span class="s2">= </span><span class="s1">Splitter</span><span class="s2">(</span>
        <span class="s1">X_binned</span><span class="s2">,</span>
        <span class="s1">n_bins_non_missing</span><span class="s2">,</span>
        <span class="s1">missing_values_bin_idx</span><span class="s2">,</span>
        <span class="s1">has_missing_values</span><span class="s2">,</span>
        <span class="s1">is_categorical</span><span class="s2">,</span>
        <span class="s1">monotonic_cst</span><span class="s2">,</span>
        <span class="s1">l2_regularization</span><span class="s2">,</span>
        <span class="s1">min_hessian_to_split</span><span class="s2">,</span>
        <span class="s1">min_samples_leaf</span><span class="s2">,</span>
        <span class="s1">min_gain_to_split</span><span class="s2">,</span>
        <span class="s1">hessians_are_constant</span><span class="s2">,</span>
    <span class="s2">)</span>

    <span class="s1">histograms </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">compute_histograms_brute</span><span class="s2">(</span><span class="s1">sample_indices</span><span class="s2">)</span>
    <span class="s1">value </span><span class="s2">= </span><span class="s1">compute_node_value</span><span class="s2">(</span>
        <span class="s1">sum_gradients</span><span class="s2">, </span><span class="s1">sum_hessians</span><span class="s2">, -</span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span><span class="s2">, </span><span class="s1">l2_regularization</span>
    <span class="s2">)</span>
    <span class="s1">split_info </span><span class="s2">= </span><span class="s1">splitter</span><span class="s2">.</span><span class="s1">find_node_split</span><span class="s2">(</span>
        <span class="s1">n_samples</span><span class="s2">, </span><span class="s1">histograms</span><span class="s2">, </span><span class="s1">sum_gradients</span><span class="s2">, </span><span class="s1">sum_hessians</span><span class="s2">, </span><span class="s1">value</span>
    <span class="s2">)</span>

    <span class="s5"># no split found</span>
    <span class="s0">assert </span><span class="s1">split_info</span><span class="s2">.</span><span class="s1">gain </span><span class="s2">== -</span><span class="s4">1</span>


<span class="s0">def </span><span class="s1">_assert_categories_equals_bitset</span><span class="s2">(</span><span class="s1">categories</span><span class="s2">, </span><span class="s1">bitset</span><span class="s2">):</span>
    <span class="s5"># assert that the bitset exactly corresponds to the categories</span>
    <span class="s5"># bitset is assumed to be an array of 8 uint32 elements</span>

    <span class="s5"># form bitset from threshold</span>
    <span class="s1">expected_bitset </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">(</span><span class="s4">8</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">uint32</span><span class="s2">)</span>
    <span class="s0">for </span><span class="s1">cat </span><span class="s0">in </span><span class="s1">categories</span><span class="s2">:</span>
        <span class="s1">idx </span><span class="s2">= </span><span class="s1">cat </span><span class="s2">// </span><span class="s4">32</span>
        <span class="s1">shift </span><span class="s2">= </span><span class="s1">cat </span><span class="s2">% </span><span class="s4">32</span>
        <span class="s1">expected_bitset</span><span class="s2">[</span><span class="s1">idx</span><span class="s2">] |= </span><span class="s4">1 </span><span class="s2">&lt;&lt; </span><span class="s1">shift</span>

    <span class="s5"># check for equality</span>
    <span class="s1">assert_array_equal</span><span class="s2">(</span><span class="s1">expected_bitset</span><span class="s2">, </span><span class="s1">bitset</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">parametrize</span><span class="s2">(</span>
    <span class="s2">(</span>
        <span class="s3">&quot;X_binned, all_gradients, expected_categories_left, n_bins_non_missing,&quot;</span>
        <span class="s3">&quot;missing_values_bin_idx, has_missing_values, expected_missing_go_to_left&quot;</span>
    <span class="s2">),</span>
    <span class="s2">[</span>
        <span class="s5"># 4 categories</span>
        <span class="s2">(</span>
            <span class="s2">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">] * </span><span class="s4">11</span><span class="s2">,  </span><span class="s5"># X_binned</span>
            <span class="s2">[</span><span class="s4">10</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">10</span><span class="s2">] * </span><span class="s4">11</span><span class="s2">,  </span><span class="s5"># all_gradients</span>
            <span class="s2">[</span><span class="s4">1</span><span class="s2">],  </span><span class="s5"># expected_categories_left</span>
            <span class="s4">4</span><span class="s2">,  </span><span class="s5"># n_bins_non_missing</span>
            <span class="s4">4</span><span class="s2">,  </span><span class="s5"># missing_values_bin_idx</span>
            <span class="s0">False</span><span class="s2">,  </span><span class="s5"># has_missing_values</span>
            <span class="s0">None</span><span class="s2">,</span>
        <span class="s2">),  </span><span class="s5"># expected_missing_go_to_left, unchecked</span>
        <span class="s5"># Make sure that the categories that are on the right (second half) of</span>
        <span class="s5"># the sorted categories array can still go in the left child. In this</span>
        <span class="s5"># case, the best split was found when scanning from right to left.</span>
        <span class="s2">(</span>
            <span class="s2">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">] * </span><span class="s4">11</span><span class="s2">,  </span><span class="s5"># X_binned</span>
            <span class="s2">[</span><span class="s4">10</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">1</span><span class="s2">] * </span><span class="s4">11</span><span class="s2">,  </span><span class="s5"># all_gradients</span>
            <span class="s2">[</span><span class="s4">3</span><span class="s2">],  </span><span class="s5"># expected_categories_left</span>
            <span class="s4">4</span><span class="s2">,  </span><span class="s5"># n_bins_non_missing</span>
            <span class="s4">4</span><span class="s2">,  </span><span class="s5"># missing_values_bin_idx</span>
            <span class="s0">False</span><span class="s2">,  </span><span class="s5"># has_missing_values</span>
            <span class="s0">None</span><span class="s2">,</span>
        <span class="s2">),  </span><span class="s5"># expected_missing_go_to_left, unchecked</span>
        <span class="s5"># categories that don't respect MIN_CAT_SUPPORT (cat 4) are always</span>
        <span class="s5"># mapped to the right child</span>
        <span class="s2">(</span>
            <span class="s2">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">] * </span><span class="s4">11 </span><span class="s2">+ [</span><span class="s4">4</span><span class="s2">] * </span><span class="s4">5</span><span class="s2">,  </span><span class="s5"># X_binned</span>
            <span class="s2">[</span><span class="s4">10</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">1</span><span class="s2">] * </span><span class="s4">11 </span><span class="s2">+ [</span><span class="s4">10</span><span class="s2">] * </span><span class="s4">5</span><span class="s2">,  </span><span class="s5"># all_gradients</span>
            <span class="s2">[</span><span class="s4">3</span><span class="s2">],  </span><span class="s5"># expected_categories_left</span>
            <span class="s4">4</span><span class="s2">,  </span><span class="s5"># n_bins_non_missing</span>
            <span class="s4">4</span><span class="s2">,  </span><span class="s5"># missing_values_bin_idx</span>
            <span class="s0">False</span><span class="s2">,  </span><span class="s5"># has_missing_values</span>
            <span class="s0">None</span><span class="s2">,</span>
        <span class="s2">),  </span><span class="s5"># expected_missing_go_to_left, unchecked</span>
        <span class="s5"># categories that don't respect MIN_CAT_SUPPORT are always mapped to</span>
        <span class="s5"># the right child: in this case a more sensible split could have been</span>
        <span class="s5"># 3, 4 - 0, 1, 2</span>
        <span class="s5"># But the split is still 3 - 0, 1, 2, 4. this is because we only scan</span>
        <span class="s5"># up to the middle of the sorted category array (0, 1, 2, 3), and</span>
        <span class="s5"># because we exclude cat 4 in this array.</span>
        <span class="s2">(</span>
            <span class="s2">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">] * </span><span class="s4">11 </span><span class="s2">+ [</span><span class="s4">4</span><span class="s2">] * </span><span class="s4">5</span><span class="s2">,  </span><span class="s5"># X_binned</span>
            <span class="s2">[</span><span class="s4">10</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">1</span><span class="s2">] * </span><span class="s4">11 </span><span class="s2">+ [</span><span class="s4">1</span><span class="s2">] * </span><span class="s4">5</span><span class="s2">,  </span><span class="s5"># all_gradients</span>
            <span class="s2">[</span><span class="s4">3</span><span class="s2">],  </span><span class="s5"># expected_categories_left</span>
            <span class="s4">4</span><span class="s2">,  </span><span class="s5"># n_bins_non_missing</span>
            <span class="s4">4</span><span class="s2">,  </span><span class="s5"># missing_values_bin_idx</span>
            <span class="s0">False</span><span class="s2">,  </span><span class="s5"># has_missing_values</span>
            <span class="s0">None</span><span class="s2">,</span>
        <span class="s2">),  </span><span class="s5"># expected_missing_go_to_left, unchecked</span>
        <span class="s5"># 4 categories with missing values that go to the right</span>
        <span class="s2">(</span>
            <span class="s2">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">] * </span><span class="s4">11 </span><span class="s2">+ [</span><span class="s4">9</span><span class="s2">] * </span><span class="s4">11</span><span class="s2">,  </span><span class="s5"># X_binned</span>
            <span class="s2">[</span><span class="s4">10</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">10</span><span class="s2">] * </span><span class="s4">11 </span><span class="s2">+ [</span><span class="s4">10</span><span class="s2">] * </span><span class="s4">11</span><span class="s2">,  </span><span class="s5"># all_gradients</span>
            <span class="s2">[</span><span class="s4">1</span><span class="s2">],  </span><span class="s5"># expected_categories_left</span>
            <span class="s4">3</span><span class="s2">,  </span><span class="s5"># n_bins_non_missing</span>
            <span class="s4">9</span><span class="s2">,  </span><span class="s5"># missing_values_bin_idx</span>
            <span class="s0">True</span><span class="s2">,  </span><span class="s5"># has_missing_values</span>
            <span class="s0">False</span><span class="s2">,</span>
        <span class="s2">),  </span><span class="s5"># expected_missing_go_to_left</span>
        <span class="s5"># 4 categories with missing values that go to the left</span>
        <span class="s2">(</span>
            <span class="s2">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">] * </span><span class="s4">11 </span><span class="s2">+ [</span><span class="s4">9</span><span class="s2">] * </span><span class="s4">11</span><span class="s2">,  </span><span class="s5"># X_binned</span>
            <span class="s2">[</span><span class="s4">10</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">10</span><span class="s2">] * </span><span class="s4">11 </span><span class="s2">+ [</span><span class="s4">1</span><span class="s2">] * </span><span class="s4">11</span><span class="s2">,  </span><span class="s5"># all_gradients</span>
            <span class="s2">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">9</span><span class="s2">],  </span><span class="s5"># expected_categories_left</span>
            <span class="s4">3</span><span class="s2">,  </span><span class="s5"># n_bins_non_missing</span>
            <span class="s4">9</span><span class="s2">,  </span><span class="s5"># missing_values_bin_idx</span>
            <span class="s0">True</span><span class="s2">,  </span><span class="s5"># has_missing_values</span>
            <span class="s0">True</span><span class="s2">,</span>
        <span class="s2">),  </span><span class="s5"># expected_missing_go_to_left</span>
        <span class="s5"># split is on the missing value</span>
        <span class="s2">(</span>
            <span class="s2">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s2">] * </span><span class="s4">11 </span><span class="s2">+ [</span><span class="s4">255</span><span class="s2">] * </span><span class="s4">12</span><span class="s2">,  </span><span class="s5"># X_binned</span>
            <span class="s2">[</span><span class="s4">10</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">10</span><span class="s2">] * </span><span class="s4">11 </span><span class="s2">+ [</span><span class="s4">1</span><span class="s2">] * </span><span class="s4">12</span><span class="s2">,  </span><span class="s5"># all_gradients</span>
            <span class="s2">[</span><span class="s4">255</span><span class="s2">],  </span><span class="s5"># expected_categories_left</span>
            <span class="s4">5</span><span class="s2">,  </span><span class="s5"># n_bins_non_missing</span>
            <span class="s4">255</span><span class="s2">,  </span><span class="s5"># missing_values_bin_idx</span>
            <span class="s0">True</span><span class="s2">,  </span><span class="s5"># has_missing_values</span>
            <span class="s0">True</span><span class="s2">,</span>
        <span class="s2">),  </span><span class="s5"># expected_missing_go_to_left</span>
        <span class="s5"># split on even categories</span>
        <span class="s2">(</span>
            <span class="s1">list</span><span class="s2">(</span><span class="s1">range</span><span class="s2">(</span><span class="s4">60</span><span class="s2">)) * </span><span class="s4">12</span><span class="s2">,  </span><span class="s5"># X_binned</span>
            <span class="s2">[</span><span class="s4">10</span><span class="s2">, </span><span class="s4">1</span><span class="s2">] * </span><span class="s4">360</span><span class="s2">,  </span><span class="s5"># all_gradients</span>
            <span class="s1">list</span><span class="s2">(</span><span class="s1">range</span><span class="s2">(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">60</span><span class="s2">, </span><span class="s4">2</span><span class="s2">)),  </span><span class="s5"># expected_categories_left</span>
            <span class="s4">59</span><span class="s2">,  </span><span class="s5"># n_bins_non_missing</span>
            <span class="s4">59</span><span class="s2">,  </span><span class="s5"># missing_values_bin_idx</span>
            <span class="s0">True</span><span class="s2">,  </span><span class="s5"># has_missing_values</span>
            <span class="s0">True</span><span class="s2">,</span>
        <span class="s2">),  </span><span class="s5"># expected_missing_go_to_left</span>
        <span class="s5"># split on every 8 categories</span>
        <span class="s2">(</span>
            <span class="s1">list</span><span class="s2">(</span><span class="s1">range</span><span class="s2">(</span><span class="s4">256</span><span class="s2">)) * </span><span class="s4">12</span><span class="s2">,  </span><span class="s5"># X_binned</span>
            <span class="s2">[</span><span class="s4">10</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">1</span><span class="s2">] * </span><span class="s4">384</span><span class="s2">,  </span><span class="s5"># all_gradients</span>
            <span class="s1">list</span><span class="s2">(</span><span class="s1">range</span><span class="s2">(</span><span class="s4">7</span><span class="s2">, </span><span class="s4">256</span><span class="s2">, </span><span class="s4">8</span><span class="s2">)),  </span><span class="s5"># expected_categories_left</span>
            <span class="s4">255</span><span class="s2">,  </span><span class="s5"># n_bins_non_missing</span>
            <span class="s4">255</span><span class="s2">,  </span><span class="s5"># missing_values_bin_idx</span>
            <span class="s0">True</span><span class="s2">,  </span><span class="s5"># has_missing_values</span>
            <span class="s0">True</span><span class="s2">,</span>
        <span class="s2">),  </span><span class="s5"># expected_missing_go_to_left</span>
    <span class="s2">],</span>
<span class="s2">)</span>
<span class="s0">def </span><span class="s1">test_splitting_categorical_sanity</span><span class="s2">(</span>
    <span class="s1">X_binned</span><span class="s2">,</span>
    <span class="s1">all_gradients</span><span class="s2">,</span>
    <span class="s1">expected_categories_left</span><span class="s2">,</span>
    <span class="s1">n_bins_non_missing</span><span class="s2">,</span>
    <span class="s1">missing_values_bin_idx</span><span class="s2">,</span>
    <span class="s1">has_missing_values</span><span class="s2">,</span>
    <span class="s1">expected_missing_go_to_left</span><span class="s2">,</span>
<span class="s2">):</span>
    <span class="s5"># Tests various combinations of categorical splits</span>

    <span class="s1">n_samples </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">X_binned</span><span class="s2">)</span>
    <span class="s1">n_bins </span><span class="s2">= </span><span class="s1">max</span><span class="s2">(</span><span class="s1">X_binned</span><span class="s2">) + </span><span class="s4">1</span>

    <span class="s1">X_binned </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">(</span><span class="s1">X_binned</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">X_BINNED_DTYPE</span><span class="s2">).</span><span class="s1">reshape</span><span class="s2">(-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">)</span>
    <span class="s1">X_binned </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asfortranarray</span><span class="s2">(</span><span class="s1">X_binned</span><span class="s2">)</span>

    <span class="s1">l2_regularization </span><span class="s2">= </span><span class="s4">0.0</span>
    <span class="s1">min_hessian_to_split </span><span class="s2">= </span><span class="s4">1e-3</span>
    <span class="s1">min_samples_leaf </span><span class="s2">= </span><span class="s4">1</span>
    <span class="s1">min_gain_to_split </span><span class="s2">= </span><span class="s4">0.0</span>

    <span class="s1">sample_indices </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(</span><span class="s1">n_samples</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">uint32</span><span class="s2">)</span>
    <span class="s1">all_gradients </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">(</span><span class="s1">all_gradients</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">G_H_DTYPE</span><span class="s2">)</span>
    <span class="s1">all_hessians </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">G_H_DTYPE</span><span class="s2">)</span>
    <span class="s1">has_missing_values </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s1">has_missing_values</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">uint8</span><span class="s2">)</span>
    <span class="s1">sum_gradients </span><span class="s2">= </span><span class="s1">all_gradients</span><span class="s2">.</span><span class="s1">sum</span><span class="s2">()</span>
    <span class="s1">sum_hessians </span><span class="s2">= </span><span class="s1">n_samples</span>
    <span class="s1">hessians_are_constant </span><span class="s2">= </span><span class="s0">True</span>

    <span class="s1">builder </span><span class="s2">= </span><span class="s1">HistogramBuilder</span><span class="s2">(</span>
        <span class="s1">X_binned</span><span class="s2">, </span><span class="s1">n_bins</span><span class="s2">, </span><span class="s1">all_gradients</span><span class="s2">, </span><span class="s1">all_hessians</span><span class="s2">, </span><span class="s1">hessians_are_constant</span><span class="s2">, </span><span class="s1">n_threads</span>
    <span class="s2">)</span>

    <span class="s1">n_bins_non_missing </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s1">n_bins_non_missing</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">uint32</span><span class="s2">)</span>
    <span class="s1">monotonic_cst </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">(</span>
        <span class="s2">[</span><span class="s1">MonotonicConstraint</span><span class="s2">.</span><span class="s1">NO_CST</span><span class="s2">] * </span><span class="s1">X_binned</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s4">1</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">int8</span>
    <span class="s2">)</span>
    <span class="s1">is_categorical </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones_like</span><span class="s2">(</span><span class="s1">monotonic_cst</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">uint8</span><span class="s2">)</span>

    <span class="s1">splitter </span><span class="s2">= </span><span class="s1">Splitter</span><span class="s2">(</span>
        <span class="s1">X_binned</span><span class="s2">,</span>
        <span class="s1">n_bins_non_missing</span><span class="s2">,</span>
        <span class="s1">missing_values_bin_idx</span><span class="s2">,</span>
        <span class="s1">has_missing_values</span><span class="s2">,</span>
        <span class="s1">is_categorical</span><span class="s2">,</span>
        <span class="s1">monotonic_cst</span><span class="s2">,</span>
        <span class="s1">l2_regularization</span><span class="s2">,</span>
        <span class="s1">min_hessian_to_split</span><span class="s2">,</span>
        <span class="s1">min_samples_leaf</span><span class="s2">,</span>
        <span class="s1">min_gain_to_split</span><span class="s2">,</span>
        <span class="s1">hessians_are_constant</span><span class="s2">,</span>
    <span class="s2">)</span>

    <span class="s1">histograms </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">compute_histograms_brute</span><span class="s2">(</span><span class="s1">sample_indices</span><span class="s2">)</span>

    <span class="s1">value </span><span class="s2">= </span><span class="s1">compute_node_value</span><span class="s2">(</span>
        <span class="s1">sum_gradients</span><span class="s2">, </span><span class="s1">sum_hessians</span><span class="s2">, -</span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span><span class="s2">, </span><span class="s1">l2_regularization</span>
    <span class="s2">)</span>
    <span class="s1">split_info </span><span class="s2">= </span><span class="s1">splitter</span><span class="s2">.</span><span class="s1">find_node_split</span><span class="s2">(</span>
        <span class="s1">n_samples</span><span class="s2">, </span><span class="s1">histograms</span><span class="s2">, </span><span class="s1">sum_gradients</span><span class="s2">, </span><span class="s1">sum_hessians</span><span class="s2">, </span><span class="s1">value</span>
    <span class="s2">)</span>

    <span class="s0">assert </span><span class="s1">split_info</span><span class="s2">.</span><span class="s1">is_categorical</span>
    <span class="s0">assert </span><span class="s1">split_info</span><span class="s2">.</span><span class="s1">gain </span><span class="s2">&gt; </span><span class="s4">0</span>
    <span class="s1">_assert_categories_equals_bitset</span><span class="s2">(</span>
        <span class="s1">expected_categories_left</span><span class="s2">, </span><span class="s1">split_info</span><span class="s2">.</span><span class="s1">left_cat_bitset</span>
    <span class="s2">)</span>
    <span class="s0">if </span><span class="s1">has_missing_values</span><span class="s2">:</span>
        <span class="s0">assert </span><span class="s1">split_info</span><span class="s2">.</span><span class="s1">missing_go_to_left </span><span class="s2">== </span><span class="s1">expected_missing_go_to_left</span>
    <span class="s5"># If there is no missing value during training, the flag missing_go_to_left</span>
    <span class="s5"># is set later in the grower.</span>

    <span class="s5"># make sure samples are split correctly</span>
    <span class="s1">samples_left</span><span class="s2">, </span><span class="s1">samples_right</span><span class="s2">, </span><span class="s1">_ </span><span class="s2">= </span><span class="s1">splitter</span><span class="s2">.</span><span class="s1">split_indices</span><span class="s2">(</span>
        <span class="s1">split_info</span><span class="s2">, </span><span class="s1">splitter</span><span class="s2">.</span><span class="s1">partition</span>
    <span class="s2">)</span>

    <span class="s1">left_mask </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isin</span><span class="s2">(</span><span class="s1">X_binned</span><span class="s2">.</span><span class="s1">ravel</span><span class="s2">(), </span><span class="s1">expected_categories_left</span><span class="s2">)</span>
    <span class="s1">assert_array_equal</span><span class="s2">(</span><span class="s1">sample_indices</span><span class="s2">[</span><span class="s1">left_mask</span><span class="s2">], </span><span class="s1">samples_left</span><span class="s2">)</span>
    <span class="s1">assert_array_equal</span><span class="s2">(</span><span class="s1">sample_indices</span><span class="s2">[~</span><span class="s1">left_mask</span><span class="s2">], </span><span class="s1">samples_right</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">test_split_interaction_constraints</span><span class="s2">():</span>
    <span class="s6">&quot;&quot;&quot;Check that allowed_features are respected.&quot;&quot;&quot;</span>
    <span class="s1">n_features </span><span class="s2">= </span><span class="s4">4</span>
    <span class="s5"># features 1 and 2 are not allowed to be split on</span>
    <span class="s1">allowed_features </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s4">0</span><span class="s2">, </span><span class="s4">3</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">uint32</span><span class="s2">)</span>
    <span class="s1">n_bins </span><span class="s2">= </span><span class="s4">5</span>
    <span class="s1">n_samples </span><span class="s2">= </span><span class="s4">10</span>
    <span class="s1">l2_regularization </span><span class="s2">= </span><span class="s4">0.0</span>
    <span class="s1">min_hessian_to_split </span><span class="s2">= </span><span class="s4">1e-3</span>
    <span class="s1">min_samples_leaf </span><span class="s2">= </span><span class="s4">1</span>
    <span class="s1">min_gain_to_split </span><span class="s2">= </span><span class="s4">0.0</span>

    <span class="s1">sample_indices </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(</span><span class="s1">n_samples</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">uint32</span><span class="s2">)</span>
    <span class="s1">all_hessians </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">G_H_DTYPE</span><span class="s2">)</span>
    <span class="s1">sum_hessians </span><span class="s2">= </span><span class="s1">n_samples</span>
    <span class="s1">hessians_are_constant </span><span class="s2">= </span><span class="s0">True</span>

    <span class="s1">split_features </span><span class="s2">= []</span>

    <span class="s5"># The loop is to ensure that we split at least once on each allowed feature (0, 3).</span>
    <span class="s5"># This is tracked by split_features and checked at the end.</span>
    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s4">10</span><span class="s2">):</span>
        <span class="s1">rng </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">random</span><span class="s2">.</span><span class="s1">RandomState</span><span class="s2">(</span><span class="s4">919 </span><span class="s2">+ </span><span class="s1">i</span><span class="s2">)</span>
        <span class="s1">X_binned </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asfortranarray</span><span class="s2">(</span>
            <span class="s1">rng</span><span class="s2">.</span><span class="s1">randint</span><span class="s2">(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">n_bins </span><span class="s2">- </span><span class="s4">1</span><span class="s2">, </span><span class="s1">size</span><span class="s2">=(</span><span class="s1">n_samples</span><span class="s2">, </span><span class="s1">n_features</span><span class="s2">)),</span>
            <span class="s1">dtype</span><span class="s2">=</span><span class="s1">X_BINNED_DTYPE</span><span class="s2">,</span>
        <span class="s2">)</span>
        <span class="s1">X_binned </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asfortranarray</span><span class="s2">(</span><span class="s1">X_binned</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">X_BINNED_DTYPE</span><span class="s2">)</span>

        <span class="s5"># Make feature 1 very important</span>
        <span class="s1">all_gradients </span><span class="s2">= (</span><span class="s4">10 </span><span class="s2">* </span><span class="s1">X_binned</span><span class="s2">[:, </span><span class="s4">1</span><span class="s2">] + </span><span class="s1">rng</span><span class="s2">.</span><span class="s1">randn</span><span class="s2">(</span><span class="s1">n_samples</span><span class="s2">)).</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">G_H_DTYPE</span><span class="s2">)</span>
        <span class="s1">sum_gradients </span><span class="s2">= </span><span class="s1">all_gradients</span><span class="s2">.</span><span class="s1">sum</span><span class="s2">()</span>

        <span class="s1">builder </span><span class="s2">= </span><span class="s1">HistogramBuilder</span><span class="s2">(</span>
            <span class="s1">X_binned</span><span class="s2">,</span>
            <span class="s1">n_bins</span><span class="s2">,</span>
            <span class="s1">all_gradients</span><span class="s2">,</span>
            <span class="s1">all_hessians</span><span class="s2">,</span>
            <span class="s1">hessians_are_constant</span><span class="s2">,</span>
            <span class="s1">n_threads</span><span class="s2">,</span>
        <span class="s2">)</span>
        <span class="s1">n_bins_non_missing </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s1">n_bins</span><span class="s2">] * </span><span class="s1">X_binned</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s4">1</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">uint32</span><span class="s2">)</span>
        <span class="s1">has_missing_values </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s0">False</span><span class="s2">] * </span><span class="s1">X_binned</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s4">1</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">uint8</span><span class="s2">)</span>
        <span class="s1">monotonic_cst </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">(</span>
            <span class="s2">[</span><span class="s1">MonotonicConstraint</span><span class="s2">.</span><span class="s1">NO_CST</span><span class="s2">] * </span><span class="s1">X_binned</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s4">1</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">int8</span>
        <span class="s2">)</span>
        <span class="s1">is_categorical </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros_like</span><span class="s2">(</span><span class="s1">monotonic_cst</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">uint8</span><span class="s2">)</span>
        <span class="s1">missing_values_bin_idx </span><span class="s2">= </span><span class="s1">n_bins </span><span class="s2">- </span><span class="s4">1</span>
        <span class="s1">splitter </span><span class="s2">= </span><span class="s1">Splitter</span><span class="s2">(</span>
            <span class="s1">X_binned</span><span class="s2">,</span>
            <span class="s1">n_bins_non_missing</span><span class="s2">,</span>
            <span class="s1">missing_values_bin_idx</span><span class="s2">,</span>
            <span class="s1">has_missing_values</span><span class="s2">,</span>
            <span class="s1">is_categorical</span><span class="s2">,</span>
            <span class="s1">monotonic_cst</span><span class="s2">,</span>
            <span class="s1">l2_regularization</span><span class="s2">,</span>
            <span class="s1">min_hessian_to_split</span><span class="s2">,</span>
            <span class="s1">min_samples_leaf</span><span class="s2">,</span>
            <span class="s1">min_gain_to_split</span><span class="s2">,</span>
            <span class="s1">hessians_are_constant</span><span class="s2">,</span>
        <span class="s2">)</span>

        <span class="s0">assert </span><span class="s1">np</span><span class="s2">.</span><span class="s1">all</span><span class="s2">(</span><span class="s1">sample_indices </span><span class="s2">== </span><span class="s1">splitter</span><span class="s2">.</span><span class="s1">partition</span><span class="s2">)</span>

        <span class="s1">histograms </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">compute_histograms_brute</span><span class="s2">(</span><span class="s1">sample_indices</span><span class="s2">)</span>
        <span class="s1">value </span><span class="s2">= </span><span class="s1">compute_node_value</span><span class="s2">(</span>
            <span class="s1">sum_gradients</span><span class="s2">, </span><span class="s1">sum_hessians</span><span class="s2">, -</span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span><span class="s2">, </span><span class="s1">l2_regularization</span>
        <span class="s2">)</span>

        <span class="s5"># with all features allowed, feature 1 should be split on as it is the most</span>
        <span class="s5"># important one by construction of the gradients</span>
        <span class="s1">si_root </span><span class="s2">= </span><span class="s1">splitter</span><span class="s2">.</span><span class="s1">find_node_split</span><span class="s2">(</span>
            <span class="s1">n_samples</span><span class="s2">,</span>
            <span class="s1">histograms</span><span class="s2">,</span>
            <span class="s1">sum_gradients</span><span class="s2">,</span>
            <span class="s1">sum_hessians</span><span class="s2">,</span>
            <span class="s1">value</span><span class="s2">,</span>
            <span class="s1">allowed_features</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s2">)</span>
        <span class="s0">assert </span><span class="s1">si_root</span><span class="s2">.</span><span class="s1">feature_idx </span><span class="s2">== </span><span class="s4">1</span>

        <span class="s5"># only features 0 and 3 are allowed to be split on</span>
        <span class="s1">si_root </span><span class="s2">= </span><span class="s1">splitter</span><span class="s2">.</span><span class="s1">find_node_split</span><span class="s2">(</span>
            <span class="s1">n_samples</span><span class="s2">,</span>
            <span class="s1">histograms</span><span class="s2">,</span>
            <span class="s1">sum_gradients</span><span class="s2">,</span>
            <span class="s1">sum_hessians</span><span class="s2">,</span>
            <span class="s1">value</span><span class="s2">,</span>
            <span class="s1">allowed_features</span><span class="s2">=</span><span class="s1">allowed_features</span><span class="s2">,</span>
        <span class="s2">)</span>
        <span class="s1">split_features</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">si_root</span><span class="s2">.</span><span class="s1">feature_idx</span><span class="s2">)</span>
        <span class="s0">assert </span><span class="s1">si_root</span><span class="s2">.</span><span class="s1">feature_idx </span><span class="s0">in </span><span class="s1">allowed_features</span>

    <span class="s5"># make sure feature 0 and feature 3 are split on in the constraint setting</span>
    <span class="s0">assert </span><span class="s1">set</span><span class="s2">(</span><span class="s1">allowed_features</span><span class="s2">) == </span><span class="s1">set</span><span class="s2">(</span><span class="s1">split_features</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">parametrize</span><span class="s2">(</span><span class="s3">&quot;forbidden_features&quot;</span><span class="s2">, [</span><span class="s1">set</span><span class="s2">(), {</span><span class="s4">1</span><span class="s2">, </span><span class="s4">3</span><span class="s2">}])</span>
<span class="s0">def </span><span class="s1">test_split_feature_fraction_per_split</span><span class="s2">(</span><span class="s1">forbidden_features</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot;Check that feature_fraction_per_split is respected. 
 
    Because we set `n_features = 4` and `feature_fraction_per_split = 0.25`, it means 
    that calling `splitter.find_node_split` will be allowed to select a split for a 
    single completely random feature at each call. So if we iterate enough, we should 
    cover all the allowed features, irrespective of the values of the gradients and 
    Hessians of the objective. 
    &quot;&quot;&quot;</span>
    <span class="s1">n_features </span><span class="s2">= </span><span class="s4">4</span>
    <span class="s1">allowed_features </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">(</span>
        <span class="s1">list</span><span class="s2">(</span><span class="s1">set</span><span class="s2">(</span><span class="s1">range</span><span class="s2">(</span><span class="s1">n_features</span><span class="s2">)) - </span><span class="s1">forbidden_features</span><span class="s2">), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">uint32</span>
    <span class="s2">)</span>
    <span class="s1">n_bins </span><span class="s2">= </span><span class="s4">5</span>
    <span class="s1">n_samples </span><span class="s2">= </span><span class="s4">40</span>
    <span class="s1">l2_regularization </span><span class="s2">= </span><span class="s4">0.0</span>
    <span class="s1">min_hessian_to_split </span><span class="s2">= </span><span class="s4">1e-3</span>
    <span class="s1">min_samples_leaf </span><span class="s2">= </span><span class="s4">1</span>
    <span class="s1">min_gain_to_split </span><span class="s2">= </span><span class="s4">0.0</span>
    <span class="s1">rng </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">random</span><span class="s2">.</span><span class="s1">default_rng</span><span class="s2">(</span><span class="s4">42</span><span class="s2">)</span>

    <span class="s1">sample_indices </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(</span><span class="s1">n_samples</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">uint32</span><span class="s2">)</span>
    <span class="s1">all_gradients </span><span class="s2">= </span><span class="s1">rng</span><span class="s2">.</span><span class="s1">uniform</span><span class="s2">(</span><span class="s1">low</span><span class="s2">=</span><span class="s4">0.5</span><span class="s2">, </span><span class="s1">high</span><span class="s2">=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">size</span><span class="s2">=</span><span class="s1">n_samples</span><span class="s2">).</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">G_H_DTYPE</span><span class="s2">)</span>
    <span class="s1">sum_gradients </span><span class="s2">= </span><span class="s1">all_gradients</span><span class="s2">.</span><span class="s1">sum</span><span class="s2">()</span>
    <span class="s1">all_hessians </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">G_H_DTYPE</span><span class="s2">)</span>
    <span class="s1">sum_hessians </span><span class="s2">= </span><span class="s1">n_samples</span>
    <span class="s1">hessians_are_constant </span><span class="s2">= </span><span class="s0">True</span>

    <span class="s1">X_binned </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asfortranarray</span><span class="s2">(</span>
        <span class="s1">rng</span><span class="s2">.</span><span class="s1">integers</span><span class="s2">(</span><span class="s1">low</span><span class="s2">=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">high</span><span class="s2">=</span><span class="s1">n_bins </span><span class="s2">- </span><span class="s4">1</span><span class="s2">, </span><span class="s1">size</span><span class="s2">=(</span><span class="s1">n_samples</span><span class="s2">, </span><span class="s1">n_features</span><span class="s2">)),</span>
        <span class="s1">dtype</span><span class="s2">=</span><span class="s1">X_BINNED_DTYPE</span><span class="s2">,</span>
    <span class="s2">)</span>
    <span class="s1">X_binned </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asfortranarray</span><span class="s2">(</span><span class="s1">X_binned</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">X_BINNED_DTYPE</span><span class="s2">)</span>
    <span class="s1">builder </span><span class="s2">= </span><span class="s1">HistogramBuilder</span><span class="s2">(</span>
        <span class="s1">X_binned</span><span class="s2">,</span>
        <span class="s1">n_bins</span><span class="s2">,</span>
        <span class="s1">all_gradients</span><span class="s2">,</span>
        <span class="s1">all_hessians</span><span class="s2">,</span>
        <span class="s1">hessians_are_constant</span><span class="s2">,</span>
        <span class="s1">n_threads</span><span class="s2">,</span>
    <span class="s2">)</span>
    <span class="s1">histograms </span><span class="s2">= </span><span class="s1">builder</span><span class="s2">.</span><span class="s1">compute_histograms_brute</span><span class="s2">(</span><span class="s1">sample_indices</span><span class="s2">)</span>
    <span class="s1">value </span><span class="s2">= </span><span class="s1">compute_node_value</span><span class="s2">(</span>
        <span class="s1">sum_gradients</span><span class="s2">, </span><span class="s1">sum_hessians</span><span class="s2">, -</span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span><span class="s2">, </span><span class="s1">l2_regularization</span>
    <span class="s2">)</span>
    <span class="s1">n_bins_non_missing </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s1">n_bins</span><span class="s2">] * </span><span class="s1">X_binned</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s4">1</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">uint32</span><span class="s2">)</span>
    <span class="s1">has_missing_values </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s0">False</span><span class="s2">] * </span><span class="s1">X_binned</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s4">1</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">uint8</span><span class="s2">)</span>
    <span class="s1">monotonic_cst </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">(</span>
        <span class="s2">[</span><span class="s1">MonotonicConstraint</span><span class="s2">.</span><span class="s1">NO_CST</span><span class="s2">] * </span><span class="s1">X_binned</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s4">1</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">int8</span>
    <span class="s2">)</span>
    <span class="s1">is_categorical </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros_like</span><span class="s2">(</span><span class="s1">monotonic_cst</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">uint8</span><span class="s2">)</span>
    <span class="s1">missing_values_bin_idx </span><span class="s2">= </span><span class="s1">n_bins </span><span class="s2">- </span><span class="s4">1</span>

    <span class="s1">params </span><span class="s2">= </span><span class="s1">dict</span><span class="s2">(</span>
        <span class="s1">X_binned</span><span class="s2">=</span><span class="s1">X_binned</span><span class="s2">,</span>
        <span class="s1">n_bins_non_missing</span><span class="s2">=</span><span class="s1">n_bins_non_missing</span><span class="s2">,</span>
        <span class="s1">missing_values_bin_idx</span><span class="s2">=</span><span class="s1">missing_values_bin_idx</span><span class="s2">,</span>
        <span class="s1">has_missing_values</span><span class="s2">=</span><span class="s1">has_missing_values</span><span class="s2">,</span>
        <span class="s1">is_categorical</span><span class="s2">=</span><span class="s1">is_categorical</span><span class="s2">,</span>
        <span class="s1">monotonic_cst</span><span class="s2">=</span><span class="s1">monotonic_cst</span><span class="s2">,</span>
        <span class="s1">l2_regularization</span><span class="s2">=</span><span class="s1">l2_regularization</span><span class="s2">,</span>
        <span class="s1">min_hessian_to_split</span><span class="s2">=</span><span class="s1">min_hessian_to_split</span><span class="s2">,</span>
        <span class="s1">min_samples_leaf</span><span class="s2">=</span><span class="s1">min_samples_leaf</span><span class="s2">,</span>
        <span class="s1">min_gain_to_split</span><span class="s2">=</span><span class="s1">min_gain_to_split</span><span class="s2">,</span>
        <span class="s1">hessians_are_constant</span><span class="s2">=</span><span class="s1">hessians_are_constant</span><span class="s2">,</span>
        <span class="s1">rng</span><span class="s2">=</span><span class="s1">rng</span><span class="s2">,</span>
    <span class="s2">)</span>
    <span class="s1">splitter_subsample </span><span class="s2">= </span><span class="s1">Splitter</span><span class="s2">(</span>
        <span class="s1">feature_fraction_per_split</span><span class="s2">=</span><span class="s4">0.25</span><span class="s2">,  </span><span class="s5"># THIS is the important setting here.</span>
        <span class="s2">**</span><span class="s1">params</span><span class="s2">,</span>
    <span class="s2">)</span>
    <span class="s1">splitter_all_features </span><span class="s2">= </span><span class="s1">Splitter</span><span class="s2">(</span><span class="s1">feature_fraction_per_split</span><span class="s2">=</span><span class="s4">1.0</span><span class="s2">, **</span><span class="s1">params</span><span class="s2">)</span>

    <span class="s0">assert </span><span class="s1">np</span><span class="s2">.</span><span class="s1">all</span><span class="s2">(</span><span class="s1">sample_indices </span><span class="s2">== </span><span class="s1">splitter_subsample</span><span class="s2">.</span><span class="s1">partition</span><span class="s2">)</span>

    <span class="s1">split_features_subsample </span><span class="s2">= []</span>
    <span class="s1">split_features_all </span><span class="s2">= []</span>
    <span class="s5"># The loop is to ensure that we split at least once on each feature.</span>
    <span class="s5"># This is tracked by split_features and checked at the end.</span>
    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s4">20</span><span class="s2">):</span>
        <span class="s1">si_root </span><span class="s2">= </span><span class="s1">splitter_subsample</span><span class="s2">.</span><span class="s1">find_node_split</span><span class="s2">(</span>
            <span class="s1">n_samples</span><span class="s2">,</span>
            <span class="s1">histograms</span><span class="s2">,</span>
            <span class="s1">sum_gradients</span><span class="s2">,</span>
            <span class="s1">sum_hessians</span><span class="s2">,</span>
            <span class="s1">value</span><span class="s2">,</span>
            <span class="s1">allowed_features</span><span class="s2">=</span><span class="s1">allowed_features</span><span class="s2">,</span>
        <span class="s2">)</span>
        <span class="s1">split_features_subsample</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">si_root</span><span class="s2">.</span><span class="s1">feature_idx</span><span class="s2">)</span>

        <span class="s5"># This second splitter is our &quot;counterfactual&quot;.</span>
        <span class="s1">si_root </span><span class="s2">= </span><span class="s1">splitter_all_features</span><span class="s2">.</span><span class="s1">find_node_split</span><span class="s2">(</span>
            <span class="s1">n_samples</span><span class="s2">,</span>
            <span class="s1">histograms</span><span class="s2">,</span>
            <span class="s1">sum_gradients</span><span class="s2">,</span>
            <span class="s1">sum_hessians</span><span class="s2">,</span>
            <span class="s1">value</span><span class="s2">,</span>
            <span class="s1">allowed_features</span><span class="s2">=</span><span class="s1">allowed_features</span><span class="s2">,</span>
        <span class="s2">)</span>
        <span class="s1">split_features_all</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">si_root</span><span class="s2">.</span><span class="s1">feature_idx</span><span class="s2">)</span>

    <span class="s5"># Make sure all features are split on.</span>
    <span class="s0">assert </span><span class="s1">set</span><span class="s2">(</span><span class="s1">split_features_subsample</span><span class="s2">) == </span><span class="s1">set</span><span class="s2">(</span><span class="s1">allowed_features</span><span class="s2">)</span>

    <span class="s5"># Make sure, our counterfactual always splits on same feature.</span>
    <span class="s0">assert </span><span class="s1">len</span><span class="s2">(</span><span class="s1">set</span><span class="s2">(</span><span class="s1">split_features_all</span><span class="s2">)) == </span><span class="s4">1</span>
</pre>
</body>
</html>