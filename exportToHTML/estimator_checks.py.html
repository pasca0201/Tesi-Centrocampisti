<html>
<head>
<title>estimator_checks.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #6aab73;}
.s5 { color: #7a7e85;}
.s6 { color: #2aacb8;}
.s7 { color: #a5c261;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
estimator_checks.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Various utilities to check the compatibility of estimators with scikit-learn API.&quot;&quot;&quot;</span>

<span class="s2">import </span><span class="s1">pickle</span>
<span class="s2">import </span><span class="s1">re</span>
<span class="s2">import </span><span class="s1">warnings</span>
<span class="s2">from </span><span class="s1">contextlib </span><span class="s2">import </span><span class="s1">nullcontext</span>
<span class="s2">from </span><span class="s1">copy </span><span class="s2">import </span><span class="s1">deepcopy</span>
<span class="s2">from </span><span class="s1">functools </span><span class="s2">import </span><span class="s1">partial</span><span class="s3">, </span><span class="s1">wraps</span>
<span class="s2">from </span><span class="s1">inspect </span><span class="s2">import </span><span class="s1">isfunction</span><span class="s3">, </span><span class="s1">signature</span>
<span class="s2">from </span><span class="s1">numbers </span><span class="s2">import </span><span class="s1">Integral</span><span class="s3">, </span><span class="s1">Real</span>

<span class="s2">import </span><span class="s1">joblib</span>
<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">from </span><span class="s1">scipy </span><span class="s2">import </span><span class="s1">sparse</span>
<span class="s2">from </span><span class="s1">scipy</span><span class="s3">.</span><span class="s1">stats </span><span class="s2">import </span><span class="s1">rankdata</span>

<span class="s2">from </span><span class="s3">.. </span><span class="s2">import </span><span class="s1">config_context</span>
<span class="s2">from </span><span class="s3">..</span><span class="s1">base </span><span class="s2">import </span><span class="s3">(</span>
    <span class="s1">ClusterMixin</span><span class="s3">,</span>
    <span class="s1">RegressorMixin</span><span class="s3">,</span>
    <span class="s1">clone</span><span class="s3">,</span>
    <span class="s1">is_classifier</span><span class="s3">,</span>
    <span class="s1">is_outlier_detector</span><span class="s3">,</span>
    <span class="s1">is_regressor</span><span class="s3">,</span>
<span class="s3">)</span>
<span class="s2">from </span><span class="s3">..</span><span class="s1">datasets </span><span class="s2">import </span><span class="s3">(</span>
    <span class="s1">load_iris</span><span class="s3">,</span>
    <span class="s1">make_blobs</span><span class="s3">,</span>
    <span class="s1">make_classification</span><span class="s3">,</span>
    <span class="s1">make_multilabel_classification</span><span class="s3">,</span>
    <span class="s1">make_regression</span><span class="s3">,</span>
<span class="s3">)</span>
<span class="s2">from </span><span class="s3">..</span><span class="s1">exceptions </span><span class="s2">import </span><span class="s1">DataConversionWarning</span><span class="s3">, </span><span class="s1">NotFittedError</span><span class="s3">, </span><span class="s1">SkipTestWarning</span>
<span class="s2">from </span><span class="s3">..</span><span class="s1">feature_selection </span><span class="s2">import </span><span class="s1">SelectFromModel</span><span class="s3">, </span><span class="s1">SelectKBest</span>
<span class="s2">from </span><span class="s3">..</span><span class="s1">linear_model </span><span class="s2">import </span><span class="s3">(</span>
    <span class="s1">LinearRegression</span><span class="s3">,</span>
    <span class="s1">LogisticRegression</span><span class="s3">,</span>
    <span class="s1">RANSACRegressor</span><span class="s3">,</span>
    <span class="s1">Ridge</span><span class="s3">,</span>
    <span class="s1">SGDRegressor</span><span class="s3">,</span>
<span class="s3">)</span>
<span class="s2">from </span><span class="s3">..</span><span class="s1">metrics </span><span class="s2">import </span><span class="s1">accuracy_score</span><span class="s3">, </span><span class="s1">adjusted_rand_score</span><span class="s3">, </span><span class="s1">f1_score</span>
<span class="s2">from </span><span class="s3">..</span><span class="s1">metrics</span><span class="s3">.</span><span class="s1">pairwise </span><span class="s2">import </span><span class="s1">linear_kernel</span><span class="s3">, </span><span class="s1">pairwise_distances</span><span class="s3">, </span><span class="s1">rbf_kernel</span>
<span class="s2">from </span><span class="s3">..</span><span class="s1">model_selection </span><span class="s2">import </span><span class="s1">ShuffleSplit</span><span class="s3">, </span><span class="s1">train_test_split</span>
<span class="s2">from </span><span class="s3">..</span><span class="s1">model_selection</span><span class="s3">.</span><span class="s1">_validation </span><span class="s2">import </span><span class="s1">_safe_split</span>
<span class="s2">from </span><span class="s3">..</span><span class="s1">pipeline </span><span class="s2">import </span><span class="s1">make_pipeline</span>
<span class="s2">from </span><span class="s3">..</span><span class="s1">preprocessing </span><span class="s2">import </span><span class="s1">StandardScaler</span><span class="s3">, </span><span class="s1">scale</span>
<span class="s2">from </span><span class="s3">..</span><span class="s1">random_projection </span><span class="s2">import </span><span class="s1">BaseRandomProjection</span>
<span class="s2">from </span><span class="s3">..</span><span class="s1">tree </span><span class="s2">import </span><span class="s1">DecisionTreeClassifier</span><span class="s3">, </span><span class="s1">DecisionTreeRegressor</span>
<span class="s2">from </span><span class="s3">..</span><span class="s1">utils</span><span class="s3">.</span><span class="s1">_array_api </span><span class="s2">import </span><span class="s3">(</span>
    <span class="s1">_atol_for_type</span><span class="s3">,</span>
    <span class="s1">_convert_to_numpy</span><span class="s3">,</span>
    <span class="s1">get_namespace</span><span class="s3">,</span>
    <span class="s1">yield_namespace_device_dtype_combinations</span><span class="s3">,</span>
<span class="s3">)</span>
<span class="s2">from </span><span class="s3">..</span><span class="s1">utils</span><span class="s3">.</span><span class="s1">_array_api </span><span class="s2">import </span><span class="s1">device </span><span class="s2">as </span><span class="s1">array_device</span>
<span class="s2">from </span><span class="s3">..</span><span class="s1">utils</span><span class="s3">.</span><span class="s1">_param_validation </span><span class="s2">import </span><span class="s3">(</span>
    <span class="s1">InvalidParameterError</span><span class="s3">,</span>
    <span class="s1">generate_invalid_param_val</span><span class="s3">,</span>
    <span class="s1">make_constraint</span><span class="s3">,</span>
<span class="s3">)</span>
<span class="s2">from </span><span class="s3">. </span><span class="s2">import </span><span class="s1">shuffle</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">_missing </span><span class="s2">import </span><span class="s1">is_scalar_nan</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">_param_validation </span><span class="s2">import </span><span class="s1">Interval</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">_tags </span><span class="s2">import </span><span class="s3">(</span>
    <span class="s1">_DEFAULT_TAGS</span><span class="s3">,</span>
    <span class="s1">_safe_tags</span><span class="s3">,</span>
<span class="s3">)</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">_testing </span><span class="s2">import </span><span class="s3">(</span>
    <span class="s1">SkipTest</span><span class="s3">,</span>
    <span class="s1">_array_api_for_tests</span><span class="s3">,</span>
    <span class="s1">_get_args</span><span class="s3">,</span>
    <span class="s1">assert_allclose</span><span class="s3">,</span>
    <span class="s1">assert_allclose_dense_sparse</span><span class="s3">,</span>
    <span class="s1">assert_array_almost_equal</span><span class="s3">,</span>
    <span class="s1">assert_array_equal</span><span class="s3">,</span>
    <span class="s1">assert_array_less</span><span class="s3">,</span>
    <span class="s1">assert_raise_message</span><span class="s3">,</span>
    <span class="s1">create_memmap_backed_data</span><span class="s3">,</span>
    <span class="s1">ignore_warnings</span><span class="s3">,</span>
    <span class="s1">raises</span><span class="s3">,</span>
    <span class="s1">set_random_state</span><span class="s3">,</span>
<span class="s3">)</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">fixes </span><span class="s2">import </span><span class="s1">_IS_PYPY</span><span class="s3">, </span><span class="s1">SPARSE_ARRAY_PRESENT</span><span class="s3">, </span><span class="s1">parse_version</span><span class="s3">, </span><span class="s1">sp_version</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">validation </span><span class="s2">import </span><span class="s1">_num_samples</span><span class="s3">, </span><span class="s1">check_is_fitted</span><span class="s3">, </span><span class="s1">has_fit_parameter</span>

<span class="s1">REGRESSION_DATASET </span><span class="s3">= </span><span class="s2">None</span>
<span class="s1">CROSS_DECOMPOSITION </span><span class="s3">= [</span><span class="s4">&quot;PLSCanonical&quot;</span><span class="s3">, </span><span class="s4">&quot;PLSRegression&quot;</span><span class="s3">, </span><span class="s4">&quot;CCA&quot;</span><span class="s3">, </span><span class="s4">&quot;PLSSVD&quot;</span><span class="s3">]</span>


<span class="s2">def </span><span class="s1">_yield_checks</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">):</span>
    <span class="s1">name </span><span class="s3">= </span><span class="s1">estimator</span><span class="s3">.</span><span class="s1">__class__</span><span class="s3">.</span><span class="s1">__name__</span>
    <span class="s1">tags </span><span class="s3">= </span><span class="s1">_safe_tags</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">)</span>

    <span class="s2">yield </span><span class="s1">check_no_attributes_set_in_init</span>
    <span class="s2">yield </span><span class="s1">check_estimators_dtypes</span>
    <span class="s2">yield </span><span class="s1">check_fit_score_takes_y</span>
    <span class="s2">if </span><span class="s1">has_fit_parameter</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s4">&quot;sample_weight&quot;</span><span class="s3">):</span>
        <span class="s2">yield </span><span class="s1">check_sample_weights_pandas_series</span>
        <span class="s2">yield </span><span class="s1">check_sample_weights_not_an_array</span>
        <span class="s2">yield </span><span class="s1">check_sample_weights_list</span>
        <span class="s2">if not </span><span class="s1">tags</span><span class="s3">[</span><span class="s4">&quot;pairwise&quot;</span><span class="s3">]:</span>
            <span class="s5"># We skip pairwise because the data is not pairwise</span>
            <span class="s2">yield </span><span class="s1">check_sample_weights_shape</span>
            <span class="s2">yield </span><span class="s1">check_sample_weights_not_overwritten</span>
            <span class="s2">yield </span><span class="s1">partial</span><span class="s3">(</span><span class="s1">check_sample_weights_invariance</span><span class="s3">, </span><span class="s1">kind</span><span class="s3">=</span><span class="s4">&quot;ones&quot;</span><span class="s3">)</span>
            <span class="s2">yield </span><span class="s1">partial</span><span class="s3">(</span><span class="s1">check_sample_weights_invariance</span><span class="s3">, </span><span class="s1">kind</span><span class="s3">=</span><span class="s4">&quot;zeros&quot;</span><span class="s3">)</span>
    <span class="s2">yield </span><span class="s1">check_estimators_fit_returns_self</span>
    <span class="s2">yield </span><span class="s1">partial</span><span class="s3">(</span><span class="s1">check_estimators_fit_returns_self</span><span class="s3">, </span><span class="s1">readonly_memmap</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

    <span class="s5"># Check that all estimator yield informative messages when</span>
    <span class="s5"># trained on empty datasets</span>
    <span class="s2">if not </span><span class="s1">tags</span><span class="s3">[</span><span class="s4">&quot;no_validation&quot;</span><span class="s3">]:</span>
        <span class="s2">yield </span><span class="s1">check_complex_data</span>
        <span class="s2">yield </span><span class="s1">check_dtype_object</span>
        <span class="s2">yield </span><span class="s1">check_estimators_empty_data_messages</span>

    <span class="s2">if </span><span class="s1">name </span><span class="s2">not in </span><span class="s1">CROSS_DECOMPOSITION</span><span class="s3">:</span>
        <span class="s5"># cross-decomposition's &quot;transform&quot; returns X and Y</span>
        <span class="s2">yield </span><span class="s1">check_pipeline_consistency</span>

    <span class="s2">if not </span><span class="s1">tags</span><span class="s3">[</span><span class="s4">&quot;allow_nan&quot;</span><span class="s3">] </span><span class="s2">and not </span><span class="s1">tags</span><span class="s3">[</span><span class="s4">&quot;no_validation&quot;</span><span class="s3">]:</span>
        <span class="s5"># Test that all estimators check their input for NaN's and infs</span>
        <span class="s2">yield </span><span class="s1">check_estimators_nan_inf</span>

    <span class="s2">if </span><span class="s1">tags</span><span class="s3">[</span><span class="s4">&quot;pairwise&quot;</span><span class="s3">]:</span>
        <span class="s5"># Check that pairwise estimator throws error on non-square input</span>
        <span class="s2">yield </span><span class="s1">check_nonsquare_error</span>

    <span class="s2">yield </span><span class="s1">check_estimators_overwrite_params</span>
    <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s4">&quot;sparsify&quot;</span><span class="s3">):</span>
        <span class="s2">yield </span><span class="s1">check_sparsify_coefficients</span>

    <span class="s2">yield </span><span class="s1">check_estimator_sparse_array</span>
    <span class="s2">yield </span><span class="s1">check_estimator_sparse_matrix</span>

    <span class="s5"># Test that estimators can be pickled, and once pickled</span>
    <span class="s5"># give the same answer as before.</span>
    <span class="s2">yield </span><span class="s1">check_estimators_pickle</span>
    <span class="s2">yield </span><span class="s1">partial</span><span class="s3">(</span><span class="s1">check_estimators_pickle</span><span class="s3">, </span><span class="s1">readonly_memmap</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

    <span class="s2">yield </span><span class="s1">check_estimator_get_tags_default_keys</span>

    <span class="s2">if </span><span class="s1">tags</span><span class="s3">[</span><span class="s4">&quot;array_api_support&quot;</span><span class="s3">]:</span>
        <span class="s2">for </span><span class="s1">check </span><span class="s2">in </span><span class="s1">_yield_array_api_checks</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">):</span>
            <span class="s2">yield </span><span class="s1">check</span>


<span class="s2">def </span><span class="s1">_yield_classifier_checks</span><span class="s3">(</span><span class="s1">classifier</span><span class="s3">):</span>
    <span class="s1">tags </span><span class="s3">= </span><span class="s1">_safe_tags</span><span class="s3">(</span><span class="s1">classifier</span><span class="s3">)</span>

    <span class="s5"># test classifiers can handle non-array data and pandas objects</span>
    <span class="s2">yield </span><span class="s1">check_classifier_data_not_an_array</span>
    <span class="s5"># test classifiers trained on a single label always return this label</span>
    <span class="s2">yield </span><span class="s1">check_classifiers_one_label</span>
    <span class="s2">yield </span><span class="s1">check_classifiers_one_label_sample_weights</span>
    <span class="s2">yield </span><span class="s1">check_classifiers_classes</span>
    <span class="s2">yield </span><span class="s1">check_estimators_partial_fit_n_features</span>
    <span class="s2">if </span><span class="s1">tags</span><span class="s3">[</span><span class="s4">&quot;multioutput&quot;</span><span class="s3">]:</span>
        <span class="s2">yield </span><span class="s1">check_classifier_multioutput</span>
    <span class="s5"># basic consistency testing</span>
    <span class="s2">yield </span><span class="s1">check_classifiers_train</span>
    <span class="s2">yield </span><span class="s1">partial</span><span class="s3">(</span><span class="s1">check_classifiers_train</span><span class="s3">, </span><span class="s1">readonly_memmap</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
    <span class="s2">yield </span><span class="s1">partial</span><span class="s3">(</span><span class="s1">check_classifiers_train</span><span class="s3">, </span><span class="s1">readonly_memmap</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">X_dtype</span><span class="s3">=</span><span class="s4">&quot;float32&quot;</span><span class="s3">)</span>
    <span class="s2">yield </span><span class="s1">check_classifiers_regression_target</span>
    <span class="s2">if </span><span class="s1">tags</span><span class="s3">[</span><span class="s4">&quot;multilabel&quot;</span><span class="s3">]:</span>
        <span class="s2">yield </span><span class="s1">check_classifiers_multilabel_representation_invariance</span>
        <span class="s2">yield </span><span class="s1">check_classifiers_multilabel_output_format_predict</span>
        <span class="s2">yield </span><span class="s1">check_classifiers_multilabel_output_format_predict_proba</span>
        <span class="s2">yield </span><span class="s1">check_classifiers_multilabel_output_format_decision_function</span>
    <span class="s2">if not </span><span class="s1">tags</span><span class="s3">[</span><span class="s4">&quot;no_validation&quot;</span><span class="s3">]:</span>
        <span class="s2">yield </span><span class="s1">check_supervised_y_no_nan</span>
        <span class="s2">if not </span><span class="s1">tags</span><span class="s3">[</span><span class="s4">&quot;multioutput_only&quot;</span><span class="s3">]:</span>
            <span class="s2">yield </span><span class="s1">check_supervised_y_2d</span>
    <span class="s2">if </span><span class="s1">tags</span><span class="s3">[</span><span class="s4">&quot;requires_fit&quot;</span><span class="s3">]:</span>
        <span class="s2">yield </span><span class="s1">check_estimators_unfitted</span>
    <span class="s2">if </span><span class="s4">&quot;class_weight&quot; </span><span class="s2">in </span><span class="s1">classifier</span><span class="s3">.</span><span class="s1">get_params</span><span class="s3">().</span><span class="s1">keys</span><span class="s3">():</span>
        <span class="s2">yield </span><span class="s1">check_class_weight_classifiers</span>

    <span class="s2">yield </span><span class="s1">check_non_transformer_estimators_n_iter</span>
    <span class="s5"># test if predict_proba is a monotonic transformation of decision_function</span>
    <span class="s2">yield </span><span class="s1">check_decision_proba_consistency</span>


<span class="s3">@</span><span class="s1">ignore_warnings</span><span class="s3">(</span><span class="s1">category</span><span class="s3">=</span><span class="s1">FutureWarning</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">check_supervised_y_no_nan</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">estimator_orig</span><span class="s3">):</span>
    <span class="s5"># Checks that the Estimator targets are not NaN.</span>
    <span class="s1">estimator </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">)</span>
    <span class="s1">rng </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">RandomState</span><span class="s3">(</span><span class="s6">888</span><span class="s3">)</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">rng</span><span class="s3">.</span><span class="s1">standard_normal</span><span class="s3">(</span><span class="s1">size</span><span class="s3">=(</span><span class="s6">10</span><span class="s3">, </span><span class="s6">5</span><span class="s3">))</span>

    <span class="s2">for </span><span class="s1">value </span><span class="s2">in </span><span class="s3">[</span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">inf</span><span class="s3">]:</span>
        <span class="s1">y </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">full</span><span class="s3">(</span><span class="s6">10</span><span class="s3">, </span><span class="s1">value</span><span class="s3">)</span>
        <span class="s1">y </span><span class="s3">= </span><span class="s1">_enforce_estimator_tags_y</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>

        <span class="s1">module_name </span><span class="s3">= </span><span class="s1">estimator</span><span class="s3">.</span><span class="s1">__module__</span>
        <span class="s2">if </span><span class="s1">module_name</span><span class="s3">.</span><span class="s1">startswith</span><span class="s3">(</span><span class="s4">&quot;sklearn.&quot;</span><span class="s3">) </span><span class="s2">and not </span><span class="s3">(</span>
            <span class="s4">&quot;test_&quot; </span><span class="s2">in </span><span class="s1">module_name </span><span class="s2">or </span><span class="s1">module_name</span><span class="s3">.</span><span class="s1">endswith</span><span class="s3">(</span><span class="s4">&quot;_testing&quot;</span><span class="s3">)</span>
        <span class="s3">):</span>
            <span class="s5"># In scikit-learn we want the error message to mention the input</span>
            <span class="s5"># name and be specific about the kind of unexpected value.</span>
            <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isinf</span><span class="s3">(</span><span class="s1">value</span><span class="s3">):</span>
                <span class="s1">match </span><span class="s3">= (</span>
                    <span class="s4">r&quot;Input (y|Y) contains infinity or a value too large for&quot;</span>
                    <span class="s4">r&quot; dtype\('float64'\).&quot;</span>
                <span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">match </span><span class="s3">= </span><span class="s4">r&quot;Input (y|Y) contains NaN.&quot;</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s5"># Do not impose a particular error message to third-party libraries.</span>
            <span class="s1">match </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s1">err_msg </span><span class="s3">= (</span>
            <span class="s4">f&quot;Estimator </span><span class="s2">{</span><span class="s1">name</span><span class="s2">} </span><span class="s4">should have raised error on fitting array y with inf&quot;</span>
            <span class="s4">&quot; value.&quot;</span>
        <span class="s3">)</span>
        <span class="s2">with </span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s1">match</span><span class="s3">, </span><span class="s1">err_msg</span><span class="s3">=</span><span class="s1">err_msg</span><span class="s3">):</span>
            <span class="s1">estimator</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">_yield_regressor_checks</span><span class="s3">(</span><span class="s1">regressor</span><span class="s3">):</span>
    <span class="s1">tags </span><span class="s3">= </span><span class="s1">_safe_tags</span><span class="s3">(</span><span class="s1">regressor</span><span class="s3">)</span>
    <span class="s5"># TODO: test with intercept</span>
    <span class="s5"># TODO: test with multiple responses</span>
    <span class="s5"># basic testing</span>
    <span class="s2">yield </span><span class="s1">check_regressors_train</span>
    <span class="s2">yield </span><span class="s1">partial</span><span class="s3">(</span><span class="s1">check_regressors_train</span><span class="s3">, </span><span class="s1">readonly_memmap</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
    <span class="s2">yield </span><span class="s1">partial</span><span class="s3">(</span><span class="s1">check_regressors_train</span><span class="s3">, </span><span class="s1">readonly_memmap</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">X_dtype</span><span class="s3">=</span><span class="s4">&quot;float32&quot;</span><span class="s3">)</span>
    <span class="s2">yield </span><span class="s1">check_regressor_data_not_an_array</span>
    <span class="s2">yield </span><span class="s1">check_estimators_partial_fit_n_features</span>
    <span class="s2">if </span><span class="s1">tags</span><span class="s3">[</span><span class="s4">&quot;multioutput&quot;</span><span class="s3">]:</span>
        <span class="s2">yield </span><span class="s1">check_regressor_multioutput</span>
    <span class="s2">yield </span><span class="s1">check_regressors_no_decision_function</span>
    <span class="s2">if not </span><span class="s1">tags</span><span class="s3">[</span><span class="s4">&quot;no_validation&quot;</span><span class="s3">] </span><span class="s2">and not </span><span class="s1">tags</span><span class="s3">[</span><span class="s4">&quot;multioutput_only&quot;</span><span class="s3">]:</span>
        <span class="s2">yield </span><span class="s1">check_supervised_y_2d</span>
    <span class="s2">yield </span><span class="s1">check_supervised_y_no_nan</span>
    <span class="s1">name </span><span class="s3">= </span><span class="s1">regressor</span><span class="s3">.</span><span class="s1">__class__</span><span class="s3">.</span><span class="s1">__name__</span>
    <span class="s2">if </span><span class="s1">name </span><span class="s3">!= </span><span class="s4">&quot;CCA&quot;</span><span class="s3">:</span>
        <span class="s5"># check that the regressor handles int input</span>
        <span class="s2">yield </span><span class="s1">check_regressors_int</span>
    <span class="s2">if </span><span class="s1">tags</span><span class="s3">[</span><span class="s4">&quot;requires_fit&quot;</span><span class="s3">]:</span>
        <span class="s2">yield </span><span class="s1">check_estimators_unfitted</span>
    <span class="s2">yield </span><span class="s1">check_non_transformer_estimators_n_iter</span>


<span class="s2">def </span><span class="s1">_yield_transformer_checks</span><span class="s3">(</span><span class="s1">transformer</span><span class="s3">):</span>
    <span class="s1">tags </span><span class="s3">= </span><span class="s1">_safe_tags</span><span class="s3">(</span><span class="s1">transformer</span><span class="s3">)</span>
    <span class="s5"># All transformers should either deal with sparse data or raise an</span>
    <span class="s5"># exception with type TypeError and an intelligible error message</span>
    <span class="s2">if not </span><span class="s1">tags</span><span class="s3">[</span><span class="s4">&quot;no_validation&quot;</span><span class="s3">]:</span>
        <span class="s2">yield </span><span class="s1">check_transformer_data_not_an_array</span>
    <span class="s5"># these don't actually fit the data, so don't raise errors</span>
    <span class="s2">yield </span><span class="s1">check_transformer_general</span>
    <span class="s2">if </span><span class="s1">tags</span><span class="s3">[</span><span class="s4">&quot;preserves_dtype&quot;</span><span class="s3">]:</span>
        <span class="s2">yield </span><span class="s1">check_transformer_preserve_dtypes</span>
    <span class="s2">yield </span><span class="s1">partial</span><span class="s3">(</span><span class="s1">check_transformer_general</span><span class="s3">, </span><span class="s1">readonly_memmap</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
    <span class="s2">if not </span><span class="s1">_safe_tags</span><span class="s3">(</span><span class="s1">transformer</span><span class="s3">, </span><span class="s1">key</span><span class="s3">=</span><span class="s4">&quot;stateless&quot;</span><span class="s3">):</span>
        <span class="s2">yield </span><span class="s1">check_transformers_unfitted</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">yield </span><span class="s1">check_transformers_unfitted_stateless</span>
    <span class="s5"># Dependent on external solvers and hence accessing the iter</span>
    <span class="s5"># param is non-trivial.</span>
    <span class="s1">external_solver </span><span class="s3">= [</span>
        <span class="s4">&quot;Isomap&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;KernelPCA&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;LocallyLinearEmbedding&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;RandomizedLasso&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;LogisticRegressionCV&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;BisectingKMeans&quot;</span><span class="s3">,</span>
    <span class="s3">]</span>

    <span class="s1">name </span><span class="s3">= </span><span class="s1">transformer</span><span class="s3">.</span><span class="s1">__class__</span><span class="s3">.</span><span class="s1">__name__</span>
    <span class="s2">if </span><span class="s1">name </span><span class="s2">not in </span><span class="s1">external_solver</span><span class="s3">:</span>
        <span class="s2">yield </span><span class="s1">check_transformer_n_iter</span>


<span class="s2">def </span><span class="s1">_yield_clustering_checks</span><span class="s3">(</span><span class="s1">clusterer</span><span class="s3">):</span>
    <span class="s2">yield </span><span class="s1">check_clusterer_compute_labels_predict</span>
    <span class="s1">name </span><span class="s3">= </span><span class="s1">clusterer</span><span class="s3">.</span><span class="s1">__class__</span><span class="s3">.</span><span class="s1">__name__</span>
    <span class="s2">if </span><span class="s1">name </span><span class="s2">not in </span><span class="s3">(</span><span class="s4">&quot;WardAgglomeration&quot;</span><span class="s3">, </span><span class="s4">&quot;FeatureAgglomeration&quot;</span><span class="s3">):</span>
        <span class="s5"># this is clustering on the features</span>
        <span class="s5"># let's not test that here.</span>
        <span class="s2">yield </span><span class="s1">check_clustering</span>
        <span class="s2">yield </span><span class="s1">partial</span><span class="s3">(</span><span class="s1">check_clustering</span><span class="s3">, </span><span class="s1">readonly_memmap</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
        <span class="s2">yield </span><span class="s1">check_estimators_partial_fit_n_features</span>
    <span class="s2">if not </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">clusterer</span><span class="s3">, </span><span class="s4">&quot;transform&quot;</span><span class="s3">):</span>
        <span class="s2">yield </span><span class="s1">check_non_transformer_estimators_n_iter</span>


<span class="s2">def </span><span class="s1">_yield_outliers_checks</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">):</span>
    <span class="s5"># checks for the contamination parameter</span>
    <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s4">&quot;contamination&quot;</span><span class="s3">):</span>
        <span class="s2">yield </span><span class="s1">check_outlier_contamination</span>

    <span class="s5"># checks for outlier detectors that have a fit_predict method</span>
    <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s4">&quot;fit_predict&quot;</span><span class="s3">):</span>
        <span class="s2">yield </span><span class="s1">check_outliers_fit_predict</span>

    <span class="s5"># checks for estimators that can be used on a test set</span>
    <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s4">&quot;predict&quot;</span><span class="s3">):</span>
        <span class="s2">yield </span><span class="s1">check_outliers_train</span>
        <span class="s2">yield </span><span class="s1">partial</span><span class="s3">(</span><span class="s1">check_outliers_train</span><span class="s3">, </span><span class="s1">readonly_memmap</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
        <span class="s5"># test outlier detectors can handle non-array data</span>
        <span class="s2">yield </span><span class="s1">check_classifier_data_not_an_array</span>
        <span class="s5"># test if NotFittedError is raised</span>
        <span class="s2">if </span><span class="s1">_safe_tags</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">key</span><span class="s3">=</span><span class="s4">&quot;requires_fit&quot;</span><span class="s3">):</span>
            <span class="s2">yield </span><span class="s1">check_estimators_unfitted</span>
    <span class="s2">yield </span><span class="s1">check_non_transformer_estimators_n_iter</span>


<span class="s2">def </span><span class="s1">_yield_array_api_checks</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">):</span>
    <span class="s2">for </span><span class="s3">(</span>
        <span class="s1">array_namespace</span><span class="s3">,</span>
        <span class="s1">device</span><span class="s3">,</span>
        <span class="s1">dtype_name</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s2">in </span><span class="s1">yield_namespace_device_dtype_combinations</span><span class="s3">():</span>
        <span class="s2">yield </span><span class="s1">partial</span><span class="s3">(</span>
            <span class="s1">check_array_api_input</span><span class="s3">,</span>
            <span class="s1">array_namespace</span><span class="s3">=</span><span class="s1">array_namespace</span><span class="s3">,</span>
            <span class="s1">dtype_name</span><span class="s3">=</span><span class="s1">dtype_name</span><span class="s3">,</span>
            <span class="s1">device</span><span class="s3">=</span><span class="s1">device</span><span class="s3">,</span>
        <span class="s3">)</span>


<span class="s2">def </span><span class="s1">_yield_all_checks</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">):</span>
    <span class="s1">name </span><span class="s3">= </span><span class="s1">estimator</span><span class="s3">.</span><span class="s1">__class__</span><span class="s3">.</span><span class="s1">__name__</span>
    <span class="s1">tags </span><span class="s3">= </span><span class="s1">_safe_tags</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s4">&quot;2darray&quot; </span><span class="s2">not in </span><span class="s1">tags</span><span class="s3">[</span><span class="s4">&quot;X_types&quot;</span><span class="s3">]:</span>
        <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span>
            <span class="s4">&quot;Can't test estimator {} which requires input  of type {}&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span>
                <span class="s1">name</span><span class="s3">, </span><span class="s1">tags</span><span class="s3">[</span><span class="s4">&quot;X_types&quot;</span><span class="s3">]</span>
            <span class="s3">),</span>
            <span class="s1">SkipTestWarning</span><span class="s3">,</span>
        <span class="s3">)</span>
        <span class="s2">return</span>
    <span class="s2">if </span><span class="s1">tags</span><span class="s3">[</span><span class="s4">&quot;_skip_test&quot;</span><span class="s3">]:</span>
        <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span>
            <span class="s4">&quot;Explicit SKIP via _skip_test tag for estimator {}.&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">name</span><span class="s3">),</span>
            <span class="s1">SkipTestWarning</span><span class="s3">,</span>
        <span class="s3">)</span>
        <span class="s2">return</span>

    <span class="s2">for </span><span class="s1">check </span><span class="s2">in </span><span class="s1">_yield_checks</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">):</span>
        <span class="s2">yield </span><span class="s1">check</span>
    <span class="s2">if </span><span class="s1">is_classifier</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">):</span>
        <span class="s2">for </span><span class="s1">check </span><span class="s2">in </span><span class="s1">_yield_classifier_checks</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">):</span>
            <span class="s2">yield </span><span class="s1">check</span>
    <span class="s2">if </span><span class="s1">is_regressor</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">):</span>
        <span class="s2">for </span><span class="s1">check </span><span class="s2">in </span><span class="s1">_yield_regressor_checks</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">):</span>
            <span class="s2">yield </span><span class="s1">check</span>
    <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s4">&quot;transform&quot;</span><span class="s3">):</span>
        <span class="s2">for </span><span class="s1">check </span><span class="s2">in </span><span class="s1">_yield_transformer_checks</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">):</span>
            <span class="s2">yield </span><span class="s1">check</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">ClusterMixin</span><span class="s3">):</span>
        <span class="s2">for </span><span class="s1">check </span><span class="s2">in </span><span class="s1">_yield_clustering_checks</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">):</span>
            <span class="s2">yield </span><span class="s1">check</span>
    <span class="s2">if </span><span class="s1">is_outlier_detector</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">):</span>
        <span class="s2">for </span><span class="s1">check </span><span class="s2">in </span><span class="s1">_yield_outliers_checks</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">):</span>
            <span class="s2">yield </span><span class="s1">check</span>
    <span class="s2">yield </span><span class="s1">check_parameters_default_constructible</span>
    <span class="s2">if not </span><span class="s1">tags</span><span class="s3">[</span><span class="s4">&quot;non_deterministic&quot;</span><span class="s3">]:</span>
        <span class="s2">yield </span><span class="s1">check_methods_sample_order_invariance</span>
        <span class="s2">yield </span><span class="s1">check_methods_subset_invariance</span>
    <span class="s2">yield </span><span class="s1">check_fit2d_1sample</span>
    <span class="s2">yield </span><span class="s1">check_fit2d_1feature</span>
    <span class="s2">yield </span><span class="s1">check_get_params_invariance</span>
    <span class="s2">yield </span><span class="s1">check_set_params</span>
    <span class="s2">yield </span><span class="s1">check_dict_unchanged</span>
    <span class="s2">yield </span><span class="s1">check_dont_overwrite_parameters</span>
    <span class="s2">yield </span><span class="s1">check_fit_idempotent</span>
    <span class="s2">yield </span><span class="s1">check_fit_check_is_fitted</span>
    <span class="s2">if not </span><span class="s1">tags</span><span class="s3">[</span><span class="s4">&quot;no_validation&quot;</span><span class="s3">]:</span>
        <span class="s2">yield </span><span class="s1">check_n_features_in</span>
        <span class="s2">yield </span><span class="s1">check_fit1d</span>
        <span class="s2">yield </span><span class="s1">check_fit2d_predict1d</span>
        <span class="s2">if </span><span class="s1">tags</span><span class="s3">[</span><span class="s4">&quot;requires_y&quot;</span><span class="s3">]:</span>
            <span class="s2">yield </span><span class="s1">check_requires_y_none</span>
    <span class="s2">if </span><span class="s1">tags</span><span class="s3">[</span><span class="s4">&quot;requires_positive_X&quot;</span><span class="s3">]:</span>
        <span class="s2">yield </span><span class="s1">check_fit_non_negative</span>


<span class="s2">def </span><span class="s1">_get_check_estimator_ids</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Create pytest ids for checks. 
 
    When `obj` is an estimator, this returns the pprint version of the 
    estimator (with `print_changed_only=True`). When `obj` is a function, the 
    name of the function is returned with its keyword arguments. 
 
    `_get_check_estimator_ids` is designed to be used as the `id` in 
    `pytest.mark.parametrize` where `check_estimator(..., generate_only=True)` 
    is yielding estimators and checks. 
 
    Parameters 
    ---------- 
    obj : estimator or function 
        Items generated by `check_estimator`. 
 
    Returns 
    ------- 
    id : str or None 
 
    See Also 
    -------- 
    check_estimator 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">isfunction</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">obj</span><span class="s3">.</span><span class="s1">__name__</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">partial</span><span class="s3">):</span>
        <span class="s2">if not </span><span class="s1">obj</span><span class="s3">.</span><span class="s1">keywords</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">obj</span><span class="s3">.</span><span class="s1">func</span><span class="s3">.</span><span class="s1">__name__</span>
        <span class="s1">kwstring </span><span class="s3">= </span><span class="s4">&quot;,&quot;</span><span class="s3">.</span><span class="s1">join</span><span class="s3">([</span><span class="s4">&quot;{}={}&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">k</span><span class="s3">, </span><span class="s1">v</span><span class="s3">) </span><span class="s2">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">obj</span><span class="s3">.</span><span class="s1">keywords</span><span class="s3">.</span><span class="s1">items</span><span class="s3">()])</span>
        <span class="s2">return </span><span class="s4">&quot;{}({})&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">.</span><span class="s1">func</span><span class="s3">.</span><span class="s1">__name__</span><span class="s3">, </span><span class="s1">kwstring</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s4">&quot;get_params&quot;</span><span class="s3">):</span>
        <span class="s2">with </span><span class="s1">config_context</span><span class="s3">(</span><span class="s1">print_changed_only</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">re</span><span class="s3">.</span><span class="s1">sub</span><span class="s3">(</span><span class="s4">r&quot;\s&quot;</span><span class="s3">, </span><span class="s4">&quot;&quot;</span><span class="s3">, </span><span class="s1">str</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">))</span>


<span class="s2">def </span><span class="s1">_construct_instance</span><span class="s3">(</span><span class="s1">Estimator</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Construct Estimator instance if possible.&quot;&quot;&quot;</span>
    <span class="s1">required_parameters </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">Estimator</span><span class="s3">, </span><span class="s4">&quot;_required_parameters&quot;</span><span class="s3">, [])</span>
    <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">required_parameters</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">required_parameters </span><span class="s2">in </span><span class="s3">([</span><span class="s4">&quot;estimator&quot;</span><span class="s3">], [</span><span class="s4">&quot;base_estimator&quot;</span><span class="s3">]):</span>
            <span class="s5"># `RANSACRegressor` will raise an error with any model other</span>
            <span class="s5"># than `LinearRegression` if we don't fix `min_samples` parameter.</span>
            <span class="s5"># For common test, we can enforce using `LinearRegression` that</span>
            <span class="s5"># is the default estimator in `RANSACRegressor` instead of `Ridge`.</span>
            <span class="s2">if </span><span class="s1">issubclass</span><span class="s3">(</span><span class="s1">Estimator</span><span class="s3">, </span><span class="s1">RANSACRegressor</span><span class="s3">):</span>
                <span class="s1">estimator </span><span class="s3">= </span><span class="s1">Estimator</span><span class="s3">(</span><span class="s1">LinearRegression</span><span class="s3">())</span>
            <span class="s2">elif </span><span class="s1">issubclass</span><span class="s3">(</span><span class="s1">Estimator</span><span class="s3">, </span><span class="s1">RegressorMixin</span><span class="s3">):</span>
                <span class="s1">estimator </span><span class="s3">= </span><span class="s1">Estimator</span><span class="s3">(</span><span class="s1">Ridge</span><span class="s3">())</span>
            <span class="s2">elif </span><span class="s1">issubclass</span><span class="s3">(</span><span class="s1">Estimator</span><span class="s3">, </span><span class="s1">SelectFromModel</span><span class="s3">):</span>
                <span class="s5"># Increases coverage because SGDRegressor has partial_fit</span>
                <span class="s1">estimator </span><span class="s3">= </span><span class="s1">Estimator</span><span class="s3">(</span><span class="s1">SGDRegressor</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">=</span><span class="s6">0</span><span class="s3">))</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">estimator </span><span class="s3">= </span><span class="s1">Estimator</span><span class="s3">(</span><span class="s1">LogisticRegression</span><span class="s3">(</span><span class="s1">C</span><span class="s3">=</span><span class="s6">1</span><span class="s3">))</span>
        <span class="s2">elif </span><span class="s1">required_parameters </span><span class="s2">in </span><span class="s3">([</span><span class="s4">&quot;estimators&quot;</span><span class="s3">],):</span>
            <span class="s5"># Heterogeneous ensemble classes (i.e. stacking, voting)</span>
            <span class="s2">if </span><span class="s1">issubclass</span><span class="s3">(</span><span class="s1">Estimator</span><span class="s3">, </span><span class="s1">RegressorMixin</span><span class="s3">):</span>
                <span class="s1">estimator </span><span class="s3">= </span><span class="s1">Estimator</span><span class="s3">(</span>
                    <span class="s1">estimators</span><span class="s3">=[</span>
                        <span class="s3">(</span><span class="s4">&quot;est1&quot;</span><span class="s3">, </span><span class="s1">DecisionTreeRegressor</span><span class="s3">(</span><span class="s1">max_depth</span><span class="s3">=</span><span class="s6">3</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s6">0</span><span class="s3">)),</span>
                        <span class="s3">(</span><span class="s4">&quot;est2&quot;</span><span class="s3">, </span><span class="s1">DecisionTreeRegressor</span><span class="s3">(</span><span class="s1">max_depth</span><span class="s3">=</span><span class="s6">3</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s6">1</span><span class="s3">)),</span>
                    <span class="s3">]</span>
                <span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">estimator </span><span class="s3">= </span><span class="s1">Estimator</span><span class="s3">(</span>
                    <span class="s1">estimators</span><span class="s3">=[</span>
                        <span class="s3">(</span><span class="s4">&quot;est1&quot;</span><span class="s3">, </span><span class="s1">DecisionTreeClassifier</span><span class="s3">(</span><span class="s1">max_depth</span><span class="s3">=</span><span class="s6">3</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s6">0</span><span class="s3">)),</span>
                        <span class="s3">(</span><span class="s4">&quot;est2&quot;</span><span class="s3">, </span><span class="s1">DecisionTreeClassifier</span><span class="s3">(</span><span class="s1">max_depth</span><span class="s3">=</span><span class="s6">3</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s6">1</span><span class="s3">)),</span>
                    <span class="s3">]</span>
                <span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">msg </span><span class="s3">= (</span>
                <span class="s4">f&quot;Can't instantiate estimator </span><span class="s2">{</span><span class="s1">Estimator</span><span class="s3">.</span><span class="s1">__name__</span><span class="s2">} </span><span class="s4">&quot;</span>
                <span class="s4">f&quot;parameters </span><span class="s2">{</span><span class="s1">required_parameters</span><span class="s2">}</span><span class="s4">&quot;</span>
            <span class="s3">)</span>
            <span class="s5"># raise additional warning to be shown by pytest</span>
            <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">, </span><span class="s1">SkipTestWarning</span><span class="s3">)</span>
            <span class="s2">raise </span><span class="s1">SkipTest</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">estimator </span><span class="s3">= </span><span class="s1">Estimator</span><span class="s3">()</span>
    <span class="s2">return </span><span class="s1">estimator</span>


<span class="s2">def </span><span class="s1">_maybe_mark_xfail</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">check</span><span class="s3">, </span><span class="s1">pytest</span><span class="s3">):</span>
    <span class="s5"># Mark (estimator, check) pairs as XFAIL if needed (see conditions in</span>
    <span class="s5"># _should_be_skipped_or_marked())</span>
    <span class="s5"># This is similar to _maybe_skip(), but this one is used by</span>
    <span class="s5"># @parametrize_with_checks() instead of check_estimator()</span>

    <span class="s1">should_be_marked</span><span class="s3">, </span><span class="s1">reason </span><span class="s3">= </span><span class="s1">_should_be_skipped_or_marked</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">check</span><span class="s3">)</span>
    <span class="s2">if not </span><span class="s1">should_be_marked</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">check</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">param</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">check</span><span class="s3">, </span><span class="s1">marks</span><span class="s3">=</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">xfail</span><span class="s3">(</span><span class="s1">reason</span><span class="s3">=</span><span class="s1">reason</span><span class="s3">))</span>


<span class="s2">def </span><span class="s1">_maybe_skip</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">check</span><span class="s3">):</span>
    <span class="s5"># Wrap a check so that it's skipped if needed (see conditions in</span>
    <span class="s5"># _should_be_skipped_or_marked())</span>
    <span class="s5"># This is similar to _maybe_mark_xfail(), but this one is used by</span>
    <span class="s5"># check_estimator() instead of @parametrize_with_checks which requires</span>
    <span class="s5"># pytest</span>
    <span class="s1">should_be_skipped</span><span class="s3">, </span><span class="s1">reason </span><span class="s3">= </span><span class="s1">_should_be_skipped_or_marked</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">check</span><span class="s3">)</span>
    <span class="s2">if not </span><span class="s1">should_be_skipped</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">check</span>

    <span class="s1">check_name </span><span class="s3">= </span><span class="s1">check</span><span class="s3">.</span><span class="s1">func</span><span class="s3">.</span><span class="s1">__name__ </span><span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">check</span><span class="s3">, </span><span class="s1">partial</span><span class="s3">) </span><span class="s2">else </span><span class="s1">check</span><span class="s3">.</span><span class="s1">__name__</span>

    <span class="s3">@</span><span class="s1">wraps</span><span class="s3">(</span><span class="s1">check</span><span class="s3">)</span>
    <span class="s2">def </span><span class="s1">wrapped</span><span class="s3">(*</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">SkipTest</span><span class="s3">(</span>
            <span class="s4">f&quot;Skipping </span><span class="s2">{</span><span class="s1">check_name</span><span class="s2">} </span><span class="s4">for </span><span class="s2">{</span><span class="s1">estimator</span><span class="s3">.</span><span class="s1">__class__</span><span class="s3">.</span><span class="s1">__name__</span><span class="s2">}</span><span class="s4">: </span><span class="s2">{</span><span class="s1">reason</span><span class="s2">}</span><span class="s4">&quot;</span>
        <span class="s3">)</span>

    <span class="s2">return </span><span class="s1">wrapped</span>


<span class="s2">def </span><span class="s1">_should_be_skipped_or_marked</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">check</span><span class="s3">):</span>
    <span class="s5"># Return whether a check should be skipped (when using check_estimator())</span>
    <span class="s5"># or marked as XFAIL (when using @parametrize_with_checks()), along with a</span>
    <span class="s5"># reason.</span>
    <span class="s5"># Currently, a check should be skipped or marked if</span>
    <span class="s5"># the check is in the _xfail_checks tag of the estimator</span>

    <span class="s1">check_name </span><span class="s3">= </span><span class="s1">check</span><span class="s3">.</span><span class="s1">func</span><span class="s3">.</span><span class="s1">__name__ </span><span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">check</span><span class="s3">, </span><span class="s1">partial</span><span class="s3">) </span><span class="s2">else </span><span class="s1">check</span><span class="s3">.</span><span class="s1">__name__</span>

    <span class="s1">xfail_checks </span><span class="s3">= </span><span class="s1">_safe_tags</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">key</span><span class="s3">=</span><span class="s4">&quot;_xfail_checks&quot;</span><span class="s3">) </span><span class="s2">or </span><span class="s3">{}</span>
    <span class="s2">if </span><span class="s1">check_name </span><span class="s2">in </span><span class="s1">xfail_checks</span><span class="s3">:</span>
        <span class="s2">return True</span><span class="s3">, </span><span class="s1">xfail_checks</span><span class="s3">[</span><span class="s1">check_name</span><span class="s3">]</span>

    <span class="s2">return False</span><span class="s3">, </span><span class="s4">&quot;placeholder reason that will never be used&quot;</span>


<span class="s2">def </span><span class="s1">parametrize_with_checks</span><span class="s3">(</span><span class="s1">estimators</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Pytest specific decorator for parametrizing estimator checks. 
 
    The `id` of each check is set to be a pprint version of the estimator 
    and the name of the check with its keyword arguments. 
    This allows to use `pytest -k` to specify which tests to run:: 
 
        pytest test_check_estimators.py -k check_estimators_fit_returns_self 
 
    Parameters 
    ---------- 
    estimators : list of estimators instances 
        Estimators to generated checks for. 
 
        .. versionchanged:: 0.24 
           Passing a class was deprecated in version 0.23, and support for 
           classes was removed in 0.24. Pass an instance instead. 
 
        .. versionadded:: 0.24 
 
    Returns 
    ------- 
    decorator : `pytest.mark.parametrize` 
 
    See Also 
    -------- 
    check_estimator : Check if estimator adheres to scikit-learn conventions. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from sklearn.utils.estimator_checks import parametrize_with_checks 
    &gt;&gt;&gt; from sklearn.linear_model import LogisticRegression 
    &gt;&gt;&gt; from sklearn.tree import DecisionTreeRegressor 
 
    &gt;&gt;&gt; @parametrize_with_checks([LogisticRegression(), 
    ...                           DecisionTreeRegressor()]) 
    ... def test_sklearn_compatible_estimator(estimator, check): 
    ...     check(estimator) 
 
    &quot;&quot;&quot;</span>
    <span class="s2">import </span><span class="s1">pytest</span>

    <span class="s2">if </span><span class="s1">any</span><span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">est</span><span class="s3">, </span><span class="s1">type</span><span class="s3">) </span><span class="s2">for </span><span class="s1">est </span><span class="s2">in </span><span class="s1">estimators</span><span class="s3">):</span>
        <span class="s1">msg </span><span class="s3">= (</span>
            <span class="s4">&quot;Passing a class was deprecated in version 0.23 &quot;</span>
            <span class="s4">&quot;and isn't supported anymore from 0.24.&quot;</span>
            <span class="s4">&quot;Please pass an instance instead.&quot;</span>
        <span class="s3">)</span>
        <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">checks_generator</span><span class="s3">():</span>
        <span class="s2">for </span><span class="s1">estimator </span><span class="s2">in </span><span class="s1">estimators</span><span class="s3">:</span>
            <span class="s1">name </span><span class="s3">= </span><span class="s1">type</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">).</span><span class="s1">__name__</span>
            <span class="s2">for </span><span class="s1">check </span><span class="s2">in </span><span class="s1">_yield_all_checks</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">):</span>
                <span class="s1">check </span><span class="s3">= </span><span class="s1">partial</span><span class="s3">(</span><span class="s1">check</span><span class="s3">, </span><span class="s1">name</span><span class="s3">)</span>
                <span class="s2">yield </span><span class="s1">_maybe_mark_xfail</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">check</span><span class="s3">, </span><span class="s1">pytest</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span>
        <span class="s4">&quot;estimator, check&quot;</span><span class="s3">, </span><span class="s1">checks_generator</span><span class="s3">(), </span><span class="s1">ids</span><span class="s3">=</span><span class="s1">_get_check_estimator_ids</span>
    <span class="s3">)</span>


<span class="s2">def </span><span class="s1">check_estimator</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">generate_only</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Check if estimator adheres to scikit-learn conventions. 
 
    This function will run an extensive test-suite for input validation, 
    shapes, etc, making sure that the estimator complies with `scikit-learn` 
    conventions as detailed in :ref:`rolling_your_own_estimator`. 
    Additional tests for classifiers, regressors, clustering or transformers 
    will be run if the Estimator class inherits from the corresponding mixin 
    from sklearn.base. 
 
    Setting `generate_only=True` returns a generator that yields (estimator, 
    check) tuples where the check can be called independently from each 
    other, i.e. `check(estimator)`. This allows all checks to be run 
    independently and report the checks that are failing. 
 
    scikit-learn provides a pytest specific decorator, 
    :func:`~sklearn.utils.estimator_checks.parametrize_with_checks`, making it 
    easier to test multiple estimators. 
 
    Parameters 
    ---------- 
    estimator : estimator object 
        Estimator instance to check. 
 
        .. versionadded:: 1.1 
           Passing a class was deprecated in version 0.23, and support for 
           classes was removed in 0.24. 
 
    generate_only : bool, default=False 
        When `False`, checks are evaluated when `check_estimator` is called. 
        When `True`, `check_estimator` returns a generator that yields 
        (estimator, check) tuples. The check is run by calling 
        `check(estimator)`. 
 
        .. versionadded:: 0.22 
 
    Returns 
    ------- 
    checks_generator : generator 
        Generator that yields (estimator, check) tuples. Returned when 
        `generate_only=True`. 
 
    See Also 
    -------- 
    parametrize_with_checks : Pytest specific decorator for parametrizing estimator 
        checks. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from sklearn.utils.estimator_checks import check_estimator 
    &gt;&gt;&gt; from sklearn.linear_model import LogisticRegression 
    &gt;&gt;&gt; check_estimator(LogisticRegression(), generate_only=True) 
    &lt;generator object ...&gt; 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">type</span><span class="s3">):</span>
        <span class="s1">msg </span><span class="s3">= (</span>
            <span class="s4">&quot;Passing a class was deprecated in version 0.23 &quot;</span>
            <span class="s4">&quot;and isn't supported anymore from 0.24.&quot;</span>
            <span class="s4">&quot;Please pass an instance instead.&quot;</span>
        <span class="s3">)</span>
        <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>

    <span class="s1">name </span><span class="s3">= </span><span class="s1">type</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">).</span><span class="s1">__name__</span>

    <span class="s2">def </span><span class="s1">checks_generator</span><span class="s3">():</span>
        <span class="s2">for </span><span class="s1">check </span><span class="s2">in </span><span class="s1">_yield_all_checks</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">):</span>
            <span class="s1">check </span><span class="s3">= </span><span class="s1">_maybe_skip</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">check</span><span class="s3">)</span>
            <span class="s2">yield </span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">partial</span><span class="s3">(</span><span class="s1">check</span><span class="s3">, </span><span class="s1">name</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">generate_only</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">checks_generator</span><span class="s3">()</span>

    <span class="s2">for </span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">check </span><span class="s2">in </span><span class="s1">checks_generator</span><span class="s3">():</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s1">check</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">)</span>
        <span class="s2">except </span><span class="s1">SkipTest </span><span class="s2">as </span><span class="s1">exception</span><span class="s3">:</span>
            <span class="s5"># SkipTest is thrown when pandas can't be imported, or by checks</span>
            <span class="s5"># that are in the xfail_checks tag</span>
            <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span><span class="s1">str</span><span class="s3">(</span><span class="s1">exception</span><span class="s3">), </span><span class="s1">SkipTestWarning</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">_regression_dataset</span><span class="s3">():</span>
    <span class="s2">global </span><span class="s1">REGRESSION_DATASET</span>
    <span class="s2">if </span><span class="s1">REGRESSION_DATASET </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">X</span><span class="s3">, </span><span class="s1">y </span><span class="s3">= </span><span class="s1">make_regression</span><span class="s3">(</span>
            <span class="s1">n_samples</span><span class="s3">=</span><span class="s6">200</span><span class="s3">,</span>
            <span class="s1">n_features</span><span class="s3">=</span><span class="s6">10</span><span class="s3">,</span>
            <span class="s1">n_informative</span><span class="s3">=</span><span class="s6">1</span><span class="s3">,</span>
            <span class="s1">bias</span><span class="s3">=</span><span class="s6">5.0</span><span class="s3">,</span>
            <span class="s1">noise</span><span class="s3">=</span><span class="s6">20</span><span class="s3">,</span>
            <span class="s1">random_state</span><span class="s3">=</span><span class="s6">42</span><span class="s3">,</span>
        <span class="s3">)</span>
        <span class="s1">X </span><span class="s3">= </span><span class="s1">StandardScaler</span><span class="s3">().</span><span class="s1">fit_transform</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
        <span class="s1">REGRESSION_DATASET </span><span class="s3">= </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span>
    <span class="s2">return </span><span class="s1">REGRESSION_DATASET</span>


<span class="s2">def </span><span class="s1">_set_checking_parameters</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">):</span>
    <span class="s5"># set parameters to speed up some estimators and</span>
    <span class="s5"># avoid deprecated behaviour</span>
    <span class="s1">params </span><span class="s3">= </span><span class="s1">estimator</span><span class="s3">.</span><span class="s1">get_params</span><span class="s3">()</span>
    <span class="s1">name </span><span class="s3">= </span><span class="s1">estimator</span><span class="s3">.</span><span class="s1">__class__</span><span class="s3">.</span><span class="s1">__name__</span>
    <span class="s2">if </span><span class="s1">name </span><span class="s3">== </span><span class="s4">&quot;TSNE&quot;</span><span class="s3">:</span>
        <span class="s1">estimator</span><span class="s3">.</span><span class="s1">set_params</span><span class="s3">(</span><span class="s1">perplexity</span><span class="s3">=</span><span class="s6">2</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s4">&quot;n_iter&quot; </span><span class="s2">in </span><span class="s1">params </span><span class="s2">and </span><span class="s1">name </span><span class="s3">!= </span><span class="s4">&quot;TSNE&quot;</span><span class="s3">:</span>
        <span class="s1">estimator</span><span class="s3">.</span><span class="s1">set_params</span><span class="s3">(</span><span class="s1">n_iter</span><span class="s3">=</span><span class="s6">5</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s4">&quot;max_iter&quot; </span><span class="s2">in </span><span class="s1">params</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">estimator</span><span class="s3">.</span><span class="s1">max_iter </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s1">estimator</span><span class="s3">.</span><span class="s1">set_params</span><span class="s3">(</span><span class="s1">max_iter</span><span class="s3">=</span><span class="s1">min</span><span class="s3">(</span><span class="s6">5</span><span class="s3">, </span><span class="s1">estimator</span><span class="s3">.</span><span class="s1">max_iter</span><span class="s3">))</span>
        <span class="s5"># LinearSVR, LinearSVC</span>
        <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s3">[</span><span class="s4">&quot;LinearSVR&quot;</span><span class="s3">, </span><span class="s4">&quot;LinearSVC&quot;</span><span class="s3">]:</span>
            <span class="s1">estimator</span><span class="s3">.</span><span class="s1">set_params</span><span class="s3">(</span><span class="s1">max_iter</span><span class="s3">=</span><span class="s6">20</span><span class="s3">)</span>
        <span class="s5"># NMF</span>
        <span class="s2">if </span><span class="s1">name </span><span class="s3">== </span><span class="s4">&quot;NMF&quot;</span><span class="s3">:</span>
            <span class="s1">estimator</span><span class="s3">.</span><span class="s1">set_params</span><span class="s3">(</span><span class="s1">max_iter</span><span class="s3">=</span><span class="s6">500</span><span class="s3">)</span>
        <span class="s5"># DictionaryLearning</span>
        <span class="s2">if </span><span class="s1">name </span><span class="s3">== </span><span class="s4">&quot;DictionaryLearning&quot;</span><span class="s3">:</span>
            <span class="s1">estimator</span><span class="s3">.</span><span class="s1">set_params</span><span class="s3">(</span><span class="s1">max_iter</span><span class="s3">=</span><span class="s6">20</span><span class="s3">, </span><span class="s1">transform_algorithm</span><span class="s3">=</span><span class="s4">&quot;lasso_lars&quot;</span><span class="s3">)</span>
        <span class="s5"># MiniBatchNMF</span>
        <span class="s2">if </span><span class="s1">estimator</span><span class="s3">.</span><span class="s1">__class__</span><span class="s3">.</span><span class="s1">__name__ </span><span class="s3">== </span><span class="s4">&quot;MiniBatchNMF&quot;</span><span class="s3">:</span>
            <span class="s1">estimator</span><span class="s3">.</span><span class="s1">set_params</span><span class="s3">(</span><span class="s1">max_iter</span><span class="s3">=</span><span class="s6">20</span><span class="s3">, </span><span class="s1">fresh_restarts</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
        <span class="s5"># MLP</span>
        <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s3">[</span><span class="s4">&quot;MLPClassifier&quot;</span><span class="s3">, </span><span class="s4">&quot;MLPRegressor&quot;</span><span class="s3">]:</span>
            <span class="s1">estimator</span><span class="s3">.</span><span class="s1">set_params</span><span class="s3">(</span><span class="s1">max_iter</span><span class="s3">=</span><span class="s6">100</span><span class="s3">)</span>
        <span class="s5"># MiniBatchDictionaryLearning</span>
        <span class="s2">if </span><span class="s1">name </span><span class="s3">== </span><span class="s4">&quot;MiniBatchDictionaryLearning&quot;</span><span class="s3">:</span>
            <span class="s1">estimator</span><span class="s3">.</span><span class="s1">set_params</span><span class="s3">(</span><span class="s1">max_iter</span><span class="s3">=</span><span class="s6">5</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s4">&quot;n_resampling&quot; </span><span class="s2">in </span><span class="s1">params</span><span class="s3">:</span>
        <span class="s5"># randomized lasso</span>
        <span class="s1">estimator</span><span class="s3">.</span><span class="s1">set_params</span><span class="s3">(</span><span class="s1">n_resampling</span><span class="s3">=</span><span class="s6">5</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s4">&quot;n_estimators&quot; </span><span class="s2">in </span><span class="s1">params</span><span class="s3">:</span>
        <span class="s1">estimator</span><span class="s3">.</span><span class="s1">set_params</span><span class="s3">(</span><span class="s1">n_estimators</span><span class="s3">=</span><span class="s1">min</span><span class="s3">(</span><span class="s6">5</span><span class="s3">, </span><span class="s1">estimator</span><span class="s3">.</span><span class="s1">n_estimators</span><span class="s3">))</span>
    <span class="s2">if </span><span class="s4">&quot;max_trials&quot; </span><span class="s2">in </span><span class="s1">params</span><span class="s3">:</span>
        <span class="s5"># RANSAC</span>
        <span class="s1">estimator</span><span class="s3">.</span><span class="s1">set_params</span><span class="s3">(</span><span class="s1">max_trials</span><span class="s3">=</span><span class="s6">10</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s4">&quot;n_init&quot; </span><span class="s2">in </span><span class="s1">params</span><span class="s3">:</span>
        <span class="s5"># K-Means</span>
        <span class="s1">estimator</span><span class="s3">.</span><span class="s1">set_params</span><span class="s3">(</span><span class="s1">n_init</span><span class="s3">=</span><span class="s6">2</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s4">&quot;batch_size&quot; </span><span class="s2">in </span><span class="s1">params </span><span class="s2">and not </span><span class="s1">name</span><span class="s3">.</span><span class="s1">startswith</span><span class="s3">(</span><span class="s4">&quot;MLP&quot;</span><span class="s3">):</span>
        <span class="s1">estimator</span><span class="s3">.</span><span class="s1">set_params</span><span class="s3">(</span><span class="s1">batch_size</span><span class="s3">=</span><span class="s6">10</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">name </span><span class="s3">== </span><span class="s4">&quot;MeanShift&quot;</span><span class="s3">:</span>
        <span class="s5"># In the case of check_fit2d_1sample, bandwidth is set to None and</span>
        <span class="s5"># is thus estimated. De facto it is 0.0 as a single sample is provided</span>
        <span class="s5"># and this makes the test fails. Hence we give it a placeholder value.</span>
        <span class="s1">estimator</span><span class="s3">.</span><span class="s1">set_params</span><span class="s3">(</span><span class="s1">bandwidth</span><span class="s3">=</span><span class="s6">1.0</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">name </span><span class="s3">== </span><span class="s4">&quot;TruncatedSVD&quot;</span><span class="s3">:</span>
        <span class="s5"># TruncatedSVD doesn't run with n_components = n_features</span>
        <span class="s5"># This is ugly :-/</span>
        <span class="s1">estimator</span><span class="s3">.</span><span class="s1">n_components </span><span class="s3">= </span><span class="s6">1</span>

    <span class="s2">if </span><span class="s1">name </span><span class="s3">== </span><span class="s4">&quot;LassoLarsIC&quot;</span><span class="s3">:</span>
        <span class="s5"># Noise variance estimation does not work when `n_samples &lt; n_features`.</span>
        <span class="s5"># We need to provide the noise variance explicitly.</span>
        <span class="s1">estimator</span><span class="s3">.</span><span class="s1">set_params</span><span class="s3">(</span><span class="s1">noise_variance</span><span class="s3">=</span><span class="s6">1.0</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s4">&quot;n_clusters&quot;</span><span class="s3">):</span>
        <span class="s1">estimator</span><span class="s3">.</span><span class="s1">n_clusters </span><span class="s3">= </span><span class="s1">min</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">.</span><span class="s1">n_clusters</span><span class="s3">, </span><span class="s6">2</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s4">&quot;n_best&quot;</span><span class="s3">):</span>
        <span class="s1">estimator</span><span class="s3">.</span><span class="s1">n_best </span><span class="s3">= </span><span class="s6">1</span>

    <span class="s2">if </span><span class="s1">name </span><span class="s3">== </span><span class="s4">&quot;SelectFdr&quot;</span><span class="s3">:</span>
        <span class="s5"># be tolerant of noisy datasets (not actually speed)</span>
        <span class="s1">estimator</span><span class="s3">.</span><span class="s1">set_params</span><span class="s3">(</span><span class="s1">alpha</span><span class="s3">=</span><span class="s6">0.5</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">name </span><span class="s3">== </span><span class="s4">&quot;TheilSenRegressor&quot;</span><span class="s3">:</span>
        <span class="s1">estimator</span><span class="s3">.</span><span class="s1">max_subpopulation </span><span class="s3">= </span><span class="s6">100</span>

    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">BaseRandomProjection</span><span class="s3">):</span>
        <span class="s5"># Due to the jl lemma and often very few samples, the number</span>
        <span class="s5"># of components of the random matrix projection will be probably</span>
        <span class="s5"># greater than the number of features.</span>
        <span class="s5"># So we impose a smaller number (avoid &quot;auto&quot; mode)</span>
        <span class="s1">estimator</span><span class="s3">.</span><span class="s1">set_params</span><span class="s3">(</span><span class="s1">n_components</span><span class="s3">=</span><span class="s6">2</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">SelectKBest</span><span class="s3">):</span>
        <span class="s5"># SelectKBest has a default of k=10</span>
        <span class="s5"># which is more feature than we have in most case.</span>
        <span class="s1">estimator</span><span class="s3">.</span><span class="s1">set_params</span><span class="s3">(</span><span class="s1">k</span><span class="s3">=</span><span class="s6">1</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s3">(</span><span class="s4">&quot;HistGradientBoostingClassifier&quot;</span><span class="s3">, </span><span class="s4">&quot;HistGradientBoostingRegressor&quot;</span><span class="s3">):</span>
        <span class="s5"># The default min_samples_leaf (20) isn't appropriate for small</span>
        <span class="s5"># datasets (only very shallow trees are built) that the checks use.</span>
        <span class="s1">estimator</span><span class="s3">.</span><span class="s1">set_params</span><span class="s3">(</span><span class="s1">min_samples_leaf</span><span class="s3">=</span><span class="s6">5</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">name </span><span class="s3">== </span><span class="s4">&quot;DummyClassifier&quot;</span><span class="s3">:</span>
        <span class="s5"># the default strategy prior would output constant predictions and fail</span>
        <span class="s5"># for check_classifiers_predictions</span>
        <span class="s1">estimator</span><span class="s3">.</span><span class="s1">set_params</span><span class="s3">(</span><span class="s1">strategy</span><span class="s3">=</span><span class="s4">&quot;stratified&quot;</span><span class="s3">)</span>

    <span class="s5"># Speed-up by reducing the number of CV or splits for CV estimators</span>
    <span class="s1">loo_cv </span><span class="s3">= [</span><span class="s4">&quot;RidgeCV&quot;</span><span class="s3">, </span><span class="s4">&quot;RidgeClassifierCV&quot;</span><span class="s3">]</span>
    <span class="s2">if </span><span class="s1">name </span><span class="s2">not in </span><span class="s1">loo_cv </span><span class="s2">and </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s4">&quot;cv&quot;</span><span class="s3">):</span>
        <span class="s1">estimator</span><span class="s3">.</span><span class="s1">set_params</span><span class="s3">(</span><span class="s1">cv</span><span class="s3">=</span><span class="s6">3</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s4">&quot;n_splits&quot;</span><span class="s3">):</span>
        <span class="s1">estimator</span><span class="s3">.</span><span class="s1">set_params</span><span class="s3">(</span><span class="s1">n_splits</span><span class="s3">=</span><span class="s6">3</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">name </span><span class="s3">== </span><span class="s4">&quot;OneHotEncoder&quot;</span><span class="s3">:</span>
        <span class="s1">estimator</span><span class="s3">.</span><span class="s1">set_params</span><span class="s3">(</span><span class="s1">handle_unknown</span><span class="s3">=</span><span class="s4">&quot;ignore&quot;</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">name </span><span class="s3">== </span><span class="s4">&quot;QuantileRegressor&quot;</span><span class="s3">:</span>
        <span class="s5"># Avoid warning due to Scipy deprecating interior-point solver</span>
        <span class="s1">solver </span><span class="s3">= </span><span class="s4">&quot;highs&quot; </span><span class="s2">if </span><span class="s1">sp_version </span><span class="s3">&gt;= </span><span class="s1">parse_version</span><span class="s3">(</span><span class="s4">&quot;1.6.0&quot;</span><span class="s3">) </span><span class="s2">else </span><span class="s4">&quot;interior-point&quot;</span>
        <span class="s1">estimator</span><span class="s3">.</span><span class="s1">set_params</span><span class="s3">(</span><span class="s1">solver</span><span class="s3">=</span><span class="s1">solver</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">CROSS_DECOMPOSITION</span><span class="s3">:</span>
        <span class="s1">estimator</span><span class="s3">.</span><span class="s1">set_params</span><span class="s3">(</span><span class="s1">n_components</span><span class="s3">=</span><span class="s6">1</span><span class="s3">)</span>

    <span class="s5"># Default &quot;auto&quot; parameter can lead to different ordering of eigenvalues on</span>
    <span class="s5"># windows: #24105</span>
    <span class="s2">if </span><span class="s1">name </span><span class="s3">== </span><span class="s4">&quot;SpectralEmbedding&quot;</span><span class="s3">:</span>
        <span class="s1">estimator</span><span class="s3">.</span><span class="s1">set_params</span><span class="s3">(</span><span class="s1">eigen_tol</span><span class="s3">=</span><span class="s6">1e-5</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">name </span><span class="s3">== </span><span class="s4">&quot;HDBSCAN&quot;</span><span class="s3">:</span>
        <span class="s1">estimator</span><span class="s3">.</span><span class="s1">set_params</span><span class="s3">(</span><span class="s1">min_samples</span><span class="s3">=</span><span class="s6">1</span><span class="s3">)</span>


<span class="s2">class </span><span class="s1">_NotAnArray</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot;An object that is convertible to an array. 
 
    Parameters 
    ---------- 
    data : array-like 
        The data. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">data</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">data </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">data</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__array__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">data</span>

    <span class="s2">def </span><span class="s1">__array_function__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">func</span><span class="s3">, </span><span class="s1">types</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">kwargs</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">func</span><span class="s3">.</span><span class="s1">__name__ </span><span class="s3">== </span><span class="s4">&quot;may_share_memory&quot;</span><span class="s3">:</span>
            <span class="s2">return True</span>
        <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s4">&quot;Don't want to call array_function {}!&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">func</span><span class="s3">.</span><span class="s1">__name__</span><span class="s3">))</span>


<span class="s2">def </span><span class="s1">_is_pairwise_metric</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Returns True if estimator accepts pairwise metric. 
 
    Parameters 
    ---------- 
    estimator : object 
        Estimator object to test. 
 
    Returns 
    ------- 
    out : bool 
        True if _pairwise is set to True and False otherwise. 
    &quot;&quot;&quot;</span>
    <span class="s1">metric </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s4">&quot;metric&quot;</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">bool</span><span class="s3">(</span><span class="s1">metric </span><span class="s3">== </span><span class="s4">&quot;precomputed&quot;</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">_generate_sparse_data</span><span class="s3">(</span><span class="s1">X_csr</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Generate sparse matrices or arrays with {32,64}bit indices of diverse format. 
 
    Parameters 
    ---------- 
    X_csr: scipy.sparse.csr_matrix or scipy.sparse.csr_array 
        Input in CSR format. 
 
    Returns 
    ------- 
    out: iter(Matrices) or iter(Arrays) 
        In format['dok', 'lil', 'dia', 'bsr', 'csr', 'csc', 'coo', 
        'coo_64', 'csc_64', 'csr_64'] 
    &quot;&quot;&quot;</span>

    <span class="s2">assert </span><span class="s1">X_csr</span><span class="s3">.</span><span class="s1">format </span><span class="s3">== </span><span class="s4">&quot;csr&quot;</span>
    <span class="s2">yield </span><span class="s4">&quot;csr&quot;</span><span class="s3">, </span><span class="s1">X_csr</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>
    <span class="s2">for </span><span class="s1">sparse_format </span><span class="s2">in </span><span class="s3">[</span><span class="s4">&quot;dok&quot;</span><span class="s3">, </span><span class="s4">&quot;lil&quot;</span><span class="s3">, </span><span class="s4">&quot;dia&quot;</span><span class="s3">, </span><span class="s4">&quot;bsr&quot;</span><span class="s3">, </span><span class="s4">&quot;csc&quot;</span><span class="s3">, </span><span class="s4">&quot;coo&quot;</span><span class="s3">]:</span>
        <span class="s2">yield </span><span class="s1">sparse_format</span><span class="s3">, </span><span class="s1">X_csr</span><span class="s3">.</span><span class="s1">asformat</span><span class="s3">(</span><span class="s1">sparse_format</span><span class="s3">)</span>

    <span class="s5"># Generate large indices matrix only if its supported by scipy</span>
    <span class="s1">X_coo </span><span class="s3">= </span><span class="s1">X_csr</span><span class="s3">.</span><span class="s1">asformat</span><span class="s3">(</span><span class="s4">&quot;coo&quot;</span><span class="s3">)</span>
    <span class="s1">X_coo</span><span class="s3">.</span><span class="s1">row </span><span class="s3">= </span><span class="s1">X_coo</span><span class="s3">.</span><span class="s1">row</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s4">&quot;int64&quot;</span><span class="s3">)</span>
    <span class="s1">X_coo</span><span class="s3">.</span><span class="s1">col </span><span class="s3">= </span><span class="s1">X_coo</span><span class="s3">.</span><span class="s1">col</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s4">&quot;int64&quot;</span><span class="s3">)</span>
    <span class="s2">yield </span><span class="s4">&quot;coo_64&quot;</span><span class="s3">, </span><span class="s1">X_coo</span>

    <span class="s2">for </span><span class="s1">sparse_format </span><span class="s2">in </span><span class="s3">[</span><span class="s4">&quot;csc&quot;</span><span class="s3">, </span><span class="s4">&quot;csr&quot;</span><span class="s3">]:</span>
        <span class="s1">X </span><span class="s3">= </span><span class="s1">X_csr</span><span class="s3">.</span><span class="s1">asformat</span><span class="s3">(</span><span class="s1">sparse_format</span><span class="s3">)</span>
        <span class="s1">X</span><span class="s3">.</span><span class="s1">indices </span><span class="s3">= </span><span class="s1">X</span><span class="s3">.</span><span class="s1">indices</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s4">&quot;int64&quot;</span><span class="s3">)</span>
        <span class="s1">X</span><span class="s3">.</span><span class="s1">indptr </span><span class="s3">= </span><span class="s1">X</span><span class="s3">.</span><span class="s1">indptr</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s4">&quot;int64&quot;</span><span class="s3">)</span>
        <span class="s2">yield </span><span class="s1">sparse_format </span><span class="s3">+ </span><span class="s4">&quot;_64&quot;</span><span class="s3">, </span><span class="s1">X</span>


<span class="s2">def </span><span class="s1">check_array_api_input</span><span class="s3">(</span>
    <span class="s1">name</span><span class="s3">,</span>
    <span class="s1">estimator_orig</span><span class="s3">,</span>
    <span class="s1">array_namespace</span><span class="s3">,</span>
    <span class="s1">device</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">dtype_name</span><span class="s3">=</span><span class="s4">&quot;float64&quot;</span><span class="s3">,</span>
    <span class="s1">check_values</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
<span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Check that the estimator can work consistently with the Array API 
 
    By default, this just checks that the types and shapes of the arrays are 
    consistent with calling the same estimator with numpy arrays. 
 
    When check_values is True, it also checks that calling the estimator on the 
    array_api Array gives the same results as ndarrays. 
    &quot;&quot;&quot;</span>
    <span class="s1">xp </span><span class="s3">= </span><span class="s1">_array_api_for_tests</span><span class="s3">(</span><span class="s1">array_namespace</span><span class="s3">, </span><span class="s1">device</span><span class="s3">)</span>

    <span class="s1">X</span><span class="s3">, </span><span class="s1">y </span><span class="s3">= </span><span class="s1">make_classification</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">=</span><span class="s6">42</span><span class="s3">)</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">X</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">dtype_name</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>

    <span class="s1">X </span><span class="s3">= </span><span class="s1">_enforce_estimator_tags_X</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">, </span><span class="s1">X</span><span class="s3">)</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">_enforce_estimator_tags_y</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>

    <span class="s1">est </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">)</span>

    <span class="s1">X_xp </span><span class="s3">= </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">device</span><span class="s3">=</span><span class="s1">device</span><span class="s3">)</span>
    <span class="s1">y_xp </span><span class="s3">= </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">y</span><span class="s3">, </span><span class="s1">device</span><span class="s3">=</span><span class="s1">device</span><span class="s3">)</span>

    <span class="s1">est</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>

    <span class="s1">array_attributes </span><span class="s3">= {</span>
        <span class="s1">key</span><span class="s3">: </span><span class="s1">value </span><span class="s2">for </span><span class="s1">key</span><span class="s3">, </span><span class="s1">value </span><span class="s2">in </span><span class="s1">vars</span><span class="s3">(</span><span class="s1">est</span><span class="s3">).</span><span class="s1">items</span><span class="s3">() </span><span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndarray</span><span class="s3">)</span>
    <span class="s3">}</span>

    <span class="s1">est_xp </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">est</span><span class="s3">)</span>
    <span class="s2">with </span><span class="s1">config_context</span><span class="s3">(</span><span class="s1">array_api_dispatch</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
        <span class="s1">est_xp</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X_xp</span><span class="s3">, </span><span class="s1">y_xp</span><span class="s3">)</span>
        <span class="s1">input_ns </span><span class="s3">= </span><span class="s1">get_namespace</span><span class="s3">(</span><span class="s1">X_xp</span><span class="s3">)[</span><span class="s6">0</span><span class="s3">].</span><span class="s1">__name__</span>

    <span class="s5"># Fitted attributes which are arrays must have the same</span>
    <span class="s5"># namespace as the one of the training data.</span>
    <span class="s2">for </span><span class="s1">key</span><span class="s3">, </span><span class="s1">attribute </span><span class="s2">in </span><span class="s1">array_attributes</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
        <span class="s1">est_xp_param </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">est_xp</span><span class="s3">, </span><span class="s1">key</span><span class="s3">)</span>
        <span class="s2">with </span><span class="s1">config_context</span><span class="s3">(</span><span class="s1">array_api_dispatch</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
            <span class="s1">attribute_ns </span><span class="s3">= </span><span class="s1">get_namespace</span><span class="s3">(</span><span class="s1">est_xp_param</span><span class="s3">)[</span><span class="s6">0</span><span class="s3">].</span><span class="s1">__name__</span>
        <span class="s2">assert </span><span class="s1">attribute_ns </span><span class="s3">== </span><span class="s1">input_ns</span><span class="s3">, (</span>
            <span class="s4">f&quot;'</span><span class="s2">{</span><span class="s1">key</span><span class="s2">}</span><span class="s4">' attribute is in wrong namespace, expected </span><span class="s2">{</span><span class="s1">input_ns</span><span class="s2">} </span><span class="s4">&quot;</span>
            <span class="s4">f&quot;got </span><span class="s2">{</span><span class="s1">attribute_ns</span><span class="s2">}</span><span class="s4">&quot;</span>
        <span class="s3">)</span>

        <span class="s2">assert </span><span class="s1">array_device</span><span class="s3">(</span><span class="s1">est_xp_param</span><span class="s3">) == </span><span class="s1">array_device</span><span class="s3">(</span><span class="s1">X_xp</span><span class="s3">)</span>

        <span class="s1">est_xp_param_np </span><span class="s3">= </span><span class="s1">_convert_to_numpy</span><span class="s3">(</span><span class="s1">est_xp_param</span><span class="s3">, </span><span class="s1">xp</span><span class="s3">=</span><span class="s1">xp</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">check_values</span><span class="s3">:</span>
            <span class="s1">assert_allclose</span><span class="s3">(</span>
                <span class="s1">attribute</span><span class="s3">,</span>
                <span class="s1">est_xp_param_np</span><span class="s3">,</span>
                <span class="s1">err_msg</span><span class="s3">=</span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">key</span><span class="s2">} </span><span class="s4">not the same&quot;</span><span class="s3">,</span>
                <span class="s1">atol</span><span class="s3">=</span><span class="s1">_atol_for_type</span><span class="s3">(</span><span class="s1">X</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">),</span>
            <span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">assert </span><span class="s1">attribute</span><span class="s3">.</span><span class="s1">shape </span><span class="s3">== </span><span class="s1">est_xp_param_np</span><span class="s3">.</span><span class="s1">shape</span>
            <span class="s2">assert </span><span class="s1">attribute</span><span class="s3">.</span><span class="s1">dtype </span><span class="s3">== </span><span class="s1">est_xp_param_np</span><span class="s3">.</span><span class="s1">dtype</span>

    <span class="s5"># Check estimator methods, if supported, give the same results</span>
    <span class="s1">methods </span><span class="s3">= (</span>
        <span class="s4">&quot;score&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;score_samples&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;decision_function&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;predict&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;predict_log_proba&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;predict_proba&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;transform&quot;</span><span class="s3">,</span>
    <span class="s3">)</span>

    <span class="s2">for </span><span class="s1">method_name </span><span class="s2">in </span><span class="s1">methods</span><span class="s3">:</span>
        <span class="s1">method </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">est</span><span class="s3">, </span><span class="s1">method_name</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">method </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s2">continue</span>

        <span class="s2">if </span><span class="s1">method_name </span><span class="s3">== </span><span class="s4">&quot;score&quot;</span><span class="s3">:</span>
            <span class="s1">result </span><span class="s3">= </span><span class="s1">method</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
            <span class="s2">with </span><span class="s1">config_context</span><span class="s3">(</span><span class="s1">array_api_dispatch</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
                <span class="s1">result_xp </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">est_xp</span><span class="s3">, </span><span class="s1">method_name</span><span class="s3">)(</span><span class="s1">X_xp</span><span class="s3">, </span><span class="s1">y_xp</span><span class="s3">)</span>
            <span class="s5"># score typically returns a Python float</span>
            <span class="s2">assert </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">result</span><span class="s3">, </span><span class="s1">float</span><span class="s3">)</span>
            <span class="s2">assert </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">result_xp</span><span class="s3">, </span><span class="s1">float</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">check_values</span><span class="s3">:</span>
                <span class="s2">assert </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">result </span><span class="s3">- </span><span class="s1">result_xp</span><span class="s3">) &lt; </span><span class="s1">_atol_for_type</span><span class="s3">(</span><span class="s1">X</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>
            <span class="s2">continue</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">result </span><span class="s3">= </span><span class="s1">method</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
            <span class="s2">with </span><span class="s1">config_context</span><span class="s3">(</span><span class="s1">array_api_dispatch</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
                <span class="s1">result_xp </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">est_xp</span><span class="s3">, </span><span class="s1">method_name</span><span class="s3">)(</span><span class="s1">X_xp</span><span class="s3">)</span>

        <span class="s2">with </span><span class="s1">config_context</span><span class="s3">(</span><span class="s1">array_api_dispatch</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
            <span class="s1">result_ns </span><span class="s3">= </span><span class="s1">get_namespace</span><span class="s3">(</span><span class="s1">result_xp</span><span class="s3">)[</span><span class="s6">0</span><span class="s3">].</span><span class="s1">__name__</span>
        <span class="s2">assert </span><span class="s1">result_ns </span><span class="s3">== </span><span class="s1">input_ns</span><span class="s3">, (</span>
            <span class="s4">f&quot;'</span><span class="s2">{</span><span class="s1">method</span><span class="s2">}</span><span class="s4">' output is in wrong namespace, expected </span><span class="s2">{</span><span class="s1">input_ns</span><span class="s2">}</span><span class="s4">, &quot;</span>
            <span class="s4">f&quot;got </span><span class="s2">{</span><span class="s1">result_ns</span><span class="s2">}</span><span class="s4">.&quot;</span>
        <span class="s3">)</span>

        <span class="s2">assert </span><span class="s1">array_device</span><span class="s3">(</span><span class="s1">result_xp</span><span class="s3">) == </span><span class="s1">array_device</span><span class="s3">(</span><span class="s1">X_xp</span><span class="s3">)</span>
        <span class="s1">result_xp_np </span><span class="s3">= </span><span class="s1">_convert_to_numpy</span><span class="s3">(</span><span class="s1">result_xp</span><span class="s3">, </span><span class="s1">xp</span><span class="s3">=</span><span class="s1">xp</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">check_values</span><span class="s3">:</span>
            <span class="s1">assert_allclose</span><span class="s3">(</span>
                <span class="s1">result</span><span class="s3">,</span>
                <span class="s1">result_xp_np</span><span class="s3">,</span>
                <span class="s1">err_msg</span><span class="s3">=</span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">method</span><span class="s2">} </span><span class="s4">did not the return the same result&quot;</span><span class="s3">,</span>
                <span class="s1">atol</span><span class="s3">=</span><span class="s1">_atol_for_type</span><span class="s3">(</span><span class="s1">X</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">),</span>
            <span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">result</span><span class="s3">, </span><span class="s4">&quot;shape&quot;</span><span class="s3">):</span>
                <span class="s2">assert </span><span class="s1">result</span><span class="s3">.</span><span class="s1">shape </span><span class="s3">== </span><span class="s1">result_xp_np</span><span class="s3">.</span><span class="s1">shape</span>
                <span class="s2">assert </span><span class="s1">result</span><span class="s3">.</span><span class="s1">dtype </span><span class="s3">== </span><span class="s1">result_xp_np</span><span class="s3">.</span><span class="s1">dtype</span>

        <span class="s2">if </span><span class="s1">method_name </span><span class="s3">== </span><span class="s4">&quot;transform&quot; </span><span class="s2">and </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">est</span><span class="s3">, </span><span class="s4">&quot;inverse_transform&quot;</span><span class="s3">):</span>
            <span class="s1">inverse_result </span><span class="s3">= </span><span class="s1">est</span><span class="s3">.</span><span class="s1">inverse_transform</span><span class="s3">(</span><span class="s1">result</span><span class="s3">)</span>
            <span class="s2">with </span><span class="s1">config_context</span><span class="s3">(</span><span class="s1">array_api_dispatch</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
                <span class="s1">invese_result_xp </span><span class="s3">= </span><span class="s1">est_xp</span><span class="s3">.</span><span class="s1">inverse_transform</span><span class="s3">(</span><span class="s1">result_xp</span><span class="s3">)</span>
                <span class="s1">inverse_result_ns </span><span class="s3">= </span><span class="s1">get_namespace</span><span class="s3">(</span><span class="s1">invese_result_xp</span><span class="s3">)[</span><span class="s6">0</span><span class="s3">].</span><span class="s1">__name__</span>
            <span class="s2">assert </span><span class="s1">inverse_result_ns </span><span class="s3">== </span><span class="s1">input_ns</span><span class="s3">, (</span>
                <span class="s4">&quot;'inverse_transform' output is in wrong namespace, expected&quot;</span>
                <span class="s4">f&quot; </span><span class="s2">{</span><span class="s1">input_ns</span><span class="s2">}</span><span class="s4">, got </span><span class="s2">{</span><span class="s1">inverse_result_ns</span><span class="s2">}</span><span class="s4">.&quot;</span>
            <span class="s3">)</span>

            <span class="s2">assert </span><span class="s1">array_device</span><span class="s3">(</span><span class="s1">invese_result_xp</span><span class="s3">) == </span><span class="s1">array_device</span><span class="s3">(</span><span class="s1">X_xp</span><span class="s3">)</span>

            <span class="s1">invese_result_xp_np </span><span class="s3">= </span><span class="s1">_convert_to_numpy</span><span class="s3">(</span><span class="s1">invese_result_xp</span><span class="s3">, </span><span class="s1">xp</span><span class="s3">=</span><span class="s1">xp</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">check_values</span><span class="s3">:</span>
                <span class="s1">assert_allclose</span><span class="s3">(</span>
                    <span class="s1">inverse_result</span><span class="s3">,</span>
                    <span class="s1">invese_result_xp_np</span><span class="s3">,</span>
                    <span class="s1">err_msg</span><span class="s3">=</span><span class="s4">&quot;inverse_transform did not the return the same result&quot;</span><span class="s3">,</span>
                    <span class="s1">atol</span><span class="s3">=</span><span class="s1">_atol_for_type</span><span class="s3">(</span><span class="s1">X</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">),</span>
                <span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s2">assert </span><span class="s1">inverse_result</span><span class="s3">.</span><span class="s1">shape </span><span class="s3">== </span><span class="s1">invese_result_xp_np</span><span class="s3">.</span><span class="s1">shape</span>
                <span class="s2">assert </span><span class="s1">inverse_result</span><span class="s3">.</span><span class="s1">dtype </span><span class="s3">== </span><span class="s1">invese_result_xp_np</span><span class="s3">.</span><span class="s1">dtype</span>


<span class="s2">def </span><span class="s1">check_array_api_input_and_values</span><span class="s3">(</span>
    <span class="s1">name</span><span class="s3">,</span>
    <span class="s1">estimator_orig</span><span class="s3">,</span>
    <span class="s1">array_namespace</span><span class="s3">,</span>
    <span class="s1">device</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">dtype_name</span><span class="s3">=</span><span class="s4">&quot;float64&quot;</span><span class="s3">,</span>
<span class="s3">):</span>
    <span class="s2">return </span><span class="s1">check_array_api_input</span><span class="s3">(</span>
        <span class="s1">name</span><span class="s3">,</span>
        <span class="s1">estimator_orig</span><span class="s3">,</span>
        <span class="s1">array_namespace</span><span class="s3">=</span><span class="s1">array_namespace</span><span class="s3">,</span>
        <span class="s1">device</span><span class="s3">=</span><span class="s1">device</span><span class="s3">,</span>
        <span class="s1">dtype_name</span><span class="s3">=</span><span class="s1">dtype_name</span><span class="s3">,</span>
        <span class="s1">check_values</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
    <span class="s3">)</span>


<span class="s2">def </span><span class="s1">_check_estimator_sparse_container</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">estimator_orig</span><span class="s3">, </span><span class="s1">sparse_type</span><span class="s3">):</span>
    <span class="s1">rng </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">RandomState</span><span class="s3">(</span><span class="s6">0</span><span class="s3">)</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">rng</span><span class="s3">.</span><span class="s1">uniform</span><span class="s3">(</span><span class="s1">size</span><span class="s3">=(</span><span class="s6">40</span><span class="s3">, </span><span class="s6">3</span><span class="s3">))</span>
    <span class="s1">X</span><span class="s3">[</span><span class="s1">X </span><span class="s3">&lt; </span><span class="s6">0.6</span><span class="s3">] = </span><span class="s6">0</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">_enforce_estimator_tags_X</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">, </span><span class="s1">X</span><span class="s3">)</span>
    <span class="s1">y </span><span class="s3">= (</span><span class="s6">4 </span><span class="s3">* </span><span class="s1">rng</span><span class="s3">.</span><span class="s1">uniform</span><span class="s3">(</span><span class="s1">size</span><span class="s3">=</span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s6">0</span><span class="s3">])).</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">int32</span><span class="s3">)</span>
    <span class="s5"># catch deprecation warnings</span>
    <span class="s2">with </span><span class="s1">ignore_warnings</span><span class="s3">(</span><span class="s1">category</span><span class="s3">=</span><span class="s1">FutureWarning</span><span class="s3">):</span>
        <span class="s1">estimator </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">)</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">_enforce_estimator_tags_y</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
    <span class="s1">tags </span><span class="s3">= </span><span class="s1">_safe_tags</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">)</span>
    <span class="s2">for </span><span class="s1">matrix_format</span><span class="s3">, </span><span class="s1">X </span><span class="s2">in </span><span class="s1">_generate_sparse_data</span><span class="s3">(</span><span class="s1">sparse_type</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)):</span>
        <span class="s5"># catch deprecation warnings</span>
        <span class="s2">with </span><span class="s1">ignore_warnings</span><span class="s3">(</span><span class="s1">category</span><span class="s3">=</span><span class="s1">FutureWarning</span><span class="s3">):</span>
            <span class="s1">estimator </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s3">[</span><span class="s4">&quot;Scaler&quot;</span><span class="s3">, </span><span class="s4">&quot;StandardScaler&quot;</span><span class="s3">]:</span>
                <span class="s1">estimator</span><span class="s3">.</span><span class="s1">set_params</span><span class="s3">(</span><span class="s1">with_mean</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
        <span class="s5"># fit and predict</span>
        <span class="s2">if </span><span class="s4">&quot;64&quot; </span><span class="s2">in </span><span class="s1">matrix_format</span><span class="s3">:</span>
            <span class="s1">err_msg </span><span class="s3">= (</span>
                <span class="s4">f&quot;Estimator </span><span class="s2">{</span><span class="s1">name</span><span class="s2">} </span><span class="s4">doesn't seem to support </span><span class="s2">{</span><span class="s1">matrix_format</span><span class="s2">} </span><span class="s4">&quot;</span>
                <span class="s4">&quot;matrix, and is not failing gracefully, e.g. by using &quot;</span>
                <span class="s4">&quot;check_array(X, accept_large_sparse=False).&quot;</span>
            <span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">err_msg </span><span class="s3">= (</span>
                <span class="s4">f&quot;Estimator </span><span class="s2">{</span><span class="s1">name</span><span class="s2">} </span><span class="s4">doesn't seem to fail gracefully on sparse &quot;</span>
                <span class="s4">&quot;data: error message should state explicitly that sparse &quot;</span>
                <span class="s4">&quot;input is not supported if this is not the case, e.g. by using &quot;</span>
                <span class="s4">&quot;check_array(X, accept_sparse=False).&quot;</span>
            <span class="s3">)</span>
        <span class="s2">with </span><span class="s1">raises</span><span class="s3">(</span>
            <span class="s3">(</span><span class="s1">TypeError</span><span class="s3">, </span><span class="s1">ValueError</span><span class="s3">),</span>
            <span class="s1">match</span><span class="s3">=[</span><span class="s4">&quot;sparse&quot;</span><span class="s3">, </span><span class="s4">&quot;Sparse&quot;</span><span class="s3">],</span>
            <span class="s1">may_pass</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
            <span class="s1">err_msg</span><span class="s3">=</span><span class="s1">err_msg</span><span class="s3">,</span>
        <span class="s3">):</span>
            <span class="s2">with </span><span class="s1">ignore_warnings</span><span class="s3">(</span><span class="s1">category</span><span class="s3">=</span><span class="s1">FutureWarning</span><span class="s3">):</span>
                <span class="s1">estimator</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s4">&quot;predict&quot;</span><span class="s3">):</span>
                <span class="s1">pred </span><span class="s3">= </span><span class="s1">estimator</span><span class="s3">.</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
                <span class="s2">if </span><span class="s1">tags</span><span class="s3">[</span><span class="s4">&quot;multioutput_only&quot;</span><span class="s3">]:</span>
                    <span class="s2">assert </span><span class="s1">pred</span><span class="s3">.</span><span class="s1">shape </span><span class="s3">== (</span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s6">0</span><span class="s3">], </span><span class="s6">1</span><span class="s3">)</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s2">assert </span><span class="s1">pred</span><span class="s3">.</span><span class="s1">shape </span><span class="s3">== (</span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s6">0</span><span class="s3">],)</span>
            <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s4">&quot;predict_proba&quot;</span><span class="s3">):</span>
                <span class="s1">probs </span><span class="s3">= </span><span class="s1">estimator</span><span class="s3">.</span><span class="s1">predict_proba</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
                <span class="s2">if </span><span class="s1">tags</span><span class="s3">[</span><span class="s4">&quot;binary_only&quot;</span><span class="s3">]:</span>
                    <span class="s1">expected_probs_shape </span><span class="s3">= (</span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s6">0</span><span class="s3">], </span><span class="s6">2</span><span class="s3">)</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">expected_probs_shape </span><span class="s3">= (</span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s6">0</span><span class="s3">], </span><span class="s6">4</span><span class="s3">)</span>
                <span class="s2">assert </span><span class="s1">probs</span><span class="s3">.</span><span class="s1">shape </span><span class="s3">== </span><span class="s1">expected_probs_shape</span>


<span class="s2">def </span><span class="s1">check_estimator_sparse_matrix</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">estimator_orig</span><span class="s3">):</span>
    <span class="s1">_check_estimator_sparse_container</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">estimator_orig</span><span class="s3">, </span><span class="s1">sparse</span><span class="s3">.</span><span class="s1">csr_matrix</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">check_estimator_sparse_array</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">estimator_orig</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">SPARSE_ARRAY_PRESENT</span><span class="s3">:</span>
        <span class="s1">_check_estimator_sparse_container</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">estimator_orig</span><span class="s3">, </span><span class="s1">sparse</span><span class="s3">.</span><span class="s1">csr_array</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">ignore_warnings</span><span class="s3">(</span><span class="s1">category</span><span class="s3">=</span><span class="s1">FutureWarning</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">check_sample_weights_pandas_series</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">estimator_orig</span><span class="s3">):</span>
    <span class="s5"># check that estimators will accept a 'sample_weight' parameter of</span>
    <span class="s5"># type pandas.Series in the 'fit' function.</span>
    <span class="s1">estimator </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">)</span>
    <span class="s2">try</span><span class="s3">:</span>
        <span class="s2">import </span><span class="s1">pandas </span><span class="s2">as </span><span class="s1">pd</span>

        <span class="s1">X </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span>
            <span class="s3">[</span>
                <span class="s3">[</span><span class="s6">1</span><span class="s3">, </span><span class="s6">1</span><span class="s3">],</span>
                <span class="s3">[</span><span class="s6">1</span><span class="s3">, </span><span class="s6">2</span><span class="s3">],</span>
                <span class="s3">[</span><span class="s6">1</span><span class="s3">, </span><span class="s6">3</span><span class="s3">],</span>
                <span class="s3">[</span><span class="s6">1</span><span class="s3">, </span><span class="s6">4</span><span class="s3">],</span>
                <span class="s3">[</span><span class="s6">2</span><span class="s3">, </span><span class="s6">1</span><span class="s3">],</span>
                <span class="s3">[</span><span class="s6">2</span><span class="s3">, </span><span class="s6">2</span><span class="s3">],</span>
                <span class="s3">[</span><span class="s6">2</span><span class="s3">, </span><span class="s6">3</span><span class="s3">],</span>
                <span class="s3">[</span><span class="s6">2</span><span class="s3">, </span><span class="s6">4</span><span class="s3">],</span>
                <span class="s3">[</span><span class="s6">3</span><span class="s3">, </span><span class="s6">1</span><span class="s3">],</span>
                <span class="s3">[</span><span class="s6">3</span><span class="s3">, </span><span class="s6">2</span><span class="s3">],</span>
                <span class="s3">[</span><span class="s6">3</span><span class="s3">, </span><span class="s6">3</span><span class="s3">],</span>
                <span class="s3">[</span><span class="s6">3</span><span class="s3">, </span><span class="s6">4</span><span class="s3">],</span>
            <span class="s3">]</span>
        <span class="s3">)</span>
        <span class="s1">X </span><span class="s3">= </span><span class="s1">pd</span><span class="s3">.</span><span class="s1">DataFrame</span><span class="s3">(</span><span class="s1">_enforce_estimator_tags_X</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">, </span><span class="s1">X</span><span class="s3">), </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
        <span class="s1">y </span><span class="s3">= </span><span class="s1">pd</span><span class="s3">.</span><span class="s1">Series</span><span class="s3">([</span><span class="s6">1</span><span class="s3">, </span><span class="s6">1</span><span class="s3">, </span><span class="s6">1</span><span class="s3">, </span><span class="s6">1</span><span class="s3">, </span><span class="s6">2</span><span class="s3">, </span><span class="s6">2</span><span class="s3">, </span><span class="s6">2</span><span class="s3">, </span><span class="s6">2</span><span class="s3">, </span><span class="s6">1</span><span class="s3">, </span><span class="s6">1</span><span class="s3">, </span><span class="s6">2</span><span class="s3">, </span><span class="s6">2</span><span class="s3">])</span>
        <span class="s1">weights </span><span class="s3">= </span><span class="s1">pd</span><span class="s3">.</span><span class="s1">Series</span><span class="s3">([</span><span class="s6">1</span><span class="s3">] * </span><span class="s6">12</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">_safe_tags</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">key</span><span class="s3">=</span><span class="s4">&quot;multioutput_only&quot;</span><span class="s3">):</span>
            <span class="s1">y </span><span class="s3">= </span><span class="s1">pd</span><span class="s3">.</span><span class="s1">DataFrame</span><span class="s3">(</span><span class="s1">y</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s1">estimator</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">sample_weight</span><span class="s3">=</span><span class="s1">weights</span><span class="s3">)</span>
        <span class="s2">except </span><span class="s1">ValueError</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span>
                <span class="s4">&quot;Estimator {0} raises error if &quot;</span>
                <span class="s4">&quot;'sample_weight' parameter is of &quot;</span>
                <span class="s4">&quot;type pandas.Series&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">name</span><span class="s3">)</span>
            <span class="s3">)</span>
    <span class="s2">except </span><span class="s1">ImportError</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">SkipTest</span><span class="s3">(</span>
            <span class="s4">&quot;pandas is not installed: not testing for &quot;</span>
            <span class="s4">&quot;input of type pandas.Series to class weight.&quot;</span>
        <span class="s3">)</span>


<span class="s3">@</span><span class="s1">ignore_warnings</span><span class="s3">(</span><span class="s1">category</span><span class="s3">=(</span><span class="s1">FutureWarning</span><span class="s3">))</span>
<span class="s2">def </span><span class="s1">check_sample_weights_not_an_array</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">estimator_orig</span><span class="s3">):</span>
    <span class="s5"># check that estimators will accept a 'sample_weight' parameter of</span>
    <span class="s5"># type _NotAnArray in the 'fit' function.</span>
    <span class="s1">estimator </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">)</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span>
        <span class="s3">[</span>
            <span class="s3">[</span><span class="s6">1</span><span class="s3">, </span><span class="s6">1</span><span class="s3">],</span>
            <span class="s3">[</span><span class="s6">1</span><span class="s3">, </span><span class="s6">2</span><span class="s3">],</span>
            <span class="s3">[</span><span class="s6">1</span><span class="s3">, </span><span class="s6">3</span><span class="s3">],</span>
            <span class="s3">[</span><span class="s6">1</span><span class="s3">, </span><span class="s6">4</span><span class="s3">],</span>
            <span class="s3">[</span><span class="s6">2</span><span class="s3">, </span><span class="s6">1</span><span class="s3">],</span>
            <span class="s3">[</span><span class="s6">2</span><span class="s3">, </span><span class="s6">2</span><span class="s3">],</span>
            <span class="s3">[</span><span class="s6">2</span><span class="s3">, </span><span class="s6">3</span><span class="s3">],</span>
            <span class="s3">[</span><span class="s6">2</span><span class="s3">, </span><span class="s6">4</span><span class="s3">],</span>
            <span class="s3">[</span><span class="s6">3</span><span class="s3">, </span><span class="s6">1</span><span class="s3">],</span>
            <span class="s3">[</span><span class="s6">3</span><span class="s3">, </span><span class="s6">2</span><span class="s3">],</span>
            <span class="s3">[</span><span class="s6">3</span><span class="s3">, </span><span class="s6">3</span><span class="s3">],</span>
            <span class="s3">[</span><span class="s6">3</span><span class="s3">, </span><span class="s6">4</span><span class="s3">],</span>
        <span class="s3">]</span>
    <span class="s3">)</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">_NotAnArray</span><span class="s3">(</span><span class="s1">_enforce_estimator_tags_X</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">, </span><span class="s1">X</span><span class="s3">))</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">_NotAnArray</span><span class="s3">([</span><span class="s6">1</span><span class="s3">, </span><span class="s6">1</span><span class="s3">, </span><span class="s6">1</span><span class="s3">, </span><span class="s6">1</span><span class="s3">, </span><span class="s6">2</span><span class="s3">, </span><span class="s6">2</span><span class="s3">, </span><span class="s6">2</span><span class="s3">, </span><span class="s6">2</span><span class="s3">, </span><span class="s6">1</span><span class="s3">, </span><span class="s6">1</span><span class="s3">, </span><span class="s6">2</span><span class="s3">, </span><span class="s6">2</span><span class="s3">])</span>
    <span class="s1">weights </span><span class="s3">= </span><span class="s1">_NotAnArray</span><span class="s3">([</span><span class="s6">1</span><span class="s3">] * </span><span class="s6">12</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">_safe_tags</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">key</span><span class="s3">=</span><span class="s4">&quot;multioutput_only&quot;</span><span class="s3">):</span>
        <span class="s1">y </span><span class="s3">= </span><span class="s1">_NotAnArray</span><span class="s3">(</span><span class="s1">y</span><span class="s3">.</span><span class="s1">data</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">(-</span><span class="s6">1</span><span class="s3">, </span><span class="s6">1</span><span class="s3">))</span>
    <span class="s1">estimator</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">sample_weight</span><span class="s3">=</span><span class="s1">weights</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">ignore_warnings</span><span class="s3">(</span><span class="s1">category</span><span class="s3">=(</span><span class="s1">FutureWarning</span><span class="s3">))</span>
<span class="s2">def </span><span class="s1">check_sample_weights_list</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">estimator_orig</span><span class="s3">):</span>
    <span class="s5"># check that estimators will accept a 'sample_weight' parameter of</span>
    <span class="s5"># type list in the 'fit' function.</span>
    <span class="s1">estimator </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">)</span>
    <span class="s1">rnd </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">RandomState</span><span class="s3">(</span><span class="s6">0</span><span class="s3">)</span>
    <span class="s1">n_samples </span><span class="s3">= </span><span class="s6">30</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">_enforce_estimator_tags_X</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">, </span><span class="s1">rnd</span><span class="s3">.</span><span class="s1">uniform</span><span class="s3">(</span><span class="s1">size</span><span class="s3">=(</span><span class="s1">n_samples</span><span class="s3">, </span><span class="s6">3</span><span class="s3">)))</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s1">n_samples</span><span class="s3">) % </span><span class="s6">3</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">_enforce_estimator_tags_y</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
    <span class="s1">sample_weight </span><span class="s3">= [</span><span class="s6">3</span><span class="s3">] * </span><span class="s1">n_samples</span>
    <span class="s5"># Test that estimators don't raise any exception</span>
    <span class="s1">estimator</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">sample_weight</span><span class="s3">=</span><span class="s1">sample_weight</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">ignore_warnings</span><span class="s3">(</span><span class="s1">category</span><span class="s3">=</span><span class="s1">FutureWarning</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">check_sample_weights_shape</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">estimator_orig</span><span class="s3">):</span>
    <span class="s5"># check that estimators raise an error if sample_weight</span>
    <span class="s5"># shape mismatches the input</span>
    <span class="s1">estimator </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">)</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span>
        <span class="s3">[</span>
            <span class="s3">[</span><span class="s6">1</span><span class="s3">, </span><span class="s6">3</span><span class="s3">],</span>
            <span class="s3">[</span><span class="s6">1</span><span class="s3">, </span><span class="s6">3</span><span class="s3">],</span>
            <span class="s3">[</span><span class="s6">1</span><span class="s3">, </span><span class="s6">3</span><span class="s3">],</span>
            <span class="s3">[</span><span class="s6">1</span><span class="s3">, </span><span class="s6">3</span><span class="s3">],</span>
            <span class="s3">[</span><span class="s6">2</span><span class="s3">, </span><span class="s6">1</span><span class="s3">],</span>
            <span class="s3">[</span><span class="s6">2</span><span class="s3">, </span><span class="s6">1</span><span class="s3">],</span>
            <span class="s3">[</span><span class="s6">2</span><span class="s3">, </span><span class="s6">1</span><span class="s3">],</span>
            <span class="s3">[</span><span class="s6">2</span><span class="s3">, </span><span class="s6">1</span><span class="s3">],</span>
            <span class="s3">[</span><span class="s6">3</span><span class="s3">, </span><span class="s6">3</span><span class="s3">],</span>
            <span class="s3">[</span><span class="s6">3</span><span class="s3">, </span><span class="s6">3</span><span class="s3">],</span>
            <span class="s3">[</span><span class="s6">3</span><span class="s3">, </span><span class="s6">3</span><span class="s3">],</span>
            <span class="s3">[</span><span class="s6">3</span><span class="s3">, </span><span class="s6">3</span><span class="s3">],</span>
            <span class="s3">[</span><span class="s6">4</span><span class="s3">, </span><span class="s6">1</span><span class="s3">],</span>
            <span class="s3">[</span><span class="s6">4</span><span class="s3">, </span><span class="s6">1</span><span class="s3">],</span>
            <span class="s3">[</span><span class="s6">4</span><span class="s3">, </span><span class="s6">1</span><span class="s3">],</span>
            <span class="s3">[</span><span class="s6">4</span><span class="s3">, </span><span class="s6">1</span><span class="s3">],</span>
        <span class="s3">]</span>
    <span class="s3">)</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s6">1</span><span class="s3">, </span><span class="s6">1</span><span class="s3">, </span><span class="s6">1</span><span class="s3">, </span><span class="s6">1</span><span class="s3">, </span><span class="s6">2</span><span class="s3">, </span><span class="s6">2</span><span class="s3">, </span><span class="s6">2</span><span class="s3">, </span><span class="s6">2</span><span class="s3">, </span><span class="s6">1</span><span class="s3">, </span><span class="s6">1</span><span class="s3">, </span><span class="s6">1</span><span class="s3">, </span><span class="s6">1</span><span class="s3">, </span><span class="s6">2</span><span class="s3">, </span><span class="s6">2</span><span class="s3">, </span><span class="s6">2</span><span class="s3">, </span><span class="s6">2</span><span class="s3">])</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">_enforce_estimator_tags_y</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>

    <span class="s1">estimator</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">sample_weight</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">y</span><span class="s3">)))</span>

    <span class="s2">with </span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">):</span>
        <span class="s1">estimator</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">sample_weight</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s6">2 </span><span class="s3">* </span><span class="s1">len</span><span class="s3">(</span><span class="s1">y</span><span class="s3">)))</span>

    <span class="s2">with </span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">):</span>
        <span class="s1">estimator</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">sample_weight</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">((</span><span class="s1">len</span><span class="s3">(</span><span class="s1">y</span><span class="s3">), </span><span class="s6">2</span><span class="s3">)))</span>


<span class="s3">@</span><span class="s1">ignore_warnings</span><span class="s3">(</span><span class="s1">category</span><span class="s3">=</span><span class="s1">FutureWarning</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">check_sample_weights_invariance</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">estimator_orig</span><span class="s3">, </span><span class="s1">kind</span><span class="s3">=</span><span class="s4">&quot;ones&quot;</span><span class="s3">):</span>
    <span class="s5"># For kind=&quot;ones&quot; check that the estimators yield same results for</span>
    <span class="s5"># unit weights and no weights</span>
    <span class="s5"># For kind=&quot;zeros&quot; check that setting sample_weight to 0 is equivalent</span>
    <span class="s5"># to removing corresponding samples.</span>
    <span class="s1">estimator1 </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">)</span>
    <span class="s1">estimator2 </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">)</span>
    <span class="s1">set_random_state</span><span class="s3">(</span><span class="s1">estimator1</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s6">0</span><span class="s3">)</span>
    <span class="s1">set_random_state</span><span class="s3">(</span><span class="s1">estimator2</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s6">0</span><span class="s3">)</span>

    <span class="s1">X1 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span>
        <span class="s3">[</span>
            <span class="s3">[</span><span class="s6">1</span><span class="s3">, </span><span class="s6">3</span><span class="s3">],</span>
            <span class="s3">[</span><span class="s6">1</span><span class="s3">, </span><span class="s6">3</span><span class="s3">],</span>
            <span class="s3">[</span><span class="s6">1</span><span class="s3">, </span><span class="s6">3</span><span class="s3">],</span>
            <span class="s3">[</span><span class="s6">1</span><span class="s3">, </span><span class="s6">3</span><span class="s3">],</span>
            <span class="s3">[</span><span class="s6">2</span><span class="s3">, </span><span class="s6">1</span><span class="s3">],</span>
            <span class="s3">[</span><span class="s6">2</span><span class="s3">, </span><span class="s6">1</span><span class="s3">],</span>
            <span class="s3">[</span><span class="s6">2</span><span class="s3">, </span><span class="s6">1</span><span class="s3">],</span>
            <span class="s3">[</span><span class="s6">2</span><span class="s3">, </span><span class="s6">1</span><span class="s3">],</span>
            <span class="s3">[</span><span class="s6">3</span><span class="s3">, </span><span class="s6">3</span><span class="s3">],</span>
            <span class="s3">[</span><span class="s6">3</span><span class="s3">, </span><span class="s6">3</span><span class="s3">],</span>
            <span class="s3">[</span><span class="s6">3</span><span class="s3">, </span><span class="s6">3</span><span class="s3">],</span>
            <span class="s3">[</span><span class="s6">3</span><span class="s3">, </span><span class="s6">3</span><span class="s3">],</span>
            <span class="s3">[</span><span class="s6">4</span><span class="s3">, </span><span class="s6">1</span><span class="s3">],</span>
            <span class="s3">[</span><span class="s6">4</span><span class="s3">, </span><span class="s6">1</span><span class="s3">],</span>
            <span class="s3">[</span><span class="s6">4</span><span class="s3">, </span><span class="s6">1</span><span class="s3">],</span>
            <span class="s3">[</span><span class="s6">4</span><span class="s3">, </span><span class="s6">1</span><span class="s3">],</span>
        <span class="s3">],</span>
        <span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">,</span>
    <span class="s3">)</span>
    <span class="s1">y1 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s6">1</span><span class="s3">, </span><span class="s6">1</span><span class="s3">, </span><span class="s6">1</span><span class="s3">, </span><span class="s6">1</span><span class="s3">, </span><span class="s6">2</span><span class="s3">, </span><span class="s6">2</span><span class="s3">, </span><span class="s6">2</span><span class="s3">, </span><span class="s6">2</span><span class="s3">, </span><span class="s6">1</span><span class="s3">, </span><span class="s6">1</span><span class="s3">, </span><span class="s6">1</span><span class="s3">, </span><span class="s6">1</span><span class="s3">, </span><span class="s6">2</span><span class="s3">, </span><span class="s6">2</span><span class="s3">, </span><span class="s6">2</span><span class="s3">, </span><span class="s6">2</span><span class="s3">], </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">int</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">kind </span><span class="s3">== </span><span class="s4">&quot;ones&quot;</span><span class="s3">:</span>
        <span class="s1">X2 </span><span class="s3">= </span><span class="s1">X1</span>
        <span class="s1">y2 </span><span class="s3">= </span><span class="s1">y1</span>
        <span class="s1">sw2 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">=</span><span class="s1">len</span><span class="s3">(</span><span class="s1">y1</span><span class="s3">))</span>
        <span class="s1">err_msg </span><span class="s3">= (</span>
            <span class="s4">f&quot;For </span><span class="s2">{</span><span class="s1">name</span><span class="s2">} </span><span class="s4">sample_weight=None is not equivalent to sample_weight=ones&quot;</span>
        <span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">kind </span><span class="s3">== </span><span class="s4">&quot;zeros&quot;</span><span class="s3">:</span>
        <span class="s5"># Construct a dataset that is very different to (X, y) if weights</span>
        <span class="s5"># are disregarded, but identical to (X, y) given weights.</span>
        <span class="s1">X2 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">vstack</span><span class="s3">([</span><span class="s1">X1</span><span class="s3">, </span><span class="s1">X1 </span><span class="s3">+ </span><span class="s6">1</span><span class="s3">])</span>
        <span class="s1">y2 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">hstack</span><span class="s3">([</span><span class="s1">y1</span><span class="s3">, </span><span class="s6">3 </span><span class="s3">- </span><span class="s1">y1</span><span class="s3">])</span>
        <span class="s1">sw2 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">=</span><span class="s1">len</span><span class="s3">(</span><span class="s1">y1</span><span class="s3">) * </span><span class="s6">2</span><span class="s3">)</span>
        <span class="s1">sw2</span><span class="s3">[</span><span class="s1">len</span><span class="s3">(</span><span class="s1">y1</span><span class="s3">) :] = </span><span class="s6">0</span>
        <span class="s1">X2</span><span class="s3">, </span><span class="s1">y2</span><span class="s3">, </span><span class="s1">sw2 </span><span class="s3">= </span><span class="s1">shuffle</span><span class="s3">(</span><span class="s1">X2</span><span class="s3">, </span><span class="s1">y2</span><span class="s3">, </span><span class="s1">sw2</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s6">0</span><span class="s3">)</span>

        <span class="s1">err_msg </span><span class="s3">= (</span>
            <span class="s4">f&quot;For </span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s4">, a zero sample_weight is not equivalent to removing the sample&quot;</span>
        <span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:  </span><span class="s5"># pragma: no cover</span>
        <span class="s2">raise </span><span class="s1">ValueError</span>

    <span class="s1">y1 </span><span class="s3">= </span><span class="s1">_enforce_estimator_tags_y</span><span class="s3">(</span><span class="s1">estimator1</span><span class="s3">, </span><span class="s1">y1</span><span class="s3">)</span>
    <span class="s1">y2 </span><span class="s3">= </span><span class="s1">_enforce_estimator_tags_y</span><span class="s3">(</span><span class="s1">estimator2</span><span class="s3">, </span><span class="s1">y2</span><span class="s3">)</span>

    <span class="s1">estimator1</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X1</span><span class="s3">, </span><span class="s1">y</span><span class="s3">=</span><span class="s1">y1</span><span class="s3">, </span><span class="s1">sample_weight</span><span class="s3">=</span><span class="s2">None</span><span class="s3">)</span>
    <span class="s1">estimator2</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X2</span><span class="s3">, </span><span class="s1">y</span><span class="s3">=</span><span class="s1">y2</span><span class="s3">, </span><span class="s1">sample_weight</span><span class="s3">=</span><span class="s1">sw2</span><span class="s3">)</span>

    <span class="s2">for </span><span class="s1">method </span><span class="s2">in </span><span class="s3">[</span><span class="s4">&quot;predict&quot;</span><span class="s3">, </span><span class="s4">&quot;predict_proba&quot;</span><span class="s3">, </span><span class="s4">&quot;decision_function&quot;</span><span class="s3">, </span><span class="s4">&quot;transform&quot;</span><span class="s3">]:</span>
        <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">, </span><span class="s1">method</span><span class="s3">):</span>
            <span class="s1">X_pred1 </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">estimator1</span><span class="s3">, </span><span class="s1">method</span><span class="s3">)(</span><span class="s1">X1</span><span class="s3">)</span>
            <span class="s1">X_pred2 </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">estimator2</span><span class="s3">, </span><span class="s1">method</span><span class="s3">)(</span><span class="s1">X1</span><span class="s3">)</span>
            <span class="s1">assert_allclose_dense_sparse</span><span class="s3">(</span><span class="s1">X_pred1</span><span class="s3">, </span><span class="s1">X_pred2</span><span class="s3">, </span><span class="s1">err_msg</span><span class="s3">=</span><span class="s1">err_msg</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">check_sample_weights_not_overwritten</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">estimator_orig</span><span class="s3">):</span>
    <span class="s5"># check that estimators don't override the passed sample_weight parameter</span>
    <span class="s1">estimator </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">)</span>
    <span class="s1">set_random_state</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s6">0</span><span class="s3">)</span>

    <span class="s1">X </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span>
        <span class="s3">[</span>
            <span class="s3">[</span><span class="s6">1</span><span class="s3">, </span><span class="s6">3</span><span class="s3">],</span>
            <span class="s3">[</span><span class="s6">1</span><span class="s3">, </span><span class="s6">3</span><span class="s3">],</span>
            <span class="s3">[</span><span class="s6">1</span><span class="s3">, </span><span class="s6">3</span><span class="s3">],</span>
            <span class="s3">[</span><span class="s6">1</span><span class="s3">, </span><span class="s6">3</span><span class="s3">],</span>
            <span class="s3">[</span><span class="s6">2</span><span class="s3">, </span><span class="s6">1</span><span class="s3">],</span>
            <span class="s3">[</span><span class="s6">2</span><span class="s3">, </span><span class="s6">1</span><span class="s3">],</span>
            <span class="s3">[</span><span class="s6">2</span><span class="s3">, </span><span class="s6">1</span><span class="s3">],</span>
            <span class="s3">[</span><span class="s6">2</span><span class="s3">, </span><span class="s6">1</span><span class="s3">],</span>
            <span class="s3">[</span><span class="s6">3</span><span class="s3">, </span><span class="s6">3</span><span class="s3">],</span>
            <span class="s3">[</span><span class="s6">3</span><span class="s3">, </span><span class="s6">3</span><span class="s3">],</span>
            <span class="s3">[</span><span class="s6">3</span><span class="s3">, </span><span class="s6">3</span><span class="s3">],</span>
            <span class="s3">[</span><span class="s6">3</span><span class="s3">, </span><span class="s6">3</span><span class="s3">],</span>
            <span class="s3">[</span><span class="s6">4</span><span class="s3">, </span><span class="s6">1</span><span class="s3">],</span>
            <span class="s3">[</span><span class="s6">4</span><span class="s3">, </span><span class="s6">1</span><span class="s3">],</span>
            <span class="s3">[</span><span class="s6">4</span><span class="s3">, </span><span class="s6">1</span><span class="s3">],</span>
            <span class="s3">[</span><span class="s6">4</span><span class="s3">, </span><span class="s6">1</span><span class="s3">],</span>
        <span class="s3">],</span>
        <span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">,</span>
    <span class="s3">)</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s6">1</span><span class="s3">, </span><span class="s6">1</span><span class="s3">, </span><span class="s6">1</span><span class="s3">, </span><span class="s6">1</span><span class="s3">, </span><span class="s6">2</span><span class="s3">, </span><span class="s6">2</span><span class="s3">, </span><span class="s6">2</span><span class="s3">, </span><span class="s6">2</span><span class="s3">, </span><span class="s6">1</span><span class="s3">, </span><span class="s6">1</span><span class="s3">, </span><span class="s6">1</span><span class="s3">, </span><span class="s6">1</span><span class="s3">, </span><span class="s6">2</span><span class="s3">, </span><span class="s6">2</span><span class="s3">, </span><span class="s6">2</span><span class="s3">, </span><span class="s6">2</span><span class="s3">], </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">int</span><span class="s3">)</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">_enforce_estimator_tags_y</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>

    <span class="s1">sample_weight_original </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">y</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s6">0</span><span class="s3">])</span>
    <span class="s1">sample_weight_original</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s6">10.0</span>

    <span class="s1">sample_weight_fit </span><span class="s3">= </span><span class="s1">sample_weight_original</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>

    <span class="s1">estimator</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">sample_weight</span><span class="s3">=</span><span class="s1">sample_weight_fit</span><span class="s3">)</span>

    <span class="s1">err_msg </span><span class="s3">= </span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">name</span><span class="s2">} </span><span class="s4">overwrote the original `sample_weight` given during fit&quot;</span>
    <span class="s1">assert_allclose</span><span class="s3">(</span><span class="s1">sample_weight_fit</span><span class="s3">, </span><span class="s1">sample_weight_original</span><span class="s3">, </span><span class="s1">err_msg</span><span class="s3">=</span><span class="s1">err_msg</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">ignore_warnings</span><span class="s3">(</span><span class="s1">category</span><span class="s3">=(</span><span class="s1">FutureWarning</span><span class="s3">, </span><span class="s1">UserWarning</span><span class="s3">))</span>
<span class="s2">def </span><span class="s1">check_dtype_object</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">estimator_orig</span><span class="s3">):</span>
    <span class="s5"># check that estimators treat dtype object as numeric if possible</span>
    <span class="s1">rng </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">RandomState</span><span class="s3">(</span><span class="s6">0</span><span class="s3">)</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">_enforce_estimator_tags_X</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">, </span><span class="s1">rng</span><span class="s3">.</span><span class="s1">uniform</span><span class="s3">(</span><span class="s1">size</span><span class="s3">=(</span><span class="s6">40</span><span class="s3">, </span><span class="s6">10</span><span class="s3">)))</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">X</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">object</span><span class="s3">)</span>
    <span class="s1">tags </span><span class="s3">= </span><span class="s1">_safe_tags</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">)</span>
    <span class="s1">y </span><span class="s3">= (</span><span class="s1">X</span><span class="s3">[:, </span><span class="s6">0</span><span class="s3">] * </span><span class="s6">4</span><span class="s3">).</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">int</span><span class="s3">)</span>
    <span class="s1">estimator </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">)</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">_enforce_estimator_tags_y</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>

    <span class="s1">estimator</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s4">&quot;predict&quot;</span><span class="s3">):</span>
        <span class="s1">estimator</span><span class="s3">.</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s4">&quot;transform&quot;</span><span class="s3">):</span>
        <span class="s1">estimator</span><span class="s3">.</span><span class="s1">transform</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>

    <span class="s2">with </span><span class="s1">raises</span><span class="s3">(</span><span class="s1">Exception</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s4">&quot;Unknown label type&quot;</span><span class="s3">, </span><span class="s1">may_pass</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
        <span class="s1">estimator</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">object</span><span class="s3">))</span>

    <span class="s2">if </span><span class="s4">&quot;string&quot; </span><span class="s2">not in </span><span class="s1">tags</span><span class="s3">[</span><span class="s4">&quot;X_types&quot;</span><span class="s3">]:</span>
        <span class="s1">X</span><span class="s3">[</span><span class="s6">0</span><span class="s3">, </span><span class="s6">0</span><span class="s3">] = {</span><span class="s4">&quot;foo&quot;</span><span class="s3">: </span><span class="s4">&quot;bar&quot;</span><span class="s3">}</span>
        <span class="s5"># This error is raised by:</span>
        <span class="s5"># - `np.asarray` in `check_array`</span>
        <span class="s5"># - `_unique_python` for encoders</span>
        <span class="s1">msg </span><span class="s3">= </span><span class="s4">&quot;argument must be .* string.* number&quot;</span>
        <span class="s2">with </span><span class="s1">raises</span><span class="s3">(</span><span class="s1">TypeError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s1">msg</span><span class="s3">):</span>
            <span class="s1">estimator</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s5"># Estimators supporting string will not call np.asarray to convert the</span>
        <span class="s5"># data to numeric and therefore, the error will not be raised.</span>
        <span class="s5"># Checking for each element dtype in the input array will be costly.</span>
        <span class="s5"># Refer to #11401 for full discussion.</span>
        <span class="s1">estimator</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">check_complex_data</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">estimator_orig</span><span class="s3">):</span>
    <span class="s1">rng </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">RandomState</span><span class="s3">(</span><span class="s6">42</span><span class="s3">)</span>
    <span class="s5"># check that estimators raise an exception on providing complex data</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">rng</span><span class="s3">.</span><span class="s1">uniform</span><span class="s3">(</span><span class="s1">size</span><span class="s3">=</span><span class="s6">10</span><span class="s3">) + </span><span class="s6">1j </span><span class="s3">* </span><span class="s1">rng</span><span class="s3">.</span><span class="s1">uniform</span><span class="s3">(</span><span class="s1">size</span><span class="s3">=</span><span class="s6">10</span><span class="s3">)</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">X</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">(-</span><span class="s6">1</span><span class="s3">, </span><span class="s6">1</span><span class="s3">)</span>

    <span class="s5"># Something both valid for classification and regression</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">rng</span><span class="s3">.</span><span class="s1">randint</span><span class="s3">(</span><span class="s1">low</span><span class="s3">=</span><span class="s6">0</span><span class="s3">, </span><span class="s1">high</span><span class="s3">=</span><span class="s6">2</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=</span><span class="s6">10</span><span class="s3">) + </span><span class="s6">1j</span>
    <span class="s1">estimator </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">)</span>
    <span class="s1">set_random_state</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s6">0</span><span class="s3">)</span>
    <span class="s2">with </span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s4">&quot;Complex data not supported&quot;</span><span class="s3">):</span>
        <span class="s1">estimator</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">ignore_warnings</span>
<span class="s2">def </span><span class="s1">check_dict_unchanged</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">estimator_orig</span><span class="s3">):</span>
    <span class="s5"># this estimator raises</span>
    <span class="s5"># ValueError: Found array with 0 feature(s) (shape=(23, 0))</span>
    <span class="s5"># while a minimum of 1 is required.</span>
    <span class="s5"># error</span>
    <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s3">[</span><span class="s4">&quot;SpectralCoclustering&quot;</span><span class="s3">]:</span>
        <span class="s2">return</span>
    <span class="s1">rnd </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">RandomState</span><span class="s3">(</span><span class="s6">0</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s3">[</span><span class="s4">&quot;RANSACRegressor&quot;</span><span class="s3">]:</span>
        <span class="s1">X </span><span class="s3">= </span><span class="s6">3 </span><span class="s3">* </span><span class="s1">rnd</span><span class="s3">.</span><span class="s1">uniform</span><span class="s3">(</span><span class="s1">size</span><span class="s3">=(</span><span class="s6">20</span><span class="s3">, </span><span class="s6">3</span><span class="s3">))</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">X </span><span class="s3">= </span><span class="s6">2 </span><span class="s3">* </span><span class="s1">rnd</span><span class="s3">.</span><span class="s1">uniform</span><span class="s3">(</span><span class="s1">size</span><span class="s3">=(</span><span class="s6">20</span><span class="s3">, </span><span class="s6">3</span><span class="s3">))</span>

    <span class="s1">X </span><span class="s3">= </span><span class="s1">_enforce_estimator_tags_X</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">, </span><span class="s1">X</span><span class="s3">)</span>

    <span class="s1">y </span><span class="s3">= </span><span class="s1">X</span><span class="s3">[:, </span><span class="s6">0</span><span class="s3">].</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">int</span><span class="s3">)</span>
    <span class="s1">estimator </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">)</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">_enforce_estimator_tags_y</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s4">&quot;n_components&quot;</span><span class="s3">):</span>
        <span class="s1">estimator</span><span class="s3">.</span><span class="s1">n_components </span><span class="s3">= </span><span class="s6">1</span>

    <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s4">&quot;n_clusters&quot;</span><span class="s3">):</span>
        <span class="s1">estimator</span><span class="s3">.</span><span class="s1">n_clusters </span><span class="s3">= </span><span class="s6">1</span>

    <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s4">&quot;n_best&quot;</span><span class="s3">):</span>
        <span class="s1">estimator</span><span class="s3">.</span><span class="s1">n_best </span><span class="s3">= </span><span class="s6">1</span>

    <span class="s1">set_random_state</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s6">1</span><span class="s3">)</span>

    <span class="s1">estimator</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
    <span class="s2">for </span><span class="s1">method </span><span class="s2">in </span><span class="s3">[</span><span class="s4">&quot;predict&quot;</span><span class="s3">, </span><span class="s4">&quot;transform&quot;</span><span class="s3">, </span><span class="s4">&quot;decision_function&quot;</span><span class="s3">, </span><span class="s4">&quot;predict_proba&quot;</span><span class="s3">]:</span>
        <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">method</span><span class="s3">):</span>
            <span class="s1">dict_before </span><span class="s3">= </span><span class="s1">estimator</span><span class="s3">.</span><span class="s1">__dict__</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>
            <span class="s1">getattr</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">method</span><span class="s3">)(</span><span class="s1">X</span><span class="s3">)</span>
            <span class="s2">assert </span><span class="s1">estimator</span><span class="s3">.</span><span class="s1">__dict__ </span><span class="s3">== </span><span class="s1">dict_before</span><span class="s3">, (</span>
                <span class="s4">&quot;Estimator changes __dict__ during %s&quot; </span><span class="s3">% </span><span class="s1">method</span>
            <span class="s3">)</span>


<span class="s2">def </span><span class="s1">_is_public_parameter</span><span class="s3">(</span><span class="s1">attr</span><span class="s3">):</span>
    <span class="s2">return not </span><span class="s3">(</span><span class="s1">attr</span><span class="s3">.</span><span class="s1">startswith</span><span class="s3">(</span><span class="s4">&quot;_&quot;</span><span class="s3">) </span><span class="s2">or </span><span class="s1">attr</span><span class="s3">.</span><span class="s1">endswith</span><span class="s3">(</span><span class="s4">&quot;_&quot;</span><span class="s3">))</span>


<span class="s3">@</span><span class="s1">ignore_warnings</span><span class="s3">(</span><span class="s1">category</span><span class="s3">=</span><span class="s1">FutureWarning</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">check_dont_overwrite_parameters</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">estimator_orig</span><span class="s3">):</span>
    <span class="s5"># check that fit method only changes or sets private attributes</span>
    <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">.</span><span class="s1">__init__</span><span class="s3">, </span><span class="s4">&quot;deprecated_original&quot;</span><span class="s3">):</span>
        <span class="s5"># to not check deprecated classes</span>
        <span class="s2">return</span>
    <span class="s1">estimator </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">)</span>
    <span class="s1">rnd </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">RandomState</span><span class="s3">(</span><span class="s6">0</span><span class="s3">)</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s6">3 </span><span class="s3">* </span><span class="s1">rnd</span><span class="s3">.</span><span class="s1">uniform</span><span class="s3">(</span><span class="s1">size</span><span class="s3">=(</span><span class="s6">20</span><span class="s3">, </span><span class="s6">3</span><span class="s3">))</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">_enforce_estimator_tags_X</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">, </span><span class="s1">X</span><span class="s3">)</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">X</span><span class="s3">[:, </span><span class="s6">0</span><span class="s3">].</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">int</span><span class="s3">)</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">_enforce_estimator_tags_y</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s4">&quot;n_components&quot;</span><span class="s3">):</span>
        <span class="s1">estimator</span><span class="s3">.</span><span class="s1">n_components </span><span class="s3">= </span><span class="s6">1</span>
    <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s4">&quot;n_clusters&quot;</span><span class="s3">):</span>
        <span class="s1">estimator</span><span class="s3">.</span><span class="s1">n_clusters </span><span class="s3">= </span><span class="s6">1</span>

    <span class="s1">set_random_state</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s6">1</span><span class="s3">)</span>
    <span class="s1">dict_before_fit </span><span class="s3">= </span><span class="s1">estimator</span><span class="s3">.</span><span class="s1">__dict__</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>
    <span class="s1">estimator</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>

    <span class="s1">dict_after_fit </span><span class="s3">= </span><span class="s1">estimator</span><span class="s3">.</span><span class="s1">__dict__</span>

    <span class="s1">public_keys_after_fit </span><span class="s3">= [</span>
        <span class="s1">key </span><span class="s2">for </span><span class="s1">key </span><span class="s2">in </span><span class="s1">dict_after_fit</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">() </span><span class="s2">if </span><span class="s1">_is_public_parameter</span><span class="s3">(</span><span class="s1">key</span><span class="s3">)</span>
    <span class="s3">]</span>

    <span class="s1">attrs_added_by_fit </span><span class="s3">= [</span>
        <span class="s1">key </span><span class="s2">for </span><span class="s1">key </span><span class="s2">in </span><span class="s1">public_keys_after_fit </span><span class="s2">if </span><span class="s1">key </span><span class="s2">not in </span><span class="s1">dict_before_fit</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">()</span>
    <span class="s3">]</span>

    <span class="s5"># check that fit doesn't add any public attribute</span>
    <span class="s2">assert not </span><span class="s1">attrs_added_by_fit</span><span class="s3">, (</span>
        <span class="s4">&quot;Estimator adds public attribute(s) during&quot;</span>
        <span class="s4">&quot; the fit method.&quot;</span>
        <span class="s4">&quot; Estimators are only allowed to add private attributes&quot;</span>
        <span class="s4">&quot; either started with _ or ended&quot;</span>
        <span class="s4">&quot; with _ but %s added&quot; </span><span class="s3">% </span><span class="s4">&quot;, &quot;</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">attrs_added_by_fit</span><span class="s3">)</span>
    <span class="s3">)</span>

    <span class="s5"># check that fit doesn't change any public attribute</span>
    <span class="s1">attrs_changed_by_fit </span><span class="s3">= [</span>
        <span class="s1">key</span>
        <span class="s2">for </span><span class="s1">key </span><span class="s2">in </span><span class="s1">public_keys_after_fit</span>
        <span class="s2">if </span><span class="s3">(</span><span class="s1">dict_before_fit</span><span class="s3">[</span><span class="s1">key</span><span class="s3">] </span><span class="s2">is not </span><span class="s1">dict_after_fit</span><span class="s3">[</span><span class="s1">key</span><span class="s3">])</span>
    <span class="s3">]</span>

    <span class="s2">assert not </span><span class="s1">attrs_changed_by_fit</span><span class="s3">, (</span>
        <span class="s4">&quot;Estimator changes public attribute(s) during&quot;</span>
        <span class="s4">&quot; the fit method. Estimators are only allowed&quot;</span>
        <span class="s4">&quot; to change attributes started&quot;</span>
        <span class="s4">&quot; or ended with _, but&quot;</span>
        <span class="s4">&quot; %s changed&quot; </span><span class="s3">% </span><span class="s4">&quot;, &quot;</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">attrs_changed_by_fit</span><span class="s3">)</span>
    <span class="s3">)</span>


<span class="s3">@</span><span class="s1">ignore_warnings</span><span class="s3">(</span><span class="s1">category</span><span class="s3">=</span><span class="s1">FutureWarning</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">check_fit2d_predict1d</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">estimator_orig</span><span class="s3">):</span>
    <span class="s5"># check by fitting a 2d array and predicting with a 1d array</span>
    <span class="s1">rnd </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">RandomState</span><span class="s3">(</span><span class="s6">0</span><span class="s3">)</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s6">3 </span><span class="s3">* </span><span class="s1">rnd</span><span class="s3">.</span><span class="s1">uniform</span><span class="s3">(</span><span class="s1">size</span><span class="s3">=(</span><span class="s6">20</span><span class="s3">, </span><span class="s6">3</span><span class="s3">))</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">_enforce_estimator_tags_X</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">, </span><span class="s1">X</span><span class="s3">)</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">X</span><span class="s3">[:, </span><span class="s6">0</span><span class="s3">].</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">int</span><span class="s3">)</span>
    <span class="s1">estimator </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">)</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">_enforce_estimator_tags_y</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s4">&quot;n_components&quot;</span><span class="s3">):</span>
        <span class="s1">estimator</span><span class="s3">.</span><span class="s1">n_components </span><span class="s3">= </span><span class="s6">1</span>
    <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s4">&quot;n_clusters&quot;</span><span class="s3">):</span>
        <span class="s1">estimator</span><span class="s3">.</span><span class="s1">n_clusters </span><span class="s3">= </span><span class="s6">1</span>

    <span class="s1">set_random_state</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s6">1</span><span class="s3">)</span>
    <span class="s1">estimator</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>

    <span class="s2">for </span><span class="s1">method </span><span class="s2">in </span><span class="s3">[</span><span class="s4">&quot;predict&quot;</span><span class="s3">, </span><span class="s4">&quot;transform&quot;</span><span class="s3">, </span><span class="s4">&quot;decision_function&quot;</span><span class="s3">, </span><span class="s4">&quot;predict_proba&quot;</span><span class="s3">]:</span>
        <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">method</span><span class="s3">):</span>
            <span class="s1">assert_raise_message</span><span class="s3">(</span>
                <span class="s1">ValueError</span><span class="s3">, </span><span class="s4">&quot;Reshape your data&quot;</span><span class="s3">, </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">method</span><span class="s3">), </span><span class="s1">X</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]</span>
            <span class="s3">)</span>


<span class="s2">def </span><span class="s1">_apply_on_subsets</span><span class="s3">(</span><span class="s1">func</span><span class="s3">, </span><span class="s1">X</span><span class="s3">):</span>
    <span class="s5"># apply function on the whole set and on mini batches</span>
    <span class="s1">result_full </span><span class="s3">= </span><span class="s1">func</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
    <span class="s1">n_features </span><span class="s3">= </span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]</span>
    <span class="s1">result_by_batch </span><span class="s3">= [</span><span class="s1">func</span><span class="s3">(</span><span class="s1">batch</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">(</span><span class="s6">1</span><span class="s3">, </span><span class="s1">n_features</span><span class="s3">)) </span><span class="s2">for </span><span class="s1">batch </span><span class="s2">in </span><span class="s1">X</span><span class="s3">]</span>

    <span class="s5"># func can output tuple (e.g. score_samples)</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">result_full</span><span class="s3">, </span><span class="s1">tuple</span><span class="s3">):</span>
        <span class="s1">result_full </span><span class="s3">= </span><span class="s1">result_full</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]</span>
        <span class="s1">result_by_batch </span><span class="s3">= </span><span class="s1">list</span><span class="s3">(</span><span class="s1">map</span><span class="s3">(</span><span class="s2">lambda </span><span class="s1">x</span><span class="s3">: </span><span class="s1">x</span><span class="s3">[</span><span class="s6">0</span><span class="s3">], </span><span class="s1">result_by_batch</span><span class="s3">))</span>

    <span class="s2">if </span><span class="s1">sparse</span><span class="s3">.</span><span class="s1">issparse</span><span class="s3">(</span><span class="s1">result_full</span><span class="s3">):</span>
        <span class="s1">result_full </span><span class="s3">= </span><span class="s1">result_full</span><span class="s3">.</span><span class="s1">toarray</span><span class="s3">()</span>
        <span class="s1">result_by_batch </span><span class="s3">= [</span><span class="s1">x</span><span class="s3">.</span><span class="s1">toarray</span><span class="s3">() </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">result_by_batch</span><span class="s3">]</span>

    <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ravel</span><span class="s3">(</span><span class="s1">result_full</span><span class="s3">), </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ravel</span><span class="s3">(</span><span class="s1">result_by_batch</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">ignore_warnings</span><span class="s3">(</span><span class="s1">category</span><span class="s3">=</span><span class="s1">FutureWarning</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">check_methods_subset_invariance</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">estimator_orig</span><span class="s3">):</span>
    <span class="s5"># check that method gives invariant results if applied</span>
    <span class="s5"># on mini batches or the whole set</span>
    <span class="s1">rnd </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">RandomState</span><span class="s3">(</span><span class="s6">0</span><span class="s3">)</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s6">3 </span><span class="s3">* </span><span class="s1">rnd</span><span class="s3">.</span><span class="s1">uniform</span><span class="s3">(</span><span class="s1">size</span><span class="s3">=(</span><span class="s6">20</span><span class="s3">, </span><span class="s6">3</span><span class="s3">))</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">_enforce_estimator_tags_X</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">, </span><span class="s1">X</span><span class="s3">)</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">X</span><span class="s3">[:, </span><span class="s6">0</span><span class="s3">].</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">int</span><span class="s3">)</span>
    <span class="s1">estimator </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">)</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">_enforce_estimator_tags_y</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s4">&quot;n_components&quot;</span><span class="s3">):</span>
        <span class="s1">estimator</span><span class="s3">.</span><span class="s1">n_components </span><span class="s3">= </span><span class="s6">1</span>
    <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s4">&quot;n_clusters&quot;</span><span class="s3">):</span>
        <span class="s1">estimator</span><span class="s3">.</span><span class="s1">n_clusters </span><span class="s3">= </span><span class="s6">1</span>

    <span class="s1">set_random_state</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s6">1</span><span class="s3">)</span>
    <span class="s1">estimator</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>

    <span class="s2">for </span><span class="s1">method </span><span class="s2">in </span><span class="s3">[</span>
        <span class="s4">&quot;predict&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;transform&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;decision_function&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;score_samples&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;predict_proba&quot;</span><span class="s3">,</span>
    <span class="s3">]:</span>
        <span class="s1">msg </span><span class="s3">= (</span><span class="s4">&quot;{method} of {name} is not invariant when applied to a subset.&quot;</span><span class="s3">).</span><span class="s1">format</span><span class="s3">(</span>
            <span class="s1">method</span><span class="s3">=</span><span class="s1">method</span><span class="s3">, </span><span class="s1">name</span><span class="s3">=</span><span class="s1">name</span>
        <span class="s3">)</span>

        <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">method</span><span class="s3">):</span>
            <span class="s1">result_full</span><span class="s3">, </span><span class="s1">result_by_batch </span><span class="s3">= </span><span class="s1">_apply_on_subsets</span><span class="s3">(</span>
                <span class="s1">getattr</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">method</span><span class="s3">), </span><span class="s1">X</span>
            <span class="s3">)</span>
            <span class="s1">assert_allclose</span><span class="s3">(</span><span class="s1">result_full</span><span class="s3">, </span><span class="s1">result_by_batch</span><span class="s3">, </span><span class="s1">atol</span><span class="s3">=</span><span class="s6">1e-7</span><span class="s3">, </span><span class="s1">err_msg</span><span class="s3">=</span><span class="s1">msg</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">ignore_warnings</span><span class="s3">(</span><span class="s1">category</span><span class="s3">=</span><span class="s1">FutureWarning</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">check_methods_sample_order_invariance</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">estimator_orig</span><span class="s3">):</span>
    <span class="s5"># check that method gives invariant results if applied</span>
    <span class="s5"># on a subset with different sample order</span>
    <span class="s1">rnd </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">RandomState</span><span class="s3">(</span><span class="s6">0</span><span class="s3">)</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s6">3 </span><span class="s3">* </span><span class="s1">rnd</span><span class="s3">.</span><span class="s1">uniform</span><span class="s3">(</span><span class="s1">size</span><span class="s3">=(</span><span class="s6">20</span><span class="s3">, </span><span class="s6">3</span><span class="s3">))</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">_enforce_estimator_tags_X</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">, </span><span class="s1">X</span><span class="s3">)</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">X</span><span class="s3">[:, </span><span class="s6">0</span><span class="s3">].</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">int64</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">_safe_tags</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">, </span><span class="s1">key</span><span class="s3">=</span><span class="s4">&quot;binary_only&quot;</span><span class="s3">):</span>
        <span class="s1">y</span><span class="s3">[</span><span class="s1">y </span><span class="s3">== </span><span class="s6">2</span><span class="s3">] = </span><span class="s6">1</span>
    <span class="s1">estimator </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">)</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">_enforce_estimator_tags_y</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s4">&quot;n_components&quot;</span><span class="s3">):</span>
        <span class="s1">estimator</span><span class="s3">.</span><span class="s1">n_components </span><span class="s3">= </span><span class="s6">1</span>
    <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s4">&quot;n_clusters&quot;</span><span class="s3">):</span>
        <span class="s1">estimator</span><span class="s3">.</span><span class="s1">n_clusters </span><span class="s3">= </span><span class="s6">2</span>

    <span class="s1">set_random_state</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s6">1</span><span class="s3">)</span>
    <span class="s1">estimator</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>

    <span class="s1">idx </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">permutation</span><span class="s3">(</span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s6">0</span><span class="s3">])</span>

    <span class="s2">for </span><span class="s1">method </span><span class="s2">in </span><span class="s3">[</span>
        <span class="s4">&quot;predict&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;transform&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;decision_function&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;score_samples&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;predict_proba&quot;</span><span class="s3">,</span>
    <span class="s3">]:</span>
        <span class="s1">msg </span><span class="s3">= (</span>
            <span class="s4">&quot;{method} of {name} is not invariant when applied to a dataset&quot;</span>
            <span class="s4">&quot;with different sample order.&quot;</span>
        <span class="s3">).</span><span class="s1">format</span><span class="s3">(</span><span class="s1">method</span><span class="s3">=</span><span class="s1">method</span><span class="s3">, </span><span class="s1">name</span><span class="s3">=</span><span class="s1">name</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">method</span><span class="s3">):</span>
            <span class="s1">assert_allclose_dense_sparse</span><span class="s3">(</span>
                <span class="s1">getattr</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">method</span><span class="s3">)(</span><span class="s1">X</span><span class="s3">)[</span><span class="s1">idx</span><span class="s3">],</span>
                <span class="s1">getattr</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">method</span><span class="s3">)(</span><span class="s1">X</span><span class="s3">[</span><span class="s1">idx</span><span class="s3">]),</span>
                <span class="s1">atol</span><span class="s3">=</span><span class="s6">1e-9</span><span class="s3">,</span>
                <span class="s1">err_msg</span><span class="s3">=</span><span class="s1">msg</span><span class="s3">,</span>
            <span class="s3">)</span>


<span class="s3">@</span><span class="s1">ignore_warnings</span>
<span class="s2">def </span><span class="s1">check_fit2d_1sample</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">estimator_orig</span><span class="s3">):</span>
    <span class="s5"># Check that fitting a 2d array with only one sample either works or</span>
    <span class="s5"># returns an informative message. The error message should either mention</span>
    <span class="s5"># the number of samples or the number of classes.</span>
    <span class="s1">rnd </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">RandomState</span><span class="s3">(</span><span class="s6">0</span><span class="s3">)</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s6">3 </span><span class="s3">* </span><span class="s1">rnd</span><span class="s3">.</span><span class="s1">uniform</span><span class="s3">(</span><span class="s1">size</span><span class="s3">=(</span><span class="s6">1</span><span class="s3">, </span><span class="s6">10</span><span class="s3">))</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">_enforce_estimator_tags_X</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">, </span><span class="s1">X</span><span class="s3">)</span>

    <span class="s1">y </span><span class="s3">= </span><span class="s1">X</span><span class="s3">[:, </span><span class="s6">0</span><span class="s3">].</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">int</span><span class="s3">)</span>
    <span class="s1">estimator </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">)</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">_enforce_estimator_tags_y</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s4">&quot;n_components&quot;</span><span class="s3">):</span>
        <span class="s1">estimator</span><span class="s3">.</span><span class="s1">n_components </span><span class="s3">= </span><span class="s6">1</span>
    <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s4">&quot;n_clusters&quot;</span><span class="s3">):</span>
        <span class="s1">estimator</span><span class="s3">.</span><span class="s1">n_clusters </span><span class="s3">= </span><span class="s6">1</span>

    <span class="s1">set_random_state</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s6">1</span><span class="s3">)</span>

    <span class="s5"># min_cluster_size cannot be less than the data size for OPTICS.</span>
    <span class="s2">if </span><span class="s1">name </span><span class="s3">== </span><span class="s4">&quot;OPTICS&quot;</span><span class="s3">:</span>
        <span class="s1">estimator</span><span class="s3">.</span><span class="s1">set_params</span><span class="s3">(</span><span class="s1">min_samples</span><span class="s3">=</span><span class="s6">1.0</span><span class="s3">)</span>

    <span class="s5"># perplexity cannot be more than the number of samples for TSNE.</span>
    <span class="s2">if </span><span class="s1">name </span><span class="s3">== </span><span class="s4">&quot;TSNE&quot;</span><span class="s3">:</span>
        <span class="s1">estimator</span><span class="s3">.</span><span class="s1">set_params</span><span class="s3">(</span><span class="s1">perplexity</span><span class="s3">=</span><span class="s6">0.5</span><span class="s3">)</span>

    <span class="s1">msgs </span><span class="s3">= [</span>
        <span class="s4">&quot;1 sample&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;n_samples = 1&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;n_samples=1&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;one sample&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;1 class&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;one class&quot;</span><span class="s3">,</span>
    <span class="s3">]</span>

    <span class="s2">with </span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s1">msgs</span><span class="s3">, </span><span class="s1">may_pass</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
        <span class="s1">estimator</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">ignore_warnings</span>
<span class="s2">def </span><span class="s1">check_fit2d_1feature</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">estimator_orig</span><span class="s3">):</span>
    <span class="s5"># check fitting a 2d array with only 1 feature either works or returns</span>
    <span class="s5"># informative message</span>
    <span class="s1">rnd </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">RandomState</span><span class="s3">(</span><span class="s6">0</span><span class="s3">)</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s6">3 </span><span class="s3">* </span><span class="s1">rnd</span><span class="s3">.</span><span class="s1">uniform</span><span class="s3">(</span><span class="s1">size</span><span class="s3">=(</span><span class="s6">10</span><span class="s3">, </span><span class="s6">1</span><span class="s3">))</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">_enforce_estimator_tags_X</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">, </span><span class="s1">X</span><span class="s3">)</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">X</span><span class="s3">[:, </span><span class="s6">0</span><span class="s3">].</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">int</span><span class="s3">)</span>
    <span class="s1">estimator </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">)</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">_enforce_estimator_tags_y</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s4">&quot;n_components&quot;</span><span class="s3">):</span>
        <span class="s1">estimator</span><span class="s3">.</span><span class="s1">n_components </span><span class="s3">= </span><span class="s6">1</span>
    <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s4">&quot;n_clusters&quot;</span><span class="s3">):</span>
        <span class="s1">estimator</span><span class="s3">.</span><span class="s1">n_clusters </span><span class="s3">= </span><span class="s6">1</span>
    <span class="s5"># ensure two labels in subsample for RandomizedLogisticRegression</span>
    <span class="s2">if </span><span class="s1">name </span><span class="s3">== </span><span class="s4">&quot;RandomizedLogisticRegression&quot;</span><span class="s3">:</span>
        <span class="s1">estimator</span><span class="s3">.</span><span class="s1">sample_fraction </span><span class="s3">= </span><span class="s6">1</span>
    <span class="s5"># ensure non skipped trials for RANSACRegressor</span>
    <span class="s2">if </span><span class="s1">name </span><span class="s3">== </span><span class="s4">&quot;RANSACRegressor&quot;</span><span class="s3">:</span>
        <span class="s1">estimator</span><span class="s3">.</span><span class="s1">residual_threshold </span><span class="s3">= </span><span class="s6">0.5</span>

    <span class="s1">y </span><span class="s3">= </span><span class="s1">_enforce_estimator_tags_y</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
    <span class="s1">set_random_state</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s6">1</span><span class="s3">)</span>

    <span class="s1">msgs </span><span class="s3">= [</span><span class="s4">r&quot;1 feature\(s\)&quot;</span><span class="s3">, </span><span class="s4">&quot;n_features = 1&quot;</span><span class="s3">, </span><span class="s4">&quot;n_features=1&quot;</span><span class="s3">]</span>

    <span class="s2">with </span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s1">msgs</span><span class="s3">, </span><span class="s1">may_pass</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
        <span class="s1">estimator</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">ignore_warnings</span>
<span class="s2">def </span><span class="s1">check_fit1d</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">estimator_orig</span><span class="s3">):</span>
    <span class="s5"># check fitting 1d X array raises a ValueError</span>
    <span class="s1">rnd </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">RandomState</span><span class="s3">(</span><span class="s6">0</span><span class="s3">)</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s6">3 </span><span class="s3">* </span><span class="s1">rnd</span><span class="s3">.</span><span class="s1">uniform</span><span class="s3">(</span><span class="s1">size</span><span class="s3">=(</span><span class="s6">20</span><span class="s3">))</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">X</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">int</span><span class="s3">)</span>
    <span class="s1">estimator </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">)</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">_enforce_estimator_tags_y</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s4">&quot;n_components&quot;</span><span class="s3">):</span>
        <span class="s1">estimator</span><span class="s3">.</span><span class="s1">n_components </span><span class="s3">= </span><span class="s6">1</span>
    <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s4">&quot;n_clusters&quot;</span><span class="s3">):</span>
        <span class="s1">estimator</span><span class="s3">.</span><span class="s1">n_clusters </span><span class="s3">= </span><span class="s6">1</span>

    <span class="s1">set_random_state</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s6">1</span><span class="s3">)</span>
    <span class="s2">with </span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">):</span>
        <span class="s1">estimator</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">ignore_warnings</span><span class="s3">(</span><span class="s1">category</span><span class="s3">=</span><span class="s1">FutureWarning</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">check_transformer_general</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">transformer</span><span class="s3">, </span><span class="s1">readonly_memmap</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s1">X</span><span class="s3">, </span><span class="s1">y </span><span class="s3">= </span><span class="s1">make_blobs</span><span class="s3">(</span>
        <span class="s1">n_samples</span><span class="s3">=</span><span class="s6">30</span><span class="s3">,</span>
        <span class="s1">centers</span><span class="s3">=[[</span><span class="s6">0</span><span class="s3">, </span><span class="s6">0</span><span class="s3">, </span><span class="s6">0</span><span class="s3">], [</span><span class="s6">1</span><span class="s3">, </span><span class="s6">1</span><span class="s3">, </span><span class="s6">1</span><span class="s3">]],</span>
        <span class="s1">random_state</span><span class="s3">=</span><span class="s6">0</span><span class="s3">,</span>
        <span class="s1">n_features</span><span class="s3">=</span><span class="s6">2</span><span class="s3">,</span>
        <span class="s1">cluster_std</span><span class="s3">=</span><span class="s6">0.1</span><span class="s3">,</span>
    <span class="s3">)</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">StandardScaler</span><span class="s3">().</span><span class="s1">fit_transform</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">_enforce_estimator_tags_X</span><span class="s3">(</span><span class="s1">transformer</span><span class="s3">, </span><span class="s1">X</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">readonly_memmap</span><span class="s3">:</span>
        <span class="s1">X</span><span class="s3">, </span><span class="s1">y </span><span class="s3">= </span><span class="s1">create_memmap_backed_data</span><span class="s3">([</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">])</span>

    <span class="s1">_check_transformer</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">transformer</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">ignore_warnings</span><span class="s3">(</span><span class="s1">category</span><span class="s3">=</span><span class="s1">FutureWarning</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">check_transformer_data_not_an_array</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">transformer</span><span class="s3">):</span>
    <span class="s1">X</span><span class="s3">, </span><span class="s1">y </span><span class="s3">= </span><span class="s1">make_blobs</span><span class="s3">(</span>
        <span class="s1">n_samples</span><span class="s3">=</span><span class="s6">30</span><span class="s3">,</span>
        <span class="s1">centers</span><span class="s3">=[[</span><span class="s6">0</span><span class="s3">, </span><span class="s6">0</span><span class="s3">, </span><span class="s6">0</span><span class="s3">], [</span><span class="s6">1</span><span class="s3">, </span><span class="s6">1</span><span class="s3">, </span><span class="s6">1</span><span class="s3">]],</span>
        <span class="s1">random_state</span><span class="s3">=</span><span class="s6">0</span><span class="s3">,</span>
        <span class="s1">n_features</span><span class="s3">=</span><span class="s6">2</span><span class="s3">,</span>
        <span class="s1">cluster_std</span><span class="s3">=</span><span class="s6">0.1</span><span class="s3">,</span>
    <span class="s3">)</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">StandardScaler</span><span class="s3">().</span><span class="s1">fit_transform</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">_enforce_estimator_tags_X</span><span class="s3">(</span><span class="s1">transformer</span><span class="s3">, </span><span class="s1">X</span><span class="s3">)</span>
    <span class="s1">this_X </span><span class="s3">= </span><span class="s1">_NotAnArray</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
    <span class="s1">this_y </span><span class="s3">= </span><span class="s1">_NotAnArray</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">y</span><span class="s3">))</span>
    <span class="s1">_check_transformer</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">transformer</span><span class="s3">, </span><span class="s1">this_X</span><span class="s3">, </span><span class="s1">this_y</span><span class="s3">)</span>
    <span class="s5"># try the same with some list</span>
    <span class="s1">_check_transformer</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">transformer</span><span class="s3">, </span><span class="s1">X</span><span class="s3">.</span><span class="s1">tolist</span><span class="s3">(), </span><span class="s1">y</span><span class="s3">.</span><span class="s1">tolist</span><span class="s3">())</span>


<span class="s3">@</span><span class="s1">ignore_warnings</span><span class="s3">(</span><span class="s1">category</span><span class="s3">=</span><span class="s1">FutureWarning</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">check_transformers_unfitted</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">transformer</span><span class="s3">):</span>
    <span class="s1">X</span><span class="s3">, </span><span class="s1">y </span><span class="s3">= </span><span class="s1">_regression_dataset</span><span class="s3">()</span>

    <span class="s1">transformer </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">transformer</span><span class="s3">)</span>
    <span class="s2">with </span><span class="s1">raises</span><span class="s3">(</span>
        <span class="s3">(</span><span class="s1">AttributeError</span><span class="s3">, </span><span class="s1">ValueError</span><span class="s3">),</span>
        <span class="s1">err_msg</span><span class="s3">=(</span>
            <span class="s4">&quot;The unfitted &quot;</span>
            <span class="s4">f&quot;transformer </span><span class="s2">{</span><span class="s1">name</span><span class="s2">} </span><span class="s4">does not raise an error when &quot;</span>
            <span class="s4">&quot;transform is called. Perhaps use &quot;</span>
            <span class="s4">&quot;check_is_fitted in transform.&quot;</span>
        <span class="s3">),</span>
    <span class="s3">):</span>
        <span class="s1">transformer</span><span class="s3">.</span><span class="s1">transform</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">ignore_warnings</span><span class="s3">(</span><span class="s1">category</span><span class="s3">=</span><span class="s1">FutureWarning</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">check_transformers_unfitted_stateless</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">transformer</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Check that using transform without prior fitting 
    doesn't raise a NotFittedError for stateless transformers. 
    &quot;&quot;&quot;</span>
    <span class="s1">rng </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">RandomState</span><span class="s3">(</span><span class="s6">0</span><span class="s3">)</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">rng</span><span class="s3">.</span><span class="s1">uniform</span><span class="s3">(</span><span class="s1">size</span><span class="s3">=(</span><span class="s6">20</span><span class="s3">, </span><span class="s6">5</span><span class="s3">))</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">_enforce_estimator_tags_X</span><span class="s3">(</span><span class="s1">transformer</span><span class="s3">, </span><span class="s1">X</span><span class="s3">)</span>

    <span class="s1">transformer </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">transformer</span><span class="s3">)</span>
    <span class="s1">X_trans </span><span class="s3">= </span><span class="s1">transformer</span><span class="s3">.</span><span class="s1">transform</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>

    <span class="s2">assert </span><span class="s1">X_trans</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] == </span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]</span>


<span class="s2">def </span><span class="s1">_check_transformer</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">transformer_orig</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">):</span>
    <span class="s1">n_samples</span><span class="s3">, </span><span class="s1">n_features </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">X</span><span class="s3">).</span><span class="s1">shape</span>
    <span class="s1">transformer </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">transformer_orig</span><span class="s3">)</span>
    <span class="s1">set_random_state</span><span class="s3">(</span><span class="s1">transformer</span><span class="s3">)</span>

    <span class="s5"># fit</span>

    <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">CROSS_DECOMPOSITION</span><span class="s3">:</span>
        <span class="s1">y_ </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">c_</span><span class="s3">[</span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">y</span><span class="s3">), </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">y</span><span class="s3">)]</span>
        <span class="s1">y_</span><span class="s3">[::</span><span class="s6">2</span><span class="s3">, </span><span class="s6">1</span><span class="s3">] *= </span><span class="s6">2</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">_NotAnArray</span><span class="s3">):</span>
            <span class="s1">y_ </span><span class="s3">= </span><span class="s1">_NotAnArray</span><span class="s3">(</span><span class="s1">y_</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">y_ </span><span class="s3">= </span><span class="s1">y</span>

    <span class="s1">transformer</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y_</span><span class="s3">)</span>
    <span class="s5"># fit_transform method should work on non fitted estimator</span>
    <span class="s1">transformer_clone </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">transformer</span><span class="s3">)</span>
    <span class="s1">X_pred </span><span class="s3">= </span><span class="s1">transformer_clone</span><span class="s3">.</span><span class="s1">fit_transform</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">=</span><span class="s1">y_</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">X_pred</span><span class="s3">, </span><span class="s1">tuple</span><span class="s3">):</span>
        <span class="s2">for </span><span class="s1">x_pred </span><span class="s2">in </span><span class="s1">X_pred</span><span class="s3">:</span>
            <span class="s2">assert </span><span class="s1">x_pred</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] == </span><span class="s1">n_samples</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s5"># check for consistent n_samples</span>
        <span class="s2">assert </span><span class="s1">X_pred</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] == </span><span class="s1">n_samples</span>

    <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">transformer</span><span class="s3">, </span><span class="s4">&quot;transform&quot;</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">CROSS_DECOMPOSITION</span><span class="s3">:</span>
            <span class="s1">X_pred2 </span><span class="s3">= </span><span class="s1">transformer</span><span class="s3">.</span><span class="s1">transform</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y_</span><span class="s3">)</span>
            <span class="s1">X_pred3 </span><span class="s3">= </span><span class="s1">transformer</span><span class="s3">.</span><span class="s1">fit_transform</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">=</span><span class="s1">y_</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">X_pred2 </span><span class="s3">= </span><span class="s1">transformer</span><span class="s3">.</span><span class="s1">transform</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
            <span class="s1">X_pred3 </span><span class="s3">= </span><span class="s1">transformer</span><span class="s3">.</span><span class="s1">fit_transform</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">=</span><span class="s1">y_</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">_safe_tags</span><span class="s3">(</span><span class="s1">transformer_orig</span><span class="s3">, </span><span class="s1">key</span><span class="s3">=</span><span class="s4">&quot;non_deterministic&quot;</span><span class="s3">):</span>
            <span class="s1">msg </span><span class="s3">= </span><span class="s1">name </span><span class="s3">+ </span><span class="s4">&quot; is non deterministic&quot;</span>
            <span class="s2">raise </span><span class="s1">SkipTest</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">X_pred</span><span class="s3">, </span><span class="s1">tuple</span><span class="s3">) </span><span class="s2">and </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">X_pred2</span><span class="s3">, </span><span class="s1">tuple</span><span class="s3">):</span>
            <span class="s2">for </span><span class="s1">x_pred</span><span class="s3">, </span><span class="s1">x_pred2</span><span class="s3">, </span><span class="s1">x_pred3 </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">X_pred</span><span class="s3">, </span><span class="s1">X_pred2</span><span class="s3">, </span><span class="s1">X_pred3</span><span class="s3">):</span>
                <span class="s1">assert_allclose_dense_sparse</span><span class="s3">(</span>
                    <span class="s1">x_pred</span><span class="s3">,</span>
                    <span class="s1">x_pred2</span><span class="s3">,</span>
                    <span class="s1">atol</span><span class="s3">=</span><span class="s6">1e-2</span><span class="s3">,</span>
                    <span class="s1">err_msg</span><span class="s3">=</span><span class="s4">&quot;fit_transform and transform outcomes not consistent in %s&quot;</span>
                    <span class="s3">% </span><span class="s1">transformer</span><span class="s3">,</span>
                <span class="s3">)</span>
                <span class="s1">assert_allclose_dense_sparse</span><span class="s3">(</span>
                    <span class="s1">x_pred</span><span class="s3">,</span>
                    <span class="s1">x_pred3</span><span class="s3">,</span>
                    <span class="s1">atol</span><span class="s3">=</span><span class="s6">1e-2</span><span class="s3">,</span>
                    <span class="s1">err_msg</span><span class="s3">=</span><span class="s4">&quot;consecutive fit_transform outcomes not consistent in %s&quot;</span>
                    <span class="s3">% </span><span class="s1">transformer</span><span class="s3">,</span>
                <span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">assert_allclose_dense_sparse</span><span class="s3">(</span>
                <span class="s1">X_pred</span><span class="s3">,</span>
                <span class="s1">X_pred2</span><span class="s3">,</span>
                <span class="s1">err_msg</span><span class="s3">=</span><span class="s4">&quot;fit_transform and transform outcomes not consistent in %s&quot;</span>
                <span class="s3">% </span><span class="s1">transformer</span><span class="s3">,</span>
                <span class="s1">atol</span><span class="s3">=</span><span class="s6">1e-2</span><span class="s3">,</span>
            <span class="s3">)</span>
            <span class="s1">assert_allclose_dense_sparse</span><span class="s3">(</span>
                <span class="s1">X_pred</span><span class="s3">,</span>
                <span class="s1">X_pred3</span><span class="s3">,</span>
                <span class="s1">atol</span><span class="s3">=</span><span class="s6">1e-2</span><span class="s3">,</span>
                <span class="s1">err_msg</span><span class="s3">=</span><span class="s4">&quot;consecutive fit_transform outcomes not consistent in %s&quot;</span>
                <span class="s3">% </span><span class="s1">transformer</span><span class="s3">,</span>
            <span class="s3">)</span>
            <span class="s2">assert </span><span class="s1">_num_samples</span><span class="s3">(</span><span class="s1">X_pred2</span><span class="s3">) == </span><span class="s1">n_samples</span>
            <span class="s2">assert </span><span class="s1">_num_samples</span><span class="s3">(</span><span class="s1">X_pred3</span><span class="s3">) == </span><span class="s1">n_samples</span>

        <span class="s5"># raises error on malformed input for transform</span>
        <span class="s2">if </span><span class="s3">(</span>
            <span class="s1">hasattr</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s4">&quot;shape&quot;</span><span class="s3">)</span>
            <span class="s2">and not </span><span class="s1">_safe_tags</span><span class="s3">(</span><span class="s1">transformer</span><span class="s3">, </span><span class="s1">key</span><span class="s3">=</span><span class="s4">&quot;stateless&quot;</span><span class="s3">)</span>
            <span class="s2">and </span><span class="s1">X</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s6">2</span>
            <span class="s2">and </span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s6">1</span><span class="s3">] &gt; </span><span class="s6">1</span>
        <span class="s3">):</span>
            <span class="s5"># If it's not an array, it does not have a 'T' property</span>
            <span class="s2">with </span><span class="s1">raises</span><span class="s3">(</span>
                <span class="s1">ValueError</span><span class="s3">,</span>
                <span class="s1">err_msg</span><span class="s3">=(</span>
                    <span class="s4">f&quot;The transformer </span><span class="s2">{</span><span class="s1">name</span><span class="s2">} </span><span class="s4">does not raise an error &quot;</span>
                    <span class="s4">&quot;when the number of features in transform is different from &quot;</span>
                    <span class="s4">&quot;the number of features in fit.&quot;</span>
                <span class="s3">),</span>
            <span class="s3">):</span>
                <span class="s1">transformer</span><span class="s3">.</span><span class="s1">transform</span><span class="s3">(</span><span class="s1">X</span><span class="s3">[:, :-</span><span class="s6">1</span><span class="s3">])</span>


<span class="s3">@</span><span class="s1">ignore_warnings</span>
<span class="s2">def </span><span class="s1">check_pipeline_consistency</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">estimator_orig</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">_safe_tags</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">, </span><span class="s1">key</span><span class="s3">=</span><span class="s4">&quot;non_deterministic&quot;</span><span class="s3">):</span>
        <span class="s1">msg </span><span class="s3">= </span><span class="s1">name </span><span class="s3">+ </span><span class="s4">&quot; is non deterministic&quot;</span>
        <span class="s2">raise </span><span class="s1">SkipTest</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>

    <span class="s5"># check that make_pipeline(est) gives same score as est</span>
    <span class="s1">X</span><span class="s3">, </span><span class="s1">y </span><span class="s3">= </span><span class="s1">make_blobs</span><span class="s3">(</span>
        <span class="s1">n_samples</span><span class="s3">=</span><span class="s6">30</span><span class="s3">,</span>
        <span class="s1">centers</span><span class="s3">=[[</span><span class="s6">0</span><span class="s3">, </span><span class="s6">0</span><span class="s3">, </span><span class="s6">0</span><span class="s3">], [</span><span class="s6">1</span><span class="s3">, </span><span class="s6">1</span><span class="s3">, </span><span class="s6">1</span><span class="s3">]],</span>
        <span class="s1">random_state</span><span class="s3">=</span><span class="s6">0</span><span class="s3">,</span>
        <span class="s1">n_features</span><span class="s3">=</span><span class="s6">2</span><span class="s3">,</span>
        <span class="s1">cluster_std</span><span class="s3">=</span><span class="s6">0.1</span><span class="s3">,</span>
    <span class="s3">)</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">_enforce_estimator_tags_X</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">kernel</span><span class="s3">=</span><span class="s1">rbf_kernel</span><span class="s3">)</span>
    <span class="s1">estimator </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">)</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">_enforce_estimator_tags_y</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
    <span class="s1">set_random_state</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">)</span>
    <span class="s1">pipeline </span><span class="s3">= </span><span class="s1">make_pipeline</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">)</span>
    <span class="s1">estimator</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
    <span class="s1">pipeline</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>

    <span class="s1">funcs </span><span class="s3">= [</span><span class="s4">&quot;score&quot;</span><span class="s3">, </span><span class="s4">&quot;fit_transform&quot;</span><span class="s3">]</span>

    <span class="s2">for </span><span class="s1">func_name </span><span class="s2">in </span><span class="s1">funcs</span><span class="s3">:</span>
        <span class="s1">func </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">func_name</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">func </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s1">func_pipeline </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">pipeline</span><span class="s3">, </span><span class="s1">func_name</span><span class="s3">)</span>
            <span class="s1">result </span><span class="s3">= </span><span class="s1">func</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
            <span class="s1">result_pipe </span><span class="s3">= </span><span class="s1">func_pipeline</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
            <span class="s1">assert_allclose_dense_sparse</span><span class="s3">(</span><span class="s1">result</span><span class="s3">, </span><span class="s1">result_pipe</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">ignore_warnings</span>
<span class="s2">def </span><span class="s1">check_fit_score_takes_y</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">estimator_orig</span><span class="s3">):</span>
    <span class="s5"># check that all estimators accept an optional y</span>
    <span class="s5"># in fit and score so they can be used in pipelines</span>
    <span class="s1">rnd </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">RandomState</span><span class="s3">(</span><span class="s6">0</span><span class="s3">)</span>
    <span class="s1">n_samples </span><span class="s3">= </span><span class="s6">30</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">rnd</span><span class="s3">.</span><span class="s1">uniform</span><span class="s3">(</span><span class="s1">size</span><span class="s3">=(</span><span class="s1">n_samples</span><span class="s3">, </span><span class="s6">3</span><span class="s3">))</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">_enforce_estimator_tags_X</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">, </span><span class="s1">X</span><span class="s3">)</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s1">n_samples</span><span class="s3">) % </span><span class="s6">3</span>
    <span class="s1">estimator </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">)</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">_enforce_estimator_tags_y</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
    <span class="s1">set_random_state</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">)</span>

    <span class="s1">funcs </span><span class="s3">= [</span><span class="s4">&quot;fit&quot;</span><span class="s3">, </span><span class="s4">&quot;score&quot;</span><span class="s3">, </span><span class="s4">&quot;partial_fit&quot;</span><span class="s3">, </span><span class="s4">&quot;fit_predict&quot;</span><span class="s3">, </span><span class="s4">&quot;fit_transform&quot;</span><span class="s3">]</span>
    <span class="s2">for </span><span class="s1">func_name </span><span class="s2">in </span><span class="s1">funcs</span><span class="s3">:</span>
        <span class="s1">func </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">func_name</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">func </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s1">func</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
            <span class="s1">args </span><span class="s3">= [</span><span class="s1">p</span><span class="s3">.</span><span class="s1">name </span><span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">signature</span><span class="s3">(</span><span class="s1">func</span><span class="s3">).</span><span class="s1">parameters</span><span class="s3">.</span><span class="s1">values</span><span class="s3">()]</span>
            <span class="s2">if </span><span class="s1">args</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] == </span><span class="s4">&quot;self&quot;</span><span class="s3">:</span>
                <span class="s5"># available_if makes methods into functions</span>
                <span class="s5"># with an explicit &quot;self&quot;, so need to shift arguments</span>
                <span class="s1">args </span><span class="s3">= </span><span class="s1">args</span><span class="s3">[</span><span class="s6">1</span><span class="s3">:]</span>
            <span class="s2">assert </span><span class="s1">args</span><span class="s3">[</span><span class="s6">1</span><span class="s3">] </span><span class="s2">in </span><span class="s3">[</span><span class="s4">&quot;y&quot;</span><span class="s3">, </span><span class="s4">&quot;Y&quot;</span><span class="s3">], (</span>
                <span class="s4">&quot;Expected y or Y as second argument for method &quot;</span>
                <span class="s4">&quot;%s of %s. Got arguments: %r.&quot;</span>
                <span class="s3">% (</span><span class="s1">func_name</span><span class="s3">, </span><span class="s1">type</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">).</span><span class="s1">__name__</span><span class="s3">, </span><span class="s1">args</span><span class="s3">)</span>
            <span class="s3">)</span>


<span class="s3">@</span><span class="s1">ignore_warnings</span>
<span class="s2">def </span><span class="s1">check_estimators_dtypes</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">estimator_orig</span><span class="s3">):</span>
    <span class="s1">rnd </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">RandomState</span><span class="s3">(</span><span class="s6">0</span><span class="s3">)</span>
    <span class="s1">X_train_32 </span><span class="s3">= </span><span class="s6">3 </span><span class="s3">* </span><span class="s1">rnd</span><span class="s3">.</span><span class="s1">uniform</span><span class="s3">(</span><span class="s1">size</span><span class="s3">=(</span><span class="s6">20</span><span class="s3">, </span><span class="s6">5</span><span class="s3">)).</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float32</span><span class="s3">)</span>
    <span class="s1">X_train_32 </span><span class="s3">= </span><span class="s1">_enforce_estimator_tags_X</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">, </span><span class="s1">X_train_32</span><span class="s3">)</span>
    <span class="s1">X_train_64 </span><span class="s3">= </span><span class="s1">X_train_32</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">)</span>
    <span class="s1">X_train_int_64 </span><span class="s3">= </span><span class="s1">X_train_32</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">int64</span><span class="s3">)</span>
    <span class="s1">X_train_int_32 </span><span class="s3">= </span><span class="s1">X_train_32</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">int32</span><span class="s3">)</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s6">1</span><span class="s3">, </span><span class="s6">2</span><span class="s3">] * </span><span class="s6">10</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">int64</span><span class="s3">)</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">_enforce_estimator_tags_y</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>

    <span class="s1">methods </span><span class="s3">= [</span><span class="s4">&quot;predict&quot;</span><span class="s3">, </span><span class="s4">&quot;transform&quot;</span><span class="s3">, </span><span class="s4">&quot;decision_function&quot;</span><span class="s3">, </span><span class="s4">&quot;predict_proba&quot;</span><span class="s3">]</span>

    <span class="s2">for </span><span class="s1">X_train </span><span class="s2">in </span><span class="s3">[</span><span class="s1">X_train_32</span><span class="s3">, </span><span class="s1">X_train_64</span><span class="s3">, </span><span class="s1">X_train_int_64</span><span class="s3">, </span><span class="s1">X_train_int_32</span><span class="s3">]:</span>
        <span class="s1">estimator </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">)</span>
        <span class="s1">set_random_state</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s6">1</span><span class="s3">)</span>
        <span class="s1">estimator</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X_train</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>

        <span class="s2">for </span><span class="s1">method </span><span class="s2">in </span><span class="s1">methods</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">method</span><span class="s3">):</span>
                <span class="s1">getattr</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">method</span><span class="s3">)(</span><span class="s1">X_train</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">check_transformer_preserve_dtypes</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">transformer_orig</span><span class="s3">):</span>
    <span class="s5"># check that dtype are preserved meaning if input X is of some dtype</span>
    <span class="s5"># X_transformed should be from the same dtype.</span>
    <span class="s1">X</span><span class="s3">, </span><span class="s1">y </span><span class="s3">= </span><span class="s1">make_blobs</span><span class="s3">(</span>
        <span class="s1">n_samples</span><span class="s3">=</span><span class="s6">30</span><span class="s3">,</span>
        <span class="s1">centers</span><span class="s3">=[[</span><span class="s6">0</span><span class="s3">, </span><span class="s6">0</span><span class="s3">, </span><span class="s6">0</span><span class="s3">], [</span><span class="s6">1</span><span class="s3">, </span><span class="s6">1</span><span class="s3">, </span><span class="s6">1</span><span class="s3">]],</span>
        <span class="s1">random_state</span><span class="s3">=</span><span class="s6">0</span><span class="s3">,</span>
        <span class="s1">cluster_std</span><span class="s3">=</span><span class="s6">0.1</span><span class="s3">,</span>
    <span class="s3">)</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">StandardScaler</span><span class="s3">().</span><span class="s1">fit_transform</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">_enforce_estimator_tags_X</span><span class="s3">(</span><span class="s1">transformer_orig</span><span class="s3">, </span><span class="s1">X</span><span class="s3">)</span>

    <span class="s2">for </span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">_safe_tags</span><span class="s3">(</span><span class="s1">transformer_orig</span><span class="s3">, </span><span class="s1">key</span><span class="s3">=</span><span class="s4">&quot;preserves_dtype&quot;</span><span class="s3">):</span>
        <span class="s1">X_cast </span><span class="s3">= </span><span class="s1">X</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">)</span>
        <span class="s1">transformer </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">transformer_orig</span><span class="s3">)</span>
        <span class="s1">set_random_state</span><span class="s3">(</span><span class="s1">transformer</span><span class="s3">)</span>
        <span class="s1">X_trans1 </span><span class="s3">= </span><span class="s1">transformer</span><span class="s3">.</span><span class="s1">fit_transform</span><span class="s3">(</span><span class="s1">X_cast</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
        <span class="s1">X_trans2 </span><span class="s3">= </span><span class="s1">transformer</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X_cast</span><span class="s3">, </span><span class="s1">y</span><span class="s3">).</span><span class="s1">transform</span><span class="s3">(</span><span class="s1">X_cast</span><span class="s3">)</span>

        <span class="s2">for </span><span class="s1">Xt</span><span class="s3">, </span><span class="s1">method </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">([</span><span class="s1">X_trans1</span><span class="s3">, </span><span class="s1">X_trans2</span><span class="s3">], [</span><span class="s4">&quot;fit_transform&quot;</span><span class="s3">, </span><span class="s4">&quot;transform&quot;</span><span class="s3">]):</span>
            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">Xt</span><span class="s3">, </span><span class="s1">tuple</span><span class="s3">):</span>
                <span class="s5"># cross-decompostion returns a tuple of (x_scores, y_scores)</span>
                <span class="s5"># when given y with fit_transform; only check the first element</span>
                <span class="s1">Xt </span><span class="s3">= </span><span class="s1">Xt</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]</span>

            <span class="s5"># check that the output dtype is preserved</span>
            <span class="s2">assert </span><span class="s1">Xt</span><span class="s3">.</span><span class="s1">dtype </span><span class="s3">== </span><span class="s1">dtype</span><span class="s3">, (</span>
                <span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">name</span><span class="s2">} </span><span class="s4">(method=</span><span class="s2">{</span><span class="s1">method</span><span class="s2">}</span><span class="s4">) does not preserve dtype. &quot;</span>
                <span class="s4">f&quot;Original/Expected dtype=</span><span class="s2">{</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">__name__</span><span class="s2">}</span><span class="s4">, got dtype=</span><span class="s2">{</span><span class="s1">Xt</span><span class="s3">.</span><span class="s1">dtype</span><span class="s2">}</span><span class="s4">.&quot;</span>
            <span class="s3">)</span>


<span class="s3">@</span><span class="s1">ignore_warnings</span><span class="s3">(</span><span class="s1">category</span><span class="s3">=</span><span class="s1">FutureWarning</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">check_estimators_empty_data_messages</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">estimator_orig</span><span class="s3">):</span>
    <span class="s1">e </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">)</span>
    <span class="s1">set_random_state</span><span class="s3">(</span><span class="s1">e</span><span class="s3">, </span><span class="s6">1</span><span class="s3">)</span>

    <span class="s1">X_zero_samples </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s6">0</span><span class="s3">).</span><span class="s1">reshape</span><span class="s3">(</span><span class="s6">0</span><span class="s3">, </span><span class="s6">3</span><span class="s3">)</span>
    <span class="s5"># The precise message can change depending on whether X or y is</span>
    <span class="s5"># validated first. Let us test the type of exception only:</span>
    <span class="s1">err_msg </span><span class="s3">= (</span>
        <span class="s4">f&quot;The estimator </span><span class="s2">{</span><span class="s1">name</span><span class="s2">} </span><span class="s4">does not raise a ValueError when an &quot;</span>
        <span class="s4">&quot;empty data is used to train. Perhaps use check_array in train.&quot;</span>
    <span class="s3">)</span>
    <span class="s2">with </span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">err_msg</span><span class="s3">=</span><span class="s1">err_msg</span><span class="s3">):</span>
        <span class="s1">e</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X_zero_samples</span><span class="s3">, [])</span>

    <span class="s1">X_zero_features </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s6">0</span><span class="s3">).</span><span class="s1">reshape</span><span class="s3">(</span><span class="s6">12</span><span class="s3">, </span><span class="s6">0</span><span class="s3">)</span>
    <span class="s5"># the following y should be accepted by both classifiers and regressors</span>
    <span class="s5"># and ignored by unsupervised models</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">_enforce_estimator_tags_y</span><span class="s3">(</span><span class="s1">e</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s6">1</span><span class="s3">, </span><span class="s6">0</span><span class="s3">, </span><span class="s6">1</span><span class="s3">, </span><span class="s6">0</span><span class="s3">, </span><span class="s6">1</span><span class="s3">, </span><span class="s6">0</span><span class="s3">, </span><span class="s6">1</span><span class="s3">, </span><span class="s6">0</span><span class="s3">, </span><span class="s6">1</span><span class="s3">, </span><span class="s6">0</span><span class="s3">, </span><span class="s6">1</span><span class="s3">, </span><span class="s6">0</span><span class="s3">]))</span>
    <span class="s1">msg </span><span class="s3">= </span><span class="s4">r&quot;0 feature\(s\) \(shape=\(\d*, 0\)\) while a minimum of \d* &quot; &quot;is required.&quot;</span>
    <span class="s2">with </span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s1">msg</span><span class="s3">):</span>
        <span class="s1">e</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X_zero_features</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">ignore_warnings</span><span class="s3">(</span><span class="s1">category</span><span class="s3">=</span><span class="s1">FutureWarning</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">check_estimators_nan_inf</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">estimator_orig</span><span class="s3">):</span>
    <span class="s5"># Checks that Estimator X's do not contain NaN or inf.</span>
    <span class="s1">rnd </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">RandomState</span><span class="s3">(</span><span class="s6">0</span><span class="s3">)</span>
    <span class="s1">X_train_finite </span><span class="s3">= </span><span class="s1">_enforce_estimator_tags_X</span><span class="s3">(</span>
        <span class="s1">estimator_orig</span><span class="s3">, </span><span class="s1">rnd</span><span class="s3">.</span><span class="s1">uniform</span><span class="s3">(</span><span class="s1">size</span><span class="s3">=(</span><span class="s6">10</span><span class="s3">, </span><span class="s6">3</span><span class="s3">))</span>
    <span class="s3">)</span>
    <span class="s1">X_train_nan </span><span class="s3">= </span><span class="s1">rnd</span><span class="s3">.</span><span class="s1">uniform</span><span class="s3">(</span><span class="s1">size</span><span class="s3">=(</span><span class="s6">10</span><span class="s3">, </span><span class="s6">3</span><span class="s3">))</span>
    <span class="s1">X_train_nan</span><span class="s3">[</span><span class="s6">0</span><span class="s3">, </span><span class="s6">0</span><span class="s3">] = </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span>
    <span class="s1">X_train_inf </span><span class="s3">= </span><span class="s1">rnd</span><span class="s3">.</span><span class="s1">uniform</span><span class="s3">(</span><span class="s1">size</span><span class="s3">=(</span><span class="s6">10</span><span class="s3">, </span><span class="s6">3</span><span class="s3">))</span>
    <span class="s1">X_train_inf</span><span class="s3">[</span><span class="s6">0</span><span class="s3">, </span><span class="s6">0</span><span class="s3">] = </span><span class="s1">np</span><span class="s3">.</span><span class="s1">inf</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s6">10</span><span class="s3">)</span>
    <span class="s1">y</span><span class="s3">[:</span><span class="s6">5</span><span class="s3">] = </span><span class="s6">0</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">_enforce_estimator_tags_y</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
    <span class="s1">error_string_fit </span><span class="s3">= </span><span class="s4">f&quot;Estimator </span><span class="s2">{</span><span class="s1">name</span><span class="s2">} </span><span class="s4">doesn't check for NaN and inf in fit.&quot;</span>
    <span class="s1">error_string_predict </span><span class="s3">= </span><span class="s4">f&quot;Estimator </span><span class="s2">{</span><span class="s1">name</span><span class="s2">} </span><span class="s4">doesn't check for NaN and inf in predict.&quot;</span>
    <span class="s1">error_string_transform </span><span class="s3">= (</span>
        <span class="s4">f&quot;Estimator </span><span class="s2">{</span><span class="s1">name</span><span class="s2">} </span><span class="s4">doesn't check for NaN and inf in transform.&quot;</span>
    <span class="s3">)</span>
    <span class="s2">for </span><span class="s1">X_train </span><span class="s2">in </span><span class="s3">[</span><span class="s1">X_train_nan</span><span class="s3">, </span><span class="s1">X_train_inf</span><span class="s3">]:</span>
        <span class="s5"># catch deprecation warnings</span>
        <span class="s2">with </span><span class="s1">ignore_warnings</span><span class="s3">(</span><span class="s1">category</span><span class="s3">=</span><span class="s1">FutureWarning</span><span class="s3">):</span>
            <span class="s1">estimator </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">)</span>
            <span class="s1">set_random_state</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s6">1</span><span class="s3">)</span>
            <span class="s5"># try to fit</span>
            <span class="s2">with </span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=[</span><span class="s4">&quot;inf&quot;</span><span class="s3">, </span><span class="s4">&quot;NaN&quot;</span><span class="s3">], </span><span class="s1">err_msg</span><span class="s3">=</span><span class="s1">error_string_fit</span><span class="s3">):</span>
                <span class="s1">estimator</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X_train</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
            <span class="s5"># actually fit</span>
            <span class="s1">estimator</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X_train_finite</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>

            <span class="s5"># predict</span>
            <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s4">&quot;predict&quot;</span><span class="s3">):</span>
                <span class="s2">with </span><span class="s1">raises</span><span class="s3">(</span>
                    <span class="s1">ValueError</span><span class="s3">,</span>
                    <span class="s1">match</span><span class="s3">=[</span><span class="s4">&quot;inf&quot;</span><span class="s3">, </span><span class="s4">&quot;NaN&quot;</span><span class="s3">],</span>
                    <span class="s1">err_msg</span><span class="s3">=</span><span class="s1">error_string_predict</span><span class="s3">,</span>
                <span class="s3">):</span>
                    <span class="s1">estimator</span><span class="s3">.</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">X_train</span><span class="s3">)</span>

            <span class="s5"># transform</span>
            <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s4">&quot;transform&quot;</span><span class="s3">):</span>
                <span class="s2">with </span><span class="s1">raises</span><span class="s3">(</span>
                    <span class="s1">ValueError</span><span class="s3">,</span>
                    <span class="s1">match</span><span class="s3">=[</span><span class="s4">&quot;inf&quot;</span><span class="s3">, </span><span class="s4">&quot;NaN&quot;</span><span class="s3">],</span>
                    <span class="s1">err_msg</span><span class="s3">=</span><span class="s1">error_string_transform</span><span class="s3">,</span>
                <span class="s3">):</span>
                    <span class="s1">estimator</span><span class="s3">.</span><span class="s1">transform</span><span class="s3">(</span><span class="s1">X_train</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">ignore_warnings</span>
<span class="s2">def </span><span class="s1">check_nonsquare_error</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">estimator_orig</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Test that error is thrown when non-square data provided.&quot;&quot;&quot;</span>

    <span class="s1">X</span><span class="s3">, </span><span class="s1">y </span><span class="s3">= </span><span class="s1">make_blobs</span><span class="s3">(</span><span class="s1">n_samples</span><span class="s3">=</span><span class="s6">20</span><span class="s3">, </span><span class="s1">n_features</span><span class="s3">=</span><span class="s6">10</span><span class="s3">)</span>
    <span class="s1">estimator </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">)</span>

    <span class="s2">with </span><span class="s1">raises</span><span class="s3">(</span>
        <span class="s1">ValueError</span><span class="s3">,</span>
        <span class="s1">err_msg</span><span class="s3">=(</span>
            <span class="s4">f&quot;The pairwise estimator </span><span class="s2">{</span><span class="s1">name</span><span class="s2">} </span><span class="s4">does not raise an error on non-square data&quot;</span>
        <span class="s3">),</span>
    <span class="s3">):</span>
        <span class="s1">estimator</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">ignore_warnings</span>
<span class="s2">def </span><span class="s1">check_estimators_pickle</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">estimator_orig</span><span class="s3">, </span><span class="s1">readonly_memmap</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Test that we can pickle all estimators.&quot;&quot;&quot;</span>
    <span class="s1">check_methods </span><span class="s3">= [</span><span class="s4">&quot;predict&quot;</span><span class="s3">, </span><span class="s4">&quot;transform&quot;</span><span class="s3">, </span><span class="s4">&quot;decision_function&quot;</span><span class="s3">, </span><span class="s4">&quot;predict_proba&quot;</span><span class="s3">]</span>

    <span class="s1">X</span><span class="s3">, </span><span class="s1">y </span><span class="s3">= </span><span class="s1">make_blobs</span><span class="s3">(</span>
        <span class="s1">n_samples</span><span class="s3">=</span><span class="s6">30</span><span class="s3">,</span>
        <span class="s1">centers</span><span class="s3">=[[</span><span class="s6">0</span><span class="s3">, </span><span class="s6">0</span><span class="s3">, </span><span class="s6">0</span><span class="s3">], [</span><span class="s6">1</span><span class="s3">, </span><span class="s6">1</span><span class="s3">, </span><span class="s6">1</span><span class="s3">]],</span>
        <span class="s1">random_state</span><span class="s3">=</span><span class="s6">0</span><span class="s3">,</span>
        <span class="s1">n_features</span><span class="s3">=</span><span class="s6">2</span><span class="s3">,</span>
        <span class="s1">cluster_std</span><span class="s3">=</span><span class="s6">0.1</span><span class="s3">,</span>
    <span class="s3">)</span>

    <span class="s1">X </span><span class="s3">= </span><span class="s1">_enforce_estimator_tags_X</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">kernel</span><span class="s3">=</span><span class="s1">rbf_kernel</span><span class="s3">)</span>

    <span class="s1">tags </span><span class="s3">= </span><span class="s1">_safe_tags</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">)</span>
    <span class="s5"># include NaN values when the estimator should deal with them</span>
    <span class="s2">if </span><span class="s1">tags</span><span class="s3">[</span><span class="s4">&quot;allow_nan&quot;</span><span class="s3">]:</span>
        <span class="s5"># set randomly 10 elements to np.nan</span>
        <span class="s1">rng </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">RandomState</span><span class="s3">(</span><span class="s6">42</span><span class="s3">)</span>
        <span class="s1">mask </span><span class="s3">= </span><span class="s1">rng</span><span class="s3">.</span><span class="s1">choice</span><span class="s3">(</span><span class="s1">X</span><span class="s3">.</span><span class="s1">size</span><span class="s3">, </span><span class="s6">10</span><span class="s3">, </span><span class="s1">replace</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
        <span class="s1">X</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">(-</span><span class="s6">1</span><span class="s3">)[</span><span class="s1">mask</span><span class="s3">] = </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span>

    <span class="s1">estimator </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">)</span>

    <span class="s1">y </span><span class="s3">= </span><span class="s1">_enforce_estimator_tags_y</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>

    <span class="s1">set_random_state</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">)</span>
    <span class="s1">estimator</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">readonly_memmap</span><span class="s3">:</span>
        <span class="s1">unpickled_estimator </span><span class="s3">= </span><span class="s1">create_memmap_backed_data</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s5"># No need to touch the file system in that case.</span>
        <span class="s1">pickled_estimator </span><span class="s3">= </span><span class="s1">pickle</span><span class="s3">.</span><span class="s1">dumps</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">)</span>
        <span class="s1">module_name </span><span class="s3">= </span><span class="s1">estimator</span><span class="s3">.</span><span class="s1">__module__</span>
        <span class="s2">if </span><span class="s1">module_name</span><span class="s3">.</span><span class="s1">startswith</span><span class="s3">(</span><span class="s4">&quot;sklearn.&quot;</span><span class="s3">) </span><span class="s2">and not </span><span class="s3">(</span>
            <span class="s4">&quot;test_&quot; </span><span class="s2">in </span><span class="s1">module_name </span><span class="s2">or </span><span class="s1">module_name</span><span class="s3">.</span><span class="s1">endswith</span><span class="s3">(</span><span class="s4">&quot;_testing&quot;</span><span class="s3">)</span>
        <span class="s3">):</span>
            <span class="s5"># strict check for sklearn estimators that are not implemented in test</span>
            <span class="s5"># modules.</span>
            <span class="s2">assert </span><span class="s7">b&quot;_sklearn_version&quot; </span><span class="s2">in </span><span class="s1">pickled_estimator</span>
        <span class="s1">unpickled_estimator </span><span class="s3">= </span><span class="s1">pickle</span><span class="s3">.</span><span class="s1">loads</span><span class="s3">(</span><span class="s1">pickled_estimator</span><span class="s3">)</span>

    <span class="s1">result </span><span class="s3">= </span><span class="s1">dict</span><span class="s3">()</span>
    <span class="s2">for </span><span class="s1">method </span><span class="s2">in </span><span class="s1">check_methods</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">method</span><span class="s3">):</span>
            <span class="s1">result</span><span class="s3">[</span><span class="s1">method</span><span class="s3">] = </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">method</span><span class="s3">)(</span><span class="s1">X</span><span class="s3">)</span>

    <span class="s2">for </span><span class="s1">method </span><span class="s2">in </span><span class="s1">result</span><span class="s3">:</span>
        <span class="s1">unpickled_result </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">unpickled_estimator</span><span class="s3">, </span><span class="s1">method</span><span class="s3">)(</span><span class="s1">X</span><span class="s3">)</span>
        <span class="s1">assert_allclose_dense_sparse</span><span class="s3">(</span><span class="s1">result</span><span class="s3">[</span><span class="s1">method</span><span class="s3">], </span><span class="s1">unpickled_result</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">ignore_warnings</span><span class="s3">(</span><span class="s1">category</span><span class="s3">=</span><span class="s1">FutureWarning</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">check_estimators_partial_fit_n_features</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">estimator_orig</span><span class="s3">):</span>
    <span class="s5"># check if number of features changes between calls to partial_fit.</span>
    <span class="s2">if not </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">, </span><span class="s4">&quot;partial_fit&quot;</span><span class="s3">):</span>
        <span class="s2">return</span>
    <span class="s1">estimator </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">)</span>
    <span class="s1">X</span><span class="s3">, </span><span class="s1">y </span><span class="s3">= </span><span class="s1">make_blobs</span><span class="s3">(</span><span class="s1">n_samples</span><span class="s3">=</span><span class="s6">50</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s6">1</span><span class="s3">)</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">_enforce_estimator_tags_X</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">, </span><span class="s1">X</span><span class="s3">)</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">_enforce_estimator_tags_y</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>

    <span class="s2">try</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">is_classifier</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">):</span>
            <span class="s1">classes </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">unique</span><span class="s3">(</span><span class="s1">y</span><span class="s3">)</span>
            <span class="s1">estimator</span><span class="s3">.</span><span class="s1">partial_fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">classes</span><span class="s3">=</span><span class="s1">classes</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">estimator</span><span class="s3">.</span><span class="s1">partial_fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
    <span class="s2">except </span><span class="s1">NotImplementedError</span><span class="s3">:</span>
        <span class="s2">return</span>

    <span class="s2">with </span><span class="s1">raises</span><span class="s3">(</span>
        <span class="s1">ValueError</span><span class="s3">,</span>
        <span class="s1">err_msg</span><span class="s3">=(</span>
            <span class="s4">f&quot;The estimator </span><span class="s2">{</span><span class="s1">name</span><span class="s2">} </span><span class="s4">does not raise an error when the &quot;</span>
            <span class="s4">&quot;number of features changes between calls to partial_fit.&quot;</span>
        <span class="s3">),</span>
    <span class="s3">):</span>
        <span class="s1">estimator</span><span class="s3">.</span><span class="s1">partial_fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">[:, :-</span><span class="s6">1</span><span class="s3">], </span><span class="s1">y</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">ignore_warnings</span><span class="s3">(</span><span class="s1">category</span><span class="s3">=</span><span class="s1">FutureWarning</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">check_classifier_multioutput</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">estimator</span><span class="s3">):</span>
    <span class="s1">n_samples</span><span class="s3">, </span><span class="s1">n_labels</span><span class="s3">, </span><span class="s1">n_classes </span><span class="s3">= </span><span class="s6">42</span><span class="s3">, </span><span class="s6">5</span><span class="s3">, </span><span class="s6">3</span>
    <span class="s1">tags </span><span class="s3">= </span><span class="s1">_safe_tags</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">)</span>
    <span class="s1">estimator </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">)</span>
    <span class="s1">X</span><span class="s3">, </span><span class="s1">y </span><span class="s3">= </span><span class="s1">make_multilabel_classification</span><span class="s3">(</span>
        <span class="s1">random_state</span><span class="s3">=</span><span class="s6">42</span><span class="s3">, </span><span class="s1">n_samples</span><span class="s3">=</span><span class="s1">n_samples</span><span class="s3">, </span><span class="s1">n_labels</span><span class="s3">=</span><span class="s1">n_labels</span><span class="s3">, </span><span class="s1">n_classes</span><span class="s3">=</span><span class="s1">n_classes</span>
    <span class="s3">)</span>
    <span class="s1">estimator</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
    <span class="s1">y_pred </span><span class="s3">= </span><span class="s1">estimator</span><span class="s3">.</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>

    <span class="s2">assert </span><span class="s1">y_pred</span><span class="s3">.</span><span class="s1">shape </span><span class="s3">== (</span><span class="s1">n_samples</span><span class="s3">, </span><span class="s1">n_classes</span><span class="s3">), (</span>
        <span class="s4">&quot;The shape of the prediction for multioutput data is &quot;</span>
        <span class="s4">&quot;incorrect. Expected {}, got {}.&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">((</span><span class="s1">n_samples</span><span class="s3">, </span><span class="s1">n_labels</span><span class="s3">), </span><span class="s1">y_pred</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">)</span>
    <span class="s3">)</span>
    <span class="s2">assert </span><span class="s1">y_pred</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">kind </span><span class="s3">== </span><span class="s4">&quot;i&quot;</span>

    <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s4">&quot;decision_function&quot;</span><span class="s3">):</span>
        <span class="s1">decision </span><span class="s3">= </span><span class="s1">estimator</span><span class="s3">.</span><span class="s1">decision_function</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
        <span class="s2">assert </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">decision</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndarray</span><span class="s3">)</span>
        <span class="s2">assert </span><span class="s1">decision</span><span class="s3">.</span><span class="s1">shape </span><span class="s3">== (</span><span class="s1">n_samples</span><span class="s3">, </span><span class="s1">n_classes</span><span class="s3">), (</span>
            <span class="s4">&quot;The shape of the decision function output for &quot;</span>
            <span class="s4">&quot;multioutput data is incorrect. Expected {}, got {}.&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span>
                <span class="s3">(</span><span class="s1">n_samples</span><span class="s3">, </span><span class="s1">n_classes</span><span class="s3">), </span><span class="s1">decision</span><span class="s3">.</span><span class="s1">shape</span>
            <span class="s3">)</span>
        <span class="s3">)</span>

        <span class="s1">dec_pred </span><span class="s3">= (</span><span class="s1">decision </span><span class="s3">&gt; </span><span class="s6">0</span><span class="s3">).</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">int</span><span class="s3">)</span>
        <span class="s1">dec_exp </span><span class="s3">= </span><span class="s1">estimator</span><span class="s3">.</span><span class="s1">classes_</span><span class="s3">[</span><span class="s1">dec_pred</span><span class="s3">]</span>
        <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">dec_exp</span><span class="s3">, </span><span class="s1">y_pred</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s4">&quot;predict_proba&quot;</span><span class="s3">):</span>
        <span class="s1">y_prob </span><span class="s3">= </span><span class="s1">estimator</span><span class="s3">.</span><span class="s1">predict_proba</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">y_prob</span><span class="s3">, </span><span class="s1">list</span><span class="s3">) </span><span class="s2">and not </span><span class="s1">tags</span><span class="s3">[</span><span class="s4">&quot;poor_score&quot;</span><span class="s3">]:</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">n_classes</span><span class="s3">):</span>
                <span class="s2">assert </span><span class="s1">y_prob</span><span class="s3">[</span><span class="s1">i</span><span class="s3">].</span><span class="s1">shape </span><span class="s3">== (</span><span class="s1">n_samples</span><span class="s3">, </span><span class="s6">2</span><span class="s3">), (</span>
                    <span class="s4">&quot;The shape of the probability for multioutput data is&quot;</span>
                    <span class="s4">&quot; incorrect. Expected {}, got {}.&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span>
                        <span class="s3">(</span><span class="s1">n_samples</span><span class="s3">, </span><span class="s6">2</span><span class="s3">), </span><span class="s1">y_prob</span><span class="s3">[</span><span class="s1">i</span><span class="s3">].</span><span class="s1">shape</span>
                    <span class="s3">)</span>
                <span class="s3">)</span>
                <span class="s1">assert_array_equal</span><span class="s3">(</span>
                    <span class="s1">np</span><span class="s3">.</span><span class="s1">argmax</span><span class="s3">(</span><span class="s1">y_prob</span><span class="s3">[</span><span class="s1">i</span><span class="s3">], </span><span class="s1">axis</span><span class="s3">=</span><span class="s6">1</span><span class="s3">).</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">int</span><span class="s3">), </span><span class="s1">y_pred</span><span class="s3">[:, </span><span class="s1">i</span><span class="s3">]</span>
                <span class="s3">)</span>
        <span class="s2">elif not </span><span class="s1">tags</span><span class="s3">[</span><span class="s4">&quot;poor_score&quot;</span><span class="s3">]:</span>
            <span class="s2">assert </span><span class="s1">y_prob</span><span class="s3">.</span><span class="s1">shape </span><span class="s3">== (</span><span class="s1">n_samples</span><span class="s3">, </span><span class="s1">n_classes</span><span class="s3">), (</span>
                <span class="s4">&quot;The shape of the probability for multioutput data is&quot;</span>
                <span class="s4">&quot; incorrect. Expected {}, got {}.&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span>
                    <span class="s3">(</span><span class="s1">n_samples</span><span class="s3">, </span><span class="s1">n_classes</span><span class="s3">), </span><span class="s1">y_prob</span><span class="s3">.</span><span class="s1">shape</span>
                <span class="s3">)</span>
            <span class="s3">)</span>
            <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">y_prob</span><span class="s3">.</span><span class="s1">round</span><span class="s3">().</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">int</span><span class="s3">), </span><span class="s1">y_pred</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s4">&quot;decision_function&quot;</span><span class="s3">) </span><span class="s2">and </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s4">&quot;predict_proba&quot;</span><span class="s3">):</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">n_classes</span><span class="s3">):</span>
            <span class="s1">y_proba </span><span class="s3">= </span><span class="s1">estimator</span><span class="s3">.</span><span class="s1">predict_proba</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)[:, </span><span class="s1">i</span><span class="s3">]</span>
            <span class="s1">y_decision </span><span class="s3">= </span><span class="s1">estimator</span><span class="s3">.</span><span class="s1">decision_function</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
            <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">rankdata</span><span class="s3">(</span><span class="s1">y_proba</span><span class="s3">), </span><span class="s1">rankdata</span><span class="s3">(</span><span class="s1">y_decision</span><span class="s3">[:, </span><span class="s1">i</span><span class="s3">]))</span>


<span class="s3">@</span><span class="s1">ignore_warnings</span><span class="s3">(</span><span class="s1">category</span><span class="s3">=</span><span class="s1">FutureWarning</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">check_regressor_multioutput</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">estimator</span><span class="s3">):</span>
    <span class="s1">estimator </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">)</span>
    <span class="s1">n_samples </span><span class="s3">= </span><span class="s1">n_features </span><span class="s3">= </span><span class="s6">10</span>

    <span class="s2">if not </span><span class="s1">_is_pairwise_metric</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">):</span>
        <span class="s1">n_samples </span><span class="s3">= </span><span class="s1">n_samples </span><span class="s3">+ </span><span class="s6">1</span>

    <span class="s1">X</span><span class="s3">, </span><span class="s1">y </span><span class="s3">= </span><span class="s1">make_regression</span><span class="s3">(</span>
        <span class="s1">random_state</span><span class="s3">=</span><span class="s6">42</span><span class="s3">, </span><span class="s1">n_targets</span><span class="s3">=</span><span class="s6">5</span><span class="s3">, </span><span class="s1">n_samples</span><span class="s3">=</span><span class="s1">n_samples</span><span class="s3">, </span><span class="s1">n_features</span><span class="s3">=</span><span class="s1">n_features</span>
    <span class="s3">)</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">_enforce_estimator_tags_X</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">X</span><span class="s3">)</span>

    <span class="s1">estimator</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
    <span class="s1">y_pred </span><span class="s3">= </span><span class="s1">estimator</span><span class="s3">.</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>

    <span class="s2">assert </span><span class="s1">y_pred</span><span class="s3">.</span><span class="s1">dtype </span><span class="s3">== </span><span class="s1">np</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">(</span><span class="s4">&quot;float64&quot;</span><span class="s3">), (</span>
        <span class="s4">&quot;Multioutput predictions by a regressor are expected to be&quot;</span>
        <span class="s4">&quot; floating-point precision. Got {} instead&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">y_pred</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>
    <span class="s3">)</span>
    <span class="s2">assert </span><span class="s1">y_pred</span><span class="s3">.</span><span class="s1">shape </span><span class="s3">== </span><span class="s1">y</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, (</span>
        <span class="s4">&quot;The shape of the prediction for multioutput data is incorrect.&quot;</span>
        <span class="s4">&quot; Expected {}, got {}.&quot;</span>
    <span class="s3">)</span>


<span class="s3">@</span><span class="s1">ignore_warnings</span><span class="s3">(</span><span class="s1">category</span><span class="s3">=</span><span class="s1">FutureWarning</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">check_clustering</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">clusterer_orig</span><span class="s3">, </span><span class="s1">readonly_memmap</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s1">clusterer </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">clusterer_orig</span><span class="s3">)</span>
    <span class="s1">X</span><span class="s3">, </span><span class="s1">y </span><span class="s3">= </span><span class="s1">make_blobs</span><span class="s3">(</span><span class="s1">n_samples</span><span class="s3">=</span><span class="s6">50</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s6">1</span><span class="s3">)</span>
    <span class="s1">X</span><span class="s3">, </span><span class="s1">y </span><span class="s3">= </span><span class="s1">shuffle</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s6">7</span><span class="s3">)</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">StandardScaler</span><span class="s3">().</span><span class="s1">fit_transform</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
    <span class="s1">rng </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">RandomState</span><span class="s3">(</span><span class="s6">7</span><span class="s3">)</span>
    <span class="s1">X_noise </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">concatenate</span><span class="s3">([</span><span class="s1">X</span><span class="s3">, </span><span class="s1">rng</span><span class="s3">.</span><span class="s1">uniform</span><span class="s3">(</span><span class="s1">low</span><span class="s3">=-</span><span class="s6">3</span><span class="s3">, </span><span class="s1">high</span><span class="s3">=</span><span class="s6">3</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=(</span><span class="s6">5</span><span class="s3">, </span><span class="s6">2</span><span class="s3">))])</span>

    <span class="s2">if </span><span class="s1">readonly_memmap</span><span class="s3">:</span>
        <span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">X_noise </span><span class="s3">= </span><span class="s1">create_memmap_backed_data</span><span class="s3">([</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">X_noise</span><span class="s3">])</span>

    <span class="s1">n_samples</span><span class="s3">, </span><span class="s1">n_features </span><span class="s3">= </span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span>
    <span class="s5"># catch deprecation and neighbors warnings</span>
    <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">clusterer</span><span class="s3">, </span><span class="s4">&quot;n_clusters&quot;</span><span class="s3">):</span>
        <span class="s1">clusterer</span><span class="s3">.</span><span class="s1">set_params</span><span class="s3">(</span><span class="s1">n_clusters</span><span class="s3">=</span><span class="s6">3</span><span class="s3">)</span>
    <span class="s1">set_random_state</span><span class="s3">(</span><span class="s1">clusterer</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">name </span><span class="s3">== </span><span class="s4">&quot;AffinityPropagation&quot;</span><span class="s3">:</span>
        <span class="s1">clusterer</span><span class="s3">.</span><span class="s1">set_params</span><span class="s3">(</span><span class="s1">preference</span><span class="s3">=-</span><span class="s6">100</span><span class="s3">)</span>
        <span class="s1">clusterer</span><span class="s3">.</span><span class="s1">set_params</span><span class="s3">(</span><span class="s1">max_iter</span><span class="s3">=</span><span class="s6">100</span><span class="s3">)</span>

    <span class="s5"># fit</span>
    <span class="s1">clusterer</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
    <span class="s5"># with lists</span>
    <span class="s1">clusterer</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">.</span><span class="s1">tolist</span><span class="s3">())</span>

    <span class="s1">pred </span><span class="s3">= </span><span class="s1">clusterer</span><span class="s3">.</span><span class="s1">labels_</span>
    <span class="s2">assert </span><span class="s1">pred</span><span class="s3">.</span><span class="s1">shape </span><span class="s3">== (</span><span class="s1">n_samples</span><span class="s3">,)</span>
    <span class="s2">assert </span><span class="s1">adjusted_rand_score</span><span class="s3">(</span><span class="s1">pred</span><span class="s3">, </span><span class="s1">y</span><span class="s3">) &gt; </span><span class="s6">0.4</span>
    <span class="s2">if </span><span class="s1">_safe_tags</span><span class="s3">(</span><span class="s1">clusterer</span><span class="s3">, </span><span class="s1">key</span><span class="s3">=</span><span class="s4">&quot;non_deterministic&quot;</span><span class="s3">):</span>
        <span class="s2">return</span>
    <span class="s1">set_random_state</span><span class="s3">(</span><span class="s1">clusterer</span><span class="s3">)</span>
    <span class="s2">with </span><span class="s1">warnings</span><span class="s3">.</span><span class="s1">catch_warnings</span><span class="s3">(</span><span class="s1">record</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
        <span class="s1">pred2 </span><span class="s3">= </span><span class="s1">clusterer</span><span class="s3">.</span><span class="s1">fit_predict</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">pred</span><span class="s3">, </span><span class="s1">pred2</span><span class="s3">)</span>

    <span class="s5"># fit_predict(X) and labels_ should be of type int</span>
    <span class="s2">assert </span><span class="s1">pred</span><span class="s3">.</span><span class="s1">dtype </span><span class="s2">in </span><span class="s3">[</span><span class="s1">np</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">(</span><span class="s4">&quot;int32&quot;</span><span class="s3">), </span><span class="s1">np</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">(</span><span class="s4">&quot;int64&quot;</span><span class="s3">)]</span>
    <span class="s2">assert </span><span class="s1">pred2</span><span class="s3">.</span><span class="s1">dtype </span><span class="s2">in </span><span class="s3">[</span><span class="s1">np</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">(</span><span class="s4">&quot;int32&quot;</span><span class="s3">), </span><span class="s1">np</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">(</span><span class="s4">&quot;int64&quot;</span><span class="s3">)]</span>

    <span class="s5"># Add noise to X to test the possible values of the labels</span>
    <span class="s1">labels </span><span class="s3">= </span><span class="s1">clusterer</span><span class="s3">.</span><span class="s1">fit_predict</span><span class="s3">(</span><span class="s1">X_noise</span><span class="s3">)</span>

    <span class="s5"># There should be at least one sample in every cluster. Equivalently</span>
    <span class="s5"># labels_ should contain all the consecutive values between its</span>
    <span class="s5"># min and its max.</span>
    <span class="s1">labels_sorted </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">unique</span><span class="s3">(</span><span class="s1">labels</span><span class="s3">)</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span>
        <span class="s1">labels_sorted</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s1">labels_sorted</span><span class="s3">[</span><span class="s6">0</span><span class="s3">], </span><span class="s1">labels_sorted</span><span class="s3">[-</span><span class="s6">1</span><span class="s3">] + </span><span class="s6">1</span><span class="s3">)</span>
    <span class="s3">)</span>

    <span class="s5"># Labels are expected to start at 0 (no noise) or -1 (if noise)</span>
    <span class="s2">assert </span><span class="s1">labels_sorted</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] </span><span class="s2">in </span><span class="s3">[</span><span class="s6">0</span><span class="s3">, -</span><span class="s6">1</span><span class="s3">]</span>
    <span class="s5"># Labels should be less than n_clusters - 1</span>
    <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">clusterer</span><span class="s3">, </span><span class="s4">&quot;n_clusters&quot;</span><span class="s3">):</span>
        <span class="s1">n_clusters </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">clusterer</span><span class="s3">, </span><span class="s4">&quot;n_clusters&quot;</span><span class="s3">)</span>
        <span class="s2">assert </span><span class="s1">n_clusters </span><span class="s3">- </span><span class="s6">1 </span><span class="s3">&gt;= </span><span class="s1">labels_sorted</span><span class="s3">[-</span><span class="s6">1</span><span class="s3">]</span>
    <span class="s5"># else labels should be less than max(labels_) which is necessarily true</span>


<span class="s3">@</span><span class="s1">ignore_warnings</span><span class="s3">(</span><span class="s1">category</span><span class="s3">=</span><span class="s1">FutureWarning</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">check_clusterer_compute_labels_predict</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">clusterer_orig</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Check that predict is invariant of compute_labels.&quot;&quot;&quot;</span>
    <span class="s1">X</span><span class="s3">, </span><span class="s1">y </span><span class="s3">= </span><span class="s1">make_blobs</span><span class="s3">(</span><span class="s1">n_samples</span><span class="s3">=</span><span class="s6">20</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s6">0</span><span class="s3">)</span>
    <span class="s1">clusterer </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">clusterer_orig</span><span class="s3">)</span>
    <span class="s1">set_random_state</span><span class="s3">(</span><span class="s1">clusterer</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">clusterer</span><span class="s3">, </span><span class="s4">&quot;compute_labels&quot;</span><span class="s3">):</span>
        <span class="s5"># MiniBatchKMeans</span>
        <span class="s1">X_pred1 </span><span class="s3">= </span><span class="s1">clusterer</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">).</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
        <span class="s1">clusterer</span><span class="s3">.</span><span class="s1">set_params</span><span class="s3">(</span><span class="s1">compute_labels</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
        <span class="s1">X_pred2 </span><span class="s3">= </span><span class="s1">clusterer</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">).</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
        <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">X_pred1</span><span class="s3">, </span><span class="s1">X_pred2</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">ignore_warnings</span><span class="s3">(</span><span class="s1">category</span><span class="s3">=</span><span class="s1">FutureWarning</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">check_classifiers_one_label</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">classifier_orig</span><span class="s3">):</span>
    <span class="s1">error_string_fit </span><span class="s3">= </span><span class="s4">&quot;Classifier can't train when only one class is present.&quot;</span>
    <span class="s1">error_string_predict </span><span class="s3">= </span><span class="s4">&quot;Classifier can't predict when only one class is present.&quot;</span>
    <span class="s1">rnd </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">RandomState</span><span class="s3">(</span><span class="s6">0</span><span class="s3">)</span>
    <span class="s1">X_train </span><span class="s3">= </span><span class="s1">rnd</span><span class="s3">.</span><span class="s1">uniform</span><span class="s3">(</span><span class="s1">size</span><span class="s3">=(</span><span class="s6">10</span><span class="s3">, </span><span class="s6">3</span><span class="s3">))</span>
    <span class="s1">X_test </span><span class="s3">= </span><span class="s1">rnd</span><span class="s3">.</span><span class="s1">uniform</span><span class="s3">(</span><span class="s1">size</span><span class="s3">=(</span><span class="s6">10</span><span class="s3">, </span><span class="s6">3</span><span class="s3">))</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s6">10</span><span class="s3">)</span>
    <span class="s5"># catch deprecation warnings</span>
    <span class="s2">with </span><span class="s1">ignore_warnings</span><span class="s3">(</span><span class="s1">category</span><span class="s3">=</span><span class="s1">FutureWarning</span><span class="s3">):</span>
        <span class="s1">classifier </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">classifier_orig</span><span class="s3">)</span>
        <span class="s2">with </span><span class="s1">raises</span><span class="s3">(</span>
            <span class="s1">ValueError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s4">&quot;class&quot;</span><span class="s3">, </span><span class="s1">may_pass</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">err_msg</span><span class="s3">=</span><span class="s1">error_string_fit</span>
        <span class="s3">) </span><span class="s2">as </span><span class="s1">cm</span><span class="s3">:</span>
            <span class="s1">classifier</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X_train</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">cm</span><span class="s3">.</span><span class="s1">raised_and_matched</span><span class="s3">:</span>
            <span class="s5"># ValueError was raised with proper error message</span>
            <span class="s2">return</span>

        <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">classifier</span><span class="s3">.</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">X_test</span><span class="s3">), </span><span class="s1">y</span><span class="s3">, </span><span class="s1">err_msg</span><span class="s3">=</span><span class="s1">error_string_predict</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">ignore_warnings</span><span class="s3">(</span><span class="s1">category</span><span class="s3">=</span><span class="s1">FutureWarning</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">check_classifiers_one_label_sample_weights</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">classifier_orig</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Check that classifiers accepting sample_weight fit or throws a ValueError with 
    an explicit message if the problem is reduced to one class. 
    &quot;&quot;&quot;</span>
    <span class="s1">error_fit </span><span class="s3">= (</span>
        <span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">name</span><span class="s2">} </span><span class="s4">failed when fitted on one label after sample_weight trimming. Error &quot;</span>
        <span class="s4">&quot;message is not explicit, it should have 'class'.&quot;</span>
    <span class="s3">)</span>
    <span class="s1">error_predict </span><span class="s3">= </span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">name</span><span class="s2">} </span><span class="s4">prediction results should only output the remaining class.&quot;</span>
    <span class="s1">rnd </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">RandomState</span><span class="s3">(</span><span class="s6">0</span><span class="s3">)</span>
    <span class="s5"># X should be square for test on SVC with precomputed kernel</span>
    <span class="s1">X_train </span><span class="s3">= </span><span class="s1">rnd</span><span class="s3">.</span><span class="s1">uniform</span><span class="s3">(</span><span class="s1">size</span><span class="s3">=(</span><span class="s6">10</span><span class="s3">, </span><span class="s6">10</span><span class="s3">))</span>
    <span class="s1">X_test </span><span class="s3">= </span><span class="s1">rnd</span><span class="s3">.</span><span class="s1">uniform</span><span class="s3">(</span><span class="s1">size</span><span class="s3">=(</span><span class="s6">10</span><span class="s3">, </span><span class="s6">10</span><span class="s3">))</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s6">10</span><span class="s3">) % </span><span class="s6">2</span>
    <span class="s1">sample_weight </span><span class="s3">= </span><span class="s1">y</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()  </span><span class="s5"># select a single class</span>
    <span class="s1">classifier </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">classifier_orig</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">has_fit_parameter</span><span class="s3">(</span><span class="s1">classifier</span><span class="s3">, </span><span class="s4">&quot;sample_weight&quot;</span><span class="s3">):</span>
        <span class="s1">match </span><span class="s3">= [</span><span class="s4">r&quot;\bclass(es)?\b&quot;</span><span class="s3">, </span><span class="s1">error_predict</span><span class="s3">]</span>
        <span class="s1">err_type</span><span class="s3">, </span><span class="s1">err_msg </span><span class="s3">= (</span><span class="s1">AssertionError</span><span class="s3">, </span><span class="s1">ValueError</span><span class="s3">), </span><span class="s1">error_fit</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">match </span><span class="s3">= </span><span class="s4">r&quot;\bsample_weight\b&quot;</span>
        <span class="s1">err_type</span><span class="s3">, </span><span class="s1">err_msg </span><span class="s3">= (</span><span class="s1">TypeError</span><span class="s3">, </span><span class="s1">ValueError</span><span class="s3">), </span><span class="s2">None</span>

    <span class="s2">with </span><span class="s1">raises</span><span class="s3">(</span><span class="s1">err_type</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s1">match</span><span class="s3">, </span><span class="s1">may_pass</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">err_msg</span><span class="s3">=</span><span class="s1">err_msg</span><span class="s3">) </span><span class="s2">as </span><span class="s1">cm</span><span class="s3">:</span>
        <span class="s1">classifier</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X_train</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">sample_weight</span><span class="s3">=</span><span class="s1">sample_weight</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">cm</span><span class="s3">.</span><span class="s1">raised_and_matched</span><span class="s3">:</span>
            <span class="s5"># raise the proper error type with the proper error message</span>
            <span class="s2">return</span>
        <span class="s5"># for estimators that do not fail, they should be able to predict the only</span>
        <span class="s5"># class remaining during fit</span>
        <span class="s1">assert_array_equal</span><span class="s3">(</span>
            <span class="s1">classifier</span><span class="s3">.</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">X_test</span><span class="s3">), </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s6">10</span><span class="s3">), </span><span class="s1">err_msg</span><span class="s3">=</span><span class="s1">error_predict</span>
        <span class="s3">)</span>


<span class="s3">@</span><span class="s1">ignore_warnings  </span><span class="s5"># Warnings are raised by decision function</span>
<span class="s2">def </span><span class="s1">check_classifiers_train</span><span class="s3">(</span>
    <span class="s1">name</span><span class="s3">, </span><span class="s1">classifier_orig</span><span class="s3">, </span><span class="s1">readonly_memmap</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">X_dtype</span><span class="s3">=</span><span class="s4">&quot;float64&quot;</span>
<span class="s3">):</span>
    <span class="s1">X_m</span><span class="s3">, </span><span class="s1">y_m </span><span class="s3">= </span><span class="s1">make_blobs</span><span class="s3">(</span><span class="s1">n_samples</span><span class="s3">=</span><span class="s6">300</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s6">0</span><span class="s3">)</span>
    <span class="s1">X_m </span><span class="s3">= </span><span class="s1">X_m</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">X_dtype</span><span class="s3">)</span>
    <span class="s1">X_m</span><span class="s3">, </span><span class="s1">y_m </span><span class="s3">= </span><span class="s1">shuffle</span><span class="s3">(</span><span class="s1">X_m</span><span class="s3">, </span><span class="s1">y_m</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s6">7</span><span class="s3">)</span>
    <span class="s1">X_m </span><span class="s3">= </span><span class="s1">StandardScaler</span><span class="s3">().</span><span class="s1">fit_transform</span><span class="s3">(</span><span class="s1">X_m</span><span class="s3">)</span>
    <span class="s5"># generate binary problem from multi-class one</span>
    <span class="s1">y_b </span><span class="s3">= </span><span class="s1">y_m</span><span class="s3">[</span><span class="s1">y_m </span><span class="s3">!= </span><span class="s6">2</span><span class="s3">]</span>
    <span class="s1">X_b </span><span class="s3">= </span><span class="s1">X_m</span><span class="s3">[</span><span class="s1">y_m </span><span class="s3">!= </span><span class="s6">2</span><span class="s3">]</span>

    <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s3">[</span><span class="s4">&quot;BernoulliNB&quot;</span><span class="s3">, </span><span class="s4">&quot;MultinomialNB&quot;</span><span class="s3">, </span><span class="s4">&quot;ComplementNB&quot;</span><span class="s3">, </span><span class="s4">&quot;CategoricalNB&quot;</span><span class="s3">]:</span>
        <span class="s1">X_m </span><span class="s3">-= </span><span class="s1">X_m</span><span class="s3">.</span><span class="s1">min</span><span class="s3">()</span>
        <span class="s1">X_b </span><span class="s3">-= </span><span class="s1">X_b</span><span class="s3">.</span><span class="s1">min</span><span class="s3">()</span>

    <span class="s2">if </span><span class="s1">readonly_memmap</span><span class="s3">:</span>
        <span class="s1">X_m</span><span class="s3">, </span><span class="s1">y_m</span><span class="s3">, </span><span class="s1">X_b</span><span class="s3">, </span><span class="s1">y_b </span><span class="s3">= </span><span class="s1">create_memmap_backed_data</span><span class="s3">([</span><span class="s1">X_m</span><span class="s3">, </span><span class="s1">y_m</span><span class="s3">, </span><span class="s1">X_b</span><span class="s3">, </span><span class="s1">y_b</span><span class="s3">])</span>

    <span class="s1">problems </span><span class="s3">= [(</span><span class="s1">X_b</span><span class="s3">, </span><span class="s1">y_b</span><span class="s3">)]</span>
    <span class="s1">tags </span><span class="s3">= </span><span class="s1">_safe_tags</span><span class="s3">(</span><span class="s1">classifier_orig</span><span class="s3">)</span>
    <span class="s2">if not </span><span class="s1">tags</span><span class="s3">[</span><span class="s4">&quot;binary_only&quot;</span><span class="s3">]:</span>
        <span class="s1">problems</span><span class="s3">.</span><span class="s1">append</span><span class="s3">((</span><span class="s1">X_m</span><span class="s3">, </span><span class="s1">y_m</span><span class="s3">))</span>

    <span class="s2">for </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y </span><span class="s2">in </span><span class="s1">problems</span><span class="s3">:</span>
        <span class="s1">classes </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">unique</span><span class="s3">(</span><span class="s1">y</span><span class="s3">)</span>
        <span class="s1">n_classes </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">classes</span><span class="s3">)</span>
        <span class="s1">n_samples</span><span class="s3">, </span><span class="s1">n_features </span><span class="s3">= </span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span>
        <span class="s1">classifier </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">classifier_orig</span><span class="s3">)</span>
        <span class="s1">X </span><span class="s3">= </span><span class="s1">_enforce_estimator_tags_X</span><span class="s3">(</span><span class="s1">classifier</span><span class="s3">, </span><span class="s1">X</span><span class="s3">)</span>
        <span class="s1">y </span><span class="s3">= </span><span class="s1">_enforce_estimator_tags_y</span><span class="s3">(</span><span class="s1">classifier</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>

        <span class="s1">set_random_state</span><span class="s3">(</span><span class="s1">classifier</span><span class="s3">)</span>
        <span class="s5"># raises error on malformed input for fit</span>
        <span class="s2">if not </span><span class="s1">tags</span><span class="s3">[</span><span class="s4">&quot;no_validation&quot;</span><span class="s3">]:</span>
            <span class="s2">with </span><span class="s1">raises</span><span class="s3">(</span>
                <span class="s1">ValueError</span><span class="s3">,</span>
                <span class="s1">err_msg</span><span class="s3">=(</span>
                    <span class="s4">f&quot;The classifier </span><span class="s2">{</span><span class="s1">name</span><span class="s2">} </span><span class="s4">does not raise an error when &quot;</span>
                    <span class="s4">&quot;incorrect/malformed input data for fit is passed. The number &quot;</span>
                    <span class="s4">&quot;of training examples is not the same as the number of &quot;</span>
                    <span class="s4">&quot;labels. Perhaps use check_X_y in fit.&quot;</span>
                <span class="s3">),</span>
            <span class="s3">):</span>
                <span class="s1">classifier</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">[:-</span><span class="s6">1</span><span class="s3">])</span>

        <span class="s5"># fit</span>
        <span class="s1">classifier</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
        <span class="s5"># with lists</span>
        <span class="s1">classifier</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">.</span><span class="s1">tolist</span><span class="s3">(), </span><span class="s1">y</span><span class="s3">.</span><span class="s1">tolist</span><span class="s3">())</span>
        <span class="s2">assert </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">classifier</span><span class="s3">, </span><span class="s4">&quot;classes_&quot;</span><span class="s3">)</span>
        <span class="s1">y_pred </span><span class="s3">= </span><span class="s1">classifier</span><span class="s3">.</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>

        <span class="s2">assert </span><span class="s1">y_pred</span><span class="s3">.</span><span class="s1">shape </span><span class="s3">== (</span><span class="s1">n_samples</span><span class="s3">,)</span>
        <span class="s5"># training set performance</span>
        <span class="s2">if not </span><span class="s1">tags</span><span class="s3">[</span><span class="s4">&quot;poor_score&quot;</span><span class="s3">]:</span>
            <span class="s2">assert </span><span class="s1">accuracy_score</span><span class="s3">(</span><span class="s1">y</span><span class="s3">, </span><span class="s1">y_pred</span><span class="s3">) &gt; </span><span class="s6">0.83</span>

        <span class="s5"># raises error on malformed input for predict</span>
        <span class="s1">msg_pairwise </span><span class="s3">= (</span>
            <span class="s4">&quot;The classifier {} does not raise an error when shape of X in &quot;</span>
            <span class="s4">&quot; {} is not equal to (n_test_samples, n_training_samples)&quot;</span>
        <span class="s3">)</span>
        <span class="s1">msg </span><span class="s3">= (</span>
            <span class="s4">&quot;The classifier {} does not raise an error when the number of &quot;</span>
            <span class="s4">&quot;features in {} is different from the number of features in &quot;</span>
            <span class="s4">&quot;fit.&quot;</span>
        <span class="s3">)</span>

        <span class="s2">if not </span><span class="s1">tags</span><span class="s3">[</span><span class="s4">&quot;no_validation&quot;</span><span class="s3">]:</span>
            <span class="s2">if </span><span class="s1">tags</span><span class="s3">[</span><span class="s4">&quot;pairwise&quot;</span><span class="s3">]:</span>
                <span class="s2">with </span><span class="s1">raises</span><span class="s3">(</span>
                    <span class="s1">ValueError</span><span class="s3">,</span>
                    <span class="s1">err_msg</span><span class="s3">=</span><span class="s1">msg_pairwise</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s4">&quot;predict&quot;</span><span class="s3">),</span>
                <span class="s3">):</span>
                    <span class="s1">classifier</span><span class="s3">.</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">X</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">(-</span><span class="s6">1</span><span class="s3">, </span><span class="s6">1</span><span class="s3">))</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s2">with </span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">err_msg</span><span class="s3">=</span><span class="s1">msg</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s4">&quot;predict&quot;</span><span class="s3">)):</span>
                    <span class="s1">classifier</span><span class="s3">.</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">X</span><span class="s3">.</span><span class="s1">T</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">classifier</span><span class="s3">, </span><span class="s4">&quot;decision_function&quot;</span><span class="s3">):</span>
            <span class="s2">try</span><span class="s3">:</span>
                <span class="s5"># decision_function agrees with predict</span>
                <span class="s1">decision </span><span class="s3">= </span><span class="s1">classifier</span><span class="s3">.</span><span class="s1">decision_function</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
                <span class="s2">if </span><span class="s1">n_classes </span><span class="s3">== </span><span class="s6">2</span><span class="s3">:</span>
                    <span class="s2">if not </span><span class="s1">tags</span><span class="s3">[</span><span class="s4">&quot;multioutput_only&quot;</span><span class="s3">]:</span>
                        <span class="s2">assert </span><span class="s1">decision</span><span class="s3">.</span><span class="s1">shape </span><span class="s3">== (</span><span class="s1">n_samples</span><span class="s3">,)</span>
                    <span class="s2">else</span><span class="s3">:</span>
                        <span class="s2">assert </span><span class="s1">decision</span><span class="s3">.</span><span class="s1">shape </span><span class="s3">== (</span><span class="s1">n_samples</span><span class="s3">, </span><span class="s6">1</span><span class="s3">)</span>
                    <span class="s1">dec_pred </span><span class="s3">= (</span><span class="s1">decision</span><span class="s3">.</span><span class="s1">ravel</span><span class="s3">() &gt; </span><span class="s6">0</span><span class="s3">).</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">int</span><span class="s3">)</span>
                    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">dec_pred</span><span class="s3">, </span><span class="s1">y_pred</span><span class="s3">)</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s2">assert </span><span class="s1">decision</span><span class="s3">.</span><span class="s1">shape </span><span class="s3">== (</span><span class="s1">n_samples</span><span class="s3">, </span><span class="s1">n_classes</span><span class="s3">)</span>
                    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">argmax</span><span class="s3">(</span><span class="s1">decision</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s6">1</span><span class="s3">), </span><span class="s1">y_pred</span><span class="s3">)</span>

                <span class="s5"># raises error on malformed input for decision_function</span>
                <span class="s2">if not </span><span class="s1">tags</span><span class="s3">[</span><span class="s4">&quot;no_validation&quot;</span><span class="s3">]:</span>
                    <span class="s2">if </span><span class="s1">tags</span><span class="s3">[</span><span class="s4">&quot;pairwise&quot;</span><span class="s3">]:</span>
                        <span class="s2">with </span><span class="s1">raises</span><span class="s3">(</span>
                            <span class="s1">ValueError</span><span class="s3">,</span>
                            <span class="s1">err_msg</span><span class="s3">=</span><span class="s1">msg_pairwise</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s4">&quot;decision_function&quot;</span><span class="s3">),</span>
                        <span class="s3">):</span>
                            <span class="s1">classifier</span><span class="s3">.</span><span class="s1">decision_function</span><span class="s3">(</span><span class="s1">X</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">(-</span><span class="s6">1</span><span class="s3">, </span><span class="s6">1</span><span class="s3">))</span>
                    <span class="s2">else</span><span class="s3">:</span>
                        <span class="s2">with </span><span class="s1">raises</span><span class="s3">(</span>
                            <span class="s1">ValueError</span><span class="s3">,</span>
                            <span class="s1">err_msg</span><span class="s3">=</span><span class="s1">msg</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s4">&quot;decision_function&quot;</span><span class="s3">),</span>
                        <span class="s3">):</span>
                            <span class="s1">classifier</span><span class="s3">.</span><span class="s1">decision_function</span><span class="s3">(</span><span class="s1">X</span><span class="s3">.</span><span class="s1">T</span><span class="s3">)</span>
            <span class="s2">except </span><span class="s1">NotImplementedError</span><span class="s3">:</span>
                <span class="s2">pass</span>

        <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">classifier</span><span class="s3">, </span><span class="s4">&quot;predict_proba&quot;</span><span class="s3">):</span>
            <span class="s5"># predict_proba agrees with predict</span>
            <span class="s1">y_prob </span><span class="s3">= </span><span class="s1">classifier</span><span class="s3">.</span><span class="s1">predict_proba</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
            <span class="s2">assert </span><span class="s1">y_prob</span><span class="s3">.</span><span class="s1">shape </span><span class="s3">== (</span><span class="s1">n_samples</span><span class="s3">, </span><span class="s1">n_classes</span><span class="s3">)</span>
            <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">argmax</span><span class="s3">(</span><span class="s1">y_prob</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s6">1</span><span class="s3">), </span><span class="s1">y_pred</span><span class="s3">)</span>
            <span class="s5"># check that probas for all classes sum to one</span>
            <span class="s1">assert_array_almost_equal</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">(</span><span class="s1">y_prob</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s6">1</span><span class="s3">), </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">n_samples</span><span class="s3">))</span>
            <span class="s2">if not </span><span class="s1">tags</span><span class="s3">[</span><span class="s4">&quot;no_validation&quot;</span><span class="s3">]:</span>
                <span class="s5"># raises error on malformed input for predict_proba</span>
                <span class="s2">if </span><span class="s1">tags</span><span class="s3">[</span><span class="s4">&quot;pairwise&quot;</span><span class="s3">]:</span>
                    <span class="s2">with </span><span class="s1">raises</span><span class="s3">(</span>
                        <span class="s1">ValueError</span><span class="s3">,</span>
                        <span class="s1">err_msg</span><span class="s3">=</span><span class="s1">msg_pairwise</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s4">&quot;predict_proba&quot;</span><span class="s3">),</span>
                    <span class="s3">):</span>
                        <span class="s1">classifier</span><span class="s3">.</span><span class="s1">predict_proba</span><span class="s3">(</span><span class="s1">X</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">(-</span><span class="s6">1</span><span class="s3">, </span><span class="s6">1</span><span class="s3">))</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s2">with </span><span class="s1">raises</span><span class="s3">(</span>
                        <span class="s1">ValueError</span><span class="s3">,</span>
                        <span class="s1">err_msg</span><span class="s3">=</span><span class="s1">msg</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s4">&quot;predict_proba&quot;</span><span class="s3">),</span>
                    <span class="s3">):</span>
                        <span class="s1">classifier</span><span class="s3">.</span><span class="s1">predict_proba</span><span class="s3">(</span><span class="s1">X</span><span class="s3">.</span><span class="s1">T</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">classifier</span><span class="s3">, </span><span class="s4">&quot;predict_log_proba&quot;</span><span class="s3">):</span>
                <span class="s5"># predict_log_proba is a transformation of predict_proba</span>
                <span class="s1">y_log_prob </span><span class="s3">= </span><span class="s1">classifier</span><span class="s3">.</span><span class="s1">predict_log_proba</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
                <span class="s1">assert_allclose</span><span class="s3">(</span><span class="s1">y_log_prob</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">log</span><span class="s3">(</span><span class="s1">y_prob</span><span class="s3">), </span><span class="s6">8</span><span class="s3">, </span><span class="s1">atol</span><span class="s3">=</span><span class="s6">1e-9</span><span class="s3">)</span>
                <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">argsort</span><span class="s3">(</span><span class="s1">y_log_prob</span><span class="s3">), </span><span class="s1">np</span><span class="s3">.</span><span class="s1">argsort</span><span class="s3">(</span><span class="s1">y_prob</span><span class="s3">))</span>


<span class="s2">def </span><span class="s1">check_outlier_corruption</span><span class="s3">(</span><span class="s1">num_outliers</span><span class="s3">, </span><span class="s1">expected_outliers</span><span class="s3">, </span><span class="s1">decision</span><span class="s3">):</span>
    <span class="s5"># Check for deviation from the precise given contamination level that may</span>
    <span class="s5"># be due to ties in the anomaly scores.</span>
    <span class="s2">if </span><span class="s1">num_outliers </span><span class="s3">&lt; </span><span class="s1">expected_outliers</span><span class="s3">:</span>
        <span class="s1">start </span><span class="s3">= </span><span class="s1">num_outliers</span>
        <span class="s1">end </span><span class="s3">= </span><span class="s1">expected_outliers </span><span class="s3">+ </span><span class="s6">1</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">start </span><span class="s3">= </span><span class="s1">expected_outliers</span>
        <span class="s1">end </span><span class="s3">= </span><span class="s1">num_outliers </span><span class="s3">+ </span><span class="s6">1</span>

    <span class="s5"># ensure that all values in the 'critical area' are tied,</span>
    <span class="s5"># leading to the observed discrepancy between provided</span>
    <span class="s5"># and actual contamination levels.</span>
    <span class="s1">sorted_decision </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sort</span><span class="s3">(</span><span class="s1">decision</span><span class="s3">)</span>
    <span class="s1">msg </span><span class="s3">= (</span>
        <span class="s4">&quot;The number of predicted outliers is not equal to the expected &quot;</span>
        <span class="s4">&quot;number of outliers and this difference is not explained by the &quot;</span>
        <span class="s4">&quot;number of ties in the decision_function values&quot;</span>
    <span class="s3">)</span>
    <span class="s2">assert </span><span class="s1">len</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">unique</span><span class="s3">(</span><span class="s1">sorted_decision</span><span class="s3">[</span><span class="s1">start</span><span class="s3">:</span><span class="s1">end</span><span class="s3">])) == </span><span class="s6">1</span><span class="s3">, </span><span class="s1">msg</span>


<span class="s2">def </span><span class="s1">check_outliers_train</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">estimator_orig</span><span class="s3">, </span><span class="s1">readonly_memmap</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
    <span class="s1">n_samples </span><span class="s3">= </span><span class="s6">300</span>
    <span class="s1">X</span><span class="s3">, </span><span class="s1">_ </span><span class="s3">= </span><span class="s1">make_blobs</span><span class="s3">(</span><span class="s1">n_samples</span><span class="s3">=</span><span class="s1">n_samples</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s6">0</span><span class="s3">)</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">shuffle</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s6">7</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">readonly_memmap</span><span class="s3">:</span>
        <span class="s1">X </span><span class="s3">= </span><span class="s1">create_memmap_backed_data</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>

    <span class="s1">n_samples</span><span class="s3">, </span><span class="s1">n_features </span><span class="s3">= </span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span>
    <span class="s1">estimator </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">)</span>
    <span class="s1">set_random_state</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">)</span>

    <span class="s5"># fit</span>
    <span class="s1">estimator</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
    <span class="s5"># with lists</span>
    <span class="s1">estimator</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">.</span><span class="s1">tolist</span><span class="s3">())</span>

    <span class="s1">y_pred </span><span class="s3">= </span><span class="s1">estimator</span><span class="s3">.</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
    <span class="s2">assert </span><span class="s1">y_pred</span><span class="s3">.</span><span class="s1">shape </span><span class="s3">== (</span><span class="s1">n_samples</span><span class="s3">,)</span>
    <span class="s2">assert </span><span class="s1">y_pred</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">kind </span><span class="s3">== </span><span class="s4">&quot;i&quot;</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">unique</span><span class="s3">(</span><span class="s1">y_pred</span><span class="s3">), </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([-</span><span class="s6">1</span><span class="s3">, </span><span class="s6">1</span><span class="s3">]))</span>

    <span class="s1">decision </span><span class="s3">= </span><span class="s1">estimator</span><span class="s3">.</span><span class="s1">decision_function</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
    <span class="s1">scores </span><span class="s3">= </span><span class="s1">estimator</span><span class="s3">.</span><span class="s1">score_samples</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
    <span class="s2">for </span><span class="s1">output </span><span class="s2">in </span><span class="s3">[</span><span class="s1">decision</span><span class="s3">, </span><span class="s1">scores</span><span class="s3">]:</span>
        <span class="s2">assert </span><span class="s1">output</span><span class="s3">.</span><span class="s1">dtype </span><span class="s3">== </span><span class="s1">np</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">(</span><span class="s4">&quot;float&quot;</span><span class="s3">)</span>
        <span class="s2">assert </span><span class="s1">output</span><span class="s3">.</span><span class="s1">shape </span><span class="s3">== (</span><span class="s1">n_samples</span><span class="s3">,)</span>

    <span class="s5"># raises error on malformed input for predict</span>
    <span class="s2">with </span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">):</span>
        <span class="s1">estimator</span><span class="s3">.</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">X</span><span class="s3">.</span><span class="s1">T</span><span class="s3">)</span>

    <span class="s5"># decision_function agrees with predict</span>
    <span class="s1">dec_pred </span><span class="s3">= (</span><span class="s1">decision </span><span class="s3">&gt;= </span><span class="s6">0</span><span class="s3">).</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">int</span><span class="s3">)</span>
    <span class="s1">dec_pred</span><span class="s3">[</span><span class="s1">dec_pred </span><span class="s3">== </span><span class="s6">0</span><span class="s3">] = -</span><span class="s6">1</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">dec_pred</span><span class="s3">, </span><span class="s1">y_pred</span><span class="s3">)</span>

    <span class="s5"># raises error on malformed input for decision_function</span>
    <span class="s2">with </span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">):</span>
        <span class="s1">estimator</span><span class="s3">.</span><span class="s1">decision_function</span><span class="s3">(</span><span class="s1">X</span><span class="s3">.</span><span class="s1">T</span><span class="s3">)</span>

    <span class="s5"># decision_function is a translation of score_samples</span>
    <span class="s1">y_dec </span><span class="s3">= </span><span class="s1">scores </span><span class="s3">- </span><span class="s1">estimator</span><span class="s3">.</span><span class="s1">offset_</span>
    <span class="s1">assert_allclose</span><span class="s3">(</span><span class="s1">y_dec</span><span class="s3">, </span><span class="s1">decision</span><span class="s3">)</span>

    <span class="s5"># raises error on malformed input for score_samples</span>
    <span class="s2">with </span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">):</span>
        <span class="s1">estimator</span><span class="s3">.</span><span class="s1">score_samples</span><span class="s3">(</span><span class="s1">X</span><span class="s3">.</span><span class="s1">T</span><span class="s3">)</span>

    <span class="s5"># contamination parameter (not for OneClassSVM which has the nu parameter)</span>
    <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s4">&quot;contamination&quot;</span><span class="s3">) </span><span class="s2">and not </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s4">&quot;novelty&quot;</span><span class="s3">):</span>
        <span class="s5"># proportion of outliers equal to contamination parameter when not</span>
        <span class="s5"># set to 'auto'. This is true for the training set and cannot thus be</span>
        <span class="s5"># checked as follows for estimators with a novelty parameter such as</span>
        <span class="s5"># LocalOutlierFactor (tested in check_outliers_fit_predict)</span>
        <span class="s1">expected_outliers </span><span class="s3">= </span><span class="s6">30</span>
        <span class="s1">contamination </span><span class="s3">= </span><span class="s1">expected_outliers </span><span class="s3">/ </span><span class="s1">n_samples</span>
        <span class="s1">estimator</span><span class="s3">.</span><span class="s1">set_params</span><span class="s3">(</span><span class="s1">contamination</span><span class="s3">=</span><span class="s1">contamination</span><span class="s3">)</span>
        <span class="s1">estimator</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
        <span class="s1">y_pred </span><span class="s3">= </span><span class="s1">estimator</span><span class="s3">.</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>

        <span class="s1">num_outliers </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">(</span><span class="s1">y_pred </span><span class="s3">!= </span><span class="s6">1</span><span class="s3">)</span>
        <span class="s5"># num_outliers should be equal to expected_outliers unless</span>
        <span class="s5"># there are ties in the decision_function values. this can</span>
        <span class="s5"># only be tested for estimators with a decision_function</span>
        <span class="s5"># method, i.e. all estimators except LOF which is already</span>
        <span class="s5"># excluded from this if branch.</span>
        <span class="s2">if </span><span class="s1">num_outliers </span><span class="s3">!= </span><span class="s1">expected_outliers</span><span class="s3">:</span>
            <span class="s1">decision </span><span class="s3">= </span><span class="s1">estimator</span><span class="s3">.</span><span class="s1">decision_function</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
            <span class="s1">check_outlier_corruption</span><span class="s3">(</span><span class="s1">num_outliers</span><span class="s3">, </span><span class="s1">expected_outliers</span><span class="s3">, </span><span class="s1">decision</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">check_outlier_contamination</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">estimator_orig</span><span class="s3">):</span>
    <span class="s5"># Check that the contamination parameter is in (0.0, 0.5] when it is an</span>
    <span class="s5"># interval constraint.</span>

    <span class="s2">if not </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">, </span><span class="s4">&quot;_parameter_constraints&quot;</span><span class="s3">):</span>
        <span class="s5"># Only estimator implementing parameter constraints will be checked</span>
        <span class="s2">return</span>

    <span class="s2">if </span><span class="s4">&quot;contamination&quot; </span><span class="s2">not in </span><span class="s1">estimator_orig</span><span class="s3">.</span><span class="s1">_parameter_constraints</span><span class="s3">:</span>
        <span class="s2">return</span>

    <span class="s1">contamination_constraints </span><span class="s3">= </span><span class="s1">estimator_orig</span><span class="s3">.</span><span class="s1">_parameter_constraints</span><span class="s3">[</span><span class="s4">&quot;contamination&quot;</span><span class="s3">]</span>
    <span class="s2">if not </span><span class="s1">any</span><span class="s3">([</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">c</span><span class="s3">, </span><span class="s1">Interval</span><span class="s3">) </span><span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">contamination_constraints</span><span class="s3">]):</span>
        <span class="s2">raise </span><span class="s1">AssertionError</span><span class="s3">(</span>
            <span class="s4">&quot;contamination constraints should contain a Real Interval constraint.&quot;</span>
        <span class="s3">)</span>

    <span class="s2">for </span><span class="s1">constraint </span><span class="s2">in </span><span class="s1">contamination_constraints</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">constraint</span><span class="s3">, </span><span class="s1">Interval</span><span class="s3">):</span>
            <span class="s2">assert </span><span class="s3">(</span>
                <span class="s1">constraint</span><span class="s3">.</span><span class="s1">type </span><span class="s3">== </span><span class="s1">Real</span>
                <span class="s2">and </span><span class="s1">constraint</span><span class="s3">.</span><span class="s1">left </span><span class="s3">&gt;= </span><span class="s6">0.0</span>
                <span class="s2">and </span><span class="s1">constraint</span><span class="s3">.</span><span class="s1">right </span><span class="s3">&lt;= </span><span class="s6">0.5</span>
                <span class="s2">and </span><span class="s3">(</span><span class="s1">constraint</span><span class="s3">.</span><span class="s1">left </span><span class="s3">&gt; </span><span class="s6">0 </span><span class="s2">or </span><span class="s1">constraint</span><span class="s3">.</span><span class="s1">closed </span><span class="s2">in </span><span class="s3">{</span><span class="s4">&quot;right&quot;</span><span class="s3">, </span><span class="s4">&quot;neither&quot;</span><span class="s3">})</span>
            <span class="s3">), </span><span class="s4">&quot;contamination constraint should be an interval in (0, 0.5]&quot;</span>


<span class="s3">@</span><span class="s1">ignore_warnings</span><span class="s3">(</span><span class="s1">category</span><span class="s3">=</span><span class="s1">FutureWarning</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">check_classifiers_multilabel_representation_invariance</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">classifier_orig</span><span class="s3">):</span>
    <span class="s1">X</span><span class="s3">, </span><span class="s1">y </span><span class="s3">= </span><span class="s1">make_multilabel_classification</span><span class="s3">(</span>
        <span class="s1">n_samples</span><span class="s3">=</span><span class="s6">100</span><span class="s3">,</span>
        <span class="s1">n_features</span><span class="s3">=</span><span class="s6">2</span><span class="s3">,</span>
        <span class="s1">n_classes</span><span class="s3">=</span><span class="s6">5</span><span class="s3">,</span>
        <span class="s1">n_labels</span><span class="s3">=</span><span class="s6">3</span><span class="s3">,</span>
        <span class="s1">length</span><span class="s3">=</span><span class="s6">50</span><span class="s3">,</span>
        <span class="s1">allow_unlabeled</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
        <span class="s1">random_state</span><span class="s3">=</span><span class="s6">0</span><span class="s3">,</span>
    <span class="s3">)</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">scale</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>

    <span class="s1">X_train</span><span class="s3">, </span><span class="s1">y_train </span><span class="s3">= </span><span class="s1">X</span><span class="s3">[:</span><span class="s6">80</span><span class="s3">], </span><span class="s1">y</span><span class="s3">[:</span><span class="s6">80</span><span class="s3">]</span>
    <span class="s1">X_test </span><span class="s3">= </span><span class="s1">X</span><span class="s3">[</span><span class="s6">80</span><span class="s3">:]</span>

    <span class="s1">y_train_list_of_lists </span><span class="s3">= </span><span class="s1">y_train</span><span class="s3">.</span><span class="s1">tolist</span><span class="s3">()</span>
    <span class="s1">y_train_list_of_arrays </span><span class="s3">= </span><span class="s1">list</span><span class="s3">(</span><span class="s1">y_train</span><span class="s3">)</span>

    <span class="s1">classifier </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">classifier_orig</span><span class="s3">)</span>
    <span class="s1">set_random_state</span><span class="s3">(</span><span class="s1">classifier</span><span class="s3">)</span>

    <span class="s1">y_pred </span><span class="s3">= </span><span class="s1">classifier</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X_train</span><span class="s3">, </span><span class="s1">y_train</span><span class="s3">).</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">X_test</span><span class="s3">)</span>

    <span class="s1">y_pred_list_of_lists </span><span class="s3">= </span><span class="s1">classifier</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X_train</span><span class="s3">, </span><span class="s1">y_train_list_of_lists</span><span class="s3">).</span><span class="s1">predict</span><span class="s3">(</span>
        <span class="s1">X_test</span>
    <span class="s3">)</span>

    <span class="s1">y_pred_list_of_arrays </span><span class="s3">= </span><span class="s1">classifier</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X_train</span><span class="s3">, </span><span class="s1">y_train_list_of_arrays</span><span class="s3">).</span><span class="s1">predict</span><span class="s3">(</span>
        <span class="s1">X_test</span>
    <span class="s3">)</span>

    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">y_pred</span><span class="s3">, </span><span class="s1">y_pred_list_of_arrays</span><span class="s3">)</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">y_pred</span><span class="s3">, </span><span class="s1">y_pred_list_of_lists</span><span class="s3">)</span>

    <span class="s2">assert </span><span class="s1">y_pred</span><span class="s3">.</span><span class="s1">dtype </span><span class="s3">== </span><span class="s1">y_pred_list_of_arrays</span><span class="s3">.</span><span class="s1">dtype</span>
    <span class="s2">assert </span><span class="s1">y_pred</span><span class="s3">.</span><span class="s1">dtype </span><span class="s3">== </span><span class="s1">y_pred_list_of_lists</span><span class="s3">.</span><span class="s1">dtype</span>
    <span class="s2">assert </span><span class="s1">type</span><span class="s3">(</span><span class="s1">y_pred</span><span class="s3">) == </span><span class="s1">type</span><span class="s3">(</span><span class="s1">y_pred_list_of_arrays</span><span class="s3">)</span>
    <span class="s2">assert </span><span class="s1">type</span><span class="s3">(</span><span class="s1">y_pred</span><span class="s3">) == </span><span class="s1">type</span><span class="s3">(</span><span class="s1">y_pred_list_of_lists</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">ignore_warnings</span><span class="s3">(</span><span class="s1">category</span><span class="s3">=</span><span class="s1">FutureWarning</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">check_classifiers_multilabel_output_format_predict</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">classifier_orig</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Check the output of the `predict` method for classifiers supporting 
    multilabel-indicator targets.&quot;&quot;&quot;</span>
    <span class="s1">classifier </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">classifier_orig</span><span class="s3">)</span>
    <span class="s1">set_random_state</span><span class="s3">(</span><span class="s1">classifier</span><span class="s3">)</span>

    <span class="s1">n_samples</span><span class="s3">, </span><span class="s1">test_size</span><span class="s3">, </span><span class="s1">n_outputs </span><span class="s3">= </span><span class="s6">100</span><span class="s3">, </span><span class="s6">25</span><span class="s3">, </span><span class="s6">5</span>
    <span class="s1">X</span><span class="s3">, </span><span class="s1">y </span><span class="s3">= </span><span class="s1">make_multilabel_classification</span><span class="s3">(</span>
        <span class="s1">n_samples</span><span class="s3">=</span><span class="s1">n_samples</span><span class="s3">,</span>
        <span class="s1">n_features</span><span class="s3">=</span><span class="s6">2</span><span class="s3">,</span>
        <span class="s1">n_classes</span><span class="s3">=</span><span class="s1">n_outputs</span><span class="s3">,</span>
        <span class="s1">n_labels</span><span class="s3">=</span><span class="s6">3</span><span class="s3">,</span>
        <span class="s1">length</span><span class="s3">=</span><span class="s6">50</span><span class="s3">,</span>
        <span class="s1">allow_unlabeled</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
        <span class="s1">random_state</span><span class="s3">=</span><span class="s6">0</span><span class="s3">,</span>
    <span class="s3">)</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">scale</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>

    <span class="s1">X_train</span><span class="s3">, </span><span class="s1">X_test </span><span class="s3">= </span><span class="s1">X</span><span class="s3">[:-</span><span class="s1">test_size</span><span class="s3">], </span><span class="s1">X</span><span class="s3">[-</span><span class="s1">test_size</span><span class="s3">:]</span>
    <span class="s1">y_train</span><span class="s3">, </span><span class="s1">y_test </span><span class="s3">= </span><span class="s1">y</span><span class="s3">[:-</span><span class="s1">test_size</span><span class="s3">], </span><span class="s1">y</span><span class="s3">[-</span><span class="s1">test_size</span><span class="s3">:]</span>
    <span class="s1">classifier</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X_train</span><span class="s3">, </span><span class="s1">y_train</span><span class="s3">)</span>

    <span class="s1">response_method_name </span><span class="s3">= </span><span class="s4">&quot;predict&quot;</span>
    <span class="s1">predict_method </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">classifier</span><span class="s3">, </span><span class="s1">response_method_name</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">predict_method </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">SkipTest</span><span class="s3">(</span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">name</span><span class="s2">} </span><span class="s4">does not have a </span><span class="s2">{</span><span class="s1">response_method_name</span><span class="s2">} </span><span class="s4">method.&quot;</span><span class="s3">)</span>

    <span class="s1">y_pred </span><span class="s3">= </span><span class="s1">predict_method</span><span class="s3">(</span><span class="s1">X_test</span><span class="s3">)</span>

    <span class="s5"># y_pred.shape -&gt; y_test.shape with the same dtype</span>
    <span class="s2">assert </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">y_pred</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndarray</span><span class="s3">), (</span>
        <span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s4">.predict is expected to output a NumPy array. Got &quot;</span>
        <span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">type</span><span class="s3">(</span><span class="s1">y_pred</span><span class="s3">)</span><span class="s2">} </span><span class="s4">instead.&quot;</span>
    <span class="s3">)</span>
    <span class="s2">assert </span><span class="s1">y_pred</span><span class="s3">.</span><span class="s1">shape </span><span class="s3">== </span><span class="s1">y_test</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, (</span>
        <span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s4">.predict outputs a NumPy array of shape </span><span class="s2">{</span><span class="s1">y_pred</span><span class="s3">.</span><span class="s1">shape</span><span class="s2">} </span><span class="s4">&quot;</span>
        <span class="s4">f&quot;instead of </span><span class="s2">{</span><span class="s1">y_test</span><span class="s3">.</span><span class="s1">shape</span><span class="s2">}</span><span class="s4">.&quot;</span>
    <span class="s3">)</span>
    <span class="s2">assert </span><span class="s1">y_pred</span><span class="s3">.</span><span class="s1">dtype </span><span class="s3">== </span><span class="s1">y_test</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, (</span>
        <span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s4">.predict does not output the same dtype than the targets. &quot;</span>
        <span class="s4">f&quot;Got </span><span class="s2">{</span><span class="s1">y_pred</span><span class="s3">.</span><span class="s1">dtype</span><span class="s2">} </span><span class="s4">instead of </span><span class="s2">{</span><span class="s1">y_test</span><span class="s3">.</span><span class="s1">dtype</span><span class="s2">}</span><span class="s4">.&quot;</span>
    <span class="s3">)</span>


<span class="s3">@</span><span class="s1">ignore_warnings</span><span class="s3">(</span><span class="s1">category</span><span class="s3">=</span><span class="s1">FutureWarning</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">check_classifiers_multilabel_output_format_predict_proba</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">classifier_orig</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Check the output of the `predict_proba` method for classifiers supporting 
    multilabel-indicator targets.&quot;&quot;&quot;</span>
    <span class="s1">classifier </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">classifier_orig</span><span class="s3">)</span>
    <span class="s1">set_random_state</span><span class="s3">(</span><span class="s1">classifier</span><span class="s3">)</span>

    <span class="s1">n_samples</span><span class="s3">, </span><span class="s1">test_size</span><span class="s3">, </span><span class="s1">n_outputs </span><span class="s3">= </span><span class="s6">100</span><span class="s3">, </span><span class="s6">25</span><span class="s3">, </span><span class="s6">5</span>
    <span class="s1">X</span><span class="s3">, </span><span class="s1">y </span><span class="s3">= </span><span class="s1">make_multilabel_classification</span><span class="s3">(</span>
        <span class="s1">n_samples</span><span class="s3">=</span><span class="s1">n_samples</span><span class="s3">,</span>
        <span class="s1">n_features</span><span class="s3">=</span><span class="s6">2</span><span class="s3">,</span>
        <span class="s1">n_classes</span><span class="s3">=</span><span class="s1">n_outputs</span><span class="s3">,</span>
        <span class="s1">n_labels</span><span class="s3">=</span><span class="s6">3</span><span class="s3">,</span>
        <span class="s1">length</span><span class="s3">=</span><span class="s6">50</span><span class="s3">,</span>
        <span class="s1">allow_unlabeled</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
        <span class="s1">random_state</span><span class="s3">=</span><span class="s6">0</span><span class="s3">,</span>
    <span class="s3">)</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">scale</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>

    <span class="s1">X_train</span><span class="s3">, </span><span class="s1">X_test </span><span class="s3">= </span><span class="s1">X</span><span class="s3">[:-</span><span class="s1">test_size</span><span class="s3">], </span><span class="s1">X</span><span class="s3">[-</span><span class="s1">test_size</span><span class="s3">:]</span>
    <span class="s1">y_train </span><span class="s3">= </span><span class="s1">y</span><span class="s3">[:-</span><span class="s1">test_size</span><span class="s3">]</span>
    <span class="s1">classifier</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X_train</span><span class="s3">, </span><span class="s1">y_train</span><span class="s3">)</span>

    <span class="s1">response_method_name </span><span class="s3">= </span><span class="s4">&quot;predict_proba&quot;</span>
    <span class="s1">predict_proba_method </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">classifier</span><span class="s3">, </span><span class="s1">response_method_name</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">predict_proba_method </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">SkipTest</span><span class="s3">(</span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">name</span><span class="s2">} </span><span class="s4">does not have a </span><span class="s2">{</span><span class="s1">response_method_name</span><span class="s2">} </span><span class="s4">method.&quot;</span><span class="s3">)</span>

    <span class="s1">y_pred </span><span class="s3">= </span><span class="s1">predict_proba_method</span><span class="s3">(</span><span class="s1">X_test</span><span class="s3">)</span>

    <span class="s5"># y_pred.shape -&gt; 2 possibilities:</span>
    <span class="s5"># - list of length n_outputs of shape (n_samples, 2);</span>
    <span class="s5"># - ndarray of shape (n_samples, n_outputs).</span>
    <span class="s5"># dtype should be floating</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">y_pred</span><span class="s3">, </span><span class="s1">list</span><span class="s3">):</span>
        <span class="s2">assert </span><span class="s1">len</span><span class="s3">(</span><span class="s1">y_pred</span><span class="s3">) == </span><span class="s1">n_outputs</span><span class="s3">, (</span>
            <span class="s4">f&quot;When </span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s4">.predict_proba returns a list, the list should &quot;</span>
            <span class="s4">&quot;be of length n_outputs and contain NumPy arrays. Got length &quot;</span>
            <span class="s4">f&quot;of </span><span class="s2">{</span><span class="s1">len</span><span class="s3">(</span><span class="s1">y_pred</span><span class="s3">)</span><span class="s2">} </span><span class="s4">instead of </span><span class="s2">{</span><span class="s1">n_outputs</span><span class="s2">}</span><span class="s4">.&quot;</span>
        <span class="s3">)</span>
        <span class="s2">for </span><span class="s1">pred </span><span class="s2">in </span><span class="s1">y_pred</span><span class="s3">:</span>
            <span class="s2">assert </span><span class="s1">pred</span><span class="s3">.</span><span class="s1">shape </span><span class="s3">== (</span><span class="s1">test_size</span><span class="s3">, </span><span class="s6">2</span><span class="s3">), (</span>
                <span class="s4">f&quot;When </span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s4">.predict_proba returns a list, this list &quot;</span>
                <span class="s4">&quot;should contain NumPy arrays of shape (n_samples, 2). Got &quot;</span>
                <span class="s4">f&quot;NumPy arrays of shape </span><span class="s2">{</span><span class="s1">pred</span><span class="s3">.</span><span class="s1">shape</span><span class="s2">} </span><span class="s4">instead of &quot;</span>
                <span class="s4">f&quot;</span><span class="s2">{</span><span class="s3">(</span><span class="s1">test_size</span><span class="s3">, </span><span class="s6">2</span><span class="s3">)</span><span class="s2">}</span><span class="s4">.&quot;</span>
            <span class="s3">)</span>
            <span class="s2">assert </span><span class="s1">pred</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">kind </span><span class="s3">== </span><span class="s4">&quot;f&quot;</span><span class="s3">, (</span>
                <span class="s4">f&quot;When </span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s4">.predict_proba returns a list, it should &quot;</span>
                <span class="s4">&quot;contain NumPy arrays with floating dtype. Got &quot;</span>
                <span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">pred</span><span class="s3">.</span><span class="s1">dtype</span><span class="s2">} </span><span class="s4">instead.&quot;</span>
            <span class="s3">)</span>
            <span class="s5"># check that we have the correct probabilities</span>
            <span class="s1">err_msg </span><span class="s3">= (</span>
                <span class="s4">f&quot;When </span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s4">.predict_proba returns a list, each NumPy &quot;</span>
                <span class="s4">&quot;array should contain probabilities for each class and &quot;</span>
                <span class="s4">&quot;thus each row should sum to 1 (or close to 1 due to &quot;</span>
                <span class="s4">&quot;numerical errors).&quot;</span>
            <span class="s3">)</span>
            <span class="s1">assert_allclose</span><span class="s3">(</span><span class="s1">pred</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">=</span><span class="s6">1</span><span class="s3">), </span><span class="s6">1</span><span class="s3">, </span><span class="s1">err_msg</span><span class="s3">=</span><span class="s1">err_msg</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">y_pred</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndarray</span><span class="s3">):</span>
        <span class="s2">assert </span><span class="s1">y_pred</span><span class="s3">.</span><span class="s1">shape </span><span class="s3">== (</span><span class="s1">test_size</span><span class="s3">, </span><span class="s1">n_outputs</span><span class="s3">), (</span>
            <span class="s4">f&quot;When </span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s4">.predict_proba returns a NumPy array, the &quot;</span>
            <span class="s4">f&quot;expected shape is (n_samples, n_outputs). Got </span><span class="s2">{</span><span class="s1">y_pred</span><span class="s3">.</span><span class="s1">shape</span><span class="s2">}</span><span class="s4">&quot;</span>
            <span class="s4">f&quot; instead of </span><span class="s2">{</span><span class="s3">(</span><span class="s1">test_size</span><span class="s3">, </span><span class="s1">n_outputs</span><span class="s3">)</span><span class="s2">}</span><span class="s4">.&quot;</span>
        <span class="s3">)</span>
        <span class="s2">assert </span><span class="s1">y_pred</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">kind </span><span class="s3">== </span><span class="s4">&quot;f&quot;</span><span class="s3">, (</span>
            <span class="s4">f&quot;When </span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s4">.predict_proba returns a NumPy array, the &quot;</span>
            <span class="s4">f&quot;expected data type is floating. Got </span><span class="s2">{</span><span class="s1">y_pred</span><span class="s3">.</span><span class="s1">dtype</span><span class="s2">} </span><span class="s4">instead.&quot;</span>
        <span class="s3">)</span>
        <span class="s1">err_msg </span><span class="s3">= (</span>
            <span class="s4">f&quot;When </span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s4">.predict_proba returns a NumPy array, this array &quot;</span>
            <span class="s4">&quot;is expected to provide probabilities of the positive class &quot;</span>
            <span class="s4">&quot;and should therefore contain values between 0 and 1.&quot;</span>
        <span class="s3">)</span>
        <span class="s1">assert_array_less</span><span class="s3">(</span><span class="s6">0</span><span class="s3">, </span><span class="s1">y_pred</span><span class="s3">, </span><span class="s1">err_msg</span><span class="s3">=</span><span class="s1">err_msg</span><span class="s3">)</span>
        <span class="s1">assert_array_less</span><span class="s3">(</span><span class="s1">y_pred</span><span class="s3">, </span><span class="s6">1</span><span class="s3">, </span><span class="s1">err_msg</span><span class="s3">=</span><span class="s1">err_msg</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span>
            <span class="s4">f&quot;Unknown returned type </span><span class="s2">{</span><span class="s1">type</span><span class="s3">(</span><span class="s1">y_pred</span><span class="s3">)</span><span class="s2">} </span><span class="s4">by </span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s4">.&quot;</span>
            <span class="s4">&quot;predict_proba. A list or a Numpy array is expected.&quot;</span>
        <span class="s3">)</span>


<span class="s3">@</span><span class="s1">ignore_warnings</span><span class="s3">(</span><span class="s1">category</span><span class="s3">=</span><span class="s1">FutureWarning</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">check_classifiers_multilabel_output_format_decision_function</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">classifier_orig</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Check the output of the `decision_function` method for classifiers supporting 
    multilabel-indicator targets.&quot;&quot;&quot;</span>
    <span class="s1">classifier </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">classifier_orig</span><span class="s3">)</span>
    <span class="s1">set_random_state</span><span class="s3">(</span><span class="s1">classifier</span><span class="s3">)</span>

    <span class="s1">n_samples</span><span class="s3">, </span><span class="s1">test_size</span><span class="s3">, </span><span class="s1">n_outputs </span><span class="s3">= </span><span class="s6">100</span><span class="s3">, </span><span class="s6">25</span><span class="s3">, </span><span class="s6">5</span>
    <span class="s1">X</span><span class="s3">, </span><span class="s1">y </span><span class="s3">= </span><span class="s1">make_multilabel_classification</span><span class="s3">(</span>
        <span class="s1">n_samples</span><span class="s3">=</span><span class="s1">n_samples</span><span class="s3">,</span>
        <span class="s1">n_features</span><span class="s3">=</span><span class="s6">2</span><span class="s3">,</span>
        <span class="s1">n_classes</span><span class="s3">=</span><span class="s1">n_outputs</span><span class="s3">,</span>
        <span class="s1">n_labels</span><span class="s3">=</span><span class="s6">3</span><span class="s3">,</span>
        <span class="s1">length</span><span class="s3">=</span><span class="s6">50</span><span class="s3">,</span>
        <span class="s1">allow_unlabeled</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
        <span class="s1">random_state</span><span class="s3">=</span><span class="s6">0</span><span class="s3">,</span>
    <span class="s3">)</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">scale</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>

    <span class="s1">X_train</span><span class="s3">, </span><span class="s1">X_test </span><span class="s3">= </span><span class="s1">X</span><span class="s3">[:-</span><span class="s1">test_size</span><span class="s3">], </span><span class="s1">X</span><span class="s3">[-</span><span class="s1">test_size</span><span class="s3">:]</span>
    <span class="s1">y_train </span><span class="s3">= </span><span class="s1">y</span><span class="s3">[:-</span><span class="s1">test_size</span><span class="s3">]</span>
    <span class="s1">classifier</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X_train</span><span class="s3">, </span><span class="s1">y_train</span><span class="s3">)</span>

    <span class="s1">response_method_name </span><span class="s3">= </span><span class="s4">&quot;decision_function&quot;</span>
    <span class="s1">decision_function_method </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">classifier</span><span class="s3">, </span><span class="s1">response_method_name</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">decision_function_method </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">SkipTest</span><span class="s3">(</span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">name</span><span class="s2">} </span><span class="s4">does not have a </span><span class="s2">{</span><span class="s1">response_method_name</span><span class="s2">} </span><span class="s4">method.&quot;</span><span class="s3">)</span>

    <span class="s1">y_pred </span><span class="s3">= </span><span class="s1">decision_function_method</span><span class="s3">(</span><span class="s1">X_test</span><span class="s3">)</span>

    <span class="s5"># y_pred.shape -&gt; y_test.shape with floating dtype</span>
    <span class="s2">assert </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">y_pred</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndarray</span><span class="s3">), (</span>
        <span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s4">.decision_function is expected to output a NumPy array.&quot;</span>
        <span class="s4">f&quot; Got </span><span class="s2">{</span><span class="s1">type</span><span class="s3">(</span><span class="s1">y_pred</span><span class="s3">)</span><span class="s2">} </span><span class="s4">instead.&quot;</span>
    <span class="s3">)</span>
    <span class="s2">assert </span><span class="s1">y_pred</span><span class="s3">.</span><span class="s1">shape </span><span class="s3">== (</span><span class="s1">test_size</span><span class="s3">, </span><span class="s1">n_outputs</span><span class="s3">), (</span>
        <span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s4">.decision_function is expected to provide a NumPy array &quot;</span>
        <span class="s4">f&quot;of shape (n_samples, n_outputs). Got </span><span class="s2">{</span><span class="s1">y_pred</span><span class="s3">.</span><span class="s1">shape</span><span class="s2">} </span><span class="s4">instead of &quot;</span>
        <span class="s4">f&quot;</span><span class="s2">{</span><span class="s3">(</span><span class="s1">test_size</span><span class="s3">, </span><span class="s1">n_outputs</span><span class="s3">)</span><span class="s2">}</span><span class="s4">.&quot;</span>
    <span class="s3">)</span>
    <span class="s2">assert </span><span class="s1">y_pred</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">kind </span><span class="s3">== </span><span class="s4">&quot;f&quot;</span><span class="s3">, (</span>
        <span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s4">.decision_function is expected to output a floating dtype.&quot;</span>
        <span class="s4">f&quot; Got </span><span class="s2">{</span><span class="s1">y_pred</span><span class="s3">.</span><span class="s1">dtype</span><span class="s2">} </span><span class="s4">instead.&quot;</span>
    <span class="s3">)</span>


<span class="s3">@</span><span class="s1">ignore_warnings</span><span class="s3">(</span><span class="s1">category</span><span class="s3">=</span><span class="s1">FutureWarning</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">check_get_feature_names_out_error</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">estimator_orig</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Check the error raised by get_feature_names_out when called before fit. 
 
    Unfitted estimators with get_feature_names_out should raise a NotFittedError. 
    &quot;&quot;&quot;</span>

    <span class="s1">estimator </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">)</span>
    <span class="s1">err_msg </span><span class="s3">= (</span>
        <span class="s4">f&quot;Estimator </span><span class="s2">{</span><span class="s1">name</span><span class="s2">} </span><span class="s4">should have raised a NotFitted error when fit is called&quot;</span>
        <span class="s4">&quot; before get_feature_names_out&quot;</span>
    <span class="s3">)</span>
    <span class="s2">with </span><span class="s1">raises</span><span class="s3">(</span><span class="s1">NotFittedError</span><span class="s3">, </span><span class="s1">err_msg</span><span class="s3">=</span><span class="s1">err_msg</span><span class="s3">):</span>
        <span class="s1">estimator</span><span class="s3">.</span><span class="s1">get_feature_names_out</span><span class="s3">()</span>


<span class="s3">@</span><span class="s1">ignore_warnings</span><span class="s3">(</span><span class="s1">category</span><span class="s3">=</span><span class="s1">FutureWarning</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">check_estimators_fit_returns_self</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">estimator_orig</span><span class="s3">, </span><span class="s1">readonly_memmap</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Check if self is returned when calling fit.&quot;&quot;&quot;</span>
    <span class="s1">X</span><span class="s3">, </span><span class="s1">y </span><span class="s3">= </span><span class="s1">make_blobs</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">=</span><span class="s6">0</span><span class="s3">, </span><span class="s1">n_samples</span><span class="s3">=</span><span class="s6">21</span><span class="s3">)</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">_enforce_estimator_tags_X</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">, </span><span class="s1">X</span><span class="s3">)</span>

    <span class="s1">estimator </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">)</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">_enforce_estimator_tags_y</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">readonly_memmap</span><span class="s3">:</span>
        <span class="s1">X</span><span class="s3">, </span><span class="s1">y </span><span class="s3">= </span><span class="s1">create_memmap_backed_data</span><span class="s3">([</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">])</span>

    <span class="s1">set_random_state</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">)</span>
    <span class="s2">assert </span><span class="s1">estimator</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">) </span><span class="s2">is </span><span class="s1">estimator</span>


<span class="s3">@</span><span class="s1">ignore_warnings</span>
<span class="s2">def </span><span class="s1">check_estimators_unfitted</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">estimator_orig</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Check that predict raises an exception in an unfitted estimator. 
 
    Unfitted estimators should raise a NotFittedError. 
    &quot;&quot;&quot;</span>
    <span class="s5"># Common test for Regressors, Classifiers and Outlier detection estimators</span>
    <span class="s1">X</span><span class="s3">, </span><span class="s1">y </span><span class="s3">= </span><span class="s1">_regression_dataset</span><span class="s3">()</span>

    <span class="s1">estimator </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">)</span>
    <span class="s2">for </span><span class="s1">method </span><span class="s2">in </span><span class="s3">(</span>
        <span class="s4">&quot;decision_function&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;predict&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;predict_proba&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;predict_log_proba&quot;</span><span class="s3">,</span>
    <span class="s3">):</span>
        <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">method</span><span class="s3">):</span>
            <span class="s2">with </span><span class="s1">raises</span><span class="s3">(</span><span class="s1">NotFittedError</span><span class="s3">):</span>
                <span class="s1">getattr</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">method</span><span class="s3">)(</span><span class="s1">X</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">ignore_warnings</span><span class="s3">(</span><span class="s1">category</span><span class="s3">=</span><span class="s1">FutureWarning</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">check_supervised_y_2d</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">estimator_orig</span><span class="s3">):</span>
    <span class="s1">tags </span><span class="s3">= </span><span class="s1">_safe_tags</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">)</span>
    <span class="s1">rnd </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">RandomState</span><span class="s3">(</span><span class="s6">0</span><span class="s3">)</span>
    <span class="s1">n_samples </span><span class="s3">= </span><span class="s6">30</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">_enforce_estimator_tags_X</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">, </span><span class="s1">rnd</span><span class="s3">.</span><span class="s1">uniform</span><span class="s3">(</span><span class="s1">size</span><span class="s3">=(</span><span class="s1">n_samples</span><span class="s3">, </span><span class="s6">3</span><span class="s3">)))</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s1">n_samples</span><span class="s3">) % </span><span class="s6">3</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">_enforce_estimator_tags_y</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
    <span class="s1">estimator </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">)</span>
    <span class="s1">set_random_state</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">)</span>
    <span class="s5"># fit</span>
    <span class="s1">estimator</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
    <span class="s1">y_pred </span><span class="s3">= </span><span class="s1">estimator</span><span class="s3">.</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>

    <span class="s1">set_random_state</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">)</span>
    <span class="s5"># Check that when a 2D y is given, a DataConversionWarning is</span>
    <span class="s5"># raised</span>
    <span class="s2">with </span><span class="s1">warnings</span><span class="s3">.</span><span class="s1">catch_warnings</span><span class="s3">(</span><span class="s1">record</span><span class="s3">=</span><span class="s2">True</span><span class="s3">) </span><span class="s2">as </span><span class="s1">w</span><span class="s3">:</span>
        <span class="s1">warnings</span><span class="s3">.</span><span class="s1">simplefilter</span><span class="s3">(</span><span class="s4">&quot;always&quot;</span><span class="s3">, </span><span class="s1">DataConversionWarning</span><span class="s3">)</span>
        <span class="s1">warnings</span><span class="s3">.</span><span class="s1">simplefilter</span><span class="s3">(</span><span class="s4">&quot;ignore&quot;</span><span class="s3">, </span><span class="s1">RuntimeWarning</span><span class="s3">)</span>
        <span class="s1">estimator</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">[:, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">newaxis</span><span class="s3">])</span>
    <span class="s1">y_pred_2d </span><span class="s3">= </span><span class="s1">estimator</span><span class="s3">.</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
    <span class="s1">msg </span><span class="s3">= </span><span class="s4">&quot;expected 1 DataConversionWarning, got: %s&quot; </span><span class="s3">% </span><span class="s4">&quot;, &quot;</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span>
        <span class="s3">[</span><span class="s1">str</span><span class="s3">(</span><span class="s1">w_x</span><span class="s3">) </span><span class="s2">for </span><span class="s1">w_x </span><span class="s2">in </span><span class="s1">w</span><span class="s3">]</span>
    <span class="s3">)</span>
    <span class="s2">if not </span><span class="s1">tags</span><span class="s3">[</span><span class="s4">&quot;multioutput&quot;</span><span class="s3">]:</span>
        <span class="s5"># check that we warned if we don't support multi-output</span>
        <span class="s2">assert </span><span class="s1">len</span><span class="s3">(</span><span class="s1">w</span><span class="s3">) &gt; </span><span class="s6">0</span><span class="s3">, </span><span class="s1">msg</span>
        <span class="s2">assert </span><span class="s3">(</span>
            <span class="s4">&quot;DataConversionWarning('A column-vector y&quot;</span>
            <span class="s4">&quot; was passed when a 1d array was expected&quot; </span><span class="s2">in </span><span class="s1">msg</span>
        <span class="s3">)</span>
    <span class="s1">assert_allclose</span><span class="s3">(</span><span class="s1">y_pred</span><span class="s3">.</span><span class="s1">ravel</span><span class="s3">(), </span><span class="s1">y_pred_2d</span><span class="s3">.</span><span class="s1">ravel</span><span class="s3">())</span>


<span class="s3">@</span><span class="s1">ignore_warnings</span>
<span class="s2">def </span><span class="s1">check_classifiers_predictions</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">classifier_orig</span><span class="s3">):</span>
    <span class="s1">classes </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">unique</span><span class="s3">(</span><span class="s1">y</span><span class="s3">)</span>
    <span class="s1">classifier </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">classifier_orig</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">name </span><span class="s3">== </span><span class="s4">&quot;BernoulliNB&quot;</span><span class="s3">:</span>
        <span class="s1">X </span><span class="s3">= </span><span class="s1">X </span><span class="s3">&gt; </span><span class="s1">X</span><span class="s3">.</span><span class="s1">mean</span><span class="s3">()</span>
    <span class="s1">set_random_state</span><span class="s3">(</span><span class="s1">classifier</span><span class="s3">)</span>

    <span class="s1">classifier</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
    <span class="s1">y_pred </span><span class="s3">= </span><span class="s1">classifier</span><span class="s3">.</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">classifier</span><span class="s3">, </span><span class="s4">&quot;decision_function&quot;</span><span class="s3">):</span>
        <span class="s1">decision </span><span class="s3">= </span><span class="s1">classifier</span><span class="s3">.</span><span class="s1">decision_function</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
        <span class="s2">assert </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">decision</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndarray</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">classes</span><span class="s3">) == </span><span class="s6">2</span><span class="s3">:</span>
            <span class="s1">dec_pred </span><span class="s3">= (</span><span class="s1">decision</span><span class="s3">.</span><span class="s1">ravel</span><span class="s3">() &gt; </span><span class="s6">0</span><span class="s3">).</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">int</span><span class="s3">)</span>
            <span class="s1">dec_exp </span><span class="s3">= </span><span class="s1">classifier</span><span class="s3">.</span><span class="s1">classes_</span><span class="s3">[</span><span class="s1">dec_pred</span><span class="s3">]</span>
            <span class="s1">assert_array_equal</span><span class="s3">(</span>
                <span class="s1">dec_exp</span><span class="s3">,</span>
                <span class="s1">y_pred</span><span class="s3">,</span>
                <span class="s1">err_msg</span><span class="s3">=(</span>
                    <span class="s4">&quot;decision_function does not match &quot;</span>
                    <span class="s4">&quot;classifier for %r: expected '%s', got '%s'&quot;</span>
                <span class="s3">)</span>
                <span class="s3">% (</span>
                    <span class="s1">classifier</span><span class="s3">,</span>
                    <span class="s4">&quot;, &quot;</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">map</span><span class="s3">(</span><span class="s1">str</span><span class="s3">, </span><span class="s1">dec_exp</span><span class="s3">)),</span>
                    <span class="s4">&quot;, &quot;</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">map</span><span class="s3">(</span><span class="s1">str</span><span class="s3">, </span><span class="s1">y_pred</span><span class="s3">)),</span>
                <span class="s3">),</span>
            <span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">classifier</span><span class="s3">, </span><span class="s4">&quot;decision_function_shape&quot;</span><span class="s3">, </span><span class="s4">&quot;ovr&quot;</span><span class="s3">) == </span><span class="s4">&quot;ovr&quot;</span><span class="s3">:</span>
            <span class="s1">decision_y </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">argmax</span><span class="s3">(</span><span class="s1">decision</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s6">1</span><span class="s3">).</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">int</span><span class="s3">)</span>
            <span class="s1">y_exp </span><span class="s3">= </span><span class="s1">classifier</span><span class="s3">.</span><span class="s1">classes_</span><span class="s3">[</span><span class="s1">decision_y</span><span class="s3">]</span>
            <span class="s1">assert_array_equal</span><span class="s3">(</span>
                <span class="s1">y_exp</span><span class="s3">,</span>
                <span class="s1">y_pred</span><span class="s3">,</span>
                <span class="s1">err_msg</span><span class="s3">=(</span>
                    <span class="s4">&quot;decision_function does not match &quot;</span>
                    <span class="s4">&quot;classifier for %r: expected '%s', got '%s'&quot;</span>
                <span class="s3">)</span>
                <span class="s3">% (</span>
                    <span class="s1">classifier</span><span class="s3">,</span>
                    <span class="s4">&quot;, &quot;</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">map</span><span class="s3">(</span><span class="s1">str</span><span class="s3">, </span><span class="s1">y_exp</span><span class="s3">)),</span>
                    <span class="s4">&quot;, &quot;</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">map</span><span class="s3">(</span><span class="s1">str</span><span class="s3">, </span><span class="s1">y_pred</span><span class="s3">)),</span>
                <span class="s3">),</span>
            <span class="s3">)</span>

    <span class="s5"># training set performance</span>
    <span class="s2">if </span><span class="s1">name </span><span class="s3">!= </span><span class="s4">&quot;ComplementNB&quot;</span><span class="s3">:</span>
        <span class="s5"># This is a pathological data set for ComplementNB.</span>
        <span class="s5"># For some specific cases 'ComplementNB' predicts less classes</span>
        <span class="s5"># than expected</span>
        <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">unique</span><span class="s3">(</span><span class="s1">y</span><span class="s3">), </span><span class="s1">np</span><span class="s3">.</span><span class="s1">unique</span><span class="s3">(</span><span class="s1">y_pred</span><span class="s3">))</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span>
        <span class="s1">classes</span><span class="s3">,</span>
        <span class="s1">classifier</span><span class="s3">.</span><span class="s1">classes_</span><span class="s3">,</span>
        <span class="s1">err_msg</span><span class="s3">=</span><span class="s4">&quot;Unexpected classes_ attribute for %r: expected '%s', got '%s'&quot;</span>
        <span class="s3">% (</span>
            <span class="s1">classifier</span><span class="s3">,</span>
            <span class="s4">&quot;, &quot;</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">map</span><span class="s3">(</span><span class="s1">str</span><span class="s3">, </span><span class="s1">classes</span><span class="s3">)),</span>
            <span class="s4">&quot;, &quot;</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">map</span><span class="s3">(</span><span class="s1">str</span><span class="s3">, </span><span class="s1">classifier</span><span class="s3">.</span><span class="s1">classes_</span><span class="s3">)),</span>
        <span class="s3">),</span>
    <span class="s3">)</span>


<span class="s2">def </span><span class="s1">_choose_check_classifiers_labels</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">y_names</span><span class="s3">):</span>
    <span class="s5"># Semisupervised classifiers use -1 as the indicator for an unlabeled</span>
    <span class="s5"># sample.</span>
    <span class="s2">return </span><span class="s3">(</span>
        <span class="s1">y</span>
        <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s3">[</span><span class="s4">&quot;LabelPropagation&quot;</span><span class="s3">, </span><span class="s4">&quot;LabelSpreading&quot;</span><span class="s3">, </span><span class="s4">&quot;SelfTrainingClassifier&quot;</span><span class="s3">]</span>
        <span class="s2">else </span><span class="s1">y_names</span>
    <span class="s3">)</span>


<span class="s2">def </span><span class="s1">check_classifiers_classes</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">classifier_orig</span><span class="s3">):</span>
    <span class="s1">X_multiclass</span><span class="s3">, </span><span class="s1">y_multiclass </span><span class="s3">= </span><span class="s1">make_blobs</span><span class="s3">(</span>
        <span class="s1">n_samples</span><span class="s3">=</span><span class="s6">30</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s6">0</span><span class="s3">, </span><span class="s1">cluster_std</span><span class="s3">=</span><span class="s6">0.1</span>
    <span class="s3">)</span>
    <span class="s1">X_multiclass</span><span class="s3">, </span><span class="s1">y_multiclass </span><span class="s3">= </span><span class="s1">shuffle</span><span class="s3">(</span><span class="s1">X_multiclass</span><span class="s3">, </span><span class="s1">y_multiclass</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s6">7</span><span class="s3">)</span>
    <span class="s1">X_multiclass </span><span class="s3">= </span><span class="s1">StandardScaler</span><span class="s3">().</span><span class="s1">fit_transform</span><span class="s3">(</span><span class="s1">X_multiclass</span><span class="s3">)</span>

    <span class="s1">X_binary </span><span class="s3">= </span><span class="s1">X_multiclass</span><span class="s3">[</span><span class="s1">y_multiclass </span><span class="s3">!= </span><span class="s6">2</span><span class="s3">]</span>
    <span class="s1">y_binary </span><span class="s3">= </span><span class="s1">y_multiclass</span><span class="s3">[</span><span class="s1">y_multiclass </span><span class="s3">!= </span><span class="s6">2</span><span class="s3">]</span>

    <span class="s1">X_multiclass </span><span class="s3">= </span><span class="s1">_enforce_estimator_tags_X</span><span class="s3">(</span><span class="s1">classifier_orig</span><span class="s3">, </span><span class="s1">X_multiclass</span><span class="s3">)</span>
    <span class="s1">X_binary </span><span class="s3">= </span><span class="s1">_enforce_estimator_tags_X</span><span class="s3">(</span><span class="s1">classifier_orig</span><span class="s3">, </span><span class="s1">X_binary</span><span class="s3">)</span>

    <span class="s1">labels_multiclass </span><span class="s3">= [</span><span class="s4">&quot;one&quot;</span><span class="s3">, </span><span class="s4">&quot;two&quot;</span><span class="s3">, </span><span class="s4">&quot;three&quot;</span><span class="s3">]</span>
    <span class="s1">labels_binary </span><span class="s3">= [</span><span class="s4">&quot;one&quot;</span><span class="s3">, </span><span class="s4">&quot;two&quot;</span><span class="s3">]</span>

    <span class="s1">y_names_multiclass </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">take</span><span class="s3">(</span><span class="s1">labels_multiclass</span><span class="s3">, </span><span class="s1">y_multiclass</span><span class="s3">)</span>
    <span class="s1">y_names_binary </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">take</span><span class="s3">(</span><span class="s1">labels_binary</span><span class="s3">, </span><span class="s1">y_binary</span><span class="s3">)</span>

    <span class="s1">problems </span><span class="s3">= [(</span><span class="s1">X_binary</span><span class="s3">, </span><span class="s1">y_binary</span><span class="s3">, </span><span class="s1">y_names_binary</span><span class="s3">)]</span>
    <span class="s2">if not </span><span class="s1">_safe_tags</span><span class="s3">(</span><span class="s1">classifier_orig</span><span class="s3">, </span><span class="s1">key</span><span class="s3">=</span><span class="s4">&quot;binary_only&quot;</span><span class="s3">):</span>
        <span class="s1">problems</span><span class="s3">.</span><span class="s1">append</span><span class="s3">((</span><span class="s1">X_multiclass</span><span class="s3">, </span><span class="s1">y_multiclass</span><span class="s3">, </span><span class="s1">y_names_multiclass</span><span class="s3">))</span>

    <span class="s2">for </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">y_names </span><span class="s2">in </span><span class="s1">problems</span><span class="s3">:</span>
        <span class="s2">for </span><span class="s1">y_names_i </span><span class="s2">in </span><span class="s3">[</span><span class="s1">y_names</span><span class="s3">, </span><span class="s1">y_names</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s4">&quot;O&quot;</span><span class="s3">)]:</span>
            <span class="s1">y_ </span><span class="s3">= </span><span class="s1">_choose_check_classifiers_labels</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">y_names_i</span><span class="s3">)</span>
            <span class="s1">check_classifiers_predictions</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y_</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">classifier_orig</span><span class="s3">)</span>

    <span class="s1">labels_binary </span><span class="s3">= [-</span><span class="s6">1</span><span class="s3">, </span><span class="s6">1</span><span class="s3">]</span>
    <span class="s1">y_names_binary </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">take</span><span class="s3">(</span><span class="s1">labels_binary</span><span class="s3">, </span><span class="s1">y_binary</span><span class="s3">)</span>
    <span class="s1">y_binary </span><span class="s3">= </span><span class="s1">_choose_check_classifiers_labels</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">y_binary</span><span class="s3">, </span><span class="s1">y_names_binary</span><span class="s3">)</span>
    <span class="s1">check_classifiers_predictions</span><span class="s3">(</span><span class="s1">X_binary</span><span class="s3">, </span><span class="s1">y_binary</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">classifier_orig</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">ignore_warnings</span><span class="s3">(</span><span class="s1">category</span><span class="s3">=</span><span class="s1">FutureWarning</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">check_regressors_int</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">regressor_orig</span><span class="s3">):</span>
    <span class="s1">X</span><span class="s3">, </span><span class="s1">_ </span><span class="s3">= </span><span class="s1">_regression_dataset</span><span class="s3">()</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">_enforce_estimator_tags_X</span><span class="s3">(</span><span class="s1">regressor_orig</span><span class="s3">, </span><span class="s1">X</span><span class="s3">[:</span><span class="s6">50</span><span class="s3">])</span>
    <span class="s1">rnd </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">RandomState</span><span class="s3">(</span><span class="s6">0</span><span class="s3">)</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">rnd</span><span class="s3">.</span><span class="s1">randint</span><span class="s3">(</span><span class="s6">3</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=</span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s6">0</span><span class="s3">])</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">_enforce_estimator_tags_y</span><span class="s3">(</span><span class="s1">regressor_orig</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
    <span class="s1">rnd </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">RandomState</span><span class="s3">(</span><span class="s6">0</span><span class="s3">)</span>
    <span class="s5"># separate estimators to control random seeds</span>
    <span class="s1">regressor_1 </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">regressor_orig</span><span class="s3">)</span>
    <span class="s1">regressor_2 </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">regressor_orig</span><span class="s3">)</span>
    <span class="s1">set_random_state</span><span class="s3">(</span><span class="s1">regressor_1</span><span class="s3">)</span>
    <span class="s1">set_random_state</span><span class="s3">(</span><span class="s1">regressor_2</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">CROSS_DECOMPOSITION</span><span class="s3">:</span>
        <span class="s1">y_ </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">vstack</span><span class="s3">([</span><span class="s1">y</span><span class="s3">, </span><span class="s6">2 </span><span class="s3">* </span><span class="s1">y </span><span class="s3">+ </span><span class="s1">rnd</span><span class="s3">.</span><span class="s1">randint</span><span class="s3">(</span><span class="s6">2</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=</span><span class="s1">len</span><span class="s3">(</span><span class="s1">y</span><span class="s3">))])</span>
        <span class="s1">y_ </span><span class="s3">= </span><span class="s1">y_</span><span class="s3">.</span><span class="s1">T</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">y_ </span><span class="s3">= </span><span class="s1">y</span>

    <span class="s5"># fit</span>
    <span class="s1">regressor_1</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y_</span><span class="s3">)</span>
    <span class="s1">pred1 </span><span class="s3">= </span><span class="s1">regressor_1</span><span class="s3">.</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
    <span class="s1">regressor_2</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y_</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">float</span><span class="s3">))</span>
    <span class="s1">pred2 </span><span class="s3">= </span><span class="s1">regressor_2</span><span class="s3">.</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
    <span class="s1">assert_allclose</span><span class="s3">(</span><span class="s1">pred1</span><span class="s3">, </span><span class="s1">pred2</span><span class="s3">, </span><span class="s1">atol</span><span class="s3">=</span><span class="s6">1e-2</span><span class="s3">, </span><span class="s1">err_msg</span><span class="s3">=</span><span class="s1">name</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">ignore_warnings</span><span class="s3">(</span><span class="s1">category</span><span class="s3">=</span><span class="s1">FutureWarning</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">check_regressors_train</span><span class="s3">(</span>
    <span class="s1">name</span><span class="s3">, </span><span class="s1">regressor_orig</span><span class="s3">, </span><span class="s1">readonly_memmap</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">X_dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span>
<span class="s3">):</span>
    <span class="s1">X</span><span class="s3">, </span><span class="s1">y </span><span class="s3">= </span><span class="s1">_regression_dataset</span><span class="s3">()</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">X</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">X_dtype</span><span class="s3">)</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">scale</span><span class="s3">(</span><span class="s1">y</span><span class="s3">)  </span><span class="s5"># X is already scaled</span>
    <span class="s1">regressor </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">regressor_orig</span><span class="s3">)</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">_enforce_estimator_tags_X</span><span class="s3">(</span><span class="s1">regressor</span><span class="s3">, </span><span class="s1">X</span><span class="s3">)</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">_enforce_estimator_tags_y</span><span class="s3">(</span><span class="s1">regressor</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">CROSS_DECOMPOSITION</span><span class="s3">:</span>
        <span class="s1">rnd </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">RandomState</span><span class="s3">(</span><span class="s6">0</span><span class="s3">)</span>
        <span class="s1">y_ </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">vstack</span><span class="s3">([</span><span class="s1">y</span><span class="s3">, </span><span class="s6">2 </span><span class="s3">* </span><span class="s1">y </span><span class="s3">+ </span><span class="s1">rnd</span><span class="s3">.</span><span class="s1">randint</span><span class="s3">(</span><span class="s6">2</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=</span><span class="s1">len</span><span class="s3">(</span><span class="s1">y</span><span class="s3">))])</span>
        <span class="s1">y_ </span><span class="s3">= </span><span class="s1">y_</span><span class="s3">.</span><span class="s1">T</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">y_ </span><span class="s3">= </span><span class="s1">y</span>

    <span class="s2">if </span><span class="s1">readonly_memmap</span><span class="s3">:</span>
        <span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">y_ </span><span class="s3">= </span><span class="s1">create_memmap_backed_data</span><span class="s3">([</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">y_</span><span class="s3">])</span>

    <span class="s2">if not </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">regressor</span><span class="s3">, </span><span class="s4">&quot;alphas&quot;</span><span class="s3">) </span><span class="s2">and </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">regressor</span><span class="s3">, </span><span class="s4">&quot;alpha&quot;</span><span class="s3">):</span>
        <span class="s5"># linear regressors need to set alpha, but not generalized CV ones</span>
        <span class="s1">regressor</span><span class="s3">.</span><span class="s1">alpha </span><span class="s3">= </span><span class="s6">0.01</span>
    <span class="s2">if </span><span class="s1">name </span><span class="s3">== </span><span class="s4">&quot;PassiveAggressiveRegressor&quot;</span><span class="s3">:</span>
        <span class="s1">regressor</span><span class="s3">.</span><span class="s1">C </span><span class="s3">= </span><span class="s6">0.01</span>

    <span class="s5"># raises error on malformed input for fit</span>
    <span class="s2">with </span><span class="s1">raises</span><span class="s3">(</span>
        <span class="s1">ValueError</span><span class="s3">,</span>
        <span class="s1">err_msg</span><span class="s3">=(</span>
            <span class="s4">f&quot;The classifier </span><span class="s2">{</span><span class="s1">name</span><span class="s2">} </span><span class="s4">does not raise an error when &quot;</span>
            <span class="s4">&quot;incorrect/malformed input data for fit is passed. The number of &quot;</span>
            <span class="s4">&quot;training examples is not the same as the number of labels. Perhaps &quot;</span>
            <span class="s4">&quot;use check_X_y in fit.&quot;</span>
        <span class="s3">),</span>
    <span class="s3">):</span>
        <span class="s1">regressor</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">[:-</span><span class="s6">1</span><span class="s3">])</span>
    <span class="s5"># fit</span>
    <span class="s1">set_random_state</span><span class="s3">(</span><span class="s1">regressor</span><span class="s3">)</span>
    <span class="s1">regressor</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y_</span><span class="s3">)</span>
    <span class="s1">regressor</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">.</span><span class="s1">tolist</span><span class="s3">(), </span><span class="s1">y_</span><span class="s3">.</span><span class="s1">tolist</span><span class="s3">())</span>
    <span class="s1">y_pred </span><span class="s3">= </span><span class="s1">regressor</span><span class="s3">.</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
    <span class="s2">assert </span><span class="s1">y_pred</span><span class="s3">.</span><span class="s1">shape </span><span class="s3">== </span><span class="s1">y_</span><span class="s3">.</span><span class="s1">shape</span>

    <span class="s5"># TODO: find out why PLS and CCA fail. RANSAC is random</span>
    <span class="s5"># and furthermore assumes the presence of outliers, hence</span>
    <span class="s5"># skipped</span>
    <span class="s2">if not </span><span class="s1">_safe_tags</span><span class="s3">(</span><span class="s1">regressor</span><span class="s3">, </span><span class="s1">key</span><span class="s3">=</span><span class="s4">&quot;poor_score&quot;</span><span class="s3">):</span>
        <span class="s2">assert </span><span class="s1">regressor</span><span class="s3">.</span><span class="s1">score</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y_</span><span class="s3">) &gt; </span><span class="s6">0.5</span>


<span class="s3">@</span><span class="s1">ignore_warnings</span>
<span class="s2">def </span><span class="s1">check_regressors_no_decision_function</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">regressor_orig</span><span class="s3">):</span>
    <span class="s5"># check that regressors don't have a decision_function, predict_proba, or</span>
    <span class="s5"># predict_log_proba method.</span>
    <span class="s1">rng </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">RandomState</span><span class="s3">(</span><span class="s6">0</span><span class="s3">)</span>
    <span class="s1">regressor </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">regressor_orig</span><span class="s3">)</span>

    <span class="s1">X </span><span class="s3">= </span><span class="s1">rng</span><span class="s3">.</span><span class="s1">normal</span><span class="s3">(</span><span class="s1">size</span><span class="s3">=(</span><span class="s6">10</span><span class="s3">, </span><span class="s6">4</span><span class="s3">))</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">_enforce_estimator_tags_X</span><span class="s3">(</span><span class="s1">regressor_orig</span><span class="s3">, </span><span class="s1">X</span><span class="s3">)</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">_enforce_estimator_tags_y</span><span class="s3">(</span><span class="s1">regressor</span><span class="s3">, </span><span class="s1">X</span><span class="s3">[:, </span><span class="s6">0</span><span class="s3">])</span>

    <span class="s1">regressor</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
    <span class="s1">funcs </span><span class="s3">= [</span><span class="s4">&quot;decision_function&quot;</span><span class="s3">, </span><span class="s4">&quot;predict_proba&quot;</span><span class="s3">, </span><span class="s4">&quot;predict_log_proba&quot;</span><span class="s3">]</span>
    <span class="s2">for </span><span class="s1">func_name </span><span class="s2">in </span><span class="s1">funcs</span><span class="s3">:</span>
        <span class="s2">assert not </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">regressor</span><span class="s3">, </span><span class="s1">func_name</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">ignore_warnings</span><span class="s3">(</span><span class="s1">category</span><span class="s3">=</span><span class="s1">FutureWarning</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">check_class_weight_classifiers</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">classifier_orig</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">_safe_tags</span><span class="s3">(</span><span class="s1">classifier_orig</span><span class="s3">, </span><span class="s1">key</span><span class="s3">=</span><span class="s4">&quot;binary_only&quot;</span><span class="s3">):</span>
        <span class="s1">problems </span><span class="s3">= [</span><span class="s6">2</span><span class="s3">]</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">problems </span><span class="s3">= [</span><span class="s6">2</span><span class="s3">, </span><span class="s6">3</span><span class="s3">]</span>

    <span class="s2">for </span><span class="s1">n_centers </span><span class="s2">in </span><span class="s1">problems</span><span class="s3">:</span>
        <span class="s5"># create a very noisy dataset</span>
        <span class="s1">X</span><span class="s3">, </span><span class="s1">y </span><span class="s3">= </span><span class="s1">make_blobs</span><span class="s3">(</span><span class="s1">centers</span><span class="s3">=</span><span class="s1">n_centers</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s6">0</span><span class="s3">, </span><span class="s1">cluster_std</span><span class="s3">=</span><span class="s6">20</span><span class="s3">)</span>
        <span class="s1">X_train</span><span class="s3">, </span><span class="s1">X_test</span><span class="s3">, </span><span class="s1">y_train</span><span class="s3">, </span><span class="s1">y_test </span><span class="s3">= </span><span class="s1">train_test_split</span><span class="s3">(</span>
            <span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">test_size</span><span class="s3">=</span><span class="s6">0.5</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s6">0</span>
        <span class="s3">)</span>

        <span class="s5"># can't use gram_if_pairwise() here, setting up gram matrix manually</span>
        <span class="s2">if </span><span class="s1">_safe_tags</span><span class="s3">(</span><span class="s1">classifier_orig</span><span class="s3">, </span><span class="s1">key</span><span class="s3">=</span><span class="s4">&quot;pairwise&quot;</span><span class="s3">):</span>
            <span class="s1">X_test </span><span class="s3">= </span><span class="s1">rbf_kernel</span><span class="s3">(</span><span class="s1">X_test</span><span class="s3">, </span><span class="s1">X_train</span><span class="s3">)</span>
            <span class="s1">X_train </span><span class="s3">= </span><span class="s1">rbf_kernel</span><span class="s3">(</span><span class="s1">X_train</span><span class="s3">, </span><span class="s1">X_train</span><span class="s3">)</span>

        <span class="s1">n_centers </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">unique</span><span class="s3">(</span><span class="s1">y_train</span><span class="s3">))</span>

        <span class="s2">if </span><span class="s1">n_centers </span><span class="s3">== </span><span class="s6">2</span><span class="s3">:</span>
            <span class="s1">class_weight </span><span class="s3">= {</span><span class="s6">0</span><span class="s3">: </span><span class="s6">1000</span><span class="s3">, </span><span class="s6">1</span><span class="s3">: </span><span class="s6">0.0001</span><span class="s3">}</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">class_weight </span><span class="s3">= {</span><span class="s6">0</span><span class="s3">: </span><span class="s6">1000</span><span class="s3">, </span><span class="s6">1</span><span class="s3">: </span><span class="s6">0.0001</span><span class="s3">, </span><span class="s6">2</span><span class="s3">: </span><span class="s6">0.0001</span><span class="s3">}</span>

        <span class="s1">classifier </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">classifier_orig</span><span class="s3">).</span><span class="s1">set_params</span><span class="s3">(</span><span class="s1">class_weight</span><span class="s3">=</span><span class="s1">class_weight</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">classifier</span><span class="s3">, </span><span class="s4">&quot;n_iter&quot;</span><span class="s3">):</span>
            <span class="s1">classifier</span><span class="s3">.</span><span class="s1">set_params</span><span class="s3">(</span><span class="s1">n_iter</span><span class="s3">=</span><span class="s6">100</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">classifier</span><span class="s3">, </span><span class="s4">&quot;max_iter&quot;</span><span class="s3">):</span>
            <span class="s1">classifier</span><span class="s3">.</span><span class="s1">set_params</span><span class="s3">(</span><span class="s1">max_iter</span><span class="s3">=</span><span class="s6">1000</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">classifier</span><span class="s3">, </span><span class="s4">&quot;min_weight_fraction_leaf&quot;</span><span class="s3">):</span>
            <span class="s1">classifier</span><span class="s3">.</span><span class="s1">set_params</span><span class="s3">(</span><span class="s1">min_weight_fraction_leaf</span><span class="s3">=</span><span class="s6">0.01</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">classifier</span><span class="s3">, </span><span class="s4">&quot;n_iter_no_change&quot;</span><span class="s3">):</span>
            <span class="s1">classifier</span><span class="s3">.</span><span class="s1">set_params</span><span class="s3">(</span><span class="s1">n_iter_no_change</span><span class="s3">=</span><span class="s6">20</span><span class="s3">)</span>

        <span class="s1">set_random_state</span><span class="s3">(</span><span class="s1">classifier</span><span class="s3">)</span>
        <span class="s1">classifier</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X_train</span><span class="s3">, </span><span class="s1">y_train</span><span class="s3">)</span>
        <span class="s1">y_pred </span><span class="s3">= </span><span class="s1">classifier</span><span class="s3">.</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">X_test</span><span class="s3">)</span>
        <span class="s5"># XXX: Generally can use 0.89 here. On Windows, LinearSVC gets</span>
        <span class="s5">#      0.88 (Issue #9111)</span>
        <span class="s2">if not </span><span class="s1">_safe_tags</span><span class="s3">(</span><span class="s1">classifier_orig</span><span class="s3">, </span><span class="s1">key</span><span class="s3">=</span><span class="s4">&quot;poor_score&quot;</span><span class="s3">):</span>
            <span class="s2">assert </span><span class="s1">np</span><span class="s3">.</span><span class="s1">mean</span><span class="s3">(</span><span class="s1">y_pred </span><span class="s3">== </span><span class="s6">0</span><span class="s3">) &gt; </span><span class="s6">0.87</span>


<span class="s3">@</span><span class="s1">ignore_warnings</span><span class="s3">(</span><span class="s1">category</span><span class="s3">=</span><span class="s1">FutureWarning</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">check_class_weight_balanced_classifiers</span><span class="s3">(</span>
    <span class="s1">name</span><span class="s3">, </span><span class="s1">classifier_orig</span><span class="s3">, </span><span class="s1">X_train</span><span class="s3">, </span><span class="s1">y_train</span><span class="s3">, </span><span class="s1">X_test</span><span class="s3">, </span><span class="s1">y_test</span><span class="s3">, </span><span class="s1">weights</span>
<span class="s3">):</span>
    <span class="s1">classifier </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">classifier_orig</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">classifier</span><span class="s3">, </span><span class="s4">&quot;n_iter&quot;</span><span class="s3">):</span>
        <span class="s1">classifier</span><span class="s3">.</span><span class="s1">set_params</span><span class="s3">(</span><span class="s1">n_iter</span><span class="s3">=</span><span class="s6">100</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">classifier</span><span class="s3">, </span><span class="s4">&quot;max_iter&quot;</span><span class="s3">):</span>
        <span class="s1">classifier</span><span class="s3">.</span><span class="s1">set_params</span><span class="s3">(</span><span class="s1">max_iter</span><span class="s3">=</span><span class="s6">1000</span><span class="s3">)</span>

    <span class="s1">set_random_state</span><span class="s3">(</span><span class="s1">classifier</span><span class="s3">)</span>
    <span class="s1">classifier</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X_train</span><span class="s3">, </span><span class="s1">y_train</span><span class="s3">)</span>
    <span class="s1">y_pred </span><span class="s3">= </span><span class="s1">classifier</span><span class="s3">.</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">X_test</span><span class="s3">)</span>

    <span class="s1">classifier</span><span class="s3">.</span><span class="s1">set_params</span><span class="s3">(</span><span class="s1">class_weight</span><span class="s3">=</span><span class="s4">&quot;balanced&quot;</span><span class="s3">)</span>
    <span class="s1">classifier</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X_train</span><span class="s3">, </span><span class="s1">y_train</span><span class="s3">)</span>
    <span class="s1">y_pred_balanced </span><span class="s3">= </span><span class="s1">classifier</span><span class="s3">.</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">X_test</span><span class="s3">)</span>
    <span class="s2">assert </span><span class="s1">f1_score</span><span class="s3">(</span><span class="s1">y_test</span><span class="s3">, </span><span class="s1">y_pred_balanced</span><span class="s3">, </span><span class="s1">average</span><span class="s3">=</span><span class="s4">&quot;weighted&quot;</span><span class="s3">) &gt; </span><span class="s1">f1_score</span><span class="s3">(</span>
        <span class="s1">y_test</span><span class="s3">, </span><span class="s1">y_pred</span><span class="s3">, </span><span class="s1">average</span><span class="s3">=</span><span class="s4">&quot;weighted&quot;</span>
    <span class="s3">)</span>


<span class="s3">@</span><span class="s1">ignore_warnings</span><span class="s3">(</span><span class="s1">category</span><span class="s3">=</span><span class="s1">FutureWarning</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">check_class_weight_balanced_linear_classifier</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">Classifier</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Test class weights with non-contiguous class labels.&quot;&quot;&quot;</span>
    <span class="s5"># this is run on classes, not instances, though this should be changed</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([[-</span><span class="s6">1.0</span><span class="s3">, -</span><span class="s6">1.0</span><span class="s3">], [-</span><span class="s6">1.0</span><span class="s3">, </span><span class="s6">0</span><span class="s3">], [-</span><span class="s6">0.8</span><span class="s3">, -</span><span class="s6">1.0</span><span class="s3">], [</span><span class="s6">1.0</span><span class="s3">, </span><span class="s6">1.0</span><span class="s3">], [</span><span class="s6">1.0</span><span class="s3">, </span><span class="s6">0.0</span><span class="s3">]])</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s6">1</span><span class="s3">, </span><span class="s6">1</span><span class="s3">, </span><span class="s6">1</span><span class="s3">, -</span><span class="s6">1</span><span class="s3">, -</span><span class="s6">1</span><span class="s3">])</span>

    <span class="s1">classifier </span><span class="s3">= </span><span class="s1">Classifier</span><span class="s3">()</span>

    <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">classifier</span><span class="s3">, </span><span class="s4">&quot;n_iter&quot;</span><span class="s3">):</span>
        <span class="s5"># This is a very small dataset, default n_iter are likely to prevent</span>
        <span class="s5"># convergence</span>
        <span class="s1">classifier</span><span class="s3">.</span><span class="s1">set_params</span><span class="s3">(</span><span class="s1">n_iter</span><span class="s3">=</span><span class="s6">1000</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">classifier</span><span class="s3">, </span><span class="s4">&quot;max_iter&quot;</span><span class="s3">):</span>
        <span class="s1">classifier</span><span class="s3">.</span><span class="s1">set_params</span><span class="s3">(</span><span class="s1">max_iter</span><span class="s3">=</span><span class="s6">1000</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">classifier</span><span class="s3">, </span><span class="s4">&quot;cv&quot;</span><span class="s3">):</span>
        <span class="s1">classifier</span><span class="s3">.</span><span class="s1">set_params</span><span class="s3">(</span><span class="s1">cv</span><span class="s3">=</span><span class="s6">3</span><span class="s3">)</span>
    <span class="s1">set_random_state</span><span class="s3">(</span><span class="s1">classifier</span><span class="s3">)</span>

    <span class="s5"># Let the model compute the class frequencies</span>
    <span class="s1">classifier</span><span class="s3">.</span><span class="s1">set_params</span><span class="s3">(</span><span class="s1">class_weight</span><span class="s3">=</span><span class="s4">&quot;balanced&quot;</span><span class="s3">)</span>
    <span class="s1">coef_balanced </span><span class="s3">= </span><span class="s1">classifier</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">).</span><span class="s1">coef_</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>

    <span class="s5"># Count each label occurrence to reweight manually</span>
    <span class="s1">n_samples </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">y</span><span class="s3">)</span>
    <span class="s1">n_classes </span><span class="s3">= </span><span class="s1">float</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">unique</span><span class="s3">(</span><span class="s1">y</span><span class="s3">)))</span>

    <span class="s1">class_weight </span><span class="s3">= {</span>
        <span class="s6">1</span><span class="s3">: </span><span class="s1">n_samples </span><span class="s3">/ (</span><span class="s1">np</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">(</span><span class="s1">y </span><span class="s3">== </span><span class="s6">1</span><span class="s3">) * </span><span class="s1">n_classes</span><span class="s3">),</span>
        <span class="s3">-</span><span class="s6">1</span><span class="s3">: </span><span class="s1">n_samples </span><span class="s3">/ (</span><span class="s1">np</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">(</span><span class="s1">y </span><span class="s3">== -</span><span class="s6">1</span><span class="s3">) * </span><span class="s1">n_classes</span><span class="s3">),</span>
    <span class="s3">}</span>
    <span class="s1">classifier</span><span class="s3">.</span><span class="s1">set_params</span><span class="s3">(</span><span class="s1">class_weight</span><span class="s3">=</span><span class="s1">class_weight</span><span class="s3">)</span>
    <span class="s1">coef_manual </span><span class="s3">= </span><span class="s1">classifier</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">).</span><span class="s1">coef_</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>

    <span class="s1">assert_allclose</span><span class="s3">(</span>
        <span class="s1">coef_balanced</span><span class="s3">,</span>
        <span class="s1">coef_manual</span><span class="s3">,</span>
        <span class="s1">err_msg</span><span class="s3">=</span><span class="s4">&quot;Classifier %s is not computing class_weight=balanced properly.&quot; </span><span class="s3">% </span><span class="s1">name</span><span class="s3">,</span>
    <span class="s3">)</span>


<span class="s3">@</span><span class="s1">ignore_warnings</span><span class="s3">(</span><span class="s1">category</span><span class="s3">=</span><span class="s1">FutureWarning</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">check_estimators_overwrite_params</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">estimator_orig</span><span class="s3">):</span>
    <span class="s1">X</span><span class="s3">, </span><span class="s1">y </span><span class="s3">= </span><span class="s1">make_blobs</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">=</span><span class="s6">0</span><span class="s3">, </span><span class="s1">n_samples</span><span class="s3">=</span><span class="s6">21</span><span class="s3">)</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">_enforce_estimator_tags_X</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">kernel</span><span class="s3">=</span><span class="s1">rbf_kernel</span><span class="s3">)</span>
    <span class="s1">estimator </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">)</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">_enforce_estimator_tags_y</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>

    <span class="s1">set_random_state</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">)</span>

    <span class="s5"># Make a physical copy of the original estimator parameters before fitting.</span>
    <span class="s1">params </span><span class="s3">= </span><span class="s1">estimator</span><span class="s3">.</span><span class="s1">get_params</span><span class="s3">()</span>
    <span class="s1">original_params </span><span class="s3">= </span><span class="s1">deepcopy</span><span class="s3">(</span><span class="s1">params</span><span class="s3">)</span>

    <span class="s5"># Fit the model</span>
    <span class="s1">estimator</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>

    <span class="s5"># Compare the state of the model parameters with the original parameters</span>
    <span class="s1">new_params </span><span class="s3">= </span><span class="s1">estimator</span><span class="s3">.</span><span class="s1">get_params</span><span class="s3">()</span>
    <span class="s2">for </span><span class="s1">param_name</span><span class="s3">, </span><span class="s1">original_value </span><span class="s2">in </span><span class="s1">original_params</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
        <span class="s1">new_value </span><span class="s3">= </span><span class="s1">new_params</span><span class="s3">[</span><span class="s1">param_name</span><span class="s3">]</span>

        <span class="s5"># We should never change or mutate the internal state of input</span>
        <span class="s5"># parameters by default. To check this we use the joblib.hash function</span>
        <span class="s5"># that introspects recursively any subobjects to compute a checksum.</span>
        <span class="s5"># The only exception to this rule of immutable constructor parameters</span>
        <span class="s5"># is possible RandomState instance but in this check we explicitly</span>
        <span class="s5"># fixed the random_state params recursively to be integer seeds.</span>
        <span class="s2">assert </span><span class="s1">joblib</span><span class="s3">.</span><span class="s1">hash</span><span class="s3">(</span><span class="s1">new_value</span><span class="s3">) == </span><span class="s1">joblib</span><span class="s3">.</span><span class="s1">hash</span><span class="s3">(</span><span class="s1">original_value</span><span class="s3">), (</span>
            <span class="s4">&quot;Estimator %s should not change or mutate &quot;</span>
            <span class="s4">&quot; the parameter %s from %s to %s during fit.&quot;</span>
            <span class="s3">% (</span><span class="s1">name</span><span class="s3">, </span><span class="s1">param_name</span><span class="s3">, </span><span class="s1">original_value</span><span class="s3">, </span><span class="s1">new_value</span><span class="s3">)</span>
        <span class="s3">)</span>


<span class="s3">@</span><span class="s1">ignore_warnings</span><span class="s3">(</span><span class="s1">category</span><span class="s3">=</span><span class="s1">FutureWarning</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">check_no_attributes_set_in_init</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">estimator_orig</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Check setting during init.&quot;&quot;&quot;</span>
    <span class="s2">try</span><span class="s3">:</span>
        <span class="s5"># Clone fails if the estimator does not store</span>
        <span class="s5"># all parameters as an attribute during init</span>
        <span class="s1">estimator </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">)</span>
    <span class="s2">except </span><span class="s1">AttributeError</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">AttributeError</span><span class="s3">(</span>
            <span class="s4">f&quot;Estimator </span><span class="s2">{</span><span class="s1">name</span><span class="s2">} </span><span class="s4">should store all parameters as an attribute during init.&quot;</span>
        <span class="s3">)</span>

    <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">type</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">).</span><span class="s1">__init__</span><span class="s3">, </span><span class="s4">&quot;deprecated_original&quot;</span><span class="s3">):</span>
        <span class="s2">return</span>

    <span class="s1">init_params </span><span class="s3">= </span><span class="s1">_get_args</span><span class="s3">(</span><span class="s1">type</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">).</span><span class="s1">__init__</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">_IS_PYPY</span><span class="s3">:</span>
        <span class="s5"># __init__ signature has additional objects in PyPy</span>
        <span class="s2">for </span><span class="s1">key </span><span class="s2">in </span><span class="s3">[</span><span class="s4">&quot;obj&quot;</span><span class="s3">]:</span>
            <span class="s2">if </span><span class="s1">key </span><span class="s2">in </span><span class="s1">init_params</span><span class="s3">:</span>
                <span class="s1">init_params</span><span class="s3">.</span><span class="s1">remove</span><span class="s3">(</span><span class="s1">key</span><span class="s3">)</span>
    <span class="s1">parents_init_params </span><span class="s3">= [</span>
        <span class="s1">param</span>
        <span class="s2">for </span><span class="s1">params_parent </span><span class="s2">in </span><span class="s3">(</span><span class="s1">_get_args</span><span class="s3">(</span><span class="s1">parent</span><span class="s3">) </span><span class="s2">for </span><span class="s1">parent </span><span class="s2">in </span><span class="s1">type</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">).</span><span class="s1">__mro__</span><span class="s3">)</span>
        <span class="s2">for </span><span class="s1">param </span><span class="s2">in </span><span class="s1">params_parent</span>
    <span class="s3">]</span>

    <span class="s5"># Test for no setting apart from parameters during init</span>
    <span class="s1">invalid_attr </span><span class="s3">= </span><span class="s1">set</span><span class="s3">(</span><span class="s1">vars</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">)) - </span><span class="s1">set</span><span class="s3">(</span><span class="s1">init_params</span><span class="s3">) - </span><span class="s1">set</span><span class="s3">(</span><span class="s1">parents_init_params</span><span class="s3">)</span>
    <span class="s5"># Ignore private attributes</span>
    <span class="s1">invalid_attr </span><span class="s3">= </span><span class="s1">set</span><span class="s3">([</span><span class="s1">attr </span><span class="s2">for </span><span class="s1">attr </span><span class="s2">in </span><span class="s1">invalid_attr </span><span class="s2">if not </span><span class="s1">attr</span><span class="s3">.</span><span class="s1">startswith</span><span class="s3">(</span><span class="s4">&quot;_&quot;</span><span class="s3">)])</span>
    <span class="s2">assert not </span><span class="s1">invalid_attr</span><span class="s3">, (</span>
        <span class="s4">&quot;Estimator %s should not set any attribute apart&quot;</span>
        <span class="s4">&quot; from parameters during init. Found attributes %s.&quot;</span>
        <span class="s3">% (</span><span class="s1">name</span><span class="s3">, </span><span class="s1">sorted</span><span class="s3">(</span><span class="s1">invalid_attr</span><span class="s3">))</span>
    <span class="s3">)</span>


<span class="s3">@</span><span class="s1">ignore_warnings</span><span class="s3">(</span><span class="s1">category</span><span class="s3">=</span><span class="s1">FutureWarning</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">check_sparsify_coefficients</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">estimator_orig</span><span class="s3">):</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span>
        <span class="s3">[</span>
            <span class="s3">[-</span><span class="s6">2</span><span class="s3">, -</span><span class="s6">1</span><span class="s3">],</span>
            <span class="s3">[-</span><span class="s6">1</span><span class="s3">, -</span><span class="s6">1</span><span class="s3">],</span>
            <span class="s3">[-</span><span class="s6">1</span><span class="s3">, -</span><span class="s6">2</span><span class="s3">],</span>
            <span class="s3">[</span><span class="s6">1</span><span class="s3">, </span><span class="s6">1</span><span class="s3">],</span>
            <span class="s3">[</span><span class="s6">1</span><span class="s3">, </span><span class="s6">2</span><span class="s3">],</span>
            <span class="s3">[</span><span class="s6">2</span><span class="s3">, </span><span class="s6">1</span><span class="s3">],</span>
            <span class="s3">[-</span><span class="s6">1</span><span class="s3">, -</span><span class="s6">2</span><span class="s3">],</span>
            <span class="s3">[</span><span class="s6">2</span><span class="s3">, </span><span class="s6">2</span><span class="s3">],</span>
            <span class="s3">[-</span><span class="s6">2</span><span class="s3">, -</span><span class="s6">2</span><span class="s3">],</span>
        <span class="s3">]</span>
    <span class="s3">)</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s6">1</span><span class="s3">, </span><span class="s6">1</span><span class="s3">, </span><span class="s6">1</span><span class="s3">, </span><span class="s6">2</span><span class="s3">, </span><span class="s6">2</span><span class="s3">, </span><span class="s6">2</span><span class="s3">, </span><span class="s6">3</span><span class="s3">, </span><span class="s6">3</span><span class="s3">, </span><span class="s6">3</span><span class="s3">])</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">_enforce_estimator_tags_y</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
    <span class="s1">est </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">)</span>

    <span class="s1">est</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
    <span class="s1">pred_orig </span><span class="s3">= </span><span class="s1">est</span><span class="s3">.</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>

    <span class="s5"># test sparsify with dense inputs</span>
    <span class="s1">est</span><span class="s3">.</span><span class="s1">sparsify</span><span class="s3">()</span>
    <span class="s2">assert </span><span class="s1">sparse</span><span class="s3">.</span><span class="s1">issparse</span><span class="s3">(</span><span class="s1">est</span><span class="s3">.</span><span class="s1">coef_</span><span class="s3">)</span>
    <span class="s1">pred </span><span class="s3">= </span><span class="s1">est</span><span class="s3">.</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">pred</span><span class="s3">, </span><span class="s1">pred_orig</span><span class="s3">)</span>

    <span class="s5"># pickle and unpickle with sparse coef_</span>
    <span class="s1">est </span><span class="s3">= </span><span class="s1">pickle</span><span class="s3">.</span><span class="s1">loads</span><span class="s3">(</span><span class="s1">pickle</span><span class="s3">.</span><span class="s1">dumps</span><span class="s3">(</span><span class="s1">est</span><span class="s3">))</span>
    <span class="s2">assert </span><span class="s1">sparse</span><span class="s3">.</span><span class="s1">issparse</span><span class="s3">(</span><span class="s1">est</span><span class="s3">.</span><span class="s1">coef_</span><span class="s3">)</span>
    <span class="s1">pred </span><span class="s3">= </span><span class="s1">est</span><span class="s3">.</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">pred</span><span class="s3">, </span><span class="s1">pred_orig</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">ignore_warnings</span><span class="s3">(</span><span class="s1">category</span><span class="s3">=</span><span class="s1">FutureWarning</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">check_classifier_data_not_an_array</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">estimator_orig</span><span class="s3">):</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span>
        <span class="s3">[</span>
            <span class="s3">[</span><span class="s6">3</span><span class="s3">, </span><span class="s6">0</span><span class="s3">],</span>
            <span class="s3">[</span><span class="s6">0</span><span class="s3">, </span><span class="s6">1</span><span class="s3">],</span>
            <span class="s3">[</span><span class="s6">0</span><span class="s3">, </span><span class="s6">2</span><span class="s3">],</span>
            <span class="s3">[</span><span class="s6">1</span><span class="s3">, </span><span class="s6">1</span><span class="s3">],</span>
            <span class="s3">[</span><span class="s6">1</span><span class="s3">, </span><span class="s6">2</span><span class="s3">],</span>
            <span class="s3">[</span><span class="s6">2</span><span class="s3">, </span><span class="s6">1</span><span class="s3">],</span>
            <span class="s3">[</span><span class="s6">0</span><span class="s3">, </span><span class="s6">3</span><span class="s3">],</span>
            <span class="s3">[</span><span class="s6">1</span><span class="s3">, </span><span class="s6">0</span><span class="s3">],</span>
            <span class="s3">[</span><span class="s6">2</span><span class="s3">, </span><span class="s6">0</span><span class="s3">],</span>
            <span class="s3">[</span><span class="s6">4</span><span class="s3">, </span><span class="s6">4</span><span class="s3">],</span>
            <span class="s3">[</span><span class="s6">2</span><span class="s3">, </span><span class="s6">3</span><span class="s3">],</span>
            <span class="s3">[</span><span class="s6">3</span><span class="s3">, </span><span class="s6">2</span><span class="s3">],</span>
        <span class="s3">]</span>
    <span class="s3">)</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">_enforce_estimator_tags_X</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">, </span><span class="s1">X</span><span class="s3">)</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s6">1</span><span class="s3">, </span><span class="s6">1</span><span class="s3">, </span><span class="s6">1</span><span class="s3">, </span><span class="s6">2</span><span class="s3">, </span><span class="s6">2</span><span class="s3">, </span><span class="s6">2</span><span class="s3">, </span><span class="s6">1</span><span class="s3">, </span><span class="s6">1</span><span class="s3">, </span><span class="s6">1</span><span class="s3">, </span><span class="s6">2</span><span class="s3">, </span><span class="s6">2</span><span class="s3">, </span><span class="s6">2</span><span class="s3">])</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">_enforce_estimator_tags_y</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
    <span class="s2">for </span><span class="s1">obj_type </span><span class="s2">in </span><span class="s3">[</span><span class="s4">&quot;NotAnArray&quot;</span><span class="s3">, </span><span class="s4">&quot;PandasDataframe&quot;</span><span class="s3">]:</span>
        <span class="s1">check_estimators_data_not_an_array</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">estimator_orig</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">obj_type</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">ignore_warnings</span><span class="s3">(</span><span class="s1">category</span><span class="s3">=</span><span class="s1">FutureWarning</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">check_regressor_data_not_an_array</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">estimator_orig</span><span class="s3">):</span>
    <span class="s1">X</span><span class="s3">, </span><span class="s1">y </span><span class="s3">= </span><span class="s1">_regression_dataset</span><span class="s3">()</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">_enforce_estimator_tags_X</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">, </span><span class="s1">X</span><span class="s3">)</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">_enforce_estimator_tags_y</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
    <span class="s2">for </span><span class="s1">obj_type </span><span class="s2">in </span><span class="s3">[</span><span class="s4">&quot;NotAnArray&quot;</span><span class="s3">, </span><span class="s4">&quot;PandasDataframe&quot;</span><span class="s3">]:</span>
        <span class="s1">check_estimators_data_not_an_array</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">estimator_orig</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">obj_type</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">ignore_warnings</span><span class="s3">(</span><span class="s1">category</span><span class="s3">=</span><span class="s1">FutureWarning</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">check_estimators_data_not_an_array</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">estimator_orig</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">obj_type</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">CROSS_DECOMPOSITION</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">SkipTest</span><span class="s3">(</span>
            <span class="s4">&quot;Skipping check_estimators_data_not_an_array &quot;</span>
            <span class="s4">&quot;for cross decomposition module as estimators &quot;</span>
            <span class="s4">&quot;are not deterministic.&quot;</span>
        <span class="s3">)</span>
    <span class="s5"># separate estimators to control random seeds</span>
    <span class="s1">estimator_1 </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">)</span>
    <span class="s1">estimator_2 </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">)</span>
    <span class="s1">set_random_state</span><span class="s3">(</span><span class="s1">estimator_1</span><span class="s3">)</span>
    <span class="s1">set_random_state</span><span class="s3">(</span><span class="s1">estimator_2</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">obj_type </span><span class="s2">not in </span><span class="s3">[</span><span class="s4">&quot;NotAnArray&quot;</span><span class="s3">, </span><span class="s4">&quot;PandasDataframe&quot;</span><span class="s3">]:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Data type {0} not supported&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">obj_type</span><span class="s3">))</span>

    <span class="s2">if </span><span class="s1">obj_type </span><span class="s3">== </span><span class="s4">&quot;NotAnArray&quot;</span><span class="s3">:</span>
        <span class="s1">y_ </span><span class="s3">= </span><span class="s1">_NotAnArray</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">y</span><span class="s3">))</span>
        <span class="s1">X_ </span><span class="s3">= </span><span class="s1">_NotAnArray</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">X</span><span class="s3">))</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s5"># Here pandas objects (Series and DataFrame) are tested explicitly</span>
        <span class="s5"># because some estimators may handle them (especially their indexing)</span>
        <span class="s5"># specially.</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s2">import </span><span class="s1">pandas </span><span class="s2">as </span><span class="s1">pd</span>

            <span class="s1">y_ </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">y</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">y_</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s6">1</span><span class="s3">:</span>
                <span class="s1">y_ </span><span class="s3">= </span><span class="s1">pd</span><span class="s3">.</span><span class="s1">Series</span><span class="s3">(</span><span class="s1">y_</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">y_ </span><span class="s3">= </span><span class="s1">pd</span><span class="s3">.</span><span class="s1">DataFrame</span><span class="s3">(</span><span class="s1">y_</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
            <span class="s1">X_ </span><span class="s3">= </span><span class="s1">pd</span><span class="s3">.</span><span class="s1">DataFrame</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">X</span><span class="s3">), </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>

        <span class="s2">except </span><span class="s1">ImportError</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">SkipTest</span><span class="s3">(</span>
                <span class="s4">&quot;pandas is not installed: not checking estimators for pandas objects.&quot;</span>
            <span class="s3">)</span>

    <span class="s5"># fit</span>
    <span class="s1">estimator_1</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X_</span><span class="s3">, </span><span class="s1">y_</span><span class="s3">)</span>
    <span class="s1">pred1 </span><span class="s3">= </span><span class="s1">estimator_1</span><span class="s3">.</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">X_</span><span class="s3">)</span>
    <span class="s1">estimator_2</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
    <span class="s1">pred2 </span><span class="s3">= </span><span class="s1">estimator_2</span><span class="s3">.</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
    <span class="s1">assert_allclose</span><span class="s3">(</span><span class="s1">pred1</span><span class="s3">, </span><span class="s1">pred2</span><span class="s3">, </span><span class="s1">atol</span><span class="s3">=</span><span class="s6">1e-2</span><span class="s3">, </span><span class="s1">err_msg</span><span class="s3">=</span><span class="s1">name</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">check_parameters_default_constructible</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">Estimator</span><span class="s3">):</span>
    <span class="s5"># test default-constructibility</span>
    <span class="s5"># get rid of deprecation warnings</span>

    <span class="s1">Estimator </span><span class="s3">= </span><span class="s1">Estimator</span><span class="s3">.</span><span class="s1">__class__</span>

    <span class="s2">with </span><span class="s1">ignore_warnings</span><span class="s3">(</span><span class="s1">category</span><span class="s3">=</span><span class="s1">FutureWarning</span><span class="s3">):</span>
        <span class="s1">estimator </span><span class="s3">= </span><span class="s1">_construct_instance</span><span class="s3">(</span><span class="s1">Estimator</span><span class="s3">)</span>
        <span class="s5"># test cloning</span>
        <span class="s1">clone</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">)</span>
        <span class="s5"># test __repr__</span>
        <span class="s1">repr</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">)</span>
        <span class="s5"># test that set_params returns self</span>
        <span class="s2">assert </span><span class="s1">estimator</span><span class="s3">.</span><span class="s1">set_params</span><span class="s3">() </span><span class="s2">is </span><span class="s1">estimator</span>

        <span class="s5"># test if init does nothing but set parameters</span>
        <span class="s5"># this is important for grid_search etc.</span>
        <span class="s5"># We get the default parameters from init and then</span>
        <span class="s5"># compare these against the actual values of the attributes.</span>

        <span class="s5"># this comes from getattr. Gets rid of deprecation decorator.</span>
        <span class="s1">init </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">.</span><span class="s1">__init__</span><span class="s3">, </span><span class="s4">&quot;deprecated_original&quot;</span><span class="s3">, </span><span class="s1">estimator</span><span class="s3">.</span><span class="s1">__init__</span><span class="s3">)</span>

        <span class="s2">try</span><span class="s3">:</span>

            <span class="s2">def </span><span class="s1">param_filter</span><span class="s3">(</span><span class="s1">p</span><span class="s3">):</span>
                <span class="s0">&quot;&quot;&quot;Identify hyper parameters of an estimator.&quot;&quot;&quot;</span>
                <span class="s2">return </span><span class="s3">(</span>
                    <span class="s1">p</span><span class="s3">.</span><span class="s1">name </span><span class="s3">!= </span><span class="s4">&quot;self&quot;</span>
                    <span class="s2">and </span><span class="s1">p</span><span class="s3">.</span><span class="s1">kind </span><span class="s3">!= </span><span class="s1">p</span><span class="s3">.</span><span class="s1">VAR_KEYWORD</span>
                    <span class="s2">and </span><span class="s1">p</span><span class="s3">.</span><span class="s1">kind </span><span class="s3">!= </span><span class="s1">p</span><span class="s3">.</span><span class="s1">VAR_POSITIONAL</span>
                <span class="s3">)</span>

            <span class="s1">init_params </span><span class="s3">= [</span>
                <span class="s1">p </span><span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">signature</span><span class="s3">(</span><span class="s1">init</span><span class="s3">).</span><span class="s1">parameters</span><span class="s3">.</span><span class="s1">values</span><span class="s3">() </span><span class="s2">if </span><span class="s1">param_filter</span><span class="s3">(</span><span class="s1">p</span><span class="s3">)</span>
            <span class="s3">]</span>

        <span class="s2">except </span><span class="s3">(</span><span class="s1">TypeError</span><span class="s3">, </span><span class="s1">ValueError</span><span class="s3">):</span>
            <span class="s5"># init is not a python function.</span>
            <span class="s5"># true for mixins</span>
            <span class="s2">return</span>
        <span class="s1">params </span><span class="s3">= </span><span class="s1">estimator</span><span class="s3">.</span><span class="s1">get_params</span><span class="s3">()</span>
        <span class="s5"># they can need a non-default argument</span>
        <span class="s1">init_params </span><span class="s3">= </span><span class="s1">init_params</span><span class="s3">[</span><span class="s1">len</span><span class="s3">(</span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s4">&quot;_required_parameters&quot;</span><span class="s3">, [])) :]</span>

        <span class="s2">for </span><span class="s1">init_param </span><span class="s2">in </span><span class="s1">init_params</span><span class="s3">:</span>
            <span class="s2">assert </span><span class="s3">(</span>
                <span class="s1">init_param</span><span class="s3">.</span><span class="s1">default </span><span class="s3">!= </span><span class="s1">init_param</span><span class="s3">.</span><span class="s1">empty</span>
            <span class="s3">), </span><span class="s4">&quot;parameter %s for %s has no default value&quot; </span><span class="s3">% (</span>
                <span class="s1">init_param</span><span class="s3">.</span><span class="s1">name</span><span class="s3">,</span>
                <span class="s1">type</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">).</span><span class="s1">__name__</span><span class="s3">,</span>
            <span class="s3">)</span>
            <span class="s1">allowed_types </span><span class="s3">= {</span>
                <span class="s1">str</span><span class="s3">,</span>
                <span class="s1">int</span><span class="s3">,</span>
                <span class="s1">float</span><span class="s3">,</span>
                <span class="s1">bool</span><span class="s3">,</span>
                <span class="s1">tuple</span><span class="s3">,</span>
                <span class="s1">type</span><span class="s3">(</span><span class="s2">None</span><span class="s3">),</span>
                <span class="s1">type</span><span class="s3">,</span>
            <span class="s3">}</span>
            <span class="s5"># Any numpy numeric such as np.int32.</span>
            <span class="s1">allowed_types</span><span class="s3">.</span><span class="s1">update</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">sctypeDict</span><span class="s3">.</span><span class="s1">values</span><span class="s3">())</span>

            <span class="s1">allowed_value </span><span class="s3">= (</span>
                <span class="s1">type</span><span class="s3">(</span><span class="s1">init_param</span><span class="s3">.</span><span class="s1">default</span><span class="s3">) </span><span class="s2">in </span><span class="s1">allowed_types</span>
                <span class="s2">or</span>
                <span class="s5"># Although callables are mutable, we accept them as argument</span>
                <span class="s5"># default value and trust that neither the implementation of</span>
                <span class="s5"># the callable nor of the estimator changes the state of the</span>
                <span class="s5"># callable.</span>
                <span class="s1">callable</span><span class="s3">(</span><span class="s1">init_param</span><span class="s3">.</span><span class="s1">default</span><span class="s3">)</span>
            <span class="s3">)</span>

            <span class="s2">assert </span><span class="s1">allowed_value</span><span class="s3">, (</span>
                <span class="s4">f&quot;Parameter '</span><span class="s2">{</span><span class="s1">init_param</span><span class="s3">.</span><span class="s1">name</span><span class="s2">}</span><span class="s4">' of estimator &quot;</span>
                <span class="s4">f&quot;'</span><span class="s2">{</span><span class="s1">Estimator</span><span class="s3">.</span><span class="s1">__name__</span><span class="s2">}</span><span class="s4">' is of type &quot;</span>
                <span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">type</span><span class="s3">(</span><span class="s1">init_param</span><span class="s3">.</span><span class="s1">default</span><span class="s3">).</span><span class="s1">__name__</span><span class="s2">} </span><span class="s4">which is not allowed. &quot;</span>
                <span class="s4">f&quot;'</span><span class="s2">{</span><span class="s1">init_param</span><span class="s3">.</span><span class="s1">name</span><span class="s2">}</span><span class="s4">' must be a callable or must be of type &quot;</span>
                <span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">set</span><span class="s3">(</span><span class="s1">type</span><span class="s3">.</span><span class="s1">__name__ </span><span class="s2">for </span><span class="s1">type </span><span class="s2">in </span><span class="s1">allowed_types</span><span class="s3">)</span><span class="s2">}</span><span class="s4">.&quot;</span>
            <span class="s3">)</span>
            <span class="s2">if </span><span class="s1">init_param</span><span class="s3">.</span><span class="s1">name </span><span class="s2">not in </span><span class="s1">params</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">():</span>
                <span class="s5"># deprecated parameter, not in get_params</span>
                <span class="s2">assert </span><span class="s1">init_param</span><span class="s3">.</span><span class="s1">default </span><span class="s2">is None</span><span class="s3">, (</span>
                    <span class="s4">f&quot;Estimator parameter '</span><span class="s2">{</span><span class="s1">init_param</span><span class="s3">.</span><span class="s1">name</span><span class="s2">}</span><span class="s4">' of estimator &quot;</span>
                    <span class="s4">f&quot;'</span><span class="s2">{</span><span class="s1">Estimator</span><span class="s3">.</span><span class="s1">__name__</span><span class="s2">}</span><span class="s4">' is not returned by get_params. &quot;</span>
                    <span class="s4">&quot;If it is deprecated, set its default value to None.&quot;</span>
                <span class="s3">)</span>
                <span class="s2">continue</span>

            <span class="s1">param_value </span><span class="s3">= </span><span class="s1">params</span><span class="s3">[</span><span class="s1">init_param</span><span class="s3">.</span><span class="s1">name</span><span class="s3">]</span>
            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">param_value</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndarray</span><span class="s3">):</span>
                <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">param_value</span><span class="s3">, </span><span class="s1">init_param</span><span class="s3">.</span><span class="s1">default</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">failure_text </span><span class="s3">= (</span>
                    <span class="s4">f&quot;Parameter </span><span class="s2">{</span><span class="s1">init_param</span><span class="s3">.</span><span class="s1">name</span><span class="s2">} </span><span class="s4">was mutated on init. All &quot;</span>
                    <span class="s4">&quot;parameters must be stored unchanged.&quot;</span>
                <span class="s3">)</span>
                <span class="s2">if </span><span class="s1">is_scalar_nan</span><span class="s3">(</span><span class="s1">param_value</span><span class="s3">):</span>
                    <span class="s5"># Allows to set default parameters to np.nan</span>
                    <span class="s2">assert </span><span class="s1">param_value </span><span class="s2">is </span><span class="s1">init_param</span><span class="s3">.</span><span class="s1">default</span><span class="s3">, </span><span class="s1">failure_text</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s2">assert </span><span class="s1">param_value </span><span class="s3">== </span><span class="s1">init_param</span><span class="s3">.</span><span class="s1">default</span><span class="s3">, </span><span class="s1">failure_text</span>


<span class="s2">def </span><span class="s1">_enforce_estimator_tags_y</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">y</span><span class="s3">):</span>
    <span class="s5"># Estimators with a `requires_positive_y` tag only accept strictly positive</span>
    <span class="s5"># data</span>
    <span class="s2">if </span><span class="s1">_safe_tags</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">key</span><span class="s3">=</span><span class="s4">&quot;requires_positive_y&quot;</span><span class="s3">):</span>
        <span class="s5"># Create strictly positive y. The minimal increment above 0 is 1, as</span>
        <span class="s5"># y could be of integer dtype.</span>
        <span class="s1">y </span><span class="s3">+= </span><span class="s6">1 </span><span class="s3">+ </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">y</span><span class="s3">.</span><span class="s1">min</span><span class="s3">())</span>
    <span class="s2">if </span><span class="s1">_safe_tags</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">key</span><span class="s3">=</span><span class="s4">&quot;binary_only&quot;</span><span class="s3">) </span><span class="s2">and </span><span class="s1">y</span><span class="s3">.</span><span class="s1">size </span><span class="s3">&gt; </span><span class="s6">0</span><span class="s3">:</span>
        <span class="s1">y </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">where</span><span class="s3">(</span><span class="s1">y </span><span class="s3">== </span><span class="s1">y</span><span class="s3">.</span><span class="s1">flat</span><span class="s3">[</span><span class="s6">0</span><span class="s3">], </span><span class="s1">y</span><span class="s3">, </span><span class="s1">y</span><span class="s3">.</span><span class="s1">flat</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] + </span><span class="s6">1</span><span class="s3">)</span>
    <span class="s5"># Estimators in mono_output_task_error raise ValueError if y is of 1-D</span>
    <span class="s5"># Convert into a 2-D y for those estimators.</span>
    <span class="s2">if </span><span class="s1">_safe_tags</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">key</span><span class="s3">=</span><span class="s4">&quot;multioutput_only&quot;</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">(</span><span class="s1">y</span><span class="s3">, (-</span><span class="s6">1</span><span class="s3">, </span><span class="s6">1</span><span class="s3">))</span>
    <span class="s2">return </span><span class="s1">y</span>


<span class="s2">def </span><span class="s1">_enforce_estimator_tags_X</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">kernel</span><span class="s3">=</span><span class="s1">linear_kernel</span><span class="s3">):</span>
    <span class="s5"># Estimators with `1darray` in `X_types` tag only accept</span>
    <span class="s5"># X of shape (`n_samples`,)</span>
    <span class="s2">if </span><span class="s4">&quot;1darray&quot; </span><span class="s2">in </span><span class="s1">_safe_tags</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">key</span><span class="s3">=</span><span class="s4">&quot;X_types&quot;</span><span class="s3">):</span>
        <span class="s1">X </span><span class="s3">= </span><span class="s1">X</span><span class="s3">[:, </span><span class="s6">0</span><span class="s3">]</span>
    <span class="s5"># Estimators with a `requires_positive_X` tag only accept</span>
    <span class="s5"># strictly positive data</span>
    <span class="s2">if </span><span class="s1">_safe_tags</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">key</span><span class="s3">=</span><span class="s4">&quot;requires_positive_X&quot;</span><span class="s3">):</span>
        <span class="s1">X </span><span class="s3">= </span><span class="s1">X </span><span class="s3">- </span><span class="s1">X</span><span class="s3">.</span><span class="s1">min</span><span class="s3">()</span>
    <span class="s2">if </span><span class="s4">&quot;categorical&quot; </span><span class="s2">in </span><span class="s1">_safe_tags</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">key</span><span class="s3">=</span><span class="s4">&quot;X_types&quot;</span><span class="s3">):</span>
        <span class="s1">dtype </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64 </span><span class="s2">if </span><span class="s1">_safe_tags</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">key</span><span class="s3">=</span><span class="s4">&quot;allow_nan&quot;</span><span class="s3">) </span><span class="s2">else </span><span class="s1">np</span><span class="s3">.</span><span class="s1">int32</span>
        <span class="s1">X </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">round</span><span class="s3">((</span><span class="s1">X </span><span class="s3">- </span><span class="s1">X</span><span class="s3">.</span><span class="s1">min</span><span class="s3">())).</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">estimator</span><span class="s3">.</span><span class="s1">__class__</span><span class="s3">.</span><span class="s1">__name__ </span><span class="s3">== </span><span class="s4">&quot;SkewedChi2Sampler&quot;</span><span class="s3">:</span>
        <span class="s5"># SkewedChi2Sampler requires X &gt; -skewdness in transform</span>
        <span class="s1">X </span><span class="s3">= </span><span class="s1">X </span><span class="s3">- </span><span class="s1">X</span><span class="s3">.</span><span class="s1">min</span><span class="s3">()</span>

    <span class="s5"># Pairwise estimators only accept</span>
    <span class="s5"># X of shape (`n_samples`, `n_samples`)</span>
    <span class="s2">if </span><span class="s1">_is_pairwise_metric</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">):</span>
        <span class="s1">X </span><span class="s3">= </span><span class="s1">pairwise_distances</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">metric</span><span class="s3">=</span><span class="s4">&quot;euclidean&quot;</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">_safe_tags</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">key</span><span class="s3">=</span><span class="s4">&quot;pairwise&quot;</span><span class="s3">):</span>
        <span class="s1">X </span><span class="s3">= </span><span class="s1">kernel</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">X</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">X</span>


<span class="s3">@</span><span class="s1">ignore_warnings</span><span class="s3">(</span><span class="s1">category</span><span class="s3">=</span><span class="s1">FutureWarning</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">check_non_transformer_estimators_n_iter</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">estimator_orig</span><span class="s3">):</span>
    <span class="s5"># Test that estimators that are not transformers with a parameter</span>
    <span class="s5"># max_iter, return the attribute of n_iter_ at least 1.</span>

    <span class="s5"># These models are dependent on external solvers like</span>
    <span class="s5"># libsvm and accessing the iter parameter is non-trivial.</span>
    <span class="s5"># SelfTrainingClassifier does not perform an iteration if all samples are</span>
    <span class="s5"># labeled, hence n_iter_ = 0 is valid.</span>
    <span class="s1">not_run_check_n_iter </span><span class="s3">= [</span>
        <span class="s4">&quot;Ridge&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;RidgeClassifier&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;RandomizedLasso&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;LogisticRegressionCV&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;LinearSVC&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;LogisticRegression&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;SelfTrainingClassifier&quot;</span><span class="s3">,</span>
    <span class="s3">]</span>

    <span class="s5"># Tested in test_transformer_n_iter</span>
    <span class="s1">not_run_check_n_iter </span><span class="s3">+= </span><span class="s1">CROSS_DECOMPOSITION</span>
    <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">not_run_check_n_iter</span><span class="s3">:</span>
        <span class="s2">return</span>

    <span class="s5"># LassoLars stops early for the default alpha=1.0 the iris dataset.</span>
    <span class="s2">if </span><span class="s1">name </span><span class="s3">== </span><span class="s4">&quot;LassoLars&quot;</span><span class="s3">:</span>
        <span class="s1">estimator </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">).</span><span class="s1">set_params</span><span class="s3">(</span><span class="s1">alpha</span><span class="s3">=</span><span class="s6">0.0</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">estimator </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s4">&quot;max_iter&quot;</span><span class="s3">):</span>
        <span class="s1">iris </span><span class="s3">= </span><span class="s1">load_iris</span><span class="s3">()</span>
        <span class="s1">X</span><span class="s3">, </span><span class="s1">y_ </span><span class="s3">= </span><span class="s1">iris</span><span class="s3">.</span><span class="s1">data</span><span class="s3">, </span><span class="s1">iris</span><span class="s3">.</span><span class="s1">target</span>
        <span class="s1">y_ </span><span class="s3">= </span><span class="s1">_enforce_estimator_tags_y</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">y_</span><span class="s3">)</span>

        <span class="s1">set_random_state</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s6">0</span><span class="s3">)</span>

        <span class="s1">X </span><span class="s3">= </span><span class="s1">_enforce_estimator_tags_X</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">, </span><span class="s1">X</span><span class="s3">)</span>

        <span class="s1">estimator</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y_</span><span class="s3">)</span>

        <span class="s2">assert </span><span class="s1">np</span><span class="s3">.</span><span class="s1">all</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">.</span><span class="s1">n_iter_ </span><span class="s3">&gt;= </span><span class="s6">1</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">ignore_warnings</span><span class="s3">(</span><span class="s1">category</span><span class="s3">=</span><span class="s1">FutureWarning</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">check_transformer_n_iter</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">estimator_orig</span><span class="s3">):</span>
    <span class="s5"># Test that transformers with a parameter max_iter, return the</span>
    <span class="s5"># attribute of n_iter_ at least 1.</span>
    <span class="s1">estimator </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s4">&quot;max_iter&quot;</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">CROSS_DECOMPOSITION</span><span class="s3">:</span>
            <span class="s5"># Check using default data</span>
            <span class="s1">X </span><span class="s3">= [[</span><span class="s6">0.0</span><span class="s3">, </span><span class="s6">0.0</span><span class="s3">, </span><span class="s6">1.0</span><span class="s3">], [</span><span class="s6">1.0</span><span class="s3">, </span><span class="s6">0.0</span><span class="s3">, </span><span class="s6">0.0</span><span class="s3">], [</span><span class="s6">2.0</span><span class="s3">, </span><span class="s6">2.0</span><span class="s3">, </span><span class="s6">2.0</span><span class="s3">], [</span><span class="s6">2.0</span><span class="s3">, </span><span class="s6">5.0</span><span class="s3">, </span><span class="s6">4.0</span><span class="s3">]]</span>
            <span class="s1">y_ </span><span class="s3">= [[</span><span class="s6">0.1</span><span class="s3">, -</span><span class="s6">0.2</span><span class="s3">], [</span><span class="s6">0.9</span><span class="s3">, </span><span class="s6">1.1</span><span class="s3">], [</span><span class="s6">0.1</span><span class="s3">, -</span><span class="s6">0.5</span><span class="s3">], [</span><span class="s6">0.3</span><span class="s3">, -</span><span class="s6">0.2</span><span class="s3">]]</span>

        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">X</span><span class="s3">, </span><span class="s1">y_ </span><span class="s3">= </span><span class="s1">make_blobs</span><span class="s3">(</span>
                <span class="s1">n_samples</span><span class="s3">=</span><span class="s6">30</span><span class="s3">,</span>
                <span class="s1">centers</span><span class="s3">=[[</span><span class="s6">0</span><span class="s3">, </span><span class="s6">0</span><span class="s3">, </span><span class="s6">0</span><span class="s3">], [</span><span class="s6">1</span><span class="s3">, </span><span class="s6">1</span><span class="s3">, </span><span class="s6">1</span><span class="s3">]],</span>
                <span class="s1">random_state</span><span class="s3">=</span><span class="s6">0</span><span class="s3">,</span>
                <span class="s1">n_features</span><span class="s3">=</span><span class="s6">2</span><span class="s3">,</span>
                <span class="s1">cluster_std</span><span class="s3">=</span><span class="s6">0.1</span><span class="s3">,</span>
            <span class="s3">)</span>
            <span class="s1">X </span><span class="s3">= </span><span class="s1">_enforce_estimator_tags_X</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">, </span><span class="s1">X</span><span class="s3">)</span>
        <span class="s1">set_random_state</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s6">0</span><span class="s3">)</span>
        <span class="s1">estimator</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y_</span><span class="s3">)</span>

        <span class="s5"># These return a n_iter per component.</span>
        <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">CROSS_DECOMPOSITION</span><span class="s3">:</span>
            <span class="s2">for </span><span class="s1">iter_ </span><span class="s2">in </span><span class="s1">estimator</span><span class="s3">.</span><span class="s1">n_iter_</span><span class="s3">:</span>
                <span class="s2">assert </span><span class="s1">iter_ </span><span class="s3">&gt;= </span><span class="s6">1</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">assert </span><span class="s1">estimator</span><span class="s3">.</span><span class="s1">n_iter_ </span><span class="s3">&gt;= </span><span class="s6">1</span>


<span class="s3">@</span><span class="s1">ignore_warnings</span><span class="s3">(</span><span class="s1">category</span><span class="s3">=</span><span class="s1">FutureWarning</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">check_get_params_invariance</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">estimator_orig</span><span class="s3">):</span>
    <span class="s5"># Checks if get_params(deep=False) is a subset of get_params(deep=True)</span>
    <span class="s1">e </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">)</span>

    <span class="s1">shallow_params </span><span class="s3">= </span><span class="s1">e</span><span class="s3">.</span><span class="s1">get_params</span><span class="s3">(</span><span class="s1">deep</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
    <span class="s1">deep_params </span><span class="s3">= </span><span class="s1">e</span><span class="s3">.</span><span class="s1">get_params</span><span class="s3">(</span><span class="s1">deep</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

    <span class="s2">assert </span><span class="s1">all</span><span class="s3">(</span><span class="s1">item </span><span class="s2">in </span><span class="s1">deep_params</span><span class="s3">.</span><span class="s1">items</span><span class="s3">() </span><span class="s2">for </span><span class="s1">item </span><span class="s2">in </span><span class="s1">shallow_params</span><span class="s3">.</span><span class="s1">items</span><span class="s3">())</span>


<span class="s3">@</span><span class="s1">ignore_warnings</span><span class="s3">(</span><span class="s1">category</span><span class="s3">=</span><span class="s1">FutureWarning</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">check_set_params</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">estimator_orig</span><span class="s3">):</span>
    <span class="s5"># Check that get_params() returns the same thing</span>
    <span class="s5"># before and after set_params() with some fuzz</span>
    <span class="s1">estimator </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">)</span>

    <span class="s1">orig_params </span><span class="s3">= </span><span class="s1">estimator</span><span class="s3">.</span><span class="s1">get_params</span><span class="s3">(</span><span class="s1">deep</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
    <span class="s1">msg </span><span class="s3">= </span><span class="s4">&quot;get_params result does not match what was passed to set_params&quot;</span>

    <span class="s1">estimator</span><span class="s3">.</span><span class="s1">set_params</span><span class="s3">(**</span><span class="s1">orig_params</span><span class="s3">)</span>
    <span class="s1">curr_params </span><span class="s3">= </span><span class="s1">estimator</span><span class="s3">.</span><span class="s1">get_params</span><span class="s3">(</span><span class="s1">deep</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
    <span class="s2">assert </span><span class="s1">set</span><span class="s3">(</span><span class="s1">orig_params</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">()) == </span><span class="s1">set</span><span class="s3">(</span><span class="s1">curr_params</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">()), </span><span class="s1">msg</span>
    <span class="s2">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">curr_params</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
        <span class="s2">assert </span><span class="s1">orig_params</span><span class="s3">[</span><span class="s1">k</span><span class="s3">] </span><span class="s2">is </span><span class="s1">v</span><span class="s3">, </span><span class="s1">msg</span>

    <span class="s5"># some fuzz values</span>
    <span class="s1">test_values </span><span class="s3">= [-</span><span class="s1">np</span><span class="s3">.</span><span class="s1">inf</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">inf</span><span class="s3">, </span><span class="s2">None</span><span class="s3">]</span>

    <span class="s1">test_params </span><span class="s3">= </span><span class="s1">deepcopy</span><span class="s3">(</span><span class="s1">orig_params</span><span class="s3">)</span>
    <span class="s2">for </span><span class="s1">param_name </span><span class="s2">in </span><span class="s1">orig_params</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">():</span>
        <span class="s1">default_value </span><span class="s3">= </span><span class="s1">orig_params</span><span class="s3">[</span><span class="s1">param_name</span><span class="s3">]</span>
        <span class="s2">for </span><span class="s1">value </span><span class="s2">in </span><span class="s1">test_values</span><span class="s3">:</span>
            <span class="s1">test_params</span><span class="s3">[</span><span class="s1">param_name</span><span class="s3">] = </span><span class="s1">value</span>
            <span class="s2">try</span><span class="s3">:</span>
                <span class="s1">estimator</span><span class="s3">.</span><span class="s1">set_params</span><span class="s3">(**</span><span class="s1">test_params</span><span class="s3">)</span>
            <span class="s2">except </span><span class="s3">(</span><span class="s1">TypeError</span><span class="s3">, </span><span class="s1">ValueError</span><span class="s3">) </span><span class="s2">as </span><span class="s1">e</span><span class="s3">:</span>
                <span class="s1">e_type </span><span class="s3">= </span><span class="s1">e</span><span class="s3">.</span><span class="s1">__class__</span><span class="s3">.</span><span class="s1">__name__</span>
                <span class="s5"># Exception occurred, possibly parameter validation</span>
                <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span>
                    <span class="s4">&quot;{0} occurred during set_params of param {1} on &quot;</span>
                    <span class="s4">&quot;{2}. It is recommended to delay parameter &quot;</span>
                    <span class="s4">&quot;validation until fit.&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">e_type</span><span class="s3">, </span><span class="s1">param_name</span><span class="s3">, </span><span class="s1">name</span><span class="s3">)</span>
                <span class="s3">)</span>

                <span class="s1">change_warning_msg </span><span class="s3">= (</span>
                    <span class="s4">&quot;Estimator's parameters changed after set_params raised {}&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span>
                        <span class="s1">e_type</span>
                    <span class="s3">)</span>
                <span class="s3">)</span>
                <span class="s1">params_before_exception </span><span class="s3">= </span><span class="s1">curr_params</span>
                <span class="s1">curr_params </span><span class="s3">= </span><span class="s1">estimator</span><span class="s3">.</span><span class="s1">get_params</span><span class="s3">(</span><span class="s1">deep</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
                <span class="s2">try</span><span class="s3">:</span>
                    <span class="s2">assert </span><span class="s1">set</span><span class="s3">(</span><span class="s1">params_before_exception</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">()) == </span><span class="s1">set</span><span class="s3">(</span>
                        <span class="s1">curr_params</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">()</span>
                    <span class="s3">)</span>
                    <span class="s2">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">curr_params</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
                        <span class="s2">assert </span><span class="s1">params_before_exception</span><span class="s3">[</span><span class="s1">k</span><span class="s3">] </span><span class="s2">is </span><span class="s1">v</span>
                <span class="s2">except </span><span class="s1">AssertionError</span><span class="s3">:</span>
                    <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span><span class="s1">change_warning_msg</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">curr_params </span><span class="s3">= </span><span class="s1">estimator</span><span class="s3">.</span><span class="s1">get_params</span><span class="s3">(</span><span class="s1">deep</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
                <span class="s2">assert </span><span class="s1">set</span><span class="s3">(</span><span class="s1">test_params</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">()) == </span><span class="s1">set</span><span class="s3">(</span><span class="s1">curr_params</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">()), </span><span class="s1">msg</span>
                <span class="s2">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">curr_params</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
                    <span class="s2">assert </span><span class="s1">test_params</span><span class="s3">[</span><span class="s1">k</span><span class="s3">] </span><span class="s2">is </span><span class="s1">v</span><span class="s3">, </span><span class="s1">msg</span>
        <span class="s1">test_params</span><span class="s3">[</span><span class="s1">param_name</span><span class="s3">] = </span><span class="s1">default_value</span>


<span class="s3">@</span><span class="s1">ignore_warnings</span><span class="s3">(</span><span class="s1">category</span><span class="s3">=</span><span class="s1">FutureWarning</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">check_classifiers_regression_target</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">estimator_orig</span><span class="s3">):</span>
    <span class="s5"># Check if classifier throws an exception when fed regression targets</span>

    <span class="s1">X</span><span class="s3">, </span><span class="s1">y </span><span class="s3">= </span><span class="s1">_regression_dataset</span><span class="s3">()</span>

    <span class="s1">X </span><span class="s3">= </span><span class="s1">_enforce_estimator_tags_X</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">, </span><span class="s1">X</span><span class="s3">)</span>
    <span class="s1">e </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">)</span>
    <span class="s1">msg </span><span class="s3">= </span><span class="s4">&quot;Unknown label type: &quot;</span>
    <span class="s2">if not </span><span class="s1">_safe_tags</span><span class="s3">(</span><span class="s1">e</span><span class="s3">, </span><span class="s1">key</span><span class="s3">=</span><span class="s4">&quot;no_validation&quot;</span><span class="s3">):</span>
        <span class="s2">with </span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s1">msg</span><span class="s3">):</span>
            <span class="s1">e</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">ignore_warnings</span><span class="s3">(</span><span class="s1">category</span><span class="s3">=</span><span class="s1">FutureWarning</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">check_decision_proba_consistency</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">estimator_orig</span><span class="s3">):</span>
    <span class="s5"># Check whether an estimator having both decision_function and</span>
    <span class="s5"># predict_proba methods has outputs with perfect rank correlation.</span>

    <span class="s1">centers </span><span class="s3">= [(</span><span class="s6">2</span><span class="s3">, </span><span class="s6">2</span><span class="s3">), (</span><span class="s6">4</span><span class="s3">, </span><span class="s6">4</span><span class="s3">)]</span>
    <span class="s1">X</span><span class="s3">, </span><span class="s1">y </span><span class="s3">= </span><span class="s1">make_blobs</span><span class="s3">(</span>
        <span class="s1">n_samples</span><span class="s3">=</span><span class="s6">100</span><span class="s3">,</span>
        <span class="s1">random_state</span><span class="s3">=</span><span class="s6">0</span><span class="s3">,</span>
        <span class="s1">n_features</span><span class="s3">=</span><span class="s6">4</span><span class="s3">,</span>
        <span class="s1">centers</span><span class="s3">=</span><span class="s1">centers</span><span class="s3">,</span>
        <span class="s1">cluster_std</span><span class="s3">=</span><span class="s6">1.0</span><span class="s3">,</span>
        <span class="s1">shuffle</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
    <span class="s3">)</span>
    <span class="s1">X_train</span><span class="s3">, </span><span class="s1">X_test</span><span class="s3">, </span><span class="s1">y_train</span><span class="s3">, </span><span class="s1">y_test </span><span class="s3">= </span><span class="s1">train_test_split</span><span class="s3">(</span>
        <span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">test_size</span><span class="s3">=</span><span class="s6">0.2</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s6">0</span>
    <span class="s3">)</span>
    <span class="s1">estimator </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s4">&quot;decision_function&quot;</span><span class="s3">) </span><span class="s2">and </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s4">&quot;predict_proba&quot;</span><span class="s3">):</span>
        <span class="s1">estimator</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X_train</span><span class="s3">, </span><span class="s1">y_train</span><span class="s3">)</span>
        <span class="s5"># Since the link function from decision_function() to predict_proba()</span>
        <span class="s5"># is sometimes not precise enough (typically expit), we round to the</span>
        <span class="s5"># 10th decimal to avoid numerical issues: we compare the rank</span>
        <span class="s5"># with deterministic ties rather than get platform specific rank</span>
        <span class="s5"># inversions in case of machine level differences.</span>
        <span class="s1">a </span><span class="s3">= </span><span class="s1">estimator</span><span class="s3">.</span><span class="s1">predict_proba</span><span class="s3">(</span><span class="s1">X_test</span><span class="s3">)[:, </span><span class="s6">1</span><span class="s3">].</span><span class="s1">round</span><span class="s3">(</span><span class="s1">decimals</span><span class="s3">=</span><span class="s6">10</span><span class="s3">)</span>
        <span class="s1">b </span><span class="s3">= </span><span class="s1">estimator</span><span class="s3">.</span><span class="s1">decision_function</span><span class="s3">(</span><span class="s1">X_test</span><span class="s3">).</span><span class="s1">round</span><span class="s3">(</span><span class="s1">decimals</span><span class="s3">=</span><span class="s6">10</span><span class="s3">)</span>

        <span class="s1">rank_proba</span><span class="s3">, </span><span class="s1">rank_score </span><span class="s3">= </span><span class="s1">rankdata</span><span class="s3">(</span><span class="s1">a</span><span class="s3">), </span><span class="s1">rankdata</span><span class="s3">(</span><span class="s1">b</span><span class="s3">)</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s1">assert_array_almost_equal</span><span class="s3">(</span><span class="s1">rank_proba</span><span class="s3">, </span><span class="s1">rank_score</span><span class="s3">)</span>
        <span class="s2">except </span><span class="s1">AssertionError</span><span class="s3">:</span>
            <span class="s5"># Sometimes, the rounding applied on the probabilities will have</span>
            <span class="s5"># ties that are not present in the scores because it is</span>
            <span class="s5"># numerically more precise. In this case, we relax the test by</span>
            <span class="s5"># grouping the decision function scores based on the probability</span>
            <span class="s5"># rank and check that the score is monotonically increasing.</span>
            <span class="s1">grouped_y_score </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span>
                <span class="s3">[</span><span class="s1">b</span><span class="s3">[</span><span class="s1">rank_proba </span><span class="s3">== </span><span class="s1">group</span><span class="s3">].</span><span class="s1">mean</span><span class="s3">() </span><span class="s2">for </span><span class="s1">group </span><span class="s2">in </span><span class="s1">np</span><span class="s3">.</span><span class="s1">unique</span><span class="s3">(</span><span class="s1">rank_proba</span><span class="s3">)]</span>
            <span class="s3">)</span>
            <span class="s1">sorted_idx </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">argsort</span><span class="s3">(</span><span class="s1">grouped_y_score</span><span class="s3">)</span>
            <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">sorted_idx</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">sorted_idx</span><span class="s3">)))</span>


<span class="s2">def </span><span class="s1">check_outliers_fit_predict</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">estimator_orig</span><span class="s3">):</span>
    <span class="s5"># Check fit_predict for outlier detectors.</span>

    <span class="s1">n_samples </span><span class="s3">= </span><span class="s6">300</span>
    <span class="s1">X</span><span class="s3">, </span><span class="s1">_ </span><span class="s3">= </span><span class="s1">make_blobs</span><span class="s3">(</span><span class="s1">n_samples</span><span class="s3">=</span><span class="s1">n_samples</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s6">0</span><span class="s3">)</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">shuffle</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s6">7</span><span class="s3">)</span>
    <span class="s1">n_samples</span><span class="s3">, </span><span class="s1">n_features </span><span class="s3">= </span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span>
    <span class="s1">estimator </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">)</span>

    <span class="s1">set_random_state</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">)</span>

    <span class="s1">y_pred </span><span class="s3">= </span><span class="s1">estimator</span><span class="s3">.</span><span class="s1">fit_predict</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
    <span class="s2">assert </span><span class="s1">y_pred</span><span class="s3">.</span><span class="s1">shape </span><span class="s3">== (</span><span class="s1">n_samples</span><span class="s3">,)</span>
    <span class="s2">assert </span><span class="s1">y_pred</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">kind </span><span class="s3">== </span><span class="s4">&quot;i&quot;</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">unique</span><span class="s3">(</span><span class="s1">y_pred</span><span class="s3">), </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([-</span><span class="s6">1</span><span class="s3">, </span><span class="s6">1</span><span class="s3">]))</span>

    <span class="s5"># check fit_predict = fit.predict when the estimator has both a predict and</span>
    <span class="s5"># a fit_predict method. recall that it is already assumed here that the</span>
    <span class="s5"># estimator has a fit_predict method</span>
    <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s4">&quot;predict&quot;</span><span class="s3">):</span>
        <span class="s1">y_pred_2 </span><span class="s3">= </span><span class="s1">estimator</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">).</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
        <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">y_pred</span><span class="s3">, </span><span class="s1">y_pred_2</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s4">&quot;contamination&quot;</span><span class="s3">):</span>
        <span class="s5"># proportion of outliers equal to contamination parameter when not</span>
        <span class="s5"># set to 'auto'</span>
        <span class="s1">expected_outliers </span><span class="s3">= </span><span class="s6">30</span>
        <span class="s1">contamination </span><span class="s3">= </span><span class="s1">float</span><span class="s3">(</span><span class="s1">expected_outliers</span><span class="s3">) / </span><span class="s1">n_samples</span>
        <span class="s1">estimator</span><span class="s3">.</span><span class="s1">set_params</span><span class="s3">(</span><span class="s1">contamination</span><span class="s3">=</span><span class="s1">contamination</span><span class="s3">)</span>
        <span class="s1">y_pred </span><span class="s3">= </span><span class="s1">estimator</span><span class="s3">.</span><span class="s1">fit_predict</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>

        <span class="s1">num_outliers </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">(</span><span class="s1">y_pred </span><span class="s3">!= </span><span class="s6">1</span><span class="s3">)</span>
        <span class="s5"># num_outliers should be equal to expected_outliers unless</span>
        <span class="s5"># there are ties in the decision_function values. this can</span>
        <span class="s5"># only be tested for estimators with a decision_function</span>
        <span class="s5"># method</span>
        <span class="s2">if </span><span class="s1">num_outliers </span><span class="s3">!= </span><span class="s1">expected_outliers </span><span class="s2">and </span><span class="s1">hasattr</span><span class="s3">(</span>
            <span class="s1">estimator</span><span class="s3">, </span><span class="s4">&quot;decision_function&quot;</span>
        <span class="s3">):</span>
            <span class="s1">decision </span><span class="s3">= </span><span class="s1">estimator</span><span class="s3">.</span><span class="s1">decision_function</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
            <span class="s1">check_outlier_corruption</span><span class="s3">(</span><span class="s1">num_outliers</span><span class="s3">, </span><span class="s1">expected_outliers</span><span class="s3">, </span><span class="s1">decision</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">check_fit_non_negative</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">estimator_orig</span><span class="s3">):</span>
    <span class="s5"># Check that proper warning is raised for non-negative X</span>
    <span class="s5"># when tag requires_positive_X is present</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([[-</span><span class="s6">1.0</span><span class="s3">, </span><span class="s6">1</span><span class="s3">], [-</span><span class="s6">1.0</span><span class="s3">, </span><span class="s6">1</span><span class="s3">]])</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s6">1</span><span class="s3">, </span><span class="s6">2</span><span class="s3">])</span>
    <span class="s1">estimator </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">)</span>
    <span class="s2">with </span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">):</span>
        <span class="s1">estimator</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">check_fit_idempotent</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">estimator_orig</span><span class="s3">):</span>
    <span class="s5"># Check that est.fit(X) is the same as est.fit(X).fit(X). Ideally we would</span>
    <span class="s5"># check that the estimated parameters during training (e.g. coefs_) are</span>
    <span class="s5"># the same, but having a universal comparison function for those</span>
    <span class="s5"># attributes is difficult and full of edge cases. So instead we check that</span>
    <span class="s5"># predict(), predict_proba(), decision_function() and transform() return</span>
    <span class="s5"># the same results.</span>

    <span class="s1">check_methods </span><span class="s3">= [</span><span class="s4">&quot;predict&quot;</span><span class="s3">, </span><span class="s4">&quot;transform&quot;</span><span class="s3">, </span><span class="s4">&quot;decision_function&quot;</span><span class="s3">, </span><span class="s4">&quot;predict_proba&quot;</span><span class="s3">]</span>
    <span class="s1">rng </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">RandomState</span><span class="s3">(</span><span class="s6">0</span><span class="s3">)</span>

    <span class="s1">estimator </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">)</span>
    <span class="s1">set_random_state</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s4">&quot;warm_start&quot; </span><span class="s2">in </span><span class="s1">estimator</span><span class="s3">.</span><span class="s1">get_params</span><span class="s3">().</span><span class="s1">keys</span><span class="s3">():</span>
        <span class="s1">estimator</span><span class="s3">.</span><span class="s1">set_params</span><span class="s3">(</span><span class="s1">warm_start</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>

    <span class="s1">n_samples </span><span class="s3">= </span><span class="s6">100</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">rng</span><span class="s3">.</span><span class="s1">normal</span><span class="s3">(</span><span class="s1">loc</span><span class="s3">=</span><span class="s6">100</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=(</span><span class="s1">n_samples</span><span class="s3">, </span><span class="s6">2</span><span class="s3">))</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">_enforce_estimator_tags_X</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">X</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">is_regressor</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">):</span>
        <span class="s1">y </span><span class="s3">= </span><span class="s1">rng</span><span class="s3">.</span><span class="s1">normal</span><span class="s3">(</span><span class="s1">size</span><span class="s3">=</span><span class="s1">n_samples</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">y </span><span class="s3">= </span><span class="s1">rng</span><span class="s3">.</span><span class="s1">randint</span><span class="s3">(</span><span class="s1">low</span><span class="s3">=</span><span class="s6">0</span><span class="s3">, </span><span class="s1">high</span><span class="s3">=</span><span class="s6">2</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=</span><span class="s1">n_samples</span><span class="s3">)</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">_enforce_estimator_tags_y</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>

    <span class="s1">train</span><span class="s3">, </span><span class="s1">test </span><span class="s3">= </span><span class="s1">next</span><span class="s3">(</span><span class="s1">ShuffleSplit</span><span class="s3">(</span><span class="s1">test_size</span><span class="s3">=</span><span class="s6">0.2</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s1">rng</span><span class="s3">).</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">))</span>
    <span class="s1">X_train</span><span class="s3">, </span><span class="s1">y_train </span><span class="s3">= </span><span class="s1">_safe_split</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">train</span><span class="s3">)</span>
    <span class="s1">X_test</span><span class="s3">, </span><span class="s1">y_test </span><span class="s3">= </span><span class="s1">_safe_split</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">test</span><span class="s3">, </span><span class="s1">train</span><span class="s3">)</span>

    <span class="s5"># Fit for the first time</span>
    <span class="s1">estimator</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X_train</span><span class="s3">, </span><span class="s1">y_train</span><span class="s3">)</span>

    <span class="s1">result </span><span class="s3">= {</span>
        <span class="s1">method</span><span class="s3">: </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">method</span><span class="s3">)(</span><span class="s1">X_test</span><span class="s3">)</span>
        <span class="s2">for </span><span class="s1">method </span><span class="s2">in </span><span class="s1">check_methods</span>
        <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">method</span><span class="s3">)</span>
    <span class="s3">}</span>

    <span class="s5"># Fit again</span>
    <span class="s1">set_random_state</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">)</span>
    <span class="s1">estimator</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X_train</span><span class="s3">, </span><span class="s1">y_train</span><span class="s3">)</span>

    <span class="s2">for </span><span class="s1">method </span><span class="s2">in </span><span class="s1">check_methods</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">method</span><span class="s3">):</span>
            <span class="s1">new_result </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">method</span><span class="s3">)(</span><span class="s1">X_test</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">issubdtype</span><span class="s3">(</span><span class="s1">new_result</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">floating</span><span class="s3">):</span>
                <span class="s1">tol </span><span class="s3">= </span><span class="s6">2 </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">finfo</span><span class="s3">(</span><span class="s1">new_result</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">).</span><span class="s1">eps</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">tol </span><span class="s3">= </span><span class="s6">2 </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">finfo</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">).</span><span class="s1">eps</span>
            <span class="s1">assert_allclose_dense_sparse</span><span class="s3">(</span>
                <span class="s1">result</span><span class="s3">[</span><span class="s1">method</span><span class="s3">],</span>
                <span class="s1">new_result</span><span class="s3">,</span>
                <span class="s1">atol</span><span class="s3">=</span><span class="s1">max</span><span class="s3">(</span><span class="s1">tol</span><span class="s3">, </span><span class="s6">1e-9</span><span class="s3">),</span>
                <span class="s1">rtol</span><span class="s3">=</span><span class="s1">max</span><span class="s3">(</span><span class="s1">tol</span><span class="s3">, </span><span class="s6">1e-7</span><span class="s3">),</span>
                <span class="s1">err_msg</span><span class="s3">=</span><span class="s4">&quot;Idempotency check failed for method {}&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">method</span><span class="s3">),</span>
            <span class="s3">)</span>


<span class="s2">def </span><span class="s1">check_fit_check_is_fitted</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">estimator_orig</span><span class="s3">):</span>
    <span class="s5"># Make sure that estimator doesn't pass check_is_fitted before calling fit</span>
    <span class="s5"># and that passes check_is_fitted once it's fit.</span>

    <span class="s1">rng </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">RandomState</span><span class="s3">(</span><span class="s6">42</span><span class="s3">)</span>

    <span class="s1">estimator </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">)</span>
    <span class="s1">set_random_state</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s4">&quot;warm_start&quot; </span><span class="s2">in </span><span class="s1">estimator</span><span class="s3">.</span><span class="s1">get_params</span><span class="s3">():</span>
        <span class="s1">estimator</span><span class="s3">.</span><span class="s1">set_params</span><span class="s3">(</span><span class="s1">warm_start</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>

    <span class="s1">n_samples </span><span class="s3">= </span><span class="s6">100</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">rng</span><span class="s3">.</span><span class="s1">normal</span><span class="s3">(</span><span class="s1">loc</span><span class="s3">=</span><span class="s6">100</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=(</span><span class="s1">n_samples</span><span class="s3">, </span><span class="s6">2</span><span class="s3">))</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">_enforce_estimator_tags_X</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">X</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">is_regressor</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">):</span>
        <span class="s1">y </span><span class="s3">= </span><span class="s1">rng</span><span class="s3">.</span><span class="s1">normal</span><span class="s3">(</span><span class="s1">size</span><span class="s3">=</span><span class="s1">n_samples</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">y </span><span class="s3">= </span><span class="s1">rng</span><span class="s3">.</span><span class="s1">randint</span><span class="s3">(</span><span class="s1">low</span><span class="s3">=</span><span class="s6">0</span><span class="s3">, </span><span class="s1">high</span><span class="s3">=</span><span class="s6">2</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=</span><span class="s1">n_samples</span><span class="s3">)</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">_enforce_estimator_tags_y</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>

    <span class="s2">if not </span><span class="s1">_safe_tags</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">).</span><span class="s1">get</span><span class="s3">(</span><span class="s4">&quot;stateless&quot;</span><span class="s3">, </span><span class="s2">False</span><span class="s3">):</span>
        <span class="s5"># stateless estimators (such as FunctionTransformer) are always &quot;fit&quot;!</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s1">check_is_fitted</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">)</span>
            <span class="s2">raise </span><span class="s1">AssertionError</span><span class="s3">(</span>
                <span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">estimator</span><span class="s3">.</span><span class="s1">__class__</span><span class="s3">.</span><span class="s1">__name__</span><span class="s2">} </span><span class="s4">passes check_is_fitted before being&quot;</span>
                <span class="s4">&quot; fit!&quot;</span>
            <span class="s3">)</span>
        <span class="s2">except </span><span class="s1">NotFittedError</span><span class="s3">:</span>
            <span class="s2">pass</span>
    <span class="s1">estimator</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
    <span class="s2">try</span><span class="s3">:</span>
        <span class="s1">check_is_fitted</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">)</span>
    <span class="s2">except </span><span class="s1">NotFittedError </span><span class="s2">as </span><span class="s1">e</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">NotFittedError</span><span class="s3">(</span>
            <span class="s4">&quot;Estimator fails to pass `check_is_fitted` even though it has been fit.&quot;</span>
        <span class="s3">) </span><span class="s2">from </span><span class="s1">e</span>


<span class="s2">def </span><span class="s1">check_n_features_in</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">estimator_orig</span><span class="s3">):</span>
    <span class="s5"># Make sure that n_features_in_ attribute doesn't exist until fit is</span>
    <span class="s5"># called, and that its value is correct.</span>

    <span class="s1">rng </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">RandomState</span><span class="s3">(</span><span class="s6">0</span><span class="s3">)</span>

    <span class="s1">estimator </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">)</span>
    <span class="s1">set_random_state</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s4">&quot;warm_start&quot; </span><span class="s2">in </span><span class="s1">estimator</span><span class="s3">.</span><span class="s1">get_params</span><span class="s3">():</span>
        <span class="s1">estimator</span><span class="s3">.</span><span class="s1">set_params</span><span class="s3">(</span><span class="s1">warm_start</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>

    <span class="s1">n_samples </span><span class="s3">= </span><span class="s6">100</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">rng</span><span class="s3">.</span><span class="s1">normal</span><span class="s3">(</span><span class="s1">loc</span><span class="s3">=</span><span class="s6">100</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=(</span><span class="s1">n_samples</span><span class="s3">, </span><span class="s6">2</span><span class="s3">))</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">_enforce_estimator_tags_X</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">X</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">is_regressor</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">):</span>
        <span class="s1">y </span><span class="s3">= </span><span class="s1">rng</span><span class="s3">.</span><span class="s1">normal</span><span class="s3">(</span><span class="s1">size</span><span class="s3">=</span><span class="s1">n_samples</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">y </span><span class="s3">= </span><span class="s1">rng</span><span class="s3">.</span><span class="s1">randint</span><span class="s3">(</span><span class="s1">low</span><span class="s3">=</span><span class="s6">0</span><span class="s3">, </span><span class="s1">high</span><span class="s3">=</span><span class="s6">2</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=</span><span class="s1">n_samples</span><span class="s3">)</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">_enforce_estimator_tags_y</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>

    <span class="s2">assert not </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s4">&quot;n_features_in_&quot;</span><span class="s3">)</span>
    <span class="s1">estimator</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
    <span class="s2">assert </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s4">&quot;n_features_in_&quot;</span><span class="s3">)</span>
    <span class="s2">assert </span><span class="s1">estimator</span><span class="s3">.</span><span class="s1">n_features_in_ </span><span class="s3">== </span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]</span>


<span class="s2">def </span><span class="s1">check_requires_y_none</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">estimator_orig</span><span class="s3">):</span>
    <span class="s5"># Make sure that an estimator with requires_y=True fails gracefully when</span>
    <span class="s5"># given y=None</span>

    <span class="s1">rng </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">RandomState</span><span class="s3">(</span><span class="s6">0</span><span class="s3">)</span>

    <span class="s1">estimator </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">)</span>
    <span class="s1">set_random_state</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">)</span>

    <span class="s1">n_samples </span><span class="s3">= </span><span class="s6">100</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">rng</span><span class="s3">.</span><span class="s1">normal</span><span class="s3">(</span><span class="s1">loc</span><span class="s3">=</span><span class="s6">100</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=(</span><span class="s1">n_samples</span><span class="s3">, </span><span class="s6">2</span><span class="s3">))</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">_enforce_estimator_tags_X</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">X</span><span class="s3">)</span>

    <span class="s1">expected_err_msgs </span><span class="s3">= (</span>
        <span class="s4">&quot;requires y to be passed, but the target y is None&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;Expected array-like (array or non-string sequence), got None&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;y should be a 1d array&quot;</span><span class="s3">,</span>
    <span class="s3">)</span>

    <span class="s2">try</span><span class="s3">:</span>
        <span class="s1">estimator</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
    <span class="s2">except </span><span class="s1">ValueError </span><span class="s2">as </span><span class="s1">ve</span><span class="s3">:</span>
        <span class="s2">if not </span><span class="s1">any</span><span class="s3">(</span><span class="s1">msg </span><span class="s2">in </span><span class="s1">str</span><span class="s3">(</span><span class="s1">ve</span><span class="s3">) </span><span class="s2">for </span><span class="s1">msg </span><span class="s2">in </span><span class="s1">expected_err_msgs</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">ve</span>


<span class="s3">@</span><span class="s1">ignore_warnings</span><span class="s3">(</span><span class="s1">category</span><span class="s3">=</span><span class="s1">FutureWarning</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">check_n_features_in_after_fitting</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">estimator_orig</span><span class="s3">):</span>
    <span class="s5"># Make sure that n_features_in are checked after fitting</span>
    <span class="s1">tags </span><span class="s3">= </span><span class="s1">_safe_tags</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">)</span>

    <span class="s1">is_supported_X_types </span><span class="s3">= (</span>
        <span class="s4">&quot;2darray&quot; </span><span class="s2">in </span><span class="s1">tags</span><span class="s3">[</span><span class="s4">&quot;X_types&quot;</span><span class="s3">] </span><span class="s2">or </span><span class="s4">&quot;categorical&quot; </span><span class="s2">in </span><span class="s1">tags</span><span class="s3">[</span><span class="s4">&quot;X_types&quot;</span><span class="s3">]</span>
    <span class="s3">)</span>

    <span class="s2">if not </span><span class="s1">is_supported_X_types </span><span class="s2">or </span><span class="s1">tags</span><span class="s3">[</span><span class="s4">&quot;no_validation&quot;</span><span class="s3">]:</span>
        <span class="s2">return</span>

    <span class="s1">rng </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">RandomState</span><span class="s3">(</span><span class="s6">0</span><span class="s3">)</span>

    <span class="s1">estimator </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">)</span>
    <span class="s1">set_random_state</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s4">&quot;warm_start&quot; </span><span class="s2">in </span><span class="s1">estimator</span><span class="s3">.</span><span class="s1">get_params</span><span class="s3">():</span>
        <span class="s1">estimator</span><span class="s3">.</span><span class="s1">set_params</span><span class="s3">(</span><span class="s1">warm_start</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>

    <span class="s1">n_samples </span><span class="s3">= </span><span class="s6">10</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">rng</span><span class="s3">.</span><span class="s1">normal</span><span class="s3">(</span><span class="s1">size</span><span class="s3">=(</span><span class="s1">n_samples</span><span class="s3">, </span><span class="s6">4</span><span class="s3">))</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">_enforce_estimator_tags_X</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">X</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">is_regressor</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">):</span>
        <span class="s1">y </span><span class="s3">= </span><span class="s1">rng</span><span class="s3">.</span><span class="s1">normal</span><span class="s3">(</span><span class="s1">size</span><span class="s3">=</span><span class="s1">n_samples</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">y </span><span class="s3">= </span><span class="s1">rng</span><span class="s3">.</span><span class="s1">randint</span><span class="s3">(</span><span class="s1">low</span><span class="s3">=</span><span class="s6">0</span><span class="s3">, </span><span class="s1">high</span><span class="s3">=</span><span class="s6">2</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=</span><span class="s1">n_samples</span><span class="s3">)</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">_enforce_estimator_tags_y</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>

    <span class="s1">estimator</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
    <span class="s2">assert </span><span class="s1">estimator</span><span class="s3">.</span><span class="s1">n_features_in_ </span><span class="s3">== </span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]</span>

    <span class="s5"># check methods will check n_features_in_</span>
    <span class="s1">check_methods </span><span class="s3">= [</span>
        <span class="s4">&quot;predict&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;transform&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;decision_function&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;predict_proba&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;score&quot;</span><span class="s3">,</span>
    <span class="s3">]</span>
    <span class="s1">X_bad </span><span class="s3">= </span><span class="s1">X</span><span class="s3">[:, [</span><span class="s6">1</span><span class="s3">]]</span>

    <span class="s1">msg </span><span class="s3">= </span><span class="s4">f&quot;X has 1 features, but </span><span class="s2">\\</span><span class="s4">w+ is expecting </span><span class="s2">{</span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]</span><span class="s2">} </span><span class="s4">features as input&quot;</span>
    <span class="s2">for </span><span class="s1">method </span><span class="s2">in </span><span class="s1">check_methods</span><span class="s3">:</span>
        <span class="s2">if not </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">method</span><span class="s3">):</span>
            <span class="s2">continue</span>

        <span class="s1">callable_method </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">method</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">method </span><span class="s3">== </span><span class="s4">&quot;score&quot;</span><span class="s3">:</span>
            <span class="s1">callable_method </span><span class="s3">= </span><span class="s1">partial</span><span class="s3">(</span><span class="s1">callable_method</span><span class="s3">, </span><span class="s1">y</span><span class="s3">=</span><span class="s1">y</span><span class="s3">)</span>

        <span class="s2">with </span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s1">msg</span><span class="s3">):</span>
            <span class="s1">callable_method</span><span class="s3">(</span><span class="s1">X_bad</span><span class="s3">)</span>

    <span class="s5"># partial_fit will check in the second call</span>
    <span class="s2">if not </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s4">&quot;partial_fit&quot;</span><span class="s3">):</span>
        <span class="s2">return</span>

    <span class="s1">estimator </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">is_classifier</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">):</span>
        <span class="s1">estimator</span><span class="s3">.</span><span class="s1">partial_fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">classes</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">unique</span><span class="s3">(</span><span class="s1">y</span><span class="s3">))</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">estimator</span><span class="s3">.</span><span class="s1">partial_fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
    <span class="s2">assert </span><span class="s1">estimator</span><span class="s3">.</span><span class="s1">n_features_in_ </span><span class="s3">== </span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]</span>

    <span class="s2">with </span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s1">msg</span><span class="s3">):</span>
        <span class="s1">estimator</span><span class="s3">.</span><span class="s1">partial_fit</span><span class="s3">(</span><span class="s1">X_bad</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">check_estimator_get_tags_default_keys</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">estimator_orig</span><span class="s3">):</span>
    <span class="s5"># check that if _get_tags is implemented, it contains all keys from</span>
    <span class="s5"># _DEFAULT_KEYS</span>
    <span class="s1">estimator </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">)</span>
    <span class="s2">if not </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s4">&quot;_get_tags&quot;</span><span class="s3">):</span>
        <span class="s2">return</span>

    <span class="s1">tags_keys </span><span class="s3">= </span><span class="s1">set</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">.</span><span class="s1">_get_tags</span><span class="s3">().</span><span class="s1">keys</span><span class="s3">())</span>
    <span class="s1">default_tags_keys </span><span class="s3">= </span><span class="s1">set</span><span class="s3">(</span><span class="s1">_DEFAULT_TAGS</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">())</span>
    <span class="s2">assert </span><span class="s1">tags_keys</span><span class="s3">.</span><span class="s1">intersection</span><span class="s3">(</span><span class="s1">default_tags_keys</span><span class="s3">) == </span><span class="s1">default_tags_keys</span><span class="s3">, (</span>
        <span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s4">._get_tags() is missing entries for the following default tags&quot;</span>
        <span class="s4">f&quot;: </span><span class="s2">{</span><span class="s1">default_tags_keys </span><span class="s3">- </span><span class="s1">tags_keys</span><span class="s3">.</span><span class="s1">intersection</span><span class="s3">(</span><span class="s1">default_tags_keys</span><span class="s3">)</span><span class="s2">}</span><span class="s4">&quot;</span>
    <span class="s3">)</span>


<span class="s2">def </span><span class="s1">check_dataframe_column_names_consistency</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">estimator_orig</span><span class="s3">):</span>
    <span class="s2">try</span><span class="s3">:</span>
        <span class="s2">import </span><span class="s1">pandas </span><span class="s2">as </span><span class="s1">pd</span>
    <span class="s2">except </span><span class="s1">ImportError</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">SkipTest</span><span class="s3">(</span>
            <span class="s4">&quot;pandas is not installed: not checking column name consistency for pandas&quot;</span>
        <span class="s3">)</span>

    <span class="s1">tags </span><span class="s3">= </span><span class="s1">_safe_tags</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">)</span>
    <span class="s1">is_supported_X_types </span><span class="s3">= (</span>
        <span class="s4">&quot;2darray&quot; </span><span class="s2">in </span><span class="s1">tags</span><span class="s3">[</span><span class="s4">&quot;X_types&quot;</span><span class="s3">] </span><span class="s2">or </span><span class="s4">&quot;categorical&quot; </span><span class="s2">in </span><span class="s1">tags</span><span class="s3">[</span><span class="s4">&quot;X_types&quot;</span><span class="s3">]</span>
    <span class="s3">)</span>

    <span class="s2">if not </span><span class="s1">is_supported_X_types </span><span class="s2">or </span><span class="s1">tags</span><span class="s3">[</span><span class="s4">&quot;no_validation&quot;</span><span class="s3">]:</span>
        <span class="s2">return</span>

    <span class="s1">rng </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">RandomState</span><span class="s3">(</span><span class="s6">0</span><span class="s3">)</span>

    <span class="s1">estimator </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">)</span>
    <span class="s1">set_random_state</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">)</span>

    <span class="s1">X_orig </span><span class="s3">= </span><span class="s1">rng</span><span class="s3">.</span><span class="s1">normal</span><span class="s3">(</span><span class="s1">size</span><span class="s3">=(</span><span class="s6">150</span><span class="s3">, </span><span class="s6">8</span><span class="s3">))</span>

    <span class="s1">X_orig </span><span class="s3">= </span><span class="s1">_enforce_estimator_tags_X</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">X_orig</span><span class="s3">)</span>
    <span class="s1">n_samples</span><span class="s3">, </span><span class="s1">n_features </span><span class="s3">= </span><span class="s1">X_orig</span><span class="s3">.</span><span class="s1">shape</span>

    <span class="s1">names </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s4">f&quot;col_</span><span class="s2">{</span><span class="s1">i</span><span class="s2">}</span><span class="s4">&quot; </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">n_features</span><span class="s3">)])</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">pd</span><span class="s3">.</span><span class="s1">DataFrame</span><span class="s3">(</span><span class="s1">X_orig</span><span class="s3">, </span><span class="s1">columns</span><span class="s3">=</span><span class="s1">names</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">is_regressor</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">):</span>
        <span class="s1">y </span><span class="s3">= </span><span class="s1">rng</span><span class="s3">.</span><span class="s1">normal</span><span class="s3">(</span><span class="s1">size</span><span class="s3">=</span><span class="s1">n_samples</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">y </span><span class="s3">= </span><span class="s1">rng</span><span class="s3">.</span><span class="s1">randint</span><span class="s3">(</span><span class="s1">low</span><span class="s3">=</span><span class="s6">0</span><span class="s3">, </span><span class="s1">high</span><span class="s3">=</span><span class="s6">2</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=</span><span class="s1">n_samples</span><span class="s3">)</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">_enforce_estimator_tags_y</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>

    <span class="s5"># Check that calling `fit` does not raise any warnings about feature names.</span>
    <span class="s2">with </span><span class="s1">warnings</span><span class="s3">.</span><span class="s1">catch_warnings</span><span class="s3">():</span>
        <span class="s1">warnings</span><span class="s3">.</span><span class="s1">filterwarnings</span><span class="s3">(</span>
            <span class="s4">&quot;error&quot;</span><span class="s3">,</span>
            <span class="s1">message</span><span class="s3">=</span><span class="s4">&quot;X does not have valid feature names&quot;</span><span class="s3">,</span>
            <span class="s1">category</span><span class="s3">=</span><span class="s1">UserWarning</span><span class="s3">,</span>
            <span class="s1">module</span><span class="s3">=</span><span class="s4">&quot;sklearn&quot;</span><span class="s3">,</span>
        <span class="s3">)</span>
        <span class="s1">estimator</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>

    <span class="s2">if not </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s4">&quot;feature_names_in_&quot;</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span>
            <span class="s4">&quot;Estimator does not have a feature_names_in_ &quot;</span>
            <span class="s4">&quot;attribute after fitting with a dataframe&quot;</span>
        <span class="s3">)</span>
    <span class="s2">assert </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">.</span><span class="s1">feature_names_in_</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndarray</span><span class="s3">)</span>
    <span class="s2">assert </span><span class="s1">estimator</span><span class="s3">.</span><span class="s1">feature_names_in_</span><span class="s3">.</span><span class="s1">dtype </span><span class="s3">== </span><span class="s1">object</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">.</span><span class="s1">feature_names_in_</span><span class="s3">, </span><span class="s1">names</span><span class="s3">)</span>

    <span class="s5"># Only check sklearn estimators for feature_names_in_ in docstring</span>
    <span class="s1">module_name </span><span class="s3">= </span><span class="s1">estimator_orig</span><span class="s3">.</span><span class="s1">__module__</span>
    <span class="s2">if </span><span class="s3">(</span>
        <span class="s1">module_name</span><span class="s3">.</span><span class="s1">startswith</span><span class="s3">(</span><span class="s4">&quot;sklearn.&quot;</span><span class="s3">)</span>
        <span class="s2">and not </span><span class="s3">(</span><span class="s4">&quot;test_&quot; </span><span class="s2">in </span><span class="s1">module_name </span><span class="s2">or </span><span class="s1">module_name</span><span class="s3">.</span><span class="s1">endswith</span><span class="s3">(</span><span class="s4">&quot;_testing&quot;</span><span class="s3">))</span>
        <span class="s2">and </span><span class="s3">(</span><span class="s4">&quot;feature_names_in_&quot; </span><span class="s2">not in </span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">.</span><span class="s1">__doc__</span><span class="s3">))</span>
    <span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span>
            <span class="s4">f&quot;Estimator </span><span class="s2">{</span><span class="s1">name</span><span class="s2">} </span><span class="s4">does not document its feature_names_in_ attribute&quot;</span>
        <span class="s3">)</span>

    <span class="s1">check_methods </span><span class="s3">= []</span>
    <span class="s2">for </span><span class="s1">method </span><span class="s2">in </span><span class="s3">(</span>
        <span class="s4">&quot;predict&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;transform&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;decision_function&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;predict_proba&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;score&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;score_samples&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;predict_log_proba&quot;</span><span class="s3">,</span>
    <span class="s3">):</span>
        <span class="s2">if not </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">method</span><span class="s3">):</span>
            <span class="s2">continue</span>

        <span class="s1">callable_method </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">method</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">method </span><span class="s3">== </span><span class="s4">&quot;score&quot;</span><span class="s3">:</span>
            <span class="s1">callable_method </span><span class="s3">= </span><span class="s1">partial</span><span class="s3">(</span><span class="s1">callable_method</span><span class="s3">, </span><span class="s1">y</span><span class="s3">=</span><span class="s1">y</span><span class="s3">)</span>
        <span class="s1">check_methods</span><span class="s3">.</span><span class="s1">append</span><span class="s3">((</span><span class="s1">method</span><span class="s3">, </span><span class="s1">callable_method</span><span class="s3">))</span>

    <span class="s2">for </span><span class="s1">_</span><span class="s3">, </span><span class="s1">method </span><span class="s2">in </span><span class="s1">check_methods</span><span class="s3">:</span>
        <span class="s2">with </span><span class="s1">warnings</span><span class="s3">.</span><span class="s1">catch_warnings</span><span class="s3">():</span>
            <span class="s1">warnings</span><span class="s3">.</span><span class="s1">filterwarnings</span><span class="s3">(</span>
                <span class="s4">&quot;error&quot;</span><span class="s3">,</span>
                <span class="s1">message</span><span class="s3">=</span><span class="s4">&quot;X does not have valid feature names&quot;</span><span class="s3">,</span>
                <span class="s1">category</span><span class="s3">=</span><span class="s1">UserWarning</span><span class="s3">,</span>
                <span class="s1">module</span><span class="s3">=</span><span class="s4">&quot;sklearn&quot;</span><span class="s3">,</span>
            <span class="s3">)</span>
            <span class="s1">method</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)  </span><span class="s5"># works without UserWarning for valid features</span>

    <span class="s1">invalid_names </span><span class="s3">= [</span>
        <span class="s3">(</span><span class="s1">names</span><span class="s3">[::-</span><span class="s6">1</span><span class="s3">], </span><span class="s4">&quot;Feature names must be in the same order as they were in fit.&quot;</span><span class="s3">),</span>
        <span class="s3">(</span>
            <span class="s3">[</span><span class="s4">f&quot;another_prefix_</span><span class="s2">{</span><span class="s1">i</span><span class="s2">}</span><span class="s4">&quot; </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">n_features</span><span class="s3">)],</span>
            <span class="s3">(</span>
                <span class="s4">&quot;Feature names unseen at fit time:</span><span class="s2">\n</span><span class="s4">- another_prefix_0</span><span class="s2">\n</span><span class="s4">-&quot;</span>
                <span class="s4">&quot; another_prefix_1</span><span class="s2">\n</span><span class="s4">&quot;</span>
            <span class="s3">),</span>
        <span class="s3">),</span>
        <span class="s3">(</span>
            <span class="s1">names</span><span class="s3">[:</span><span class="s6">3</span><span class="s3">],</span>
            <span class="s4">f&quot;Feature names seen at fit time, yet now missing:</span><span class="s2">\n</span><span class="s4">- </span><span class="s2">{</span><span class="s1">min</span><span class="s3">(</span><span class="s1">names</span><span class="s3">[</span><span class="s6">3</span><span class="s3">:])</span><span class="s2">}\n</span><span class="s4">&quot;</span><span class="s3">,</span>
        <span class="s3">),</span>
    <span class="s3">]</span>
    <span class="s1">params </span><span class="s3">= {</span>
        <span class="s1">key</span><span class="s3">: </span><span class="s1">value</span>
        <span class="s2">for </span><span class="s1">key</span><span class="s3">, </span><span class="s1">value </span><span class="s2">in </span><span class="s1">estimator</span><span class="s3">.</span><span class="s1">get_params</span><span class="s3">().</span><span class="s1">items</span><span class="s3">()</span>
        <span class="s2">if </span><span class="s4">&quot;early_stopping&quot; </span><span class="s2">in </span><span class="s1">key</span>
    <span class="s3">}</span>
    <span class="s1">early_stopping_enabled </span><span class="s3">= </span><span class="s1">any</span><span class="s3">(</span><span class="s1">value </span><span class="s2">is True for </span><span class="s1">value </span><span class="s2">in </span><span class="s1">params</span><span class="s3">.</span><span class="s1">values</span><span class="s3">())</span>

    <span class="s2">for </span><span class="s1">invalid_name</span><span class="s3">, </span><span class="s1">additional_message </span><span class="s2">in </span><span class="s1">invalid_names</span><span class="s3">:</span>
        <span class="s1">X_bad </span><span class="s3">= </span><span class="s1">pd</span><span class="s3">.</span><span class="s1">DataFrame</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">columns</span><span class="s3">=</span><span class="s1">invalid_name</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>

        <span class="s1">expected_msg </span><span class="s3">= </span><span class="s1">re</span><span class="s3">.</span><span class="s1">escape</span><span class="s3">(</span>
            <span class="s4">&quot;The feature names should match those that were passed during fit.</span><span class="s2">\n</span><span class="s4">&quot;</span>
            <span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">additional_message</span><span class="s2">}</span><span class="s4">&quot;</span>
        <span class="s3">)</span>
        <span class="s2">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">method </span><span class="s2">in </span><span class="s1">check_methods</span><span class="s3">:</span>
            <span class="s2">with </span><span class="s1">raises</span><span class="s3">(</span>
                <span class="s1">ValueError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s1">expected_msg</span><span class="s3">, </span><span class="s1">err_msg</span><span class="s3">=</span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">name</span><span class="s2">} </span><span class="s4">did not raise&quot;</span>
            <span class="s3">):</span>
                <span class="s1">method</span><span class="s3">(</span><span class="s1">X_bad</span><span class="s3">)</span>

        <span class="s5"># partial_fit checks on second call</span>
        <span class="s5"># Do not call partial fit if early_stopping is on</span>
        <span class="s2">if not </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s4">&quot;partial_fit&quot;</span><span class="s3">) </span><span class="s2">or </span><span class="s1">early_stopping_enabled</span><span class="s3">:</span>
            <span class="s2">continue</span>

        <span class="s1">estimator </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">is_classifier</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">):</span>
            <span class="s1">classes </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">unique</span><span class="s3">(</span><span class="s1">y</span><span class="s3">)</span>
            <span class="s1">estimator</span><span class="s3">.</span><span class="s1">partial_fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">classes</span><span class="s3">=</span><span class="s1">classes</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">estimator</span><span class="s3">.</span><span class="s1">partial_fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>

        <span class="s2">with </span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s1">expected_msg</span><span class="s3">):</span>
            <span class="s1">estimator</span><span class="s3">.</span><span class="s1">partial_fit</span><span class="s3">(</span><span class="s1">X_bad</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">check_transformer_get_feature_names_out</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">transformer_orig</span><span class="s3">):</span>
    <span class="s1">tags </span><span class="s3">= </span><span class="s1">transformer_orig</span><span class="s3">.</span><span class="s1">_get_tags</span><span class="s3">()</span>
    <span class="s2">if </span><span class="s4">&quot;2darray&quot; </span><span class="s2">not in </span><span class="s1">tags</span><span class="s3">[</span><span class="s4">&quot;X_types&quot;</span><span class="s3">] </span><span class="s2">or </span><span class="s1">tags</span><span class="s3">[</span><span class="s4">&quot;no_validation&quot;</span><span class="s3">]:</span>
        <span class="s2">return</span>

    <span class="s1">X</span><span class="s3">, </span><span class="s1">y </span><span class="s3">= </span><span class="s1">make_blobs</span><span class="s3">(</span>
        <span class="s1">n_samples</span><span class="s3">=</span><span class="s6">30</span><span class="s3">,</span>
        <span class="s1">centers</span><span class="s3">=[[</span><span class="s6">0</span><span class="s3">, </span><span class="s6">0</span><span class="s3">, </span><span class="s6">0</span><span class="s3">], [</span><span class="s6">1</span><span class="s3">, </span><span class="s6">1</span><span class="s3">, </span><span class="s6">1</span><span class="s3">]],</span>
        <span class="s1">random_state</span><span class="s3">=</span><span class="s6">0</span><span class="s3">,</span>
        <span class="s1">n_features</span><span class="s3">=</span><span class="s6">2</span><span class="s3">,</span>
        <span class="s1">cluster_std</span><span class="s3">=</span><span class="s6">0.1</span><span class="s3">,</span>
    <span class="s3">)</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">StandardScaler</span><span class="s3">().</span><span class="s1">fit_transform</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>

    <span class="s1">transformer </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">transformer_orig</span><span class="s3">)</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">_enforce_estimator_tags_X</span><span class="s3">(</span><span class="s1">transformer</span><span class="s3">, </span><span class="s1">X</span><span class="s3">)</span>

    <span class="s1">n_features </span><span class="s3">= </span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]</span>
    <span class="s1">set_random_state</span><span class="s3">(</span><span class="s1">transformer</span><span class="s3">)</span>

    <span class="s1">y_ </span><span class="s3">= </span><span class="s1">y</span>
    <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">CROSS_DECOMPOSITION</span><span class="s3">:</span>
        <span class="s1">y_ </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">c_</span><span class="s3">[</span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">y</span><span class="s3">), </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">y</span><span class="s3">)]</span>
        <span class="s1">y_</span><span class="s3">[::</span><span class="s6">2</span><span class="s3">, </span><span class="s6">1</span><span class="s3">] *= </span><span class="s6">2</span>

    <span class="s1">X_transform </span><span class="s3">= </span><span class="s1">transformer</span><span class="s3">.</span><span class="s1">fit_transform</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">=</span><span class="s1">y_</span><span class="s3">)</span>
    <span class="s1">input_features </span><span class="s3">= [</span><span class="s4">f&quot;feature</span><span class="s2">{</span><span class="s1">i</span><span class="s2">}</span><span class="s4">&quot; </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">n_features</span><span class="s3">)]</span>

    <span class="s5"># input_features names is not the same length as n_features_in_</span>
    <span class="s2">with </span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s4">&quot;input_features should have length equal&quot;</span><span class="s3">):</span>
        <span class="s1">transformer</span><span class="s3">.</span><span class="s1">get_feature_names_out</span><span class="s3">(</span><span class="s1">input_features</span><span class="s3">[::</span><span class="s6">2</span><span class="s3">])</span>

    <span class="s1">feature_names_out </span><span class="s3">= </span><span class="s1">transformer</span><span class="s3">.</span><span class="s1">get_feature_names_out</span><span class="s3">(</span><span class="s1">input_features</span><span class="s3">)</span>
    <span class="s2">assert </span><span class="s1">feature_names_out </span><span class="s2">is not None</span>
    <span class="s2">assert </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">feature_names_out</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndarray</span><span class="s3">)</span>
    <span class="s2">assert </span><span class="s1">feature_names_out</span><span class="s3">.</span><span class="s1">dtype </span><span class="s3">== </span><span class="s1">object</span>
    <span class="s2">assert </span><span class="s1">all</span><span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">str</span><span class="s3">) </span><span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">feature_names_out</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">X_transform</span><span class="s3">, </span><span class="s1">tuple</span><span class="s3">):</span>
        <span class="s1">n_features_out </span><span class="s3">= </span><span class="s1">X_transform</span><span class="s3">[</span><span class="s6">0</span><span class="s3">].</span><span class="s1">shape</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">n_features_out </span><span class="s3">= </span><span class="s1">X_transform</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]</span>

    <span class="s2">assert </span><span class="s3">(</span>
        <span class="s1">len</span><span class="s3">(</span><span class="s1">feature_names_out</span><span class="s3">) == </span><span class="s1">n_features_out</span>
    <span class="s3">), </span><span class="s4">f&quot;Expected </span><span class="s2">{</span><span class="s1">n_features_out</span><span class="s2">} </span><span class="s4">feature names, got </span><span class="s2">{</span><span class="s1">len</span><span class="s3">(</span><span class="s1">feature_names_out</span><span class="s3">)</span><span class="s2">}</span><span class="s4">&quot;</span>


<span class="s2">def </span><span class="s1">check_transformer_get_feature_names_out_pandas</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">transformer_orig</span><span class="s3">):</span>
    <span class="s2">try</span><span class="s3">:</span>
        <span class="s2">import </span><span class="s1">pandas </span><span class="s2">as </span><span class="s1">pd</span>
    <span class="s2">except </span><span class="s1">ImportError</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">SkipTest</span><span class="s3">(</span>
            <span class="s4">&quot;pandas is not installed: not checking column name consistency for pandas&quot;</span>
        <span class="s3">)</span>

    <span class="s1">tags </span><span class="s3">= </span><span class="s1">transformer_orig</span><span class="s3">.</span><span class="s1">_get_tags</span><span class="s3">()</span>
    <span class="s2">if </span><span class="s4">&quot;2darray&quot; </span><span class="s2">not in </span><span class="s1">tags</span><span class="s3">[</span><span class="s4">&quot;X_types&quot;</span><span class="s3">] </span><span class="s2">or </span><span class="s1">tags</span><span class="s3">[</span><span class="s4">&quot;no_validation&quot;</span><span class="s3">]:</span>
        <span class="s2">return</span>

    <span class="s1">X</span><span class="s3">, </span><span class="s1">y </span><span class="s3">= </span><span class="s1">make_blobs</span><span class="s3">(</span>
        <span class="s1">n_samples</span><span class="s3">=</span><span class="s6">30</span><span class="s3">,</span>
        <span class="s1">centers</span><span class="s3">=[[</span><span class="s6">0</span><span class="s3">, </span><span class="s6">0</span><span class="s3">, </span><span class="s6">0</span><span class="s3">], [</span><span class="s6">1</span><span class="s3">, </span><span class="s6">1</span><span class="s3">, </span><span class="s6">1</span><span class="s3">]],</span>
        <span class="s1">random_state</span><span class="s3">=</span><span class="s6">0</span><span class="s3">,</span>
        <span class="s1">n_features</span><span class="s3">=</span><span class="s6">2</span><span class="s3">,</span>
        <span class="s1">cluster_std</span><span class="s3">=</span><span class="s6">0.1</span><span class="s3">,</span>
    <span class="s3">)</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">StandardScaler</span><span class="s3">().</span><span class="s1">fit_transform</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>

    <span class="s1">transformer </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">transformer_orig</span><span class="s3">)</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">_enforce_estimator_tags_X</span><span class="s3">(</span><span class="s1">transformer</span><span class="s3">, </span><span class="s1">X</span><span class="s3">)</span>

    <span class="s1">n_features </span><span class="s3">= </span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]</span>
    <span class="s1">set_random_state</span><span class="s3">(</span><span class="s1">transformer</span><span class="s3">)</span>

    <span class="s1">y_ </span><span class="s3">= </span><span class="s1">y</span>
    <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">CROSS_DECOMPOSITION</span><span class="s3">:</span>
        <span class="s1">y_ </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">c_</span><span class="s3">[</span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">y</span><span class="s3">), </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">y</span><span class="s3">)]</span>
        <span class="s1">y_</span><span class="s3">[::</span><span class="s6">2</span><span class="s3">, </span><span class="s6">1</span><span class="s3">] *= </span><span class="s6">2</span>

    <span class="s1">feature_names_in </span><span class="s3">= [</span><span class="s4">f&quot;col</span><span class="s2">{</span><span class="s1">i</span><span class="s2">}</span><span class="s4">&quot; </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">n_features</span><span class="s3">)]</span>
    <span class="s1">df </span><span class="s3">= </span><span class="s1">pd</span><span class="s3">.</span><span class="s1">DataFrame</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">columns</span><span class="s3">=</span><span class="s1">feature_names_in</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
    <span class="s1">X_transform </span><span class="s3">= </span><span class="s1">transformer</span><span class="s3">.</span><span class="s1">fit_transform</span><span class="s3">(</span><span class="s1">df</span><span class="s3">, </span><span class="s1">y</span><span class="s3">=</span><span class="s1">y_</span><span class="s3">)</span>

    <span class="s5"># error is raised when `input_features` do not match feature_names_in</span>
    <span class="s1">invalid_feature_names </span><span class="s3">= [</span><span class="s4">f&quot;bad</span><span class="s2">{</span><span class="s1">i</span><span class="s2">}</span><span class="s4">&quot; </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">n_features</span><span class="s3">)]</span>
    <span class="s2">with </span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s4">&quot;input_features is not equal to feature_names_in_&quot;</span><span class="s3">):</span>
        <span class="s1">transformer</span><span class="s3">.</span><span class="s1">get_feature_names_out</span><span class="s3">(</span><span class="s1">invalid_feature_names</span><span class="s3">)</span>

    <span class="s1">feature_names_out_default </span><span class="s3">= </span><span class="s1">transformer</span><span class="s3">.</span><span class="s1">get_feature_names_out</span><span class="s3">()</span>
    <span class="s1">feature_names_in_explicit_names </span><span class="s3">= </span><span class="s1">transformer</span><span class="s3">.</span><span class="s1">get_feature_names_out</span><span class="s3">(</span>
        <span class="s1">feature_names_in</span>
    <span class="s3">)</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">feature_names_out_default</span><span class="s3">, </span><span class="s1">feature_names_in_explicit_names</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">X_transform</span><span class="s3">, </span><span class="s1">tuple</span><span class="s3">):</span>
        <span class="s1">n_features_out </span><span class="s3">= </span><span class="s1">X_transform</span><span class="s3">[</span><span class="s6">0</span><span class="s3">].</span><span class="s1">shape</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">n_features_out </span><span class="s3">= </span><span class="s1">X_transform</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]</span>

    <span class="s2">assert </span><span class="s3">(</span>
        <span class="s1">len</span><span class="s3">(</span><span class="s1">feature_names_out_default</span><span class="s3">) == </span><span class="s1">n_features_out</span>
    <span class="s3">), </span><span class="s4">f&quot;Expected </span><span class="s2">{</span><span class="s1">n_features_out</span><span class="s2">} </span><span class="s4">feature names, got </span><span class="s2">{</span><span class="s1">len</span><span class="s3">(</span><span class="s1">feature_names_out_default</span><span class="s3">)</span><span class="s2">}</span><span class="s4">&quot;</span>


<span class="s2">def </span><span class="s1">check_param_validation</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">estimator_orig</span><span class="s3">):</span>
    <span class="s5"># Check that an informative error is raised when the value of a constructor</span>
    <span class="s5"># parameter does not have an appropriate type or value.</span>
    <span class="s1">rng </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">RandomState</span><span class="s3">(</span><span class="s6">0</span><span class="s3">)</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">rng</span><span class="s3">.</span><span class="s1">uniform</span><span class="s3">(</span><span class="s1">size</span><span class="s3">=(</span><span class="s6">20</span><span class="s3">, </span><span class="s6">5</span><span class="s3">))</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">rng</span><span class="s3">.</span><span class="s1">randint</span><span class="s3">(</span><span class="s6">0</span><span class="s3">, </span><span class="s6">2</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=</span><span class="s6">20</span><span class="s3">)</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">_enforce_estimator_tags_y</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>

    <span class="s1">estimator_params </span><span class="s3">= </span><span class="s1">estimator_orig</span><span class="s3">.</span><span class="s1">get_params</span><span class="s3">(</span><span class="s1">deep</span><span class="s3">=</span><span class="s2">False</span><span class="s3">).</span><span class="s1">keys</span><span class="s3">()</span>

    <span class="s5"># check that there is a constraint for each parameter</span>
    <span class="s2">if </span><span class="s1">estimator_params</span><span class="s3">:</span>
        <span class="s1">validation_params </span><span class="s3">= </span><span class="s1">estimator_orig</span><span class="s3">.</span><span class="s1">_parameter_constraints</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">()</span>
        <span class="s1">unexpected_params </span><span class="s3">= </span><span class="s1">set</span><span class="s3">(</span><span class="s1">validation_params</span><span class="s3">) - </span><span class="s1">set</span><span class="s3">(</span><span class="s1">estimator_params</span><span class="s3">)</span>
        <span class="s1">missing_params </span><span class="s3">= </span><span class="s1">set</span><span class="s3">(</span><span class="s1">estimator_params</span><span class="s3">) - </span><span class="s1">set</span><span class="s3">(</span><span class="s1">validation_params</span><span class="s3">)</span>
        <span class="s1">err_msg </span><span class="s3">= (</span>
            <span class="s4">f&quot;Mismatch between _parameter_constraints and the parameters of </span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s4">.&quot;</span>
            <span class="s4">f&quot;</span><span class="s2">\n</span><span class="s4">Consider the unexpected parameters </span><span class="s2">{</span><span class="s1">unexpected_params</span><span class="s2">} </span><span class="s4">and expected but&quot;</span>
            <span class="s4">f&quot; missing parameters </span><span class="s2">{</span><span class="s1">missing_params</span><span class="s2">}</span><span class="s4">&quot;</span>
        <span class="s3">)</span>
        <span class="s2">assert </span><span class="s1">validation_params </span><span class="s3">== </span><span class="s1">estimator_params</span><span class="s3">, </span><span class="s1">err_msg</span>

    <span class="s5"># this object does not have a valid type for sure for all params</span>
    <span class="s1">param_with_bad_type </span><span class="s3">= </span><span class="s1">type</span><span class="s3">(</span><span class="s4">&quot;BadType&quot;</span><span class="s3">, (), {})()</span>

    <span class="s1">fit_methods </span><span class="s3">= [</span><span class="s4">&quot;fit&quot;</span><span class="s3">, </span><span class="s4">&quot;partial_fit&quot;</span><span class="s3">, </span><span class="s4">&quot;fit_transform&quot;</span><span class="s3">, </span><span class="s4">&quot;fit_predict&quot;</span><span class="s3">]</span>

    <span class="s2">for </span><span class="s1">param_name </span><span class="s2">in </span><span class="s1">estimator_params</span><span class="s3">:</span>
        <span class="s1">constraints </span><span class="s3">= </span><span class="s1">estimator_orig</span><span class="s3">.</span><span class="s1">_parameter_constraints</span><span class="s3">[</span><span class="s1">param_name</span><span class="s3">]</span>

        <span class="s2">if </span><span class="s1">constraints </span><span class="s3">== </span><span class="s4">&quot;no_validation&quot;</span><span class="s3">:</span>
            <span class="s5"># This parameter is not validated</span>
            <span class="s2">continue</span>

        <span class="s5"># Mixing an interval of reals and an interval of integers must be avoided.</span>
        <span class="s2">if </span><span class="s1">any</span><span class="s3">(</span>
            <span class="s1">isinstance</span><span class="s3">(</span><span class="s1">constraint</span><span class="s3">, </span><span class="s1">Interval</span><span class="s3">) </span><span class="s2">and </span><span class="s1">constraint</span><span class="s3">.</span><span class="s1">type </span><span class="s3">== </span><span class="s1">Integral</span>
            <span class="s2">for </span><span class="s1">constraint </span><span class="s2">in </span><span class="s1">constraints</span>
        <span class="s3">) </span><span class="s2">and </span><span class="s1">any</span><span class="s3">(</span>
            <span class="s1">isinstance</span><span class="s3">(</span><span class="s1">constraint</span><span class="s3">, </span><span class="s1">Interval</span><span class="s3">) </span><span class="s2">and </span><span class="s1">constraint</span><span class="s3">.</span><span class="s1">type </span><span class="s3">== </span><span class="s1">Real</span>
            <span class="s2">for </span><span class="s1">constraint </span><span class="s2">in </span><span class="s1">constraints</span>
        <span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span>
                <span class="s4">f&quot;The constraint for parameter </span><span class="s2">{</span><span class="s1">param_name</span><span class="s2">} </span><span class="s4">of </span><span class="s2">{</span><span class="s1">name</span><span class="s2">} </span><span class="s4">can't have a mix&quot;</span>
                <span class="s4">&quot; of intervals of Integral and Real types. Use the type RealNotInt&quot;</span>
                <span class="s4">&quot; instead of Real.&quot;</span>
            <span class="s3">)</span>

        <span class="s1">match </span><span class="s3">= </span><span class="s4">rf&quot;The '</span><span class="s2">{</span><span class="s1">param_name</span><span class="s2">}</span><span class="s4">' parameter of </span><span class="s2">{</span><span class="s1">name</span><span class="s2">} </span><span class="s4">must be .* Got .* instead.&quot;</span>
        <span class="s1">err_msg </span><span class="s3">= (</span>
            <span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">name</span><span class="s2">} </span><span class="s4">does not raise an informative error message when the &quot;</span>
            <span class="s4">f&quot;parameter </span><span class="s2">{</span><span class="s1">param_name</span><span class="s2">} </span><span class="s4">does not have a valid type or value.&quot;</span>
        <span class="s3">)</span>

        <span class="s1">estimator </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">)</span>

        <span class="s5"># First, check that the error is raised if param doesn't match any valid type.</span>
        <span class="s1">estimator</span><span class="s3">.</span><span class="s1">set_params</span><span class="s3">(**{</span><span class="s1">param_name</span><span class="s3">: </span><span class="s1">param_with_bad_type</span><span class="s3">})</span>

        <span class="s2">for </span><span class="s1">method </span><span class="s2">in </span><span class="s1">fit_methods</span><span class="s3">:</span>
            <span class="s2">if not </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">method</span><span class="s3">):</span>
                <span class="s5"># the method is not accessible with the current set of parameters</span>
                <span class="s2">continue</span>

            <span class="s1">err_msg </span><span class="s3">= (</span>
                <span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">name</span><span class="s2">} </span><span class="s4">does not raise an informative error message when the parameter&quot;</span>
                <span class="s4">f&quot; </span><span class="s2">{</span><span class="s1">param_name</span><span class="s2">} </span><span class="s4">does not have a valid type. If any Python type is&quot;</span>
                <span class="s4">&quot; valid, the constraint should be 'no_validation'.&quot;</span>
            <span class="s3">)</span>

            <span class="s2">with </span><span class="s1">raises</span><span class="s3">(</span><span class="s1">InvalidParameterError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s1">match</span><span class="s3">, </span><span class="s1">err_msg</span><span class="s3">=</span><span class="s1">err_msg</span><span class="s3">):</span>
                <span class="s2">if </span><span class="s1">any</span><span class="s3">(</span>
                    <span class="s1">isinstance</span><span class="s3">(</span><span class="s1">X_type</span><span class="s3">, </span><span class="s1">str</span><span class="s3">) </span><span class="s2">and </span><span class="s1">X_type</span><span class="s3">.</span><span class="s1">endswith</span><span class="s3">(</span><span class="s4">&quot;labels&quot;</span><span class="s3">)</span>
                    <span class="s2">for </span><span class="s1">X_type </span><span class="s2">in </span><span class="s1">_safe_tags</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">key</span><span class="s3">=</span><span class="s4">&quot;X_types&quot;</span><span class="s3">)</span>
                <span class="s3">):</span>
                    <span class="s5"># The estimator is a label transformer and take only `y`</span>
                    <span class="s1">getattr</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">method</span><span class="s3">)(</span><span class="s1">y</span><span class="s3">)</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">getattr</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">method</span><span class="s3">)(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>

        <span class="s5"># Then, for constraints that are more than a type constraint, check that the</span>
        <span class="s5"># error is raised if param does match a valid type but does not match any valid</span>
        <span class="s5"># value for this type.</span>
        <span class="s1">constraints </span><span class="s3">= [</span><span class="s1">make_constraint</span><span class="s3">(</span><span class="s1">constraint</span><span class="s3">) </span><span class="s2">for </span><span class="s1">constraint </span><span class="s2">in </span><span class="s1">constraints</span><span class="s3">]</span>

        <span class="s2">for </span><span class="s1">constraint </span><span class="s2">in </span><span class="s1">constraints</span><span class="s3">:</span>
            <span class="s2">try</span><span class="s3">:</span>
                <span class="s1">bad_value </span><span class="s3">= </span><span class="s1">generate_invalid_param_val</span><span class="s3">(</span><span class="s1">constraint</span><span class="s3">)</span>
            <span class="s2">except </span><span class="s1">NotImplementedError</span><span class="s3">:</span>
                <span class="s2">continue</span>

            <span class="s1">estimator</span><span class="s3">.</span><span class="s1">set_params</span><span class="s3">(**{</span><span class="s1">param_name</span><span class="s3">: </span><span class="s1">bad_value</span><span class="s3">})</span>

            <span class="s2">for </span><span class="s1">method </span><span class="s2">in </span><span class="s1">fit_methods</span><span class="s3">:</span>
                <span class="s2">if not </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">method</span><span class="s3">):</span>
                    <span class="s5"># the method is not accessible with the current set of parameters</span>
                    <span class="s2">continue</span>

                <span class="s1">err_msg </span><span class="s3">= (</span>
                    <span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">name</span><span class="s2">} </span><span class="s4">does not raise an informative error message when the &quot;</span>
                    <span class="s4">f&quot;parameter </span><span class="s2">{</span><span class="s1">param_name</span><span class="s2">} </span><span class="s4">does not have a valid value.</span><span class="s2">\n</span><span class="s4">&quot;</span>
                    <span class="s4">&quot;Constraints should be disjoint. For instance &quot;</span>
                    <span class="s4">&quot;[StrOptions({'a_string'}), str] is not a acceptable set of &quot;</span>
                    <span class="s4">&quot;constraint because generating an invalid string for the first &quot;</span>
                    <span class="s4">&quot;constraint will always produce a valid string for the second &quot;</span>
                    <span class="s4">&quot;constraint.&quot;</span>
                <span class="s3">)</span>

                <span class="s2">with </span><span class="s1">raises</span><span class="s3">(</span><span class="s1">InvalidParameterError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s1">match</span><span class="s3">, </span><span class="s1">err_msg</span><span class="s3">=</span><span class="s1">err_msg</span><span class="s3">):</span>
                    <span class="s2">if </span><span class="s1">any</span><span class="s3">(</span>
                        <span class="s1">X_type</span><span class="s3">.</span><span class="s1">endswith</span><span class="s3">(</span><span class="s4">&quot;labels&quot;</span><span class="s3">)</span>
                        <span class="s2">for </span><span class="s1">X_type </span><span class="s2">in </span><span class="s1">_safe_tags</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">key</span><span class="s3">=</span><span class="s4">&quot;X_types&quot;</span><span class="s3">)</span>
                    <span class="s3">):</span>
                        <span class="s5"># The estimator is a label transformer and take only `y`</span>
                        <span class="s1">getattr</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">method</span><span class="s3">)(</span><span class="s1">y</span><span class="s3">)</span>
                    <span class="s2">else</span><span class="s3">:</span>
                        <span class="s1">getattr</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">method</span><span class="s3">)(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">check_set_output_transform</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">transformer_orig</span><span class="s3">):</span>
    <span class="s5"># Check transformer.set_output with the default configuration does not</span>
    <span class="s5"># change the transform output.</span>
    <span class="s1">tags </span><span class="s3">= </span><span class="s1">transformer_orig</span><span class="s3">.</span><span class="s1">_get_tags</span><span class="s3">()</span>
    <span class="s2">if </span><span class="s4">&quot;2darray&quot; </span><span class="s2">not in </span><span class="s1">tags</span><span class="s3">[</span><span class="s4">&quot;X_types&quot;</span><span class="s3">] </span><span class="s2">or </span><span class="s1">tags</span><span class="s3">[</span><span class="s4">&quot;no_validation&quot;</span><span class="s3">]:</span>
        <span class="s2">return</span>

    <span class="s1">rng </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">RandomState</span><span class="s3">(</span><span class="s6">0</span><span class="s3">)</span>
    <span class="s1">transformer </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">transformer_orig</span><span class="s3">)</span>

    <span class="s1">X </span><span class="s3">= </span><span class="s1">rng</span><span class="s3">.</span><span class="s1">uniform</span><span class="s3">(</span><span class="s1">size</span><span class="s3">=(</span><span class="s6">20</span><span class="s3">, </span><span class="s6">5</span><span class="s3">))</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">_enforce_estimator_tags_X</span><span class="s3">(</span><span class="s1">transformer_orig</span><span class="s3">, </span><span class="s1">X</span><span class="s3">)</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">rng</span><span class="s3">.</span><span class="s1">randint</span><span class="s3">(</span><span class="s6">0</span><span class="s3">, </span><span class="s6">2</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=</span><span class="s6">20</span><span class="s3">)</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">_enforce_estimator_tags_y</span><span class="s3">(</span><span class="s1">transformer_orig</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
    <span class="s1">set_random_state</span><span class="s3">(</span><span class="s1">transformer</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">fit_then_transform</span><span class="s3">(</span><span class="s1">est</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">CROSS_DECOMPOSITION</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">est</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">).</span><span class="s1">transform</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">est</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">).</span><span class="s1">transform</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">fit_transform</span><span class="s3">(</span><span class="s1">est</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">est</span><span class="s3">.</span><span class="s1">fit_transform</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>

    <span class="s1">transform_methods </span><span class="s3">= {</span>
        <span class="s4">&quot;transform&quot;</span><span class="s3">: </span><span class="s1">fit_then_transform</span><span class="s3">,</span>
        <span class="s4">&quot;fit_transform&quot;</span><span class="s3">: </span><span class="s1">fit_transform</span><span class="s3">,</span>
    <span class="s3">}</span>
    <span class="s2">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">transform_method </span><span class="s2">in </span><span class="s1">transform_methods</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
        <span class="s1">transformer </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">transformer</span><span class="s3">)</span>
        <span class="s2">if not </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">transformer</span><span class="s3">, </span><span class="s1">name</span><span class="s3">):</span>
            <span class="s2">continue</span>
        <span class="s1">X_trans_no_setting </span><span class="s3">= </span><span class="s1">transform_method</span><span class="s3">(</span><span class="s1">transformer</span><span class="s3">)</span>

        <span class="s5"># Auto wrapping only wraps the first array</span>
        <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">CROSS_DECOMPOSITION</span><span class="s3">:</span>
            <span class="s1">X_trans_no_setting </span><span class="s3">= </span><span class="s1">X_trans_no_setting</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]</span>

        <span class="s1">transformer</span><span class="s3">.</span><span class="s1">set_output</span><span class="s3">(</span><span class="s1">transform</span><span class="s3">=</span><span class="s4">&quot;default&quot;</span><span class="s3">)</span>
        <span class="s1">X_trans_default </span><span class="s3">= </span><span class="s1">transform_method</span><span class="s3">(</span><span class="s1">transformer</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">CROSS_DECOMPOSITION</span><span class="s3">:</span>
            <span class="s1">X_trans_default </span><span class="s3">= </span><span class="s1">X_trans_default</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]</span>

        <span class="s5"># Default and no setting -&gt; returns the same transformation</span>
        <span class="s1">assert_allclose_dense_sparse</span><span class="s3">(</span><span class="s1">X_trans_no_setting</span><span class="s3">, </span><span class="s1">X_trans_default</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">_output_from_fit_transform</span><span class="s3">(</span><span class="s1">transformer</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">df</span><span class="s3">, </span><span class="s1">y</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Generate output to test `set_output` for different configuration: 
 
    - calling either `fit.transform` or `fit_transform`; 
    - passing either a dataframe or a numpy array to fit; 
    - passing either a dataframe or a numpy array to transform. 
    &quot;&quot;&quot;</span>
    <span class="s1">outputs </span><span class="s3">= {}</span>

    <span class="s5"># fit then transform case:</span>
    <span class="s1">cases </span><span class="s3">= [</span>
        <span class="s3">(</span><span class="s4">&quot;fit.transform/df/df&quot;</span><span class="s3">, </span><span class="s1">df</span><span class="s3">, </span><span class="s1">df</span><span class="s3">),</span>
        <span class="s3">(</span><span class="s4">&quot;fit.transform/df/array&quot;</span><span class="s3">, </span><span class="s1">df</span><span class="s3">, </span><span class="s1">X</span><span class="s3">),</span>
        <span class="s3">(</span><span class="s4">&quot;fit.transform/array/df&quot;</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">df</span><span class="s3">),</span>
        <span class="s3">(</span><span class="s4">&quot;fit.transform/array/array&quot;</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">X</span><span class="s3">),</span>
    <span class="s3">]</span>
    <span class="s2">if </span><span class="s1">all</span><span class="s3">(</span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">transformer</span><span class="s3">, </span><span class="s1">meth</span><span class="s3">) </span><span class="s2">for </span><span class="s1">meth </span><span class="s2">in </span><span class="s3">[</span><span class="s4">&quot;fit&quot;</span><span class="s3">, </span><span class="s4">&quot;transform&quot;</span><span class="s3">]):</span>
        <span class="s2">for </span><span class="s3">(</span>
            <span class="s1">case</span><span class="s3">,</span>
            <span class="s1">data_fit</span><span class="s3">,</span>
            <span class="s1">data_transform</span><span class="s3">,</span>
        <span class="s3">) </span><span class="s2">in </span><span class="s1">cases</span><span class="s3">:</span>
            <span class="s1">transformer</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">data_fit</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">CROSS_DECOMPOSITION</span><span class="s3">:</span>
                <span class="s1">X_trans</span><span class="s3">, </span><span class="s1">_ </span><span class="s3">= </span><span class="s1">transformer</span><span class="s3">.</span><span class="s1">transform</span><span class="s3">(</span><span class="s1">data_transform</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">X_trans </span><span class="s3">= </span><span class="s1">transformer</span><span class="s3">.</span><span class="s1">transform</span><span class="s3">(</span><span class="s1">data_transform</span><span class="s3">)</span>
            <span class="s1">outputs</span><span class="s3">[</span><span class="s1">case</span><span class="s3">] = (</span><span class="s1">X_trans</span><span class="s3">, </span><span class="s1">transformer</span><span class="s3">.</span><span class="s1">get_feature_names_out</span><span class="s3">())</span>

    <span class="s5"># fit_transform case:</span>
    <span class="s1">cases </span><span class="s3">= [</span>
        <span class="s3">(</span><span class="s4">&quot;fit_transform/df&quot;</span><span class="s3">, </span><span class="s1">df</span><span class="s3">),</span>
        <span class="s3">(</span><span class="s4">&quot;fit_transform/array&quot;</span><span class="s3">, </span><span class="s1">X</span><span class="s3">),</span>
    <span class="s3">]</span>
    <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">transformer</span><span class="s3">, </span><span class="s4">&quot;fit_transform&quot;</span><span class="s3">):</span>
        <span class="s2">for </span><span class="s1">case</span><span class="s3">, </span><span class="s1">data </span><span class="s2">in </span><span class="s1">cases</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">CROSS_DECOMPOSITION</span><span class="s3">:</span>
                <span class="s1">X_trans</span><span class="s3">, </span><span class="s1">_ </span><span class="s3">= </span><span class="s1">transformer</span><span class="s3">.</span><span class="s1">fit_transform</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">X_trans </span><span class="s3">= </span><span class="s1">transformer</span><span class="s3">.</span><span class="s1">fit_transform</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
            <span class="s1">outputs</span><span class="s3">[</span><span class="s1">case</span><span class="s3">] = (</span><span class="s1">X_trans</span><span class="s3">, </span><span class="s1">transformer</span><span class="s3">.</span><span class="s1">get_feature_names_out</span><span class="s3">())</span>

    <span class="s2">return </span><span class="s1">outputs</span>


<span class="s2">def </span><span class="s1">_check_generated_dataframe</span><span class="s3">(</span>
    <span class="s1">name</span><span class="s3">,</span>
    <span class="s1">case</span><span class="s3">,</span>
    <span class="s1">index</span><span class="s3">,</span>
    <span class="s1">outputs_default</span><span class="s3">,</span>
    <span class="s1">outputs_dataframe_lib</span><span class="s3">,</span>
    <span class="s1">is_supported_dataframe</span><span class="s3">,</span>
    <span class="s1">create_dataframe</span><span class="s3">,</span>
    <span class="s1">assert_frame_equal</span><span class="s3">,</span>
<span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Check if the generated DataFrame by the transformer is valid. 
 
    The DataFrame implementation is specified through the parameters of this function. 
 
    Parameters 
    ---------- 
    name : str 
        The name of the transformer. 
    case : str 
        A single case from the cases generated by `_output_from_fit_transform`. 
    index : index or None 
        The index of the DataFrame. `None` if the library does not implement a DataFrame 
        with an index. 
    outputs_default : tuple 
        A tuple containing the output data and feature names for the default output. 
    outputs_dataframe_lib : tuple 
        A tuple containing the output data and feature names for the pandas case. 
    is_supported_dataframe : callable 
        A callable that takes a DataFrame instance as input and return whether or 
        E.g. `lambda X: isintance(X, pd.DataFrame)`. 
    create_dataframe : callable 
        A callable taking as parameters `data`, `columns`, and `index` and returns 
        a callable. Be aware that `index` can be ignored. For example, polars dataframes 
        would ignore the idnex. 
    assert_frame_equal : callable 
        A callable taking 2 dataframes to compare if they are equal. 
    &quot;&quot;&quot;</span>
    <span class="s1">X_trans</span><span class="s3">, </span><span class="s1">feature_names_default </span><span class="s3">= </span><span class="s1">outputs_default</span>
    <span class="s1">df_trans</span><span class="s3">, </span><span class="s1">feature_names_dataframe_lib </span><span class="s3">= </span><span class="s1">outputs_dataframe_lib</span>

    <span class="s2">assert </span><span class="s1">is_supported_dataframe</span><span class="s3">(</span><span class="s1">df_trans</span><span class="s3">)</span>
    <span class="s5"># We always rely on the output of `get_feature_names_out` of the</span>
    <span class="s5"># transformer used to generate the dataframe as a ground-truth of the</span>
    <span class="s5"># columns.</span>
    <span class="s5"># If a dataframe is passed into transform, then the output should have the same</span>
    <span class="s5"># index</span>
    <span class="s1">expected_index </span><span class="s3">= </span><span class="s1">index </span><span class="s2">if </span><span class="s1">case</span><span class="s3">.</span><span class="s1">endswith</span><span class="s3">(</span><span class="s4">&quot;df&quot;</span><span class="s3">) </span><span class="s2">else None</span>
    <span class="s1">expected_dataframe </span><span class="s3">= </span><span class="s1">create_dataframe</span><span class="s3">(</span>
        <span class="s1">X_trans</span><span class="s3">, </span><span class="s1">columns</span><span class="s3">=</span><span class="s1">feature_names_dataframe_lib</span><span class="s3">, </span><span class="s1">index</span><span class="s3">=</span><span class="s1">expected_index</span>
    <span class="s3">)</span>

    <span class="s2">try</span><span class="s3">:</span>
        <span class="s1">assert_frame_equal</span><span class="s3">(</span><span class="s1">df_trans</span><span class="s3">, </span><span class="s1">expected_dataframe</span><span class="s3">)</span>
    <span class="s2">except </span><span class="s1">AssertionError </span><span class="s2">as </span><span class="s1">e</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">AssertionError</span><span class="s3">(</span>
            <span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">name</span><span class="s2">} </span><span class="s4">does not generate a valid dataframe in the </span><span class="s2">{</span><span class="s1">case</span><span class="s2">} </span><span class="s4">&quot;</span>
            <span class="s4">&quot;case. The generated dataframe is not equal to the expected &quot;</span>
            <span class="s4">f&quot;dataframe. The error message is: </span><span class="s2">{</span><span class="s1">e</span><span class="s2">}</span><span class="s4">&quot;</span>
        <span class="s3">) </span><span class="s2">from </span><span class="s1">e</span>


<span class="s2">def </span><span class="s1">_check_set_output_transform_dataframe</span><span class="s3">(</span>
    <span class="s1">name</span><span class="s3">,</span>
    <span class="s1">transformer_orig</span><span class="s3">,</span>
    <span class="s3">*,</span>
    <span class="s1">dataframe_lib</span><span class="s3">,</span>
    <span class="s1">is_supported_dataframe</span><span class="s3">,</span>
    <span class="s1">create_dataframe</span><span class="s3">,</span>
    <span class="s1">assert_frame_equal</span><span class="s3">,</span>
    <span class="s1">context</span><span class="s3">,</span>
<span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Check that a transformer can output a DataFrame when requested. 
 
    The DataFrame implementation is specified through the parameters of this function. 
 
    Parameters 
    ---------- 
    name : str 
        The name of the transformer. 
    transformer_orig : estimator 
        The original transformer instance. 
    dataframe_lib : str 
        The name of the library implementing the DataFrame. 
    is_supported_dataframe : callable 
        A callable that takes a DataFrame instance as input and returns whether or 
        not it is supported by the dataframe library. 
        E.g. `lambda X: isintance(X, pd.DataFrame)`. 
    create_dataframe : callable 
        A callable taking as parameters `data`, `columns`, and `index` and returns 
        a callable. Be aware that `index` can be ignored. For example, polars dataframes 
        will ignore the index. 
    assert_frame_equal : callable 
        A callable taking 2 dataframes to compare if they are equal. 
    context : {&quot;local&quot;, &quot;global&quot;} 
        Whether to use a local context by setting `set_output(...)` on the transformer 
        or a global context by using the `with config_context(...)` 
    &quot;&quot;&quot;</span>
    <span class="s5"># Check transformer.set_output configures the output of transform=&quot;pandas&quot;.</span>
    <span class="s1">tags </span><span class="s3">= </span><span class="s1">transformer_orig</span><span class="s3">.</span><span class="s1">_get_tags</span><span class="s3">()</span>
    <span class="s2">if </span><span class="s4">&quot;2darray&quot; </span><span class="s2">not in </span><span class="s1">tags</span><span class="s3">[</span><span class="s4">&quot;X_types&quot;</span><span class="s3">] </span><span class="s2">or </span><span class="s1">tags</span><span class="s3">[</span><span class="s4">&quot;no_validation&quot;</span><span class="s3">]:</span>
        <span class="s2">return</span>

    <span class="s1">rng </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">RandomState</span><span class="s3">(</span><span class="s6">0</span><span class="s3">)</span>
    <span class="s1">transformer </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">transformer_orig</span><span class="s3">)</span>

    <span class="s1">X </span><span class="s3">= </span><span class="s1">rng</span><span class="s3">.</span><span class="s1">uniform</span><span class="s3">(</span><span class="s1">size</span><span class="s3">=(</span><span class="s6">20</span><span class="s3">, </span><span class="s6">5</span><span class="s3">))</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">_enforce_estimator_tags_X</span><span class="s3">(</span><span class="s1">transformer_orig</span><span class="s3">, </span><span class="s1">X</span><span class="s3">)</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">rng</span><span class="s3">.</span><span class="s1">randint</span><span class="s3">(</span><span class="s6">0</span><span class="s3">, </span><span class="s6">2</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=</span><span class="s6">20</span><span class="s3">)</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">_enforce_estimator_tags_y</span><span class="s3">(</span><span class="s1">transformer_orig</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
    <span class="s1">set_random_state</span><span class="s3">(</span><span class="s1">transformer</span><span class="s3">)</span>

    <span class="s1">feature_names_in </span><span class="s3">= [</span><span class="s4">f&quot;col</span><span class="s2">{</span><span class="s1">i</span><span class="s2">}</span><span class="s4">&quot; </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s6">1</span><span class="s3">])]</span>
    <span class="s1">index </span><span class="s3">= [</span><span class="s4">f&quot;index</span><span class="s2">{</span><span class="s1">i</span><span class="s2">}</span><span class="s4">&quot; </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s6">0</span><span class="s3">])]</span>
    <span class="s1">df </span><span class="s3">= </span><span class="s1">create_dataframe</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">columns</span><span class="s3">=</span><span class="s1">feature_names_in</span><span class="s3">, </span><span class="s1">index</span><span class="s3">=</span><span class="s1">index</span><span class="s3">)</span>

    <span class="s1">transformer_default </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">transformer</span><span class="s3">).</span><span class="s1">set_output</span><span class="s3">(</span><span class="s1">transform</span><span class="s3">=</span><span class="s4">&quot;default&quot;</span><span class="s3">)</span>
    <span class="s1">outputs_default </span><span class="s3">= </span><span class="s1">_output_from_fit_transform</span><span class="s3">(</span><span class="s1">transformer_default</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">df</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">context </span><span class="s3">== </span><span class="s4">&quot;local&quot;</span><span class="s3">:</span>
        <span class="s1">transformer_df </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">transformer</span><span class="s3">).</span><span class="s1">set_output</span><span class="s3">(</span><span class="s1">transform</span><span class="s3">=</span><span class="s1">dataframe_lib</span><span class="s3">)</span>
        <span class="s1">context_to_use </span><span class="s3">= </span><span class="s1">nullcontext</span><span class="s3">()</span>
    <span class="s2">else</span><span class="s3">:  </span><span class="s5"># global</span>
        <span class="s1">transformer_df </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">transformer</span><span class="s3">)</span>
        <span class="s1">context_to_use </span><span class="s3">= </span><span class="s1">config_context</span><span class="s3">(</span><span class="s1">transform_output</span><span class="s3">=</span><span class="s1">dataframe_lib</span><span class="s3">)</span>

    <span class="s2">try</span><span class="s3">:</span>
        <span class="s2">with </span><span class="s1">context_to_use</span><span class="s3">:</span>
            <span class="s1">outputs_df </span><span class="s3">= </span><span class="s1">_output_from_fit_transform</span><span class="s3">(</span><span class="s1">transformer_df</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">df</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
    <span class="s2">except </span><span class="s1">ValueError </span><span class="s2">as </span><span class="s1">e</span><span class="s3">:</span>
        <span class="s5"># transformer does not support sparse data</span>
        <span class="s1">capitalized_lib </span><span class="s3">= </span><span class="s1">dataframe_lib</span><span class="s3">.</span><span class="s1">capitalize</span><span class="s3">()</span>
        <span class="s1">error_message </span><span class="s3">= </span><span class="s1">str</span><span class="s3">(</span><span class="s1">e</span><span class="s3">)</span>
        <span class="s2">assert </span><span class="s3">(</span>
            <span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">capitalized_lib</span><span class="s2">} </span><span class="s4">output does not support sparse data.&quot; </span><span class="s2">in </span><span class="s1">error_message</span>
            <span class="s2">or </span><span class="s4">&quot;The transformer outputs a scipy sparse matrix.&quot; </span><span class="s2">in </span><span class="s1">error_message</span>
        <span class="s3">), </span><span class="s1">e</span>
        <span class="s2">return</span>

    <span class="s2">for </span><span class="s1">case </span><span class="s2">in </span><span class="s1">outputs_default</span><span class="s3">:</span>
        <span class="s1">_check_generated_dataframe</span><span class="s3">(</span>
            <span class="s1">name</span><span class="s3">,</span>
            <span class="s1">case</span><span class="s3">,</span>
            <span class="s1">index</span><span class="s3">,</span>
            <span class="s1">outputs_default</span><span class="s3">[</span><span class="s1">case</span><span class="s3">],</span>
            <span class="s1">outputs_df</span><span class="s3">[</span><span class="s1">case</span><span class="s3">],</span>
            <span class="s1">is_supported_dataframe</span><span class="s3">,</span>
            <span class="s1">create_dataframe</span><span class="s3">,</span>
            <span class="s1">assert_frame_equal</span><span class="s3">,</span>
        <span class="s3">)</span>


<span class="s2">def </span><span class="s1">_check_set_output_transform_pandas_context</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">transformer_orig</span><span class="s3">, </span><span class="s1">context</span><span class="s3">):</span>
    <span class="s2">try</span><span class="s3">:</span>
        <span class="s2">import </span><span class="s1">pandas </span><span class="s2">as </span><span class="s1">pd</span>
    <span class="s2">except </span><span class="s1">ImportError</span><span class="s3">:  </span><span class="s5"># pragma: no cover</span>
        <span class="s2">raise </span><span class="s1">SkipTest</span><span class="s3">(</span><span class="s4">&quot;pandas is not installed: not checking set output&quot;</span><span class="s3">)</span>

    <span class="s1">_check_set_output_transform_dataframe</span><span class="s3">(</span>
        <span class="s1">name</span><span class="s3">,</span>
        <span class="s1">transformer_orig</span><span class="s3">,</span>
        <span class="s1">dataframe_lib</span><span class="s3">=</span><span class="s4">&quot;pandas&quot;</span><span class="s3">,</span>
        <span class="s1">is_supported_dataframe</span><span class="s3">=</span><span class="s2">lambda </span><span class="s1">X</span><span class="s3">: </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">pd</span><span class="s3">.</span><span class="s1">DataFrame</span><span class="s3">),</span>
        <span class="s1">create_dataframe</span><span class="s3">=</span><span class="s2">lambda </span><span class="s1">X</span><span class="s3">, </span><span class="s1">columns</span><span class="s3">, </span><span class="s1">index</span><span class="s3">: </span><span class="s1">pd</span><span class="s3">.</span><span class="s1">DataFrame</span><span class="s3">(</span>
            <span class="s1">X</span><span class="s3">, </span><span class="s1">columns</span><span class="s3">=</span><span class="s1">columns</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">index</span><span class="s3">=</span><span class="s1">index</span>
        <span class="s3">),</span>
        <span class="s1">assert_frame_equal</span><span class="s3">=</span><span class="s1">pd</span><span class="s3">.</span><span class="s1">testing</span><span class="s3">.</span><span class="s1">assert_frame_equal</span><span class="s3">,</span>
        <span class="s1">context</span><span class="s3">=</span><span class="s1">context</span><span class="s3">,</span>
    <span class="s3">)</span>


<span class="s2">def </span><span class="s1">check_set_output_transform_pandas</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">transformer_orig</span><span class="s3">):</span>
    <span class="s1">_check_set_output_transform_pandas_context</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">transformer_orig</span><span class="s3">, </span><span class="s4">&quot;local&quot;</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">check_global_output_transform_pandas</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">transformer_orig</span><span class="s3">):</span>
    <span class="s1">_check_set_output_transform_pandas_context</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">transformer_orig</span><span class="s3">, </span><span class="s4">&quot;global&quot;</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">_check_set_output_transform_polars_context</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">transformer_orig</span><span class="s3">, </span><span class="s1">context</span><span class="s3">):</span>
    <span class="s2">try</span><span class="s3">:</span>
        <span class="s2">import </span><span class="s1">polars </span><span class="s2">as </span><span class="s1">pl</span>
        <span class="s2">from </span><span class="s1">polars</span><span class="s3">.</span><span class="s1">testing </span><span class="s2">import </span><span class="s1">assert_frame_equal</span>
    <span class="s2">except </span><span class="s1">ImportError</span><span class="s3">:  </span><span class="s5"># pragma: no cover</span>
        <span class="s2">raise </span><span class="s1">SkipTest</span><span class="s3">(</span><span class="s4">&quot;polars is not installed: not checking set output&quot;</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">create_dataframe</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">columns</span><span class="s3">, </span><span class="s1">index</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">columns</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndarray</span><span class="s3">):</span>
            <span class="s1">columns </span><span class="s3">= </span><span class="s1">columns</span><span class="s3">.</span><span class="s1">tolist</span><span class="s3">()</span>

        <span class="s2">return </span><span class="s1">pl</span><span class="s3">.</span><span class="s1">DataFrame</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">schema</span><span class="s3">=</span><span class="s1">columns</span><span class="s3">, </span><span class="s1">orient</span><span class="s3">=</span><span class="s4">&quot;row&quot;</span><span class="s3">)</span>

    <span class="s1">_check_set_output_transform_dataframe</span><span class="s3">(</span>
        <span class="s1">name</span><span class="s3">,</span>
        <span class="s1">transformer_orig</span><span class="s3">,</span>
        <span class="s1">dataframe_lib</span><span class="s3">=</span><span class="s4">&quot;polars&quot;</span><span class="s3">,</span>
        <span class="s1">is_supported_dataframe</span><span class="s3">=</span><span class="s2">lambda </span><span class="s1">X</span><span class="s3">: </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">pl</span><span class="s3">.</span><span class="s1">DataFrame</span><span class="s3">),</span>
        <span class="s1">create_dataframe</span><span class="s3">=</span><span class="s1">create_dataframe</span><span class="s3">,</span>
        <span class="s1">assert_frame_equal</span><span class="s3">=</span><span class="s1">assert_frame_equal</span><span class="s3">,</span>
        <span class="s1">context</span><span class="s3">=</span><span class="s1">context</span><span class="s3">,</span>
    <span class="s3">)</span>


<span class="s2">def </span><span class="s1">check_set_output_transform_polars</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">transformer_orig</span><span class="s3">):</span>
    <span class="s1">_check_set_output_transform_polars_context</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">transformer_orig</span><span class="s3">, </span><span class="s4">&quot;local&quot;</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">check_global_set_output_transform_polars</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">transformer_orig</span><span class="s3">):</span>
    <span class="s1">_check_set_output_transform_polars_context</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">transformer_orig</span><span class="s3">, </span><span class="s4">&quot;global&quot;</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">ignore_warnings</span><span class="s3">(</span><span class="s1">category</span><span class="s3">=</span><span class="s1">FutureWarning</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">check_inplace_ensure_writeable</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">estimator_orig</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Check that estimators able to do inplace operations can work on read-only 
    input data even if a copy is not explicitly requested by the user. 
 
    Make sure that a copy is made and consequently that the input array and its 
    writeability are not modified by the estimator. 
    &quot;&quot;&quot;</span>
    <span class="s1">rng </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">RandomState</span><span class="s3">(</span><span class="s6">0</span><span class="s3">)</span>

    <span class="s1">estimator </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">estimator_orig</span><span class="s3">)</span>
    <span class="s1">set_random_state</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">)</span>

    <span class="s1">n_samples </span><span class="s3">= </span><span class="s6">100</span>

    <span class="s1">X</span><span class="s3">, </span><span class="s1">_ </span><span class="s3">= </span><span class="s1">make_blobs</span><span class="s3">(</span><span class="s1">n_samples</span><span class="s3">=</span><span class="s1">n_samples</span><span class="s3">, </span><span class="s1">n_features</span><span class="s3">=</span><span class="s6">3</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s1">rng</span><span class="s3">)</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">_enforce_estimator_tags_X</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">X</span><span class="s3">)</span>

    <span class="s5"># These estimators can only work inplace with fortran ordered input</span>
    <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s3">(</span><span class="s4">&quot;Lasso&quot;</span><span class="s3">, </span><span class="s4">&quot;ElasticNet&quot;</span><span class="s3">, </span><span class="s4">&quot;MultiTaskElasticNet&quot;</span><span class="s3">, </span><span class="s4">&quot;MultiTaskLasso&quot;</span><span class="s3">):</span>
        <span class="s1">X </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asfortranarray</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>

    <span class="s5"># Add a missing value for imputers so that transform has to do something</span>
    <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s4">&quot;missing_values&quot;</span><span class="s3">):</span>
        <span class="s1">X</span><span class="s3">[</span><span class="s6">0</span><span class="s3">, </span><span class="s6">0</span><span class="s3">] = </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span>

    <span class="s2">if </span><span class="s1">is_regressor</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">):</span>
        <span class="s1">y </span><span class="s3">= </span><span class="s1">rng</span><span class="s3">.</span><span class="s1">normal</span><span class="s3">(</span><span class="s1">size</span><span class="s3">=</span><span class="s1">n_samples</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">y </span><span class="s3">= </span><span class="s1">rng</span><span class="s3">.</span><span class="s1">randint</span><span class="s3">(</span><span class="s1">low</span><span class="s3">=</span><span class="s6">0</span><span class="s3">, </span><span class="s1">high</span><span class="s3">=</span><span class="s6">2</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=</span><span class="s1">n_samples</span><span class="s3">)</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">_enforce_estimator_tags_y</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>

    <span class="s1">X_copy </span><span class="s3">= </span><span class="s1">X</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>

    <span class="s5"># Make X read-only</span>
    <span class="s1">X</span><span class="s3">.</span><span class="s1">setflags</span><span class="s3">(</span><span class="s1">write</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>

    <span class="s1">estimator</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s4">&quot;transform&quot;</span><span class="s3">):</span>
        <span class="s1">estimator</span><span class="s3">.</span><span class="s1">transform</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>

    <span class="s2">assert not </span><span class="s1">X</span><span class="s3">.</span><span class="s1">flags</span><span class="s3">.</span><span class="s1">writeable</span>
    <span class="s1">assert_allclose</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">X_copy</span><span class="s3">)</span>
</pre>
</body>
</html>