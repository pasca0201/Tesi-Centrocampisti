<html>
<head>
<title>_peak_finding.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #6aab73;}
.s5 { color: #2aacb8;}
.s6 { color: #7a7e85;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_peak_finding.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Functions for identifying peaks in signals. 
&quot;&quot;&quot;</span>
<span class="s2">import </span><span class="s1">math</span>
<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>

<span class="s2">from </span><span class="s1">scipy</span><span class="s3">.</span><span class="s1">signal</span><span class="s3">.</span><span class="s1">_wavelets </span><span class="s2">import </span><span class="s1">_cwt</span><span class="s3">, </span><span class="s1">_ricker</span>
<span class="s2">from </span><span class="s1">scipy</span><span class="s3">.</span><span class="s1">stats </span><span class="s2">import </span><span class="s1">scoreatpercentile</span>

<span class="s2">from </span><span class="s3">.</span><span class="s1">_peak_finding_utils </span><span class="s2">import </span><span class="s3">(</span>
    <span class="s1">_local_maxima_1d</span><span class="s3">,</span>
    <span class="s1">_select_by_peak_distance</span><span class="s3">,</span>
    <span class="s1">_peak_prominences</span><span class="s3">,</span>
    <span class="s1">_peak_widths</span>
<span class="s3">)</span>


<span class="s1">__all__ </span><span class="s3">= [</span><span class="s4">'argrelmin'</span><span class="s3">, </span><span class="s4">'argrelmax'</span><span class="s3">, </span><span class="s4">'argrelextrema'</span><span class="s3">, </span><span class="s4">'peak_prominences'</span><span class="s3">,</span>
           <span class="s4">'peak_widths'</span><span class="s3">, </span><span class="s4">'find_peaks'</span><span class="s3">, </span><span class="s4">'find_peaks_cwt'</span><span class="s3">]</span>


<span class="s2">def </span><span class="s1">_boolrelextrema</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">comparator</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">order</span><span class="s3">=</span><span class="s5">1</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">=</span><span class="s4">'clip'</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Calculate the relative extrema of `data`. 
 
    Relative extrema are calculated by finding locations where 
    ``comparator(data[n], data[n+1:n+order+1])`` is True. 
 
    Parameters 
    ---------- 
    data : ndarray 
        Array in which to find the relative extrema. 
    comparator : callable 
        Function to use to compare two data points. 
        Should take two arrays as arguments. 
    axis : int, optional 
        Axis over which to select from `data`. Default is 0. 
    order : int, optional 
        How many points on each side to use for the comparison 
        to consider ``comparator(n,n+x)`` to be True. 
    mode : str, optional 
        How the edges of the vector are treated. 'wrap' (wrap around) or 
        'clip' (treat overflow as the same as the last (or first) element). 
        Default 'clip'. See numpy.take. 
 
    Returns 
    ------- 
    extrema : ndarray 
        Boolean array of the same shape as `data` that is True at an extrema, 
        False otherwise. 
 
    See also 
    -------- 
    argrelmax, argrelmin 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.signal._peak_finding import _boolrelextrema 
    &gt;&gt;&gt; testdata = np.array([1,2,3,2,1]) 
    &gt;&gt;&gt; _boolrelextrema(testdata, np.greater, axis=0) 
    array([False, False,  True, False, False], dtype=bool) 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">int</span><span class="s3">(</span><span class="s1">order</span><span class="s3">) != </span><span class="s1">order</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">order </span><span class="s3">&lt; </span><span class="s5">1</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'Order must be an int &gt;= 1'</span><span class="s3">)</span>

    <span class="s1">datalen </span><span class="s3">= </span><span class="s1">data</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s1">axis</span><span class="s3">]</span>
    <span class="s1">locs </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">datalen</span><span class="s3">)</span>

    <span class="s1">results </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">data</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">bool</span><span class="s3">)</span>
    <span class="s1">main </span><span class="s3">= </span><span class="s1">data</span><span class="s3">.</span><span class="s1">take</span><span class="s3">(</span><span class="s1">locs</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">=</span><span class="s1">mode</span><span class="s3">)</span>
    <span class="s2">for </span><span class="s1">shift </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s5">1</span><span class="s3">, </span><span class="s1">order </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">):</span>
        <span class="s1">plus </span><span class="s3">= </span><span class="s1">data</span><span class="s3">.</span><span class="s1">take</span><span class="s3">(</span><span class="s1">locs </span><span class="s3">+ </span><span class="s1">shift</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">=</span><span class="s1">mode</span><span class="s3">)</span>
        <span class="s1">minus </span><span class="s3">= </span><span class="s1">data</span><span class="s3">.</span><span class="s1">take</span><span class="s3">(</span><span class="s1">locs </span><span class="s3">- </span><span class="s1">shift</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">=</span><span class="s1">mode</span><span class="s3">)</span>
        <span class="s1">results </span><span class="s3">&amp;= </span><span class="s1">comparator</span><span class="s3">(</span><span class="s1">main</span><span class="s3">, </span><span class="s1">plus</span><span class="s3">)</span>
        <span class="s1">results </span><span class="s3">&amp;= </span><span class="s1">comparator</span><span class="s3">(</span><span class="s1">main</span><span class="s3">, </span><span class="s1">minus</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s3">~</span><span class="s1">results</span><span class="s3">.</span><span class="s1">any</span><span class="s3">():</span>
            <span class="s2">return </span><span class="s1">results</span>
    <span class="s2">return </span><span class="s1">results</span>


<span class="s2">def </span><span class="s1">argrelmin</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">order</span><span class="s3">=</span><span class="s5">1</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">=</span><span class="s4">'clip'</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Calculate the relative minima of `data`. 
 
    Parameters 
    ---------- 
    data : ndarray 
        Array in which to find the relative minima. 
    axis : int, optional 
        Axis over which to select from `data`. Default is 0. 
    order : int, optional 
        How many points on each side to use for the comparison 
        to consider ``comparator(n, n+x)`` to be True. 
    mode : str, optional 
        How the edges of the vector are treated. 
        Available options are 'wrap' (wrap around) or 'clip' (treat overflow 
        as the same as the last (or first) element). 
        Default 'clip'. See numpy.take. 
 
    Returns 
    ------- 
    extrema : tuple of ndarrays 
        Indices of the minima in arrays of integers. ``extrema[k]`` is 
        the array of indices of axis `k` of `data`. Note that the 
        return value is a tuple even when `data` is 1-D. 
 
    See Also 
    -------- 
    argrelextrema, argrelmax, find_peaks 
 
    Notes 
    ----- 
    This function uses `argrelextrema` with np.less as comparator. Therefore, it 
    requires a strict inequality on both sides of a value to consider it a 
    minimum. This means flat minima (more than one sample wide) are not detected. 
    In case of 1-D `data` `find_peaks` can be used to detect all 
    local minima, including flat ones, by calling it with negated `data`. 
 
    .. versionadded:: 0.11.0 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.signal import argrelmin 
    &gt;&gt;&gt; x = np.array([2, 1, 2, 3, 2, 0, 1, 0]) 
    &gt;&gt;&gt; argrelmin(x) 
    (array([1, 5]),) 
    &gt;&gt;&gt; y = np.array([[1, 2, 1, 2], 
    ...               [2, 2, 0, 0], 
    ...               [5, 3, 4, 4]]) 
    ... 
    &gt;&gt;&gt; argrelmin(y, axis=1) 
    (array([0, 2]), array([2, 1])) 
 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">argrelextrema</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">less</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">order</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">argrelmax</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">order</span><span class="s3">=</span><span class="s5">1</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">=</span><span class="s4">'clip'</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Calculate the relative maxima of `data`. 
 
    Parameters 
    ---------- 
    data : ndarray 
        Array in which to find the relative maxima. 
    axis : int, optional 
        Axis over which to select from `data`. Default is 0. 
    order : int, optional 
        How many points on each side to use for the comparison 
        to consider ``comparator(n, n+x)`` to be True. 
    mode : str, optional 
        How the edges of the vector are treated. 
        Available options are 'wrap' (wrap around) or 'clip' (treat overflow 
        as the same as the last (or first) element). 
        Default 'clip'. See `numpy.take`. 
 
    Returns 
    ------- 
    extrema : tuple of ndarrays 
        Indices of the maxima in arrays of integers. ``extrema[k]`` is 
        the array of indices of axis `k` of `data`. Note that the 
        return value is a tuple even when `data` is 1-D. 
 
    See Also 
    -------- 
    argrelextrema, argrelmin, find_peaks 
 
    Notes 
    ----- 
    This function uses `argrelextrema` with np.greater as comparator. Therefore, 
    it  requires a strict inequality on both sides of a value to consider it a 
    maximum. This means flat maxima (more than one sample wide) are not detected. 
    In case of 1-D `data` `find_peaks` can be used to detect all 
    local maxima, including flat ones. 
 
    .. versionadded:: 0.11.0 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.signal import argrelmax 
    &gt;&gt;&gt; x = np.array([2, 1, 2, 3, 2, 0, 1, 0]) 
    &gt;&gt;&gt; argrelmax(x) 
    (array([3, 6]),) 
    &gt;&gt;&gt; y = np.array([[1, 2, 1, 2], 
    ...               [2, 2, 0, 0], 
    ...               [5, 3, 4, 4]]) 
    ... 
    &gt;&gt;&gt; argrelmax(y, axis=1) 
    (array([0]), array([1])) 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">argrelextrema</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">greater</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">order</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">argrelextrema</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">comparator</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">order</span><span class="s3">=</span><span class="s5">1</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">=</span><span class="s4">'clip'</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Calculate the relative extrema of `data`. 
 
    Parameters 
    ---------- 
    data : ndarray 
        Array in which to find the relative extrema. 
    comparator : callable 
        Function to use to compare two data points. 
        Should take two arrays as arguments. 
    axis : int, optional 
        Axis over which to select from `data`. Default is 0. 
    order : int, optional 
        How many points on each side to use for the comparison 
        to consider ``comparator(n, n+x)`` to be True. 
    mode : str, optional 
        How the edges of the vector are treated. 'wrap' (wrap around) or 
        'clip' (treat overflow as the same as the last (or first) element). 
        Default is 'clip'. See `numpy.take`. 
 
    Returns 
    ------- 
    extrema : tuple of ndarrays 
        Indices of the maxima in arrays of integers. ``extrema[k]`` is 
        the array of indices of axis `k` of `data`. Note that the 
        return value is a tuple even when `data` is 1-D. 
 
    See Also 
    -------- 
    argrelmin, argrelmax 
 
    Notes 
    ----- 
 
    .. versionadded:: 0.11.0 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.signal import argrelextrema 
    &gt;&gt;&gt; x = np.array([2, 1, 2, 3, 2, 0, 1, 0]) 
    &gt;&gt;&gt; argrelextrema(x, np.greater) 
    (array([3, 6]),) 
    &gt;&gt;&gt; y = np.array([[1, 2, 1, 2], 
    ...               [2, 2, 0, 0], 
    ...               [5, 3, 4, 4]]) 
    ... 
    &gt;&gt;&gt; argrelextrema(y, np.less, axis=1) 
    (array([0, 2]), array([2, 1])) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">results </span><span class="s3">= </span><span class="s1">_boolrelextrema</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">comparator</span><span class="s3">,</span>
                              <span class="s1">axis</span><span class="s3">, </span><span class="s1">order</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nonzero</span><span class="s3">(</span><span class="s1">results</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">_arg_x_as_expected</span><span class="s3">(</span><span class="s1">value</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Ensure argument `x` is a 1-D C-contiguous array of dtype('float64'). 
 
    Used in `find_peaks`, `peak_prominences` and `peak_widths` to make `x` 
    compatible with the signature of the wrapped Cython functions. 
 
    Returns 
    ------- 
    value : ndarray 
        A 1-D C-contiguous array with dtype('float64'). 
    &quot;&quot;&quot;</span>
    <span class="s1">value </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">order</span><span class="s3">=</span><span class="s4">'C'</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">value</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">!= </span><span class="s5">1</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'`x` must be a 1-D array'</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">value</span>


<span class="s2">def </span><span class="s1">_arg_peaks_as_expected</span><span class="s3">(</span><span class="s1">value</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Ensure argument `peaks` is a 1-D C-contiguous array of dtype('intp'). 
 
    Used in `peak_prominences` and `peak_widths` to make `peaks` compatible 
    with the signature of the wrapped Cython functions. 
 
    Returns 
    ------- 
    value : ndarray 
        A 1-D C-contiguous array with dtype('intp'). 
    &quot;&quot;&quot;</span>
    <span class="s1">value </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">value</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">value</span><span class="s3">.</span><span class="s1">size </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s6"># Empty arrays default to np.float64 but are valid input</span>
        <span class="s1">value </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([], </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">)</span>
    <span class="s2">try</span><span class="s3">:</span>
        <span class="s6"># Safely convert to C-contiguous array of type np.intp</span>
        <span class="s1">value </span><span class="s3">= </span><span class="s1">value</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">, </span><span class="s1">order</span><span class="s3">=</span><span class="s4">'C'</span><span class="s3">, </span><span class="s1">casting</span><span class="s3">=</span><span class="s4">'safe'</span><span class="s3">,</span>
                             <span class="s1">subok</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
    <span class="s2">except </span><span class="s1">TypeError </span><span class="s2">as </span><span class="s1">e</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s4">&quot;cannot safely cast `peaks` to dtype('intp')&quot;</span><span class="s3">) </span><span class="s2">from </span><span class="s1">e</span>
    <span class="s2">if </span><span class="s1">value</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">!= </span><span class="s5">1</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'`peaks` must be a 1-D array'</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">value</span>


<span class="s2">def </span><span class="s1">_arg_wlen_as_expected</span><span class="s3">(</span><span class="s1">value</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Ensure argument `wlen` is of type `np.intp` and larger than 1. 
 
    Used in `peak_prominences` and `peak_widths`. 
 
    Returns 
    ------- 
    value : np.intp 
        The original `value` rounded up to an integer or -1 if `value` was 
        None. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">value </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s6"># _peak_prominences expects an intp; -1 signals that no value was</span>
        <span class="s6"># supplied by the user</span>
        <span class="s1">value </span><span class="s3">= -</span><span class="s5">1</span>
    <span class="s2">elif </span><span class="s5">1 </span><span class="s3">&lt; </span><span class="s1">value</span><span class="s3">:</span>
        <span class="s6"># Round up to a positive integer</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">float</span><span class="s3">):</span>
            <span class="s1">value </span><span class="s3">= </span><span class="s1">math</span><span class="s3">.</span><span class="s1">ceil</span><span class="s3">(</span><span class="s1">value</span><span class="s3">)</span>
        <span class="s1">value </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">(</span><span class="s1">value</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">f'`wlen` must be larger than 1, was </span><span class="s2">{</span><span class="s1">value</span><span class="s2">}</span><span class="s4">'</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">value</span>


<span class="s2">def </span><span class="s1">peak_prominences</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">peaks</span><span class="s3">, </span><span class="s1">wlen</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Calculate the prominence of each peak in a signal. 
 
    The prominence of a peak measures how much a peak stands out from the 
    surrounding baseline of the signal and is defined as the vertical distance 
    between the peak and its lowest contour line. 
 
    Parameters 
    ---------- 
    x : sequence 
        A signal with peaks. 
    peaks : sequence 
        Indices of peaks in `x`. 
    wlen : int, optional 
        A window length in samples that optionally limits the evaluated area for 
        each peak to a subset of `x`. The peak is always placed in the middle of 
        the window therefore the given length is rounded up to the next odd 
        integer. This parameter can speed up the calculation (see Notes). 
 
    Returns 
    ------- 
    prominences : ndarray 
        The calculated prominences for each peak in `peaks`. 
    left_bases, right_bases : ndarray 
        The peaks' bases as indices in `x` to the left and right of each peak. 
        The higher base of each pair is a peak's lowest contour line. 
 
    Raises 
    ------ 
    ValueError 
        If a value in `peaks` is an invalid index for `x`. 
 
    Warns 
    ----- 
    PeakPropertyWarning 
        For indices in `peaks` that don't point to valid local maxima in `x`, 
        the returned prominence will be 0 and this warning is raised. This 
        also happens if `wlen` is smaller than the plateau size of a peak. 
 
    Warnings 
    -------- 
    This function may return unexpected results for data containing NaNs. To 
    avoid this, NaNs should either be removed or replaced. 
 
    See Also 
    -------- 
    find_peaks 
        Find peaks inside a signal based on peak properties. 
    peak_widths 
        Calculate the width of peaks. 
 
    Notes 
    ----- 
    Strategy to compute a peak's prominence: 
 
    1. Extend a horizontal line from the current peak to the left and right 
       until the line either reaches the window border (see `wlen`) or 
       intersects the signal again at the slope of a higher peak. An 
       intersection with a peak of the same height is ignored. 
    2. On each side find the minimal signal value within the interval defined 
       above. These points are the peak's bases. 
    3. The higher one of the two bases marks the peak's lowest contour line. The 
       prominence can then be calculated as the vertical difference between the 
       peaks height itself and its lowest contour line. 
 
    Searching for the peak's bases can be slow for large `x` with periodic 
    behavior because large chunks or even the full signal need to be evaluated 
    for the first algorithmic step. This evaluation area can be limited with the 
    parameter `wlen` which restricts the algorithm to a window around the 
    current peak and can shorten the calculation time if the window length is 
    short in relation to `x`. 
    However, this may stop the algorithm from finding the true global contour 
    line if the peak's true bases are outside this window. Instead, a higher 
    contour line is found within the restricted window leading to a smaller 
    calculated prominence. In practice, this is only relevant for the highest set 
    of peaks in `x`. This behavior may even be used intentionally to calculate 
    &quot;local&quot; prominences. 
 
    .. versionadded:: 1.1.0 
 
    References 
    ---------- 
    .. [1] Wikipedia Article for Topographic Prominence: 
       https://en.wikipedia.org/wiki/Topographic_prominence 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.signal import find_peaks, peak_prominences 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
 
    Create a test signal with two overlaid harmonics 
 
    &gt;&gt;&gt; x = np.linspace(0, 6 * np.pi, 1000) 
    &gt;&gt;&gt; x = np.sin(x) + 0.6 * np.sin(2.6 * x) 
 
    Find all peaks and calculate prominences 
 
    &gt;&gt;&gt; peaks, _ = find_peaks(x) 
    &gt;&gt;&gt; prominences = peak_prominences(x, peaks)[0] 
    &gt;&gt;&gt; prominences 
    array([1.24159486, 0.47840168, 0.28470524, 3.10716793, 0.284603  , 
           0.47822491, 2.48340261, 0.47822491]) 
 
    Calculate the height of each peak's contour line and plot the results 
 
    &gt;&gt;&gt; contour_heights = x[peaks] - prominences 
    &gt;&gt;&gt; plt.plot(x) 
    &gt;&gt;&gt; plt.plot(peaks, x[peaks], &quot;x&quot;) 
    &gt;&gt;&gt; plt.vlines(x=peaks, ymin=contour_heights, ymax=x[peaks]) 
    &gt;&gt;&gt; plt.show() 
 
    Let's evaluate a second example that demonstrates several edge cases for 
    one peak at index 5. 
 
    &gt;&gt;&gt; x = np.array([0, 1, 0, 3, 1, 3, 0, 4, 0]) 
    &gt;&gt;&gt; peaks = np.array([5]) 
    &gt;&gt;&gt; plt.plot(x) 
    &gt;&gt;&gt; plt.plot(peaks, x[peaks], &quot;x&quot;) 
    &gt;&gt;&gt; plt.show() 
    &gt;&gt;&gt; peak_prominences(x, peaks)  # -&gt; (prominences, left_bases, right_bases) 
    (array([3.]), array([2]), array([6])) 
 
    Note how the peak at index 3 of the same height is not considered as a 
    border while searching for the left base. Instead, two minima at 0 and 2 
    are found in which case the one closer to the evaluated peak is always 
    chosen. On the right side, however, the base must be placed at 6 because the 
    higher peak represents the right border to the evaluated area. 
 
    &gt;&gt;&gt; peak_prominences(x, peaks, wlen=3.1) 
    (array([2.]), array([4]), array([6])) 
 
    Here, we restricted the algorithm to a window from 3 to 7 (the length is 5 
    samples because `wlen` was rounded up to the next odd integer). Thus, the 
    only two candidates in the evaluated area are the two neighboring samples 
    and a smaller prominence is calculated. 
    &quot;&quot;&quot;</span>
    <span class="s1">x </span><span class="s3">= </span><span class="s1">_arg_x_as_expected</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
    <span class="s1">peaks </span><span class="s3">= </span><span class="s1">_arg_peaks_as_expected</span><span class="s3">(</span><span class="s1">peaks</span><span class="s3">)</span>
    <span class="s1">wlen </span><span class="s3">= </span><span class="s1">_arg_wlen_as_expected</span><span class="s3">(</span><span class="s1">wlen</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">_peak_prominences</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">peaks</span><span class="s3">, </span><span class="s1">wlen</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">peak_widths</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">peaks</span><span class="s3">, </span><span class="s1">rel_height</span><span class="s3">=</span><span class="s5">0.5</span><span class="s3">, </span><span class="s1">prominence_data</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">wlen</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Calculate the width of each peak in a signal. 
 
    This function calculates the width of a peak in samples at a relative 
    distance to the peak's height and prominence. 
 
    Parameters 
    ---------- 
    x : sequence 
        A signal with peaks. 
    peaks : sequence 
        Indices of peaks in `x`. 
    rel_height : float, optional 
        Chooses the relative height at which the peak width is measured as a 
        percentage of its prominence. 1.0 calculates the width of the peak at 
        its lowest contour line while 0.5 evaluates at half the prominence 
        height. Must be at least 0. See notes for further explanation. 
    prominence_data : tuple, optional 
        A tuple of three arrays matching the output of `peak_prominences` when 
        called with the same arguments `x` and `peaks`. This data are calculated 
        internally if not provided. 
    wlen : int, optional 
        A window length in samples passed to `peak_prominences` as an optional 
        argument for internal calculation of `prominence_data`. This argument 
        is ignored if `prominence_data` is given. 
 
    Returns 
    ------- 
    widths : ndarray 
        The widths for each peak in samples. 
    width_heights : ndarray 
        The height of the contour lines at which the `widths` where evaluated. 
    left_ips, right_ips : ndarray 
        Interpolated positions of left and right intersection points of a 
        horizontal line at the respective evaluation height. 
 
    Raises 
    ------ 
    ValueError 
        If `prominence_data` is supplied but doesn't satisfy the condition 
        ``0 &lt;= left_base &lt;= peak &lt;= right_base &lt; x.shape[0]`` for each peak, 
        has the wrong dtype, is not C-contiguous or does not have the same 
        shape. 
 
    Warns 
    ----- 
    PeakPropertyWarning 
        Raised if any calculated width is 0. This may stem from the supplied 
        `prominence_data` or if `rel_height` is set to 0. 
 
    Warnings 
    -------- 
    This function may return unexpected results for data containing NaNs. To 
    avoid this, NaNs should either be removed or replaced. 
 
    See Also 
    -------- 
    find_peaks 
        Find peaks inside a signal based on peak properties. 
    peak_prominences 
        Calculate the prominence of peaks. 
 
    Notes 
    ----- 
    The basic algorithm to calculate a peak's width is as follows: 
 
    * Calculate the evaluation height :math:`h_{eval}` with the formula 
      :math:`h_{eval} = h_{Peak} - P \\cdot R`, where :math:`h_{Peak}` is the 
      height of the peak itself, :math:`P` is the peak's prominence and 
      :math:`R` a positive ratio specified with the argument `rel_height`. 
    * Draw a horizontal line at the evaluation height to both sides, starting at 
      the peak's current vertical position until the lines either intersect a 
      slope, the signal border or cross the vertical position of the peak's 
      base (see `peak_prominences` for an definition). For the first case, 
      intersection with the signal, the true intersection point is estimated 
      with linear interpolation. 
    * Calculate the width as the horizontal distance between the chosen 
      endpoints on both sides. As a consequence of this the maximal possible 
      width for each peak is the horizontal distance between its bases. 
 
    As shown above to calculate a peak's width its prominence and bases must be 
    known. You can supply these yourself with the argument `prominence_data`. 
    Otherwise, they are internally calculated (see `peak_prominences`). 
 
    .. versionadded:: 1.1.0 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.signal import chirp, find_peaks, peak_widths 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
 
    Create a test signal with two overlaid harmonics 
 
    &gt;&gt;&gt; x = np.linspace(0, 6 * np.pi, 1000) 
    &gt;&gt;&gt; x = np.sin(x) + 0.6 * np.sin(2.6 * x) 
 
    Find all peaks and calculate their widths at the relative height of 0.5 
    (contour line at half the prominence height) and 1 (at the lowest contour 
    line at full prominence height). 
 
    &gt;&gt;&gt; peaks, _ = find_peaks(x) 
    &gt;&gt;&gt; results_half = peak_widths(x, peaks, rel_height=0.5) 
    &gt;&gt;&gt; results_half[0]  # widths 
    array([ 64.25172825,  41.29465463,  35.46943289, 104.71586081, 
            35.46729324,  41.30429622, 181.93835853,  45.37078546]) 
    &gt;&gt;&gt; results_full = peak_widths(x, peaks, rel_height=1) 
    &gt;&gt;&gt; results_full[0]  # widths 
    array([181.9396084 ,  72.99284945,  61.28657872, 373.84622694, 
        61.78404617,  72.48822812, 253.09161876,  79.36860878]) 
 
    Plot signal, peaks and contour lines at which the widths where calculated 
 
    &gt;&gt;&gt; plt.plot(x) 
    &gt;&gt;&gt; plt.plot(peaks, x[peaks], &quot;x&quot;) 
    &gt;&gt;&gt; plt.hlines(*results_half[1:], color=&quot;C2&quot;) 
    &gt;&gt;&gt; plt.hlines(*results_full[1:], color=&quot;C3&quot;) 
    &gt;&gt;&gt; plt.show() 
    &quot;&quot;&quot;</span>
    <span class="s1">x </span><span class="s3">= </span><span class="s1">_arg_x_as_expected</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
    <span class="s1">peaks </span><span class="s3">= </span><span class="s1">_arg_peaks_as_expected</span><span class="s3">(</span><span class="s1">peaks</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">prominence_data </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s6"># Calculate prominence if not supplied and use wlen if supplied.</span>
        <span class="s1">wlen </span><span class="s3">= </span><span class="s1">_arg_wlen_as_expected</span><span class="s3">(</span><span class="s1">wlen</span><span class="s3">)</span>
        <span class="s1">prominence_data </span><span class="s3">= </span><span class="s1">_peak_prominences</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">peaks</span><span class="s3">, </span><span class="s1">wlen</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">_peak_widths</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">peaks</span><span class="s3">, </span><span class="s1">rel_height</span><span class="s3">, *</span><span class="s1">prominence_data</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">_unpack_condition_args</span><span class="s3">(</span><span class="s1">interval</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">peaks</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Parse condition arguments for `find_peaks`. 
 
    Parameters 
    ---------- 
    interval : number or ndarray or sequence 
        Either a number or ndarray or a 2-element sequence of the former. The 
        first value is always interpreted as `imin` and the second, if supplied, 
        as `imax`. 
    x : ndarray 
        The signal with `peaks`. 
    peaks : ndarray 
        An array with indices used to reduce `imin` and / or `imax` if those are 
        arrays. 
 
    Returns 
    ------- 
    imin, imax : number or ndarray or None 
        Minimal and maximal value in `argument`. 
 
    Raises 
    ------ 
    ValueError : 
        If interval border is given as array and its size does not match the size 
        of `x`. 
 
    Notes 
    ----- 
 
    .. versionadded:: 1.1.0 
    &quot;&quot;&quot;</span>
    <span class="s2">try</span><span class="s3">:</span>
        <span class="s1">imin</span><span class="s3">, </span><span class="s1">imax </span><span class="s3">= </span><span class="s1">interval</span>
    <span class="s2">except </span><span class="s3">(</span><span class="s1">TypeError</span><span class="s3">, </span><span class="s1">ValueError</span><span class="s3">):</span>
        <span class="s1">imin</span><span class="s3">, </span><span class="s1">imax </span><span class="s3">= (</span><span class="s1">interval</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>

    <span class="s6"># Reduce arrays if arrays</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">imin</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndarray</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">imin</span><span class="s3">.</span><span class="s1">size </span><span class="s3">!= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">size</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'array size of lower interval border must match x'</span><span class="s3">)</span>
        <span class="s1">imin </span><span class="s3">= </span><span class="s1">imin</span><span class="s3">[</span><span class="s1">peaks</span><span class="s3">]</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">imax</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndarray</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">imax</span><span class="s3">.</span><span class="s1">size </span><span class="s3">!= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">size</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'array size of upper interval border must match x'</span><span class="s3">)</span>
        <span class="s1">imax </span><span class="s3">= </span><span class="s1">imax</span><span class="s3">[</span><span class="s1">peaks</span><span class="s3">]</span>

    <span class="s2">return </span><span class="s1">imin</span><span class="s3">, </span><span class="s1">imax</span>


<span class="s2">def </span><span class="s1">_select_by_property</span><span class="s3">(</span><span class="s1">peak_properties</span><span class="s3">, </span><span class="s1">pmin</span><span class="s3">, </span><span class="s1">pmax</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Evaluate where the generic property of peaks confirms to an interval. 
 
    Parameters 
    ---------- 
    peak_properties : ndarray 
        An array with properties for each peak. 
    pmin : None or number or ndarray 
        Lower interval boundary for `peak_properties`. ``None`` is interpreted as 
        an open border. 
    pmax : None or number or ndarray 
        Upper interval boundary for `peak_properties`. ``None`` is interpreted as 
        an open border. 
 
    Returns 
    ------- 
    keep : bool 
        A boolean mask evaluating to true where `peak_properties` confirms to the 
        interval. 
 
    See Also 
    -------- 
    find_peaks 
 
    Notes 
    ----- 
 
    .. versionadded:: 1.1.0 
    &quot;&quot;&quot;</span>
    <span class="s1">keep </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">peak_properties</span><span class="s3">.</span><span class="s1">size</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">bool</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">pmin </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s1">keep </span><span class="s3">&amp;= (</span><span class="s1">pmin </span><span class="s3">&lt;= </span><span class="s1">peak_properties</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">pmax </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s1">keep </span><span class="s3">&amp;= (</span><span class="s1">peak_properties </span><span class="s3">&lt;= </span><span class="s1">pmax</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">keep</span>


<span class="s2">def </span><span class="s1">_select_by_peak_threshold</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">peaks</span><span class="s3">, </span><span class="s1">tmin</span><span class="s3">, </span><span class="s1">tmax</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Evaluate which peaks fulfill the threshold condition. 
 
    Parameters 
    ---------- 
    x : ndarray 
        A 1-D array which is indexable by `peaks`. 
    peaks : ndarray 
        Indices of peaks in `x`. 
    tmin, tmax : scalar or ndarray or None 
         Minimal and / or maximal required thresholds. If supplied as ndarrays 
         their size must match `peaks`. ``None`` is interpreted as an open 
         border. 
 
    Returns 
    ------- 
    keep : bool 
        A boolean mask evaluating to true where `peaks` fulfill the threshold 
        condition. 
    left_thresholds, right_thresholds : ndarray 
        Array matching `peak` containing the thresholds of each peak on 
        both sides. 
 
    Notes 
    ----- 
 
    .. versionadded:: 1.1.0 
    &quot;&quot;&quot;</span>
    <span class="s6"># Stack thresholds on both sides to make min / max operations easier:</span>
    <span class="s6"># tmin is compared with the smaller, and tmax with the greater threshold to</span>
    <span class="s6"># each peak's side</span>
    <span class="s1">stacked_thresholds </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">vstack</span><span class="s3">([</span><span class="s1">x</span><span class="s3">[</span><span class="s1">peaks</span><span class="s3">] - </span><span class="s1">x</span><span class="s3">[</span><span class="s1">peaks </span><span class="s3">- </span><span class="s5">1</span><span class="s3">],</span>
                                    <span class="s1">x</span><span class="s3">[</span><span class="s1">peaks</span><span class="s3">] - </span><span class="s1">x</span><span class="s3">[</span><span class="s1">peaks </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">]])</span>
    <span class="s1">keep </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">peaks</span><span class="s3">.</span><span class="s1">size</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">bool</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">tmin </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s1">min_thresholds </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">min</span><span class="s3">(</span><span class="s1">stacked_thresholds</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s5">0</span><span class="s3">)</span>
        <span class="s1">keep </span><span class="s3">&amp;= (</span><span class="s1">tmin </span><span class="s3">&lt;= </span><span class="s1">min_thresholds</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">tmax </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s1">max_thresholds </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">max</span><span class="s3">(</span><span class="s1">stacked_thresholds</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s5">0</span><span class="s3">)</span>
        <span class="s1">keep </span><span class="s3">&amp;= (</span><span class="s1">max_thresholds </span><span class="s3">&lt;= </span><span class="s1">tmax</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">keep</span><span class="s3">, </span><span class="s1">stacked_thresholds</span><span class="s3">[</span><span class="s5">0</span><span class="s3">], </span><span class="s1">stacked_thresholds</span><span class="s3">[</span><span class="s5">1</span><span class="s3">]</span>


<span class="s2">def </span><span class="s1">find_peaks</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">height</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">threshold</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">distance</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
               <span class="s1">prominence</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">width</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">wlen</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">rel_height</span><span class="s3">=</span><span class="s5">0.5</span><span class="s3">,</span>
               <span class="s1">plateau_size</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Find peaks inside a signal based on peak properties. 
 
    This function takes a 1-D array and finds all local maxima by 
    simple comparison of neighboring values. Optionally, a subset of these 
    peaks can be selected by specifying conditions for a peak's properties. 
 
    Parameters 
    ---------- 
    x : sequence 
        A signal with peaks. 
    height : number or ndarray or sequence, optional 
        Required height of peaks. Either a number, ``None``, an array matching 
        `x` or a 2-element sequence of the former. The first element is 
        always interpreted as the  minimal and the second, if supplied, as the 
        maximal required height. 
    threshold : number or ndarray or sequence, optional 
        Required threshold of peaks, the vertical distance to its neighboring 
        samples. Either a number, ``None``, an array matching `x` or a 
        2-element sequence of the former. The first element is always 
        interpreted as the  minimal and the second, if supplied, as the maximal 
        required threshold. 
    distance : number, optional 
        Required minimal horizontal distance (&gt;= 1) in samples between 
        neighbouring peaks. Smaller peaks are removed first until the condition 
        is fulfilled for all remaining peaks. 
    prominence : number or ndarray or sequence, optional 
        Required prominence of peaks. Either a number, ``None``, an array 
        matching `x` or a 2-element sequence of the former. The first 
        element is always interpreted as the  minimal and the second, if 
        supplied, as the maximal required prominence. 
    width : number or ndarray or sequence, optional 
        Required width of peaks in samples. Either a number, ``None``, an array 
        matching `x` or a 2-element sequence of the former. The first 
        element is always interpreted as the  minimal and the second, if 
        supplied, as the maximal required width. 
    wlen : int, optional 
        Used for calculation of the peaks prominences, thus it is only used if 
        one of the arguments `prominence` or `width` is given. See argument 
        `wlen` in `peak_prominences` for a full description of its effects. 
    rel_height : float, optional 
        Used for calculation of the peaks width, thus it is only used if `width` 
        is given. See argument  `rel_height` in `peak_widths` for a full 
        description of its effects. 
    plateau_size : number or ndarray or sequence, optional 
        Required size of the flat top of peaks in samples. Either a number, 
        ``None``, an array matching `x` or a 2-element sequence of the former. 
        The first element is always interpreted as the minimal and the second, 
        if supplied as the maximal required plateau size. 
 
        .. versionadded:: 1.2.0 
 
    Returns 
    ------- 
    peaks : ndarray 
        Indices of peaks in `x` that satisfy all given conditions. 
    properties : dict 
        A dictionary containing properties of the returned peaks which were 
        calculated as intermediate results during evaluation of the specified 
        conditions: 
 
        * 'peak_heights' 
              If `height` is given, the height of each peak in `x`. 
        * 'left_thresholds', 'right_thresholds' 
              If `threshold` is given, these keys contain a peaks vertical 
              distance to its neighbouring samples. 
        * 'prominences', 'right_bases', 'left_bases' 
              If `prominence` is given, these keys are accessible. See 
              `peak_prominences` for a description of their content. 
        * 'width_heights', 'left_ips', 'right_ips' 
              If `width` is given, these keys are accessible. See `peak_widths` 
              for a description of their content. 
        * 'plateau_sizes', left_edges', 'right_edges' 
              If `plateau_size` is given, these keys are accessible and contain 
              the indices of a peak's edges (edges are still part of the 
              plateau) and the calculated plateau sizes. 
 
              .. versionadded:: 1.2.0 
 
        To calculate and return properties without excluding peaks, provide the 
        open interval ``(None, None)`` as a value to the appropriate argument 
        (excluding `distance`). 
 
    Warns 
    ----- 
    PeakPropertyWarning 
        Raised if a peak's properties have unexpected values (see 
        `peak_prominences` and `peak_widths`). 
 
    Warnings 
    -------- 
    This function may return unexpected results for data containing NaNs. To 
    avoid this, NaNs should either be removed or replaced. 
 
    See Also 
    -------- 
    find_peaks_cwt 
        Find peaks using the wavelet transformation. 
    peak_prominences 
        Directly calculate the prominence of peaks. 
    peak_widths 
        Directly calculate the width of peaks. 
 
    Notes 
    ----- 
    In the context of this function, a peak or local maximum is defined as any 
    sample whose two direct neighbours have a smaller amplitude. For flat peaks 
    (more than one sample of equal amplitude wide) the index of the middle 
    sample is returned (rounded down in case the number of samples is even). 
    For noisy signals the peak locations can be off because the noise might 
    change the position of local maxima. In those cases consider smoothing the 
    signal before searching for peaks or use other peak finding and fitting 
    methods (like `find_peaks_cwt`). 
 
    Some additional comments on specifying conditions: 
 
    * Almost all conditions (excluding `distance`) can be given as half-open or 
      closed intervals, e.g., ``1`` or ``(1, None)`` defines the half-open 
      interval :math:`[1, \\infty]` while ``(None, 1)`` defines the interval 
      :math:`[-\\infty, 1]`. The open interval ``(None, None)`` can be specified 
      as well, which returns the matching properties without exclusion of peaks. 
    * The border is always included in the interval used to select valid peaks. 
    * For several conditions the interval borders can be specified with 
      arrays matching `x` in shape which enables dynamic constrains based on 
      the sample position. 
    * The conditions are evaluated in the following order: `plateau_size`, 
      `height`, `threshold`, `distance`, `prominence`, `width`. In most cases 
      this order is the fastest one because faster operations are applied first 
      to reduce the number of peaks that need to be evaluated later. 
    * While indices in `peaks` are guaranteed to be at least `distance` samples 
      apart, edges of flat peaks may be closer than the allowed `distance`. 
    * Use `wlen` to reduce the time it takes to evaluate the conditions for 
      `prominence` or `width` if `x` is large or has many local maxima 
      (see `peak_prominences`). 
 
    .. versionadded:: 1.1.0 
 
    Examples 
    -------- 
    To demonstrate this function's usage we use a signal `x` supplied with 
    SciPy (see `scipy.datasets.electrocardiogram`). Let's find all peaks (local 
    maxima) in `x` whose amplitude lies above 0. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; from scipy.datasets import electrocardiogram 
    &gt;&gt;&gt; from scipy.signal import find_peaks 
    &gt;&gt;&gt; x = electrocardiogram()[2000:4000] 
    &gt;&gt;&gt; peaks, _ = find_peaks(x, height=0) 
    &gt;&gt;&gt; plt.plot(x) 
    &gt;&gt;&gt; plt.plot(peaks, x[peaks], &quot;x&quot;) 
    &gt;&gt;&gt; plt.plot(np.zeros_like(x), &quot;--&quot;, color=&quot;gray&quot;) 
    &gt;&gt;&gt; plt.show() 
 
    We can select peaks below 0 with ``height=(None, 0)`` or use arrays matching 
    `x` in size to reflect a changing condition for different parts of the 
    signal. 
 
    &gt;&gt;&gt; border = np.sin(np.linspace(0, 3 * np.pi, x.size)) 
    &gt;&gt;&gt; peaks, _ = find_peaks(x, height=(-border, border)) 
    &gt;&gt;&gt; plt.plot(x) 
    &gt;&gt;&gt; plt.plot(-border, &quot;--&quot;, color=&quot;gray&quot;) 
    &gt;&gt;&gt; plt.plot(border, &quot;:&quot;, color=&quot;gray&quot;) 
    &gt;&gt;&gt; plt.plot(peaks, x[peaks], &quot;x&quot;) 
    &gt;&gt;&gt; plt.show() 
 
    Another useful condition for periodic signals can be given with the 
    `distance` argument. In this case, we can easily select the positions of 
    QRS complexes within the electrocardiogram (ECG) by demanding a distance of 
    at least 150 samples. 
 
    &gt;&gt;&gt; peaks, _ = find_peaks(x, distance=150) 
    &gt;&gt;&gt; np.diff(peaks) 
    array([186, 180, 177, 171, 177, 169, 167, 164, 158, 162, 172]) 
    &gt;&gt;&gt; plt.plot(x) 
    &gt;&gt;&gt; plt.plot(peaks, x[peaks], &quot;x&quot;) 
    &gt;&gt;&gt; plt.show() 
 
    Especially for noisy signals peaks can be easily grouped by their 
    prominence (see `peak_prominences`). E.g., we can select all peaks except 
    for the mentioned QRS complexes by limiting the allowed prominence to 0.6. 
 
    &gt;&gt;&gt; peaks, properties = find_peaks(x, prominence=(None, 0.6)) 
    &gt;&gt;&gt; properties[&quot;prominences&quot;].max() 
    0.5049999999999999 
    &gt;&gt;&gt; plt.plot(x) 
    &gt;&gt;&gt; plt.plot(peaks, x[peaks], &quot;x&quot;) 
    &gt;&gt;&gt; plt.show() 
 
    And, finally, let's examine a different section of the ECG which contains 
    beat forms of different shape. To select only the atypical heart beats, we 
    combine two conditions: a minimal prominence of 1 and width of at least 20 
    samples. 
 
    &gt;&gt;&gt; x = electrocardiogram()[17000:18000] 
    &gt;&gt;&gt; peaks, properties = find_peaks(x, prominence=1, width=20) 
    &gt;&gt;&gt; properties[&quot;prominences&quot;], properties[&quot;widths&quot;] 
    (array([1.495, 2.3  ]), array([36.93773946, 39.32723577])) 
    &gt;&gt;&gt; plt.plot(x) 
    &gt;&gt;&gt; plt.plot(peaks, x[peaks], &quot;x&quot;) 
    &gt;&gt;&gt; plt.vlines(x=peaks, ymin=x[peaks] - properties[&quot;prominences&quot;], 
    ...            ymax = x[peaks], color = &quot;C1&quot;) 
    &gt;&gt;&gt; plt.hlines(y=properties[&quot;width_heights&quot;], xmin=properties[&quot;left_ips&quot;], 
    ...            xmax=properties[&quot;right_ips&quot;], color = &quot;C1&quot;) 
    &gt;&gt;&gt; plt.show() 
    &quot;&quot;&quot;</span>
    <span class="s6"># _argmaxima1d expects array of dtype 'float64'</span>
    <span class="s1">x </span><span class="s3">= </span><span class="s1">_arg_x_as_expected</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">distance </span><span class="s2">is not None and </span><span class="s1">distance </span><span class="s3">&lt; </span><span class="s5">1</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'`distance` must be greater or equal to 1'</span><span class="s3">)</span>

    <span class="s1">peaks</span><span class="s3">, </span><span class="s1">left_edges</span><span class="s3">, </span><span class="s1">right_edges </span><span class="s3">= </span><span class="s1">_local_maxima_1d</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
    <span class="s1">properties </span><span class="s3">= {}</span>

    <span class="s2">if </span><span class="s1">plateau_size </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s6"># Evaluate plateau size</span>
        <span class="s1">plateau_sizes </span><span class="s3">= </span><span class="s1">right_edges </span><span class="s3">- </span><span class="s1">left_edges </span><span class="s3">+ </span><span class="s5">1</span>
        <span class="s1">pmin</span><span class="s3">, </span><span class="s1">pmax </span><span class="s3">= </span><span class="s1">_unpack_condition_args</span><span class="s3">(</span><span class="s1">plateau_size</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">peaks</span><span class="s3">)</span>
        <span class="s1">keep </span><span class="s3">= </span><span class="s1">_select_by_property</span><span class="s3">(</span><span class="s1">plateau_sizes</span><span class="s3">, </span><span class="s1">pmin</span><span class="s3">, </span><span class="s1">pmax</span><span class="s3">)</span>
        <span class="s1">peaks </span><span class="s3">= </span><span class="s1">peaks</span><span class="s3">[</span><span class="s1">keep</span><span class="s3">]</span>
        <span class="s1">properties</span><span class="s3">[</span><span class="s4">&quot;plateau_sizes&quot;</span><span class="s3">] = </span><span class="s1">plateau_sizes</span>
        <span class="s1">properties</span><span class="s3">[</span><span class="s4">&quot;left_edges&quot;</span><span class="s3">] = </span><span class="s1">left_edges</span>
        <span class="s1">properties</span><span class="s3">[</span><span class="s4">&quot;right_edges&quot;</span><span class="s3">] = </span><span class="s1">right_edges</span>
        <span class="s1">properties </span><span class="s3">= {</span><span class="s1">key</span><span class="s3">: </span><span class="s1">array</span><span class="s3">[</span><span class="s1">keep</span><span class="s3">] </span><span class="s2">for </span><span class="s1">key</span><span class="s3">, </span><span class="s1">array </span><span class="s2">in </span><span class="s1">properties</span><span class="s3">.</span><span class="s1">items</span><span class="s3">()}</span>

    <span class="s2">if </span><span class="s1">height </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s6"># Evaluate height condition</span>
        <span class="s1">peak_heights </span><span class="s3">= </span><span class="s1">x</span><span class="s3">[</span><span class="s1">peaks</span><span class="s3">]</span>
        <span class="s1">hmin</span><span class="s3">, </span><span class="s1">hmax </span><span class="s3">= </span><span class="s1">_unpack_condition_args</span><span class="s3">(</span><span class="s1">height</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">peaks</span><span class="s3">)</span>
        <span class="s1">keep </span><span class="s3">= </span><span class="s1">_select_by_property</span><span class="s3">(</span><span class="s1">peak_heights</span><span class="s3">, </span><span class="s1">hmin</span><span class="s3">, </span><span class="s1">hmax</span><span class="s3">)</span>
        <span class="s1">peaks </span><span class="s3">= </span><span class="s1">peaks</span><span class="s3">[</span><span class="s1">keep</span><span class="s3">]</span>
        <span class="s1">properties</span><span class="s3">[</span><span class="s4">&quot;peak_heights&quot;</span><span class="s3">] = </span><span class="s1">peak_heights</span>
        <span class="s1">properties </span><span class="s3">= {</span><span class="s1">key</span><span class="s3">: </span><span class="s1">array</span><span class="s3">[</span><span class="s1">keep</span><span class="s3">] </span><span class="s2">for </span><span class="s1">key</span><span class="s3">, </span><span class="s1">array </span><span class="s2">in </span><span class="s1">properties</span><span class="s3">.</span><span class="s1">items</span><span class="s3">()}</span>

    <span class="s2">if </span><span class="s1">threshold </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s6"># Evaluate threshold condition</span>
        <span class="s1">tmin</span><span class="s3">, </span><span class="s1">tmax </span><span class="s3">= </span><span class="s1">_unpack_condition_args</span><span class="s3">(</span><span class="s1">threshold</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">peaks</span><span class="s3">)</span>
        <span class="s1">keep</span><span class="s3">, </span><span class="s1">left_thresholds</span><span class="s3">, </span><span class="s1">right_thresholds </span><span class="s3">= </span><span class="s1">_select_by_peak_threshold</span><span class="s3">(</span>
            <span class="s1">x</span><span class="s3">, </span><span class="s1">peaks</span><span class="s3">, </span><span class="s1">tmin</span><span class="s3">, </span><span class="s1">tmax</span><span class="s3">)</span>
        <span class="s1">peaks </span><span class="s3">= </span><span class="s1">peaks</span><span class="s3">[</span><span class="s1">keep</span><span class="s3">]</span>
        <span class="s1">properties</span><span class="s3">[</span><span class="s4">&quot;left_thresholds&quot;</span><span class="s3">] = </span><span class="s1">left_thresholds</span>
        <span class="s1">properties</span><span class="s3">[</span><span class="s4">&quot;right_thresholds&quot;</span><span class="s3">] = </span><span class="s1">right_thresholds</span>
        <span class="s1">properties </span><span class="s3">= {</span><span class="s1">key</span><span class="s3">: </span><span class="s1">array</span><span class="s3">[</span><span class="s1">keep</span><span class="s3">] </span><span class="s2">for </span><span class="s1">key</span><span class="s3">, </span><span class="s1">array </span><span class="s2">in </span><span class="s1">properties</span><span class="s3">.</span><span class="s1">items</span><span class="s3">()}</span>

    <span class="s2">if </span><span class="s1">distance </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s6"># Evaluate distance condition</span>
        <span class="s1">keep </span><span class="s3">= </span><span class="s1">_select_by_peak_distance</span><span class="s3">(</span><span class="s1">peaks</span><span class="s3">, </span><span class="s1">x</span><span class="s3">[</span><span class="s1">peaks</span><span class="s3">], </span><span class="s1">distance</span><span class="s3">)</span>
        <span class="s1">peaks </span><span class="s3">= </span><span class="s1">peaks</span><span class="s3">[</span><span class="s1">keep</span><span class="s3">]</span>
        <span class="s1">properties </span><span class="s3">= {</span><span class="s1">key</span><span class="s3">: </span><span class="s1">array</span><span class="s3">[</span><span class="s1">keep</span><span class="s3">] </span><span class="s2">for </span><span class="s1">key</span><span class="s3">, </span><span class="s1">array </span><span class="s2">in </span><span class="s1">properties</span><span class="s3">.</span><span class="s1">items</span><span class="s3">()}</span>

    <span class="s2">if </span><span class="s1">prominence </span><span class="s2">is not None or </span><span class="s1">width </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s6"># Calculate prominence (required for both conditions)</span>
        <span class="s1">wlen </span><span class="s3">= </span><span class="s1">_arg_wlen_as_expected</span><span class="s3">(</span><span class="s1">wlen</span><span class="s3">)</span>
        <span class="s1">properties</span><span class="s3">.</span><span class="s1">update</span><span class="s3">(</span><span class="s1">zip</span><span class="s3">(</span>
            <span class="s3">[</span><span class="s4">'prominences'</span><span class="s3">, </span><span class="s4">'left_bases'</span><span class="s3">, </span><span class="s4">'right_bases'</span><span class="s3">],</span>
            <span class="s1">_peak_prominences</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">peaks</span><span class="s3">, </span><span class="s1">wlen</span><span class="s3">=</span><span class="s1">wlen</span><span class="s3">)</span>
        <span class="s3">))</span>

    <span class="s2">if </span><span class="s1">prominence </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s6"># Evaluate prominence condition</span>
        <span class="s1">pmin</span><span class="s3">, </span><span class="s1">pmax </span><span class="s3">= </span><span class="s1">_unpack_condition_args</span><span class="s3">(</span><span class="s1">prominence</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">peaks</span><span class="s3">)</span>
        <span class="s1">keep </span><span class="s3">= </span><span class="s1">_select_by_property</span><span class="s3">(</span><span class="s1">properties</span><span class="s3">[</span><span class="s4">'prominences'</span><span class="s3">], </span><span class="s1">pmin</span><span class="s3">, </span><span class="s1">pmax</span><span class="s3">)</span>
        <span class="s1">peaks </span><span class="s3">= </span><span class="s1">peaks</span><span class="s3">[</span><span class="s1">keep</span><span class="s3">]</span>
        <span class="s1">properties </span><span class="s3">= {</span><span class="s1">key</span><span class="s3">: </span><span class="s1">array</span><span class="s3">[</span><span class="s1">keep</span><span class="s3">] </span><span class="s2">for </span><span class="s1">key</span><span class="s3">, </span><span class="s1">array </span><span class="s2">in </span><span class="s1">properties</span><span class="s3">.</span><span class="s1">items</span><span class="s3">()}</span>

    <span class="s2">if </span><span class="s1">width </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s6"># Calculate widths</span>
        <span class="s1">properties</span><span class="s3">.</span><span class="s1">update</span><span class="s3">(</span><span class="s1">zip</span><span class="s3">(</span>
            <span class="s3">[</span><span class="s4">'widths'</span><span class="s3">, </span><span class="s4">'width_heights'</span><span class="s3">, </span><span class="s4">'left_ips'</span><span class="s3">, </span><span class="s4">'right_ips'</span><span class="s3">],</span>
            <span class="s1">_peak_widths</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">peaks</span><span class="s3">, </span><span class="s1">rel_height</span><span class="s3">, </span><span class="s1">properties</span><span class="s3">[</span><span class="s4">'prominences'</span><span class="s3">],</span>
                         <span class="s1">properties</span><span class="s3">[</span><span class="s4">'left_bases'</span><span class="s3">], </span><span class="s1">properties</span><span class="s3">[</span><span class="s4">'right_bases'</span><span class="s3">])</span>
        <span class="s3">))</span>
        <span class="s6"># Evaluate width condition</span>
        <span class="s1">wmin</span><span class="s3">, </span><span class="s1">wmax </span><span class="s3">= </span><span class="s1">_unpack_condition_args</span><span class="s3">(</span><span class="s1">width</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">peaks</span><span class="s3">)</span>
        <span class="s1">keep </span><span class="s3">= </span><span class="s1">_select_by_property</span><span class="s3">(</span><span class="s1">properties</span><span class="s3">[</span><span class="s4">'widths'</span><span class="s3">], </span><span class="s1">wmin</span><span class="s3">, </span><span class="s1">wmax</span><span class="s3">)</span>
        <span class="s1">peaks </span><span class="s3">= </span><span class="s1">peaks</span><span class="s3">[</span><span class="s1">keep</span><span class="s3">]</span>
        <span class="s1">properties </span><span class="s3">= {</span><span class="s1">key</span><span class="s3">: </span><span class="s1">array</span><span class="s3">[</span><span class="s1">keep</span><span class="s3">] </span><span class="s2">for </span><span class="s1">key</span><span class="s3">, </span><span class="s1">array </span><span class="s2">in </span><span class="s1">properties</span><span class="s3">.</span><span class="s1">items</span><span class="s3">()}</span>

    <span class="s2">return </span><span class="s1">peaks</span><span class="s3">, </span><span class="s1">properties</span>


<span class="s2">def </span><span class="s1">_identify_ridge_lines</span><span class="s3">(</span><span class="s1">matr</span><span class="s3">, </span><span class="s1">max_distances</span><span class="s3">, </span><span class="s1">gap_thresh</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Identify ridges in the 2-D matrix. 
 
    Expect that the width of the wavelet feature increases with increasing row 
    number. 
 
    Parameters 
    ---------- 
    matr : 2-D ndarray 
        Matrix in which to identify ridge lines. 
    max_distances : 1-D sequence 
        At each row, a ridge line is only connected 
        if the relative max at row[n] is within 
        `max_distances`[n] from the relative max at row[n+1]. 
    gap_thresh : int 
        If a relative maximum is not found within `max_distances`, 
        there will be a gap. A ridge line is discontinued if 
        there are more than `gap_thresh` points without connecting 
        a new relative maximum. 
 
    Returns 
    ------- 
    ridge_lines : tuple 
        Tuple of 2 1-D sequences. `ridge_lines`[ii][0] are the rows of the 
        ii-th ridge-line, `ridge_lines`[ii][1] are the columns. Empty if none 
        found.  Each ridge-line will be sorted by row (increasing), but the 
        order of the ridge lines is not specified. 
 
    References 
    ---------- 
    .. [1] Bioinformatics (2006) 22 (17): 2059-2065. 
       :doi:`10.1093/bioinformatics/btl355` 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.signal._peak_finding import _identify_ridge_lines 
    &gt;&gt;&gt; rng = np.random.default_rng() 
    &gt;&gt;&gt; data = rng.random((5,5)) 
    &gt;&gt;&gt; max_dist = 3 
    &gt;&gt;&gt; max_distances = np.full(20, max_dist) 
    &gt;&gt;&gt; ridge_lines = _identify_ridge_lines(data, max_distances, 1) 
 
    Notes 
    ----- 
    This function is intended to be used in conjunction with `cwt` 
    as part of `find_peaks_cwt`. 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">max_distances</span><span class="s3">) &lt; </span><span class="s1">matr</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'Max_distances must have at least as many rows '</span>
                         <span class="s4">'as matr'</span><span class="s3">)</span>

    <span class="s1">all_max_cols </span><span class="s3">= </span><span class="s1">_boolrelextrema</span><span class="s3">(</span><span class="s1">matr</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">greater</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s5">1</span><span class="s3">, </span><span class="s1">order</span><span class="s3">=</span><span class="s5">1</span><span class="s3">)</span>
    <span class="s6"># Highest row for which there are any relative maxima</span>
    <span class="s1">has_relmax </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nonzero</span><span class="s3">(</span><span class="s1">all_max_cols</span><span class="s3">.</span><span class="s1">any</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">=</span><span class="s5">1</span><span class="s3">))[</span><span class="s5">0</span><span class="s3">]</span>
    <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">has_relmax</span><span class="s3">) == </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s3">[]</span>
    <span class="s1">start_row </span><span class="s3">= </span><span class="s1">has_relmax</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">]</span>
    <span class="s6"># Each ridge line is a 3-tuple:</span>
    <span class="s6"># rows, cols,Gap number</span>
    <span class="s1">ridge_lines </span><span class="s3">= [[[</span><span class="s1">start_row</span><span class="s3">],</span>
                   <span class="s3">[</span><span class="s1">col</span><span class="s3">],</span>
                   <span class="s5">0</span><span class="s3">] </span><span class="s2">for </span><span class="s1">col </span><span class="s2">in </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nonzero</span><span class="s3">(</span><span class="s1">all_max_cols</span><span class="s3">[</span><span class="s1">start_row</span><span class="s3">])[</span><span class="s5">0</span><span class="s3">]]</span>
    <span class="s1">final_lines </span><span class="s3">= []</span>
    <span class="s1">rows </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s1">start_row </span><span class="s3">- </span><span class="s5">1</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">)</span>
    <span class="s1">cols </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">matr</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s5">1</span><span class="s3">])</span>
    <span class="s2">for </span><span class="s1">row </span><span class="s2">in </span><span class="s1">rows</span><span class="s3">:</span>
        <span class="s1">this_max_cols </span><span class="s3">= </span><span class="s1">cols</span><span class="s3">[</span><span class="s1">all_max_cols</span><span class="s3">[</span><span class="s1">row</span><span class="s3">]]</span>

        <span class="s6"># Increment gap number of each line,</span>
        <span class="s6"># set it to zero later if appropriate</span>
        <span class="s2">for </span><span class="s1">line </span><span class="s2">in </span><span class="s1">ridge_lines</span><span class="s3">:</span>
            <span class="s1">line</span><span class="s3">[</span><span class="s5">2</span><span class="s3">] += </span><span class="s5">1</span>

        <span class="s6"># XXX These should always be all_max_cols[row]</span>
        <span class="s6"># But the order might be different. Might be an efficiency gain</span>
        <span class="s6"># to make sure the order is the same and avoid this iteration</span>
        <span class="s1">prev_ridge_cols </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s1">line</span><span class="s3">[</span><span class="s5">1</span><span class="s3">][-</span><span class="s5">1</span><span class="s3">] </span><span class="s2">for </span><span class="s1">line </span><span class="s2">in </span><span class="s1">ridge_lines</span><span class="s3">])</span>
        <span class="s6"># Look through every relative maximum found at current row</span>
        <span class="s6"># Attempt to connect them with existing ridge lines.</span>
        <span class="s2">for </span><span class="s1">ind</span><span class="s3">, </span><span class="s1">col </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">this_max_cols</span><span class="s3">):</span>
            <span class="s6"># If there is a previous ridge line within</span>
            <span class="s6"># the max_distance to connect to, do so.</span>
            <span class="s6"># Otherwise start a new one.</span>
            <span class="s1">line </span><span class="s3">= </span><span class="s2">None</span>
            <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">prev_ridge_cols</span><span class="s3">) &gt; </span><span class="s5">0</span><span class="s3">:</span>
                <span class="s1">diffs </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">col </span><span class="s3">- </span><span class="s1">prev_ridge_cols</span><span class="s3">)</span>
                <span class="s1">closest </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">argmin</span><span class="s3">(</span><span class="s1">diffs</span><span class="s3">)</span>
                <span class="s2">if </span><span class="s1">diffs</span><span class="s3">[</span><span class="s1">closest</span><span class="s3">] &lt;= </span><span class="s1">max_distances</span><span class="s3">[</span><span class="s1">row</span><span class="s3">]:</span>
                    <span class="s1">line </span><span class="s3">= </span><span class="s1">ridge_lines</span><span class="s3">[</span><span class="s1">closest</span><span class="s3">]</span>
            <span class="s2">if </span><span class="s1">line </span><span class="s2">is not None</span><span class="s3">:</span>
                <span class="s6"># Found a point close enough, extend current ridge line</span>
                <span class="s1">line</span><span class="s3">[</span><span class="s5">1</span><span class="s3">].</span><span class="s1">append</span><span class="s3">(</span><span class="s1">col</span><span class="s3">)</span>
                <span class="s1">line</span><span class="s3">[</span><span class="s5">0</span><span class="s3">].</span><span class="s1">append</span><span class="s3">(</span><span class="s1">row</span><span class="s3">)</span>
                <span class="s1">line</span><span class="s3">[</span><span class="s5">2</span><span class="s3">] = </span><span class="s5">0</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">new_line </span><span class="s3">= [[</span><span class="s1">row</span><span class="s3">],</span>
                            <span class="s3">[</span><span class="s1">col</span><span class="s3">],</span>
                            <span class="s5">0</span><span class="s3">]</span>
                <span class="s1">ridge_lines</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">new_line</span><span class="s3">)</span>

        <span class="s6"># Remove the ridge lines with gap_number too high</span>
        <span class="s6"># XXX Modifying a list while iterating over it.</span>
        <span class="s6"># Should be safe, since we iterate backwards, but</span>
        <span class="s6"># still tacky.</span>
        <span class="s2">for </span><span class="s1">ind </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">ridge_lines</span><span class="s3">) - </span><span class="s5">1</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">):</span>
            <span class="s1">line </span><span class="s3">= </span><span class="s1">ridge_lines</span><span class="s3">[</span><span class="s1">ind</span><span class="s3">]</span>
            <span class="s2">if </span><span class="s1">line</span><span class="s3">[</span><span class="s5">2</span><span class="s3">] &gt; </span><span class="s1">gap_thresh</span><span class="s3">:</span>
                <span class="s1">final_lines</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">line</span><span class="s3">)</span>
                <span class="s2">del </span><span class="s1">ridge_lines</span><span class="s3">[</span><span class="s1">ind</span><span class="s3">]</span>

    <span class="s1">out_lines </span><span class="s3">= []</span>
    <span class="s2">for </span><span class="s1">line </span><span class="s2">in </span><span class="s3">(</span><span class="s1">final_lines </span><span class="s3">+ </span><span class="s1">ridge_lines</span><span class="s3">):</span>
        <span class="s1">sortargs </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">argsort</span><span class="s3">(</span><span class="s1">line</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]))</span>
        <span class="s1">rows</span><span class="s3">, </span><span class="s1">cols </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros_like</span><span class="s3">(</span><span class="s1">sortargs</span><span class="s3">), </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros_like</span><span class="s3">(</span><span class="s1">sortargs</span><span class="s3">)</span>
        <span class="s1">rows</span><span class="s3">[</span><span class="s1">sortargs</span><span class="s3">] = </span><span class="s1">line</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
        <span class="s1">cols</span><span class="s3">[</span><span class="s1">sortargs</span><span class="s3">] = </span><span class="s1">line</span><span class="s3">[</span><span class="s5">1</span><span class="s3">]</span>
        <span class="s1">out_lines</span><span class="s3">.</span><span class="s1">append</span><span class="s3">([</span><span class="s1">rows</span><span class="s3">, </span><span class="s1">cols</span><span class="s3">])</span>

    <span class="s2">return </span><span class="s1">out_lines</span>


<span class="s2">def </span><span class="s1">_filter_ridge_lines</span><span class="s3">(</span><span class="s1">cwt</span><span class="s3">, </span><span class="s1">ridge_lines</span><span class="s3">, </span><span class="s1">window_size</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">min_length</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
                        <span class="s1">min_snr</span><span class="s3">=</span><span class="s5">1</span><span class="s3">, </span><span class="s1">noise_perc</span><span class="s3">=</span><span class="s5">10</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Filter ridge lines according to prescribed criteria. Intended 
    to be used for finding relative maxima. 
 
    Parameters 
    ---------- 
    cwt : 2-D ndarray 
        Continuous wavelet transform from which the `ridge_lines` were defined. 
    ridge_lines : 1-D sequence 
        Each element should contain 2 sequences, the rows and columns 
        of the ridge line (respectively). 
    window_size : int, optional 
        Size of window to use to calculate noise floor. 
        Default is ``cwt.shape[1] / 20``. 
    min_length : int, optional 
        Minimum length a ridge line needs to be acceptable. 
        Default is ``cwt.shape[0] / 4``, ie 1/4-th the number of widths. 
    min_snr : float, optional 
        Minimum SNR ratio. Default 1. The signal is the value of 
        the cwt matrix at the shortest length scale (``cwt[0, loc]``), the 
        noise is the `noise_perc`\\ th percentile of datapoints contained within a 
        window of `window_size` around ``cwt[0, loc]``. 
    noise_perc : float, optional 
        When calculating the noise floor, percentile of data points 
        examined below which to consider noise. Calculated using 
        scipy.stats.scoreatpercentile. 
 
    References 
    ---------- 
    .. [1] Bioinformatics (2006) 22 (17): 2059-2065. 
       :doi:`10.1093/bioinformatics/btl355` 
 
    &quot;&quot;&quot;</span>
    <span class="s1">num_points </span><span class="s3">= </span><span class="s1">cwt</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s5">1</span><span class="s3">]</span>
    <span class="s2">if </span><span class="s1">min_length </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">min_length </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ceil</span><span class="s3">(</span><span class="s1">cwt</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] / </span><span class="s5">4</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">window_size </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">window_size </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ceil</span><span class="s3">(</span><span class="s1">num_points </span><span class="s3">/ </span><span class="s5">20</span><span class="s3">)</span>

    <span class="s1">window_size </span><span class="s3">= </span><span class="s1">int</span><span class="s3">(</span><span class="s1">window_size</span><span class="s3">)</span>
    <span class="s1">hf_window</span><span class="s3">, </span><span class="s1">odd </span><span class="s3">= </span><span class="s1">divmod</span><span class="s3">(</span><span class="s1">window_size</span><span class="s3">, </span><span class="s5">2</span><span class="s3">)</span>

    <span class="s6"># Filter based on SNR</span>
    <span class="s1">row_one </span><span class="s3">= </span><span class="s1">cwt</span><span class="s3">[</span><span class="s5">0</span><span class="s3">, :]</span>
    <span class="s1">noises </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty_like</span><span class="s3">(</span><span class="s1">row_one</span><span class="s3">)</span>
    <span class="s2">for </span><span class="s1">ind</span><span class="s3">, </span><span class="s1">val </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">row_one</span><span class="s3">):</span>
        <span class="s1">window_start </span><span class="s3">= </span><span class="s1">max</span><span class="s3">(</span><span class="s1">ind </span><span class="s3">- </span><span class="s1">hf_window</span><span class="s3">, </span><span class="s5">0</span><span class="s3">)</span>
        <span class="s1">window_end </span><span class="s3">= </span><span class="s1">min</span><span class="s3">(</span><span class="s1">ind </span><span class="s3">+ </span><span class="s1">hf_window </span><span class="s3">+ </span><span class="s1">odd</span><span class="s3">, </span><span class="s1">num_points</span><span class="s3">)</span>
        <span class="s1">noises</span><span class="s3">[</span><span class="s1">ind</span><span class="s3">] = </span><span class="s1">scoreatpercentile</span><span class="s3">(</span><span class="s1">row_one</span><span class="s3">[</span><span class="s1">window_start</span><span class="s3">:</span><span class="s1">window_end</span><span class="s3">],</span>
                                        <span class="s1">per</span><span class="s3">=</span><span class="s1">noise_perc</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">filt_func</span><span class="s3">(</span><span class="s1">line</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">line</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]) &lt; </span><span class="s1">min_length</span><span class="s3">:</span>
            <span class="s2">return False</span>
        <span class="s1">snr </span><span class="s3">= </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">cwt</span><span class="s3">[</span><span class="s1">line</span><span class="s3">[</span><span class="s5">0</span><span class="s3">][</span><span class="s5">0</span><span class="s3">], </span><span class="s1">line</span><span class="s3">[</span><span class="s5">1</span><span class="s3">][</span><span class="s5">0</span><span class="s3">]] / </span><span class="s1">noises</span><span class="s3">[</span><span class="s1">line</span><span class="s3">[</span><span class="s5">1</span><span class="s3">][</span><span class="s5">0</span><span class="s3">]])</span>
        <span class="s2">if </span><span class="s1">snr </span><span class="s3">&lt; </span><span class="s1">min_snr</span><span class="s3">:</span>
            <span class="s2">return False</span>
        <span class="s2">return True</span>

    <span class="s2">return </span><span class="s1">list</span><span class="s3">(</span><span class="s1">filter</span><span class="s3">(</span><span class="s1">filt_func</span><span class="s3">, </span><span class="s1">ridge_lines</span><span class="s3">))</span>


<span class="s2">def </span><span class="s1">find_peaks_cwt</span><span class="s3">(</span><span class="s1">vector</span><span class="s3">, </span><span class="s1">widths</span><span class="s3">, </span><span class="s1">wavelet</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">max_distances</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
                   <span class="s1">gap_thresh</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">min_length</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
                   <span class="s1">min_snr</span><span class="s3">=</span><span class="s5">1</span><span class="s3">, </span><span class="s1">noise_perc</span><span class="s3">=</span><span class="s5">10</span><span class="s3">, </span><span class="s1">window_size</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Find peaks in a 1-D array with wavelet transformation. 
 
    The general approach is to smooth `vector` by convolving it with 
    `wavelet(width)` for each width in `widths`. Relative maxima which 
    appear at enough length scales, and with sufficiently high SNR, are 
    accepted. 
 
    Parameters 
    ---------- 
    vector : ndarray 
        1-D array in which to find the peaks. 
    widths : float or sequence 
        Single width or 1-D array-like of widths to use for calculating 
        the CWT matrix. In general, 
        this range should cover the expected width of peaks of interest. 
    wavelet : callable, optional 
        Should take two parameters and return a 1-D array to convolve 
        with `vector`. The first parameter determines the number of points 
        of the returned wavelet array, the second parameter is the scale 
        (`width`) of the wavelet. Should be normalized and symmetric. 
        Default is the ricker wavelet. 
    max_distances : ndarray, optional 
        At each row, a ridge line is only connected if the relative max at 
        row[n] is within ``max_distances[n]`` from the relative max at 
        ``row[n+1]``.  Default value is ``widths/4``. 
    gap_thresh : float, optional 
        If a relative maximum is not found within `max_distances`, 
        there will be a gap. A ridge line is discontinued if there are more 
        than `gap_thresh` points without connecting a new relative maximum. 
        Default is the first value of the widths array i.e. widths[0]. 
    min_length : int, optional 
        Minimum length a ridge line needs to be acceptable. 
        Default is ``cwt.shape[0] / 4``, ie 1/4-th the number of widths. 
    min_snr : float, optional 
        Minimum SNR ratio. Default 1. The signal is the maximum CWT coefficient 
        on the largest ridge line. The noise is `noise_perc` th percentile of 
        datapoints contained within the same ridge line. 
    noise_perc : float, optional 
        When calculating the noise floor, percentile of data points 
        examined below which to consider noise. Calculated using 
        `stats.scoreatpercentile`.  Default is 10. 
    window_size : int, optional 
        Size of window to use to calculate noise floor. 
        Default is ``cwt.shape[1] / 20``. 
 
    Returns 
    ------- 
    peaks_indices : ndarray 
        Indices of the locations in the `vector` where peaks were found. 
        The list is sorted. 
 
    See Also 
    -------- 
    cwt 
        Continuous wavelet transform. 
    find_peaks 
        Find peaks inside a signal based on peak properties. 
 
    Notes 
    ----- 
    This approach was designed for finding sharp peaks among noisy data, 
    however with proper parameter selection it should function well for 
    different peak shapes. 
 
    The algorithm is as follows: 
     1. Perform a continuous wavelet transform on `vector`, for the supplied 
        `widths`. This is a convolution of `vector` with `wavelet(width)` for 
        each width in `widths`. See `cwt`. 
     2. Identify &quot;ridge lines&quot; in the cwt matrix. These are relative maxima 
        at each row, connected across adjacent rows. See identify_ridge_lines 
     3. Filter the ridge_lines using filter_ridge_lines. 
 
    .. versionadded:: 0.11.0 
 
    References 
    ---------- 
    .. [1] Bioinformatics (2006) 22 (17): 2059-2065. 
       :doi:`10.1093/bioinformatics/btl355` 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import signal 
    &gt;&gt;&gt; xs = np.arange(0, np.pi, 0.05) 
    &gt;&gt;&gt; data = np.sin(xs) 
    &gt;&gt;&gt; peakind = signal.find_peaks_cwt(data, np.arange(1,10)) 
    &gt;&gt;&gt; peakind, xs[peakind], data[peakind] 
    ([32], array([ 1.6]), array([ 0.9995736])) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">widths </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">atleast_1d</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">widths</span><span class="s3">))</span>

    <span class="s2">if </span><span class="s1">gap_thresh </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">gap_thresh </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ceil</span><span class="s3">(</span><span class="s1">widths</span><span class="s3">[</span><span class="s5">0</span><span class="s3">])</span>
    <span class="s2">if </span><span class="s1">max_distances </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">max_distances </span><span class="s3">= </span><span class="s1">widths </span><span class="s3">/ </span><span class="s5">4.0</span>
    <span class="s2">if </span><span class="s1">wavelet </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">wavelet </span><span class="s3">= </span><span class="s1">_ricker</span>

    <span class="s1">cwt_dat </span><span class="s3">= </span><span class="s1">_cwt</span><span class="s3">(</span><span class="s1">vector</span><span class="s3">, </span><span class="s1">wavelet</span><span class="s3">, </span><span class="s1">widths</span><span class="s3">)</span>
    <span class="s1">ridge_lines </span><span class="s3">= </span><span class="s1">_identify_ridge_lines</span><span class="s3">(</span><span class="s1">cwt_dat</span><span class="s3">, </span><span class="s1">max_distances</span><span class="s3">, </span><span class="s1">gap_thresh</span><span class="s3">)</span>
    <span class="s1">filtered </span><span class="s3">= </span><span class="s1">_filter_ridge_lines</span><span class="s3">(</span><span class="s1">cwt_dat</span><span class="s3">, </span><span class="s1">ridge_lines</span><span class="s3">, </span><span class="s1">min_length</span><span class="s3">=</span><span class="s1">min_length</span><span class="s3">,</span>
                                   <span class="s1">window_size</span><span class="s3">=</span><span class="s1">window_size</span><span class="s3">, </span><span class="s1">min_snr</span><span class="s3">=</span><span class="s1">min_snr</span><span class="s3">,</span>
                                   <span class="s1">noise_perc</span><span class="s3">=</span><span class="s1">noise_perc</span><span class="s3">)</span>
    <span class="s1">max_locs </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">([</span><span class="s1">x</span><span class="s3">[</span><span class="s5">1</span><span class="s3">][</span><span class="s5">0</span><span class="s3">] </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">filtered</span><span class="s3">])</span>
    <span class="s1">max_locs</span><span class="s3">.</span><span class="s1">sort</span><span class="s3">()</span>

    <span class="s2">return </span><span class="s1">max_locs</span>
</pre>
</body>
</html>