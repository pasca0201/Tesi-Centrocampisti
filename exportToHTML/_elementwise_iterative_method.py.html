<html>
<head>
<title>_elementwise_iterative_method.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #2aacb8;}
.s5 { color: #5f826b; font-style: italic;}
.s6 { color: #6aab73;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_elementwise_iterative_method.py</font>
</center></td></tr></table>
<pre><span class="s0"># `_elementwise_iterative_method.py` includes tools for writing functions that</span>
<span class="s0"># - are vectorized to work elementwise on arrays,</span>
<span class="s0"># - implement non-trivial, iterative algorithms with a callback interface, and</span>
<span class="s0"># - return rich objects with iteration count, termination status, etc.</span>
<span class="s0">#</span>
<span class="s0"># Examples include:</span>
<span class="s0"># `scipy.optimize._chandrupatla._chandrupatla for scalar rootfinding,</span>
<span class="s0"># `scipy.optimize._chandrupatla._chandrupatla_minimize for scalar minimization,</span>
<span class="s0"># `scipy.optimize._differentiate._differentiate for numerical differentiation,</span>
<span class="s0"># `scipy.optimize._bracket._bracket_root for finding rootfinding brackets,</span>
<span class="s0"># `scipy.optimize._bracket._bracket_minimize for finding minimization brackets,</span>
<span class="s0"># `scipy.integrate._tanhsinh._tanhsinh` for numerical quadrature.</span>

<span class="s2">import </span><span class="s1">math</span>
<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">_util </span><span class="s2">import </span><span class="s1">_RichResult</span><span class="s3">, </span><span class="s1">_call_callback_maybe_halt</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">_array_api </span><span class="s2">import </span><span class="s1">array_namespace</span><span class="s3">, </span><span class="s1">size </span><span class="s2">as </span><span class="s1">xp_size</span>

<span class="s1">_ESIGNERR </span><span class="s3">= -</span><span class="s4">1</span>
<span class="s1">_ECONVERR </span><span class="s3">= -</span><span class="s4">2</span>
<span class="s1">_EVALUEERR </span><span class="s3">= -</span><span class="s4">3</span>
<span class="s1">_ECALLBACK </span><span class="s3">= -</span><span class="s4">4</span>
<span class="s1">_EINPUTERR </span><span class="s3">= -</span><span class="s4">5</span>
<span class="s1">_ECONVERGED </span><span class="s3">= </span><span class="s4">0</span>
<span class="s1">_EINPROGRESS </span><span class="s3">= </span><span class="s4">1</span>

<span class="s2">def </span><span class="s1">_initialize</span><span class="s3">(</span><span class="s1">func</span><span class="s3">, </span><span class="s1">xs</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">complex_ok</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">preserve_shape</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s5">&quot;&quot;&quot;Initialize abscissa, function, and args arrays for elementwise function 
 
    Parameters 
    ---------- 
    func : callable 
        An elementwise function with signature 
 
            func(x: ndarray, *args) -&gt; ndarray 
 
        where each element of ``x`` is a finite real and ``args`` is a tuple, 
        which may contain an arbitrary number of arrays that are broadcastable 
        with ``x``. 
    xs : tuple of arrays 
        Finite real abscissa arrays. Must be broadcastable. 
    args : tuple, optional 
        Additional positional arguments to be passed to `func`. 
    preserve_shape : bool, default:False 
        When ``preserve_shape=False`` (default), `func` may be passed 
        arguments of any shape; `_scalar_optimization_loop` is permitted 
        to reshape and compress arguments at will. When 
        ``preserve_shape=False``, arguments passed to `func` must have shape 
        `shape` or ``shape + (n,)``, where ``n`` is any integer. 
 
    Returns 
    ------- 
    xs, fs, args : tuple of arrays 
        Broadcasted, writeable, 1D abscissa and function value arrays (or 
        NumPy floats, if appropriate). The dtypes of the `xs` and `fs` are 
        `xfat`; the dtype of the `args` are unchanged. 
    shape : tuple of ints 
        Original shape of broadcasted arrays. 
    xfat : NumPy dtype 
        Result dtype of abscissae, function values, and args determined using 
        `np.result_type`, except integer types are promoted to `np.float64`. 
 
    Raises 
    ------ 
    ValueError 
        If the result dtype is not that of a real scalar 
 
    Notes 
    ----- 
    Useful for initializing the input of SciPy functions that accept 
    an elementwise callable, abscissae, and arguments; e.g. 
    `scipy.optimize._chandrupatla`. 
    &quot;&quot;&quot;</span>
    <span class="s1">nx </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">xs</span><span class="s3">)</span>
    <span class="s1">xp </span><span class="s3">= </span><span class="s1">array_namespace</span><span class="s3">(*</span><span class="s1">xs</span><span class="s3">)</span>

    <span class="s0"># Try to preserve `dtype`, but we need to ensure that the arguments are at</span>
    <span class="s0"># least floats before passing them into the function; integers can overflow</span>
    <span class="s0"># and cause failure.</span>
    <span class="s0"># There might be benefit to combining the `xs` into a single array and</span>
    <span class="s0"># calling `func` once on the combined array. For now, keep them separate.</span>
    <span class="s1">xas </span><span class="s3">= </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">broadcast_arrays</span><span class="s3">(*</span><span class="s1">xs</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">)  </span><span class="s0"># broadcast and rename</span>
    <span class="s1">xat </span><span class="s3">= </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">result_type</span><span class="s3">(*[</span><span class="s1">xa</span><span class="s3">.</span><span class="s1">dtype </span><span class="s2">for </span><span class="s1">xa </span><span class="s2">in </span><span class="s1">xas</span><span class="s3">])</span>
    <span class="s1">xat </span><span class="s3">= </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s4">1.</span><span class="s3">).</span><span class="s1">dtype </span><span class="s2">if </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">isdtype</span><span class="s3">(</span><span class="s1">xat</span><span class="s3">, </span><span class="s6">&quot;integral&quot;</span><span class="s3">) </span><span class="s2">else </span><span class="s1">xat</span>
    <span class="s1">xs</span><span class="s3">, </span><span class="s1">args </span><span class="s3">= </span><span class="s1">xas</span><span class="s3">[:</span><span class="s1">nx</span><span class="s3">], </span><span class="s1">xas</span><span class="s3">[</span><span class="s1">nx</span><span class="s3">:]</span>
    <span class="s1">xs </span><span class="s3">= [</span><span class="s1">xp</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">xat</span><span class="s3">) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">xs</span><span class="s3">]  </span><span class="s0"># use copy=False when implemented</span>
    <span class="s1">fs </span><span class="s3">= [</span><span class="s1">xp</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">func</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">)) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">xs</span><span class="s3">]</span>
    <span class="s1">shape </span><span class="s3">= </span><span class="s1">xs</span><span class="s3">[</span><span class="s4">0</span><span class="s3">].</span><span class="s1">shape</span>
    <span class="s1">fshape </span><span class="s3">= </span><span class="s1">fs</span><span class="s3">[</span><span class="s4">0</span><span class="s3">].</span><span class="s1">shape</span>

    <span class="s2">if </span><span class="s1">preserve_shape</span><span class="s3">:</span>
        <span class="s0"># bind original shape/func now to avoid late-binding gotcha</span>
        <span class="s2">def </span><span class="s1">func</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">=</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">func</span><span class="s3">=</span><span class="s1">func</span><span class="s3">,  **</span><span class="s1">kwargs</span><span class="s3">):</span>
            <span class="s1">i </span><span class="s3">= (</span><span class="s4">0</span><span class="s3">,)*(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">fshape</span><span class="s3">) - </span><span class="s1">len</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">))</span>
            <span class="s2">return </span><span class="s1">func</span><span class="s3">(</span><span class="s1">x</span><span class="s3">[</span><span class="s1">i</span><span class="s3">], *</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">)</span>
        <span class="s1">shape </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">broadcast_shapes</span><span class="s3">(</span><span class="s1">fshape</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">)  </span><span class="s0"># just shapes; use of NumPy OK</span>
        <span class="s1">xs </span><span class="s3">= [</span><span class="s1">xp</span><span class="s3">.</span><span class="s1">broadcast_to</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">xs</span><span class="s3">]</span>
        <span class="s1">args </span><span class="s3">= [</span><span class="s1">xp</span><span class="s3">.</span><span class="s1">broadcast_to</span><span class="s3">(</span><span class="s1">arg</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">) </span><span class="s2">for </span><span class="s1">arg </span><span class="s2">in </span><span class="s1">args</span><span class="s3">]</span>

    <span class="s1">message </span><span class="s3">= (</span><span class="s6">&quot;The shape of the array returned by `func` must be the same as &quot;</span>
               <span class="s6">&quot;the broadcasted shape of `x` and all other `args`.&quot;</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">preserve_shape </span><span class="s2">is not None</span><span class="s3">:  </span><span class="s0"># only in tanhsinh for now</span>
        <span class="s1">message </span><span class="s3">= </span><span class="s6">f&quot;When `preserve_shape=False`, </span><span class="s2">{</span><span class="s1">message</span><span class="s3">.</span><span class="s1">lower</span><span class="s3">()</span><span class="s2">}</span><span class="s6">&quot;</span>
    <span class="s1">shapes_equal </span><span class="s3">= [</span><span class="s1">f</span><span class="s3">.</span><span class="s1">shape </span><span class="s3">== </span><span class="s1">shape </span><span class="s2">for </span><span class="s1">f </span><span class="s2">in </span><span class="s1">fs</span><span class="s3">]</span>
    <span class="s2">if not </span><span class="s1">all</span><span class="s3">(</span><span class="s1">shapes_equal</span><span class="s3">):  </span><span class="s0"># use Python all to reduce overhead</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s1">message</span><span class="s3">)</span>

    <span class="s0"># These algorithms tend to mix the dtypes of the abscissae and function</span>
    <span class="s0"># values, so figure out what the result will be and convert them all to</span>
    <span class="s0"># that type from the outset.</span>
    <span class="s1">xfat </span><span class="s3">= </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">result_type</span><span class="s3">(*([</span><span class="s1">f</span><span class="s3">.</span><span class="s1">dtype </span><span class="s2">for </span><span class="s1">f </span><span class="s2">in </span><span class="s1">fs</span><span class="s3">] + [</span><span class="s1">xat</span><span class="s3">]))</span>
    <span class="s2">if not </span><span class="s1">complex_ok </span><span class="s2">and not </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">isdtype</span><span class="s3">(</span><span class="s1">xfat</span><span class="s3">, </span><span class="s6">&quot;real floating&quot;</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s6">&quot;Abscissae and function output must be real numbers.&quot;</span><span class="s3">)</span>
    <span class="s1">xs </span><span class="s3">= [</span><span class="s1">xp</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">xfat</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">True</span><span class="s3">) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">xs</span><span class="s3">]</span>
    <span class="s1">fs </span><span class="s3">= [</span><span class="s1">xp</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">f</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">xfat</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">True</span><span class="s3">) </span><span class="s2">for </span><span class="s1">f </span><span class="s2">in </span><span class="s1">fs</span><span class="s3">]</span>

    <span class="s0"># To ensure that we can do indexing, we'll work with at least 1d arrays,</span>
    <span class="s0"># but remember the appropriate shape of the output.</span>
    <span class="s1">xs </span><span class="s3">= [</span><span class="s1">xp</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, (-</span><span class="s4">1</span><span class="s3">,)) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">xs</span><span class="s3">]</span>
    <span class="s1">fs </span><span class="s3">= [</span><span class="s1">xp</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">(</span><span class="s1">f</span><span class="s3">, (-</span><span class="s4">1</span><span class="s3">,)) </span><span class="s2">for </span><span class="s1">f </span><span class="s2">in </span><span class="s1">fs</span><span class="s3">]</span>
    <span class="s1">args </span><span class="s3">= [</span><span class="s1">xp</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">(</span><span class="s1">xp</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">arg</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">True</span><span class="s3">), (-</span><span class="s4">1</span><span class="s3">,)) </span><span class="s2">for </span><span class="s1">arg </span><span class="s2">in </span><span class="s1">args</span><span class="s3">]</span>
    <span class="s2">return </span><span class="s1">func</span><span class="s3">, </span><span class="s1">xs</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">, </span><span class="s1">xfat</span><span class="s3">, </span><span class="s1">xp</span>


<span class="s2">def </span><span class="s1">_loop</span><span class="s3">(</span><span class="s1">work</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">, </span><span class="s1">maxiter</span><span class="s3">, </span><span class="s1">func</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">pre_func_eval</span><span class="s3">,</span>
          <span class="s1">post_func_eval</span><span class="s3">, </span><span class="s1">check_termination</span><span class="s3">, </span><span class="s1">post_termination_check</span><span class="s3">,</span>
          <span class="s1">customize_result</span><span class="s3">, </span><span class="s1">res_work_pairs</span><span class="s3">, </span><span class="s1">xp</span><span class="s3">, </span><span class="s1">preserve_shape</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s5">&quot;&quot;&quot;Main loop of a vectorized scalar optimization algorithm 
 
    Parameters 
    ---------- 
    work : _RichResult 
        All variables that need to be retained between iterations. Must 
        contain attributes `nit`, `nfev`, and `success` 
    callback : callable 
        User-specified callback function 
    shape : tuple of ints 
        The shape of all output arrays 
    maxiter : 
        Maximum number of iterations of the algorithm 
    func : callable 
        The user-specified callable that is being optimized or solved 
    args : tuple 
        Additional positional arguments to be passed to `func`. 
    dtype : NumPy dtype 
        The common dtype of all abscissae and function values 
    pre_func_eval : callable 
        A function that accepts `work` and returns `x`, the active elements 
        of `x` at which `func` will be evaluated. May modify attributes 
        of `work` with any algorithmic steps that need to happen 
         at the beginning of an iteration, before `func` is evaluated, 
    post_func_eval : callable 
        A function that accepts `x`, `func(x)`, and `work`. May modify 
        attributes of `work` with any algorithmic steps that need to happen 
         in the middle of an iteration, after `func` is evaluated but before 
         the termination check. 
    check_termination : callable 
        A function that accepts `work` and returns `stop`, a boolean array 
        indicating which of the active elements have met a termination 
        condition. 
    post_termination_check : callable 
        A function that accepts `work`. May modify `work` with any algorithmic 
        steps that need to happen after the termination check and before the 
        end of the iteration. 
    customize_result : callable 
        A function that accepts `res` and `shape` and returns `shape`. May 
        modify `res` (in-place) according to preferences (e.g. rearrange 
        elements between attributes) and modify `shape` if needed. 
    res_work_pairs : list of (str, str) 
        Identifies correspondence between attributes of `res` and attributes 
        of `work`; i.e., attributes of active elements of `work` will be 
        copied to the appropriate indices of `res` when appropriate. The order 
        determines the order in which _RichResult attributes will be 
        pretty-printed. 
 
    Returns 
    ------- 
    res : _RichResult 
        The final result object 
 
    Notes 
    ----- 
    Besides providing structure, this framework provides several important 
    services for a vectorized optimization algorithm. 
 
    - It handles common tasks involving iteration count, function evaluation 
      count, a user-specified callback, and associated termination conditions. 
    - It compresses the attributes of `work` to eliminate unnecessary 
      computation on elements that have already converged. 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">xp </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span><span class="s3">(</span><span class="s6">&quot;Must provide xp.&quot;</span><span class="s3">)</span>

    <span class="s1">cb_terminate </span><span class="s3">= </span><span class="s2">False</span>

    <span class="s0"># Initialize the result object and active element index array</span>
    <span class="s1">n_elements </span><span class="s3">= </span><span class="s1">math</span><span class="s3">.</span><span class="s1">prod</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">)</span>
    <span class="s1">active </span><span class="s3">= </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s1">n_elements</span><span class="s3">)  </span><span class="s0"># in-progress element indices</span>
    <span class="s1">res_dict </span><span class="s3">= {</span><span class="s1">i</span><span class="s3">: </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">n_elements</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dtype</span><span class="s3">) </span><span class="s2">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">j </span><span class="s2">in </span><span class="s1">res_work_pairs</span><span class="s3">}</span>
    <span class="s1">res_dict</span><span class="s3">[</span><span class="s6">'success'</span><span class="s3">] = </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">n_elements</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">xp</span><span class="s3">.</span><span class="s1">bool</span><span class="s3">)</span>
    <span class="s1">res_dict</span><span class="s3">[</span><span class="s6">'status'</span><span class="s3">] = </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">full</span><span class="s3">(</span><span class="s1">n_elements</span><span class="s3">, </span><span class="s1">_EINPROGRESS</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">xp</span><span class="s3">.</span><span class="s1">int32</span><span class="s3">)</span>
    <span class="s1">res_dict</span><span class="s3">[</span><span class="s6">'nit'</span><span class="s3">] = </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">n_elements</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">xp</span><span class="s3">.</span><span class="s1">int32</span><span class="s3">)</span>
    <span class="s1">res_dict</span><span class="s3">[</span><span class="s6">'nfev'</span><span class="s3">] = </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">n_elements</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">xp</span><span class="s3">.</span><span class="s1">int32</span><span class="s3">)</span>
    <span class="s1">res </span><span class="s3">= </span><span class="s1">_RichResult</span><span class="s3">(</span><span class="s1">res_dict</span><span class="s3">)</span>
    <span class="s1">work</span><span class="s3">.</span><span class="s1">args </span><span class="s3">= </span><span class="s1">args</span>

    <span class="s1">active </span><span class="s3">= </span><span class="s1">_check_termination</span><span class="s3">(</span><span class="s1">work</span><span class="s3">, </span><span class="s1">res</span><span class="s3">, </span><span class="s1">res_work_pairs</span><span class="s3">, </span><span class="s1">active</span><span class="s3">,</span>
                                <span class="s1">check_termination</span><span class="s3">, </span><span class="s1">preserve_shape</span><span class="s3">, </span><span class="s1">xp</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">callback </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s1">temp </span><span class="s3">= </span><span class="s1">_prepare_result</span><span class="s3">(</span><span class="s1">work</span><span class="s3">, </span><span class="s1">res</span><span class="s3">, </span><span class="s1">res_work_pairs</span><span class="s3">, </span><span class="s1">active</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">,</span>
                               <span class="s1">customize_result</span><span class="s3">, </span><span class="s1">preserve_shape</span><span class="s3">, </span><span class="s1">xp</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">_call_callback_maybe_halt</span><span class="s3">(</span><span class="s1">callback</span><span class="s3">, </span><span class="s1">temp</span><span class="s3">):</span>
            <span class="s1">cb_terminate </span><span class="s3">= </span><span class="s2">True</span>

    <span class="s2">while </span><span class="s1">work</span><span class="s3">.</span><span class="s1">nit </span><span class="s3">&lt; </span><span class="s1">maxiter </span><span class="s2">and </span><span class="s1">xp_size</span><span class="s3">(</span><span class="s1">active</span><span class="s3">) </span><span class="s2">and not </span><span class="s1">cb_terminate </span><span class="s2">and </span><span class="s1">n_elements</span><span class="s3">:</span>
        <span class="s1">x </span><span class="s3">= </span><span class="s1">pre_func_eval</span><span class="s3">(</span><span class="s1">work</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">work</span><span class="s3">.</span><span class="s1">args </span><span class="s2">and </span><span class="s1">work</span><span class="s3">.</span><span class="s1">args</span><span class="s3">[</span><span class="s4">0</span><span class="s3">].</span><span class="s1">ndim </span><span class="s3">!= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">:</span>
            <span class="s0"># `x` always starts as 1D. If the SciPy function that uses</span>
            <span class="s0"># _loop added dimensions to `x`, we need to</span>
            <span class="s0"># add them to the elements of `args`.</span>
            <span class="s1">args </span><span class="s3">= []</span>
            <span class="s2">for </span><span class="s1">arg </span><span class="s2">in </span><span class="s1">work</span><span class="s3">.</span><span class="s1">args</span><span class="s3">:</span>
                <span class="s1">n_new_dims </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">- </span><span class="s1">arg</span><span class="s3">.</span><span class="s1">ndim</span>
                <span class="s1">new_shape </span><span class="s3">= </span><span class="s1">arg</span><span class="s3">.</span><span class="s1">shape </span><span class="s3">+ (</span><span class="s4">1</span><span class="s3">,)*</span><span class="s1">n_new_dims</span>
                <span class="s1">args</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">xp</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">(</span><span class="s1">arg</span><span class="s3">, </span><span class="s1">new_shape</span><span class="s3">))</span>
            <span class="s1">work</span><span class="s3">.</span><span class="s1">args </span><span class="s3">= </span><span class="s1">args</span>

        <span class="s1">x_shape </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">shape</span>
        <span class="s2">if </span><span class="s1">preserve_shape</span><span class="s3">:</span>
            <span class="s1">x </span><span class="s3">= </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, (</span><span class="s1">shape </span><span class="s3">+ (-</span><span class="s4">1</span><span class="s3">,)))</span>
        <span class="s1">f </span><span class="s3">= </span><span class="s1">func</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, *</span><span class="s1">work</span><span class="s3">.</span><span class="s1">args</span><span class="s3">)</span>
        <span class="s1">f </span><span class="s3">= </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">f</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dtype</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">preserve_shape</span><span class="s3">:</span>
            <span class="s1">x </span><span class="s3">= </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">x_shape</span><span class="s3">)</span>
            <span class="s1">f </span><span class="s3">= </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">(</span><span class="s1">f</span><span class="s3">, </span><span class="s1">x_shape</span><span class="s3">)</span>
        <span class="s1">work</span><span class="s3">.</span><span class="s1">nfev </span><span class="s3">+= </span><span class="s4">1 </span><span class="s2">if </span><span class="s1">x</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s4">1 </span><span class="s2">else </span><span class="s1">x</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[-</span><span class="s4">1</span><span class="s3">]</span>

        <span class="s1">post_func_eval</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">f</span><span class="s3">, </span><span class="s1">work</span><span class="s3">)</span>

        <span class="s1">work</span><span class="s3">.</span><span class="s1">nit </span><span class="s3">+= </span><span class="s4">1</span>
        <span class="s1">active </span><span class="s3">= </span><span class="s1">_check_termination</span><span class="s3">(</span><span class="s1">work</span><span class="s3">, </span><span class="s1">res</span><span class="s3">, </span><span class="s1">res_work_pairs</span><span class="s3">, </span><span class="s1">active</span><span class="s3">,</span>
                                    <span class="s1">check_termination</span><span class="s3">, </span><span class="s1">preserve_shape</span><span class="s3">, </span><span class="s1">xp</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">callback </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s1">temp </span><span class="s3">= </span><span class="s1">_prepare_result</span><span class="s3">(</span><span class="s1">work</span><span class="s3">, </span><span class="s1">res</span><span class="s3">, </span><span class="s1">res_work_pairs</span><span class="s3">, </span><span class="s1">active</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">,</span>
                                   <span class="s1">customize_result</span><span class="s3">, </span><span class="s1">preserve_shape</span><span class="s3">, </span><span class="s1">xp</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">_call_callback_maybe_halt</span><span class="s3">(</span><span class="s1">callback</span><span class="s3">, </span><span class="s1">temp</span><span class="s3">):</span>
                <span class="s1">cb_terminate </span><span class="s3">= </span><span class="s2">True</span>
                <span class="s2">break</span>
        <span class="s2">if </span><span class="s1">xp_size</span><span class="s3">(</span><span class="s1">active</span><span class="s3">) == </span><span class="s4">0</span><span class="s3">:</span>
            <span class="s2">break</span>

        <span class="s1">post_termination_check</span><span class="s3">(</span><span class="s1">work</span><span class="s3">)</span>

    <span class="s1">work</span><span class="s3">.</span><span class="s1">status</span><span class="s3">[:] = </span><span class="s1">_ECALLBACK </span><span class="s2">if </span><span class="s1">cb_terminate </span><span class="s2">else </span><span class="s1">_ECONVERR</span>
    <span class="s2">return </span><span class="s1">_prepare_result</span><span class="s3">(</span><span class="s1">work</span><span class="s3">, </span><span class="s1">res</span><span class="s3">, </span><span class="s1">res_work_pairs</span><span class="s3">, </span><span class="s1">active</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">,</span>
                           <span class="s1">customize_result</span><span class="s3">, </span><span class="s1">preserve_shape</span><span class="s3">, </span><span class="s1">xp</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">_check_termination</span><span class="s3">(</span><span class="s1">work</span><span class="s3">, </span><span class="s1">res</span><span class="s3">, </span><span class="s1">res_work_pairs</span><span class="s3">, </span><span class="s1">active</span><span class="s3">, </span><span class="s1">check_termination</span><span class="s3">,</span>
                       <span class="s1">preserve_shape</span><span class="s3">, </span><span class="s1">xp</span><span class="s3">):</span>
    <span class="s0"># Checks termination conditions, updates elements of `res` with</span>
    <span class="s0"># corresponding elements of `work`, and compresses `work`.</span>

    <span class="s1">stop </span><span class="s3">= </span><span class="s1">check_termination</span><span class="s3">(</span><span class="s1">work</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">any</span><span class="s3">(</span><span class="s1">stop</span><span class="s3">):</span>
        <span class="s0"># update the active elements of the result object with the active</span>
        <span class="s0"># elements for which a termination condition has been met</span>
        <span class="s1">_update_active</span><span class="s3">(</span><span class="s1">work</span><span class="s3">, </span><span class="s1">res</span><span class="s3">, </span><span class="s1">res_work_pairs</span><span class="s3">, </span><span class="s1">active</span><span class="s3">, </span><span class="s1">stop</span><span class="s3">, </span><span class="s1">preserve_shape</span><span class="s3">, </span><span class="s1">xp</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">preserve_shape</span><span class="s3">:</span>
            <span class="s1">stop </span><span class="s3">= </span><span class="s1">stop</span><span class="s3">[</span><span class="s1">active</span><span class="s3">]</span>

        <span class="s1">proceed </span><span class="s3">= ~</span><span class="s1">stop</span>
        <span class="s1">active </span><span class="s3">= </span><span class="s1">active</span><span class="s3">[</span><span class="s1">proceed</span><span class="s3">]</span>

        <span class="s2">if not </span><span class="s1">preserve_shape</span><span class="s3">:</span>
            <span class="s0"># compress the arrays to avoid unnecessary computation</span>
            <span class="s2">for </span><span class="s1">key</span><span class="s3">, </span><span class="s1">val </span><span class="s2">in </span><span class="s1">work</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
                <span class="s0"># Need to find a better way than these try/excepts</span>
                <span class="s0"># Somehow need to keep compressible numerical args separate</span>
                <span class="s2">if </span><span class="s1">key </span><span class="s3">== </span><span class="s6">'args'</span><span class="s3">:</span>
                    <span class="s2">continue</span>
                <span class="s2">try</span><span class="s3">:</span>
                    <span class="s1">work</span><span class="s3">[</span><span class="s1">key</span><span class="s3">] = </span><span class="s1">val</span><span class="s3">[</span><span class="s1">proceed</span><span class="s3">]</span>
                <span class="s2">except </span><span class="s3">(</span><span class="s1">IndexError</span><span class="s3">, </span><span class="s1">TypeError</span><span class="s3">, </span><span class="s1">KeyError</span><span class="s3">):  </span><span class="s0"># not a compressible array</span>
                    <span class="s1">work</span><span class="s3">[</span><span class="s1">key</span><span class="s3">] = </span><span class="s1">val</span>
            <span class="s1">work</span><span class="s3">.</span><span class="s1">args </span><span class="s3">= [</span><span class="s1">arg</span><span class="s3">[</span><span class="s1">proceed</span><span class="s3">] </span><span class="s2">for </span><span class="s1">arg </span><span class="s2">in </span><span class="s1">work</span><span class="s3">.</span><span class="s1">args</span><span class="s3">]</span>

    <span class="s2">return </span><span class="s1">active</span>


<span class="s2">def </span><span class="s1">_update_active</span><span class="s3">(</span><span class="s1">work</span><span class="s3">, </span><span class="s1">res</span><span class="s3">, </span><span class="s1">res_work_pairs</span><span class="s3">, </span><span class="s1">active</span><span class="s3">, </span><span class="s1">mask</span><span class="s3">, </span><span class="s1">preserve_shape</span><span class="s3">, </span><span class="s1">xp</span><span class="s3">):</span>
    <span class="s0"># Update `active` indices of the arrays in result object `res` with the</span>
    <span class="s0"># contents of the scalars and arrays in `update_dict`. When provided,</span>
    <span class="s0"># `mask` is a boolean array applied both to the arrays in `update_dict`</span>
    <span class="s0"># that are to be used and to the arrays in `res` that are to be updated.</span>
    <span class="s1">update_dict </span><span class="s3">= {</span><span class="s1">key1</span><span class="s3">: </span><span class="s1">work</span><span class="s3">[</span><span class="s1">key2</span><span class="s3">] </span><span class="s2">for </span><span class="s1">key1</span><span class="s3">, </span><span class="s1">key2 </span><span class="s2">in </span><span class="s1">res_work_pairs</span><span class="s3">}</span>
    <span class="s1">update_dict</span><span class="s3">[</span><span class="s6">'success'</span><span class="s3">] = </span><span class="s1">work</span><span class="s3">.</span><span class="s1">status </span><span class="s3">== </span><span class="s4">0</span>

    <span class="s2">if </span><span class="s1">mask </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">preserve_shape</span><span class="s3">:</span>
            <span class="s1">active_mask </span><span class="s3">= </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">zeros_like</span><span class="s3">(</span><span class="s1">mask</span><span class="s3">)</span>
            <span class="s1">active_mask</span><span class="s3">[</span><span class="s1">active</span><span class="s3">] = </span><span class="s4">1</span>
            <span class="s1">active_mask </span><span class="s3">= </span><span class="s1">active_mask </span><span class="s3">&amp; </span><span class="s1">mask</span>
            <span class="s2">for </span><span class="s1">key</span><span class="s3">, </span><span class="s1">val </span><span class="s2">in </span><span class="s1">update_dict</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
                <span class="s2">try</span><span class="s3">:</span>
                    <span class="s1">res</span><span class="s3">[</span><span class="s1">key</span><span class="s3">][</span><span class="s1">active_mask</span><span class="s3">] = </span><span class="s1">val</span><span class="s3">[</span><span class="s1">active_mask</span><span class="s3">]</span>
                <span class="s2">except </span><span class="s3">(</span><span class="s1">IndexError</span><span class="s3">, </span><span class="s1">TypeError</span><span class="s3">, </span><span class="s1">KeyError</span><span class="s3">):</span>
                    <span class="s1">res</span><span class="s3">[</span><span class="s1">key</span><span class="s3">][</span><span class="s1">active_mask</span><span class="s3">] = </span><span class="s1">val</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">active_mask </span><span class="s3">= </span><span class="s1">active</span><span class="s3">[</span><span class="s1">mask</span><span class="s3">]</span>
            <span class="s2">for </span><span class="s1">key</span><span class="s3">, </span><span class="s1">val </span><span class="s2">in </span><span class="s1">update_dict</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
                <span class="s2">try</span><span class="s3">:</span>
                    <span class="s1">res</span><span class="s3">[</span><span class="s1">key</span><span class="s3">][</span><span class="s1">active_mask</span><span class="s3">] = </span><span class="s1">val</span><span class="s3">[</span><span class="s1">mask</span><span class="s3">]</span>
                <span class="s2">except </span><span class="s3">(</span><span class="s1">IndexError</span><span class="s3">, </span><span class="s1">TypeError</span><span class="s3">, </span><span class="s1">KeyError</span><span class="s3">):</span>
                    <span class="s1">res</span><span class="s3">[</span><span class="s1">key</span><span class="s3">][</span><span class="s1">active_mask</span><span class="s3">] = </span><span class="s1">val</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">for </span><span class="s1">key</span><span class="s3">, </span><span class="s1">val </span><span class="s2">in </span><span class="s1">update_dict</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
            <span class="s2">if </span><span class="s1">preserve_shape</span><span class="s3">:</span>
                <span class="s2">try</span><span class="s3">:</span>
                    <span class="s1">val </span><span class="s3">= </span><span class="s1">val</span><span class="s3">[</span><span class="s1">active</span><span class="s3">]</span>
                <span class="s2">except </span><span class="s3">(</span><span class="s1">IndexError</span><span class="s3">, </span><span class="s1">TypeError</span><span class="s3">, </span><span class="s1">KeyError</span><span class="s3">):</span>
                    <span class="s2">pass</span>
            <span class="s1">res</span><span class="s3">[</span><span class="s1">key</span><span class="s3">][</span><span class="s1">active</span><span class="s3">] = </span><span class="s1">val</span>


<span class="s2">def </span><span class="s1">_prepare_result</span><span class="s3">(</span><span class="s1">work</span><span class="s3">, </span><span class="s1">res</span><span class="s3">, </span><span class="s1">res_work_pairs</span><span class="s3">, </span><span class="s1">active</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">, </span><span class="s1">customize_result</span><span class="s3">,</span>
                    <span class="s1">preserve_shape</span><span class="s3">, </span><span class="s1">xp</span><span class="s3">):</span>
    <span class="s0"># Prepare the result object `res` by creating a copy, copying the latest</span>
    <span class="s0"># data from work, running the provided result customization function,</span>
    <span class="s0"># and reshaping the data to the original shapes.</span>
    <span class="s1">res </span><span class="s3">= </span><span class="s1">res</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>
    <span class="s1">_update_active</span><span class="s3">(</span><span class="s1">work</span><span class="s3">, </span><span class="s1">res</span><span class="s3">, </span><span class="s1">res_work_pairs</span><span class="s3">, </span><span class="s1">active</span><span class="s3">, </span><span class="s2">None</span><span class="s3">, </span><span class="s1">preserve_shape</span><span class="s3">, </span><span class="s1">xp</span><span class="s3">)</span>

    <span class="s1">shape </span><span class="s3">= </span><span class="s1">customize_result</span><span class="s3">(</span><span class="s1">res</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">)</span>

    <span class="s2">for </span><span class="s1">key</span><span class="s3">, </span><span class="s1">val </span><span class="s2">in </span><span class="s1">res</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
        <span class="s0"># this looks like it won't work for xp != np if val is not numeric</span>
        <span class="s1">temp </span><span class="s3">= </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">(</span><span class="s1">val</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">)</span>
        <span class="s1">res</span><span class="s3">[</span><span class="s1">key</span><span class="s3">] = </span><span class="s1">temp</span><span class="s3">[()] </span><span class="s2">if </span><span class="s1">temp</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s4">0 </span><span class="s2">else </span><span class="s1">temp</span>

    <span class="s1">res</span><span class="s3">[</span><span class="s6">'_order_keys'</span><span class="s3">] = [</span><span class="s6">'success'</span><span class="s3">] + [</span><span class="s1">i </span><span class="s2">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">j </span><span class="s2">in </span><span class="s1">res_work_pairs</span><span class="s3">]</span>
    <span class="s2">return </span><span class="s1">_RichResult</span><span class="s3">(**</span><span class="s1">res</span><span class="s3">)</span>
</pre>
</body>
</html>