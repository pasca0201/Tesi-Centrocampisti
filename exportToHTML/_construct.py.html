<html>
<head>
<title>_construct.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #6aab73;}
.s4 { color: #cf8e6d;}
.s5 { color: #2aacb8;}
.s6 { color: #7a7e85;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_construct.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Functions to construct sparse matrices and arrays 
&quot;&quot;&quot;</span>

<span class="s1">__docformat__ </span><span class="s2">= </span><span class="s3">&quot;restructuredtext en&quot;</span>

<span class="s1">__all__ </span><span class="s2">= [</span><span class="s3">'spdiags'</span><span class="s2">, </span><span class="s3">'eye'</span><span class="s2">, </span><span class="s3">'identity'</span><span class="s2">, </span><span class="s3">'kron'</span><span class="s2">, </span><span class="s3">'kronsum'</span><span class="s2">,</span>
           <span class="s3">'hstack'</span><span class="s2">, </span><span class="s3">'vstack'</span><span class="s2">, </span><span class="s3">'bmat'</span><span class="s2">, </span><span class="s3">'rand'</span><span class="s2">, </span><span class="s3">'random'</span><span class="s2">, </span><span class="s3">'diags'</span><span class="s2">, </span><span class="s3">'block_diag'</span><span class="s2">,</span>
           <span class="s3">'diags_array'</span><span class="s2">, </span><span class="s3">'block_array'</span><span class="s2">, </span><span class="s3">'eye_array'</span><span class="s2">, </span><span class="s3">'random_array'</span><span class="s2">]</span>

<span class="s4">import </span><span class="s1">numbers</span>
<span class="s4">import </span><span class="s1">math</span>
<span class="s4">import </span><span class="s1">numpy </span><span class="s4">as </span><span class="s1">np</span>

<span class="s4">from </span><span class="s1">scipy</span><span class="s2">.</span><span class="s1">_lib</span><span class="s2">.</span><span class="s1">_util </span><span class="s4">import </span><span class="s1">check_random_state</span><span class="s2">, </span><span class="s1">rng_integers</span>
<span class="s4">from </span><span class="s2">.</span><span class="s1">_sputils </span><span class="s4">import </span><span class="s1">upcast</span><span class="s2">, </span><span class="s1">get_index_dtype</span><span class="s2">, </span><span class="s1">isscalarlike</span>

<span class="s4">from </span><span class="s2">.</span><span class="s1">_sparsetools </span><span class="s4">import </span><span class="s1">csr_hstack</span>
<span class="s4">from </span><span class="s2">.</span><span class="s1">_bsr </span><span class="s4">import </span><span class="s1">bsr_matrix</span><span class="s2">, </span><span class="s1">bsr_array</span>
<span class="s4">from </span><span class="s2">.</span><span class="s1">_coo </span><span class="s4">import </span><span class="s1">coo_matrix</span><span class="s2">, </span><span class="s1">coo_array</span>
<span class="s4">from </span><span class="s2">.</span><span class="s1">_csc </span><span class="s4">import </span><span class="s1">csc_matrix</span><span class="s2">, </span><span class="s1">csc_array</span>
<span class="s4">from </span><span class="s2">.</span><span class="s1">_csr </span><span class="s4">import </span><span class="s1">csr_matrix</span><span class="s2">, </span><span class="s1">csr_array</span>
<span class="s4">from </span><span class="s2">.</span><span class="s1">_dia </span><span class="s4">import </span><span class="s1">dia_matrix</span><span class="s2">, </span><span class="s1">dia_array</span>

<span class="s4">from </span><span class="s2">.</span><span class="s1">_base </span><span class="s4">import </span><span class="s1">issparse</span><span class="s2">, </span><span class="s1">sparray</span>


<span class="s4">def </span><span class="s1">spdiags</span><span class="s2">(</span><span class="s1">data</span><span class="s2">, </span><span class="s1">diags</span><span class="s2">, </span><span class="s1">m</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">n</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">format</span><span class="s2">=</span><span class="s4">None</span><span class="s2">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return a sparse matrix from diagonals. 
 
    Parameters 
    ---------- 
    data : array_like 
        Matrix diagonals stored row-wise 
    diags : sequence of int or an int 
        Diagonals to set: 
 
        * k = 0  the main diagonal 
        * k &gt; 0  the kth upper diagonal 
        * k &lt; 0  the kth lower diagonal 
    m, n : int, tuple, optional 
        Shape of the result. If `n` is None and `m` is a given tuple, 
        the shape is this tuple. If omitted, the matrix is square and 
        its shape is len(data[0]). 
    format : str, optional 
        Format of the result. By default (format=None) an appropriate sparse 
        matrix format is returned. This choice is subject to change. 
 
    .. warning:: 
 
        This function returns a sparse matrix -- not a sparse array. 
        You are encouraged to use ``diags_array`` to take advantage 
        of the sparse array functionality. 
 
    See Also 
    -------- 
    diags_array : more convenient form of this function 
    diags : matrix version of diags_array 
    dia_matrix : the sparse DIAgonal format. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.sparse import spdiags 
    &gt;&gt;&gt; data = np.array([[1, 2, 3, 4], [1, 2, 3, 4], [1, 2, 3, 4]]) 
    &gt;&gt;&gt; diags = np.array([0, -1, 2]) 
    &gt;&gt;&gt; spdiags(data, diags, 4, 4).toarray() 
    array([[1, 0, 3, 0], 
           [1, 2, 0, 4], 
           [0, 2, 3, 0], 
           [0, 0, 3, 4]]) 
 
    &quot;&quot;&quot;</span>
    <span class="s4">if </span><span class="s1">m </span><span class="s4">is None and </span><span class="s1">n </span><span class="s4">is None</span><span class="s2">:</span>
        <span class="s1">m </span><span class="s2">= </span><span class="s1">n </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">data</span><span class="s2">[</span><span class="s5">0</span><span class="s2">])</span>
    <span class="s4">elif </span><span class="s1">n </span><span class="s4">is None</span><span class="s2">:</span>
        <span class="s1">m</span><span class="s2">, </span><span class="s1">n </span><span class="s2">= </span><span class="s1">m</span>
    <span class="s4">return </span><span class="s1">dia_matrix</span><span class="s2">((</span><span class="s1">data</span><span class="s2">, </span><span class="s1">diags</span><span class="s2">), </span><span class="s1">shape</span><span class="s2">=(</span><span class="s1">m</span><span class="s2">, </span><span class="s1">n</span><span class="s2">)).</span><span class="s1">asformat</span><span class="s2">(</span><span class="s1">format</span><span class="s2">)</span>


<span class="s4">def </span><span class="s1">diags_array</span><span class="s2">(</span><span class="s1">diagonals</span><span class="s2">, /, *, </span><span class="s1">offsets</span><span class="s2">=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">shape</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">format</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s4">None</span><span class="s2">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Construct a sparse array from diagonals. 
 
    Parameters 
    ---------- 
    diagonals : sequence of array_like 
        Sequence of arrays containing the array diagonals, 
        corresponding to `offsets`. 
    offsets : sequence of int or an int, optional 
        Diagonals to set: 
          - k = 0  the main diagonal (default) 
          - k &gt; 0  the kth upper diagonal 
          - k &lt; 0  the kth lower diagonal 
    shape : tuple of int, optional 
        Shape of the result. If omitted, a square array large enough 
        to contain the diagonals is returned. 
    format : {&quot;dia&quot;, &quot;csr&quot;, &quot;csc&quot;, &quot;lil&quot;, ...}, optional 
        Matrix format of the result. By default (format=None) an 
        appropriate sparse array format is returned. This choice is 
        subject to change. 
    dtype : dtype, optional 
        Data type of the array. 
 
    Notes 
    ----- 
    The result from `diags_array` is the sparse equivalent of:: 
 
        np.diag(diagonals[0], offsets[0]) 
        + ... 
        + np.diag(diagonals[k], offsets[k]) 
 
    Repeated diagonal offsets are disallowed. 
 
    .. versionadded:: 1.11 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.sparse import diags_array 
    &gt;&gt;&gt; diagonals = [[1, 2, 3, 4], [1, 2, 3], [1, 2]] 
    &gt;&gt;&gt; diags_array(diagonals, offsets=[0, -1, 2]).toarray() 
    array([[1, 0, 1, 0], 
           [1, 2, 0, 2], 
           [0, 2, 3, 0], 
           [0, 0, 3, 4]]) 
 
    Broadcasting of scalars is supported (but shape needs to be 
    specified): 
 
    &gt;&gt;&gt; diags_array([1, -2, 1], offsets=[-1, 0, 1], shape=(4, 4)).toarray() 
    array([[-2.,  1.,  0.,  0.], 
           [ 1., -2.,  1.,  0.], 
           [ 0.,  1., -2.,  1.], 
           [ 0.,  0.,  1., -2.]]) 
 
 
    If only one diagonal is wanted (as in `numpy.diag`), the following 
    works as well: 
 
    &gt;&gt;&gt; diags_array([1, 2, 3], offsets=1).toarray() 
    array([[ 0.,  1.,  0.,  0.], 
           [ 0.,  0.,  2.,  0.], 
           [ 0.,  0.,  0.,  3.], 
           [ 0.,  0.,  0.,  0.]]) 
    &quot;&quot;&quot;</span>
    <span class="s6"># if offsets is not a sequence, assume that there's only one diagonal</span>
    <span class="s4">if </span><span class="s1">isscalarlike</span><span class="s2">(</span><span class="s1">offsets</span><span class="s2">):</span>
        <span class="s6"># now check that there's actually only one diagonal</span>
        <span class="s4">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">diagonals</span><span class="s2">) == </span><span class="s5">0 </span><span class="s4">or </span><span class="s1">isscalarlike</span><span class="s2">(</span><span class="s1">diagonals</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]):</span>
            <span class="s1">diagonals </span><span class="s2">= [</span><span class="s1">np</span><span class="s2">.</span><span class="s1">atleast_1d</span><span class="s2">(</span><span class="s1">diagonals</span><span class="s2">)]</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;Different number of diagonals and offsets.&quot;</span><span class="s2">)</span>
    <span class="s4">else</span><span class="s2">:</span>
        <span class="s1">diagonals </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">map</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">atleast_1d</span><span class="s2">, </span><span class="s1">diagonals</span><span class="s2">))</span>

    <span class="s1">offsets </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">atleast_1d</span><span class="s2">(</span><span class="s1">offsets</span><span class="s2">)</span>

    <span class="s6"># Basic check</span>
    <span class="s4">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">diagonals</span><span class="s2">) != </span><span class="s1">len</span><span class="s2">(</span><span class="s1">offsets</span><span class="s2">):</span>
        <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;Different number of diagonals and offsets.&quot;</span><span class="s2">)</span>

    <span class="s6"># Determine shape, if omitted</span>
    <span class="s4">if </span><span class="s1">shape </span><span class="s4">is None</span><span class="s2">:</span>
        <span class="s1">m </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">diagonals</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]) + </span><span class="s1">abs</span><span class="s2">(</span><span class="s1">int</span><span class="s2">(</span><span class="s1">offsets</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]))</span>
        <span class="s1">shape </span><span class="s2">= (</span><span class="s1">m</span><span class="s2">, </span><span class="s1">m</span><span class="s2">)</span>

    <span class="s6"># Determine data type, if omitted</span>
    <span class="s4">if </span><span class="s1">dtype </span><span class="s4">is None</span><span class="s2">:</span>
        <span class="s1">dtype </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">common_type</span><span class="s2">(*</span><span class="s1">diagonals</span><span class="s2">)</span>

    <span class="s6"># Construct data array</span>
    <span class="s1">m</span><span class="s2">, </span><span class="s1">n </span><span class="s2">= </span><span class="s1">shape</span>

    <span class="s1">M </span><span class="s2">= </span><span class="s1">max</span><span class="s2">([</span><span class="s1">min</span><span class="s2">(</span><span class="s1">m </span><span class="s2">+ </span><span class="s1">offset</span><span class="s2">, </span><span class="s1">n </span><span class="s2">- </span><span class="s1">offset</span><span class="s2">) + </span><span class="s1">max</span><span class="s2">(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">offset</span><span class="s2">)</span>
             <span class="s4">for </span><span class="s1">offset </span><span class="s4">in </span><span class="s1">offsets</span><span class="s2">])</span>
    <span class="s1">M </span><span class="s2">= </span><span class="s1">max</span><span class="s2">(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">M</span><span class="s2">)</span>
    <span class="s1">data_arr </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">((</span><span class="s1">len</span><span class="s2">(</span><span class="s1">offsets</span><span class="s2">), </span><span class="s1">M</span><span class="s2">), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">)</span>

    <span class="s1">K </span><span class="s2">= </span><span class="s1">min</span><span class="s2">(</span><span class="s1">m</span><span class="s2">, </span><span class="s1">n</span><span class="s2">)</span>

    <span class="s4">for </span><span class="s1">j</span><span class="s2">, </span><span class="s1">diagonal </span><span class="s4">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">diagonals</span><span class="s2">):</span>
        <span class="s1">offset </span><span class="s2">= </span><span class="s1">offsets</span><span class="s2">[</span><span class="s1">j</span><span class="s2">]</span>
        <span class="s1">k </span><span class="s2">= </span><span class="s1">max</span><span class="s2">(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">offset</span><span class="s2">)</span>
        <span class="s1">length </span><span class="s2">= </span><span class="s1">min</span><span class="s2">(</span><span class="s1">m </span><span class="s2">+ </span><span class="s1">offset</span><span class="s2">, </span><span class="s1">n </span><span class="s2">- </span><span class="s1">offset</span><span class="s2">, </span><span class="s1">K</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">length </span><span class="s2">&lt; </span><span class="s5">0</span><span class="s2">:</span>
            <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;Offset %d (index %d) out of bounds&quot; </span><span class="s2">% (</span><span class="s1">offset</span><span class="s2">, </span><span class="s1">j</span><span class="s2">))</span>
        <span class="s4">try</span><span class="s2">:</span>
            <span class="s1">data_arr</span><span class="s2">[</span><span class="s1">j</span><span class="s2">, </span><span class="s1">k</span><span class="s2">:</span><span class="s1">k</span><span class="s2">+</span><span class="s1">length</span><span class="s2">] = </span><span class="s1">diagonal</span><span class="s2">[...,:</span><span class="s1">length</span><span class="s2">]</span>
        <span class="s4">except </span><span class="s1">ValueError </span><span class="s4">as </span><span class="s1">e</span><span class="s2">:</span>
            <span class="s4">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">diagonal</span><span class="s2">) != </span><span class="s1">length </span><span class="s4">and </span><span class="s1">len</span><span class="s2">(</span><span class="s1">diagonal</span><span class="s2">) != </span><span class="s5">1</span><span class="s2">:</span>
                <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
                    <span class="s3">&quot;Diagonal length (index %d: %d at offset %d) does not &quot;</span>
                    <span class="s3">&quot;agree with array size (%d, %d).&quot; </span><span class="s2">% (</span>
                    <span class="s1">j</span><span class="s2">, </span><span class="s1">len</span><span class="s2">(</span><span class="s1">diagonal</span><span class="s2">), </span><span class="s1">offset</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">n</span><span class="s2">)) </span><span class="s4">from </span><span class="s1">e</span>
            <span class="s4">raise</span>

    <span class="s4">return </span><span class="s1">dia_array</span><span class="s2">((</span><span class="s1">data_arr</span><span class="s2">, </span><span class="s1">offsets</span><span class="s2">), </span><span class="s1">shape</span><span class="s2">=(</span><span class="s1">m</span><span class="s2">, </span><span class="s1">n</span><span class="s2">)).</span><span class="s1">asformat</span><span class="s2">(</span><span class="s1">format</span><span class="s2">)</span>


<span class="s4">def </span><span class="s1">diags</span><span class="s2">(</span><span class="s1">diagonals</span><span class="s2">, </span><span class="s1">offsets</span><span class="s2">=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">shape</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">format</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s4">None</span><span class="s2">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Construct a sparse matrix from diagonals. 
 
    .. warning:: 
 
        This function returns a sparse matrix -- not a sparse array. 
        You are encouraged to use ``diags_array`` to take advantage 
        of the sparse array functionality. 
 
    Parameters 
    ---------- 
    diagonals : sequence of array_like 
        Sequence of arrays containing the matrix diagonals, 
        corresponding to `offsets`. 
    offsets : sequence of int or an int, optional 
        Diagonals to set: 
          - k = 0  the main diagonal (default) 
          - k &gt; 0  the kth upper diagonal 
          - k &lt; 0  the kth lower diagonal 
    shape : tuple of int, optional 
        Shape of the result. If omitted, a square matrix large enough 
        to contain the diagonals is returned. 
    format : {&quot;dia&quot;, &quot;csr&quot;, &quot;csc&quot;, &quot;lil&quot;, ...}, optional 
        Matrix format of the result. By default (format=None) an 
        appropriate sparse matrix format is returned. This choice is 
        subject to change. 
    dtype : dtype, optional 
        Data type of the matrix. 
 
    See Also 
    -------- 
    spdiags : construct matrix from diagonals 
    diags_array : construct sparse array instead of sparse matrix 
 
    Notes 
    ----- 
    This function differs from `spdiags` in the way it handles 
    off-diagonals. 
 
    The result from `diags` is the sparse equivalent of:: 
 
        np.diag(diagonals[0], offsets[0]) 
        + ... 
        + np.diag(diagonals[k], offsets[k]) 
 
    Repeated diagonal offsets are disallowed. 
 
    .. versionadded:: 0.11 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.sparse import diags 
    &gt;&gt;&gt; diagonals = [[1, 2, 3, 4], [1, 2, 3], [1, 2]] 
    &gt;&gt;&gt; diags(diagonals, [0, -1, 2]).toarray() 
    array([[1, 0, 1, 0], 
           [1, 2, 0, 2], 
           [0, 2, 3, 0], 
           [0, 0, 3, 4]]) 
 
    Broadcasting of scalars is supported (but shape needs to be 
    specified): 
 
    &gt;&gt;&gt; diags([1, -2, 1], [-1, 0, 1], shape=(4, 4)).toarray() 
    array([[-2.,  1.,  0.,  0.], 
           [ 1., -2.,  1.,  0.], 
           [ 0.,  1., -2.,  1.], 
           [ 0.,  0.,  1., -2.]]) 
 
 
    If only one diagonal is wanted (as in `numpy.diag`), the following 
    works as well: 
 
    &gt;&gt;&gt; diags([1, 2, 3], 1).toarray() 
    array([[ 0.,  1.,  0.,  0.], 
           [ 0.,  0.,  2.,  0.], 
           [ 0.,  0.,  0.,  3.], 
           [ 0.,  0.,  0.,  0.]]) 
    &quot;&quot;&quot;</span>
    <span class="s1">A </span><span class="s2">= </span><span class="s1">diags_array</span><span class="s2">(</span><span class="s1">diagonals</span><span class="s2">, </span><span class="s1">offsets</span><span class="s2">=</span><span class="s1">offsets</span><span class="s2">, </span><span class="s1">shape</span><span class="s2">=</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">)</span>
    <span class="s4">return </span><span class="s1">dia_matrix</span><span class="s2">(</span><span class="s1">A</span><span class="s2">).</span><span class="s1">asformat</span><span class="s2">(</span><span class="s1">format</span><span class="s2">)</span>


<span class="s4">def </span><span class="s1">identity</span><span class="s2">(</span><span class="s1">n</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s3">'d'</span><span class="s2">, </span><span class="s1">format</span><span class="s2">=</span><span class="s4">None</span><span class="s2">):</span>
    <span class="s0">&quot;&quot;&quot;Identity matrix in sparse format 
 
    Returns an identity matrix with shape (n,n) using a given 
    sparse format and dtype. This differs from `eye_array` in 
    that it has a square shape with ones only on the main diagonal. 
    It is thus the multiplicative identity. `eye_array` allows 
    rectangular shapes and the diagonal can be offset from the main one. 
 
    .. warning:: 
 
        This function returns a sparse matrix -- not a sparse array. 
        You are encouraged to use ``eye_array`` to take advantage 
        of the sparse array functionality. 
 
    Parameters 
    ---------- 
    n : int 
        Shape of the identity matrix. 
    dtype : dtype, optional 
        Data type of the matrix 
    format : str, optional 
        Sparse format of the result, e.g., format=&quot;csr&quot;, etc. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import scipy as sp 
    &gt;&gt;&gt; sp.sparse.identity(3).toarray() 
    array([[ 1.,  0.,  0.], 
           [ 0.,  1.,  0.], 
           [ 0.,  0.,  1.]]) 
    &gt;&gt;&gt; sp.sparse.identity(3, dtype='int8', format='dia') 
    &lt;DIAgonal sparse matrix of dtype 'int8' 
        with 3 stored elements (1 diagonals) and shape (3, 3)&gt; 
    &gt;&gt;&gt; sp.sparse.eye_array(3, dtype='int8', format='dia') 
    &lt;DIAgonal sparse array of dtype 'int8' 
        with 3 stored elements (1 diagonals) and shape (3, 3)&gt; 
 
    &quot;&quot;&quot;</span>
    <span class="s4">return </span><span class="s1">eye</span><span class="s2">(</span><span class="s1">n</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">format</span><span class="s2">=</span><span class="s1">format</span><span class="s2">)</span>


<span class="s4">def </span><span class="s1">eye_array</span><span class="s2">(</span><span class="s1">m</span><span class="s2">, </span><span class="s1">n</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, *, </span><span class="s1">k</span><span class="s2">=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">float</span><span class="s2">, </span><span class="s1">format</span><span class="s2">=</span><span class="s4">None</span><span class="s2">):</span>
    <span class="s0">&quot;&quot;&quot;Identity matrix in sparse array format 
 
    Return a sparse array with ones on diagonal. 
    Specifically a sparse array (m x n) where the kth diagonal 
    is all ones and everything else is zeros. 
 
    Parameters 
    ---------- 
    m : int or tuple of ints 
        Number of rows requested. 
    n : int, optional 
        Number of columns. Default: `m`. 
    k : int, optional 
        Diagonal to place ones on. Default: 0 (main diagonal). 
    dtype : dtype, optional 
        Data type of the array 
    format : str, optional (default: &quot;dia&quot;) 
        Sparse format of the result, e.g., format=&quot;csr&quot;, etc. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; import scipy as sp 
    &gt;&gt;&gt; sp.sparse.eye_array(3).toarray() 
    array([[ 1.,  0.,  0.], 
           [ 0.,  1.,  0.], 
           [ 0.,  0.,  1.]]) 
    &gt;&gt;&gt; sp.sparse.eye_array(3, dtype=np.int8) 
    &lt;DIAgonal sparse array of dtype 'int8' 
        with 3 stored elements (1 diagonals) and shape (3, 3)&gt; 
 
    &quot;&quot;&quot;</span>
    <span class="s6"># TODO: delete next 15 lines [combine with _eye()] once spmatrix removed</span>
    <span class="s4">return </span><span class="s1">_eye</span><span class="s2">(</span><span class="s1">m</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">k</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">format</span><span class="s2">)</span>


<span class="s4">def </span><span class="s1">_eye</span><span class="s2">(</span><span class="s1">m</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">k</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">format</span><span class="s2">, </span><span class="s1">as_sparray</span><span class="s2">=</span><span class="s4">True</span><span class="s2">):</span>
    <span class="s4">if </span><span class="s1">as_sparray</span><span class="s2">:</span>
        <span class="s1">csr_sparse </span><span class="s2">= </span><span class="s1">csr_array</span>
        <span class="s1">csc_sparse </span><span class="s2">= </span><span class="s1">csc_array</span>
        <span class="s1">coo_sparse </span><span class="s2">= </span><span class="s1">coo_array</span>
        <span class="s1">diags_sparse </span><span class="s2">= </span><span class="s1">diags_array</span>
    <span class="s4">else</span><span class="s2">:</span>
        <span class="s1">csr_sparse </span><span class="s2">= </span><span class="s1">csr_matrix</span>
        <span class="s1">csc_sparse </span><span class="s2">= </span><span class="s1">csc_matrix</span>
        <span class="s1">coo_sparse </span><span class="s2">= </span><span class="s1">coo_matrix</span>
        <span class="s1">diags_sparse </span><span class="s2">= </span><span class="s1">diags</span>

    <span class="s4">if </span><span class="s1">n </span><span class="s4">is None</span><span class="s2">:</span>
        <span class="s1">n </span><span class="s2">= </span><span class="s1">m</span>
    <span class="s1">m</span><span class="s2">, </span><span class="s1">n </span><span class="s2">= </span><span class="s1">int</span><span class="s2">(</span><span class="s1">m</span><span class="s2">), </span><span class="s1">int</span><span class="s2">(</span><span class="s1">n</span><span class="s2">)</span>

    <span class="s4">if </span><span class="s1">m </span><span class="s2">== </span><span class="s1">n </span><span class="s4">and </span><span class="s1">k </span><span class="s2">== </span><span class="s5">0</span><span class="s2">:</span>
        <span class="s6"># fast branch for special formats</span>
        <span class="s4">if </span><span class="s1">format </span><span class="s4">in </span><span class="s2">[</span><span class="s3">'csr'</span><span class="s2">, </span><span class="s3">'csc'</span><span class="s2">]:</span>
            <span class="s1">idx_dtype </span><span class="s2">= </span><span class="s1">get_index_dtype</span><span class="s2">(</span><span class="s1">maxval</span><span class="s2">=</span><span class="s1">n</span><span class="s2">)</span>
            <span class="s1">indptr </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(</span><span class="s1">n</span><span class="s2">+</span><span class="s5">1</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">idx_dtype</span><span class="s2">)</span>
            <span class="s1">indices </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(</span><span class="s1">n</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">idx_dtype</span><span class="s2">)</span>
            <span class="s1">data </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">(</span><span class="s1">n</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">)</span>
            <span class="s1">cls </span><span class="s2">= {</span><span class="s3">'csr'</span><span class="s2">: </span><span class="s1">csr_sparse</span><span class="s2">, </span><span class="s3">'csc'</span><span class="s2">: </span><span class="s1">csc_sparse</span><span class="s2">}[</span><span class="s1">format</span><span class="s2">]</span>
            <span class="s4">return </span><span class="s1">cls</span><span class="s2">((</span><span class="s1">data</span><span class="s2">, </span><span class="s1">indices</span><span class="s2">, </span><span class="s1">indptr</span><span class="s2">), (</span><span class="s1">n</span><span class="s2">, </span><span class="s1">n</span><span class="s2">))</span>

        <span class="s4">elif </span><span class="s1">format </span><span class="s2">== </span><span class="s3">'coo'</span><span class="s2">:</span>
            <span class="s1">idx_dtype </span><span class="s2">= </span><span class="s1">get_index_dtype</span><span class="s2">(</span><span class="s1">maxval</span><span class="s2">=</span><span class="s1">n</span><span class="s2">)</span>
            <span class="s1">row </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(</span><span class="s1">n</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">idx_dtype</span><span class="s2">)</span>
            <span class="s1">col </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(</span><span class="s1">n</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">idx_dtype</span><span class="s2">)</span>
            <span class="s1">data </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">(</span><span class="s1">n</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">)</span>
            <span class="s4">return </span><span class="s1">coo_sparse</span><span class="s2">((</span><span class="s1">data</span><span class="s2">, (</span><span class="s1">row</span><span class="s2">, </span><span class="s1">col</span><span class="s2">)), (</span><span class="s1">n</span><span class="s2">, </span><span class="s1">n</span><span class="s2">))</span>

    <span class="s1">data </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">((</span><span class="s5">1</span><span class="s2">, </span><span class="s1">max</span><span class="s2">(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">min</span><span class="s2">(</span><span class="s1">m </span><span class="s2">+ </span><span class="s1">k</span><span class="s2">, </span><span class="s1">n</span><span class="s2">))), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">)</span>
    <span class="s4">return </span><span class="s1">diags_sparse</span><span class="s2">(</span><span class="s1">data</span><span class="s2">, </span><span class="s1">offsets</span><span class="s2">=[</span><span class="s1">k</span><span class="s2">], </span><span class="s1">shape</span><span class="s2">=(</span><span class="s1">m</span><span class="s2">, </span><span class="s1">n</span><span class="s2">), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">).</span><span class="s1">asformat</span><span class="s2">(</span><span class="s1">format</span><span class="s2">)</span>


<span class="s4">def </span><span class="s1">eye</span><span class="s2">(</span><span class="s1">m</span><span class="s2">, </span><span class="s1">n</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">k</span><span class="s2">=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">float</span><span class="s2">, </span><span class="s1">format</span><span class="s2">=</span><span class="s4">None</span><span class="s2">):</span>
    <span class="s0">&quot;&quot;&quot;Sparse matrix with ones on diagonal 
 
    Returns a sparse matrix (m x n) where the kth diagonal 
    is all ones and everything else is zeros. 
 
    Parameters 
    ---------- 
    m : int 
        Number of rows in the matrix. 
    n : int, optional 
        Number of columns. Default: `m`. 
    k : int, optional 
        Diagonal to place ones on. Default: 0 (main diagonal). 
    dtype : dtype, optional 
        Data type of the matrix. 
    format : str, optional 
        Sparse format of the result, e.g., format=&quot;csr&quot;, etc. 
 
    .. warning:: 
 
        This function returns a sparse matrix -- not a sparse array. 
        You are encouraged to use ``eye_array`` to take advantage 
        of the sparse array functionality. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; import scipy as sp 
    &gt;&gt;&gt; sp.sparse.eye(3).toarray() 
    array([[ 1.,  0.,  0.], 
           [ 0.,  1.,  0.], 
           [ 0.,  0.,  1.]]) 
    &gt;&gt;&gt; sp.sparse.eye(3, dtype=np.int8) 
    &lt;DIAgonal sparse matrix of dtype 'int8' 
        with 3 stored elements (1 diagonals) and shape (3, 3)&gt; 
 
    &quot;&quot;&quot;</span>
    <span class="s4">return </span><span class="s1">_eye</span><span class="s2">(</span><span class="s1">m</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">k</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">format</span><span class="s2">, </span><span class="s4">False</span><span class="s2">)</span>


<span class="s4">def </span><span class="s1">kron</span><span class="s2">(</span><span class="s1">A</span><span class="s2">, </span><span class="s1">B</span><span class="s2">, </span><span class="s1">format</span><span class="s2">=</span><span class="s4">None</span><span class="s2">):</span>
    <span class="s0">&quot;&quot;&quot;kronecker product of sparse matrices A and B 
 
    Parameters 
    ---------- 
    A : sparse or dense matrix 
        first matrix of the product 
    B : sparse or dense matrix 
        second matrix of the product 
    format : str, optional (default: 'bsr' or 'coo') 
        format of the result (e.g. &quot;csr&quot;) 
        If None, choose 'bsr' for relatively dense array and 'coo' for others 
 
    Returns 
    ------- 
    kronecker product in a sparse format. 
    Returns a sparse matrix unless either A or B is a 
    sparse array in which case returns a sparse array. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; import scipy as sp 
    &gt;&gt;&gt; A = sp.sparse.csr_array(np.array([[0, 2], [5, 0]])) 
    &gt;&gt;&gt; B = sp.sparse.csr_array(np.array([[1, 2], [3, 4]])) 
    &gt;&gt;&gt; sp.sparse.kron(A, B).toarray() 
    array([[ 0,  0,  2,  4], 
           [ 0,  0,  6,  8], 
           [ 5, 10,  0,  0], 
           [15, 20,  0,  0]]) 
 
    &gt;&gt;&gt; sp.sparse.kron(A, [[1, 2], [3, 4]]).toarray() 
    array([[ 0,  0,  2,  4], 
           [ 0,  0,  6,  8], 
           [ 5, 10,  0,  0], 
           [15, 20,  0,  0]]) 
 
    &quot;&quot;&quot;</span>
    <span class="s6"># TODO: delete next 10 lines and replace _sparse with _array when spmatrix removed</span>
    <span class="s4">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">A</span><span class="s2">, </span><span class="s1">sparray</span><span class="s2">) </span><span class="s4">or </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">B</span><span class="s2">, </span><span class="s1">sparray</span><span class="s2">):</span>
        <span class="s6"># convert to local variables</span>
        <span class="s1">bsr_sparse </span><span class="s2">= </span><span class="s1">bsr_array</span>
        <span class="s1">csr_sparse </span><span class="s2">= </span><span class="s1">csr_array</span>
        <span class="s1">coo_sparse </span><span class="s2">= </span><span class="s1">coo_array</span>
    <span class="s4">else</span><span class="s2">:  </span><span class="s6"># use spmatrix</span>
        <span class="s1">bsr_sparse </span><span class="s2">= </span><span class="s1">bsr_matrix</span>
        <span class="s1">csr_sparse </span><span class="s2">= </span><span class="s1">csr_matrix</span>
        <span class="s1">coo_sparse </span><span class="s2">= </span><span class="s1">coo_matrix</span>

    <span class="s1">B </span><span class="s2">= </span><span class="s1">coo_sparse</span><span class="s2">(</span><span class="s1">B</span><span class="s2">)</span>
    <span class="s4">if </span><span class="s1">B</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">!= </span><span class="s5">2</span><span class="s2">:</span>
        <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">f&quot;kron requires 2D input arrays. `B` is </span><span class="s4">{</span><span class="s1">B</span><span class="s2">.</span><span class="s1">ndim</span><span class="s4">}</span><span class="s3">D.&quot;</span><span class="s2">)</span>

    <span class="s6"># B is fairly dense, use BSR</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s1">format </span><span class="s4">is None or </span><span class="s1">format </span><span class="s2">== </span><span class="s3">&quot;bsr&quot;</span><span class="s2">) </span><span class="s4">and </span><span class="s5">2</span><span class="s2">*</span><span class="s1">B</span><span class="s2">.</span><span class="s1">nnz </span><span class="s2">&gt;= </span><span class="s1">B</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">0</span><span class="s2">] * </span><span class="s1">B</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">1</span><span class="s2">]:</span>
        <span class="s1">A </span><span class="s2">= </span><span class="s1">csr_sparse</span><span class="s2">(</span><span class="s1">A</span><span class="s2">,</span><span class="s1">copy</span><span class="s2">=</span><span class="s4">True</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">A</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">!= </span><span class="s5">2</span><span class="s2">:</span>
            <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">f&quot;kron requires 2D input arrays. `A` is </span><span class="s4">{</span><span class="s1">A</span><span class="s2">.</span><span class="s1">ndim</span><span class="s4">}</span><span class="s3">D.&quot;</span><span class="s2">)</span>
        <span class="s1">output_shape </span><span class="s2">= (</span><span class="s1">A</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]*</span><span class="s1">B</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">0</span><span class="s2">], </span><span class="s1">A</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">1</span><span class="s2">]*</span><span class="s1">B</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">1</span><span class="s2">])</span>

        <span class="s4">if </span><span class="s1">A</span><span class="s2">.</span><span class="s1">nnz </span><span class="s2">== </span><span class="s5">0 </span><span class="s4">or </span><span class="s1">B</span><span class="s2">.</span><span class="s1">nnz </span><span class="s2">== </span><span class="s5">0</span><span class="s2">:</span>
            <span class="s6"># kronecker product is the zero matrix</span>
            <span class="s4">return </span><span class="s1">coo_sparse</span><span class="s2">(</span><span class="s1">output_shape</span><span class="s2">).</span><span class="s1">asformat</span><span class="s2">(</span><span class="s1">format</span><span class="s2">)</span>

        <span class="s1">B </span><span class="s2">= </span><span class="s1">B</span><span class="s2">.</span><span class="s1">toarray</span><span class="s2">()</span>
        <span class="s1">data </span><span class="s2">= </span><span class="s1">A</span><span class="s2">.</span><span class="s1">data</span><span class="s2">.</span><span class="s1">repeat</span><span class="s2">(</span><span class="s1">B</span><span class="s2">.</span><span class="s1">size</span><span class="s2">).</span><span class="s1">reshape</span><span class="s2">(-</span><span class="s5">1</span><span class="s2">,</span><span class="s1">B</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">0</span><span class="s2">],</span><span class="s1">B</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">1</span><span class="s2">])</span>
        <span class="s1">data </span><span class="s2">= </span><span class="s1">data </span><span class="s2">* </span><span class="s1">B</span>

        <span class="s4">return </span><span class="s1">bsr_sparse</span><span class="s2">((</span><span class="s1">data</span><span class="s2">,</span><span class="s1">A</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">,</span><span class="s1">A</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">), </span><span class="s1">shape</span><span class="s2">=</span><span class="s1">output_shape</span><span class="s2">)</span>
    <span class="s4">else</span><span class="s2">:</span>
        <span class="s6"># use COO</span>
        <span class="s1">A </span><span class="s2">= </span><span class="s1">coo_sparse</span><span class="s2">(</span><span class="s1">A</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">A</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">!= </span><span class="s5">2</span><span class="s2">:</span>
            <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">f&quot;kron requires 2D input arrays. `A` is </span><span class="s4">{</span><span class="s1">A</span><span class="s2">.</span><span class="s1">ndim</span><span class="s4">}</span><span class="s3">D.&quot;</span><span class="s2">)</span>
        <span class="s1">output_shape </span><span class="s2">= (</span><span class="s1">A</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]*</span><span class="s1">B</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">0</span><span class="s2">], </span><span class="s1">A</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">1</span><span class="s2">]*</span><span class="s1">B</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">1</span><span class="s2">])</span>

        <span class="s4">if </span><span class="s1">A</span><span class="s2">.</span><span class="s1">nnz </span><span class="s2">== </span><span class="s5">0 </span><span class="s4">or </span><span class="s1">B</span><span class="s2">.</span><span class="s1">nnz </span><span class="s2">== </span><span class="s5">0</span><span class="s2">:</span>
            <span class="s6"># kronecker product is the zero matrix</span>
            <span class="s4">return </span><span class="s1">coo_sparse</span><span class="s2">(</span><span class="s1">output_shape</span><span class="s2">).</span><span class="s1">asformat</span><span class="s2">(</span><span class="s1">format</span><span class="s2">)</span>

        <span class="s6"># expand entries of a into blocks</span>
        <span class="s1">row </span><span class="s2">= </span><span class="s1">A</span><span class="s2">.</span><span class="s1">row</span><span class="s2">.</span><span class="s1">repeat</span><span class="s2">(</span><span class="s1">B</span><span class="s2">.</span><span class="s1">nnz</span><span class="s2">)</span>
        <span class="s1">col </span><span class="s2">= </span><span class="s1">A</span><span class="s2">.</span><span class="s1">col</span><span class="s2">.</span><span class="s1">repeat</span><span class="s2">(</span><span class="s1">B</span><span class="s2">.</span><span class="s1">nnz</span><span class="s2">)</span>
        <span class="s1">data </span><span class="s2">= </span><span class="s1">A</span><span class="s2">.</span><span class="s1">data</span><span class="s2">.</span><span class="s1">repeat</span><span class="s2">(</span><span class="s1">B</span><span class="s2">.</span><span class="s1">nnz</span><span class="s2">)</span>

        <span class="s4">if </span><span class="s1">max</span><span class="s2">(</span><span class="s1">A</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]*</span><span class="s1">B</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">0</span><span class="s2">], </span><span class="s1">A</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">1</span><span class="s2">]*</span><span class="s1">B</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">1</span><span class="s2">]) &gt; </span><span class="s1">np</span><span class="s2">.</span><span class="s1">iinfo</span><span class="s2">(</span><span class="s3">'int32'</span><span class="s2">).</span><span class="s1">max</span><span class="s2">:</span>
            <span class="s1">row </span><span class="s2">= </span><span class="s1">row</span><span class="s2">.</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">int64</span><span class="s2">)</span>
            <span class="s1">col </span><span class="s2">= </span><span class="s1">col</span><span class="s2">.</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">int64</span><span class="s2">)</span>

        <span class="s1">row </span><span class="s2">*= </span><span class="s1">B</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]</span>
        <span class="s1">col </span><span class="s2">*= </span><span class="s1">B</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">1</span><span class="s2">]</span>

        <span class="s6"># increment block indices</span>
        <span class="s1">row</span><span class="s2">,</span><span class="s1">col </span><span class="s2">= </span><span class="s1">row</span><span class="s2">.</span><span class="s1">reshape</span><span class="s2">(-</span><span class="s5">1</span><span class="s2">,</span><span class="s1">B</span><span class="s2">.</span><span class="s1">nnz</span><span class="s2">),</span><span class="s1">col</span><span class="s2">.</span><span class="s1">reshape</span><span class="s2">(-</span><span class="s5">1</span><span class="s2">,</span><span class="s1">B</span><span class="s2">.</span><span class="s1">nnz</span><span class="s2">)</span>
        <span class="s1">row </span><span class="s2">+= </span><span class="s1">B</span><span class="s2">.</span><span class="s1">row</span>
        <span class="s1">col </span><span class="s2">+= </span><span class="s1">B</span><span class="s2">.</span><span class="s1">col</span>
        <span class="s1">row</span><span class="s2">,</span><span class="s1">col </span><span class="s2">= </span><span class="s1">row</span><span class="s2">.</span><span class="s1">reshape</span><span class="s2">(-</span><span class="s5">1</span><span class="s2">),</span><span class="s1">col</span><span class="s2">.</span><span class="s1">reshape</span><span class="s2">(-</span><span class="s5">1</span><span class="s2">)</span>

        <span class="s6"># compute block entries</span>
        <span class="s1">data </span><span class="s2">= </span><span class="s1">data</span><span class="s2">.</span><span class="s1">reshape</span><span class="s2">(-</span><span class="s5">1</span><span class="s2">,</span><span class="s1">B</span><span class="s2">.</span><span class="s1">nnz</span><span class="s2">) * </span><span class="s1">B</span><span class="s2">.</span><span class="s1">data</span>
        <span class="s1">data </span><span class="s2">= </span><span class="s1">data</span><span class="s2">.</span><span class="s1">reshape</span><span class="s2">(-</span><span class="s5">1</span><span class="s2">)</span>

        <span class="s4">return </span><span class="s1">coo_sparse</span><span class="s2">((</span><span class="s1">data</span><span class="s2">,(</span><span class="s1">row</span><span class="s2">,</span><span class="s1">col</span><span class="s2">)), </span><span class="s1">shape</span><span class="s2">=</span><span class="s1">output_shape</span><span class="s2">).</span><span class="s1">asformat</span><span class="s2">(</span><span class="s1">format</span><span class="s2">)</span>


<span class="s4">def </span><span class="s1">kronsum</span><span class="s2">(</span><span class="s1">A</span><span class="s2">, </span><span class="s1">B</span><span class="s2">, </span><span class="s1">format</span><span class="s2">=</span><span class="s4">None</span><span class="s2">):</span>
    <span class="s0">&quot;&quot;&quot;kronecker sum of square sparse matrices A and B 
 
    Kronecker sum of two sparse matrices is a sum of two Kronecker 
    products kron(I_n,A) + kron(B,I_m) where A has shape (m,m) 
    and B has shape (n,n) and I_m and I_n are identity matrices 
    of shape (m,m) and (n,n), respectively. 
 
    Parameters 
    ---------- 
    A 
        square matrix 
    B 
        square matrix 
    format : str 
        format of the result (e.g. &quot;csr&quot;) 
 
    Returns 
    ------- 
    kronecker sum in a sparse matrix format 
 
    &quot;&quot;&quot;</span>
    <span class="s6"># TODO: delete next 8 lines and replace _sparse with _array when spmatrix removed</span>
    <span class="s4">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">A</span><span class="s2">, </span><span class="s1">sparray</span><span class="s2">) </span><span class="s4">or </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">B</span><span class="s2">, </span><span class="s1">sparray</span><span class="s2">):</span>
        <span class="s6"># convert to local variables</span>
        <span class="s1">coo_sparse </span><span class="s2">= </span><span class="s1">coo_array</span>
        <span class="s1">identity_sparse </span><span class="s2">= </span><span class="s1">eye_array</span>
    <span class="s4">else</span><span class="s2">:</span>
        <span class="s1">coo_sparse </span><span class="s2">= </span><span class="s1">coo_matrix</span>
        <span class="s1">identity_sparse </span><span class="s2">= </span><span class="s1">identity</span>

    <span class="s1">A </span><span class="s2">= </span><span class="s1">coo_sparse</span><span class="s2">(</span><span class="s1">A</span><span class="s2">)</span>
    <span class="s1">B </span><span class="s2">= </span><span class="s1">coo_sparse</span><span class="s2">(</span><span class="s1">B</span><span class="s2">)</span>

    <span class="s4">if </span><span class="s1">A</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">!= </span><span class="s5">2</span><span class="s2">:</span>
        <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">f&quot;kronsum requires 2D inputs. `A` is </span><span class="s4">{</span><span class="s1">A</span><span class="s2">.</span><span class="s1">ndim</span><span class="s4">}</span><span class="s3">D.&quot;</span><span class="s2">)</span>
    <span class="s4">if </span><span class="s1">B</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">!= </span><span class="s5">2</span><span class="s2">:</span>
        <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">f&quot;kronsum requires 2D inputs. `B` is </span><span class="s4">{</span><span class="s1">B</span><span class="s2">.</span><span class="s1">ndim</span><span class="s4">}</span><span class="s3">D.&quot;</span><span class="s2">)</span>
    <span class="s4">if </span><span class="s1">A</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">0</span><span class="s2">] != </span><span class="s1">A</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">1</span><span class="s2">]:</span>
        <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">'A is not square'</span><span class="s2">)</span>
    <span class="s4">if </span><span class="s1">B</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">0</span><span class="s2">] != </span><span class="s1">B</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">1</span><span class="s2">]:</span>
        <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">'B is not square'</span><span class="s2">)</span>

    <span class="s1">dtype </span><span class="s2">= </span><span class="s1">upcast</span><span class="s2">(</span><span class="s1">A</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">B</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>

    <span class="s1">I_n </span><span class="s2">= </span><span class="s1">identity_sparse</span><span class="s2">(</span><span class="s1">A</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">0</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">)</span>
    <span class="s1">I_m </span><span class="s2">= </span><span class="s1">identity_sparse</span><span class="s2">(</span><span class="s1">B</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">0</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">)</span>
    <span class="s1">L </span><span class="s2">= </span><span class="s1">kron</span><span class="s2">(</span><span class="s1">I_m</span><span class="s2">, </span><span class="s1">A</span><span class="s2">, </span><span class="s1">format</span><span class="s2">=</span><span class="s3">'coo'</span><span class="s2">)</span>
    <span class="s1">R </span><span class="s2">= </span><span class="s1">kron</span><span class="s2">(</span><span class="s1">B</span><span class="s2">, </span><span class="s1">I_n</span><span class="s2">, </span><span class="s1">format</span><span class="s2">=</span><span class="s3">'coo'</span><span class="s2">)</span>

    <span class="s4">return </span><span class="s2">(</span><span class="s1">L </span><span class="s2">+ </span><span class="s1">R</span><span class="s2">).</span><span class="s1">asformat</span><span class="s2">(</span><span class="s1">format</span><span class="s2">)</span>


<span class="s4">def </span><span class="s1">_compressed_sparse_stack</span><span class="s2">(</span><span class="s1">blocks</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">return_spmatrix</span><span class="s2">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Stacking fast path for CSR/CSC matrices or arrays 
    (i) vstack for CSR, (ii) hstack for CSC. 
    &quot;&quot;&quot;</span>
    <span class="s1">other_axis </span><span class="s2">= </span><span class="s5">1 </span><span class="s4">if </span><span class="s1">axis </span><span class="s2">== </span><span class="s5">0 </span><span class="s4">else </span><span class="s5">0</span>
    <span class="s1">data </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">concatenate</span><span class="s2">([</span><span class="s1">b</span><span class="s2">.</span><span class="s1">data </span><span class="s4">for </span><span class="s1">b </span><span class="s4">in </span><span class="s1">blocks</span><span class="s2">])</span>
    <span class="s1">constant_dim </span><span class="s2">= </span><span class="s1">blocks</span><span class="s2">[</span><span class="s5">0</span><span class="s2">].</span><span class="s1">_shape_as_2d</span><span class="s2">[</span><span class="s1">other_axis</span><span class="s2">]</span>
    <span class="s1">idx_dtype </span><span class="s2">= </span><span class="s1">get_index_dtype</span><span class="s2">(</span><span class="s1">arrays</span><span class="s2">=[</span><span class="s1">b</span><span class="s2">.</span><span class="s1">indptr </span><span class="s4">for </span><span class="s1">b </span><span class="s4">in </span><span class="s1">blocks</span><span class="s2">],</span>
                                <span class="s1">maxval</span><span class="s2">=</span><span class="s1">max</span><span class="s2">(</span><span class="s1">data</span><span class="s2">.</span><span class="s1">size</span><span class="s2">, </span><span class="s1">constant_dim</span><span class="s2">))</span>
    <span class="s1">indices </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">(</span><span class="s1">data</span><span class="s2">.</span><span class="s1">size</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">idx_dtype</span><span class="s2">)</span>
    <span class="s1">indptr </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">(</span><span class="s1">sum</span><span class="s2">(</span><span class="s1">b</span><span class="s2">.</span><span class="s1">_shape_as_2d</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">] </span><span class="s4">for </span><span class="s1">b </span><span class="s4">in </span><span class="s1">blocks</span><span class="s2">) + </span><span class="s5">1</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">idx_dtype</span><span class="s2">)</span>
    <span class="s1">last_indptr </span><span class="s2">= </span><span class="s1">idx_dtype</span><span class="s2">(</span><span class="s5">0</span><span class="s2">)</span>
    <span class="s1">sum_dim </span><span class="s2">= </span><span class="s5">0</span>
    <span class="s1">sum_indices </span><span class="s2">= </span><span class="s5">0</span>
    <span class="s4">for </span><span class="s1">b </span><span class="s4">in </span><span class="s1">blocks</span><span class="s2">:</span>
        <span class="s4">if </span><span class="s1">b</span><span class="s2">.</span><span class="s1">_shape_as_2d</span><span class="s2">[</span><span class="s1">other_axis</span><span class="s2">] != </span><span class="s1">constant_dim</span><span class="s2">:</span>
            <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">f'incompatible dimensions for axis </span><span class="s4">{</span><span class="s1">other_axis</span><span class="s4">}</span><span class="s3">'</span><span class="s2">)</span>
        <span class="s1">indices</span><span class="s2">[</span><span class="s1">sum_indices</span><span class="s2">:</span><span class="s1">sum_indices</span><span class="s2">+</span><span class="s1">b</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">.</span><span class="s1">size</span><span class="s2">] = </span><span class="s1">b</span><span class="s2">.</span><span class="s1">indices</span>
        <span class="s1">sum_indices </span><span class="s2">+= </span><span class="s1">b</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">.</span><span class="s1">size</span>
        <span class="s1">idxs </span><span class="s2">= </span><span class="s1">slice</span><span class="s2">(</span><span class="s1">sum_dim</span><span class="s2">, </span><span class="s1">sum_dim </span><span class="s2">+ </span><span class="s1">b</span><span class="s2">.</span><span class="s1">_shape_as_2d</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">])</span>
        <span class="s1">indptr</span><span class="s2">[</span><span class="s1">idxs</span><span class="s2">] = </span><span class="s1">b</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">[:-</span><span class="s5">1</span><span class="s2">]</span>
        <span class="s1">indptr</span><span class="s2">[</span><span class="s1">idxs</span><span class="s2">] += </span><span class="s1">last_indptr</span>
        <span class="s1">sum_dim </span><span class="s2">+= </span><span class="s1">b</span><span class="s2">.</span><span class="s1">_shape_as_2d</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">]</span>
        <span class="s1">last_indptr </span><span class="s2">+= </span><span class="s1">b</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">[-</span><span class="s5">1</span><span class="s2">]</span>
    <span class="s1">indptr</span><span class="s2">[-</span><span class="s5">1</span><span class="s2">] = </span><span class="s1">last_indptr</span>
    <span class="s6"># TODO remove this if-structure when sparse matrices removed</span>
    <span class="s4">if </span><span class="s1">return_spmatrix</span><span class="s2">:</span>
        <span class="s4">if </span><span class="s1">axis </span><span class="s2">== </span><span class="s5">0</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s1">csr_matrix</span><span class="s2">((</span><span class="s1">data</span><span class="s2">, </span><span class="s1">indices</span><span class="s2">, </span><span class="s1">indptr</span><span class="s2">),</span>
                              <span class="s1">shape</span><span class="s2">=(</span><span class="s1">sum_dim</span><span class="s2">, </span><span class="s1">constant_dim</span><span class="s2">))</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s1">csc_matrix</span><span class="s2">((</span><span class="s1">data</span><span class="s2">, </span><span class="s1">indices</span><span class="s2">, </span><span class="s1">indptr</span><span class="s2">),</span>
                              <span class="s1">shape</span><span class="s2">=(</span><span class="s1">constant_dim</span><span class="s2">, </span><span class="s1">sum_dim</span><span class="s2">))</span>

    <span class="s4">if </span><span class="s1">axis </span><span class="s2">== </span><span class="s5">0</span><span class="s2">:</span>
        <span class="s4">return </span><span class="s1">csr_array</span><span class="s2">((</span><span class="s1">data</span><span class="s2">, </span><span class="s1">indices</span><span class="s2">, </span><span class="s1">indptr</span><span class="s2">),</span>
                          <span class="s1">shape</span><span class="s2">=(</span><span class="s1">sum_dim</span><span class="s2">, </span><span class="s1">constant_dim</span><span class="s2">))</span>
    <span class="s4">else</span><span class="s2">:</span>
        <span class="s4">return </span><span class="s1">csc_array</span><span class="s2">((</span><span class="s1">data</span><span class="s2">, </span><span class="s1">indices</span><span class="s2">, </span><span class="s1">indptr</span><span class="s2">),</span>
                          <span class="s1">shape</span><span class="s2">=(</span><span class="s1">constant_dim</span><span class="s2">, </span><span class="s1">sum_dim</span><span class="s2">))</span>


<span class="s4">def </span><span class="s1">_stack_along_minor_axis</span><span class="s2">(</span><span class="s1">blocks</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Stacking fast path for CSR/CSC matrices along the minor axis 
    (i) hstack for CSR, (ii) vstack for CSC. 
    &quot;&quot;&quot;</span>
    <span class="s1">n_blocks </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">blocks</span><span class="s2">)</span>
    <span class="s4">if </span><span class="s1">n_blocks </span><span class="s2">== </span><span class="s5">0</span><span class="s2">:</span>
        <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">'Missing block matrices'</span><span class="s2">)</span>

    <span class="s4">if </span><span class="s1">n_blocks </span><span class="s2">== </span><span class="s5">1</span><span class="s2">:</span>
        <span class="s4">return </span><span class="s1">blocks</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]</span>

    <span class="s6"># check for incompatible dimensions</span>
    <span class="s1">other_axis </span><span class="s2">= </span><span class="s5">1 </span><span class="s4">if </span><span class="s1">axis </span><span class="s2">== </span><span class="s5">0 </span><span class="s4">else </span><span class="s5">0</span>
    <span class="s1">other_axis_dims </span><span class="s2">= {</span><span class="s1">b</span><span class="s2">.</span><span class="s1">_shape_as_2d</span><span class="s2">[</span><span class="s1">other_axis</span><span class="s2">] </span><span class="s4">for </span><span class="s1">b </span><span class="s4">in </span><span class="s1">blocks</span><span class="s2">}</span>
    <span class="s4">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">other_axis_dims</span><span class="s2">) &gt; </span><span class="s5">1</span><span class="s2">:</span>
        <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">f'Mismatching dimensions along axis </span><span class="s4">{</span><span class="s1">other_axis</span><span class="s4">}</span><span class="s3">: '</span>
                         <span class="s3">f'</span><span class="s4">{</span><span class="s1">other_axis_dims</span><span class="s4">}</span><span class="s3">'</span><span class="s2">)</span>
    <span class="s1">constant_dim</span><span class="s2">, = </span><span class="s1">other_axis_dims</span>

    <span class="s6"># Do the stacking</span>
    <span class="s1">indptr_list </span><span class="s2">= [</span><span class="s1">b</span><span class="s2">.</span><span class="s1">indptr </span><span class="s4">for </span><span class="s1">b </span><span class="s4">in </span><span class="s1">blocks</span><span class="s2">]</span>
    <span class="s1">data_cat </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">concatenate</span><span class="s2">([</span><span class="s1">b</span><span class="s2">.</span><span class="s1">data </span><span class="s4">for </span><span class="s1">b </span><span class="s4">in </span><span class="s1">blocks</span><span class="s2">])</span>

    <span class="s6"># Need to check if any indices/indptr, would be too large post-</span>
    <span class="s6"># concatenation for np.int32:</span>
    <span class="s6"># - The max value of indices is the output array's stacking-axis length - 1</span>
    <span class="s6"># - The max value in indptr is the number of non-zero entries. This is</span>
    <span class="s6">#   exceedingly unlikely to require int64, but is checked out of an</span>
    <span class="s6">#   abundance of caution.</span>
    <span class="s1">sum_dim </span><span class="s2">= </span><span class="s1">sum</span><span class="s2">(</span><span class="s1">b</span><span class="s2">.</span><span class="s1">_shape_as_2d</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">] </span><span class="s4">for </span><span class="s1">b </span><span class="s4">in </span><span class="s1">blocks</span><span class="s2">)</span>
    <span class="s1">nnz </span><span class="s2">= </span><span class="s1">sum</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">b</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">) </span><span class="s4">for </span><span class="s1">b </span><span class="s4">in </span><span class="s1">blocks</span><span class="s2">)</span>
    <span class="s1">idx_dtype </span><span class="s2">= </span><span class="s1">get_index_dtype</span><span class="s2">(</span><span class="s1">maxval</span><span class="s2">=</span><span class="s1">max</span><span class="s2">(</span><span class="s1">sum_dim </span><span class="s2">- </span><span class="s5">1</span><span class="s2">, </span><span class="s1">nnz</span><span class="s2">))</span>
    <span class="s1">stack_dim_cat </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s1">b</span><span class="s2">.</span><span class="s1">_shape_as_2d</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">] </span><span class="s4">for </span><span class="s1">b </span><span class="s4">in </span><span class="s1">blocks</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">idx_dtype</span><span class="s2">)</span>
    <span class="s4">if </span><span class="s1">data_cat</span><span class="s2">.</span><span class="s1">size </span><span class="s2">&gt; </span><span class="s5">0</span><span class="s2">:</span>
        <span class="s1">indptr_cat </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">concatenate</span><span class="s2">(</span><span class="s1">indptr_list</span><span class="s2">).</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">idx_dtype</span><span class="s2">)</span>
        <span class="s1">indices_cat </span><span class="s2">= (</span><span class="s1">np</span><span class="s2">.</span><span class="s1">concatenate</span><span class="s2">([</span><span class="s1">b</span><span class="s2">.</span><span class="s1">indices </span><span class="s4">for </span><span class="s1">b </span><span class="s4">in </span><span class="s1">blocks</span><span class="s2">])</span>
                       <span class="s2">.</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">idx_dtype</span><span class="s2">))</span>
        <span class="s1">indptr </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">(</span><span class="s1">constant_dim </span><span class="s2">+ </span><span class="s5">1</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">idx_dtype</span><span class="s2">)</span>
        <span class="s1">indices </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty_like</span><span class="s2">(</span><span class="s1">indices_cat</span><span class="s2">)</span>
        <span class="s1">data </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty_like</span><span class="s2">(</span><span class="s1">data_cat</span><span class="s2">)</span>
        <span class="s1">csr_hstack</span><span class="s2">(</span><span class="s1">n_blocks</span><span class="s2">, </span><span class="s1">constant_dim</span><span class="s2">, </span><span class="s1">stack_dim_cat</span><span class="s2">,</span>
                   <span class="s1">indptr_cat</span><span class="s2">, </span><span class="s1">indices_cat</span><span class="s2">, </span><span class="s1">data_cat</span><span class="s2">,</span>
                   <span class="s1">indptr</span><span class="s2">, </span><span class="s1">indices</span><span class="s2">, </span><span class="s1">data</span><span class="s2">)</span>
    <span class="s4">else</span><span class="s2">:</span>
        <span class="s1">indptr </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">(</span><span class="s1">constant_dim </span><span class="s2">+ </span><span class="s5">1</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">idx_dtype</span><span class="s2">)</span>
        <span class="s1">indices </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">idx_dtype</span><span class="s2">)</span>
        <span class="s1">data </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">data_cat</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>

    <span class="s4">if </span><span class="s1">axis </span><span class="s2">== </span><span class="s5">0</span><span class="s2">:</span>
        <span class="s4">return </span><span class="s1">blocks</span><span class="s2">[</span><span class="s5">0</span><span class="s2">].</span><span class="s1">_csc_container</span><span class="s2">((</span><span class="s1">data</span><span class="s2">, </span><span class="s1">indices</span><span class="s2">, </span><span class="s1">indptr</span><span class="s2">),</span>
                          <span class="s1">shape</span><span class="s2">=(</span><span class="s1">sum_dim</span><span class="s2">, </span><span class="s1">constant_dim</span><span class="s2">))</span>
    <span class="s4">else</span><span class="s2">:</span>
        <span class="s4">return </span><span class="s1">blocks</span><span class="s2">[</span><span class="s5">0</span><span class="s2">].</span><span class="s1">_csr_container</span><span class="s2">((</span><span class="s1">data</span><span class="s2">, </span><span class="s1">indices</span><span class="s2">, </span><span class="s1">indptr</span><span class="s2">),</span>
                          <span class="s1">shape</span><span class="s2">=(</span><span class="s1">constant_dim</span><span class="s2">, </span><span class="s1">sum_dim</span><span class="s2">))</span>


<span class="s4">def </span><span class="s1">hstack</span><span class="s2">(</span><span class="s1">blocks</span><span class="s2">, </span><span class="s1">format</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s4">None</span><span class="s2">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Stack sparse matrices horizontally (column wise) 
 
    Parameters 
    ---------- 
    blocks 
        sequence of sparse matrices with compatible shapes 
    format : str 
        sparse format of the result (e.g., &quot;csr&quot;) 
        by default an appropriate sparse matrix format is returned. 
        This choice is subject to change. 
    dtype : dtype, optional 
        The data-type of the output matrix. If not given, the dtype is 
        determined from that of `blocks`. 
 
    Returns 
    ------- 
    new_array : sparse matrix or array 
        If any block in blocks is a sparse array, return a sparse array. 
        Otherwise return a sparse matrix. 
 
        If you want a sparse array built from blocks that are not sparse 
        arrays, use `block(hstack(blocks))` or convert one block 
        e.g. `blocks[0] = csr_array(blocks[0])`. 
 
    See Also 
    -------- 
    vstack : stack sparse matrices vertically (row wise) 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.sparse import coo_matrix, hstack 
    &gt;&gt;&gt; A = coo_matrix([[1, 2], [3, 4]]) 
    &gt;&gt;&gt; B = coo_matrix([[5], [6]]) 
    &gt;&gt;&gt; hstack([A,B]).toarray() 
    array([[1, 2, 5], 
           [3, 4, 6]]) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">blocks </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">blocks</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s3">'object'</span><span class="s2">)</span>
    <span class="s4">if </span><span class="s1">any</span><span class="s2">(</span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">b</span><span class="s2">, </span><span class="s1">sparray</span><span class="s2">) </span><span class="s4">for </span><span class="s1">b </span><span class="s4">in </span><span class="s1">blocks</span><span class="s2">.</span><span class="s1">flat</span><span class="s2">):</span>
        <span class="s4">return </span><span class="s1">_block</span><span class="s2">([</span><span class="s1">blocks</span><span class="s2">], </span><span class="s1">format</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">)</span>
    <span class="s4">else</span><span class="s2">:</span>
        <span class="s4">return </span><span class="s1">_block</span><span class="s2">([</span><span class="s1">blocks</span><span class="s2">], </span><span class="s1">format</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">return_spmatrix</span><span class="s2">=</span><span class="s4">True</span><span class="s2">)</span>


<span class="s4">def </span><span class="s1">vstack</span><span class="s2">(</span><span class="s1">blocks</span><span class="s2">, </span><span class="s1">format</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s4">None</span><span class="s2">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Stack sparse arrays vertically (row wise) 
 
    Parameters 
    ---------- 
    blocks 
        sequence of sparse arrays with compatible shapes 
    format : str, optional 
        sparse format of the result (e.g., &quot;csr&quot;) 
        by default an appropriate sparse array format is returned. 
        This choice is subject to change. 
    dtype : dtype, optional 
        The data-type of the output array. If not given, the dtype is 
        determined from that of `blocks`. 
 
    Returns 
    ------- 
    new_array : sparse matrix or array 
        If any block in blocks is a sparse array, return a sparse array. 
        Otherwise return a sparse matrix. 
 
        If you want a sparse array built from blocks that are not sparse 
        arrays, use `block(vstack(blocks))` or convert one block 
        e.g. `blocks[0] = csr_array(blocks[0])`. 
 
    See Also 
    -------- 
    hstack : stack sparse matrices horizontally (column wise) 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.sparse import coo_array, vstack 
    &gt;&gt;&gt; A = coo_array([[1, 2], [3, 4]]) 
    &gt;&gt;&gt; B = coo_array([[5, 6]]) 
    &gt;&gt;&gt; vstack([A, B]).toarray() 
    array([[1, 2], 
           [3, 4], 
           [5, 6]]) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">blocks </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">blocks</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s3">'object'</span><span class="s2">)</span>
    <span class="s4">if </span><span class="s1">any</span><span class="s2">(</span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">b</span><span class="s2">, </span><span class="s1">sparray</span><span class="s2">) </span><span class="s4">for </span><span class="s1">b </span><span class="s4">in </span><span class="s1">blocks</span><span class="s2">.</span><span class="s1">flat</span><span class="s2">):</span>
        <span class="s4">return </span><span class="s1">_block</span><span class="s2">([[</span><span class="s1">b</span><span class="s2">] </span><span class="s4">for </span><span class="s1">b </span><span class="s4">in </span><span class="s1">blocks</span><span class="s2">], </span><span class="s1">format</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">)</span>
    <span class="s4">else</span><span class="s2">:</span>
        <span class="s4">return </span><span class="s1">_block</span><span class="s2">([[</span><span class="s1">b</span><span class="s2">] </span><span class="s4">for </span><span class="s1">b </span><span class="s4">in </span><span class="s1">blocks</span><span class="s2">], </span><span class="s1">format</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">return_spmatrix</span><span class="s2">=</span><span class="s4">True</span><span class="s2">)</span>


<span class="s4">def </span><span class="s1">bmat</span><span class="s2">(</span><span class="s1">blocks</span><span class="s2">, </span><span class="s1">format</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s4">None</span><span class="s2">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Build a sparse array or matrix from sparse sub-blocks 
 
    Note: `block_array` is preferred over `bmat`. They are the same function 
    except that `bmat` can return a deprecated sparse matrix. 
    `bmat` returns a coo_matrix if none of the inputs are a sparse array. 
 
    .. warning:: 
 
        This function returns a sparse matrix -- not a sparse array. 
        You are encouraged to use ``block_array`` to take advantage 
        of the sparse array functionality. 
 
    Parameters 
    ---------- 
    blocks : array_like 
        Grid of sparse matrices with compatible shapes. 
        An entry of None implies an all-zero matrix. 
    format : {'bsr', 'coo', 'csc', 'csr', 'dia', 'dok', 'lil'}, optional 
        The sparse format of the result (e.g. &quot;csr&quot;). By default an 
        appropriate sparse matrix format is returned. 
        This choice is subject to change. 
    dtype : dtype, optional 
        The data-type of the output matrix. If not given, the dtype is 
        determined from that of `blocks`. 
 
    Returns 
    ------- 
    bmat : sparse matrix or array 
        If any block in blocks is a sparse array, return a sparse array. 
        Otherwise return a sparse matrix. 
 
        If you want a sparse array built from blocks that are not sparse 
        arrays, use `block_array()`. 
 
    See Also 
    -------- 
    block_array 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.sparse import coo_array, bmat 
    &gt;&gt;&gt; A = coo_array([[1, 2], [3, 4]]) 
    &gt;&gt;&gt; B = coo_array([[5], [6]]) 
    &gt;&gt;&gt; C = coo_array([[7]]) 
    &gt;&gt;&gt; bmat([[A, B], [None, C]]).toarray() 
    array([[1, 2, 5], 
           [3, 4, 6], 
           [0, 0, 7]]) 
 
    &gt;&gt;&gt; bmat([[A, None], [None, C]]).toarray() 
    array([[1, 2, 0], 
           [3, 4, 0], 
           [0, 0, 7]]) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">blocks </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">blocks</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s3">'object'</span><span class="s2">)</span>
    <span class="s4">if </span><span class="s1">any</span><span class="s2">(</span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">b</span><span class="s2">, </span><span class="s1">sparray</span><span class="s2">) </span><span class="s4">for </span><span class="s1">b </span><span class="s4">in </span><span class="s1">blocks</span><span class="s2">.</span><span class="s1">flat</span><span class="s2">):</span>
        <span class="s4">return </span><span class="s1">_block</span><span class="s2">(</span><span class="s1">blocks</span><span class="s2">, </span><span class="s1">format</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">)</span>
    <span class="s4">else</span><span class="s2">:</span>
        <span class="s4">return </span><span class="s1">_block</span><span class="s2">(</span><span class="s1">blocks</span><span class="s2">, </span><span class="s1">format</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">return_spmatrix</span><span class="s2">=</span><span class="s4">True</span><span class="s2">)</span>


<span class="s4">def </span><span class="s1">block_array</span><span class="s2">(</span><span class="s1">blocks</span><span class="s2">, *, </span><span class="s1">format</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s4">None</span><span class="s2">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Build a sparse array from sparse sub-blocks 
 
    Parameters 
    ---------- 
    blocks : array_like 
        Grid of sparse arrays with compatible shapes. 
        An entry of None implies an all-zero array. 
    format : {'bsr', 'coo', 'csc', 'csr', 'dia', 'dok', 'lil'}, optional 
        The sparse format of the result (e.g. &quot;csr&quot;). By default an 
        appropriate sparse array format is returned. 
        This choice is subject to change. 
    dtype : dtype, optional 
        The data-type of the output array. If not given, the dtype is 
        determined from that of `blocks`. 
 
    Returns 
    ------- 
    block : sparse array 
 
    See Also 
    -------- 
    block_diag : specify blocks along the main diagonals 
    diags : specify (possibly offset) diagonals 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.sparse import coo_array, block_array 
    &gt;&gt;&gt; A = coo_array([[1, 2], [3, 4]]) 
    &gt;&gt;&gt; B = coo_array([[5], [6]]) 
    &gt;&gt;&gt; C = coo_array([[7]]) 
    &gt;&gt;&gt; block_array([[A, B], [None, C]]).toarray() 
    array([[1, 2, 5], 
           [3, 4, 6], 
           [0, 0, 7]]) 
 
    &gt;&gt;&gt; block_array([[A, None], [None, C]]).toarray() 
    array([[1, 2, 0], 
           [3, 4, 0], 
           [0, 0, 7]]) 
 
    &quot;&quot;&quot;</span>
    <span class="s4">return </span><span class="s1">_block</span><span class="s2">(</span><span class="s1">blocks</span><span class="s2">, </span><span class="s1">format</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">)</span>


<span class="s4">def </span><span class="s1">_block</span><span class="s2">(</span><span class="s1">blocks</span><span class="s2">, </span><span class="s1">format</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">return_spmatrix</span><span class="s2">=</span><span class="s4">False</span><span class="s2">):</span>
    <span class="s1">blocks </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">blocks</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s3">'object'</span><span class="s2">)</span>

    <span class="s4">if </span><span class="s1">blocks</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">!= </span><span class="s5">2</span><span class="s2">:</span>
        <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">'blocks must be 2-D'</span><span class="s2">)</span>

    <span class="s1">M</span><span class="s2">,</span><span class="s1">N </span><span class="s2">= </span><span class="s1">blocks</span><span class="s2">.</span><span class="s1">shape</span>

    <span class="s6"># check for fast path cases</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s1">format </span><span class="s4">in </span><span class="s2">(</span><span class="s4">None</span><span class="s2">, </span><span class="s3">'csr'</span><span class="s2">) </span><span class="s4">and</span>
        <span class="s1">all</span><span class="s2">(</span><span class="s1">issparse</span><span class="s2">(</span><span class="s1">b</span><span class="s2">) </span><span class="s4">and </span><span class="s1">b</span><span class="s2">.</span><span class="s1">format </span><span class="s2">== </span><span class="s3">'csr' </span><span class="s4">for </span><span class="s1">b </span><span class="s4">in </span><span class="s1">blocks</span><span class="s2">.</span><span class="s1">flat</span><span class="s2">)</span>
    <span class="s2">):</span>
        <span class="s4">if </span><span class="s1">N </span><span class="s2">&gt; </span><span class="s5">1</span><span class="s2">:</span>
            <span class="s6"># stack along columns (axis 1): must have shape (M, 1)</span>
            <span class="s1">blocks </span><span class="s2">= [[</span><span class="s1">_stack_along_minor_axis</span><span class="s2">(</span><span class="s1">blocks</span><span class="s2">[</span><span class="s1">b</span><span class="s2">, :], </span><span class="s5">1</span><span class="s2">)] </span><span class="s4">for </span><span class="s1">b </span><span class="s4">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">M</span><span class="s2">)]</span>
            <span class="s1">blocks </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">blocks</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s3">'object'</span><span class="s2">)</span>

        <span class="s6"># stack along rows (axis 0):</span>
        <span class="s1">A </span><span class="s2">= </span><span class="s1">_compressed_sparse_stack</span><span class="s2">(</span><span class="s1">blocks</span><span class="s2">[:, </span><span class="s5">0</span><span class="s2">], </span><span class="s5">0</span><span class="s2">, </span><span class="s1">return_spmatrix</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">dtype </span><span class="s4">is not None</span><span class="s2">:</span>
            <span class="s1">A </span><span class="s2">= </span><span class="s1">A</span><span class="s2">.</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s4">return </span><span class="s1">A</span>
    <span class="s4">elif </span><span class="s2">(</span><span class="s1">format </span><span class="s4">in </span><span class="s2">(</span><span class="s4">None</span><span class="s2">, </span><span class="s3">'csc'</span><span class="s2">) </span><span class="s4">and</span>
          <span class="s1">all</span><span class="s2">(</span><span class="s1">issparse</span><span class="s2">(</span><span class="s1">b</span><span class="s2">) </span><span class="s4">and </span><span class="s1">b</span><span class="s2">.</span><span class="s1">format </span><span class="s2">== </span><span class="s3">'csc' </span><span class="s4">for </span><span class="s1">b </span><span class="s4">in </span><span class="s1">blocks</span><span class="s2">.</span><span class="s1">flat</span><span class="s2">)</span>
    <span class="s2">):</span>
        <span class="s4">if </span><span class="s1">M </span><span class="s2">&gt; </span><span class="s5">1</span><span class="s2">:</span>
            <span class="s6"># stack along rows (axis 0): must have shape (1, N)</span>
            <span class="s1">blocks </span><span class="s2">= [[</span><span class="s1">_stack_along_minor_axis</span><span class="s2">(</span><span class="s1">blocks</span><span class="s2">[:, </span><span class="s1">b</span><span class="s2">], </span><span class="s5">0</span><span class="s2">) </span><span class="s4">for </span><span class="s1">b </span><span class="s4">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">N</span><span class="s2">)]]</span>
            <span class="s1">blocks </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">blocks</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s3">'object'</span><span class="s2">)</span>

        <span class="s6"># stack along columns (axis 1):</span>
        <span class="s1">A </span><span class="s2">= </span><span class="s1">_compressed_sparse_stack</span><span class="s2">(</span><span class="s1">blocks</span><span class="s2">[</span><span class="s5">0</span><span class="s2">, :], </span><span class="s5">1</span><span class="s2">, </span><span class="s1">return_spmatrix</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">dtype </span><span class="s4">is not None</span><span class="s2">:</span>
            <span class="s1">A </span><span class="s2">= </span><span class="s1">A</span><span class="s2">.</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s4">return </span><span class="s1">A</span>

    <span class="s1">block_mask </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">(</span><span class="s1">blocks</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">bool</span><span class="s2">)</span>
    <span class="s1">brow_lengths </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">(</span><span class="s1">M</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">int64</span><span class="s2">)</span>
    <span class="s1">bcol_lengths </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">(</span><span class="s1">N</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">int64</span><span class="s2">)</span>

    <span class="s6"># convert everything to COO format</span>
    <span class="s4">for </span><span class="s1">i </span><span class="s4">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">M</span><span class="s2">):</span>
        <span class="s4">for </span><span class="s1">j </span><span class="s4">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">N</span><span class="s2">):</span>
            <span class="s4">if </span><span class="s1">blocks</span><span class="s2">[</span><span class="s1">i</span><span class="s2">,</span><span class="s1">j</span><span class="s2">] </span><span class="s4">is not None</span><span class="s2">:</span>
                <span class="s1">A </span><span class="s2">= </span><span class="s1">coo_array</span><span class="s2">(</span><span class="s1">blocks</span><span class="s2">[</span><span class="s1">i</span><span class="s2">,</span><span class="s1">j</span><span class="s2">])</span>
                <span class="s1">blocks</span><span class="s2">[</span><span class="s1">i</span><span class="s2">,</span><span class="s1">j</span><span class="s2">] = </span><span class="s1">A</span>
                <span class="s1">block_mask</span><span class="s2">[</span><span class="s1">i</span><span class="s2">,</span><span class="s1">j</span><span class="s2">] = </span><span class="s4">True</span>

                <span class="s4">if </span><span class="s1">brow_lengths</span><span class="s2">[</span><span class="s1">i</span><span class="s2">] == </span><span class="s5">0</span><span class="s2">:</span>
                    <span class="s1">brow_lengths</span><span class="s2">[</span><span class="s1">i</span><span class="s2">] = </span><span class="s1">A</span><span class="s2">.</span><span class="s1">_shape_as_2d</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]</span>
                <span class="s4">elif </span><span class="s1">brow_lengths</span><span class="s2">[</span><span class="s1">i</span><span class="s2">] != </span><span class="s1">A</span><span class="s2">.</span><span class="s1">_shape_as_2d</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]:</span>
                    <span class="s1">msg </span><span class="s2">= (</span><span class="s3">f'blocks[</span><span class="s4">{</span><span class="s1">i</span><span class="s4">}</span><span class="s3">,:] has incompatible row dimensions. '</span>
                           <span class="s3">f'Got blocks[</span><span class="s4">{</span><span class="s1">i</span><span class="s4">}</span><span class="s3">,</span><span class="s4">{</span><span class="s1">j</span><span class="s4">}</span><span class="s3">].shape[0] == </span><span class="s4">{</span><span class="s1">A</span><span class="s2">.</span><span class="s1">_shape_as_2d</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]</span><span class="s4">}</span><span class="s3">, '</span>
                           <span class="s3">f'expected </span><span class="s4">{</span><span class="s1">brow_lengths</span><span class="s2">[</span><span class="s1">i</span><span class="s2">]</span><span class="s4">}</span><span class="s3">.'</span><span class="s2">)</span>
                    <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">)</span>

                <span class="s4">if </span><span class="s1">bcol_lengths</span><span class="s2">[</span><span class="s1">j</span><span class="s2">] == </span><span class="s5">0</span><span class="s2">:</span>
                    <span class="s1">bcol_lengths</span><span class="s2">[</span><span class="s1">j</span><span class="s2">] = </span><span class="s1">A</span><span class="s2">.</span><span class="s1">_shape_as_2d</span><span class="s2">[</span><span class="s5">1</span><span class="s2">]</span>
                <span class="s4">elif </span><span class="s1">bcol_lengths</span><span class="s2">[</span><span class="s1">j</span><span class="s2">] != </span><span class="s1">A</span><span class="s2">.</span><span class="s1">_shape_as_2d</span><span class="s2">[</span><span class="s5">1</span><span class="s2">]:</span>
                    <span class="s1">msg </span><span class="s2">= (</span><span class="s3">f'blocks[:,</span><span class="s4">{</span><span class="s1">j</span><span class="s4">}</span><span class="s3">] has incompatible column '</span>
                           <span class="s3">f'dimensions. '</span>
                           <span class="s3">f'Got blocks[</span><span class="s4">{</span><span class="s1">i</span><span class="s4">}</span><span class="s3">,</span><span class="s4">{</span><span class="s1">j</span><span class="s4">}</span><span class="s3">].shape[1] == </span><span class="s4">{</span><span class="s1">A</span><span class="s2">.</span><span class="s1">_shape_as_2d</span><span class="s2">[</span><span class="s5">1</span><span class="s2">]</span><span class="s4">}</span><span class="s3">, '</span>
                           <span class="s3">f'expected </span><span class="s4">{</span><span class="s1">bcol_lengths</span><span class="s2">[</span><span class="s1">j</span><span class="s2">]</span><span class="s4">}</span><span class="s3">.'</span><span class="s2">)</span>
                    <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">)</span>

    <span class="s1">nnz </span><span class="s2">= </span><span class="s1">sum</span><span class="s2">(</span><span class="s1">block</span><span class="s2">.</span><span class="s1">nnz </span><span class="s4">for </span><span class="s1">block </span><span class="s4">in </span><span class="s1">blocks</span><span class="s2">[</span><span class="s1">block_mask</span><span class="s2">])</span>
    <span class="s4">if </span><span class="s1">dtype </span><span class="s4">is None</span><span class="s2">:</span>
        <span class="s1">all_dtypes </span><span class="s2">= [</span><span class="s1">blk</span><span class="s2">.</span><span class="s1">dtype </span><span class="s4">for </span><span class="s1">blk </span><span class="s4">in </span><span class="s1">blocks</span><span class="s2">[</span><span class="s1">block_mask</span><span class="s2">]]</span>
        <span class="s1">dtype </span><span class="s2">= </span><span class="s1">upcast</span><span class="s2">(*</span><span class="s1">all_dtypes</span><span class="s2">) </span><span class="s4">if </span><span class="s1">all_dtypes </span><span class="s4">else None</span>

    <span class="s1">row_offsets </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">cumsum</span><span class="s2">(</span><span class="s1">brow_lengths</span><span class="s2">))</span>
    <span class="s1">col_offsets </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">cumsum</span><span class="s2">(</span><span class="s1">bcol_lengths</span><span class="s2">))</span>

    <span class="s1">shape </span><span class="s2">= (</span><span class="s1">row_offsets</span><span class="s2">[-</span><span class="s5">1</span><span class="s2">], </span><span class="s1">col_offsets</span><span class="s2">[-</span><span class="s5">1</span><span class="s2">])</span>

    <span class="s1">data </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">(</span><span class="s1">nnz</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">)</span>
    <span class="s1">idx_dtype </span><span class="s2">= </span><span class="s1">get_index_dtype</span><span class="s2">(</span><span class="s1">maxval</span><span class="s2">=</span><span class="s1">max</span><span class="s2">(</span><span class="s1">shape</span><span class="s2">))</span>
    <span class="s1">row </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">(</span><span class="s1">nnz</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">idx_dtype</span><span class="s2">)</span>
    <span class="s1">col </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">(</span><span class="s1">nnz</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">idx_dtype</span><span class="s2">)</span>

    <span class="s1">nnz </span><span class="s2">= </span><span class="s5">0</span>
    <span class="s1">ii</span><span class="s2">, </span><span class="s1">jj </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">nonzero</span><span class="s2">(</span><span class="s1">block_mask</span><span class="s2">)</span>
    <span class="s4">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">j </span><span class="s4">in </span><span class="s1">zip</span><span class="s2">(</span><span class="s1">ii</span><span class="s2">, </span><span class="s1">jj</span><span class="s2">):</span>
        <span class="s1">B </span><span class="s2">= </span><span class="s1">blocks</span><span class="s2">[</span><span class="s1">i</span><span class="s2">, </span><span class="s1">j</span><span class="s2">]</span>
        <span class="s1">idx </span><span class="s2">= </span><span class="s1">slice</span><span class="s2">(</span><span class="s1">nnz</span><span class="s2">, </span><span class="s1">nnz </span><span class="s2">+ </span><span class="s1">B</span><span class="s2">.</span><span class="s1">nnz</span><span class="s2">)</span>
        <span class="s1">data</span><span class="s2">[</span><span class="s1">idx</span><span class="s2">] = </span><span class="s1">B</span><span class="s2">.</span><span class="s1">data</span>
        <span class="s1">np</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">B</span><span class="s2">.</span><span class="s1">row</span><span class="s2">, </span><span class="s1">row_offsets</span><span class="s2">[</span><span class="s1">i</span><span class="s2">], </span><span class="s1">out</span><span class="s2">=</span><span class="s1">row</span><span class="s2">[</span><span class="s1">idx</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">idx_dtype</span><span class="s2">)</span>
        <span class="s1">np</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">B</span><span class="s2">.</span><span class="s1">col</span><span class="s2">, </span><span class="s1">col_offsets</span><span class="s2">[</span><span class="s1">j</span><span class="s2">], </span><span class="s1">out</span><span class="s2">=</span><span class="s1">col</span><span class="s2">[</span><span class="s1">idx</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">idx_dtype</span><span class="s2">)</span>
        <span class="s1">nnz </span><span class="s2">+= </span><span class="s1">B</span><span class="s2">.</span><span class="s1">nnz</span>

    <span class="s4">if </span><span class="s1">return_spmatrix</span><span class="s2">:</span>
        <span class="s4">return </span><span class="s1">coo_matrix</span><span class="s2">((</span><span class="s1">data</span><span class="s2">, (</span><span class="s1">row</span><span class="s2">, </span><span class="s1">col</span><span class="s2">)), </span><span class="s1">shape</span><span class="s2">=</span><span class="s1">shape</span><span class="s2">).</span><span class="s1">asformat</span><span class="s2">(</span><span class="s1">format</span><span class="s2">)</span>
    <span class="s4">return </span><span class="s1">coo_array</span><span class="s2">((</span><span class="s1">data</span><span class="s2">, (</span><span class="s1">row</span><span class="s2">, </span><span class="s1">col</span><span class="s2">)), </span><span class="s1">shape</span><span class="s2">=</span><span class="s1">shape</span><span class="s2">).</span><span class="s1">asformat</span><span class="s2">(</span><span class="s1">format</span><span class="s2">)</span>


<span class="s4">def </span><span class="s1">block_diag</span><span class="s2">(</span><span class="s1">mats</span><span class="s2">, </span><span class="s1">format</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s4">None</span><span class="s2">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Build a block diagonal sparse matrix or array from provided matrices. 
 
    Parameters 
    ---------- 
    mats : sequence of matrices or arrays 
        Input matrices or arrays. 
    format : str, optional 
        The sparse format of the result (e.g., &quot;csr&quot;). If not given, the result 
        is returned in &quot;coo&quot; format. 
    dtype : dtype specifier, optional 
        The data-type of the output. If not given, the dtype is 
        determined from that of `blocks`. 
 
    Returns 
    ------- 
    res : sparse matrix or array 
        If at least one input is a sparse array, the output is a sparse array. 
        Otherwise the output is a sparse matrix. 
 
    Notes 
    ----- 
 
    .. versionadded:: 0.11.0 
 
    See Also 
    -------- 
    block_array 
    diags_array 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.sparse import coo_array, block_diag 
    &gt;&gt;&gt; A = coo_array([[1, 2], [3, 4]]) 
    &gt;&gt;&gt; B = coo_array([[5], [6]]) 
    &gt;&gt;&gt; C = coo_array([[7]]) 
    &gt;&gt;&gt; block_diag((A, B, C)).toarray() 
    array([[1, 2, 0, 0], 
           [3, 4, 0, 0], 
           [0, 0, 5, 0], 
           [0, 0, 6, 0], 
           [0, 0, 0, 7]]) 
 
    &quot;&quot;&quot;</span>
    <span class="s4">if </span><span class="s1">any</span><span class="s2">(</span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">sparray</span><span class="s2">) </span><span class="s4">for </span><span class="s1">a </span><span class="s4">in </span><span class="s1">mats</span><span class="s2">):</span>
        <span class="s1">container </span><span class="s2">= </span><span class="s1">coo_array</span>
    <span class="s4">else</span><span class="s2">:</span>
        <span class="s1">container </span><span class="s2">= </span><span class="s1">coo_matrix</span>

    <span class="s1">row </span><span class="s2">= []</span>
    <span class="s1">col </span><span class="s2">= []</span>
    <span class="s1">data </span><span class="s2">= []</span>
    <span class="s1">r_idx </span><span class="s2">= </span><span class="s5">0</span>
    <span class="s1">c_idx </span><span class="s2">= </span><span class="s5">0</span>
    <span class="s4">for </span><span class="s1">a </span><span class="s4">in </span><span class="s1">mats</span><span class="s2">:</span>
        <span class="s4">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, (</span><span class="s1">list</span><span class="s2">, </span><span class="s1">numbers</span><span class="s2">.</span><span class="s1">Number</span><span class="s2">)):</span>
            <span class="s1">a </span><span class="s2">= </span><span class="s1">coo_array</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">atleast_2d</span><span class="s2">(</span><span class="s1">a</span><span class="s2">))</span>
        <span class="s4">if </span><span class="s1">issparse</span><span class="s2">(</span><span class="s1">a</span><span class="s2">):</span>
            <span class="s1">a </span><span class="s2">= </span><span class="s1">a</span><span class="s2">.</span><span class="s1">tocoo</span><span class="s2">()</span>
            <span class="s1">nrows</span><span class="s2">, </span><span class="s1">ncols </span><span class="s2">= </span><span class="s1">a</span><span class="s2">.</span><span class="s1">_shape_as_2d</span>
            <span class="s1">row</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">a</span><span class="s2">.</span><span class="s1">row </span><span class="s2">+ </span><span class="s1">r_idx</span><span class="s2">)</span>
            <span class="s1">col</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">a</span><span class="s2">.</span><span class="s1">col </span><span class="s2">+ </span><span class="s1">c_idx</span><span class="s2">)</span>
            <span class="s1">data</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">a</span><span class="s2">.</span><span class="s1">data</span><span class="s2">)</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">nrows</span><span class="s2">, </span><span class="s1">ncols </span><span class="s2">= </span><span class="s1">a</span><span class="s2">.</span><span class="s1">shape</span>
            <span class="s1">a_row</span><span class="s2">, </span><span class="s1">a_col </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">divmod</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(</span><span class="s1">nrows</span><span class="s2">*</span><span class="s1">ncols</span><span class="s2">), </span><span class="s1">ncols</span><span class="s2">)</span>
            <span class="s1">row</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">a_row </span><span class="s2">+ </span><span class="s1">r_idx</span><span class="s2">)</span>
            <span class="s1">col</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">a_col </span><span class="s2">+ </span><span class="s1">c_idx</span><span class="s2">)</span>
            <span class="s1">data</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">a</span><span class="s2">.</span><span class="s1">ravel</span><span class="s2">())</span>
        <span class="s1">r_idx </span><span class="s2">+= </span><span class="s1">nrows</span>
        <span class="s1">c_idx </span><span class="s2">+= </span><span class="s1">ncols</span>
    <span class="s1">row </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">concatenate</span><span class="s2">(</span><span class="s1">row</span><span class="s2">)</span>
    <span class="s1">col </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">concatenate</span><span class="s2">(</span><span class="s1">col</span><span class="s2">)</span>
    <span class="s1">data </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">concatenate</span><span class="s2">(</span><span class="s1">data</span><span class="s2">)</span>
    <span class="s4">return </span><span class="s1">container</span><span class="s2">((</span><span class="s1">data</span><span class="s2">, (</span><span class="s1">row</span><span class="s2">, </span><span class="s1">col</span><span class="s2">)),</span>
                      <span class="s1">shape</span><span class="s2">=(</span><span class="s1">r_idx</span><span class="s2">, </span><span class="s1">c_idx</span><span class="s2">),</span>
                      <span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">).</span><span class="s1">asformat</span><span class="s2">(</span><span class="s1">format</span><span class="s2">)</span>


<span class="s4">def </span><span class="s1">random_array</span><span class="s2">(</span><span class="s1">shape</span><span class="s2">, *, </span><span class="s1">density</span><span class="s2">=</span><span class="s5">0.01</span><span class="s2">, </span><span class="s1">format</span><span class="s2">=</span><span class="s3">'coo'</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s4">None</span><span class="s2">,</span>
                 <span class="s1">random_state</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">data_sampler</span><span class="s2">=</span><span class="s4">None</span><span class="s2">):</span>
    <span class="s0">&quot;&quot;&quot;Return a sparse array of uniformly random numbers in [0, 1) 
 
    Returns a sparse array with the given shape and density 
    where values are generated uniformly randomly in the range [0, 1). 
 
    .. warning:: 
 
        Since numpy 1.17, passing a ``np.random.Generator`` (e.g. 
        ``np.random.default_rng``) for ``random_state`` will lead to much 
        faster execution times. 
 
        A much slower implementation is used by default for backwards 
        compatibility. 
 
    Parameters 
    ---------- 
    shape : int or tuple of ints 
        shape of the array 
    density : real, optional (default: 0.01) 
        density of the generated matrix: density equal to one means a full 
        matrix, density of 0 means a matrix with no non-zero items. 
    format : str, optional (default: 'coo') 
        sparse matrix format. 
    dtype : dtype, optional (default: np.float64) 
        type of the returned matrix values. 
    random_state : {None, int, `Generator`, `RandomState`}, optional 
        A random number generator to determine nonzero structure. We recommend using 
        a `numpy.random.Generator` manually provided for every call as it is much 
        faster than RandomState. 
 
        - If `None` (or `np.random`), the `numpy.random.RandomState` 
          singleton is used. 
        - If an int, a new ``Generator`` instance is used, 
          seeded with the int. 
        - If a ``Generator`` or ``RandomState`` instance then 
          that instance is used. 
 
        This random state will be used for sampling `indices` (the sparsity 
        structure), and by default for the data values too (see `data_sampler`). 
 
    data_sampler : callable, optional (default depends on dtype) 
        Sampler of random data values with keyword arg `size`. 
        This function should take a single keyword argument `size` specifying 
        the length of its returned ndarray. It is used to generate the nonzero 
        values in the matrix after the locations of those values are chosen. 
        By default, uniform [0, 1) random values are used unless `dtype` is 
        an integer (default uniform integers from that dtype) or 
        complex (default uniform over the unit square in the complex plane). 
        For these, the `random_state` rng is used e.g. `rng.uniform(size=size)`. 
 
    Returns 
    ------- 
    res : sparse array 
 
    Examples 
    -------- 
 
    Passing a ``np.random.Generator`` instance for better performance: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; import scipy as sp 
    &gt;&gt;&gt; rng = np.random.default_rng() 
 
    Default sampling uniformly from [0, 1): 
 
    &gt;&gt;&gt; S = sp.sparse.random_array((3, 4), density=0.25, random_state=rng) 
 
    Providing a sampler for the values: 
 
    &gt;&gt;&gt; rvs = sp.stats.poisson(25, loc=10).rvs 
    &gt;&gt;&gt; S = sp.sparse.random_array((3, 4), density=0.25, 
    ...                            random_state=rng, data_sampler=rvs) 
    &gt;&gt;&gt; S.toarray() 
    array([[ 36.,   0.,  33.,   0.],   # random 
           [  0.,   0.,   0.,   0.], 
           [  0.,   0.,  36.,   0.]]) 
 
    Building a custom distribution. 
    This example builds a squared normal from np.random: 
 
    &gt;&gt;&gt; def np_normal_squared(size=None, random_state=rng): 
    ...     return random_state.standard_normal(size) ** 2 
    &gt;&gt;&gt; S = sp.sparse.random_array((3, 4), density=0.25, random_state=rng, 
    ...                      data_sampler=np_normal_squared) 
 
    Or we can build it from sp.stats style rvs functions: 
 
    &gt;&gt;&gt; def sp_stats_normal_squared(size=None, random_state=rng): 
    ...     std_normal = sp.stats.distributions.norm_gen().rvs 
    ...     return std_normal(size=size, random_state=random_state) ** 2 
    &gt;&gt;&gt; S = sp.sparse.random_array((3, 4), density=0.25, random_state=rng, 
    ...                      data_sampler=sp_stats_normal_squared) 
 
    Or we can subclass sp.stats rv_continous or rv_discrete: 
 
    &gt;&gt;&gt; class NormalSquared(sp.stats.rv_continuous): 
    ...     def _rvs(self,  size=None, random_state=rng): 
    ...         return random_state.standard_normal(size) ** 2 
    &gt;&gt;&gt; X = NormalSquared() 
    &gt;&gt;&gt; Y = X().rvs 
    &gt;&gt;&gt; S = sp.sparse.random_array((3, 4), density=0.25, 
    ...                            random_state=rng, data_sampler=Y) 
    &quot;&quot;&quot;</span>
    <span class="s6"># Use the more efficient RNG by default.</span>
    <span class="s4">if </span><span class="s1">random_state </span><span class="s4">is None</span><span class="s2">:</span>
        <span class="s1">random_state </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">random</span><span class="s2">.</span><span class="s1">default_rng</span><span class="s2">()</span>
    <span class="s1">data</span><span class="s2">, </span><span class="s1">ind </span><span class="s2">= </span><span class="s1">_random</span><span class="s2">(</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">density</span><span class="s2">, </span><span class="s1">format</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">random_state</span><span class="s2">, </span><span class="s1">data_sampler</span><span class="s2">)</span>
    <span class="s4">return </span><span class="s1">coo_array</span><span class="s2">((</span><span class="s1">data</span><span class="s2">, </span><span class="s1">ind</span><span class="s2">), </span><span class="s1">shape</span><span class="s2">=</span><span class="s1">shape</span><span class="s2">).</span><span class="s1">asformat</span><span class="s2">(</span><span class="s1">format</span><span class="s2">)</span>


<span class="s4">def </span><span class="s1">_random</span><span class="s2">(</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">density</span><span class="s2">=</span><span class="s5">0.01</span><span class="s2">, </span><span class="s1">format</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s4">None</span><span class="s2">,</span>
            <span class="s1">random_state</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">data_sampler</span><span class="s2">=</span><span class="s4">None</span><span class="s2">):</span>
    <span class="s4">if </span><span class="s1">density </span><span class="s2">&lt; </span><span class="s5">0 </span><span class="s4">or </span><span class="s1">density </span><span class="s2">&gt; </span><span class="s5">1</span><span class="s2">:</span>
        <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;density expected to be 0 &lt;= density &lt;= 1&quot;</span><span class="s2">)</span>

    <span class="s1">tot_prod </span><span class="s2">= </span><span class="s1">math</span><span class="s2">.</span><span class="s1">prod</span><span class="s2">(</span><span class="s1">shape</span><span class="s2">)  </span><span class="s6"># use `math` for when prod is &gt;= 2**64</span>

    <span class="s6"># Number of non zero values</span>
    <span class="s1">size </span><span class="s2">= </span><span class="s1">int</span><span class="s2">(</span><span class="s1">round</span><span class="s2">(</span><span class="s1">density </span><span class="s2">* </span><span class="s1">tot_prod</span><span class="s2">))</span>

    <span class="s1">rng </span><span class="s2">= </span><span class="s1">check_random_state</span><span class="s2">(</span><span class="s1">random_state</span><span class="s2">)</span>

    <span class="s4">if </span><span class="s1">data_sampler </span><span class="s4">is None</span><span class="s2">:</span>
        <span class="s4">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">issubdtype</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">integer</span><span class="s2">):</span>
            <span class="s4">def </span><span class="s1">data_sampler</span><span class="s2">(</span><span class="s1">size</span><span class="s2">):</span>
                <span class="s4">return </span><span class="s1">rng_integers</span><span class="s2">(</span><span class="s1">rng</span><span class="s2">,</span>
                                    <span class="s1">np</span><span class="s2">.</span><span class="s1">iinfo</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">).</span><span class="s1">min</span><span class="s2">,</span>
                                    <span class="s1">np</span><span class="s2">.</span><span class="s1">iinfo</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">).</span><span class="s1">max</span><span class="s2">,</span>
                                    <span class="s1">size</span><span class="s2">,</span>
                                    <span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s4">elif </span><span class="s1">np</span><span class="s2">.</span><span class="s1">issubdtype</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">complexfloating</span><span class="s2">):</span>
            <span class="s4">def </span><span class="s1">data_sampler</span><span class="s2">(</span><span class="s1">size</span><span class="s2">):</span>
                <span class="s4">return </span><span class="s2">(</span><span class="s1">rng</span><span class="s2">.</span><span class="s1">uniform</span><span class="s2">(</span><span class="s1">size</span><span class="s2">=</span><span class="s1">size</span><span class="s2">) +</span>
                        <span class="s1">rng</span><span class="s2">.</span><span class="s1">uniform</span><span class="s2">(</span><span class="s1">size</span><span class="s2">=</span><span class="s1">size</span><span class="s2">) * </span><span class="s5">1j</span><span class="s2">)</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">data_sampler </span><span class="s2">= </span><span class="s1">rng</span><span class="s2">.</span><span class="s1">uniform</span>

    <span class="s6"># rng.choice uses int64 if first arg is an int</span>
    <span class="s4">if </span><span class="s1">tot_prod </span><span class="s2">&lt; </span><span class="s1">np</span><span class="s2">.</span><span class="s1">iinfo</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">int64</span><span class="s2">).</span><span class="s1">max</span><span class="s2">:</span>
        <span class="s1">raveled_ind </span><span class="s2">= </span><span class="s1">rng</span><span class="s2">.</span><span class="s1">choice</span><span class="s2">(</span><span class="s1">tot_prod</span><span class="s2">, </span><span class="s1">size</span><span class="s2">=</span><span class="s1">size</span><span class="s2">, </span><span class="s1">replace</span><span class="s2">=</span><span class="s4">False</span><span class="s2">)</span>
        <span class="s1">ind </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">unravel_index</span><span class="s2">(</span><span class="s1">raveled_ind</span><span class="s2">, </span><span class="s1">shape</span><span class="s2">=</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">order</span><span class="s2">=</span><span class="s3">'F'</span><span class="s2">)</span>
    <span class="s4">else</span><span class="s2">:</span>
        <span class="s6"># for ravel indices bigger than dtype max, use sets to remove duplicates</span>
        <span class="s1">ndim </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">shape</span><span class="s2">)</span>
        <span class="s1">seen </span><span class="s2">= </span><span class="s1">set</span><span class="s2">()</span>
        <span class="s4">while </span><span class="s1">len</span><span class="s2">(</span><span class="s1">seen</span><span class="s2">) &lt; </span><span class="s1">size</span><span class="s2">:</span>
            <span class="s1">dsize </span><span class="s2">= </span><span class="s1">size </span><span class="s2">- </span><span class="s1">len</span><span class="s2">(</span><span class="s1">seen</span><span class="s2">)</span>
            <span class="s1">seen</span><span class="s2">.</span><span class="s1">update</span><span class="s2">(</span><span class="s1">map</span><span class="s2">(</span><span class="s1">tuple</span><span class="s2">, </span><span class="s1">rng_integers</span><span class="s2">(</span><span class="s1">rng</span><span class="s2">, </span><span class="s1">shape</span><span class="s2">, </span><span class="s1">size</span><span class="s2">=(</span><span class="s1">dsize</span><span class="s2">, </span><span class="s1">ndim</span><span class="s2">))))</span>
        <span class="s1">ind </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">(</span><span class="s1">list</span><span class="s2">(</span><span class="s1">seen</span><span class="s2">)).</span><span class="s1">T</span><span class="s2">)</span>

    <span class="s6"># size kwarg allows eg data_sampler=partial(np.random.poisson, lam=5)</span>
    <span class="s1">vals </span><span class="s2">= </span><span class="s1">data_sampler</span><span class="s2">(</span><span class="s1">size</span><span class="s2">=</span><span class="s1">size</span><span class="s2">).</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s4">False</span><span class="s2">)</span>
    <span class="s4">return </span><span class="s1">vals</span><span class="s2">, </span><span class="s1">ind</span>


<span class="s4">def </span><span class="s1">random</span><span class="s2">(</span><span class="s1">m</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">density</span><span class="s2">=</span><span class="s5">0.01</span><span class="s2">, </span><span class="s1">format</span><span class="s2">=</span><span class="s3">'coo'</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s4">None</span><span class="s2">,</span>
           <span class="s1">random_state</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">data_rvs</span><span class="s2">=</span><span class="s4">None</span><span class="s2">):</span>
    <span class="s0">&quot;&quot;&quot;Generate a sparse matrix of the given shape and density with randomly 
    distributed values. 
 
    .. warning:: 
 
        Since numpy 1.17, passing a ``np.random.Generator`` (e.g. 
        ``np.random.default_rng``) for ``random_state`` will lead to much 
        faster execution times. 
 
        A much slower implementation is used by default for backwards 
        compatibility. 
 
    .. warning:: 
 
        This function returns a sparse matrix -- not a sparse array. 
        You are encouraged to use ``random_array`` to take advantage of the 
        sparse array functionality. 
 
    Parameters 
    ---------- 
    m, n : int 
        shape of the matrix 
    density : real, optional 
        density of the generated matrix: density equal to one means a full 
        matrix, density of 0 means a matrix with no non-zero items. 
    format : str, optional 
        sparse matrix format. 
    dtype : dtype, optional 
        type of the returned matrix values. 
    random_state : {None, int, `numpy.random.Generator`, 
                    `numpy.random.RandomState`}, optional 
 
        - If `seed` is None (or `np.random`), the `numpy.random.RandomState` 
          singleton is used. 
        - If `seed` is an int, a new ``RandomState`` instance is used, 
          seeded with `seed`. 
        - If `seed` is already a ``Generator`` or ``RandomState`` instance then 
          that instance is used. 
 
        This random state will be used for sampling the sparsity structure, but 
        not necessarily for sampling the values of the structurally nonzero 
        entries of the matrix. 
    data_rvs : callable, optional 
        Samples a requested number of random values. 
        This function should take a single argument specifying the length 
        of the ndarray that it will return. The structurally nonzero entries 
        of the sparse random matrix will be taken from the array sampled 
        by this function. By default, uniform [0, 1) random values will be 
        sampled using the same random state as is used for sampling 
        the sparsity structure. 
 
    Returns 
    ------- 
    res : sparse matrix 
 
    See Also 
    -------- 
    random_array : constructs sparse arrays instead of sparse matrices 
 
    Examples 
    -------- 
 
    Passing a ``np.random.Generator`` instance for better performance: 
 
    &gt;&gt;&gt; import scipy as sp 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; rng = np.random.default_rng() 
    &gt;&gt;&gt; S = sp.sparse.random(3, 4, density=0.25, random_state=rng) 
 
    Providing a sampler for the values: 
 
    &gt;&gt;&gt; rvs = sp.stats.poisson(25, loc=10).rvs 
    &gt;&gt;&gt; S = sp.sparse.random(3, 4, density=0.25, random_state=rng, data_rvs=rvs) 
    &gt;&gt;&gt; S.toarray() 
    array([[ 36.,   0.,  33.,   0.],   # random 
           [  0.,   0.,   0.,   0.], 
           [  0.,   0.,  36.,   0.]]) 
 
    Building a custom distribution. 
    This example builds a squared normal from np.random: 
 
    &gt;&gt;&gt; def np_normal_squared(size=None, random_state=rng): 
    ...     return random_state.standard_normal(size) ** 2 
    &gt;&gt;&gt; S = sp.sparse.random(3, 4, density=0.25, random_state=rng, 
    ...                      data_rvs=np_normal_squared) 
 
    Or we can build it from sp.stats style rvs functions: 
 
    &gt;&gt;&gt; def sp_stats_normal_squared(size=None, random_state=rng): 
    ...     std_normal = sp.stats.distributions.norm_gen().rvs 
    ...     return std_normal(size=size, random_state=random_state) ** 2 
    &gt;&gt;&gt; S = sp.sparse.random(3, 4, density=0.25, random_state=rng, 
    ...                      data_rvs=sp_stats_normal_squared) 
 
    Or we can subclass sp.stats rv_continous or rv_discrete: 
 
    &gt;&gt;&gt; class NormalSquared(sp.stats.rv_continuous): 
    ...     def _rvs(self,  size=None, random_state=rng): 
    ...         return random_state.standard_normal(size) ** 2 
    &gt;&gt;&gt; X = NormalSquared() 
    &gt;&gt;&gt; Y = X()  # get a frozen version of the distribution 
    &gt;&gt;&gt; S = sp.sparse.random(3, 4, density=0.25, random_state=rng, data_rvs=Y.rvs) 
    &quot;&quot;&quot;</span>
    <span class="s4">if </span><span class="s1">n </span><span class="s4">is None</span><span class="s2">:</span>
        <span class="s1">n </span><span class="s2">= </span><span class="s1">m</span>
    <span class="s1">m</span><span class="s2">, </span><span class="s1">n </span><span class="s2">= </span><span class="s1">int</span><span class="s2">(</span><span class="s1">m</span><span class="s2">), </span><span class="s1">int</span><span class="s2">(</span><span class="s1">n</span><span class="s2">)</span>
    <span class="s6"># make keyword syntax work for data_rvs e.g. data_rvs(size=7)</span>
    <span class="s4">if </span><span class="s1">data_rvs </span><span class="s4">is not None</span><span class="s2">:</span>
        <span class="s4">def </span><span class="s1">data_rvs_kw</span><span class="s2">(</span><span class="s1">size</span><span class="s2">):</span>
            <span class="s4">return </span><span class="s1">data_rvs</span><span class="s2">(</span><span class="s1">size</span><span class="s2">)</span>
    <span class="s4">else</span><span class="s2">:</span>
        <span class="s1">data_rvs_kw </span><span class="s2">= </span><span class="s4">None</span>
    <span class="s1">vals</span><span class="s2">, </span><span class="s1">ind </span><span class="s2">= </span><span class="s1">_random</span><span class="s2">((</span><span class="s1">m</span><span class="s2">, </span><span class="s1">n</span><span class="s2">), </span><span class="s1">density</span><span class="s2">, </span><span class="s1">format</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">random_state</span><span class="s2">, </span><span class="s1">data_rvs_kw</span><span class="s2">)</span>
    <span class="s4">return </span><span class="s1">coo_matrix</span><span class="s2">((</span><span class="s1">vals</span><span class="s2">, </span><span class="s1">ind</span><span class="s2">), </span><span class="s1">shape</span><span class="s2">=(</span><span class="s1">m</span><span class="s2">, </span><span class="s1">n</span><span class="s2">)).</span><span class="s1">asformat</span><span class="s2">(</span><span class="s1">format</span><span class="s2">)</span>


<span class="s4">def </span><span class="s1">rand</span><span class="s2">(</span><span class="s1">m</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">density</span><span class="s2">=</span><span class="s5">0.01</span><span class="s2">, </span><span class="s1">format</span><span class="s2">=</span><span class="s3">&quot;coo&quot;</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">random_state</span><span class="s2">=</span><span class="s4">None</span><span class="s2">):</span>
    <span class="s0">&quot;&quot;&quot;Generate a sparse matrix of the given shape and density with uniformly 
    distributed values. 
 
    .. warning:: 
 
        This function returns a sparse matrix -- not a sparse array. 
        You are encouraged to use ``random_array`` to take advantage 
        of the sparse array functionality. 
 
    Parameters 
    ---------- 
    m, n : int 
        shape of the matrix 
    density : real, optional 
        density of the generated matrix: density equal to one means a full 
        matrix, density of 0 means a matrix with no non-zero items. 
    format : str, optional 
        sparse matrix format. 
    dtype : dtype, optional 
        type of the returned matrix values. 
    random_state : {None, int, `numpy.random.Generator`, 
                    `numpy.random.RandomState`}, optional 
 
        If `seed` is None (or `np.random`), the `numpy.random.RandomState` 
        singleton is used. 
        If `seed` is an int, a new ``RandomState`` instance is used, 
        seeded with `seed`. 
        If `seed` is already a ``Generator`` or ``RandomState`` instance then 
        that instance is used. 
 
    Returns 
    ------- 
    res : sparse matrix 
 
    Notes 
    ----- 
    Only float types are supported for now. 
 
    See Also 
    -------- 
    random : Similar function allowing a custom random data sampler 
    random_array : Similar to random() but returns a sparse array 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.sparse import rand 
    &gt;&gt;&gt; matrix = rand(3, 4, density=0.25, format=&quot;csr&quot;, random_state=42) 
    &gt;&gt;&gt; matrix 
    &lt;Compressed Sparse Row sparse matrix of dtype 'float64' 
        with 3 stored elements and shape (3, 4)&gt; 
    &gt;&gt;&gt; matrix.toarray() 
    array([[0.05641158, 0.        , 0.        , 0.65088847],  # random 
           [0.        , 0.        , 0.        , 0.14286682], 
           [0.        , 0.        , 0.        , 0.        ]]) 
 
    &quot;&quot;&quot;</span>
    <span class="s4">return </span><span class="s1">random</span><span class="s2">(</span><span class="s1">m</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">density</span><span class="s2">, </span><span class="s1">format</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">random_state</span><span class="s2">)</span>
</pre>
</body>
</html>