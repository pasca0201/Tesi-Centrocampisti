<html>
<head>
<title>_stacking.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #7a7e85;}
.s3 { color: #cf8e6d;}
.s4 { color: #bcbec4;}
.s5 { color: #6aab73;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_stacking.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Stacking classifier and regressor.&quot;&quot;&quot;</span>

<span class="s2"># Authors: Guillaume Lemaitre &lt;g.lemaitre58@gmail.com&gt;</span>
<span class="s2"># License: BSD 3 clause</span>

<span class="s3">from </span><span class="s1">abc </span><span class="s3">import </span><span class="s1">ABCMeta</span><span class="s4">, </span><span class="s1">abstractmethod</span>
<span class="s3">from </span><span class="s1">copy </span><span class="s3">import </span><span class="s1">deepcopy</span>
<span class="s3">from </span><span class="s1">numbers </span><span class="s3">import </span><span class="s1">Integral</span>

<span class="s3">import </span><span class="s1">numpy </span><span class="s3">as </span><span class="s1">np</span>
<span class="s3">import </span><span class="s1">scipy</span><span class="s4">.</span><span class="s1">sparse </span><span class="s3">as </span><span class="s1">sparse</span>

<span class="s3">from </span><span class="s4">..</span><span class="s1">base </span><span class="s3">import </span><span class="s4">(</span>
    <span class="s1">ClassifierMixin</span><span class="s4">,</span>
    <span class="s1">RegressorMixin</span><span class="s4">,</span>
    <span class="s1">TransformerMixin</span><span class="s4">,</span>
    <span class="s1">_fit_context</span><span class="s4">,</span>
    <span class="s1">clone</span><span class="s4">,</span>
    <span class="s1">is_classifier</span><span class="s4">,</span>
    <span class="s1">is_regressor</span><span class="s4">,</span>
<span class="s4">)</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">exceptions </span><span class="s3">import </span><span class="s1">NotFittedError</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">linear_model </span><span class="s3">import </span><span class="s1">LogisticRegression</span><span class="s4">, </span><span class="s1">RidgeCV</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">model_selection </span><span class="s3">import </span><span class="s1">check_cv</span><span class="s4">, </span><span class="s1">cross_val_predict</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">preprocessing </span><span class="s3">import </span><span class="s1">LabelEncoder</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">utils </span><span class="s3">import </span><span class="s1">Bunch</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">utils</span><span class="s4">.</span><span class="s1">_estimator_html_repr </span><span class="s3">import </span><span class="s1">_VisualBlock</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">utils</span><span class="s4">.</span><span class="s1">_param_validation </span><span class="s3">import </span><span class="s1">HasMethods</span><span class="s4">, </span><span class="s1">StrOptions</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">utils</span><span class="s4">.</span><span class="s1">metadata_routing </span><span class="s3">import </span><span class="s4">(</span>
    <span class="s1">_raise_for_unsupported_routing</span><span class="s4">,</span>
    <span class="s1">_RoutingNotSupportedMixin</span><span class="s4">,</span>
<span class="s4">)</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">utils</span><span class="s4">.</span><span class="s1">metaestimators </span><span class="s3">import </span><span class="s1">available_if</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">utils</span><span class="s4">.</span><span class="s1">multiclass </span><span class="s3">import </span><span class="s1">check_classification_targets</span><span class="s4">, </span><span class="s1">type_of_target</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">utils</span><span class="s4">.</span><span class="s1">parallel </span><span class="s3">import </span><span class="s1">Parallel</span><span class="s4">, </span><span class="s1">delayed</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">utils</span><span class="s4">.</span><span class="s1">validation </span><span class="s3">import </span><span class="s4">(</span>
    <span class="s1">_check_feature_names_in</span><span class="s4">,</span>
    <span class="s1">_check_response_method</span><span class="s4">,</span>
    <span class="s1">check_is_fitted</span><span class="s4">,</span>
    <span class="s1">column_or_1d</span><span class="s4">,</span>
<span class="s4">)</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">_base </span><span class="s3">import </span><span class="s1">_BaseHeterogeneousEnsemble</span><span class="s4">, </span><span class="s1">_fit_single_estimator</span>


<span class="s3">def </span><span class="s1">_estimator_has</span><span class="s4">(</span><span class="s1">attr</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Check if we can delegate a method to the underlying estimator. 
 
    First, we check the fitted `final_estimator_` if available, otherwise we check the 
    unfitted `final_estimator`. We raise the original `AttributeError` if `attr` does 
    not exist. This function is used together with `available_if`. 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">check</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s5">&quot;final_estimator_&quot;</span><span class="s4">):</span>
            <span class="s1">getattr</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">final_estimator_</span><span class="s4">, </span><span class="s1">attr</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">getattr</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">final_estimator</span><span class="s4">, </span><span class="s1">attr</span><span class="s4">)</span>

        <span class="s3">return True</span>

    <span class="s3">return </span><span class="s1">check</span>


<span class="s3">class </span><span class="s1">_BaseStacking</span><span class="s4">(</span><span class="s1">TransformerMixin</span><span class="s4">, </span><span class="s1">_BaseHeterogeneousEnsemble</span><span class="s4">, </span><span class="s1">metaclass</span><span class="s4">=</span><span class="s1">ABCMeta</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Base class for stacking method.&quot;&quot;&quot;</span>

    <span class="s1">_parameter_constraints</span><span class="s4">: </span><span class="s1">dict </span><span class="s4">= {</span>
        <span class="s5">&quot;estimators&quot;</span><span class="s4">: [</span><span class="s1">list</span><span class="s4">],</span>
        <span class="s5">&quot;final_estimator&quot;</span><span class="s4">: [</span><span class="s3">None</span><span class="s4">, </span><span class="s1">HasMethods</span><span class="s4">(</span><span class="s5">&quot;fit&quot;</span><span class="s4">)],</span>
        <span class="s5">&quot;cv&quot;</span><span class="s4">: [</span><span class="s5">&quot;cv_object&quot;</span><span class="s4">, </span><span class="s1">StrOptions</span><span class="s4">({</span><span class="s5">&quot;prefit&quot;</span><span class="s4">})],</span>
        <span class="s5">&quot;n_jobs&quot;</span><span class="s4">: [</span><span class="s3">None</span><span class="s4">, </span><span class="s1">Integral</span><span class="s4">],</span>
        <span class="s5">&quot;passthrough&quot;</span><span class="s4">: [</span><span class="s5">&quot;boolean&quot;</span><span class="s4">],</span>
        <span class="s5">&quot;verbose&quot;</span><span class="s4">: [</span><span class="s5">&quot;verbose&quot;</span><span class="s4">],</span>
    <span class="s4">}</span>

    <span class="s4">@</span><span class="s1">abstractmethod</span>
    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">estimators</span><span class="s4">,</span>
        <span class="s1">final_estimator</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
        <span class="s4">*,</span>
        <span class="s1">cv</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">stack_method</span><span class="s4">=</span><span class="s5">&quot;auto&quot;</span><span class="s4">,</span>
        <span class="s1">n_jobs</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">verbose</span><span class="s4">=</span><span class="s6">0</span><span class="s4">,</span>
        <span class="s1">passthrough</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
    <span class="s4">):</span>
        <span class="s1">super</span><span class="s4">().</span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">estimators</span><span class="s4">=</span><span class="s1">estimators</span><span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">final_estimator </span><span class="s4">= </span><span class="s1">final_estimator</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">cv </span><span class="s4">= </span><span class="s1">cv</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">stack_method </span><span class="s4">= </span><span class="s1">stack_method</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">n_jobs </span><span class="s4">= </span><span class="s1">n_jobs</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">verbose </span><span class="s4">= </span><span class="s1">verbose</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">passthrough </span><span class="s4">= </span><span class="s1">passthrough</span>

    <span class="s3">def </span><span class="s1">_clone_final_estimator</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">default</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">final_estimator </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">final_estimator_ </span><span class="s4">= </span><span class="s1">clone</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">final_estimator</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">final_estimator_ </span><span class="s4">= </span><span class="s1">clone</span><span class="s4">(</span><span class="s1">default</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_concatenate_predictions</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">X</span><span class="s4">, </span><span class="s1">predictions</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Concatenate the predictions of each first layer learner and 
        possibly the input dataset `X`. 
 
        If `X` is sparse and `self.passthrough` is False, the output of 
        `transform` will be dense (the predictions). If `X` is sparse 
        and `self.passthrough` is True, the output of `transform` will 
        be sparse. 
 
        This helper is in charge of ensuring the predictions are 2D arrays and 
        it will drop one of the probability column when using probabilities 
        in the binary case. Indeed, the p(y|c=0) = 1 - p(y|c=1) 
 
        When `y` type is `&quot;multilabel-indicator&quot;`` and the method used is 
        `predict_proba`, `preds` can be either a `ndarray` of shape 
        `(n_samples, n_class)` or for some estimators a list of `ndarray`. 
        This function will drop one of the probability column in this situation as well. 
        &quot;&quot;&quot;</span>
        <span class="s1">X_meta </span><span class="s4">= []</span>
        <span class="s3">for </span><span class="s1">est_idx</span><span class="s4">, </span><span class="s1">preds </span><span class="s3">in </span><span class="s1">enumerate</span><span class="s4">(</span><span class="s1">predictions</span><span class="s4">):</span>
            <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">preds</span><span class="s4">, </span><span class="s1">list</span><span class="s4">):</span>
                <span class="s2"># `preds` is here a list of `n_targets` 2D ndarrays of</span>
                <span class="s2"># `n_classes` columns. The k-th column contains the</span>
                <span class="s2"># probabilities of the samples belonging the k-th class.</span>
                <span class="s2">#</span>
                <span class="s2"># Since those probabilities must sum to one for each sample,</span>
                <span class="s2"># we can work with probabilities of `n_classes - 1` classes.</span>
                <span class="s2"># Hence we drop the first column.</span>
                <span class="s3">for </span><span class="s1">pred </span><span class="s3">in </span><span class="s1">preds</span><span class="s4">:</span>
                    <span class="s1">X_meta</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">pred</span><span class="s4">[:, </span><span class="s6">1</span><span class="s4">:])</span>
            <span class="s3">elif </span><span class="s1">preds</span><span class="s4">.</span><span class="s1">ndim </span><span class="s4">== </span><span class="s6">1</span><span class="s4">:</span>
                <span class="s2"># Some estimator return a 1D array for predictions</span>
                <span class="s2"># which must be 2-dimensional arrays.</span>
                <span class="s1">X_meta</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">preds</span><span class="s4">.</span><span class="s1">reshape</span><span class="s4">(-</span><span class="s6">1</span><span class="s4">, </span><span class="s6">1</span><span class="s4">))</span>
            <span class="s3">elif </span><span class="s4">(</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">stack_method_</span><span class="s4">[</span><span class="s1">est_idx</span><span class="s4">] == </span><span class="s5">&quot;predict_proba&quot;</span>
                <span class="s3">and </span><span class="s1">len</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">classes_</span><span class="s4">) == </span><span class="s6">2</span>
            <span class="s4">):</span>
                <span class="s2"># Remove the first column when using probabilities in</span>
                <span class="s2"># binary classification because both features `preds` are perfectly</span>
                <span class="s2"># collinear.</span>
                <span class="s1">X_meta</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">preds</span><span class="s4">[:, </span><span class="s6">1</span><span class="s4">:])</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">X_meta</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">preds</span><span class="s4">)</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">_n_feature_outs </span><span class="s4">= [</span><span class="s1">pred</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">1</span><span class="s4">] </span><span class="s3">for </span><span class="s1">pred </span><span class="s3">in </span><span class="s1">X_meta</span><span class="s4">]</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">passthrough</span><span class="s4">:</span>
            <span class="s1">X_meta</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)</span>
            <span class="s3">if </span><span class="s1">sparse</span><span class="s4">.</span><span class="s1">issparse</span><span class="s4">(</span><span class="s1">X</span><span class="s4">):</span>
                <span class="s3">return </span><span class="s1">sparse</span><span class="s4">.</span><span class="s1">hstack</span><span class="s4">(</span><span class="s1">X_meta</span><span class="s4">, </span><span class="s1">format</span><span class="s4">=</span><span class="s1">X</span><span class="s4">.</span><span class="s1">format</span><span class="s4">)</span>

        <span class="s3">return </span><span class="s1">np</span><span class="s4">.</span><span class="s1">hstack</span><span class="s4">(</span><span class="s1">X_meta</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">staticmethod</span>
    <span class="s3">def </span><span class="s1">_method_name</span><span class="s4">(</span><span class="s1">name</span><span class="s4">, </span><span class="s1">estimator</span><span class="s4">, </span><span class="s1">method</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">estimator </span><span class="s4">== </span><span class="s5">&quot;drop&quot;</span><span class="s4">:</span>
            <span class="s3">return None</span>
        <span class="s3">if </span><span class="s1">method </span><span class="s4">== </span><span class="s5">&quot;auto&quot;</span><span class="s4">:</span>
            <span class="s1">method </span><span class="s4">= [</span><span class="s5">&quot;predict_proba&quot;</span><span class="s4">, </span><span class="s5">&quot;decision_function&quot;</span><span class="s4">, </span><span class="s5">&quot;predict&quot;</span><span class="s4">]</span>
        <span class="s3">try</span><span class="s4">:</span>
            <span class="s1">method_name </span><span class="s4">= </span><span class="s1">_check_response_method</span><span class="s4">(</span><span class="s1">estimator</span><span class="s4">, </span><span class="s1">method</span><span class="s4">).</span><span class="s1">__name__</span>
        <span class="s3">except </span><span class="s1">AttributeError </span><span class="s3">as </span><span class="s1">e</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span>
                <span class="s5">f&quot;Underlying estimator </span><span class="s3">{</span><span class="s1">name</span><span class="s3">} </span><span class="s5">does not implement the method </span><span class="s3">{</span><span class="s1">method</span><span class="s3">}</span><span class="s5">.&quot;</span>
            <span class="s4">) </span><span class="s3">from </span><span class="s1">e</span>

        <span class="s3">return </span><span class="s1">method_name</span>

    <span class="s4">@</span><span class="s1">_fit_context</span><span class="s4">(</span>
        <span class="s2"># estimators in Stacking*.estimators are not validated yet</span>
        <span class="s1">prefer_skip_nested_validation</span><span class="s4">=</span><span class="s3">False</span>
    <span class="s4">)</span>
    <span class="s3">def </span><span class="s1">fit</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">X</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, </span><span class="s1">sample_weight</span><span class="s4">=</span><span class="s3">None</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Fit the estimators. 
 
        Parameters 
        ---------- 
        X : {array-like, sparse matrix} of shape (n_samples, n_features) 
            Training vectors, where `n_samples` is the number of samples and 
            `n_features` is the number of features. 
 
        y : array-like of shape (n_samples,) 
            Target values. 
 
        sample_weight : array-like of shape (n_samples,) or default=None 
            Sample weights. If None, then samples are equally weighted. 
            Note that this is supported only if all underlying estimators 
            support sample weights. 
 
            .. versionchanged:: 0.23 
               when not None, `sample_weight` is passed to all underlying 
               estimators 
 
        Returns 
        ------- 
        self : object 
        &quot;&quot;&quot;</span>
        <span class="s2"># all_estimators contains all estimators, the one to be fitted and the</span>
        <span class="s2"># 'drop' string.</span>
        <span class="s1">names</span><span class="s4">, </span><span class="s1">all_estimators </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_validate_estimators</span><span class="s4">()</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_validate_final_estimator</span><span class="s4">()</span>

        <span class="s2"># FIXME: when adding support for metadata routing in Stacking*.</span>
        <span class="s2"># This is a hotfix to make StackingClassifier and StackingRegressor</span>
        <span class="s2"># pass the tests despite not supporting metadata routing but sharing</span>
        <span class="s2"># the same base class with VotingClassifier and VotingRegressor.</span>
        <span class="s1">fit_params </span><span class="s4">= </span><span class="s1">dict</span><span class="s4">()</span>
        <span class="s3">if </span><span class="s1">sample_weight </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s1">fit_params</span><span class="s4">[</span><span class="s5">&quot;sample_weight&quot;</span><span class="s4">] = </span><span class="s1">sample_weight</span>

        <span class="s1">stack_method </span><span class="s4">= [</span><span class="s1">self</span><span class="s4">.</span><span class="s1">stack_method</span><span class="s4">] * </span><span class="s1">len</span><span class="s4">(</span><span class="s1">all_estimators</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">cv </span><span class="s4">== </span><span class="s5">&quot;prefit&quot;</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">estimators_ </span><span class="s4">= []</span>
            <span class="s3">for </span><span class="s1">estimator </span><span class="s3">in </span><span class="s1">all_estimators</span><span class="s4">:</span>
                <span class="s3">if </span><span class="s1">estimator </span><span class="s4">!= </span><span class="s5">&quot;drop&quot;</span><span class="s4">:</span>
                    <span class="s1">check_is_fitted</span><span class="s4">(</span><span class="s1">estimator</span><span class="s4">)</span>
                    <span class="s1">self</span><span class="s4">.</span><span class="s1">estimators_</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">estimator</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s2"># Fit the base estimators on the whole training data. Those</span>
            <span class="s2"># base estimators will be used in transform, predict, and</span>
            <span class="s2"># predict_proba. They are exposed publicly.</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">estimators_ </span><span class="s4">= </span><span class="s1">Parallel</span><span class="s4">(</span><span class="s1">n_jobs</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">n_jobs</span><span class="s4">)(</span>
                <span class="s1">delayed</span><span class="s4">(</span><span class="s1">_fit_single_estimator</span><span class="s4">)(</span><span class="s1">clone</span><span class="s4">(</span><span class="s1">est</span><span class="s4">), </span><span class="s1">X</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, </span><span class="s1">fit_params</span><span class="s4">)</span>
                <span class="s3">for </span><span class="s1">est </span><span class="s3">in </span><span class="s1">all_estimators</span>
                <span class="s3">if </span><span class="s1">est </span><span class="s4">!= </span><span class="s5">&quot;drop&quot;</span>
            <span class="s4">)</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">named_estimators_ </span><span class="s4">= </span><span class="s1">Bunch</span><span class="s4">()</span>
        <span class="s1">est_fitted_idx </span><span class="s4">= </span><span class="s6">0</span>
        <span class="s3">for </span><span class="s1">name_est</span><span class="s4">, </span><span class="s1">org_est </span><span class="s3">in </span><span class="s1">zip</span><span class="s4">(</span><span class="s1">names</span><span class="s4">, </span><span class="s1">all_estimators</span><span class="s4">):</span>
            <span class="s3">if </span><span class="s1">org_est </span><span class="s4">!= </span><span class="s5">&quot;drop&quot;</span><span class="s4">:</span>
                <span class="s1">current_estimator </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">estimators_</span><span class="s4">[</span><span class="s1">est_fitted_idx</span><span class="s4">]</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">named_estimators_</span><span class="s4">[</span><span class="s1">name_est</span><span class="s4">] = </span><span class="s1">current_estimator</span>
                <span class="s1">est_fitted_idx </span><span class="s4">+= </span><span class="s6">1</span>
                <span class="s3">if </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">current_estimator</span><span class="s4">, </span><span class="s5">&quot;feature_names_in_&quot;</span><span class="s4">):</span>
                    <span class="s1">self</span><span class="s4">.</span><span class="s1">feature_names_in_ </span><span class="s4">= </span><span class="s1">current_estimator</span><span class="s4">.</span><span class="s1">feature_names_in_</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">named_estimators_</span><span class="s4">[</span><span class="s1">name_est</span><span class="s4">] = </span><span class="s5">&quot;drop&quot;</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">stack_method_ </span><span class="s4">= [</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_method_name</span><span class="s4">(</span><span class="s1">name</span><span class="s4">, </span><span class="s1">est</span><span class="s4">, </span><span class="s1">meth</span><span class="s4">)</span>
            <span class="s3">for </span><span class="s1">name</span><span class="s4">, </span><span class="s1">est</span><span class="s4">, </span><span class="s1">meth </span><span class="s3">in </span><span class="s1">zip</span><span class="s4">(</span><span class="s1">names</span><span class="s4">, </span><span class="s1">all_estimators</span><span class="s4">, </span><span class="s1">stack_method</span><span class="s4">)</span>
        <span class="s4">]</span>

        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">cv </span><span class="s4">== </span><span class="s5">&quot;prefit&quot;</span><span class="s4">:</span>
            <span class="s2"># Generate predictions from prefit models</span>
            <span class="s1">predictions </span><span class="s4">= [</span>
                <span class="s1">getattr</span><span class="s4">(</span><span class="s1">estimator</span><span class="s4">, </span><span class="s1">predict_method</span><span class="s4">)(</span><span class="s1">X</span><span class="s4">)</span>
                <span class="s3">for </span><span class="s1">estimator</span><span class="s4">, </span><span class="s1">predict_method </span><span class="s3">in </span><span class="s1">zip</span><span class="s4">(</span><span class="s1">all_estimators</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">stack_method_</span><span class="s4">)</span>
                <span class="s3">if </span><span class="s1">estimator </span><span class="s4">!= </span><span class="s5">&quot;drop&quot;</span>
            <span class="s4">]</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s2"># To train the meta-classifier using the most data as possible, we use</span>
            <span class="s2"># a cross-validation to obtain the output of the stacked estimators.</span>
            <span class="s2"># To ensure that the data provided to each estimator are the same,</span>
            <span class="s2"># we need to set the random state of the cv if there is one and we</span>
            <span class="s2"># need to take a copy.</span>
            <span class="s1">cv </span><span class="s4">= </span><span class="s1">check_cv</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">cv</span><span class="s4">, </span><span class="s1">y</span><span class="s4">=</span><span class="s1">y</span><span class="s4">, </span><span class="s1">classifier</span><span class="s4">=</span><span class="s1">is_classifier</span><span class="s4">(</span><span class="s1">self</span><span class="s4">))</span>
            <span class="s3">if </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">cv</span><span class="s4">, </span><span class="s5">&quot;random_state&quot;</span><span class="s4">) </span><span class="s3">and </span><span class="s1">cv</span><span class="s4">.</span><span class="s1">random_state </span><span class="s3">is None</span><span class="s4">:</span>
                <span class="s1">cv</span><span class="s4">.</span><span class="s1">random_state </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">random</span><span class="s4">.</span><span class="s1">RandomState</span><span class="s4">()</span>

            <span class="s1">predictions </span><span class="s4">= </span><span class="s1">Parallel</span><span class="s4">(</span><span class="s1">n_jobs</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">n_jobs</span><span class="s4">)(</span>
                <span class="s1">delayed</span><span class="s4">(</span><span class="s1">cross_val_predict</span><span class="s4">)(</span>
                    <span class="s1">clone</span><span class="s4">(</span><span class="s1">est</span><span class="s4">),</span>
                    <span class="s1">X</span><span class="s4">,</span>
                    <span class="s1">y</span><span class="s4">,</span>
                    <span class="s1">cv</span><span class="s4">=</span><span class="s1">deepcopy</span><span class="s4">(</span><span class="s1">cv</span><span class="s4">),</span>
                    <span class="s1">method</span><span class="s4">=</span><span class="s1">meth</span><span class="s4">,</span>
                    <span class="s1">n_jobs</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">n_jobs</span><span class="s4">,</span>
                    <span class="s1">params</span><span class="s4">=</span><span class="s1">fit_params</span><span class="s4">,</span>
                    <span class="s1">verbose</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">verbose</span><span class="s4">,</span>
                <span class="s4">)</span>
                <span class="s3">for </span><span class="s1">est</span><span class="s4">, </span><span class="s1">meth </span><span class="s3">in </span><span class="s1">zip</span><span class="s4">(</span><span class="s1">all_estimators</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">stack_method_</span><span class="s4">)</span>
                <span class="s3">if </span><span class="s1">est </span><span class="s4">!= </span><span class="s5">&quot;drop&quot;</span>
            <span class="s4">)</span>

        <span class="s2"># Only not None or not 'drop' estimators will be used in transform.</span>
        <span class="s2"># Remove the None from the method as well.</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">stack_method_ </span><span class="s4">= [</span>
            <span class="s1">meth</span>
            <span class="s3">for </span><span class="s4">(</span><span class="s1">meth</span><span class="s4">, </span><span class="s1">est</span><span class="s4">) </span><span class="s3">in </span><span class="s1">zip</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">stack_method_</span><span class="s4">, </span><span class="s1">all_estimators</span><span class="s4">)</span>
            <span class="s3">if </span><span class="s1">est </span><span class="s4">!= </span><span class="s5">&quot;drop&quot;</span>
        <span class="s4">]</span>

        <span class="s1">X_meta </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_concatenate_predictions</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">predictions</span><span class="s4">)</span>
        <span class="s1">_fit_single_estimator</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">final_estimator_</span><span class="s4">, </span><span class="s1">X_meta</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, </span><span class="s1">fit_params</span><span class="s4">=</span><span class="s1">fit_params</span><span class="s4">)</span>

        <span class="s3">return </span><span class="s1">self</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">n_features_in_</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Number of features seen during :term:`fit`.&quot;&quot;&quot;</span>
        <span class="s3">try</span><span class="s4">:</span>
            <span class="s1">check_is_fitted</span><span class="s4">(</span><span class="s1">self</span><span class="s4">)</span>
        <span class="s3">except </span><span class="s1">NotFittedError </span><span class="s3">as </span><span class="s1">nfe</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">AttributeError</span><span class="s4">(</span>
                <span class="s5">f&quot;</span><span class="s3">{</span><span class="s1">self</span><span class="s4">.</span><span class="s1">__class__</span><span class="s4">.</span><span class="s1">__name__</span><span class="s3">} </span><span class="s5">object has no attribute n_features_in_&quot;</span>
            <span class="s4">) </span><span class="s3">from </span><span class="s1">nfe</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">estimators_</span><span class="s4">[</span><span class="s6">0</span><span class="s4">].</span><span class="s1">n_features_in_</span>

    <span class="s3">def </span><span class="s1">_transform</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">X</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Concatenate and return the predictions of the estimators.&quot;&quot;&quot;</span>
        <span class="s1">check_is_fitted</span><span class="s4">(</span><span class="s1">self</span><span class="s4">)</span>
        <span class="s1">predictions </span><span class="s4">= [</span>
            <span class="s1">getattr</span><span class="s4">(</span><span class="s1">est</span><span class="s4">, </span><span class="s1">meth</span><span class="s4">)(</span><span class="s1">X</span><span class="s4">)</span>
            <span class="s3">for </span><span class="s1">est</span><span class="s4">, </span><span class="s1">meth </span><span class="s3">in </span><span class="s1">zip</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">estimators_</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">stack_method_</span><span class="s4">)</span>
            <span class="s3">if </span><span class="s1">est </span><span class="s4">!= </span><span class="s5">&quot;drop&quot;</span>
        <span class="s4">]</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_concatenate_predictions</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">predictions</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">get_feature_names_out</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">input_features</span><span class="s4">=</span><span class="s3">None</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Get output feature names for transformation. 
 
        Parameters 
        ---------- 
        input_features : array-like of str or None, default=None 
            Input features. The input feature names are only used when `passthrough` is 
            `True`. 
 
            - If `input_features` is `None`, then `feature_names_in_` is 
              used as feature names in. If `feature_names_in_` is not defined, 
              then names are generated: `[x0, x1, ..., x(n_features_in_ - 1)]`. 
            - If `input_features` is an array-like, then `input_features` must 
              match `feature_names_in_` if `feature_names_in_` is defined. 
 
            If `passthrough` is `False`, then only the names of `estimators` are used 
            to generate the output feature names. 
 
        Returns 
        ------- 
        feature_names_out : ndarray of str objects 
            Transformed feature names. 
        &quot;&quot;&quot;</span>
        <span class="s1">check_is_fitted</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s5">&quot;n_features_in_&quot;</span><span class="s4">)</span>
        <span class="s1">input_features </span><span class="s4">= </span><span class="s1">_check_feature_names_in</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">, </span><span class="s1">input_features</span><span class="s4">, </span><span class="s1">generate_names</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">passthrough</span>
        <span class="s4">)</span>

        <span class="s1">class_name </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">__class__</span><span class="s4">.</span><span class="s1">__name__</span><span class="s4">.</span><span class="s1">lower</span><span class="s4">()</span>
        <span class="s1">non_dropped_estimators </span><span class="s4">= (</span>
            <span class="s1">name </span><span class="s3">for </span><span class="s1">name</span><span class="s4">, </span><span class="s1">est </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">estimators </span><span class="s3">if </span><span class="s1">est </span><span class="s4">!= </span><span class="s5">&quot;drop&quot;</span>
        <span class="s4">)</span>
        <span class="s1">meta_names </span><span class="s4">= []</span>
        <span class="s3">for </span><span class="s1">est</span><span class="s4">, </span><span class="s1">n_features_out </span><span class="s3">in </span><span class="s1">zip</span><span class="s4">(</span><span class="s1">non_dropped_estimators</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_n_feature_outs</span><span class="s4">):</span>
            <span class="s3">if </span><span class="s1">n_features_out </span><span class="s4">== </span><span class="s6">1</span><span class="s4">:</span>
                <span class="s1">meta_names</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s5">f&quot;</span><span class="s3">{</span><span class="s1">class_name</span><span class="s3">}</span><span class="s5">_</span><span class="s3">{</span><span class="s1">est</span><span class="s3">}</span><span class="s5">&quot;</span><span class="s4">)</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">meta_names</span><span class="s4">.</span><span class="s1">extend</span><span class="s4">(</span>
                    <span class="s5">f&quot;</span><span class="s3">{</span><span class="s1">class_name</span><span class="s3">}</span><span class="s5">_</span><span class="s3">{</span><span class="s1">est</span><span class="s3">}{</span><span class="s1">i</span><span class="s3">}</span><span class="s5">&quot; </span><span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range</span><span class="s4">(</span><span class="s1">n_features_out</span><span class="s4">)</span>
                <span class="s4">)</span>

        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">passthrough</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">np</span><span class="s4">.</span><span class="s1">concatenate</span><span class="s4">((</span><span class="s1">meta_names</span><span class="s4">, </span><span class="s1">input_features</span><span class="s4">))</span>

        <span class="s3">return </span><span class="s1">np</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">(</span><span class="s1">meta_names</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">object</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">available_if</span><span class="s4">(</span><span class="s1">_estimator_has</span><span class="s4">(</span><span class="s5">&quot;predict&quot;</span><span class="s4">))</span>
    <span class="s3">def </span><span class="s1">predict</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">X</span><span class="s4">, **</span><span class="s1">predict_params</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Predict target for X. 
 
        Parameters 
        ---------- 
        X : {array-like, sparse matrix} of shape (n_samples, n_features) 
            Training vectors, where `n_samples` is the number of samples and 
            `n_features` is the number of features. 
 
        **predict_params : dict of str -&gt; obj 
            Parameters to the `predict` called by the `final_estimator`. Note 
            that this may be used to return uncertainties from some estimators 
            with `return_std` or `return_cov`. Be aware that it will only 
            accounts for uncertainty in the final estimator. 
 
        Returns 
        ------- 
        y_pred : ndarray of shape (n_samples,) or (n_samples, n_output) 
            Predicted targets. 
        &quot;&quot;&quot;</span>

        <span class="s1">check_is_fitted</span><span class="s4">(</span><span class="s1">self</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">final_estimator_</span><span class="s4">.</span><span class="s1">predict</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">transform</span><span class="s4">(</span><span class="s1">X</span><span class="s4">), **</span><span class="s1">predict_params</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_sk_visual_block_with_final_estimator</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">final_estimator</span><span class="s4">):</span>
        <span class="s1">names</span><span class="s4">, </span><span class="s1">estimators </span><span class="s4">= </span><span class="s1">zip</span><span class="s4">(*</span><span class="s1">self</span><span class="s4">.</span><span class="s1">estimators</span><span class="s4">)</span>
        <span class="s1">parallel </span><span class="s4">= </span><span class="s1">_VisualBlock</span><span class="s4">(</span><span class="s5">&quot;parallel&quot;</span><span class="s4">, </span><span class="s1">estimators</span><span class="s4">, </span><span class="s1">names</span><span class="s4">=</span><span class="s1">names</span><span class="s4">, </span><span class="s1">dash_wrapped</span><span class="s4">=</span><span class="s3">False</span><span class="s4">)</span>

        <span class="s2"># final estimator is wrapped in a parallel block to show the label:</span>
        <span class="s2"># 'final_estimator' in the html repr</span>
        <span class="s1">final_block </span><span class="s4">= </span><span class="s1">_VisualBlock</span><span class="s4">(</span>
            <span class="s5">&quot;parallel&quot;</span><span class="s4">, [</span><span class="s1">final_estimator</span><span class="s4">], </span><span class="s1">names</span><span class="s4">=[</span><span class="s5">&quot;final_estimator&quot;</span><span class="s4">], </span><span class="s1">dash_wrapped</span><span class="s4">=</span><span class="s3">False</span>
        <span class="s4">)</span>
        <span class="s3">return </span><span class="s1">_VisualBlock</span><span class="s4">(</span><span class="s5">&quot;serial&quot;</span><span class="s4">, (</span><span class="s1">parallel</span><span class="s4">, </span><span class="s1">final_block</span><span class="s4">), </span><span class="s1">dash_wrapped</span><span class="s4">=</span><span class="s3">False</span><span class="s4">)</span>


<span class="s3">class </span><span class="s1">StackingClassifier</span><span class="s4">(</span><span class="s1">_RoutingNotSupportedMixin</span><span class="s4">, </span><span class="s1">ClassifierMixin</span><span class="s4">, </span><span class="s1">_BaseStacking</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Stack of estimators with a final classifier. 
 
    Stacked generalization consists in stacking the output of individual 
    estimator and use a classifier to compute the final prediction. Stacking 
    allows to use the strength of each individual estimator by using their 
    output as input of a final estimator. 
 
    Note that `estimators_` are fitted on the full `X` while `final_estimator_` 
    is trained using cross-validated predictions of the base estimators using 
    `cross_val_predict`. 
 
    Read more in the :ref:`User Guide &lt;stacking&gt;`. 
 
    .. versionadded:: 0.22 
 
    Parameters 
    ---------- 
    estimators : list of (str, estimator) 
        Base estimators which will be stacked together. Each element of the 
        list is defined as a tuple of string (i.e. name) and an estimator 
        instance. An estimator can be set to 'drop' using `set_params`. 
 
        The type of estimator is generally expected to be a classifier. 
        However, one can pass a regressor for some use case (e.g. ordinal 
        regression). 
 
    final_estimator : estimator, default=None 
        A classifier which will be used to combine the base estimators. 
        The default classifier is a 
        :class:`~sklearn.linear_model.LogisticRegression`. 
 
    cv : int, cross-validation generator, iterable, or &quot;prefit&quot;, default=None 
        Determines the cross-validation splitting strategy used in 
        `cross_val_predict` to train `final_estimator`. Possible inputs for 
        cv are: 
 
        * None, to use the default 5-fold cross validation, 
        * integer, to specify the number of folds in a (Stratified) KFold, 
        * An object to be used as a cross-validation generator, 
        * An iterable yielding train, test splits, 
        * `&quot;prefit&quot;` to assume the `estimators` are prefit. In this case, the 
          estimators will not be refitted. 
 
        For integer/None inputs, if the estimator is a classifier and y is 
        either binary or multiclass, 
        :class:`~sklearn.model_selection.StratifiedKFold` is used. 
        In all other cases, :class:`~sklearn.model_selection.KFold` is used. 
        These splitters are instantiated with `shuffle=False` so the splits 
        will be the same across calls. 
 
        Refer :ref:`User Guide &lt;cross_validation&gt;` for the various 
        cross-validation strategies that can be used here. 
 
        If &quot;prefit&quot; is passed, it is assumed that all `estimators` have 
        been fitted already. The `final_estimator_` is trained on the `estimators` 
        predictions on the full training set and are **not** cross validated 
        predictions. Please note that if the models have been trained on the same 
        data to train the stacking model, there is a very high risk of overfitting. 
 
        .. versionadded:: 1.1 
            The 'prefit' option was added in 1.1 
 
        .. note:: 
           A larger number of split will provide no benefits if the number 
           of training samples is large enough. Indeed, the training time 
           will increase. ``cv`` is not used for model evaluation but for 
           prediction. 
 
    stack_method : {'auto', 'predict_proba', 'decision_function', 'predict'}, \ 
            default='auto' 
        Methods called for each base estimator. It can be: 
 
        * if 'auto', it will try to invoke, for each estimator, 
          `'predict_proba'`, `'decision_function'` or `'predict'` in that 
          order. 
        * otherwise, one of `'predict_proba'`, `'decision_function'` or 
          `'predict'`. If the method is not implemented by the estimator, it 
          will raise an error. 
 
    n_jobs : int, default=None 
        The number of jobs to run in parallel all `estimators` `fit`. 
        `None` means 1 unless in a `joblib.parallel_backend` context. -1 means 
        using all processors. See Glossary for more details. 
 
    passthrough : bool, default=False 
        When False, only the predictions of estimators will be used as 
        training data for `final_estimator`. When True, the 
        `final_estimator` is trained on the predictions as well as the 
        original training data. 
 
    verbose : int, default=0 
        Verbosity level. 
 
    Attributes 
    ---------- 
    classes_ : ndarray of shape (n_classes,) or list of ndarray if `y` \ 
        is of type `&quot;multilabel-indicator&quot;`. 
        Class labels. 
 
    estimators_ : list of estimators 
        The elements of the `estimators` parameter, having been fitted on the 
        training data. If an estimator has been set to `'drop'`, it 
        will not appear in `estimators_`. When `cv=&quot;prefit&quot;`, `estimators_` 
        is set to `estimators` and is not fitted again. 
 
    named_estimators_ : :class:`~sklearn.utils.Bunch` 
        Attribute to access any fitted sub-estimators by name. 
 
    n_features_in_ : int 
        Number of features seen during :term:`fit`. Only defined if the 
        underlying classifier exposes such an attribute when fit. 
 
        .. versionadded:: 0.24 
 
    feature_names_in_ : ndarray of shape (`n_features_in_`,) 
        Names of features seen during :term:`fit`. Only defined if the 
        underlying estimators expose such an attribute when fit. 
 
        .. versionadded:: 1.0 
 
    final_estimator_ : estimator 
        The classifier which predicts given the output of `estimators_`. 
 
    stack_method_ : list of str 
        The method used by each base estimator. 
 
    See Also 
    -------- 
    StackingRegressor : Stack of estimators with a final regressor. 
 
    Notes 
    ----- 
    When `predict_proba` is used by each estimator (i.e. most of the time for 
    `stack_method='auto'` or specifically for `stack_method='predict_proba'`), 
    The first column predicted by each estimator will be dropped in the case 
    of a binary classification problem. Indeed, both feature will be perfectly 
    collinear. 
 
    In some cases (e.g. ordinal regression), one can pass regressors as the 
    first layer of the :class:`StackingClassifier`. However, note that `y` will 
    be internally encoded in a numerically increasing order or lexicographic 
    order. If this ordering is not adequate, one should manually numerically 
    encode the classes in the desired order. 
 
    References 
    ---------- 
    .. [1] Wolpert, David H. &quot;Stacked generalization.&quot; Neural networks 5.2 
       (1992): 241-259. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from sklearn.datasets import load_iris 
    &gt;&gt;&gt; from sklearn.ensemble import RandomForestClassifier 
    &gt;&gt;&gt; from sklearn.svm import LinearSVC 
    &gt;&gt;&gt; from sklearn.linear_model import LogisticRegression 
    &gt;&gt;&gt; from sklearn.preprocessing import StandardScaler 
    &gt;&gt;&gt; from sklearn.pipeline import make_pipeline 
    &gt;&gt;&gt; from sklearn.ensemble import StackingClassifier 
    &gt;&gt;&gt; X, y = load_iris(return_X_y=True) 
    &gt;&gt;&gt; estimators = [ 
    ...     ('rf', RandomForestClassifier(n_estimators=10, random_state=42)), 
    ...     ('svr', make_pipeline(StandardScaler(), 
    ...                           LinearSVC(random_state=42))) 
    ... ] 
    &gt;&gt;&gt; clf = StackingClassifier( 
    ...     estimators=estimators, final_estimator=LogisticRegression() 
    ... ) 
    &gt;&gt;&gt; from sklearn.model_selection import train_test_split 
    &gt;&gt;&gt; X_train, X_test, y_train, y_test = train_test_split( 
    ...     X, y, stratify=y, random_state=42 
    ... ) 
    &gt;&gt;&gt; clf.fit(X_train, y_train).score(X_test, y_test) 
    0.9... 
    &quot;&quot;&quot;</span>

    <span class="s1">_parameter_constraints</span><span class="s4">: </span><span class="s1">dict </span><span class="s4">= {</span>
        <span class="s4">**</span><span class="s1">_BaseStacking</span><span class="s4">.</span><span class="s1">_parameter_constraints</span><span class="s4">,</span>
        <span class="s5">&quot;stack_method&quot;</span><span class="s4">: [</span>
            <span class="s1">StrOptions</span><span class="s4">({</span><span class="s5">&quot;auto&quot;</span><span class="s4">, </span><span class="s5">&quot;predict_proba&quot;</span><span class="s4">, </span><span class="s5">&quot;decision_function&quot;</span><span class="s4">, </span><span class="s5">&quot;predict&quot;</span><span class="s4">})</span>
        <span class="s4">],</span>
    <span class="s4">}</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">estimators</span><span class="s4">,</span>
        <span class="s1">final_estimator</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
        <span class="s4">*,</span>
        <span class="s1">cv</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">stack_method</span><span class="s4">=</span><span class="s5">&quot;auto&quot;</span><span class="s4">,</span>
        <span class="s1">n_jobs</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">passthrough</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
        <span class="s1">verbose</span><span class="s4">=</span><span class="s6">0</span><span class="s4">,</span>
    <span class="s4">):</span>
        <span class="s1">super</span><span class="s4">().</span><span class="s1">__init__</span><span class="s4">(</span>
            <span class="s1">estimators</span><span class="s4">=</span><span class="s1">estimators</span><span class="s4">,</span>
            <span class="s1">final_estimator</span><span class="s4">=</span><span class="s1">final_estimator</span><span class="s4">,</span>
            <span class="s1">cv</span><span class="s4">=</span><span class="s1">cv</span><span class="s4">,</span>
            <span class="s1">stack_method</span><span class="s4">=</span><span class="s1">stack_method</span><span class="s4">,</span>
            <span class="s1">n_jobs</span><span class="s4">=</span><span class="s1">n_jobs</span><span class="s4">,</span>
            <span class="s1">passthrough</span><span class="s4">=</span><span class="s1">passthrough</span><span class="s4">,</span>
            <span class="s1">verbose</span><span class="s4">=</span><span class="s1">verbose</span><span class="s4">,</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_validate_final_estimator</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_clone_final_estimator</span><span class="s4">(</span><span class="s1">default</span><span class="s4">=</span><span class="s1">LogisticRegression</span><span class="s4">())</span>
        <span class="s3">if not </span><span class="s1">is_classifier</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">final_estimator_</span><span class="s4">):</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span>
                <span class="s5">&quot;'final_estimator' parameter should be a classifier. Got {}&quot;</span><span class="s4">.</span><span class="s1">format</span><span class="s4">(</span>
                    <span class="s1">self</span><span class="s4">.</span><span class="s1">final_estimator_</span>
                <span class="s4">)</span>
            <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_validate_estimators</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Overload the method of `_BaseHeterogeneousEnsemble` to be more 
        lenient towards the type of `estimators`. 
 
        Regressors can be accepted for some cases such as ordinal regression. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">estimators</span><span class="s4">) == </span><span class="s6">0</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span>
                <span class="s5">&quot;Invalid 'estimators' attribute, 'estimators' should be a &quot;</span>
                <span class="s5">&quot;non-empty list of (string, estimator) tuples.&quot;</span>
            <span class="s4">)</span>
        <span class="s1">names</span><span class="s4">, </span><span class="s1">estimators </span><span class="s4">= </span><span class="s1">zip</span><span class="s4">(*</span><span class="s1">self</span><span class="s4">.</span><span class="s1">estimators</span><span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_validate_names</span><span class="s4">(</span><span class="s1">names</span><span class="s4">)</span>

        <span class="s1">has_estimator </span><span class="s4">= </span><span class="s1">any</span><span class="s4">(</span><span class="s1">est </span><span class="s4">!= </span><span class="s5">&quot;drop&quot; </span><span class="s3">for </span><span class="s1">est </span><span class="s3">in </span><span class="s1">estimators</span><span class="s4">)</span>
        <span class="s3">if not </span><span class="s1">has_estimator</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span>
                <span class="s5">&quot;All estimators are dropped. At least one is required &quot;</span>
                <span class="s5">&quot;to be an estimator.&quot;</span>
            <span class="s4">)</span>

        <span class="s3">return </span><span class="s1">names</span><span class="s4">, </span><span class="s1">estimators</span>

    <span class="s3">def </span><span class="s1">fit</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">X</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, </span><span class="s1">sample_weight</span><span class="s4">=</span><span class="s3">None</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Fit the estimators. 
 
        Parameters 
        ---------- 
        X : {array-like, sparse matrix} of shape (n_samples, n_features) 
            Training vectors, where `n_samples` is the number of samples and 
            `n_features` is the number of features. 
 
        y : array-like of shape (n_samples,) 
            Target values. Note that `y` will be internally encoded in 
            numerically increasing order or lexicographic order. If the order 
            matter (e.g. for ordinal regression), one should numerically encode 
            the target `y` before calling :term:`fit`. 
 
        sample_weight : array-like of shape (n_samples,), default=None 
            Sample weights. If None, then samples are equally weighted. 
            Note that this is supported only if all underlying estimators 
            support sample weights. 
 
        Returns 
        ------- 
        self : object 
            Returns a fitted instance of estimator. 
        &quot;&quot;&quot;</span>
        <span class="s1">_raise_for_unsupported_routing</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s5">&quot;fit&quot;</span><span class="s4">, </span><span class="s1">sample_weight</span><span class="s4">=</span><span class="s1">sample_weight</span><span class="s4">)</span>
        <span class="s1">check_classification_targets</span><span class="s4">(</span><span class="s1">y</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">type_of_target</span><span class="s4">(</span><span class="s1">y</span><span class="s4">) == </span><span class="s5">&quot;multilabel-indicator&quot;</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_label_encoder </span><span class="s4">= [</span><span class="s1">LabelEncoder</span><span class="s4">().</span><span class="s1">fit</span><span class="s4">(</span><span class="s1">yk</span><span class="s4">) </span><span class="s3">for </span><span class="s1">yk </span><span class="s3">in </span><span class="s1">y</span><span class="s4">.</span><span class="s1">T</span><span class="s4">]</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">classes_ </span><span class="s4">= [</span><span class="s1">le</span><span class="s4">.</span><span class="s1">classes_ </span><span class="s3">for </span><span class="s1">le </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_label_encoder</span><span class="s4">]</span>
            <span class="s1">y_encoded </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">array</span><span class="s4">(</span>
                <span class="s4">[</span>
                    <span class="s1">self</span><span class="s4">.</span><span class="s1">_label_encoder</span><span class="s4">[</span><span class="s1">target_idx</span><span class="s4">].</span><span class="s1">transform</span><span class="s4">(</span><span class="s1">target</span><span class="s4">)</span>
                    <span class="s3">for </span><span class="s1">target_idx</span><span class="s4">, </span><span class="s1">target </span><span class="s3">in </span><span class="s1">enumerate</span><span class="s4">(</span><span class="s1">y</span><span class="s4">.</span><span class="s1">T</span><span class="s4">)</span>
                <span class="s4">]</span>
            <span class="s4">).</span><span class="s1">T</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_label_encoder </span><span class="s4">= </span><span class="s1">LabelEncoder</span><span class="s4">().</span><span class="s1">fit</span><span class="s4">(</span><span class="s1">y</span><span class="s4">)</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">classes_ </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_label_encoder</span><span class="s4">.</span><span class="s1">classes_</span>
            <span class="s1">y_encoded </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_label_encoder</span><span class="s4">.</span><span class="s1">transform</span><span class="s4">(</span><span class="s1">y</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">super</span><span class="s4">().</span><span class="s1">fit</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">y_encoded</span><span class="s4">, </span><span class="s1">sample_weight</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">available_if</span><span class="s4">(</span><span class="s1">_estimator_has</span><span class="s4">(</span><span class="s5">&quot;predict&quot;</span><span class="s4">))</span>
    <span class="s3">def </span><span class="s1">predict</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">X</span><span class="s4">, **</span><span class="s1">predict_params</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Predict target for X. 
 
        Parameters 
        ---------- 
        X : {array-like, sparse matrix} of shape (n_samples, n_features) 
            Training vectors, where `n_samples` is the number of samples and 
            `n_features` is the number of features. 
 
        **predict_params : dict of str -&gt; obj 
            Parameters to the `predict` called by the `final_estimator`. Note 
            that this may be used to return uncertainties from some estimators 
            with `return_std` or `return_cov`. Be aware that it will only 
            accounts for uncertainty in the final estimator. 
 
        Returns 
        ------- 
        y_pred : ndarray of shape (n_samples,) or (n_samples, n_output) 
            Predicted targets. 
        &quot;&quot;&quot;</span>
        <span class="s1">y_pred </span><span class="s4">= </span><span class="s1">super</span><span class="s4">().</span><span class="s1">predict</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, **</span><span class="s1">predict_params</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_label_encoder</span><span class="s4">, </span><span class="s1">list</span><span class="s4">):</span>
            <span class="s2"># Handle the multilabel-indicator case</span>
            <span class="s1">y_pred </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">array</span><span class="s4">(</span>
                <span class="s4">[</span>
                    <span class="s1">self</span><span class="s4">.</span><span class="s1">_label_encoder</span><span class="s4">[</span><span class="s1">target_idx</span><span class="s4">].</span><span class="s1">inverse_transform</span><span class="s4">(</span><span class="s1">target</span><span class="s4">)</span>
                    <span class="s3">for </span><span class="s1">target_idx</span><span class="s4">, </span><span class="s1">target </span><span class="s3">in </span><span class="s1">enumerate</span><span class="s4">(</span><span class="s1">y_pred</span><span class="s4">.</span><span class="s1">T</span><span class="s4">)</span>
                <span class="s4">]</span>
            <span class="s4">).</span><span class="s1">T</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">y_pred </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_label_encoder</span><span class="s4">.</span><span class="s1">inverse_transform</span><span class="s4">(</span><span class="s1">y_pred</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">y_pred</span>

    <span class="s4">@</span><span class="s1">available_if</span><span class="s4">(</span><span class="s1">_estimator_has</span><span class="s4">(</span><span class="s5">&quot;predict_proba&quot;</span><span class="s4">))</span>
    <span class="s3">def </span><span class="s1">predict_proba</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">X</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Predict class probabilities for `X` using the final estimator. 
 
        Parameters 
        ---------- 
        X : {array-like, sparse matrix} of shape (n_samples, n_features) 
            Training vectors, where `n_samples` is the number of samples and 
            `n_features` is the number of features. 
 
        Returns 
        ------- 
        probabilities : ndarray of shape (n_samples, n_classes) or \ 
            list of ndarray of shape (n_output,) 
            The class probabilities of the input samples. 
        &quot;&quot;&quot;</span>
        <span class="s1">check_is_fitted</span><span class="s4">(</span><span class="s1">self</span><span class="s4">)</span>
        <span class="s1">y_pred </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">final_estimator_</span><span class="s4">.</span><span class="s1">predict_proba</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">transform</span><span class="s4">(</span><span class="s1">X</span><span class="s4">))</span>

        <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_label_encoder</span><span class="s4">, </span><span class="s1">list</span><span class="s4">):</span>
            <span class="s2"># Handle the multilabel-indicator cases</span>
            <span class="s1">y_pred </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">array</span><span class="s4">([</span><span class="s1">preds</span><span class="s4">[:, </span><span class="s6">0</span><span class="s4">] </span><span class="s3">for </span><span class="s1">preds </span><span class="s3">in </span><span class="s1">y_pred</span><span class="s4">]).</span><span class="s1">T</span>
        <span class="s3">return </span><span class="s1">y_pred</span>

    <span class="s4">@</span><span class="s1">available_if</span><span class="s4">(</span><span class="s1">_estimator_has</span><span class="s4">(</span><span class="s5">&quot;decision_function&quot;</span><span class="s4">))</span>
    <span class="s3">def </span><span class="s1">decision_function</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">X</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Decision function for samples in `X` using the final estimator. 
 
        Parameters 
        ---------- 
        X : {array-like, sparse matrix} of shape (n_samples, n_features) 
            Training vectors, where `n_samples` is the number of samples and 
            `n_features` is the number of features. 
 
        Returns 
        ------- 
        decisions : ndarray of shape (n_samples,), (n_samples, n_classes), \ 
            or (n_samples, n_classes * (n_classes-1) / 2) 
            The decision function computed the final estimator. 
        &quot;&quot;&quot;</span>
        <span class="s1">check_is_fitted</span><span class="s4">(</span><span class="s1">self</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">final_estimator_</span><span class="s4">.</span><span class="s1">decision_function</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">transform</span><span class="s4">(</span><span class="s1">X</span><span class="s4">))</span>

    <span class="s3">def </span><span class="s1">transform</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">X</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Return class labels or probabilities for X for each estimator. 
 
        Parameters 
        ---------- 
        X : {array-like, sparse matrix} of shape (n_samples, n_features) 
            Training vectors, where `n_samples` is the number of samples and 
            `n_features` is the number of features. 
 
        Returns 
        ------- 
        y_preds : ndarray of shape (n_samples, n_estimators) or \ 
                (n_samples, n_classes * n_estimators) 
            Prediction outputs for each estimator. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_transform</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_sk_visual_block_</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s2"># If final_estimator's default changes then this should be</span>
        <span class="s2"># updated.</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">final_estimator </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s1">final_estimator </span><span class="s4">= </span><span class="s1">LogisticRegression</span><span class="s4">()</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">final_estimator </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">final_estimator</span>
        <span class="s3">return </span><span class="s1">super</span><span class="s4">().</span><span class="s1">_sk_visual_block_with_final_estimator</span><span class="s4">(</span><span class="s1">final_estimator</span><span class="s4">)</span>


<span class="s3">class </span><span class="s1">StackingRegressor</span><span class="s4">(</span><span class="s1">_RoutingNotSupportedMixin</span><span class="s4">, </span><span class="s1">RegressorMixin</span><span class="s4">, </span><span class="s1">_BaseStacking</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Stack of estimators with a final regressor. 
 
    Stacked generalization consists in stacking the output of individual 
    estimator and use a regressor to compute the final prediction. Stacking 
    allows to use the strength of each individual estimator by using their 
    output as input of a final estimator. 
 
    Note that `estimators_` are fitted on the full `X` while `final_estimator_` 
    is trained using cross-validated predictions of the base estimators using 
    `cross_val_predict`. 
 
    Read more in the :ref:`User Guide &lt;stacking&gt;`. 
 
    .. versionadded:: 0.22 
 
    Parameters 
    ---------- 
    estimators : list of (str, estimator) 
        Base estimators which will be stacked together. Each element of the 
        list is defined as a tuple of string (i.e. name) and an estimator 
        instance. An estimator can be set to 'drop' using `set_params`. 
 
    final_estimator : estimator, default=None 
        A regressor which will be used to combine the base estimators. 
        The default regressor is a :class:`~sklearn.linear_model.RidgeCV`. 
 
    cv : int, cross-validation generator, iterable, or &quot;prefit&quot;, default=None 
        Determines the cross-validation splitting strategy used in 
        `cross_val_predict` to train `final_estimator`. Possible inputs for 
        cv are: 
 
        * None, to use the default 5-fold cross validation, 
        * integer, to specify the number of folds in a (Stratified) KFold, 
        * An object to be used as a cross-validation generator, 
        * An iterable yielding train, test splits. 
        * &quot;prefit&quot; to assume the `estimators` are prefit, and skip cross validation 
 
        For integer/None inputs, if the estimator is a classifier and y is 
        either binary or multiclass, 
        :class:`~sklearn.model_selection.StratifiedKFold` is used. 
        In all other cases, :class:`~sklearn.model_selection.KFold` is used. 
        These splitters are instantiated with `shuffle=False` so the splits 
        will be the same across calls. 
 
        Refer :ref:`User Guide &lt;cross_validation&gt;` for the various 
        cross-validation strategies that can be used here. 
 
        If &quot;prefit&quot; is passed, it is assumed that all `estimators` have 
        been fitted already. The `final_estimator_` is trained on the `estimators` 
        predictions on the full training set and are **not** cross validated 
        predictions. Please note that if the models have been trained on the same 
        data to train the stacking model, there is a very high risk of overfitting. 
 
        .. versionadded:: 1.1 
            The 'prefit' option was added in 1.1 
 
        .. note:: 
           A larger number of split will provide no benefits if the number 
           of training samples is large enough. Indeed, the training time 
           will increase. ``cv`` is not used for model evaluation but for 
           prediction. 
 
    n_jobs : int, default=None 
        The number of jobs to run in parallel for `fit` of all `estimators`. 
        `None` means 1 unless in a `joblib.parallel_backend` context. -1 means 
        using all processors. See Glossary for more details. 
 
    passthrough : bool, default=False 
        When False, only the predictions of estimators will be used as 
        training data for `final_estimator`. When True, the 
        `final_estimator` is trained on the predictions as well as the 
        original training data. 
 
    verbose : int, default=0 
        Verbosity level. 
 
    Attributes 
    ---------- 
    estimators_ : list of estimator 
        The elements of the `estimators` parameter, having been fitted on the 
        training data. If an estimator has been set to `'drop'`, it 
        will not appear in `estimators_`. When `cv=&quot;prefit&quot;`, `estimators_` 
        is set to `estimators` and is not fitted again. 
 
    named_estimators_ : :class:`~sklearn.utils.Bunch` 
        Attribute to access any fitted sub-estimators by name. 
 
    n_features_in_ : int 
        Number of features seen during :term:`fit`. Only defined if the 
        underlying regressor exposes such an attribute when fit. 
 
        .. versionadded:: 0.24 
 
    feature_names_in_ : ndarray of shape (`n_features_in_`,) 
        Names of features seen during :term:`fit`. Only defined if the 
        underlying estimators expose such an attribute when fit. 
 
        .. versionadded:: 1.0 
 
    final_estimator_ : estimator 
        The regressor to stacked the base estimators fitted. 
 
    stack_method_ : list of str 
        The method used by each base estimator. 
 
    See Also 
    -------- 
    StackingClassifier : Stack of estimators with a final classifier. 
 
    References 
    ---------- 
    .. [1] Wolpert, David H. &quot;Stacked generalization.&quot; Neural networks 5.2 
       (1992): 241-259. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from sklearn.datasets import load_diabetes 
    &gt;&gt;&gt; from sklearn.linear_model import RidgeCV 
    &gt;&gt;&gt; from sklearn.svm import LinearSVR 
    &gt;&gt;&gt; from sklearn.ensemble import RandomForestRegressor 
    &gt;&gt;&gt; from sklearn.ensemble import StackingRegressor 
    &gt;&gt;&gt; X, y = load_diabetes(return_X_y=True) 
    &gt;&gt;&gt; estimators = [ 
    ...     ('lr', RidgeCV()), 
    ...     ('svr', LinearSVR(random_state=42)) 
    ... ] 
    &gt;&gt;&gt; reg = StackingRegressor( 
    ...     estimators=estimators, 
    ...     final_estimator=RandomForestRegressor(n_estimators=10, 
    ...                                           random_state=42) 
    ... ) 
    &gt;&gt;&gt; from sklearn.model_selection import train_test_split 
    &gt;&gt;&gt; X_train, X_test, y_train, y_test = train_test_split( 
    ...     X, y, random_state=42 
    ... ) 
    &gt;&gt;&gt; reg.fit(X_train, y_train).score(X_test, y_test) 
    0.3... 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">estimators</span><span class="s4">,</span>
        <span class="s1">final_estimator</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
        <span class="s4">*,</span>
        <span class="s1">cv</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">n_jobs</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">passthrough</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
        <span class="s1">verbose</span><span class="s4">=</span><span class="s6">0</span><span class="s4">,</span>
    <span class="s4">):</span>
        <span class="s1">super</span><span class="s4">().</span><span class="s1">__init__</span><span class="s4">(</span>
            <span class="s1">estimators</span><span class="s4">=</span><span class="s1">estimators</span><span class="s4">,</span>
            <span class="s1">final_estimator</span><span class="s4">=</span><span class="s1">final_estimator</span><span class="s4">,</span>
            <span class="s1">cv</span><span class="s4">=</span><span class="s1">cv</span><span class="s4">,</span>
            <span class="s1">stack_method</span><span class="s4">=</span><span class="s5">&quot;predict&quot;</span><span class="s4">,</span>
            <span class="s1">n_jobs</span><span class="s4">=</span><span class="s1">n_jobs</span><span class="s4">,</span>
            <span class="s1">passthrough</span><span class="s4">=</span><span class="s1">passthrough</span><span class="s4">,</span>
            <span class="s1">verbose</span><span class="s4">=</span><span class="s1">verbose</span><span class="s4">,</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_validate_final_estimator</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_clone_final_estimator</span><span class="s4">(</span><span class="s1">default</span><span class="s4">=</span><span class="s1">RidgeCV</span><span class="s4">())</span>
        <span class="s3">if not </span><span class="s1">is_regressor</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">final_estimator_</span><span class="s4">):</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span>
                <span class="s5">&quot;'final_estimator' parameter should be a regressor. Got {}&quot;</span><span class="s4">.</span><span class="s1">format</span><span class="s4">(</span>
                    <span class="s1">self</span><span class="s4">.</span><span class="s1">final_estimator_</span>
                <span class="s4">)</span>
            <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">fit</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">X</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, </span><span class="s1">sample_weight</span><span class="s4">=</span><span class="s3">None</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Fit the estimators. 
 
        Parameters 
        ---------- 
        X : {array-like, sparse matrix} of shape (n_samples, n_features) 
            Training vectors, where `n_samples` is the number of samples and 
            `n_features` is the number of features. 
 
        y : array-like of shape (n_samples,) 
            Target values. 
 
        sample_weight : array-like of shape (n_samples,), default=None 
            Sample weights. If None, then samples are equally weighted. 
            Note that this is supported only if all underlying estimators 
            support sample weights. 
 
        Returns 
        ------- 
        self : object 
            Returns a fitted instance. 
        &quot;&quot;&quot;</span>
        <span class="s1">_raise_for_unsupported_routing</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s5">&quot;fit&quot;</span><span class="s4">, </span><span class="s1">sample_weight</span><span class="s4">=</span><span class="s1">sample_weight</span><span class="s4">)</span>
        <span class="s1">y </span><span class="s4">= </span><span class="s1">column_or_1d</span><span class="s4">(</span><span class="s1">y</span><span class="s4">, </span><span class="s1">warn</span><span class="s4">=</span><span class="s3">True</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">super</span><span class="s4">().</span><span class="s1">fit</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, </span><span class="s1">sample_weight</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">transform</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">X</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Return the predictions for X for each estimator. 
 
        Parameters 
        ---------- 
        X : {array-like, sparse matrix} of shape (n_samples, n_features) 
            Training vectors, where `n_samples` is the number of samples and 
            `n_features` is the number of features. 
 
        Returns 
        ------- 
        y_preds : ndarray of shape (n_samples, n_estimators) 
            Prediction outputs for each estimator. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_transform</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">fit_transform</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">X</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, </span><span class="s1">sample_weight</span><span class="s4">=</span><span class="s3">None</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Fit the estimators and return the predictions for X for each estimator. 
 
        Parameters 
        ---------- 
        X : {array-like, sparse matrix} of shape (n_samples, n_features) 
            Training vectors, where `n_samples` is the number of samples and 
            `n_features` is the number of features. 
 
        y : array-like of shape (n_samples,) 
            Target values. 
 
        sample_weight : array-like of shape (n_samples,), default=None 
            Sample weights. If None, then samples are equally weighted. 
            Note that this is supported only if all underlying estimators 
            support sample weights. 
 
        Returns 
        ------- 
        y_preds : ndarray of shape (n_samples, n_estimators) 
            Prediction outputs for each estimator. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">super</span><span class="s4">().</span><span class="s1">fit_transform</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, </span><span class="s1">sample_weight</span><span class="s4">=</span><span class="s1">sample_weight</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_sk_visual_block_</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s2"># If final_estimator's default changes then this should be</span>
        <span class="s2"># updated.</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">final_estimator </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s1">final_estimator </span><span class="s4">= </span><span class="s1">RidgeCV</span><span class="s4">()</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">final_estimator </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">final_estimator</span>
        <span class="s3">return </span><span class="s1">super</span><span class="s4">().</span><span class="s1">_sk_visual_block_with_final_estimator</span><span class="s4">(</span><span class="s1">final_estimator</span><span class="s4">)</span>
</pre>
</body>
</html>