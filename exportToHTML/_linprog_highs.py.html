<html>
<head>
<title>_linprog_highs.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #2aacb8;}
.s5 { color: #6aab73;}
.s6 { color: #7a7e85;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_linprog_highs.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;HiGHS Linear Optimization Methods 
 
Interface to HiGHS linear optimization software. 
https://highs.dev/ 
 
.. versionadded:: 1.5.0 
 
References 
---------- 
.. [1] Q. Huangfu and J.A.J. Hall. &quot;Parallelizing the dual revised simplex 
           method.&quot; Mathematical Programming Computation, 10 (1), 119-142, 
           2018. DOI: 10.1007/s12532-017-0130-5 
 
&quot;&quot;&quot;</span>

<span class="s2">import </span><span class="s1">inspect</span>
<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">_optimize </span><span class="s2">import </span><span class="s1">OptimizeWarning</span><span class="s3">, </span><span class="s1">OptimizeResult</span>
<span class="s2">from </span><span class="s1">warnings </span><span class="s2">import </span><span class="s1">warn</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">_highs</span><span class="s3">.</span><span class="s1">_highs_wrapper </span><span class="s2">import </span><span class="s1">_highs_wrapper</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">_highs</span><span class="s3">.</span><span class="s1">_highs_constants </span><span class="s2">import </span><span class="s3">(</span>
    <span class="s1">CONST_INF</span><span class="s3">,</span>
    <span class="s1">MESSAGE_LEVEL_NONE</span><span class="s3">,</span>
    <span class="s1">HIGHS_OBJECTIVE_SENSE_MINIMIZE</span><span class="s3">,</span>

    <span class="s1">MODEL_STATUS_NOTSET</span><span class="s3">,</span>
    <span class="s1">MODEL_STATUS_LOAD_ERROR</span><span class="s3">,</span>
    <span class="s1">MODEL_STATUS_MODEL_ERROR</span><span class="s3">,</span>
    <span class="s1">MODEL_STATUS_PRESOLVE_ERROR</span><span class="s3">,</span>
    <span class="s1">MODEL_STATUS_SOLVE_ERROR</span><span class="s3">,</span>
    <span class="s1">MODEL_STATUS_POSTSOLVE_ERROR</span><span class="s3">,</span>
    <span class="s1">MODEL_STATUS_MODEL_EMPTY</span><span class="s3">,</span>
    <span class="s1">MODEL_STATUS_OPTIMAL</span><span class="s3">,</span>
    <span class="s1">MODEL_STATUS_INFEASIBLE</span><span class="s3">,</span>
    <span class="s1">MODEL_STATUS_UNBOUNDED_OR_INFEASIBLE</span><span class="s3">,</span>
    <span class="s1">MODEL_STATUS_UNBOUNDED</span><span class="s3">,</span>
    <span class="s1">MODEL_STATUS_REACHED_DUAL_OBJECTIVE_VALUE_UPPER_BOUND</span>
    <span class="s2">as </span><span class="s1">MODEL_STATUS_RDOVUB</span><span class="s3">,</span>
    <span class="s1">MODEL_STATUS_REACHED_OBJECTIVE_TARGET</span><span class="s3">,</span>
    <span class="s1">MODEL_STATUS_REACHED_TIME_LIMIT</span><span class="s3">,</span>
    <span class="s1">MODEL_STATUS_REACHED_ITERATION_LIMIT</span><span class="s3">,</span>

    <span class="s1">HIGHS_SIMPLEX_STRATEGY_DUAL</span><span class="s3">,</span>

    <span class="s1">HIGHS_SIMPLEX_CRASH_STRATEGY_OFF</span><span class="s3">,</span>

    <span class="s1">HIGHS_SIMPLEX_EDGE_WEIGHT_STRATEGY_CHOOSE</span><span class="s3">,</span>
    <span class="s1">HIGHS_SIMPLEX_EDGE_WEIGHT_STRATEGY_DANTZIG</span><span class="s3">,</span>
    <span class="s1">HIGHS_SIMPLEX_EDGE_WEIGHT_STRATEGY_DEVEX</span><span class="s3">,</span>
    <span class="s1">HIGHS_SIMPLEX_EDGE_WEIGHT_STRATEGY_STEEPEST_EDGE</span><span class="s3">,</span>
<span class="s3">)</span>
<span class="s2">from </span><span class="s1">scipy</span><span class="s3">.</span><span class="s1">sparse </span><span class="s2">import </span><span class="s1">csc_matrix</span><span class="s3">, </span><span class="s1">vstack</span><span class="s3">, </span><span class="s1">issparse</span>


<span class="s2">def </span><span class="s1">_highs_to_scipy_status_message</span><span class="s3">(</span><span class="s1">highs_status</span><span class="s3">, </span><span class="s1">highs_message</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Converts HiGHS status number/message to SciPy status number/message&quot;&quot;&quot;</span>

    <span class="s1">scipy_statuses_messages </span><span class="s3">= {</span>
        <span class="s2">None</span><span class="s3">: (</span><span class="s4">4</span><span class="s3">, </span><span class="s5">&quot;HiGHS did not provide a status code. &quot;</span><span class="s3">),</span>
        <span class="s1">MODEL_STATUS_NOTSET</span><span class="s3">: (</span><span class="s4">4</span><span class="s3">, </span><span class="s5">&quot;&quot;</span><span class="s3">),</span>
        <span class="s1">MODEL_STATUS_LOAD_ERROR</span><span class="s3">: (</span><span class="s4">4</span><span class="s3">, </span><span class="s5">&quot;&quot;</span><span class="s3">),</span>
        <span class="s1">MODEL_STATUS_MODEL_ERROR</span><span class="s3">: (</span><span class="s4">2</span><span class="s3">, </span><span class="s5">&quot;&quot;</span><span class="s3">),</span>
        <span class="s1">MODEL_STATUS_PRESOLVE_ERROR</span><span class="s3">: (</span><span class="s4">4</span><span class="s3">, </span><span class="s5">&quot;&quot;</span><span class="s3">),</span>
        <span class="s1">MODEL_STATUS_SOLVE_ERROR</span><span class="s3">: (</span><span class="s4">4</span><span class="s3">, </span><span class="s5">&quot;&quot;</span><span class="s3">),</span>
        <span class="s1">MODEL_STATUS_POSTSOLVE_ERROR</span><span class="s3">: (</span><span class="s4">4</span><span class="s3">, </span><span class="s5">&quot;&quot;</span><span class="s3">),</span>
        <span class="s1">MODEL_STATUS_MODEL_EMPTY</span><span class="s3">: (</span><span class="s4">4</span><span class="s3">, </span><span class="s5">&quot;&quot;</span><span class="s3">),</span>
        <span class="s1">MODEL_STATUS_RDOVUB</span><span class="s3">: (</span><span class="s4">4</span><span class="s3">, </span><span class="s5">&quot;&quot;</span><span class="s3">),</span>
        <span class="s1">MODEL_STATUS_REACHED_OBJECTIVE_TARGET</span><span class="s3">: (</span><span class="s4">4</span><span class="s3">, </span><span class="s5">&quot;&quot;</span><span class="s3">),</span>
        <span class="s1">MODEL_STATUS_OPTIMAL</span><span class="s3">: (</span><span class="s4">0</span><span class="s3">, </span><span class="s5">&quot;Optimization terminated successfully. &quot;</span><span class="s3">),</span>
        <span class="s1">MODEL_STATUS_REACHED_TIME_LIMIT</span><span class="s3">: (</span><span class="s4">1</span><span class="s3">, </span><span class="s5">&quot;Time limit reached. &quot;</span><span class="s3">),</span>
        <span class="s1">MODEL_STATUS_REACHED_ITERATION_LIMIT</span><span class="s3">: (</span><span class="s4">1</span><span class="s3">, </span><span class="s5">&quot;Iteration limit reached. &quot;</span><span class="s3">),</span>
        <span class="s1">MODEL_STATUS_INFEASIBLE</span><span class="s3">: (</span><span class="s4">2</span><span class="s3">, </span><span class="s5">&quot;The problem is infeasible. &quot;</span><span class="s3">),</span>
        <span class="s1">MODEL_STATUS_UNBOUNDED</span><span class="s3">: (</span><span class="s4">3</span><span class="s3">, </span><span class="s5">&quot;The problem is unbounded. &quot;</span><span class="s3">),</span>
        <span class="s1">MODEL_STATUS_UNBOUNDED_OR_INFEASIBLE</span><span class="s3">: (</span><span class="s4">4</span><span class="s3">, </span><span class="s5">&quot;The problem is unbounded &quot;</span>
                                               <span class="s5">&quot;or infeasible. &quot;</span><span class="s3">)}</span>
    <span class="s1">unrecognized </span><span class="s3">= (</span><span class="s4">4</span><span class="s3">, </span><span class="s5">&quot;The HiGHS status code was not recognized. &quot;</span><span class="s3">)</span>
    <span class="s1">scipy_status</span><span class="s3">, </span><span class="s1">scipy_message </span><span class="s3">= (</span>
        <span class="s1">scipy_statuses_messages</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">highs_status</span><span class="s3">, </span><span class="s1">unrecognized</span><span class="s3">))</span>
    <span class="s1">scipy_message </span><span class="s3">= (</span><span class="s5">f&quot;</span><span class="s2">{</span><span class="s1">scipy_message</span><span class="s2">}</span><span class="s5">&quot;</span>
                     <span class="s5">f&quot;(HiGHS Status </span><span class="s2">{</span><span class="s1">highs_status</span><span class="s2">}</span><span class="s5">: </span><span class="s2">{</span><span class="s1">highs_message</span><span class="s2">}</span><span class="s5">)&quot;</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">scipy_status</span><span class="s3">, </span><span class="s1">scipy_message</span>


<span class="s2">def </span><span class="s1">_replace_inf</span><span class="s3">(</span><span class="s1">x</span><span class="s3">):</span>
    <span class="s6"># Replace `np.inf` with CONST_INF</span>
    <span class="s1">infs </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isinf</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
    <span class="s2">with </span><span class="s1">np</span><span class="s3">.</span><span class="s1">errstate</span><span class="s3">(</span><span class="s1">invalid</span><span class="s3">=</span><span class="s5">&quot;ignore&quot;</span><span class="s3">):</span>
        <span class="s1">x</span><span class="s3">[</span><span class="s1">infs</span><span class="s3">] = </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sign</span><span class="s3">(</span><span class="s1">x</span><span class="s3">[</span><span class="s1">infs</span><span class="s3">])*</span><span class="s1">CONST_INF</span>
    <span class="s2">return </span><span class="s1">x</span>


<span class="s2">def </span><span class="s1">_convert_to_highs_enum</span><span class="s3">(</span><span class="s1">option</span><span class="s3">, </span><span class="s1">option_str</span><span class="s3">, </span><span class="s1">choices</span><span class="s3">):</span>
    <span class="s6"># If option is in the choices we can look it up, if not use</span>
    <span class="s6"># the default value taken from function signature and warn:</span>
    <span class="s2">try</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">choices</span><span class="s3">[</span><span class="s1">option</span><span class="s3">.</span><span class="s1">lower</span><span class="s3">()]</span>
    <span class="s2">except </span><span class="s1">AttributeError</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">choices</span><span class="s3">[</span><span class="s1">option</span><span class="s3">]</span>
    <span class="s2">except </span><span class="s1">KeyError</span><span class="s3">:</span>
        <span class="s1">sig </span><span class="s3">= </span><span class="s1">inspect</span><span class="s3">.</span><span class="s1">signature</span><span class="s3">(</span><span class="s1">_linprog_highs</span><span class="s3">)</span>
        <span class="s1">default_str </span><span class="s3">= </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">parameters</span><span class="s3">[</span><span class="s1">option_str</span><span class="s3">].</span><span class="s1">default</span>
        <span class="s1">warn</span><span class="s3">(</span><span class="s5">f&quot;Option </span><span class="s2">{</span><span class="s1">option_str</span><span class="s2">} </span><span class="s5">is </span><span class="s2">{</span><span class="s1">option</span><span class="s2">}</span><span class="s5">, but only values in &quot;</span>
             <span class="s5">f&quot;</span><span class="s2">{</span><span class="s1">set</span><span class="s3">(</span><span class="s1">choices</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">())</span><span class="s2">} </span><span class="s5">are allowed. Using default: &quot;</span>
             <span class="s5">f&quot;</span><span class="s2">{</span><span class="s1">default_str</span><span class="s2">}</span><span class="s5">.&quot;</span><span class="s3">,</span>
             <span class="s1">OptimizeWarning</span><span class="s3">, </span><span class="s1">stacklevel</span><span class="s3">=</span><span class="s4">3</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">choices</span><span class="s3">[</span><span class="s1">default_str</span><span class="s3">]</span>


<span class="s2">def </span><span class="s1">_linprog_highs</span><span class="s3">(</span><span class="s1">lp</span><span class="s3">, </span><span class="s1">solver</span><span class="s3">, </span><span class="s1">time_limit</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">presolve</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
                   <span class="s1">disp</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">maxiter</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
                   <span class="s1">dual_feasibility_tolerance</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
                   <span class="s1">primal_feasibility_tolerance</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
                   <span class="s1">ipm_optimality_tolerance</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
                   <span class="s1">simplex_dual_edge_weight_strategy</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
                   <span class="s1">mip_rel_gap</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
                   <span class="s1">mip_max_nodes</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
                   <span class="s3">**</span><span class="s1">unknown_options</span><span class="s3">):</span>
    <span class="s0">r&quot;&quot;&quot; 
    Solve the following linear programming problem using one of the HiGHS 
    solvers: 
 
    User-facing documentation is in _linprog_doc.py. 
 
    Parameters 
    ---------- 
    lp :  _LPProblem 
        A ``scipy.optimize._linprog_util._LPProblem`` ``namedtuple``. 
    solver : &quot;ipm&quot; or &quot;simplex&quot; or None 
        Which HiGHS solver to use.  If ``None``, &quot;simplex&quot; will be used. 
 
    Options 
    ------- 
    maxiter : int 
        The maximum number of iterations to perform in either phase. For 
        ``solver='ipm'``, this does not include the number of crossover 
        iterations.  Default is the largest possible value for an ``int`` 
        on the platform. 
    disp : bool 
        Set to ``True`` if indicators of optimization status are to be printed 
        to the console each iteration; default ``False``. 
    time_limit : float 
        The maximum time in seconds allotted to solve the problem; default is 
        the largest possible value for a ``double`` on the platform. 
    presolve : bool 
        Presolve attempts to identify trivial infeasibilities, 
        identify trivial unboundedness, and simplify the problem before 
        sending it to the main solver. It is generally recommended 
        to keep the default setting ``True``; set to ``False`` if presolve is 
        to be disabled. 
    dual_feasibility_tolerance : double 
        Dual feasibility tolerance.  Default is 1e-07. 
        The minimum of this and ``primal_feasibility_tolerance`` 
        is used for the feasibility tolerance when ``solver='ipm'``. 
    primal_feasibility_tolerance : double 
        Primal feasibility tolerance.  Default is 1e-07. 
        The minimum of this and ``dual_feasibility_tolerance`` 
        is used for the feasibility tolerance when ``solver='ipm'``. 
    ipm_optimality_tolerance : double 
        Optimality tolerance for ``solver='ipm'``.  Default is 1e-08. 
        Minimum possible value is 1e-12 and must be smaller than the largest 
        possible value for a ``double`` on the platform. 
    simplex_dual_edge_weight_strategy : str (default: None) 
        Strategy for simplex dual edge weights. The default, ``None``, 
        automatically selects one of the following. 
 
        ``'dantzig'`` uses Dantzig's original strategy of choosing the most 
        negative reduced cost. 
 
        ``'devex'`` uses the strategy described in [15]_. 
 
        ``steepest`` uses the exact steepest edge strategy as described in 
        [16]_. 
 
        ``'steepest-devex'`` begins with the exact steepest edge strategy 
        until the computation is too costly or inexact and then switches to 
        the devex method. 
 
        Currently, using ``None`` always selects ``'steepest-devex'``, but this 
        may change as new options become available. 
 
    mip_max_nodes : int 
        The maximum number of nodes allotted to solve the problem; default is 
        the largest possible value for a ``HighsInt`` on the platform. 
        Ignored if not using the MIP solver. 
    unknown_options : dict 
        Optional arguments not used by this particular solver. If 
        ``unknown_options`` is non-empty, a warning is issued listing all 
        unused options. 
 
    Returns 
    ------- 
    sol : dict 
        A dictionary consisting of the fields: 
 
            x : 1D array 
                The values of the decision variables that minimizes the 
                objective function while satisfying the constraints. 
            fun : float 
                The optimal value of the objective function ``c @ x``. 
            slack : 1D array 
                The (nominally positive) values of the slack, 
                ``b_ub - A_ub @ x``. 
            con : 1D array 
                The (nominally zero) residuals of the equality constraints, 
                ``b_eq - A_eq @ x``. 
            success : bool 
                ``True`` when the algorithm succeeds in finding an optimal 
                solution. 
            status : int 
                An integer representing the exit status of the algorithm. 
 
                ``0`` : Optimization terminated successfully. 
 
                ``1`` : Iteration or time limit reached. 
 
                ``2`` : Problem appears to be infeasible. 
 
                ``3`` : Problem appears to be unbounded. 
 
                ``4`` : The HiGHS solver ran into a problem. 
 
            message : str 
                A string descriptor of the exit status of the algorithm. 
            nit : int 
                The total number of iterations performed. 
                For ``solver='simplex'``, this includes iterations in all 
                phases. For ``solver='ipm'``, this does not include 
                crossover iterations. 
            crossover_nit : int 
                The number of primal/dual pushes performed during the 
                crossover routine for ``solver='ipm'``.  This is ``0`` 
                for ``solver='simplex'``. 
            ineqlin : OptimizeResult 
                Solution and sensitivity information corresponding to the 
                inequality constraints, `b_ub`. A dictionary consisting of the 
                fields: 
 
                residual : np.ndnarray 
                    The (nominally positive) values of the slack variables, 
                    ``b_ub - A_ub @ x``.  This quantity is also commonly 
                    referred to as &quot;slack&quot;. 
 
                marginals : np.ndarray 
                    The sensitivity (partial derivative) of the objective 
                    function with respect to the right-hand side of the 
                    inequality constraints, `b_ub`. 
 
            eqlin : OptimizeResult 
                Solution and sensitivity information corresponding to the 
                equality constraints, `b_eq`.  A dictionary consisting of the 
                fields: 
 
                residual : np.ndarray 
                    The (nominally zero) residuals of the equality constraints, 
                    ``b_eq - A_eq @ x``. 
 
                marginals : np.ndarray 
                    The sensitivity (partial derivative) of the objective 
                    function with respect to the right-hand side of the 
                    equality constraints, `b_eq`. 
 
            lower, upper : OptimizeResult 
                Solution and sensitivity information corresponding to the 
                lower and upper bounds on decision variables, `bounds`. 
 
                residual : np.ndarray 
                    The (nominally positive) values of the quantity 
                    ``x - lb`` (lower) or ``ub - x`` (upper). 
 
                marginals : np.ndarray 
                    The sensitivity (partial derivative) of the objective 
                    function with respect to the lower and upper 
                    `bounds`. 
 
            mip_node_count : int 
                The number of subproblems or &quot;nodes&quot; solved by the MILP 
                solver. Only present when `integrality` is not `None`. 
 
            mip_dual_bound : float 
                The MILP solver's final estimate of the lower bound on the 
                optimal solution. Only present when `integrality` is not 
                `None`. 
 
            mip_gap : float 
                The difference between the final objective function value 
                and the final dual bound, scaled by the final objective 
                function value. Only present when `integrality` is not 
                `None`. 
 
    Notes 
    ----- 
    The result fields `ineqlin`, `eqlin`, `lower`, and `upper` all contain 
    `marginals`, or partial derivatives of the objective function with respect 
    to the right-hand side of each constraint. These partial derivatives are 
    also referred to as &quot;Lagrange multipliers&quot;, &quot;dual values&quot;, and 
    &quot;shadow prices&quot;. The sign convention of `marginals` is opposite that 
    of Lagrange multipliers produced by many nonlinear solvers. 
 
    References 
    ---------- 
    .. [15] Harris, Paula MJ. &quot;Pivot selection methods of the Devex LP code.&quot; 
            Mathematical programming 5.1 (1973): 1-28. 
    .. [16] Goldfarb, Donald, and John Ker Reid. &quot;A practicable steepest-edge 
            simplex algorithm.&quot; Mathematical Programming 12.1 (1977): 361-371. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">unknown_options</span><span class="s3">:</span>
        <span class="s1">message </span><span class="s3">= (</span><span class="s5">f&quot;Unrecognized options detected: </span><span class="s2">{</span><span class="s1">unknown_options</span><span class="s2">}</span><span class="s5">. &quot;</span>
                   <span class="s5">&quot;These will be passed to HiGHS verbatim.&quot;</span><span class="s3">)</span>
        <span class="s1">warn</span><span class="s3">(</span><span class="s1">message</span><span class="s3">, </span><span class="s1">OptimizeWarning</span><span class="s3">, </span><span class="s1">stacklevel</span><span class="s3">=</span><span class="s4">3</span><span class="s3">)</span>

    <span class="s6"># Map options to HiGHS enum values</span>
    <span class="s1">simplex_dual_edge_weight_strategy_enum </span><span class="s3">= </span><span class="s1">_convert_to_highs_enum</span><span class="s3">(</span>
        <span class="s1">simplex_dual_edge_weight_strategy</span><span class="s3">,</span>
        <span class="s5">'simplex_dual_edge_weight_strategy'</span><span class="s3">,</span>
        <span class="s1">choices</span><span class="s3">={</span><span class="s5">'dantzig'</span><span class="s3">: </span><span class="s1">HIGHS_SIMPLEX_EDGE_WEIGHT_STRATEGY_DANTZIG</span><span class="s3">,</span>
                 <span class="s5">'devex'</span><span class="s3">: </span><span class="s1">HIGHS_SIMPLEX_EDGE_WEIGHT_STRATEGY_DEVEX</span><span class="s3">,</span>
                 <span class="s5">'steepest-devex'</span><span class="s3">: </span><span class="s1">HIGHS_SIMPLEX_EDGE_WEIGHT_STRATEGY_CHOOSE</span><span class="s3">,</span>
                 <span class="s5">'steepest'</span><span class="s3">:</span>
                 <span class="s1">HIGHS_SIMPLEX_EDGE_WEIGHT_STRATEGY_STEEPEST_EDGE</span><span class="s3">,</span>
                 <span class="s2">None</span><span class="s3">: </span><span class="s2">None</span><span class="s3">})</span>

    <span class="s1">c</span><span class="s3">, </span><span class="s1">A_ub</span><span class="s3">, </span><span class="s1">b_ub</span><span class="s3">, </span><span class="s1">A_eq</span><span class="s3">, </span><span class="s1">b_eq</span><span class="s3">, </span><span class="s1">bounds</span><span class="s3">, </span><span class="s1">x0</span><span class="s3">, </span><span class="s1">integrality </span><span class="s3">= </span><span class="s1">lp</span>

    <span class="s1">lb</span><span class="s3">, </span><span class="s1">ub </span><span class="s3">= </span><span class="s1">bounds</span><span class="s3">.</span><span class="s1">T</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()  </span><span class="s6"># separate bounds, copy-&gt;C-cntgs</span>
    <span class="s6"># highs_wrapper solves LHS &lt;= A*x &lt;= RHS, not equality constraints</span>
    <span class="s2">with </span><span class="s1">np</span><span class="s3">.</span><span class="s1">errstate</span><span class="s3">(</span><span class="s1">invalid</span><span class="s3">=</span><span class="s5">&quot;ignore&quot;</span><span class="s3">):</span>
        <span class="s1">lhs_ub </span><span class="s3">= -</span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones_like</span><span class="s3">(</span><span class="s1">b_ub</span><span class="s3">)*</span><span class="s1">np</span><span class="s3">.</span><span class="s1">inf  </span><span class="s6"># LHS of UB constraints is -inf</span>
    <span class="s1">rhs_ub </span><span class="s3">= </span><span class="s1">b_ub  </span><span class="s6"># RHS of UB constraints is b_ub</span>
    <span class="s1">lhs_eq </span><span class="s3">= </span><span class="s1">b_eq  </span><span class="s6"># Equality constraint is inequality</span>
    <span class="s1">rhs_eq </span><span class="s3">= </span><span class="s1">b_eq  </span><span class="s6"># constraint with LHS=RHS</span>
    <span class="s1">lhs </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">concatenate</span><span class="s3">((</span><span class="s1">lhs_ub</span><span class="s3">, </span><span class="s1">lhs_eq</span><span class="s3">))</span>
    <span class="s1">rhs </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">concatenate</span><span class="s3">((</span><span class="s1">rhs_ub</span><span class="s3">, </span><span class="s1">rhs_eq</span><span class="s3">))</span>

    <span class="s2">if </span><span class="s1">issparse</span><span class="s3">(</span><span class="s1">A_ub</span><span class="s3">) </span><span class="s2">or </span><span class="s1">issparse</span><span class="s3">(</span><span class="s1">A_eq</span><span class="s3">):</span>
        <span class="s1">A </span><span class="s3">= </span><span class="s1">vstack</span><span class="s3">((</span><span class="s1">A_ub</span><span class="s3">, </span><span class="s1">A_eq</span><span class="s3">))</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">A </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">vstack</span><span class="s3">((</span><span class="s1">A_ub</span><span class="s3">, </span><span class="s1">A_eq</span><span class="s3">))</span>
    <span class="s1">A </span><span class="s3">= </span><span class="s1">csc_matrix</span><span class="s3">(</span><span class="s1">A</span><span class="s3">)</span>

    <span class="s1">options </span><span class="s3">= {</span>
        <span class="s5">'presolve'</span><span class="s3">: </span><span class="s1">presolve</span><span class="s3">,</span>
        <span class="s5">'sense'</span><span class="s3">: </span><span class="s1">HIGHS_OBJECTIVE_SENSE_MINIMIZE</span><span class="s3">,</span>
        <span class="s5">'solver'</span><span class="s3">: </span><span class="s1">solver</span><span class="s3">,</span>
        <span class="s5">'time_limit'</span><span class="s3">: </span><span class="s1">time_limit</span><span class="s3">,</span>
        <span class="s5">'highs_debug_level'</span><span class="s3">: </span><span class="s1">MESSAGE_LEVEL_NONE</span><span class="s3">,</span>
        <span class="s5">'dual_feasibility_tolerance'</span><span class="s3">: </span><span class="s1">dual_feasibility_tolerance</span><span class="s3">,</span>
        <span class="s5">'ipm_optimality_tolerance'</span><span class="s3">: </span><span class="s1">ipm_optimality_tolerance</span><span class="s3">,</span>
        <span class="s5">'log_to_console'</span><span class="s3">: </span><span class="s1">disp</span><span class="s3">,</span>
        <span class="s5">'mip_max_nodes'</span><span class="s3">: </span><span class="s1">mip_max_nodes</span><span class="s3">,</span>
        <span class="s5">'output_flag'</span><span class="s3">: </span><span class="s1">disp</span><span class="s3">,</span>
        <span class="s5">'primal_feasibility_tolerance'</span><span class="s3">: </span><span class="s1">primal_feasibility_tolerance</span><span class="s3">,</span>
        <span class="s5">'simplex_dual_edge_weight_strategy'</span><span class="s3">:</span>
            <span class="s1">simplex_dual_edge_weight_strategy_enum</span><span class="s3">,</span>
        <span class="s5">'simplex_strategy'</span><span class="s3">: </span><span class="s1">HIGHS_SIMPLEX_STRATEGY_DUAL</span><span class="s3">,</span>
        <span class="s5">'simplex_crash_strategy'</span><span class="s3">: </span><span class="s1">HIGHS_SIMPLEX_CRASH_STRATEGY_OFF</span><span class="s3">,</span>
        <span class="s5">'ipm_iteration_limit'</span><span class="s3">: </span><span class="s1">maxiter</span><span class="s3">,</span>
        <span class="s5">'simplex_iteration_limit'</span><span class="s3">: </span><span class="s1">maxiter</span><span class="s3">,</span>
        <span class="s5">'mip_rel_gap'</span><span class="s3">: </span><span class="s1">mip_rel_gap</span><span class="s3">,</span>
    <span class="s3">}</span>
    <span class="s1">options</span><span class="s3">.</span><span class="s1">update</span><span class="s3">(</span><span class="s1">unknown_options</span><span class="s3">)</span>

    <span class="s6"># np.inf doesn't work; use very large constant</span>
    <span class="s1">rhs </span><span class="s3">= </span><span class="s1">_replace_inf</span><span class="s3">(</span><span class="s1">rhs</span><span class="s3">)</span>
    <span class="s1">lhs </span><span class="s3">= </span><span class="s1">_replace_inf</span><span class="s3">(</span><span class="s1">lhs</span><span class="s3">)</span>
    <span class="s1">lb </span><span class="s3">= </span><span class="s1">_replace_inf</span><span class="s3">(</span><span class="s1">lb</span><span class="s3">)</span>
    <span class="s1">ub </span><span class="s3">= </span><span class="s1">_replace_inf</span><span class="s3">(</span><span class="s1">ub</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">integrality </span><span class="s2">is None or </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">(</span><span class="s1">integrality</span><span class="s3">) == </span><span class="s4">0</span><span class="s3">:</span>
        <span class="s1">integrality </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s4">0</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">integrality </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">integrality</span><span class="s3">)</span>

    <span class="s1">res </span><span class="s3">= </span><span class="s1">_highs_wrapper</span><span class="s3">(</span><span class="s1">c</span><span class="s3">, </span><span class="s1">A</span><span class="s3">.</span><span class="s1">indptr</span><span class="s3">, </span><span class="s1">A</span><span class="s3">.</span><span class="s1">indices</span><span class="s3">, </span><span class="s1">A</span><span class="s3">.</span><span class="s1">data</span><span class="s3">, </span><span class="s1">lhs</span><span class="s3">, </span><span class="s1">rhs</span><span class="s3">,</span>
                         <span class="s1">lb</span><span class="s3">, </span><span class="s1">ub</span><span class="s3">, </span><span class="s1">integrality</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">uint8</span><span class="s3">), </span><span class="s1">options</span><span class="s3">)</span>

    <span class="s6"># HiGHS represents constraints as lhs/rhs, so</span>
    <span class="s6"># Ax + s = b =&gt; Ax = b - s</span>
    <span class="s6"># and we need to split up s by A_ub and A_eq</span>
    <span class="s2">if </span><span class="s5">'slack' </span><span class="s2">in </span><span class="s1">res</span><span class="s3">:</span>
        <span class="s1">slack </span><span class="s3">= </span><span class="s1">res</span><span class="s3">[</span><span class="s5">'slack'</span><span class="s3">]</span>
        <span class="s1">con </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">slack</span><span class="s3">[</span><span class="s1">len</span><span class="s3">(</span><span class="s1">b_ub</span><span class="s3">):])</span>
        <span class="s1">slack </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">slack</span><span class="s3">[:</span><span class="s1">len</span><span class="s3">(</span><span class="s1">b_ub</span><span class="s3">)])</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">slack</span><span class="s3">, </span><span class="s1">con </span><span class="s3">= </span><span class="s2">None</span><span class="s3">, </span><span class="s2">None</span>

    <span class="s6"># lagrange multipliers for equalities/inequalities and upper/lower bounds</span>
    <span class="s2">if </span><span class="s5">'lambda' </span><span class="s2">in </span><span class="s1">res</span><span class="s3">:</span>
        <span class="s1">lamda </span><span class="s3">= </span><span class="s1">res</span><span class="s3">[</span><span class="s5">'lambda'</span><span class="s3">]</span>
        <span class="s1">marg_ineqlin </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">lamda</span><span class="s3">[:</span><span class="s1">len</span><span class="s3">(</span><span class="s1">b_ub</span><span class="s3">)])</span>
        <span class="s1">marg_eqlin </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">lamda</span><span class="s3">[</span><span class="s1">len</span><span class="s3">(</span><span class="s1">b_ub</span><span class="s3">):])</span>
        <span class="s1">marg_upper </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">res</span><span class="s3">[</span><span class="s5">'marg_bnds'</span><span class="s3">][</span><span class="s4">1</span><span class="s3">, :])</span>
        <span class="s1">marg_lower </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">res</span><span class="s3">[</span><span class="s5">'marg_bnds'</span><span class="s3">][</span><span class="s4">0</span><span class="s3">, :])</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">marg_ineqlin</span><span class="s3">, </span><span class="s1">marg_eqlin </span><span class="s3">= </span><span class="s2">None</span><span class="s3">, </span><span class="s2">None</span>
        <span class="s1">marg_upper</span><span class="s3">, </span><span class="s1">marg_lower </span><span class="s3">= </span><span class="s2">None</span><span class="s3">, </span><span class="s2">None</span>

    <span class="s6"># this needs to be updated if we start choosing the solver intelligently</span>

    <span class="s6"># Convert to scipy-style status and message</span>
    <span class="s1">highs_status </span><span class="s3">= </span><span class="s1">res</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s5">'status'</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
    <span class="s1">highs_message </span><span class="s3">= </span><span class="s1">res</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s5">'message'</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
    <span class="s1">status</span><span class="s3">, </span><span class="s1">message </span><span class="s3">= </span><span class="s1">_highs_to_scipy_status_message</span><span class="s3">(</span><span class="s1">highs_status</span><span class="s3">,</span>
                                                     <span class="s1">highs_message</span><span class="s3">)</span>

    <span class="s1">x </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">res</span><span class="s3">[</span><span class="s5">'x'</span><span class="s3">]) </span><span class="s2">if </span><span class="s5">'x' </span><span class="s2">in </span><span class="s1">res </span><span class="s2">else None</span>
    <span class="s1">sol </span><span class="s3">= {</span><span class="s5">'x'</span><span class="s3">: </span><span class="s1">x</span><span class="s3">,</span>
           <span class="s5">'slack'</span><span class="s3">: </span><span class="s1">slack</span><span class="s3">,</span>
           <span class="s5">'con'</span><span class="s3">: </span><span class="s1">con</span><span class="s3">,</span>
           <span class="s5">'ineqlin'</span><span class="s3">: </span><span class="s1">OptimizeResult</span><span class="s3">({</span>
               <span class="s5">'residual'</span><span class="s3">: </span><span class="s1">slack</span><span class="s3">,</span>
               <span class="s5">'marginals'</span><span class="s3">: </span><span class="s1">marg_ineqlin</span><span class="s3">,</span>
           <span class="s3">}),</span>
           <span class="s5">'eqlin'</span><span class="s3">: </span><span class="s1">OptimizeResult</span><span class="s3">({</span>
               <span class="s5">'residual'</span><span class="s3">: </span><span class="s1">con</span><span class="s3">,</span>
               <span class="s5">'marginals'</span><span class="s3">: </span><span class="s1">marg_eqlin</span><span class="s3">,</span>
           <span class="s3">}),</span>
           <span class="s5">'lower'</span><span class="s3">: </span><span class="s1">OptimizeResult</span><span class="s3">({</span>
               <span class="s5">'residual'</span><span class="s3">: </span><span class="s2">None if </span><span class="s1">x </span><span class="s2">is None else </span><span class="s1">x </span><span class="s3">- </span><span class="s1">lb</span><span class="s3">,</span>
               <span class="s5">'marginals'</span><span class="s3">: </span><span class="s1">marg_lower</span><span class="s3">,</span>
           <span class="s3">}),</span>
           <span class="s5">'upper'</span><span class="s3">: </span><span class="s1">OptimizeResult</span><span class="s3">({</span>
               <span class="s5">'residual'</span><span class="s3">: </span><span class="s2">None if </span><span class="s1">x </span><span class="s2">is None else </span><span class="s1">ub </span><span class="s3">- </span><span class="s1">x</span><span class="s3">,</span>
               <span class="s5">'marginals'</span><span class="s3">: </span><span class="s1">marg_upper</span>
            <span class="s3">}),</span>
           <span class="s5">'fun'</span><span class="s3">: </span><span class="s1">res</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s5">'fun'</span><span class="s3">),</span>
           <span class="s5">'status'</span><span class="s3">: </span><span class="s1">status</span><span class="s3">,</span>
           <span class="s5">'success'</span><span class="s3">: </span><span class="s1">res</span><span class="s3">[</span><span class="s5">'status'</span><span class="s3">] == </span><span class="s1">MODEL_STATUS_OPTIMAL</span><span class="s3">,</span>
           <span class="s5">'message'</span><span class="s3">: </span><span class="s1">message</span><span class="s3">,</span>
           <span class="s5">'nit'</span><span class="s3">: </span><span class="s1">res</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s5">'simplex_nit'</span><span class="s3">, </span><span class="s4">0</span><span class="s3">) </span><span class="s2">or </span><span class="s1">res</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s5">'ipm_nit'</span><span class="s3">, </span><span class="s4">0</span><span class="s3">),</span>
           <span class="s5">'crossover_nit'</span><span class="s3">: </span><span class="s1">res</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s5">'crossover_nit'</span><span class="s3">),</span>
           <span class="s3">}</span>

    <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">any</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) </span><span class="s2">and </span><span class="s1">integrality </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s1">sol</span><span class="s3">.</span><span class="s1">update</span><span class="s3">({</span>
            <span class="s5">'mip_node_count'</span><span class="s3">: </span><span class="s1">res</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s5">'mip_node_count'</span><span class="s3">, </span><span class="s4">0</span><span class="s3">),</span>
            <span class="s5">'mip_dual_bound'</span><span class="s3">: </span><span class="s1">res</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s5">'mip_dual_bound'</span><span class="s3">, </span><span class="s4">0.0</span><span class="s3">),</span>
            <span class="s5">'mip_gap'</span><span class="s3">: </span><span class="s1">res</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s5">'mip_gap'</span><span class="s3">, </span><span class="s4">0.0</span><span class="s3">),</span>
        <span class="s3">})</span>

    <span class="s2">return </span><span class="s1">sol</span>
</pre>
</body>
</html>