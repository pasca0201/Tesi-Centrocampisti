<html>
<head>
<title>_arffread.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #6aab73;}
.s4 { color: #bcbec4;}
.s5 { color: #5f826b; font-style: italic;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_arffread.py</font>
</center></td></tr></table>
<pre><span class="s0"># Last Change: Mon Aug 20 08:00 PM 2007 J</span>
<span class="s2">import </span><span class="s1">re</span>
<span class="s2">import </span><span class="s1">datetime</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>

<span class="s2">import </span><span class="s1">csv</span>
<span class="s2">import </span><span class="s1">ctypes</span>

<span class="s3">&quot;&quot;&quot;A module to read arff files.&quot;&quot;&quot;</span>

<span class="s1">__all__ </span><span class="s4">= [</span><span class="s3">'MetaData'</span><span class="s4">, </span><span class="s3">'loadarff'</span><span class="s4">, </span><span class="s3">'ArffError'</span><span class="s4">, </span><span class="s3">'ParseArffError'</span><span class="s4">]</span>

<span class="s0"># An Arff file is basically two parts:</span>
<span class="s0">#   - header</span>
<span class="s0">#   - data</span>
<span class="s0">#</span>
<span class="s0"># A header has each of its components starting by @META where META is one of</span>
<span class="s0"># the keyword (attribute of relation, for now).</span>

<span class="s0"># TODO:</span>
<span class="s0">#   - both integer and reals are treated as numeric -&gt; the integer info</span>
<span class="s0">#    is lost!</span>
<span class="s0">#   - Replace ValueError by ParseError or something</span>

<span class="s0"># We know can handle the following:</span>
<span class="s0">#   - numeric and nominal attributes</span>
<span class="s0">#   - missing values for numeric attributes</span>

<span class="s1">r_meta </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span><span class="s3">r'^\s*@'</span><span class="s4">)</span>
<span class="s0"># Match a comment</span>
<span class="s1">r_comment </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span><span class="s3">r'^%'</span><span class="s4">)</span>
<span class="s0"># Match an empty line</span>
<span class="s1">r_empty </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span><span class="s3">r'^\s+$'</span><span class="s4">)</span>
<span class="s0"># Match a header line, that is a line which starts by @ + a word</span>
<span class="s1">r_headerline </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span><span class="s3">r'^\s*@\S*'</span><span class="s4">)</span>
<span class="s1">r_datameta </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span><span class="s3">r'^@[Dd][Aa][Tt][Aa]'</span><span class="s4">)</span>
<span class="s1">r_relation </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span><span class="s3">r'^@[Rr][Ee][Ll][Aa][Tt][Ii][Oo][Nn]\s*(\S*)'</span><span class="s4">)</span>
<span class="s1">r_attribute </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span><span class="s3">r'^\s*@[Aa][Tt][Tt][Rr][Ii][Bb][Uu][Tt][Ee]\s*(..*$)'</span><span class="s4">)</span>

<span class="s1">r_nominal </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span><span class="s3">r'{(.+)}'</span><span class="s4">)</span>
<span class="s1">r_date </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span><span class="s3">r&quot;[Dd][Aa][Tt][Ee]\s+[\&quot;']?(.+?)[\&quot;']?$&quot;</span><span class="s4">)</span>

<span class="s0"># To get attributes name enclosed with ''</span>
<span class="s1">r_comattrval </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span><span class="s3">r&quot;'(..+)'\s+(..+$)&quot;</span><span class="s4">)</span>
<span class="s0"># To get normal attributes</span>
<span class="s1">r_wcomattrval </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span><span class="s3">r&quot;(\S+)\s+(..+$)&quot;</span><span class="s4">)</span>

<span class="s0"># ------------------------</span>
<span class="s0"># Module defined exception</span>
<span class="s0"># ------------------------</span>


<span class="s2">class </span><span class="s1">ArffError</span><span class="s4">(</span><span class="s1">OSError</span><span class="s4">):</span>
    <span class="s2">pass</span>


<span class="s2">class </span><span class="s1">ParseArffError</span><span class="s4">(</span><span class="s1">ArffError</span><span class="s4">):</span>
    <span class="s2">pass</span>


<span class="s0"># ----------</span>
<span class="s0"># Attributes</span>
<span class="s0"># ----------</span>
<span class="s2">class </span><span class="s1">Attribute</span><span class="s4">:</span>

    <span class="s1">type_name </span><span class="s4">= </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">name</span><span class="s4">):</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">name </span><span class="s4">= </span><span class="s1">name</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">range </span><span class="s4">= </span><span class="s2">None</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">dtype </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">object_</span>

    <span class="s4">@</span><span class="s1">classmethod</span>
    <span class="s2">def </span><span class="s1">parse_attribute</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">, </span><span class="s1">name</span><span class="s4">, </span><span class="s1">attr_string</span><span class="s4">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Parse the attribute line if it knows how. Returns the parsed 
        attribute, or None. 
        &quot;&quot;&quot;</span>
        <span class="s2">return None</span>

    <span class="s2">def </span><span class="s1">parse_data</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">data_str</span><span class="s4">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Parse a value of this type. 
        &quot;&quot;&quot;</span>
        <span class="s2">return None</span>

    <span class="s2">def </span><span class="s1">__str__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Parse a value of this type. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">name </span><span class="s4">+ </span><span class="s3">',' </span><span class="s4">+ </span><span class="s1">self</span><span class="s4">.</span><span class="s1">type_name</span>


<span class="s2">class </span><span class="s1">NominalAttribute</span><span class="s4">(</span><span class="s1">Attribute</span><span class="s4">):</span>

    <span class="s1">type_name </span><span class="s4">= </span><span class="s3">'nominal'</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">name</span><span class="s4">, </span><span class="s1">values</span><span class="s4">):</span>
        <span class="s1">super</span><span class="s4">().</span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">name</span><span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">values </span><span class="s4">= </span><span class="s1">values</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">range </span><span class="s4">= </span><span class="s1">values</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">dtype </span><span class="s4">= (</span><span class="s1">np</span><span class="s4">.</span><span class="s1">bytes_</span><span class="s4">, </span><span class="s1">max</span><span class="s4">(</span><span class="s1">len</span><span class="s4">(</span><span class="s1">i</span><span class="s4">) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">values</span><span class="s4">))</span>

    <span class="s4">@</span><span class="s1">staticmethod</span>
    <span class="s2">def </span><span class="s1">_get_nom_val</span><span class="s4">(</span><span class="s1">atrv</span><span class="s4">):</span>
        <span class="s5">&quot;&quot;&quot;Given a string containing a nominal type, returns a tuple of the 
        possible values. 
 
        A nominal type is defined as something framed between braces ({}). 
 
        Parameters 
        ---------- 
        atrv : str 
           Nominal type definition 
 
        Returns 
        ------- 
        poss_vals : tuple 
           possible values 
 
        Examples 
        -------- 
        &gt;&gt;&gt; from scipy.io.arff._arffread import NominalAttribute 
        &gt;&gt;&gt; NominalAttribute._get_nom_val(&quot;{floup, bouga, fl, ratata}&quot;) 
        ('floup', 'bouga', 'fl', 'ratata') 
        &quot;&quot;&quot;</span>
        <span class="s1">m </span><span class="s4">= </span><span class="s1">r_nominal</span><span class="s4">.</span><span class="s1">match</span><span class="s4">(</span><span class="s1">atrv</span><span class="s4">)</span>
        <span class="s2">if </span><span class="s1">m</span><span class="s4">:</span>
            <span class="s1">attrs</span><span class="s4">, </span><span class="s1">_ </span><span class="s4">= </span><span class="s1">split_data_line</span><span class="s4">(</span><span class="s1">m</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">1</span><span class="s4">))</span>
            <span class="s2">return </span><span class="s1">tuple</span><span class="s4">(</span><span class="s1">attrs</span><span class="s4">)</span>
        <span class="s2">else</span><span class="s4">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s3">&quot;This does not look like a nominal string&quot;</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">classmethod</span>
    <span class="s2">def </span><span class="s1">parse_attribute</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">, </span><span class="s1">name</span><span class="s4">, </span><span class="s1">attr_string</span><span class="s4">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Parse the attribute line if it knows how. Returns the parsed 
        attribute, or None. 
 
        For nominal attributes, the attribute string would be like '{&lt;attr_1&gt;, 
         &lt;attr2&gt;, &lt;attr_3&gt;}'. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">attr_string</span><span class="s4">[</span><span class="s6">0</span><span class="s4">] == </span><span class="s3">'{'</span><span class="s4">:</span>
            <span class="s1">values </span><span class="s4">= </span><span class="s1">cls</span><span class="s4">.</span><span class="s1">_get_nom_val</span><span class="s4">(</span><span class="s1">attr_string</span><span class="s4">)</span>
            <span class="s2">return </span><span class="s1">cls</span><span class="s4">(</span><span class="s1">name</span><span class="s4">, </span><span class="s1">values</span><span class="s4">)</span>
        <span class="s2">else</span><span class="s4">:</span>
            <span class="s2">return None</span>

    <span class="s2">def </span><span class="s1">parse_data</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">data_str</span><span class="s4">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Parse a value of this type. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">data_str </span><span class="s2">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">values</span><span class="s4">:</span>
            <span class="s2">return </span><span class="s1">data_str</span>
        <span class="s2">elif </span><span class="s1">data_str </span><span class="s4">== </span><span class="s3">'?'</span><span class="s4">:</span>
            <span class="s2">return </span><span class="s1">data_str</span>
        <span class="s2">else</span><span class="s4">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">str</span><span class="s4">(</span><span class="s1">data_str</span><span class="s4">)</span><span class="s2">} </span><span class="s3">value not in </span><span class="s2">{</span><span class="s1">str</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">values</span><span class="s4">)</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s4">)</span>

    <span class="s2">def </span><span class="s1">__str__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s1">msg </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">name </span><span class="s4">+ </span><span class="s3">&quot;,{&quot;</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s4">(</span><span class="s1">len</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">values</span><span class="s4">)-</span><span class="s6">1</span><span class="s4">):</span>
            <span class="s1">msg </span><span class="s4">+= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">values</span><span class="s4">[</span><span class="s1">i</span><span class="s4">] + </span><span class="s3">&quot;,&quot;</span>
        <span class="s1">msg </span><span class="s4">+= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">values</span><span class="s4">[-</span><span class="s6">1</span><span class="s4">]</span>
        <span class="s1">msg </span><span class="s4">+= </span><span class="s3">&quot;}&quot;</span>
        <span class="s2">return </span><span class="s1">msg</span>


<span class="s2">class </span><span class="s1">NumericAttribute</span><span class="s4">(</span><span class="s1">Attribute</span><span class="s4">):</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">name</span><span class="s4">):</span>
        <span class="s1">super</span><span class="s4">().</span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">name</span><span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">type_name </span><span class="s4">= </span><span class="s3">'numeric'</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">dtype </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">float64</span>

    <span class="s4">@</span><span class="s1">classmethod</span>
    <span class="s2">def </span><span class="s1">parse_attribute</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">, </span><span class="s1">name</span><span class="s4">, </span><span class="s1">attr_string</span><span class="s4">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Parse the attribute line if it knows how. Returns the parsed 
        attribute, or None. 
 
        For numeric attributes, the attribute string would be like 
        'numeric' or 'int' or 'real'. 
        &quot;&quot;&quot;</span>

        <span class="s1">attr_string </span><span class="s4">= </span><span class="s1">attr_string</span><span class="s4">.</span><span class="s1">lower</span><span class="s4">().</span><span class="s1">strip</span><span class="s4">()</span>

        <span class="s2">if </span><span class="s4">(</span><span class="s1">attr_string</span><span class="s4">[:</span><span class="s1">len</span><span class="s4">(</span><span class="s3">'numeric'</span><span class="s4">)] == </span><span class="s3">'numeric' </span><span class="s2">or</span>
           <span class="s1">attr_string</span><span class="s4">[:</span><span class="s1">len</span><span class="s4">(</span><span class="s3">'int'</span><span class="s4">)] == </span><span class="s3">'int' </span><span class="s2">or</span>
           <span class="s1">attr_string</span><span class="s4">[:</span><span class="s1">len</span><span class="s4">(</span><span class="s3">'real'</span><span class="s4">)] == </span><span class="s3">'real'</span><span class="s4">):</span>
            <span class="s2">return </span><span class="s1">cls</span><span class="s4">(</span><span class="s1">name</span><span class="s4">)</span>
        <span class="s2">else</span><span class="s4">:</span>
            <span class="s2">return None</span>

    <span class="s2">def </span><span class="s1">parse_data</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">data_str</span><span class="s4">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Parse a value of this type. 
 
        Parameters 
        ---------- 
        data_str : str 
           string to convert 
 
        Returns 
        ------- 
        f : float 
           where float can be nan 
 
        Examples 
        -------- 
        &gt;&gt;&gt; from scipy.io.arff._arffread import NumericAttribute 
        &gt;&gt;&gt; atr = NumericAttribute('atr') 
        &gt;&gt;&gt; atr.parse_data('1') 
        1.0 
        &gt;&gt;&gt; atr.parse_data('1\\n') 
        1.0 
        &gt;&gt;&gt; atr.parse_data('?\\n') 
        nan 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s3">'?' </span><span class="s2">in </span><span class="s1">data_str</span><span class="s4">:</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s4">.</span><span class="s1">nan</span>
        <span class="s2">else</span><span class="s4">:</span>
            <span class="s2">return </span><span class="s1">float</span><span class="s4">(</span><span class="s1">data_str</span><span class="s4">)</span>

    <span class="s2">def </span><span class="s1">_basic_stats</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">data</span><span class="s4">):</span>
        <span class="s1">nbfac </span><span class="s4">= </span><span class="s1">data</span><span class="s4">.</span><span class="s1">size </span><span class="s4">* </span><span class="s6">1. </span><span class="s4">/ (</span><span class="s1">data</span><span class="s4">.</span><span class="s1">size </span><span class="s4">- </span><span class="s6">1</span><span class="s4">)</span>
        <span class="s2">return </span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">nanmin</span><span class="s4">(</span><span class="s1">data</span><span class="s4">), </span><span class="s1">np</span><span class="s4">.</span><span class="s1">nanmax</span><span class="s4">(</span><span class="s1">data</span><span class="s4">),</span>
                <span class="s1">np</span><span class="s4">.</span><span class="s1">mean</span><span class="s4">(</span><span class="s1">data</span><span class="s4">), </span><span class="s1">np</span><span class="s4">.</span><span class="s1">std</span><span class="s4">(</span><span class="s1">data</span><span class="s4">) * </span><span class="s1">nbfac</span><span class="s4">)</span>


<span class="s2">class </span><span class="s1">StringAttribute</span><span class="s4">(</span><span class="s1">Attribute</span><span class="s4">):</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">name</span><span class="s4">):</span>
        <span class="s1">super</span><span class="s4">().</span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">name</span><span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">type_name </span><span class="s4">= </span><span class="s3">'string'</span>

    <span class="s4">@</span><span class="s1">classmethod</span>
    <span class="s2">def </span><span class="s1">parse_attribute</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">, </span><span class="s1">name</span><span class="s4">, </span><span class="s1">attr_string</span><span class="s4">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Parse the attribute line if it knows how. Returns the parsed 
        attribute, or None. 
 
        For string attributes, the attribute string would be like 
        'string'. 
        &quot;&quot;&quot;</span>

        <span class="s1">attr_string </span><span class="s4">= </span><span class="s1">attr_string</span><span class="s4">.</span><span class="s1">lower</span><span class="s4">().</span><span class="s1">strip</span><span class="s4">()</span>

        <span class="s2">if </span><span class="s1">attr_string</span><span class="s4">[:</span><span class="s1">len</span><span class="s4">(</span><span class="s3">'string'</span><span class="s4">)] == </span><span class="s3">'string'</span><span class="s4">:</span>
            <span class="s2">return </span><span class="s1">cls</span><span class="s4">(</span><span class="s1">name</span><span class="s4">)</span>
        <span class="s2">else</span><span class="s4">:</span>
            <span class="s2">return None</span>


<span class="s2">class </span><span class="s1">DateAttribute</span><span class="s4">(</span><span class="s1">Attribute</span><span class="s4">):</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">name</span><span class="s4">, </span><span class="s1">date_format</span><span class="s4">, </span><span class="s1">datetime_unit</span><span class="s4">):</span>
        <span class="s1">super</span><span class="s4">().</span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">name</span><span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">date_format </span><span class="s4">= </span><span class="s1">date_format</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">datetime_unit </span><span class="s4">= </span><span class="s1">datetime_unit</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">type_name </span><span class="s4">= </span><span class="s3">'date'</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">range </span><span class="s4">= </span><span class="s1">date_format</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">dtype </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">datetime64</span><span class="s4">(</span><span class="s6">0</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">datetime_unit</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">staticmethod</span>
    <span class="s2">def </span><span class="s1">_get_date_format</span><span class="s4">(</span><span class="s1">atrv</span><span class="s4">):</span>
        <span class="s1">m </span><span class="s4">= </span><span class="s1">r_date</span><span class="s4">.</span><span class="s1">match</span><span class="s4">(</span><span class="s1">atrv</span><span class="s4">)</span>
        <span class="s2">if </span><span class="s1">m</span><span class="s4">:</span>
            <span class="s1">pattern </span><span class="s4">= </span><span class="s1">m</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">1</span><span class="s4">).</span><span class="s1">strip</span><span class="s4">()</span>
            <span class="s0"># convert time pattern from Java's SimpleDateFormat to C's format</span>
            <span class="s1">datetime_unit </span><span class="s4">= </span><span class="s2">None</span>
            <span class="s2">if </span><span class="s3">&quot;yyyy&quot; </span><span class="s2">in </span><span class="s1">pattern</span><span class="s4">:</span>
                <span class="s1">pattern </span><span class="s4">= </span><span class="s1">pattern</span><span class="s4">.</span><span class="s1">replace</span><span class="s4">(</span><span class="s3">&quot;yyyy&quot;</span><span class="s4">, </span><span class="s3">&quot;%Y&quot;</span><span class="s4">)</span>
                <span class="s1">datetime_unit </span><span class="s4">= </span><span class="s3">&quot;Y&quot;</span>
            <span class="s2">elif </span><span class="s3">&quot;yy&quot;</span><span class="s4">:</span>
                <span class="s1">pattern </span><span class="s4">= </span><span class="s1">pattern</span><span class="s4">.</span><span class="s1">replace</span><span class="s4">(</span><span class="s3">&quot;yy&quot;</span><span class="s4">, </span><span class="s3">&quot;%y&quot;</span><span class="s4">)</span>
                <span class="s1">datetime_unit </span><span class="s4">= </span><span class="s3">&quot;Y&quot;</span>
            <span class="s2">if </span><span class="s3">&quot;MM&quot; </span><span class="s2">in </span><span class="s1">pattern</span><span class="s4">:</span>
                <span class="s1">pattern </span><span class="s4">= </span><span class="s1">pattern</span><span class="s4">.</span><span class="s1">replace</span><span class="s4">(</span><span class="s3">&quot;MM&quot;</span><span class="s4">, </span><span class="s3">&quot;%m&quot;</span><span class="s4">)</span>
                <span class="s1">datetime_unit </span><span class="s4">= </span><span class="s3">&quot;M&quot;</span>
            <span class="s2">if </span><span class="s3">&quot;dd&quot; </span><span class="s2">in </span><span class="s1">pattern</span><span class="s4">:</span>
                <span class="s1">pattern </span><span class="s4">= </span><span class="s1">pattern</span><span class="s4">.</span><span class="s1">replace</span><span class="s4">(</span><span class="s3">&quot;dd&quot;</span><span class="s4">, </span><span class="s3">&quot;%d&quot;</span><span class="s4">)</span>
                <span class="s1">datetime_unit </span><span class="s4">= </span><span class="s3">&quot;D&quot;</span>
            <span class="s2">if </span><span class="s3">&quot;HH&quot; </span><span class="s2">in </span><span class="s1">pattern</span><span class="s4">:</span>
                <span class="s1">pattern </span><span class="s4">= </span><span class="s1">pattern</span><span class="s4">.</span><span class="s1">replace</span><span class="s4">(</span><span class="s3">&quot;HH&quot;</span><span class="s4">, </span><span class="s3">&quot;%H&quot;</span><span class="s4">)</span>
                <span class="s1">datetime_unit </span><span class="s4">= </span><span class="s3">&quot;h&quot;</span>
            <span class="s2">if </span><span class="s3">&quot;mm&quot; </span><span class="s2">in </span><span class="s1">pattern</span><span class="s4">:</span>
                <span class="s1">pattern </span><span class="s4">= </span><span class="s1">pattern</span><span class="s4">.</span><span class="s1">replace</span><span class="s4">(</span><span class="s3">&quot;mm&quot;</span><span class="s4">, </span><span class="s3">&quot;%M&quot;</span><span class="s4">)</span>
                <span class="s1">datetime_unit </span><span class="s4">= </span><span class="s3">&quot;m&quot;</span>
            <span class="s2">if </span><span class="s3">&quot;ss&quot; </span><span class="s2">in </span><span class="s1">pattern</span><span class="s4">:</span>
                <span class="s1">pattern </span><span class="s4">= </span><span class="s1">pattern</span><span class="s4">.</span><span class="s1">replace</span><span class="s4">(</span><span class="s3">&quot;ss&quot;</span><span class="s4">, </span><span class="s3">&quot;%S&quot;</span><span class="s4">)</span>
                <span class="s1">datetime_unit </span><span class="s4">= </span><span class="s3">&quot;s&quot;</span>
            <span class="s2">if </span><span class="s3">&quot;z&quot; </span><span class="s2">in </span><span class="s1">pattern </span><span class="s2">or </span><span class="s3">&quot;Z&quot; </span><span class="s2">in </span><span class="s1">pattern</span><span class="s4">:</span>
                <span class="s2">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s3">&quot;Date type attributes with time zone not &quot;</span>
                                 <span class="s3">&quot;supported, yet&quot;</span><span class="s4">)</span>

            <span class="s2">if </span><span class="s1">datetime_unit </span><span class="s2">is None</span><span class="s4">:</span>
                <span class="s2">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s3">&quot;Invalid or unsupported date format&quot;</span><span class="s4">)</span>

            <span class="s2">return </span><span class="s1">pattern</span><span class="s4">, </span><span class="s1">datetime_unit</span>
        <span class="s2">else</span><span class="s4">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s3">&quot;Invalid or no date format&quot;</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">classmethod</span>
    <span class="s2">def </span><span class="s1">parse_attribute</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">, </span><span class="s1">name</span><span class="s4">, </span><span class="s1">attr_string</span><span class="s4">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Parse the attribute line if it knows how. Returns the parsed 
        attribute, or None. 
 
        For date attributes, the attribute string would be like 
        'date &lt;format&gt;'. 
        &quot;&quot;&quot;</span>

        <span class="s1">attr_string_lower </span><span class="s4">= </span><span class="s1">attr_string</span><span class="s4">.</span><span class="s1">lower</span><span class="s4">().</span><span class="s1">strip</span><span class="s4">()</span>

        <span class="s2">if </span><span class="s1">attr_string_lower</span><span class="s4">[:</span><span class="s1">len</span><span class="s4">(</span><span class="s3">'date'</span><span class="s4">)] == </span><span class="s3">'date'</span><span class="s4">:</span>
            <span class="s1">date_format</span><span class="s4">, </span><span class="s1">datetime_unit </span><span class="s4">= </span><span class="s1">cls</span><span class="s4">.</span><span class="s1">_get_date_format</span><span class="s4">(</span><span class="s1">attr_string</span><span class="s4">)</span>
            <span class="s2">return </span><span class="s1">cls</span><span class="s4">(</span><span class="s1">name</span><span class="s4">, </span><span class="s1">date_format</span><span class="s4">, </span><span class="s1">datetime_unit</span><span class="s4">)</span>
        <span class="s2">else</span><span class="s4">:</span>
            <span class="s2">return None</span>

    <span class="s2">def </span><span class="s1">parse_data</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">data_str</span><span class="s4">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Parse a value of this type. 
        &quot;&quot;&quot;</span>
        <span class="s1">date_str </span><span class="s4">= </span><span class="s1">data_str</span><span class="s4">.</span><span class="s1">strip</span><span class="s4">().</span><span class="s1">strip</span><span class="s4">(</span><span class="s3">&quot;'&quot;</span><span class="s4">).</span><span class="s1">strip</span><span class="s4">(</span><span class="s3">'&quot;'</span><span class="s4">)</span>
        <span class="s2">if </span><span class="s1">date_str </span><span class="s4">== </span><span class="s3">'?'</span><span class="s4">:</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s4">.</span><span class="s1">datetime64</span><span class="s4">(</span><span class="s3">'NaT'</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">datetime_unit</span><span class="s4">)</span>
        <span class="s2">else</span><span class="s4">:</span>
            <span class="s1">dt </span><span class="s4">= </span><span class="s1">datetime</span><span class="s4">.</span><span class="s1">datetime</span><span class="s4">.</span><span class="s1">strptime</span><span class="s4">(</span><span class="s1">date_str</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">date_format</span><span class="s4">)</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s4">.</span><span class="s1">datetime64</span><span class="s4">(</span><span class="s1">dt</span><span class="s4">).</span><span class="s1">astype</span><span class="s4">(</span>
                <span class="s3">&quot;datetime64[%s]&quot; </span><span class="s4">% </span><span class="s1">self</span><span class="s4">.</span><span class="s1">datetime_unit</span><span class="s4">)</span>

    <span class="s2">def </span><span class="s1">__str__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s2">return </span><span class="s1">super</span><span class="s4">().</span><span class="s1">__str__</span><span class="s4">() + </span><span class="s3">',' </span><span class="s4">+ </span><span class="s1">self</span><span class="s4">.</span><span class="s1">date_format</span>


<span class="s2">class </span><span class="s1">RelationalAttribute</span><span class="s4">(</span><span class="s1">Attribute</span><span class="s4">):</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">name</span><span class="s4">):</span>
        <span class="s1">super</span><span class="s4">().</span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">name</span><span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">type_name </span><span class="s4">= </span><span class="s3">'relational'</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">dtype </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">object_</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">attributes </span><span class="s4">= []</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">dialect </span><span class="s4">= </span><span class="s2">None</span>

    <span class="s4">@</span><span class="s1">classmethod</span>
    <span class="s2">def </span><span class="s1">parse_attribute</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">, </span><span class="s1">name</span><span class="s4">, </span><span class="s1">attr_string</span><span class="s4">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Parse the attribute line if it knows how. Returns the parsed 
        attribute, or None. 
 
        For date attributes, the attribute string would be like 
        'date &lt;format&gt;'. 
        &quot;&quot;&quot;</span>

        <span class="s1">attr_string_lower </span><span class="s4">= </span><span class="s1">attr_string</span><span class="s4">.</span><span class="s1">lower</span><span class="s4">().</span><span class="s1">strip</span><span class="s4">()</span>

        <span class="s2">if </span><span class="s1">attr_string_lower</span><span class="s4">[:</span><span class="s1">len</span><span class="s4">(</span><span class="s3">'relational'</span><span class="s4">)] == </span><span class="s3">'relational'</span><span class="s4">:</span>
            <span class="s2">return </span><span class="s1">cls</span><span class="s4">(</span><span class="s1">name</span><span class="s4">)</span>
        <span class="s2">else</span><span class="s4">:</span>
            <span class="s2">return None</span>

    <span class="s2">def </span><span class="s1">parse_data</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">data_str</span><span class="s4">):</span>
        <span class="s0"># Copy-pasted</span>
        <span class="s1">elems </span><span class="s4">= </span><span class="s1">list</span><span class="s4">(</span><span class="s1">range</span><span class="s4">(</span><span class="s1">len</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">attributes</span><span class="s4">)))</span>

        <span class="s1">escaped_string </span><span class="s4">= </span><span class="s1">data_str</span><span class="s4">.</span><span class="s1">encode</span><span class="s4">().</span><span class="s1">decode</span><span class="s4">(</span><span class="s3">&quot;unicode-escape&quot;</span><span class="s4">)</span>

        <span class="s1">row_tuples </span><span class="s4">= []</span>

        <span class="s2">for </span><span class="s1">raw </span><span class="s2">in </span><span class="s1">escaped_string</span><span class="s4">.</span><span class="s1">split</span><span class="s4">(</span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s4">):</span>
            <span class="s1">row</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">dialect </span><span class="s4">= </span><span class="s1">split_data_line</span><span class="s4">(</span><span class="s1">raw</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">dialect</span><span class="s4">)</span>

            <span class="s1">row_tuples</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">tuple</span><span class="s4">(</span>
                <span class="s4">[</span><span class="s1">self</span><span class="s4">.</span><span class="s1">attributes</span><span class="s4">[</span><span class="s1">i</span><span class="s4">].</span><span class="s1">parse_data</span><span class="s4">(</span><span class="s1">row</span><span class="s4">[</span><span class="s1">i</span><span class="s4">]) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">elems</span><span class="s4">]))</span>

        <span class="s2">return </span><span class="s1">np</span><span class="s4">.</span><span class="s1">array</span><span class="s4">(</span><span class="s1">row_tuples</span><span class="s4">,</span>
                        <span class="s4">[(</span><span class="s1">a</span><span class="s4">.</span><span class="s1">name</span><span class="s4">, </span><span class="s1">a</span><span class="s4">.</span><span class="s1">dtype</span><span class="s4">) </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">attributes</span><span class="s4">])</span>

    <span class="s2">def </span><span class="s1">__str__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s2">return </span><span class="s4">(</span><span class="s1">super</span><span class="s4">().</span><span class="s1">__str__</span><span class="s4">() + </span><span class="s3">'</span><span class="s2">\n\t</span><span class="s3">' </span><span class="s4">+</span>
                <span class="s3">'</span><span class="s2">\n\t</span><span class="s3">'</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span><span class="s1">str</span><span class="s4">(</span><span class="s1">a</span><span class="s4">) </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">attributes</span><span class="s4">))</span>


<span class="s0"># -----------------</span>
<span class="s0"># Various utilities</span>
<span class="s0"># -----------------</span>
<span class="s2">def </span><span class="s1">to_attribute</span><span class="s4">(</span><span class="s1">name</span><span class="s4">, </span><span class="s1">attr_string</span><span class="s4">):</span>
    <span class="s1">attr_classes </span><span class="s4">= (</span><span class="s1">NominalAttribute</span><span class="s4">, </span><span class="s1">NumericAttribute</span><span class="s4">, </span><span class="s1">DateAttribute</span><span class="s4">,</span>
                    <span class="s1">StringAttribute</span><span class="s4">, </span><span class="s1">RelationalAttribute</span><span class="s4">)</span>

    <span class="s2">for </span><span class="s1">cls </span><span class="s2">in </span><span class="s1">attr_classes</span><span class="s4">:</span>
        <span class="s1">attr </span><span class="s4">= </span><span class="s1">cls</span><span class="s4">.</span><span class="s1">parse_attribute</span><span class="s4">(</span><span class="s1">name</span><span class="s4">, </span><span class="s1">attr_string</span><span class="s4">)</span>
        <span class="s2">if </span><span class="s1">attr </span><span class="s2">is not None</span><span class="s4">:</span>
            <span class="s2">return </span><span class="s1">attr</span>

    <span class="s2">raise </span><span class="s1">ParseArffError</span><span class="s4">(</span><span class="s3">&quot;unknown attribute %s&quot; </span><span class="s4">% </span><span class="s1">attr_string</span><span class="s4">)</span>


<span class="s2">def </span><span class="s1">csv_sniffer_has_bug_last_field</span><span class="s4">():</span>
    <span class="s5">&quot;&quot;&quot; 
    Checks if the bug https://bugs.python.org/issue30157 is unpatched. 
    &quot;&quot;&quot;</span>

    <span class="s0"># We only compute this once.</span>
    <span class="s1">has_bug </span><span class="s4">= </span><span class="s1">getattr</span><span class="s4">(</span><span class="s1">csv_sniffer_has_bug_last_field</span><span class="s4">, </span><span class="s3">&quot;has_bug&quot;</span><span class="s4">, </span><span class="s2">None</span><span class="s4">)</span>

    <span class="s2">if </span><span class="s1">has_bug </span><span class="s2">is None</span><span class="s4">:</span>
        <span class="s1">dialect </span><span class="s4">= </span><span class="s1">csv</span><span class="s4">.</span><span class="s1">Sniffer</span><span class="s4">().</span><span class="s1">sniff</span><span class="s4">(</span><span class="s3">&quot;3, 'a'&quot;</span><span class="s4">)</span>
        <span class="s1">csv_sniffer_has_bug_last_field</span><span class="s4">.</span><span class="s1">has_bug </span><span class="s4">= </span><span class="s1">dialect</span><span class="s4">.</span><span class="s1">quotechar </span><span class="s4">!= </span><span class="s3">&quot;'&quot;</span>
        <span class="s1">has_bug </span><span class="s4">= </span><span class="s1">csv_sniffer_has_bug_last_field</span><span class="s4">.</span><span class="s1">has_bug</span>

    <span class="s2">return </span><span class="s1">has_bug</span>


<span class="s2">def </span><span class="s1">workaround_csv_sniffer_bug_last_field</span><span class="s4">(</span><span class="s1">sniff_line</span><span class="s4">, </span><span class="s1">dialect</span><span class="s4">, </span><span class="s1">delimiters</span><span class="s4">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Workaround for the bug https://bugs.python.org/issue30157 if is unpatched. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">csv_sniffer_has_bug_last_field</span><span class="s4">():</span>
        <span class="s0"># Reuses code from the csv module</span>
        <span class="s1">right_regex </span><span class="s4">= </span><span class="s3">r'(?P&lt;delim&gt;[^\w\n&quot;\'])(?P&lt;space&gt; ?)(?P&lt;quote&gt;[&quot;\']).*?(?P=quote)(?:$|\n)'  </span><span class="s0"># noqa: E501</span>

        <span class="s2">for </span><span class="s1">restr </span><span class="s2">in </span><span class="s4">(</span><span class="s3">r'(?P&lt;delim&gt;[^\w\n&quot;\'])(?P&lt;space&gt; ?)(?P&lt;quote&gt;[&quot;\']).*?(?P=quote)(?P=delim)'</span><span class="s4">,  </span><span class="s0"># ,&quot;.*?&quot;,  # noqa: E501</span>
                      <span class="s3">r'(?:^|\n)(?P&lt;quote&gt;[&quot;\']).*?(?P=quote)(?P&lt;delim&gt;[^\w\n&quot;\'])(?P&lt;space&gt; ?)'</span><span class="s4">,  </span><span class="s0"># .*?&quot;,  # noqa: E501</span>
                      <span class="s1">right_regex</span><span class="s4">,  </span><span class="s0"># ,&quot;.*?&quot;</span>
                      <span class="s3">r'(?:^|\n)(?P&lt;quote&gt;[&quot;\']).*?(?P=quote)(?:$|\n)'</span><span class="s4">):  </span><span class="s0"># &quot;.*?&quot; (no delim, no space)  # noqa: E501</span>
            <span class="s1">regexp </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span><span class="s1">restr</span><span class="s4">, </span><span class="s1">re</span><span class="s4">.</span><span class="s1">DOTALL </span><span class="s4">| </span><span class="s1">re</span><span class="s4">.</span><span class="s1">MULTILINE</span><span class="s4">)</span>
            <span class="s1">matches </span><span class="s4">= </span><span class="s1">regexp</span><span class="s4">.</span><span class="s1">findall</span><span class="s4">(</span><span class="s1">sniff_line</span><span class="s4">)</span>
            <span class="s2">if </span><span class="s1">matches</span><span class="s4">:</span>
                <span class="s2">break</span>

        <span class="s0"># If it does not match the expression that was bugged,</span>
        <span class="s0"># then this bug does not apply</span>
        <span class="s2">if </span><span class="s1">restr </span><span class="s4">!= </span><span class="s1">right_regex</span><span class="s4">:</span>
            <span class="s2">return</span>

        <span class="s1">groupindex </span><span class="s4">= </span><span class="s1">regexp</span><span class="s4">.</span><span class="s1">groupindex</span>

        <span class="s0"># There is only one end of the string</span>
        <span class="s2">assert </span><span class="s1">len</span><span class="s4">(</span><span class="s1">matches</span><span class="s4">) == </span><span class="s6">1</span>
        <span class="s1">m </span><span class="s4">= </span><span class="s1">matches</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]</span>

        <span class="s1">n </span><span class="s4">= </span><span class="s1">groupindex</span><span class="s4">[</span><span class="s3">'quote'</span><span class="s4">] - </span><span class="s6">1</span>
        <span class="s1">quote </span><span class="s4">= </span><span class="s1">m</span><span class="s4">[</span><span class="s1">n</span><span class="s4">]</span>

        <span class="s1">n </span><span class="s4">= </span><span class="s1">groupindex</span><span class="s4">[</span><span class="s3">'delim'</span><span class="s4">] - </span><span class="s6">1</span>
        <span class="s1">delim </span><span class="s4">= </span><span class="s1">m</span><span class="s4">[</span><span class="s1">n</span><span class="s4">]</span>

        <span class="s1">n </span><span class="s4">= </span><span class="s1">groupindex</span><span class="s4">[</span><span class="s3">'space'</span><span class="s4">] - </span><span class="s6">1</span>
        <span class="s1">space </span><span class="s4">= </span><span class="s1">bool</span><span class="s4">(</span><span class="s1">m</span><span class="s4">[</span><span class="s1">n</span><span class="s4">])</span>

        <span class="s1">dq_regexp </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span>
            <span class="s3">rf&quot;((</span><span class="s2">{</span><span class="s1">re</span><span class="s4">.</span><span class="s1">escape</span><span class="s4">(</span><span class="s1">delim</span><span class="s4">)</span><span class="s2">}</span><span class="s3">)|^)\W*</span><span class="s2">{</span><span class="s1">quote</span><span class="s2">}</span><span class="s3">[^</span><span class="s2">{</span><span class="s1">re</span><span class="s4">.</span><span class="s1">escape</span><span class="s4">(</span><span class="s1">delim</span><span class="s4">)</span><span class="s2">}</span><span class="s3">\n]*</span><span class="s2">{</span><span class="s1">quote</span><span class="s2">}</span><span class="s3">[^</span><span class="s2">{</span><span class="s1">re</span><span class="s4">.</span><span class="s1">escape</span><span class="s4">(</span><span class="s1">delim</span><span class="s4">)</span><span class="s2">}</span><span class="s3">\n]*</span><span class="s2">{</span><span class="s1">quote</span><span class="s2">}</span><span class="s3">\W*((</span><span class="s2">{</span><span class="s1">re</span><span class="s4">.</span><span class="s1">escape</span><span class="s4">(</span><span class="s1">delim</span><span class="s4">)</span><span class="s2">}</span><span class="s3">)|$)&quot;</span><span class="s4">, </span><span class="s1">re</span><span class="s4">.</span><span class="s1">MULTILINE  </span><span class="s0"># noqa: E501</span>
        <span class="s4">)</span>

        <span class="s1">doublequote </span><span class="s4">= </span><span class="s1">bool</span><span class="s4">(</span><span class="s1">dq_regexp</span><span class="s4">.</span><span class="s1">search</span><span class="s4">(</span><span class="s1">sniff_line</span><span class="s4">))</span>

        <span class="s1">dialect</span><span class="s4">.</span><span class="s1">quotechar </span><span class="s4">= </span><span class="s1">quote</span>
        <span class="s2">if </span><span class="s1">delim </span><span class="s2">in </span><span class="s1">delimiters</span><span class="s4">:</span>
            <span class="s1">dialect</span><span class="s4">.</span><span class="s1">delimiter </span><span class="s4">= </span><span class="s1">delim</span>
        <span class="s1">dialect</span><span class="s4">.</span><span class="s1">doublequote </span><span class="s4">= </span><span class="s1">doublequote</span>
        <span class="s1">dialect</span><span class="s4">.</span><span class="s1">skipinitialspace </span><span class="s4">= </span><span class="s1">space</span>


<span class="s2">def </span><span class="s1">split_data_line</span><span class="s4">(</span><span class="s1">line</span><span class="s4">, </span><span class="s1">dialect</span><span class="s4">=</span><span class="s2">None</span><span class="s4">):</span>
    <span class="s1">delimiters </span><span class="s4">= </span><span class="s3">&quot;,</span><span class="s2">\t</span><span class="s3">&quot;</span>

    <span class="s0"># This can not be done in a per reader basis, and relational fields</span>
    <span class="s0"># can be HUGE</span>
    <span class="s1">csv</span><span class="s4">.</span><span class="s1">field_size_limit</span><span class="s4">(</span><span class="s1">int</span><span class="s4">(</span><span class="s1">ctypes</span><span class="s4">.</span><span class="s1">c_ulong</span><span class="s4">(-</span><span class="s6">1</span><span class="s4">).</span><span class="s1">value </span><span class="s4">// </span><span class="s6">2</span><span class="s4">))</span>

    <span class="s0"># Remove the line end if any</span>
    <span class="s2">if </span><span class="s1">line</span><span class="s4">[-</span><span class="s6">1</span><span class="s4">] == </span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s4">:</span>
        <span class="s1">line </span><span class="s4">= </span><span class="s1">line</span><span class="s4">[:-</span><span class="s6">1</span><span class="s4">]</span>
    
    <span class="s0"># Remove potential trailing whitespace</span>
    <span class="s1">line </span><span class="s4">= </span><span class="s1">line</span><span class="s4">.</span><span class="s1">strip</span><span class="s4">()</span>
    
    <span class="s1">sniff_line </span><span class="s4">= </span><span class="s1">line</span>

    <span class="s0"># Add a delimiter if none is present, so that the csv.Sniffer</span>
    <span class="s0"># does not complain for a single-field CSV.</span>
    <span class="s2">if not </span><span class="s1">any</span><span class="s4">(</span><span class="s1">d </span><span class="s2">in </span><span class="s1">line </span><span class="s2">for </span><span class="s1">d </span><span class="s2">in </span><span class="s1">delimiters</span><span class="s4">):</span>
        <span class="s1">sniff_line </span><span class="s4">+= </span><span class="s3">&quot;,&quot;</span>

    <span class="s2">if </span><span class="s1">dialect </span><span class="s2">is None</span><span class="s4">:</span>
        <span class="s1">dialect </span><span class="s4">= </span><span class="s1">csv</span><span class="s4">.</span><span class="s1">Sniffer</span><span class="s4">().</span><span class="s1">sniff</span><span class="s4">(</span><span class="s1">sniff_line</span><span class="s4">, </span><span class="s1">delimiters</span><span class="s4">=</span><span class="s1">delimiters</span><span class="s4">)</span>
        <span class="s1">workaround_csv_sniffer_bug_last_field</span><span class="s4">(</span><span class="s1">sniff_line</span><span class="s4">=</span><span class="s1">sniff_line</span><span class="s4">,</span>
                                              <span class="s1">dialect</span><span class="s4">=</span><span class="s1">dialect</span><span class="s4">,</span>
                                              <span class="s1">delimiters</span><span class="s4">=</span><span class="s1">delimiters</span><span class="s4">)</span>

    <span class="s1">row </span><span class="s4">= </span><span class="s1">next</span><span class="s4">(</span><span class="s1">csv</span><span class="s4">.</span><span class="s1">reader</span><span class="s4">([</span><span class="s1">line</span><span class="s4">], </span><span class="s1">dialect</span><span class="s4">))</span>

    <span class="s2">return </span><span class="s1">row</span><span class="s4">, </span><span class="s1">dialect</span>


<span class="s0"># --------------</span>
<span class="s0"># Parsing header</span>
<span class="s0"># --------------</span>
<span class="s2">def </span><span class="s1">tokenize_attribute</span><span class="s4">(</span><span class="s1">iterable</span><span class="s4">, </span><span class="s1">attribute</span><span class="s4">):</span>
    <span class="s5">&quot;&quot;&quot;Parse a raw string in header (e.g., starts by @attribute). 
 
    Given a raw string attribute, try to get the name and type of the 
    attribute. Constraints: 
 
    * The first line must start with @attribute (case insensitive, and 
      space like characters before @attribute are allowed) 
    * Works also if the attribute is spread on multilines. 
    * Works if empty lines or comments are in between 
 
    Parameters 
    ---------- 
    attribute : str 
       the attribute string. 
 
    Returns 
    ------- 
    name : str 
       name of the attribute 
    value : str 
       value of the attribute 
    next : str 
       next line to be parsed 
 
    Examples 
    -------- 
    If attribute is a string defined in python as r&quot;floupi real&quot;, will 
    return floupi as name, and real as value. 
 
    &gt;&gt;&gt; from scipy.io.arff._arffread import tokenize_attribute 
    &gt;&gt;&gt; iterable = iter([0] * 10) # dummy iterator 
    &gt;&gt;&gt; tokenize_attribute(iterable, r&quot;@attribute floupi real&quot;) 
    ('floupi', 'real', 0) 
 
    If attribute is r&quot;'floupi 2' real&quot;, will return 'floupi 2' as name, 
    and real as value. 
 
    &gt;&gt;&gt; tokenize_attribute(iterable, r&quot;  @attribute 'floupi 2' real   &quot;) 
    ('floupi 2', 'real', 0) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">sattr </span><span class="s4">= </span><span class="s1">attribute</span><span class="s4">.</span><span class="s1">strip</span><span class="s4">()</span>
    <span class="s1">mattr </span><span class="s4">= </span><span class="s1">r_attribute</span><span class="s4">.</span><span class="s1">match</span><span class="s4">(</span><span class="s1">sattr</span><span class="s4">)</span>
    <span class="s2">if </span><span class="s1">mattr</span><span class="s4">:</span>
        <span class="s0"># atrv is everything after @attribute</span>
        <span class="s1">atrv </span><span class="s4">= </span><span class="s1">mattr</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">1</span><span class="s4">)</span>
        <span class="s2">if </span><span class="s1">r_comattrval</span><span class="s4">.</span><span class="s1">match</span><span class="s4">(</span><span class="s1">atrv</span><span class="s4">):</span>
            <span class="s1">name</span><span class="s4">, </span><span class="s1">type </span><span class="s4">= </span><span class="s1">tokenize_single_comma</span><span class="s4">(</span><span class="s1">atrv</span><span class="s4">)</span>
            <span class="s1">next_item </span><span class="s4">= </span><span class="s1">next</span><span class="s4">(</span><span class="s1">iterable</span><span class="s4">)</span>
        <span class="s2">elif </span><span class="s1">r_wcomattrval</span><span class="s4">.</span><span class="s1">match</span><span class="s4">(</span><span class="s1">atrv</span><span class="s4">):</span>
            <span class="s1">name</span><span class="s4">, </span><span class="s1">type </span><span class="s4">= </span><span class="s1">tokenize_single_wcomma</span><span class="s4">(</span><span class="s1">atrv</span><span class="s4">)</span>
            <span class="s1">next_item </span><span class="s4">= </span><span class="s1">next</span><span class="s4">(</span><span class="s1">iterable</span><span class="s4">)</span>
        <span class="s2">else</span><span class="s4">:</span>
            <span class="s0"># Not sure we should support this, as it does not seem supported by</span>
            <span class="s0"># weka.</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s3">&quot;multi line not supported yet&quot;</span><span class="s4">)</span>
    <span class="s2">else</span><span class="s4">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s3">&quot;First line unparsable: %s&quot; </span><span class="s4">% </span><span class="s1">sattr</span><span class="s4">)</span>

    <span class="s1">attribute </span><span class="s4">= </span><span class="s1">to_attribute</span><span class="s4">(</span><span class="s1">name</span><span class="s4">, </span><span class="s1">type</span><span class="s4">)</span>

    <span class="s2">if </span><span class="s1">type</span><span class="s4">.</span><span class="s1">lower</span><span class="s4">() == </span><span class="s3">'relational'</span><span class="s4">:</span>
        <span class="s1">next_item </span><span class="s4">= </span><span class="s1">read_relational_attribute</span><span class="s4">(</span><span class="s1">iterable</span><span class="s4">, </span><span class="s1">attribute</span><span class="s4">, </span><span class="s1">next_item</span><span class="s4">)</span>
    <span class="s0">#    raise ValueError(&quot;relational attributes not supported yet&quot;)</span>

    <span class="s2">return </span><span class="s1">attribute</span><span class="s4">, </span><span class="s1">next_item</span>


<span class="s2">def </span><span class="s1">tokenize_single_comma</span><span class="s4">(</span><span class="s1">val</span><span class="s4">):</span>
    <span class="s0"># XXX we match twice the same string (here and at the caller level). It is</span>
    <span class="s0"># stupid, but it is easier for now...</span>
    <span class="s1">m </span><span class="s4">= </span><span class="s1">r_comattrval</span><span class="s4">.</span><span class="s1">match</span><span class="s4">(</span><span class="s1">val</span><span class="s4">)</span>
    <span class="s2">if </span><span class="s1">m</span><span class="s4">:</span>
        <span class="s2">try</span><span class="s4">:</span>
            <span class="s1">name </span><span class="s4">= </span><span class="s1">m</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">1</span><span class="s4">).</span><span class="s1">strip</span><span class="s4">()</span>
            <span class="s1">type </span><span class="s4">= </span><span class="s1">m</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">2</span><span class="s4">).</span><span class="s1">strip</span><span class="s4">()</span>
        <span class="s2">except </span><span class="s1">IndexError </span><span class="s2">as </span><span class="s1">e</span><span class="s4">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s3">&quot;Error while tokenizing attribute&quot;</span><span class="s4">) </span><span class="s2">from </span><span class="s1">e</span>
    <span class="s2">else</span><span class="s4">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s3">&quot;Error while tokenizing single %s&quot; </span><span class="s4">% </span><span class="s1">val</span><span class="s4">)</span>
    <span class="s2">return </span><span class="s1">name</span><span class="s4">, </span><span class="s1">type</span>


<span class="s2">def </span><span class="s1">tokenize_single_wcomma</span><span class="s4">(</span><span class="s1">val</span><span class="s4">):</span>
    <span class="s0"># XXX we match twice the same string (here and at the caller level). It is</span>
    <span class="s0"># stupid, but it is easier for now...</span>
    <span class="s1">m </span><span class="s4">= </span><span class="s1">r_wcomattrval</span><span class="s4">.</span><span class="s1">match</span><span class="s4">(</span><span class="s1">val</span><span class="s4">)</span>
    <span class="s2">if </span><span class="s1">m</span><span class="s4">:</span>
        <span class="s2">try</span><span class="s4">:</span>
            <span class="s1">name </span><span class="s4">= </span><span class="s1">m</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">1</span><span class="s4">).</span><span class="s1">strip</span><span class="s4">()</span>
            <span class="s1">type </span><span class="s4">= </span><span class="s1">m</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">2</span><span class="s4">).</span><span class="s1">strip</span><span class="s4">()</span>
        <span class="s2">except </span><span class="s1">IndexError </span><span class="s2">as </span><span class="s1">e</span><span class="s4">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s3">&quot;Error while tokenizing attribute&quot;</span><span class="s4">) </span><span class="s2">from </span><span class="s1">e</span>
    <span class="s2">else</span><span class="s4">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s3">&quot;Error while tokenizing single %s&quot; </span><span class="s4">% </span><span class="s1">val</span><span class="s4">)</span>
    <span class="s2">return </span><span class="s1">name</span><span class="s4">, </span><span class="s1">type</span>


<span class="s2">def </span><span class="s1">read_relational_attribute</span><span class="s4">(</span><span class="s1">ofile</span><span class="s4">, </span><span class="s1">relational_attribute</span><span class="s4">, </span><span class="s1">i</span><span class="s4">):</span>
    <span class="s5">&quot;&quot;&quot;Read the nested attributes of a relational attribute&quot;&quot;&quot;</span>

    <span class="s1">r_end_relational </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span><span class="s3">r'^@[Ee][Nn][Dd]\s*' </span><span class="s4">+</span>
                                  <span class="s1">relational_attribute</span><span class="s4">.</span><span class="s1">name </span><span class="s4">+ </span><span class="s3">r'\s*$'</span><span class="s4">)</span>

    <span class="s2">while not </span><span class="s1">r_end_relational</span><span class="s4">.</span><span class="s1">match</span><span class="s4">(</span><span class="s1">i</span><span class="s4">):</span>
        <span class="s1">m </span><span class="s4">= </span><span class="s1">r_headerline</span><span class="s4">.</span><span class="s1">match</span><span class="s4">(</span><span class="s1">i</span><span class="s4">)</span>
        <span class="s2">if </span><span class="s1">m</span><span class="s4">:</span>
            <span class="s1">isattr </span><span class="s4">= </span><span class="s1">r_attribute</span><span class="s4">.</span><span class="s1">match</span><span class="s4">(</span><span class="s1">i</span><span class="s4">)</span>
            <span class="s2">if </span><span class="s1">isattr</span><span class="s4">:</span>
                <span class="s1">attr</span><span class="s4">, </span><span class="s1">i </span><span class="s4">= </span><span class="s1">tokenize_attribute</span><span class="s4">(</span><span class="s1">ofile</span><span class="s4">, </span><span class="s1">i</span><span class="s4">)</span>
                <span class="s1">relational_attribute</span><span class="s4">.</span><span class="s1">attributes</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">attr</span><span class="s4">)</span>
            <span class="s2">else</span><span class="s4">:</span>
                <span class="s2">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s3">&quot;Error parsing line %s&quot; </span><span class="s4">% </span><span class="s1">i</span><span class="s4">)</span>
        <span class="s2">else</span><span class="s4">:</span>
            <span class="s1">i </span><span class="s4">= </span><span class="s1">next</span><span class="s4">(</span><span class="s1">ofile</span><span class="s4">)</span>

    <span class="s1">i </span><span class="s4">= </span><span class="s1">next</span><span class="s4">(</span><span class="s1">ofile</span><span class="s4">)</span>
    <span class="s2">return </span><span class="s1">i</span>


<span class="s2">def </span><span class="s1">read_header</span><span class="s4">(</span><span class="s1">ofile</span><span class="s4">):</span>
    <span class="s5">&quot;&quot;&quot;Read the header of the iterable ofile.&quot;&quot;&quot;</span>
    <span class="s1">i </span><span class="s4">= </span><span class="s1">next</span><span class="s4">(</span><span class="s1">ofile</span><span class="s4">)</span>

    <span class="s0"># Pass first comments</span>
    <span class="s2">while </span><span class="s1">r_comment</span><span class="s4">.</span><span class="s1">match</span><span class="s4">(</span><span class="s1">i</span><span class="s4">):</span>
        <span class="s1">i </span><span class="s4">= </span><span class="s1">next</span><span class="s4">(</span><span class="s1">ofile</span><span class="s4">)</span>

    <span class="s0"># Header is everything up to DATA attribute ?</span>
    <span class="s1">relation </span><span class="s4">= </span><span class="s2">None</span>
    <span class="s1">attributes </span><span class="s4">= []</span>
    <span class="s2">while not </span><span class="s1">r_datameta</span><span class="s4">.</span><span class="s1">match</span><span class="s4">(</span><span class="s1">i</span><span class="s4">):</span>
        <span class="s1">m </span><span class="s4">= </span><span class="s1">r_headerline</span><span class="s4">.</span><span class="s1">match</span><span class="s4">(</span><span class="s1">i</span><span class="s4">)</span>
        <span class="s2">if </span><span class="s1">m</span><span class="s4">:</span>
            <span class="s1">isattr </span><span class="s4">= </span><span class="s1">r_attribute</span><span class="s4">.</span><span class="s1">match</span><span class="s4">(</span><span class="s1">i</span><span class="s4">)</span>
            <span class="s2">if </span><span class="s1">isattr</span><span class="s4">:</span>
                <span class="s1">attr</span><span class="s4">, </span><span class="s1">i </span><span class="s4">= </span><span class="s1">tokenize_attribute</span><span class="s4">(</span><span class="s1">ofile</span><span class="s4">, </span><span class="s1">i</span><span class="s4">)</span>
                <span class="s1">attributes</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">attr</span><span class="s4">)</span>
            <span class="s2">else</span><span class="s4">:</span>
                <span class="s1">isrel </span><span class="s4">= </span><span class="s1">r_relation</span><span class="s4">.</span><span class="s1">match</span><span class="s4">(</span><span class="s1">i</span><span class="s4">)</span>
                <span class="s2">if </span><span class="s1">isrel</span><span class="s4">:</span>
                    <span class="s1">relation </span><span class="s4">= </span><span class="s1">isrel</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">1</span><span class="s4">)</span>
                <span class="s2">else</span><span class="s4">:</span>
                    <span class="s2">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s3">&quot;Error parsing line %s&quot; </span><span class="s4">% </span><span class="s1">i</span><span class="s4">)</span>
                <span class="s1">i </span><span class="s4">= </span><span class="s1">next</span><span class="s4">(</span><span class="s1">ofile</span><span class="s4">)</span>
        <span class="s2">else</span><span class="s4">:</span>
            <span class="s1">i </span><span class="s4">= </span><span class="s1">next</span><span class="s4">(</span><span class="s1">ofile</span><span class="s4">)</span>

    <span class="s2">return </span><span class="s1">relation</span><span class="s4">, </span><span class="s1">attributes</span>


<span class="s2">class </span><span class="s1">MetaData</span><span class="s4">:</span>
    <span class="s5">&quot;&quot;&quot;Small container to keep useful information on a ARFF dataset. 
 
    Knows about attributes names and types. 
 
    Examples 
    -------- 
    :: 
 
        data, meta = loadarff('iris.arff') 
        # This will print the attributes names of the iris.arff dataset 
        for i in meta: 
            print(i) 
        # This works too 
        meta.names() 
        # Getting attribute type 
        types = meta.types() 
 
    Methods 
    ------- 
    names 
    types 
 
    Notes 
    ----- 
    Also maintains the list of attributes in order, i.e., doing for i in 
    meta, where meta is an instance of MetaData, will return the 
    different attribute names in the order they were defined. 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">rel</span><span class="s4">, </span><span class="s1">attr</span><span class="s4">):</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">name </span><span class="s4">= </span><span class="s1">rel</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_attributes </span><span class="s4">= {</span><span class="s1">a</span><span class="s4">.</span><span class="s1">name</span><span class="s4">: </span><span class="s1">a </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">attr</span><span class="s4">}</span>

    <span class="s2">def </span><span class="s1">__repr__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s1">msg </span><span class="s4">= </span><span class="s3">&quot;&quot;</span>
        <span class="s1">msg </span><span class="s4">+= </span><span class="s3">&quot;Dataset: %s</span><span class="s2">\n</span><span class="s3">&quot; </span><span class="s4">% </span><span class="s1">self</span><span class="s4">.</span><span class="s1">name</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_attributes</span><span class="s4">:</span>
            <span class="s1">msg </span><span class="s4">+= </span><span class="s3">f&quot;</span><span class="s2">\t{</span><span class="s1">i</span><span class="s2">}</span><span class="s3">'s type is </span><span class="s2">{</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_attributes</span><span class="s4">[</span><span class="s1">i</span><span class="s4">].</span><span class="s1">type_name</span><span class="s2">}</span><span class="s3">&quot;</span>
            <span class="s2">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_attributes</span><span class="s4">[</span><span class="s1">i</span><span class="s4">].</span><span class="s1">range</span><span class="s4">:</span>
                <span class="s1">msg </span><span class="s4">+= </span><span class="s3">&quot;, range is %s&quot; </span><span class="s4">% </span><span class="s1">str</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_attributes</span><span class="s4">[</span><span class="s1">i</span><span class="s4">].</span><span class="s1">range</span><span class="s4">)</span>
            <span class="s1">msg </span><span class="s4">+= </span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span>
        <span class="s2">return </span><span class="s1">msg</span>

    <span class="s2">def </span><span class="s1">__iter__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s2">return </span><span class="s1">iter</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_attributes</span><span class="s4">)</span>

    <span class="s2">def </span><span class="s1">__getitem__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">key</span><span class="s4">):</span>
        <span class="s1">attr </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_attributes</span><span class="s4">[</span><span class="s1">key</span><span class="s4">]</span>

        <span class="s2">return </span><span class="s4">(</span><span class="s1">attr</span><span class="s4">.</span><span class="s1">type_name</span><span class="s4">, </span><span class="s1">attr</span><span class="s4">.</span><span class="s1">range</span><span class="s4">)</span>

    <span class="s2">def </span><span class="s1">names</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s5">&quot;&quot;&quot;Return the list of attribute names. 
 
        Returns 
        ------- 
        attrnames : list of str 
            The attribute names. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">list</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_attributes</span><span class="s4">)</span>

    <span class="s2">def </span><span class="s1">types</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s5">&quot;&quot;&quot;Return the list of attribute types. 
 
        Returns 
        ------- 
        attr_types : list of str 
            The attribute types. 
        &quot;&quot;&quot;</span>
        <span class="s1">attr_types </span><span class="s4">= [</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_attributes</span><span class="s4">[</span><span class="s1">name</span><span class="s4">].</span><span class="s1">type_name</span>
                      <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_attributes</span><span class="s4">]</span>
        <span class="s2">return </span><span class="s1">attr_types</span>


<span class="s2">def </span><span class="s1">loadarff</span><span class="s4">(</span><span class="s1">f</span><span class="s4">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Read an arff file. 
 
    The data is returned as a record array, which can be accessed much like 
    a dictionary of NumPy arrays. For example, if one of the attributes is 
    called 'pressure', then its first 10 data points can be accessed from the 
    ``data`` record array like so: ``data['pressure'][0:10]`` 
 
 
    Parameters 
    ---------- 
    f : file-like or str 
       File-like object to read from, or filename to open. 
 
    Returns 
    ------- 
    data : record array 
       The data of the arff file, accessible by attribute names. 
    meta : `MetaData` 
       Contains information about the arff file such as name and 
       type of attributes, the relation (name of the dataset), etc. 
 
    Raises 
    ------ 
    ParseArffError 
        This is raised if the given file is not ARFF-formatted. 
    NotImplementedError 
        The ARFF file has an attribute which is not supported yet. 
 
    Notes 
    ----- 
 
    This function should be able to read most arff files. Not 
    implemented functionality include: 
 
    * date type attributes 
    * string type attributes 
 
    It can read files with numeric and nominal attributes. It cannot read 
    files with sparse data ({} in the file). However, this function can 
    read files with missing data (? in the file), representing the data 
    points as NaNs. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.io import arff 
    &gt;&gt;&gt; from io import StringIO 
    &gt;&gt;&gt; content = \&quot;\&quot;\&quot; 
    ... @relation foo 
    ... @attribute width  numeric 
    ... @attribute height numeric 
    ... @attribute color  {red,green,blue,yellow,black} 
    ... @data 
    ... 5.0,3.25,blue 
    ... 4.5,3.75,green 
    ... 3.0,4.00,red 
    ... \&quot;\&quot;\&quot; 
    &gt;&gt;&gt; f = StringIO(content) 
    &gt;&gt;&gt; data, meta = arff.loadarff(f) 
    &gt;&gt;&gt; data 
    array([(5.0, 3.25, 'blue'), (4.5, 3.75, 'green'), (3.0, 4.0, 'red')], 
          dtype=[('width', '&lt;f8'), ('height', '&lt;f8'), ('color', '|S6')]) 
    &gt;&gt;&gt; meta 
    Dataset: foo 
    \twidth's type is numeric 
    \theight's type is numeric 
    \tcolor's type is nominal, range is ('red', 'green', 'blue', 'yellow', 'black') 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">f</span><span class="s4">, </span><span class="s3">'read'</span><span class="s4">):</span>
        <span class="s1">ofile </span><span class="s4">= </span><span class="s1">f</span>
    <span class="s2">else</span><span class="s4">:</span>
        <span class="s1">ofile </span><span class="s4">= </span><span class="s1">open</span><span class="s4">(</span><span class="s1">f</span><span class="s4">)</span>
    <span class="s2">try</span><span class="s4">:</span>
        <span class="s2">return </span><span class="s1">_loadarff</span><span class="s4">(</span><span class="s1">ofile</span><span class="s4">)</span>
    <span class="s2">finally</span><span class="s4">:</span>
        <span class="s2">if </span><span class="s1">ofile </span><span class="s2">is not </span><span class="s1">f</span><span class="s4">:  </span><span class="s0"># only close what we opened</span>
            <span class="s1">ofile</span><span class="s4">.</span><span class="s1">close</span><span class="s4">()</span>


<span class="s2">def </span><span class="s1">_loadarff</span><span class="s4">(</span><span class="s1">ofile</span><span class="s4">):</span>
    <span class="s0"># Parse the header file</span>
    <span class="s2">try</span><span class="s4">:</span>
        <span class="s1">rel</span><span class="s4">, </span><span class="s1">attr </span><span class="s4">= </span><span class="s1">read_header</span><span class="s4">(</span><span class="s1">ofile</span><span class="s4">)</span>
    <span class="s2">except </span><span class="s1">ValueError </span><span class="s2">as </span><span class="s1">e</span><span class="s4">:</span>
        <span class="s1">msg </span><span class="s4">= </span><span class="s3">&quot;Error while parsing header, error was: &quot; </span><span class="s4">+ </span><span class="s1">str</span><span class="s4">(</span><span class="s1">e</span><span class="s4">)</span>
        <span class="s2">raise </span><span class="s1">ParseArffError</span><span class="s4">(</span><span class="s1">msg</span><span class="s4">) </span><span class="s2">from </span><span class="s1">e</span>

    <span class="s0"># Check whether we have a string attribute (not supported yet)</span>
    <span class="s1">hasstr </span><span class="s4">= </span><span class="s2">False</span>
    <span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">attr</span><span class="s4">:</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">a</span><span class="s4">, </span><span class="s1">StringAttribute</span><span class="s4">):</span>
            <span class="s1">hasstr </span><span class="s4">= </span><span class="s2">True</span>

    <span class="s1">meta </span><span class="s4">= </span><span class="s1">MetaData</span><span class="s4">(</span><span class="s1">rel</span><span class="s4">, </span><span class="s1">attr</span><span class="s4">)</span>

    <span class="s0"># XXX The following code is not great</span>
    <span class="s0"># Build the type descriptor descr and the list of converters to convert</span>
    <span class="s0"># each attribute to the suitable type (which should match the one in</span>
    <span class="s0"># descr).</span>

    <span class="s0"># This can be used once we want to support integer as integer values and</span>
    <span class="s0"># not as numeric anymore (using masked arrays ?).</span>

    <span class="s2">if </span><span class="s1">hasstr</span><span class="s4">:</span>
        <span class="s0"># How to support string efficiently ? Ideally, we should know the max</span>
        <span class="s0"># size of the string before allocating the numpy array.</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span><span class="s4">(</span><span class="s3">&quot;String attributes not supported yet, sorry&quot;</span><span class="s4">)</span>

    <span class="s1">ni </span><span class="s4">= </span><span class="s1">len</span><span class="s4">(</span><span class="s1">attr</span><span class="s4">)</span>

    <span class="s2">def </span><span class="s1">generator</span><span class="s4">(</span><span class="s1">row_iter</span><span class="s4">, </span><span class="s1">delim</span><span class="s4">=</span><span class="s3">','</span><span class="s4">):</span>
        <span class="s0"># TODO: this is where we are spending time (~80%). I think things</span>
        <span class="s0"># could be made more efficiently:</span>
        <span class="s0">#   - We could for example &quot;compile&quot; the function, because some values</span>
        <span class="s0">#   do not change here.</span>
        <span class="s0">#   - The function to convert a line to dtyped values could also be</span>
        <span class="s0">#   generated on the fly from a string and be executed instead of</span>
        <span class="s0">#   looping.</span>
        <span class="s0">#   - The regex are overkill: for comments, checking that a line starts</span>
        <span class="s0">#   by % should be enough and faster, and for empty lines, same thing</span>
        <span class="s0">#   --&gt; this does not seem to change anything.</span>

        <span class="s0"># 'compiling' the range since it does not change</span>
        <span class="s0"># Note, I have already tried zipping the converters and</span>
        <span class="s0"># row elements and got slightly worse performance.</span>
        <span class="s1">elems </span><span class="s4">= </span><span class="s1">list</span><span class="s4">(</span><span class="s1">range</span><span class="s4">(</span><span class="s1">ni</span><span class="s4">))</span>

        <span class="s1">dialect </span><span class="s4">= </span><span class="s2">None</span>
        <span class="s2">for </span><span class="s1">raw </span><span class="s2">in </span><span class="s1">row_iter</span><span class="s4">:</span>
            <span class="s0"># We do not abstract skipping comments and empty lines for</span>
            <span class="s0"># performance reasons.</span>
            <span class="s2">if </span><span class="s1">r_comment</span><span class="s4">.</span><span class="s1">match</span><span class="s4">(</span><span class="s1">raw</span><span class="s4">) </span><span class="s2">or </span><span class="s1">r_empty</span><span class="s4">.</span><span class="s1">match</span><span class="s4">(</span><span class="s1">raw</span><span class="s4">):</span>
                <span class="s2">continue</span>

            <span class="s1">row</span><span class="s4">, </span><span class="s1">dialect </span><span class="s4">= </span><span class="s1">split_data_line</span><span class="s4">(</span><span class="s1">raw</span><span class="s4">, </span><span class="s1">dialect</span><span class="s4">)</span>

            <span class="s2">yield </span><span class="s1">tuple</span><span class="s4">([</span><span class="s1">attr</span><span class="s4">[</span><span class="s1">i</span><span class="s4">].</span><span class="s1">parse_data</span><span class="s4">(</span><span class="s1">row</span><span class="s4">[</span><span class="s1">i</span><span class="s4">]) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">elems</span><span class="s4">])</span>

    <span class="s1">a </span><span class="s4">= </span><span class="s1">list</span><span class="s4">(</span><span class="s1">generator</span><span class="s4">(</span><span class="s1">ofile</span><span class="s4">))</span>
    <span class="s0"># No error should happen here: it is a bug otherwise</span>
    <span class="s1">data </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">array</span><span class="s4">(</span><span class="s1">a</span><span class="s4">, [(</span><span class="s1">a</span><span class="s4">.</span><span class="s1">name</span><span class="s4">, </span><span class="s1">a</span><span class="s4">.</span><span class="s1">dtype</span><span class="s4">) </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">attr</span><span class="s4">])</span>
    <span class="s2">return </span><span class="s1">data</span><span class="s4">, </span><span class="s1">meta</span>


<span class="s0"># ----</span>
<span class="s0"># Misc</span>
<span class="s0"># ----</span>
<span class="s2">def </span><span class="s1">basic_stats</span><span class="s4">(</span><span class="s1">data</span><span class="s4">):</span>
    <span class="s1">nbfac </span><span class="s4">= </span><span class="s1">data</span><span class="s4">.</span><span class="s1">size </span><span class="s4">* </span><span class="s6">1. </span><span class="s4">/ (</span><span class="s1">data</span><span class="s4">.</span><span class="s1">size </span><span class="s4">- </span><span class="s6">1</span><span class="s4">)</span>
    <span class="s2">return </span><span class="s1">np</span><span class="s4">.</span><span class="s1">nanmin</span><span class="s4">(</span><span class="s1">data</span><span class="s4">), </span><span class="s1">np</span><span class="s4">.</span><span class="s1">nanmax</span><span class="s4">(</span><span class="s1">data</span><span class="s4">), </span><span class="s1">np</span><span class="s4">.</span><span class="s1">mean</span><span class="s4">(</span><span class="s1">data</span><span class="s4">), </span><span class="s1">np</span><span class="s4">.</span><span class="s1">std</span><span class="s4">(</span><span class="s1">data</span><span class="s4">) * </span><span class="s1">nbfac</span>


<span class="s2">def </span><span class="s1">print_attribute</span><span class="s4">(</span><span class="s1">name</span><span class="s4">, </span><span class="s1">tp</span><span class="s4">, </span><span class="s1">data</span><span class="s4">):</span>
    <span class="s1">type </span><span class="s4">= </span><span class="s1">tp</span><span class="s4">.</span><span class="s1">type_name</span>
    <span class="s2">if </span><span class="s1">type </span><span class="s4">== </span><span class="s3">'numeric' </span><span class="s2">or </span><span class="s1">type </span><span class="s4">== </span><span class="s3">'real' </span><span class="s2">or </span><span class="s1">type </span><span class="s4">== </span><span class="s3">'integer'</span><span class="s4">:</span>
        <span class="s1">min</span><span class="s4">, </span><span class="s1">max</span><span class="s4">, </span><span class="s1">mean</span><span class="s4">, </span><span class="s1">std </span><span class="s4">= </span><span class="s1">basic_stats</span><span class="s4">(</span><span class="s1">data</span><span class="s4">)</span>
        <span class="s1">print</span><span class="s4">(</span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s3">,</span><span class="s2">{</span><span class="s1">type</span><span class="s2">}</span><span class="s3">,</span><span class="s2">{</span><span class="s1">min</span><span class="s2">:</span><span class="s3">f</span><span class="s2">}</span><span class="s3">,</span><span class="s2">{</span><span class="s1">max</span><span class="s2">:</span><span class="s3">f</span><span class="s2">}</span><span class="s3">,</span><span class="s2">{</span><span class="s1">mean</span><span class="s2">:</span><span class="s3">f</span><span class="s2">}</span><span class="s3">,</span><span class="s2">{</span><span class="s1">std</span><span class="s2">:</span><span class="s3">f</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s4">)</span>
    <span class="s2">else</span><span class="s4">:</span>
        <span class="s1">print</span><span class="s4">(</span><span class="s1">str</span><span class="s4">(</span><span class="s1">tp</span><span class="s4">))</span>


<span class="s2">def </span><span class="s1">test_weka</span><span class="s4">(</span><span class="s1">filename</span><span class="s4">):</span>
    <span class="s1">data</span><span class="s4">, </span><span class="s1">meta </span><span class="s4">= </span><span class="s1">loadarff</span><span class="s4">(</span><span class="s1">filename</span><span class="s4">)</span>
    <span class="s1">print</span><span class="s4">(</span><span class="s1">len</span><span class="s4">(</span><span class="s1">data</span><span class="s4">.</span><span class="s1">dtype</span><span class="s4">))</span>
    <span class="s1">print</span><span class="s4">(</span><span class="s1">data</span><span class="s4">.</span><span class="s1">size</span><span class="s4">)</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">meta</span><span class="s4">:</span>
        <span class="s1">print_attribute</span><span class="s4">(</span><span class="s1">i</span><span class="s4">, </span><span class="s1">meta</span><span class="s4">[</span><span class="s1">i</span><span class="s4">], </span><span class="s1">data</span><span class="s4">[</span><span class="s1">i</span><span class="s4">])</span>


<span class="s0"># make sure nose does not find this as a test</span>
<span class="s1">test_weka</span><span class="s4">.</span><span class="s1">__test__ </span><span class="s4">= </span><span class="s2">False</span>


<span class="s2">if </span><span class="s1">__name__ </span><span class="s4">== </span><span class="s3">'__main__'</span><span class="s4">:</span>
    <span class="s2">import </span><span class="s1">sys</span>
    <span class="s1">filename </span><span class="s4">= </span><span class="s1">sys</span><span class="s4">.</span><span class="s1">argv</span><span class="s4">[</span><span class="s6">1</span><span class="s4">]</span>
    <span class="s1">test_weka</span><span class="s4">(</span><span class="s1">filename</span><span class="s4">)</span>
</pre>
</body>
</html>