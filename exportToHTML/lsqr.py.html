<html>
<head>
<title>lsqr.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #6aab73;}
.s4 { color: #cf8e6d;}
.s5 { color: #2aacb8;}
.s6 { color: #7a7e85;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
lsqr.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Sparse Equations and Least Squares. 
 
The original Fortran code was written by C. C. Paige and M. A. Saunders as 
described in 
 
C. C. Paige and M. A. Saunders, LSQR: An algorithm for sparse linear 
equations and sparse least squares, TOMS 8(1), 43--71 (1982). 
 
C. C. Paige and M. A. Saunders, Algorithm 583; LSQR: Sparse linear 
equations and least-squares problems, TOMS 8(2), 195--209 (1982). 
 
It is licensed under the following BSD license: 
 
Copyright (c) 2006, Systems Optimization Laboratory 
All rights reserved. 
 
Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are 
met: 
 
    * Redistributions of source code must retain the above copyright 
      notice, this list of conditions and the following disclaimer. 
 
    * Redistributions in binary form must reproduce the above 
      copyright notice, this list of conditions and the following 
      disclaimer in the documentation and/or other materials provided 
      with the distribution. 
 
    * Neither the name of Stanford University nor the names of its 
      contributors may be used to endorse or promote products derived 
      from this software without specific prior written permission. 
 
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
&quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR 
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
 
The Fortran code was translated to Python for use in CVXOPT by Jeffery 
Kline with contributions by Mridul Aanjaneya and Bob Myhill. 
 
Adapted for SciPy by Stefan van der Walt. 
 
&quot;&quot;&quot;</span>

<span class="s1">__all__ </span><span class="s2">= [</span><span class="s3">'lsqr'</span><span class="s2">]</span>

<span class="s4">import </span><span class="s1">numpy </span><span class="s4">as </span><span class="s1">np</span>
<span class="s4">from </span><span class="s1">math </span><span class="s4">import </span><span class="s1">sqrt</span>
<span class="s4">from </span><span class="s1">scipy</span><span class="s2">.</span><span class="s1">sparse</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">_interface </span><span class="s4">import </span><span class="s1">aslinearoperator</span>

<span class="s1">eps </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">finfo</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">).</span><span class="s1">eps</span>


<span class="s4">def </span><span class="s1">_sym_ortho</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Stable implementation of Givens rotation. 
 
    Notes 
    ----- 
    The routine 'SymOrtho' was added for numerical stability. This is 
    recommended by S.-C. Choi in [1]_.  It removes the unpleasant potential of 
    ``1/eps`` in some important places (see, for example text following 
    &quot;Compute the next plane rotation Qk&quot; in minres.py). 
 
    References 
    ---------- 
    .. [1] S.-C. Choi, &quot;Iterative Methods for Singular Linear Equations 
           and Least-Squares Problems&quot;, Dissertation, 
           http://www.stanford.edu/group/SOL/dissertations/sou-cheng-choi-thesis.pdf 
 
    &quot;&quot;&quot;</span>
    <span class="s4">if </span><span class="s1">b </span><span class="s2">== </span><span class="s5">0</span><span class="s2">:</span>
        <span class="s4">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sign</span><span class="s2">(</span><span class="s1">a</span><span class="s2">), </span><span class="s5">0</span><span class="s2">, </span><span class="s1">abs</span><span class="s2">(</span><span class="s1">a</span><span class="s2">)</span>
    <span class="s4">elif </span><span class="s1">a </span><span class="s2">== </span><span class="s5">0</span><span class="s2">:</span>
        <span class="s4">return </span><span class="s5">0</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sign</span><span class="s2">(</span><span class="s1">b</span><span class="s2">), </span><span class="s1">abs</span><span class="s2">(</span><span class="s1">b</span><span class="s2">)</span>
    <span class="s4">elif </span><span class="s1">abs</span><span class="s2">(</span><span class="s1">b</span><span class="s2">) &gt; </span><span class="s1">abs</span><span class="s2">(</span><span class="s1">a</span><span class="s2">):</span>
        <span class="s1">tau </span><span class="s2">= </span><span class="s1">a </span><span class="s2">/ </span><span class="s1">b</span>
        <span class="s1">s </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sign</span><span class="s2">(</span><span class="s1">b</span><span class="s2">) / </span><span class="s1">sqrt</span><span class="s2">(</span><span class="s5">1 </span><span class="s2">+ </span><span class="s1">tau </span><span class="s2">* </span><span class="s1">tau</span><span class="s2">)</span>
        <span class="s1">c </span><span class="s2">= </span><span class="s1">s </span><span class="s2">* </span><span class="s1">tau</span>
        <span class="s1">r </span><span class="s2">= </span><span class="s1">b </span><span class="s2">/ </span><span class="s1">s</span>
    <span class="s4">else</span><span class="s2">:</span>
        <span class="s1">tau </span><span class="s2">= </span><span class="s1">b </span><span class="s2">/ </span><span class="s1">a</span>
        <span class="s1">c </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sign</span><span class="s2">(</span><span class="s1">a</span><span class="s2">) / </span><span class="s1">sqrt</span><span class="s2">(</span><span class="s5">1</span><span class="s2">+</span><span class="s1">tau</span><span class="s2">*</span><span class="s1">tau</span><span class="s2">)</span>
        <span class="s1">s </span><span class="s2">= </span><span class="s1">c </span><span class="s2">* </span><span class="s1">tau</span>
        <span class="s1">r </span><span class="s2">= </span><span class="s1">a </span><span class="s2">/ </span><span class="s1">c</span>
    <span class="s4">return </span><span class="s1">c</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">r</span>


<span class="s4">def </span><span class="s1">lsqr</span><span class="s2">(</span><span class="s1">A</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">damp</span><span class="s2">=</span><span class="s5">0.0</span><span class="s2">, </span><span class="s1">atol</span><span class="s2">=</span><span class="s5">1e-6</span><span class="s2">, </span><span class="s1">btol</span><span class="s2">=</span><span class="s5">1e-6</span><span class="s2">, </span><span class="s1">conlim</span><span class="s2">=</span><span class="s5">1e8</span><span class="s2">,</span>
         <span class="s1">iter_lim</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">show</span><span class="s2">=</span><span class="s4">False</span><span class="s2">, </span><span class="s1">calc_var</span><span class="s2">=</span><span class="s4">False</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">=</span><span class="s4">None</span><span class="s2">):</span>
    <span class="s0">&quot;&quot;&quot;Find the least-squares solution to a large, sparse, linear system 
    of equations. 
 
    The function solves ``Ax = b``  or  ``min ||Ax - b||^2`` or 
    ``min ||Ax - b||^2 + d^2 ||x - x0||^2``. 
 
    The matrix A may be square or rectangular (over-determined or 
    under-determined), and may have any rank. 
 
    :: 
 
      1. Unsymmetric equations --    solve  Ax = b 
 
      2. Linear least squares  --    solve  Ax = b 
                                     in the least-squares sense 
 
      3. Damped least squares  --    solve  (   A    )*x = (    b    ) 
                                            ( damp*I )     ( damp*x0 ) 
                                     in the least-squares sense 
 
    Parameters 
    ---------- 
    A : {sparse matrix, ndarray, LinearOperator} 
        Representation of an m-by-n matrix. 
        Alternatively, ``A`` can be a linear operator which can 
        produce ``Ax`` and ``A^T x`` using, e.g., 
        ``scipy.sparse.linalg.LinearOperator``. 
    b : array_like, shape (m,) 
        Right-hand side vector ``b``. 
    damp : float 
        Damping coefficient. Default is 0. 
    atol, btol : float, optional 
        Stopping tolerances. `lsqr` continues iterations until a 
        certain backward error estimate is smaller than some quantity 
        depending on atol and btol.  Let ``r = b - Ax`` be the 
        residual vector for the current approximate solution ``x``. 
        If ``Ax = b`` seems to be consistent, `lsqr` terminates 
        when ``norm(r) &lt;= atol * norm(A) * norm(x) + btol * norm(b)``. 
        Otherwise, `lsqr` terminates when ``norm(A^H r) &lt;= 
        atol * norm(A) * norm(r)``.  If both tolerances are 1.0e-6 (default), 
        the final ``norm(r)`` should be accurate to about 6 
        digits. (The final ``x`` will usually have fewer correct digits, 
        depending on ``cond(A)`` and the size of LAMBDA.)  If `atol` 
        or `btol` is None, a default value of 1.0e-6 will be used. 
        Ideally, they should be estimates of the relative error in the 
        entries of ``A`` and ``b`` respectively.  For example, if the entries 
        of ``A`` have 7 correct digits, set ``atol = 1e-7``. This prevents 
        the algorithm from doing unnecessary work beyond the 
        uncertainty of the input data. 
    conlim : float, optional 
        Another stopping tolerance.  lsqr terminates if an estimate of 
        ``cond(A)`` exceeds `conlim`.  For compatible systems ``Ax = 
        b``, `conlim` could be as large as 1.0e+12 (say).  For 
        least-squares problems, conlim should be less than 1.0e+8. 
        Maximum precision can be obtained by setting ``atol = btol = 
        conlim = zero``, but the number of iterations may then be 
        excessive. Default is 1e8. 
    iter_lim : int, optional 
        Explicit limitation on number of iterations (for safety). 
    show : bool, optional 
        Display an iteration log. Default is False. 
    calc_var : bool, optional 
        Whether to estimate diagonals of ``(A'A + damp^2*I)^{-1}``. 
    x0 : array_like, shape (n,), optional 
        Initial guess of x, if None zeros are used. Default is None. 
 
        .. versionadded:: 1.0.0 
 
    Returns 
    ------- 
    x : ndarray of float 
        The final solution. 
    istop : int 
        Gives the reason for termination. 
        1 means x is an approximate solution to Ax = b. 
        2 means x approximately solves the least-squares problem. 
    itn : int 
        Iteration number upon termination. 
    r1norm : float 
        ``norm(r)``, where ``r = b - Ax``. 
    r2norm : float 
        ``sqrt( norm(r)^2  +  damp^2 * norm(x - x0)^2 )``.  Equal to `r1norm` 
        if ``damp == 0``. 
    anorm : float 
        Estimate of Frobenius norm of ``Abar = [[A]; [damp*I]]``. 
    acond : float 
        Estimate of ``cond(Abar)``. 
    arnorm : float 
        Estimate of ``norm(A'@r - damp^2*(x - x0))``. 
    xnorm : float 
        ``norm(x)`` 
    var : ndarray of float 
        If ``calc_var`` is True, estimates all diagonals of 
        ``(A'A)^{-1}`` (if ``damp == 0``) or more generally ``(A'A + 
        damp^2*I)^{-1}``.  This is well defined if A has full column 
        rank or ``damp &gt; 0``.  (Not sure what var means if ``rank(A) 
        &lt; n`` and ``damp = 0.``) 
 
    Notes 
    ----- 
    LSQR uses an iterative method to approximate the solution.  The 
    number of iterations required to reach a certain accuracy depends 
    strongly on the scaling of the problem.  Poor scaling of the rows 
    or columns of A should therefore be avoided where possible. 
 
    For example, in problem 1 the solution is unaltered by 
    row-scaling.  If a row of A is very small or large compared to 
    the other rows of A, the corresponding row of ( A  b ) should be 
    scaled up or down. 
 
    In problems 1 and 2, the solution x is easily recovered 
    following column-scaling.  Unless better information is known, 
    the nonzero columns of A should be scaled so that they all have 
    the same Euclidean norm (e.g., 1.0). 
 
    In problem 3, there is no freedom to re-scale if damp is 
    nonzero.  However, the value of damp should be assigned only 
    after attention has been paid to the scaling of A. 
 
    The parameter damp is intended to help regularize 
    ill-conditioned systems, by preventing the true solution from 
    being very large.  Another aid to regularization is provided by 
    the parameter acond, which may be used to terminate iterations 
    before the computed solution becomes very large. 
 
    If some initial estimate ``x0`` is known and if ``damp == 0``, 
    one could proceed as follows: 
 
      1. Compute a residual vector ``r0 = b - A@x0``. 
      2. Use LSQR to solve the system  ``A@dx = r0``. 
      3. Add the correction dx to obtain a final solution ``x = x0 + dx``. 
 
    This requires that ``x0`` be available before and after the call 
    to LSQR.  To judge the benefits, suppose LSQR takes k1 iterations 
    to solve A@x = b and k2 iterations to solve A@dx = r0. 
    If x0 is &quot;good&quot;, norm(r0) will be smaller than norm(b). 
    If the same stopping tolerances atol and btol are used for each 
    system, k1 and k2 will be similar, but the final solution x0 + dx 
    should be more accurate.  The only way to reduce the total work 
    is to use a larger stopping tolerance for the second system. 
    If some value btol is suitable for A@x = b, the larger value 
    btol*norm(b)/norm(r0)  should be suitable for A@dx = r0. 
 
    Preconditioning is another way to reduce the number of iterations. 
    If it is possible to solve a related system ``M@x = b`` 
    efficiently, where M approximates A in some helpful way (e.g. M - 
    A has low rank or its elements are small relative to those of A), 
    LSQR may converge more rapidly on the system ``A@M(inverse)@z = 
    b``, after which x can be recovered by solving M@x = z. 
 
    If A is symmetric, LSQR should not be used! 
 
    Alternatives are the symmetric conjugate-gradient method (cg) 
    and/or SYMMLQ.  SYMMLQ is an implementation of symmetric cg that 
    applies to any symmetric A and will converge more rapidly than 
    LSQR.  If A is positive definite, there are other implementations 
    of symmetric cg that require slightly less work per iteration than 
    SYMMLQ (but will take the same number of iterations). 
 
    References 
    ---------- 
    .. [1] C. C. Paige and M. A. Saunders (1982a). 
           &quot;LSQR: An algorithm for sparse linear equations and 
           sparse least squares&quot;, ACM TOMS 8(1), 43-71. 
    .. [2] C. C. Paige and M. A. Saunders (1982b). 
           &quot;Algorithm 583.  LSQR: Sparse linear equations and least 
           squares problems&quot;, ACM TOMS 8(2), 195-209. 
    .. [3] M. A. Saunders (1995).  &quot;Solution of sparse rectangular 
           systems using LSQR and CRAIG&quot;, BIT 35, 588-604. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.sparse import csc_matrix 
    &gt;&gt;&gt; from scipy.sparse.linalg import lsqr 
    &gt;&gt;&gt; A = csc_matrix([[1., 0.], [1., 1.], [0., 1.]], dtype=float) 
 
    The first example has the trivial solution ``[0, 0]`` 
 
    &gt;&gt;&gt; b = np.array([0., 0., 0.], dtype=float) 
    &gt;&gt;&gt; x, istop, itn, normr = lsqr(A, b)[:4] 
    &gt;&gt;&gt; istop 
    0 
    &gt;&gt;&gt; x 
    array([ 0.,  0.]) 
 
    The stopping code `istop=0` returned indicates that a vector of zeros was 
    found as a solution. The returned solution `x` indeed contains 
    ``[0., 0.]``. The next example has a non-trivial solution: 
 
    &gt;&gt;&gt; b = np.array([1., 0., -1.], dtype=float) 
    &gt;&gt;&gt; x, istop, itn, r1norm = lsqr(A, b)[:4] 
    &gt;&gt;&gt; istop 
    1 
    &gt;&gt;&gt; x 
    array([ 1., -1.]) 
    &gt;&gt;&gt; itn 
    1 
    &gt;&gt;&gt; r1norm 
    4.440892098500627e-16 
 
    As indicated by `istop=1`, `lsqr` found a solution obeying the tolerance 
    limits. The given solution ``[1., -1.]`` obviously solves the equation. The 
    remaining return values include information about the number of iterations 
    (`itn=1`) and the remaining difference of left and right side of the solved 
    equation. 
    The final example demonstrates the behavior in the case where there is no 
    solution for the equation: 
 
    &gt;&gt;&gt; b = np.array([1., 0.01, -1.], dtype=float) 
    &gt;&gt;&gt; x, istop, itn, r1norm = lsqr(A, b)[:4] 
    &gt;&gt;&gt; istop 
    2 
    &gt;&gt;&gt; x 
    array([ 1.00333333, -0.99666667]) 
    &gt;&gt;&gt; A.dot(x)-b 
    array([ 0.00333333, -0.00333333,  0.00333333]) 
    &gt;&gt;&gt; r1norm 
    0.005773502691896255 
 
    `istop` indicates that the system is inconsistent and thus `x` is rather an 
    approximate solution to the corresponding least-squares problem. `r1norm` 
    contains the norm of the minimal residual that was found. 
    &quot;&quot;&quot;</span>
    <span class="s1">A </span><span class="s2">= </span><span class="s1">aslinearoperator</span><span class="s2">(</span><span class="s1">A</span><span class="s2">)</span>
    <span class="s1">b </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">atleast_1d</span><span class="s2">(</span><span class="s1">b</span><span class="s2">)</span>
    <span class="s4">if </span><span class="s1">b</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">&gt; </span><span class="s5">1</span><span class="s2">:</span>
        <span class="s1">b </span><span class="s2">= </span><span class="s1">b</span><span class="s2">.</span><span class="s1">squeeze</span><span class="s2">()</span>

    <span class="s1">m</span><span class="s2">, </span><span class="s1">n </span><span class="s2">= </span><span class="s1">A</span><span class="s2">.</span><span class="s1">shape</span>
    <span class="s4">if </span><span class="s1">iter_lim </span><span class="s4">is None</span><span class="s2">:</span>
        <span class="s1">iter_lim </span><span class="s2">= </span><span class="s5">2 </span><span class="s2">* </span><span class="s1">n</span>
    <span class="s1">var </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">(</span><span class="s1">n</span><span class="s2">)</span>

    <span class="s1">msg </span><span class="s2">= (</span><span class="s3">'The exact solution is  x = 0                              '</span><span class="s2">,</span>
           <span class="s3">'Ax - b is small enough, given atol, btol                  '</span><span class="s2">,</span>
           <span class="s3">'The least-squares solution is good enough, given atol     '</span><span class="s2">,</span>
           <span class="s3">'The estimate of cond(Abar) has exceeded conlim            '</span><span class="s2">,</span>
           <span class="s3">'Ax - b is small enough for this machine                   '</span><span class="s2">,</span>
           <span class="s3">'The least-squares solution is good enough for this machine'</span><span class="s2">,</span>
           <span class="s3">'Cond(Abar) seems to be too large for this machine         '</span><span class="s2">,</span>
           <span class="s3">'The iteration limit has been reached                      '</span><span class="s2">)</span>

    <span class="s4">if </span><span class="s1">show</span><span class="s2">:</span>
        <span class="s1">print</span><span class="s2">(</span><span class="s3">' '</span><span class="s2">)</span>
        <span class="s1">print</span><span class="s2">(</span><span class="s3">'LSQR            Least-squares solution of  Ax = b'</span><span class="s2">)</span>
        <span class="s1">str1 </span><span class="s2">= </span><span class="s3">f'The matrix A has </span><span class="s4">{</span><span class="s1">m</span><span class="s4">} </span><span class="s3">rows and </span><span class="s4">{</span><span class="s1">n</span><span class="s4">} </span><span class="s3">columns'</span>
        <span class="s1">str2 </span><span class="s2">= </span><span class="s3">f'damp = </span><span class="s4">{</span><span class="s1">damp</span><span class="s4">:</span><span class="s3">20.14e</span><span class="s4">}   </span><span class="s3">calc_var = </span><span class="s4">{</span><span class="s1">calc_var</span><span class="s4">:</span><span class="s3">8g</span><span class="s4">}</span><span class="s3">'</span>
        <span class="s1">str3 </span><span class="s2">= </span><span class="s3">f'atol = </span><span class="s4">{</span><span class="s1">atol</span><span class="s4">:</span><span class="s3">8.2e</span><span class="s4">}                 </span><span class="s3">conlim = </span><span class="s4">{</span><span class="s1">conlim</span><span class="s4">:</span><span class="s3">8.2e</span><span class="s4">}</span><span class="s3">'</span>
        <span class="s1">str4 </span><span class="s2">= </span><span class="s3">f'btol = </span><span class="s4">{</span><span class="s1">btol</span><span class="s4">:</span><span class="s3">8.2e</span><span class="s4">}               </span><span class="s3">iter_lim = </span><span class="s4">{</span><span class="s1">iter_lim</span><span class="s4">:</span><span class="s3">8g</span><span class="s4">}</span><span class="s3">'</span>
        <span class="s1">print</span><span class="s2">(</span><span class="s1">str1</span><span class="s2">)</span>
        <span class="s1">print</span><span class="s2">(</span><span class="s1">str2</span><span class="s2">)</span>
        <span class="s1">print</span><span class="s2">(</span><span class="s1">str3</span><span class="s2">)</span>
        <span class="s1">print</span><span class="s2">(</span><span class="s1">str4</span><span class="s2">)</span>

    <span class="s1">itn </span><span class="s2">= </span><span class="s5">0</span>
    <span class="s1">istop </span><span class="s2">= </span><span class="s5">0</span>
    <span class="s1">ctol </span><span class="s2">= </span><span class="s5">0</span>
    <span class="s4">if </span><span class="s1">conlim </span><span class="s2">&gt; </span><span class="s5">0</span><span class="s2">:</span>
        <span class="s1">ctol </span><span class="s2">= </span><span class="s5">1</span><span class="s2">/</span><span class="s1">conlim</span>
    <span class="s1">anorm </span><span class="s2">= </span><span class="s5">0</span>
    <span class="s1">acond </span><span class="s2">= </span><span class="s5">0</span>
    <span class="s1">dampsq </span><span class="s2">= </span><span class="s1">damp</span><span class="s2">**</span><span class="s5">2</span>
    <span class="s1">ddnorm </span><span class="s2">= </span><span class="s5">0</span>
    <span class="s1">res2 </span><span class="s2">= </span><span class="s5">0</span>
    <span class="s1">xnorm </span><span class="s2">= </span><span class="s5">0</span>
    <span class="s1">xxnorm </span><span class="s2">= </span><span class="s5">0</span>
    <span class="s1">z </span><span class="s2">= </span><span class="s5">0</span>
    <span class="s1">cs2 </span><span class="s2">= -</span><span class="s5">1</span>
    <span class="s1">sn2 </span><span class="s2">= </span><span class="s5">0</span>

    <span class="s6"># Set up the first vectors u and v for the bidiagonalization.</span>
    <span class="s6"># These satisfy  beta*u = b - A@x,  alfa*v = A'@u.</span>
    <span class="s1">u </span><span class="s2">= </span><span class="s1">b</span>
    <span class="s1">bnorm </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">norm</span><span class="s2">(</span><span class="s1">b</span><span class="s2">)</span>

    <span class="s4">if </span><span class="s1">x0 </span><span class="s4">is None</span><span class="s2">:</span>
        <span class="s1">x </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">(</span><span class="s1">n</span><span class="s2">)</span>
        <span class="s1">beta </span><span class="s2">= </span><span class="s1">bnorm</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>
    <span class="s4">else</span><span class="s2">:</span>
        <span class="s1">x </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">x0</span><span class="s2">)</span>
        <span class="s1">u </span><span class="s2">= </span><span class="s1">u </span><span class="s2">- </span><span class="s1">A</span><span class="s2">.</span><span class="s1">matvec</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)</span>
        <span class="s1">beta </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">norm</span><span class="s2">(</span><span class="s1">u</span><span class="s2">)</span>

    <span class="s4">if </span><span class="s1">beta </span><span class="s2">&gt; </span><span class="s5">0</span><span class="s2">:</span>
        <span class="s1">u </span><span class="s2">= (</span><span class="s5">1</span><span class="s2">/</span><span class="s1">beta</span><span class="s2">) * </span><span class="s1">u</span>
        <span class="s1">v </span><span class="s2">= </span><span class="s1">A</span><span class="s2">.</span><span class="s1">rmatvec</span><span class="s2">(</span><span class="s1">u</span><span class="s2">)</span>
        <span class="s1">alfa </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">norm</span><span class="s2">(</span><span class="s1">v</span><span class="s2">)</span>
    <span class="s4">else</span><span class="s2">:</span>
        <span class="s1">v </span><span class="s2">= </span><span class="s1">x</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>
        <span class="s1">alfa </span><span class="s2">= </span><span class="s5">0</span>

    <span class="s4">if </span><span class="s1">alfa </span><span class="s2">&gt; </span><span class="s5">0</span><span class="s2">:</span>
        <span class="s1">v </span><span class="s2">= (</span><span class="s5">1</span><span class="s2">/</span><span class="s1">alfa</span><span class="s2">) * </span><span class="s1">v</span>
    <span class="s1">w </span><span class="s2">= </span><span class="s1">v</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>

    <span class="s1">rhobar </span><span class="s2">= </span><span class="s1">alfa</span>
    <span class="s1">phibar </span><span class="s2">= </span><span class="s1">beta</span>
    <span class="s1">rnorm </span><span class="s2">= </span><span class="s1">beta</span>
    <span class="s1">r1norm </span><span class="s2">= </span><span class="s1">rnorm</span>
    <span class="s1">r2norm </span><span class="s2">= </span><span class="s1">rnorm</span>

    <span class="s6"># Reverse the order here from the original matlab code because</span>
    <span class="s6"># there was an error on return when arnorm==0</span>
    <span class="s1">arnorm </span><span class="s2">= </span><span class="s1">alfa </span><span class="s2">* </span><span class="s1">beta</span>
    <span class="s4">if </span><span class="s1">arnorm </span><span class="s2">== </span><span class="s5">0</span><span class="s2">:</span>
        <span class="s4">if </span><span class="s1">show</span><span class="s2">:</span>
            <span class="s1">print</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">[</span><span class="s5">0</span><span class="s2">])</span>
        <span class="s4">return </span><span class="s1">x</span><span class="s2">, </span><span class="s1">istop</span><span class="s2">, </span><span class="s1">itn</span><span class="s2">, </span><span class="s1">r1norm</span><span class="s2">, </span><span class="s1">r2norm</span><span class="s2">, </span><span class="s1">anorm</span><span class="s2">, </span><span class="s1">acond</span><span class="s2">, </span><span class="s1">arnorm</span><span class="s2">, </span><span class="s1">xnorm</span><span class="s2">, </span><span class="s1">var</span>

    <span class="s1">head1 </span><span class="s2">= </span><span class="s3">'   Itn      x[0]       r1norm     r2norm '</span>
    <span class="s1">head2 </span><span class="s2">= </span><span class="s3">' Compatible    LS      Norm A   Cond A'</span>

    <span class="s4">if </span><span class="s1">show</span><span class="s2">:</span>
        <span class="s1">print</span><span class="s2">(</span><span class="s3">' '</span><span class="s2">)</span>
        <span class="s1">print</span><span class="s2">(</span><span class="s1">head1</span><span class="s2">, </span><span class="s1">head2</span><span class="s2">)</span>
        <span class="s1">test1 </span><span class="s2">= </span><span class="s5">1</span>
        <span class="s1">test2 </span><span class="s2">= </span><span class="s1">alfa </span><span class="s2">/ </span><span class="s1">beta</span>
        <span class="s1">str1 </span><span class="s2">= </span><span class="s3">f'</span><span class="s4">{</span><span class="s1">itn</span><span class="s4">:</span><span class="s3">6g</span><span class="s4">} {</span><span class="s1">x</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]</span><span class="s4">:</span><span class="s3">12.5e</span><span class="s4">}</span><span class="s3">'</span>
        <span class="s1">str2 </span><span class="s2">= </span><span class="s3">f' </span><span class="s4">{</span><span class="s1">r1norm</span><span class="s4">:</span><span class="s3">10.3e</span><span class="s4">} {</span><span class="s1">r2norm</span><span class="s4">:</span><span class="s3">10.3e</span><span class="s4">}</span><span class="s3">'</span>
        <span class="s1">str3 </span><span class="s2">= </span><span class="s3">f'  </span><span class="s4">{</span><span class="s1">test1</span><span class="s4">:</span><span class="s3">8.1e</span><span class="s4">} {</span><span class="s1">test2</span><span class="s4">:</span><span class="s3">8.1e</span><span class="s4">}</span><span class="s3">'</span>
        <span class="s1">print</span><span class="s2">(</span><span class="s1">str1</span><span class="s2">, </span><span class="s1">str2</span><span class="s2">, </span><span class="s1">str3</span><span class="s2">)</span>

    <span class="s6"># Main iteration loop.</span>
    <span class="s4">while </span><span class="s1">itn </span><span class="s2">&lt; </span><span class="s1">iter_lim</span><span class="s2">:</span>
        <span class="s1">itn </span><span class="s2">= </span><span class="s1">itn </span><span class="s2">+ </span><span class="s5">1</span>
        <span class="s6"># Perform the next step of the bidiagonalization to obtain the</span>
        <span class="s6"># next  beta, u, alfa, v. These satisfy the relations</span>
        <span class="s6">#     beta*u  =  a@v   -  alfa*u,</span>
        <span class="s6">#     alfa*v  =  A'@u  -  beta*v.</span>
        <span class="s1">u </span><span class="s2">= </span><span class="s1">A</span><span class="s2">.</span><span class="s1">matvec</span><span class="s2">(</span><span class="s1">v</span><span class="s2">) - </span><span class="s1">alfa </span><span class="s2">* </span><span class="s1">u</span>
        <span class="s1">beta </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">norm</span><span class="s2">(</span><span class="s1">u</span><span class="s2">)</span>

        <span class="s4">if </span><span class="s1">beta </span><span class="s2">&gt; </span><span class="s5">0</span><span class="s2">:</span>
            <span class="s1">u </span><span class="s2">= (</span><span class="s5">1</span><span class="s2">/</span><span class="s1">beta</span><span class="s2">) * </span><span class="s1">u</span>
            <span class="s1">anorm </span><span class="s2">= </span><span class="s1">sqrt</span><span class="s2">(</span><span class="s1">anorm</span><span class="s2">**</span><span class="s5">2 </span><span class="s2">+ </span><span class="s1">alfa</span><span class="s2">**</span><span class="s5">2 </span><span class="s2">+ </span><span class="s1">beta</span><span class="s2">**</span><span class="s5">2 </span><span class="s2">+ </span><span class="s1">dampsq</span><span class="s2">)</span>
            <span class="s1">v </span><span class="s2">= </span><span class="s1">A</span><span class="s2">.</span><span class="s1">rmatvec</span><span class="s2">(</span><span class="s1">u</span><span class="s2">) - </span><span class="s1">beta </span><span class="s2">* </span><span class="s1">v</span>
            <span class="s1">alfa </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">norm</span><span class="s2">(</span><span class="s1">v</span><span class="s2">)</span>
            <span class="s4">if </span><span class="s1">alfa </span><span class="s2">&gt; </span><span class="s5">0</span><span class="s2">:</span>
                <span class="s1">v </span><span class="s2">= (</span><span class="s5">1 </span><span class="s2">/ </span><span class="s1">alfa</span><span class="s2">) * </span><span class="s1">v</span>

        <span class="s6"># Use a plane rotation to eliminate the damping parameter.</span>
        <span class="s6"># This alters the diagonal (rhobar) of the lower-bidiagonal matrix.</span>
        <span class="s4">if </span><span class="s1">damp </span><span class="s2">&gt; </span><span class="s5">0</span><span class="s2">:</span>
            <span class="s1">rhobar1 </span><span class="s2">= </span><span class="s1">sqrt</span><span class="s2">(</span><span class="s1">rhobar</span><span class="s2">**</span><span class="s5">2 </span><span class="s2">+ </span><span class="s1">dampsq</span><span class="s2">)</span>
            <span class="s1">cs1 </span><span class="s2">= </span><span class="s1">rhobar </span><span class="s2">/ </span><span class="s1">rhobar1</span>
            <span class="s1">sn1 </span><span class="s2">= </span><span class="s1">damp </span><span class="s2">/ </span><span class="s1">rhobar1</span>
            <span class="s1">psi </span><span class="s2">= </span><span class="s1">sn1 </span><span class="s2">* </span><span class="s1">phibar</span>
            <span class="s1">phibar </span><span class="s2">= </span><span class="s1">cs1 </span><span class="s2">* </span><span class="s1">phibar</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s6"># cs1 = 1 and sn1 = 0</span>
            <span class="s1">rhobar1 </span><span class="s2">= </span><span class="s1">rhobar</span>
            <span class="s1">psi </span><span class="s2">= </span><span class="s5">0.</span>

        <span class="s6"># Use a plane rotation to eliminate the subdiagonal element (beta)</span>
        <span class="s6"># of the lower-bidiagonal matrix, giving an upper-bidiagonal matrix.</span>
        <span class="s1">cs</span><span class="s2">, </span><span class="s1">sn</span><span class="s2">, </span><span class="s1">rho </span><span class="s2">= </span><span class="s1">_sym_ortho</span><span class="s2">(</span><span class="s1">rhobar1</span><span class="s2">, </span><span class="s1">beta</span><span class="s2">)</span>

        <span class="s1">theta </span><span class="s2">= </span><span class="s1">sn </span><span class="s2">* </span><span class="s1">alfa</span>
        <span class="s1">rhobar </span><span class="s2">= -</span><span class="s1">cs </span><span class="s2">* </span><span class="s1">alfa</span>
        <span class="s1">phi </span><span class="s2">= </span><span class="s1">cs </span><span class="s2">* </span><span class="s1">phibar</span>
        <span class="s1">phibar </span><span class="s2">= </span><span class="s1">sn </span><span class="s2">* </span><span class="s1">phibar</span>
        <span class="s1">tau </span><span class="s2">= </span><span class="s1">sn </span><span class="s2">* </span><span class="s1">phi</span>

        <span class="s6"># Update x and w.</span>
        <span class="s1">t1 </span><span class="s2">= </span><span class="s1">phi </span><span class="s2">/ </span><span class="s1">rho</span>
        <span class="s1">t2 </span><span class="s2">= -</span><span class="s1">theta </span><span class="s2">/ </span><span class="s1">rho</span>
        <span class="s1">dk </span><span class="s2">= (</span><span class="s5">1 </span><span class="s2">/ </span><span class="s1">rho</span><span class="s2">) * </span><span class="s1">w</span>

        <span class="s1">x </span><span class="s2">= </span><span class="s1">x </span><span class="s2">+ </span><span class="s1">t1 </span><span class="s2">* </span><span class="s1">w</span>
        <span class="s1">w </span><span class="s2">= </span><span class="s1">v </span><span class="s2">+ </span><span class="s1">t2 </span><span class="s2">* </span><span class="s1">w</span>
        <span class="s1">ddnorm </span><span class="s2">= </span><span class="s1">ddnorm </span><span class="s2">+ </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">norm</span><span class="s2">(</span><span class="s1">dk</span><span class="s2">)**</span><span class="s5">2</span>

        <span class="s4">if </span><span class="s1">calc_var</span><span class="s2">:</span>
            <span class="s1">var </span><span class="s2">= </span><span class="s1">var </span><span class="s2">+ </span><span class="s1">dk</span><span class="s2">**</span><span class="s5">2</span>

        <span class="s6"># Use a plane rotation on the right to eliminate the</span>
        <span class="s6"># super-diagonal element (theta) of the upper-bidiagonal matrix.</span>
        <span class="s6"># Then use the result to estimate norm(x).</span>
        <span class="s1">delta </span><span class="s2">= </span><span class="s1">sn2 </span><span class="s2">* </span><span class="s1">rho</span>
        <span class="s1">gambar </span><span class="s2">= -</span><span class="s1">cs2 </span><span class="s2">* </span><span class="s1">rho</span>
        <span class="s1">rhs </span><span class="s2">= </span><span class="s1">phi </span><span class="s2">- </span><span class="s1">delta </span><span class="s2">* </span><span class="s1">z</span>
        <span class="s1">zbar </span><span class="s2">= </span><span class="s1">rhs </span><span class="s2">/ </span><span class="s1">gambar</span>
        <span class="s1">xnorm </span><span class="s2">= </span><span class="s1">sqrt</span><span class="s2">(</span><span class="s1">xxnorm </span><span class="s2">+ </span><span class="s1">zbar</span><span class="s2">**</span><span class="s5">2</span><span class="s2">)</span>
        <span class="s1">gamma </span><span class="s2">= </span><span class="s1">sqrt</span><span class="s2">(</span><span class="s1">gambar</span><span class="s2">**</span><span class="s5">2 </span><span class="s2">+ </span><span class="s1">theta</span><span class="s2">**</span><span class="s5">2</span><span class="s2">)</span>
        <span class="s1">cs2 </span><span class="s2">= </span><span class="s1">gambar </span><span class="s2">/ </span><span class="s1">gamma</span>
        <span class="s1">sn2 </span><span class="s2">= </span><span class="s1">theta </span><span class="s2">/ </span><span class="s1">gamma</span>
        <span class="s1">z </span><span class="s2">= </span><span class="s1">rhs </span><span class="s2">/ </span><span class="s1">gamma</span>
        <span class="s1">xxnorm </span><span class="s2">= </span><span class="s1">xxnorm </span><span class="s2">+ </span><span class="s1">z</span><span class="s2">**</span><span class="s5">2</span>

        <span class="s6"># Test for convergence.</span>
        <span class="s6"># First, estimate the condition of the matrix  Abar,</span>
        <span class="s6"># and the norms of  rbar  and  Abar'rbar.</span>
        <span class="s1">acond </span><span class="s2">= </span><span class="s1">anorm </span><span class="s2">* </span><span class="s1">sqrt</span><span class="s2">(</span><span class="s1">ddnorm</span><span class="s2">)</span>
        <span class="s1">res1 </span><span class="s2">= </span><span class="s1">phibar</span><span class="s2">**</span><span class="s5">2</span>
        <span class="s1">res2 </span><span class="s2">= </span><span class="s1">res2 </span><span class="s2">+ </span><span class="s1">psi</span><span class="s2">**</span><span class="s5">2</span>
        <span class="s1">rnorm </span><span class="s2">= </span><span class="s1">sqrt</span><span class="s2">(</span><span class="s1">res1 </span><span class="s2">+ </span><span class="s1">res2</span><span class="s2">)</span>
        <span class="s1">arnorm </span><span class="s2">= </span><span class="s1">alfa </span><span class="s2">* </span><span class="s1">abs</span><span class="s2">(</span><span class="s1">tau</span><span class="s2">)</span>

        <span class="s6"># Distinguish between</span>
        <span class="s6">#    r1norm = ||b - Ax|| and</span>
        <span class="s6">#    r2norm = rnorm in current code</span>
        <span class="s6">#           = sqrt(r1norm^2 + damp^2*||x - x0||^2).</span>
        <span class="s6">#    Estimate r1norm from</span>
        <span class="s6">#    r1norm = sqrt(r2norm^2 - damp^2*||x - x0||^2).</span>
        <span class="s6"># Although there is cancellation, it might be accurate enough.</span>
        <span class="s4">if </span><span class="s1">damp </span><span class="s2">&gt; </span><span class="s5">0</span><span class="s2">:</span>
            <span class="s1">r1sq </span><span class="s2">= </span><span class="s1">rnorm</span><span class="s2">**</span><span class="s5">2 </span><span class="s2">- </span><span class="s1">dampsq </span><span class="s2">* </span><span class="s1">xxnorm</span>
            <span class="s1">r1norm </span><span class="s2">= </span><span class="s1">sqrt</span><span class="s2">(</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">r1sq</span><span class="s2">))</span>
            <span class="s4">if </span><span class="s1">r1sq </span><span class="s2">&lt; </span><span class="s5">0</span><span class="s2">:</span>
                <span class="s1">r1norm </span><span class="s2">= -</span><span class="s1">r1norm</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">r1norm </span><span class="s2">= </span><span class="s1">rnorm</span>
        <span class="s1">r2norm </span><span class="s2">= </span><span class="s1">rnorm</span>

        <span class="s6"># Now use these norms to estimate certain other quantities,</span>
        <span class="s6"># some of which will be small near a solution.</span>
        <span class="s1">test1 </span><span class="s2">= </span><span class="s1">rnorm </span><span class="s2">/ </span><span class="s1">bnorm</span>
        <span class="s1">test2 </span><span class="s2">= </span><span class="s1">arnorm </span><span class="s2">/ (</span><span class="s1">anorm </span><span class="s2">* </span><span class="s1">rnorm </span><span class="s2">+ </span><span class="s1">eps</span><span class="s2">)</span>
        <span class="s1">test3 </span><span class="s2">= </span><span class="s5">1 </span><span class="s2">/ (</span><span class="s1">acond </span><span class="s2">+ </span><span class="s1">eps</span><span class="s2">)</span>
        <span class="s1">t1 </span><span class="s2">= </span><span class="s1">test1 </span><span class="s2">/ (</span><span class="s5">1 </span><span class="s2">+ </span><span class="s1">anorm </span><span class="s2">* </span><span class="s1">xnorm </span><span class="s2">/ </span><span class="s1">bnorm</span><span class="s2">)</span>
        <span class="s1">rtol </span><span class="s2">= </span><span class="s1">btol </span><span class="s2">+ </span><span class="s1">atol </span><span class="s2">* </span><span class="s1">anorm </span><span class="s2">* </span><span class="s1">xnorm </span><span class="s2">/ </span><span class="s1">bnorm</span>

        <span class="s6"># The following tests guard against extremely small values of</span>
        <span class="s6"># atol, btol  or  ctol.  (The user may have set any or all of</span>
        <span class="s6"># the parameters  atol, btol, conlim  to 0.)</span>
        <span class="s6"># The effect is equivalent to the normal tests using</span>
        <span class="s6"># atol = eps,  btol = eps,  conlim = 1/eps.</span>
        <span class="s4">if </span><span class="s1">itn </span><span class="s2">&gt;= </span><span class="s1">iter_lim</span><span class="s2">:</span>
            <span class="s1">istop </span><span class="s2">= </span><span class="s5">7</span>
        <span class="s4">if </span><span class="s5">1 </span><span class="s2">+ </span><span class="s1">test3 </span><span class="s2">&lt;= </span><span class="s5">1</span><span class="s2">:</span>
            <span class="s1">istop </span><span class="s2">= </span><span class="s5">6</span>
        <span class="s4">if </span><span class="s5">1 </span><span class="s2">+ </span><span class="s1">test2 </span><span class="s2">&lt;= </span><span class="s5">1</span><span class="s2">:</span>
            <span class="s1">istop </span><span class="s2">= </span><span class="s5">5</span>
        <span class="s4">if </span><span class="s5">1 </span><span class="s2">+ </span><span class="s1">t1 </span><span class="s2">&lt;= </span><span class="s5">1</span><span class="s2">:</span>
            <span class="s1">istop </span><span class="s2">= </span><span class="s5">4</span>

        <span class="s6"># Allow for tolerances set by the user.</span>
        <span class="s4">if </span><span class="s1">test3 </span><span class="s2">&lt;= </span><span class="s1">ctol</span><span class="s2">:</span>
            <span class="s1">istop </span><span class="s2">= </span><span class="s5">3</span>
        <span class="s4">if </span><span class="s1">test2 </span><span class="s2">&lt;= </span><span class="s1">atol</span><span class="s2">:</span>
            <span class="s1">istop </span><span class="s2">= </span><span class="s5">2</span>
        <span class="s4">if </span><span class="s1">test1 </span><span class="s2">&lt;= </span><span class="s1">rtol</span><span class="s2">:</span>
            <span class="s1">istop </span><span class="s2">= </span><span class="s5">1</span>

        <span class="s4">if </span><span class="s1">show</span><span class="s2">:</span>
            <span class="s6"># See if it is time to print something.</span>
            <span class="s1">prnt </span><span class="s2">= </span><span class="s4">False</span>
            <span class="s4">if </span><span class="s1">n </span><span class="s2">&lt;= </span><span class="s5">40</span><span class="s2">:</span>
                <span class="s1">prnt </span><span class="s2">= </span><span class="s4">True</span>
            <span class="s4">if </span><span class="s1">itn </span><span class="s2">&lt;= </span><span class="s5">10</span><span class="s2">:</span>
                <span class="s1">prnt </span><span class="s2">= </span><span class="s4">True</span>
            <span class="s4">if </span><span class="s1">itn </span><span class="s2">&gt;= </span><span class="s1">iter_lim</span><span class="s2">-</span><span class="s5">10</span><span class="s2">:</span>
                <span class="s1">prnt </span><span class="s2">= </span><span class="s4">True</span>
            <span class="s6"># if itn%10 == 0: prnt = True</span>
            <span class="s4">if </span><span class="s1">test3 </span><span class="s2">&lt;= </span><span class="s5">2</span><span class="s2">*</span><span class="s1">ctol</span><span class="s2">:</span>
                <span class="s1">prnt </span><span class="s2">= </span><span class="s4">True</span>
            <span class="s4">if </span><span class="s1">test2 </span><span class="s2">&lt;= </span><span class="s5">10</span><span class="s2">*</span><span class="s1">atol</span><span class="s2">:</span>
                <span class="s1">prnt </span><span class="s2">= </span><span class="s4">True</span>
            <span class="s4">if </span><span class="s1">test1 </span><span class="s2">&lt;= </span><span class="s5">10</span><span class="s2">*</span><span class="s1">rtol</span><span class="s2">:</span>
                <span class="s1">prnt </span><span class="s2">= </span><span class="s4">True</span>
            <span class="s4">if </span><span class="s1">istop </span><span class="s2">!= </span><span class="s5">0</span><span class="s2">:</span>
                <span class="s1">prnt </span><span class="s2">= </span><span class="s4">True</span>

            <span class="s4">if </span><span class="s1">prnt</span><span class="s2">:</span>
                <span class="s1">str1 </span><span class="s2">= </span><span class="s3">f'</span><span class="s4">{</span><span class="s1">itn</span><span class="s4">:</span><span class="s3">6g</span><span class="s4">} {</span><span class="s1">x</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]</span><span class="s4">:</span><span class="s3">12.5e</span><span class="s4">}</span><span class="s3">'</span>
                <span class="s1">str2 </span><span class="s2">= </span><span class="s3">f' </span><span class="s4">{</span><span class="s1">r1norm</span><span class="s4">:</span><span class="s3">10.3e</span><span class="s4">} {</span><span class="s1">r2norm</span><span class="s4">:</span><span class="s3">10.3e</span><span class="s4">}</span><span class="s3">'</span>
                <span class="s1">str3 </span><span class="s2">= </span><span class="s3">f'  </span><span class="s4">{</span><span class="s1">test1</span><span class="s4">:</span><span class="s3">8.1e</span><span class="s4">} {</span><span class="s1">test2</span><span class="s4">:</span><span class="s3">8.1e</span><span class="s4">}</span><span class="s3">'</span>
                <span class="s1">str4 </span><span class="s2">= </span><span class="s3">f' </span><span class="s4">{</span><span class="s1">anorm</span><span class="s4">:</span><span class="s3">8.1e</span><span class="s4">} {</span><span class="s1">acond</span><span class="s4">:</span><span class="s3">8.1e</span><span class="s4">}</span><span class="s3">'</span>
                <span class="s1">print</span><span class="s2">(</span><span class="s1">str1</span><span class="s2">, </span><span class="s1">str2</span><span class="s2">, </span><span class="s1">str3</span><span class="s2">, </span><span class="s1">str4</span><span class="s2">)</span>

        <span class="s4">if </span><span class="s1">istop </span><span class="s2">!= </span><span class="s5">0</span><span class="s2">:</span>
            <span class="s4">break</span>

    <span class="s6"># End of iteration loop.</span>
    <span class="s6"># Print the stopping condition.</span>
    <span class="s4">if </span><span class="s1">show</span><span class="s2">:</span>
        <span class="s1">print</span><span class="s2">(</span><span class="s3">' '</span><span class="s2">)</span>
        <span class="s1">print</span><span class="s2">(</span><span class="s3">'LSQR finished'</span><span class="s2">)</span>
        <span class="s1">print</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">[</span><span class="s1">istop</span><span class="s2">])</span>
        <span class="s1">print</span><span class="s2">(</span><span class="s3">' '</span><span class="s2">)</span>
        <span class="s1">str1 </span><span class="s2">= </span><span class="s3">f'istop =</span><span class="s4">{</span><span class="s1">istop</span><span class="s4">:</span><span class="s3">8g</span><span class="s4">}   </span><span class="s3">r1norm =</span><span class="s4">{</span><span class="s1">r1norm</span><span class="s4">:</span><span class="s3">8.1e</span><span class="s4">}</span><span class="s3">'</span>
        <span class="s1">str2 </span><span class="s2">= </span><span class="s3">f'anorm =</span><span class="s4">{</span><span class="s1">anorm</span><span class="s4">:</span><span class="s3">8.1e</span><span class="s4">}   </span><span class="s3">arnorm =</span><span class="s4">{</span><span class="s1">arnorm</span><span class="s4">:</span><span class="s3">8.1e</span><span class="s4">}</span><span class="s3">'</span>
        <span class="s1">str3 </span><span class="s2">= </span><span class="s3">f'itn   =</span><span class="s4">{</span><span class="s1">itn</span><span class="s4">:</span><span class="s3">8g</span><span class="s4">}   </span><span class="s3">r2norm =</span><span class="s4">{</span><span class="s1">r2norm</span><span class="s4">:</span><span class="s3">8.1e</span><span class="s4">}</span><span class="s3">'</span>
        <span class="s1">str4 </span><span class="s2">= </span><span class="s3">f'acond =</span><span class="s4">{</span><span class="s1">acond</span><span class="s4">:</span><span class="s3">8.1e</span><span class="s4">}   </span><span class="s3">xnorm  =</span><span class="s4">{</span><span class="s1">xnorm</span><span class="s4">:</span><span class="s3">8.1e</span><span class="s4">}</span><span class="s3">'</span>
        <span class="s1">print</span><span class="s2">(</span><span class="s1">str1 </span><span class="s2">+ </span><span class="s3">'   ' </span><span class="s2">+ </span><span class="s1">str2</span><span class="s2">)</span>
        <span class="s1">print</span><span class="s2">(</span><span class="s1">str3 </span><span class="s2">+ </span><span class="s3">'   ' </span><span class="s2">+ </span><span class="s1">str4</span><span class="s2">)</span>
        <span class="s1">print</span><span class="s2">(</span><span class="s3">' '</span><span class="s2">)</span>

    <span class="s4">return </span><span class="s1">x</span><span class="s2">, </span><span class="s1">istop</span><span class="s2">, </span><span class="s1">itn</span><span class="s2">, </span><span class="s1">r1norm</span><span class="s2">, </span><span class="s1">r2norm</span><span class="s2">, </span><span class="s1">anorm</span><span class="s2">, </span><span class="s1">acond</span><span class="s2">, </span><span class="s1">arnorm</span><span class="s2">, </span><span class="s1">xnorm</span><span class="s2">, </span><span class="s1">var</span>
</pre>
</body>
</html>