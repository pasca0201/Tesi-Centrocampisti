<html>
<head>
<title>psycopg2.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #6aab73;}
.s3 { color: #cf8e6d;}
.s4 { color: #bcbec4;}
.s5 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
psycopg2.py</font>
</center></td></tr></table>
<pre><span class="s0"># dialects/postgresql/psycopg2.py</span>
<span class="s0"># Copyright (C) 2005-2024 the SQLAlchemy authors and contributors</span>
<span class="s0"># &lt;see AUTHORS file&gt;</span>
<span class="s0">#</span>
<span class="s0"># This module is part of SQLAlchemy and is released under</span>
<span class="s0"># the MIT License: https://www.opensource.org/licenses/mit-license.php</span>
<span class="s0"># mypy: ignore-errors</span>

<span class="s2">r&quot;&quot;&quot; 
.. dialect:: postgresql+psycopg2 
    :name: psycopg2 
    :dbapi: psycopg2 
    :connectstring: postgresql+psycopg2://user:password@host:port/dbname[?key=value&amp;key=value...] 
    :url: https://pypi.org/project/psycopg2/ 
 
.. _psycopg2_toplevel: 
 
psycopg2 Connect Arguments 
-------------------------- 
 
Keyword arguments that are specific to the SQLAlchemy psycopg2 dialect 
may be passed to :func:`_sa.create_engine()`, and include the following: 
 
 
* ``isolation_level``: This option, available for all PostgreSQL dialects, 
  includes the ``AUTOCOMMIT`` isolation level when using the psycopg2 
  dialect.   This option sets the **default** isolation level for the 
  connection that is set immediately upon connection to the database before 
  the connection is pooled.  This option is generally superseded by the more 
  modern :paramref:`_engine.Connection.execution_options.isolation_level` 
  execution option, detailed at :ref:`dbapi_autocommit`. 
 
  .. seealso:: 
 
    :ref:`psycopg2_isolation_level` 
 
    :ref:`dbapi_autocommit` 
 
 
* ``client_encoding``: sets the client encoding in a libpq-agnostic way, 
  using psycopg2's ``set_client_encoding()`` method. 
 
  .. seealso:: 
 
    :ref:`psycopg2_unicode` 
 
 
* ``executemany_mode``, ``executemany_batch_page_size``, 
  ``executemany_values_page_size``: Allows use of psycopg2 
  extensions for optimizing &quot;executemany&quot;-style queries.  See the referenced 
  section below for details. 
 
  .. seealso:: 
 
    :ref:`psycopg2_executemany_mode` 
 
.. tip:: 
 
    The above keyword arguments are **dialect** keyword arguments, meaning 
    that they are passed as explicit keyword arguments to :func:`_sa.create_engine()`:: 
 
        engine = create_engine( 
            &quot;postgresql+psycopg2://scott:tiger@localhost/test&quot;, 
            isolation_level=&quot;SERIALIZABLE&quot;, 
        ) 
 
    These should not be confused with **DBAPI** connect arguments, which 
    are passed as part of the :paramref:`_sa.create_engine.connect_args` 
    dictionary and/or are passed in the URL query string, as detailed in 
    the section :ref:`custom_dbapi_args`. 
 
.. _psycopg2_ssl: 
 
SSL Connections 
--------------- 
 
The psycopg2 module has a connection argument named ``sslmode`` for 
controlling its behavior regarding secure (SSL) connections. The default is 
``sslmode=prefer``; it will attempt an SSL connection and if that fails it 
will fall back to an unencrypted connection. ``sslmode=require`` may be used 
to ensure that only secure connections are established.  Consult the 
psycopg2 / libpq documentation for further options that are available. 
 
Note that ``sslmode`` is specific to psycopg2 so it is included in the 
connection URI:: 
 
    engine = sa.create_engine( 
        &quot;postgresql+psycopg2://scott:tiger@192.168.0.199:5432/test?sslmode=require&quot; 
    ) 
 
 
Unix Domain Connections 
------------------------ 
 
psycopg2 supports connecting via Unix domain connections.   When the ``host`` 
portion of the URL is omitted, SQLAlchemy passes ``None`` to psycopg2, 
which specifies Unix-domain communication rather than TCP/IP communication:: 
 
    create_engine(&quot;postgresql+psycopg2://user:password@/dbname&quot;) 
 
By default, the socket file used is to connect to a Unix-domain socket 
in ``/tmp``, or whatever socket directory was specified when PostgreSQL 
was built.  This value can be overridden by passing a pathname to psycopg2, 
using ``host`` as an additional keyword argument:: 
 
    create_engine(&quot;postgresql+psycopg2://user:password@/dbname?host=/var/lib/postgresql&quot;) 
 
.. warning::  The format accepted here allows for a hostname in the main URL 
   in addition to the &quot;host&quot; query string argument.  **When using this URL 
   format, the initial host is silently ignored**.  That is, this URL:: 
 
        engine = create_engine(&quot;postgresql+psycopg2://user:password@myhost1/dbname?host=myhost2&quot;) 
 
   Above, the hostname ``myhost1`` is **silently ignored and discarded.**  The 
   host which is connected is the ``myhost2`` host. 
 
   This is to maintain some degree of compatibility with PostgreSQL's own URL 
   format which has been tested to behave the same way and for which tools like 
   PifPaf hardcode two hostnames. 
 
.. seealso:: 
 
    `PQconnectdbParams \ 
    &lt;https://www.postgresql.org/docs/current/static/libpq-connect.html#LIBPQ-PQCONNECTDBPARAMS&gt;`_ 
 
.. _psycopg2_multi_host: 
 
Specifying multiple fallback hosts 
----------------------------------- 
 
psycopg2 supports multiple connection points in the connection string. 
When the ``host`` parameter is used multiple times in the query section of 
the URL, SQLAlchemy will create a single string of the host and port 
information provided to make the connections.  Tokens may consist of 
``host::port`` or just ``host``; in the latter case, the default port 
is selected by libpq.  In the example below, three host connections 
are specified, for ``HostA::PortA``, ``HostB`` connecting to the default port, 
and ``HostC::PortC``:: 
 
    create_engine( 
        &quot;postgresql+psycopg2://user:password@/dbname?host=HostA:PortA&amp;host=HostB&amp;host=HostC:PortC&quot; 
    ) 
 
As an alternative, libpq query string format also may be used; this specifies 
``host`` and ``port`` as single query string arguments with comma-separated 
lists - the default port can be chosen by indicating an empty value 
in the comma separated list:: 
 
    create_engine( 
        &quot;postgresql+psycopg2://user:password@/dbname?host=HostA,HostB,HostC&amp;port=PortA,,PortC&quot; 
    ) 
 
With either URL style, connections to each host is attempted based on a 
configurable strategy, which may be configured using the libpq 
``target_session_attrs`` parameter.  Per libpq this defaults to ``any`` 
which indicates a connection to each host is then attempted until a connection is successful. 
Other strategies include ``primary``, ``prefer-standby``, etc.  The complete 
list is documented by PostgreSQL at 
`libpq connection strings &lt;https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-CONNSTRING&gt;`_. 
 
For example, to indicate two hosts using the ``primary`` strategy:: 
 
    create_engine( 
        &quot;postgresql+psycopg2://user:password@/dbname?host=HostA:PortA&amp;host=HostB&amp;host=HostC:PortC&amp;target_session_attrs=primary&quot; 
    ) 
 
.. versionchanged:: 1.4.40 Port specification in psycopg2 multiple host format 
   is repaired, previously ports were not correctly interpreted in this context. 
   libpq comma-separated format is also now supported. 
 
.. versionadded:: 1.3.20 Support for multiple hosts in PostgreSQL connection 
   string. 
 
.. seealso:: 
 
    `libpq connection strings &lt;https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-CONNSTRING&gt;`_ - please refer 
    to this section in the libpq documentation for complete background on multiple host support. 
 
 
Empty DSN Connections / Environment Variable Connections 
--------------------------------------------------------- 
 
The psycopg2 DBAPI can connect to PostgreSQL by passing an empty DSN to the 
libpq client library, which by default indicates to connect to a localhost 
PostgreSQL database that is open for &quot;trust&quot; connections.  This behavior can be 
further tailored using a particular set of environment variables which are 
prefixed with ``PG_...``, which are  consumed by ``libpq`` to take the place of 
any or all elements of the connection string. 
 
For this form, the URL can be passed without any elements other than the 
initial scheme:: 
 
    engine = create_engine('postgresql+psycopg2://') 
 
In the above form, a blank &quot;dsn&quot; string is passed to the ``psycopg2.connect()`` 
function which in turn represents an empty DSN passed to libpq. 
 
.. versionadded:: 1.3.2 support for parameter-less connections with psycopg2. 
 
.. seealso:: 
 
    `Environment Variables\ 
    &lt;https://www.postgresql.org/docs/current/libpq-envars.html&gt;`_ - 
    PostgreSQL documentation on how to use ``PG_...`` 
    environment variables for connections. 
 
.. _psycopg2_execution_options: 
 
Per-Statement/Connection Execution Options 
------------------------------------------- 
 
The following DBAPI-specific options are respected when used with 
:meth:`_engine.Connection.execution_options`, 
:meth:`.Executable.execution_options`, 
:meth:`_query.Query.execution_options`, 
in addition to those not specific to DBAPIs: 
 
* ``isolation_level`` - Set the transaction isolation level for the lifespan 
  of a :class:`_engine.Connection` (can only be set on a connection, 
  not a statement 
  or query).   See :ref:`psycopg2_isolation_level`. 
 
* ``stream_results`` - Enable or disable usage of psycopg2 server side 
  cursors - this feature makes use of &quot;named&quot; cursors in combination with 
  special result handling methods so that result rows are not fully buffered. 
  Defaults to False, meaning cursors are buffered by default. 
 
* ``max_row_buffer`` - when using ``stream_results``, an integer value that 
  specifies the maximum number of rows to buffer at a time.  This is 
  interpreted by the :class:`.BufferedRowCursorResult`, and if omitted the 
  buffer will grow to ultimately store 1000 rows at a time. 
 
  .. versionchanged:: 1.4  The ``max_row_buffer`` size can now be greater than 
     1000, and the buffer will grow to that size. 
 
.. _psycopg2_batch_mode: 
 
.. _psycopg2_executemany_mode: 
 
Psycopg2 Fast Execution Helpers 
------------------------------- 
 
Modern versions of psycopg2 include a feature known as 
`Fast Execution Helpers \ 
&lt;https://www.psycopg.org/docs/extras.html#fast-execution-helpers&gt;`_, which 
have been shown in benchmarking to improve psycopg2's executemany() 
performance, primarily with INSERT statements, by at least 
an order of magnitude. 
 
SQLAlchemy implements a native form of the &quot;insert many values&quot; 
handler that will rewrite a single-row INSERT statement to accommodate for 
many values at once within an extended VALUES clause; this handler is 
equivalent to psycopg2's ``execute_values()`` handler; an overview of this 
feature and its configuration are at :ref:`engine_insertmanyvalues`. 
 
.. versionadded:: 2.0 Replaced psycopg2's ``execute_values()`` fast execution 
   helper with a native SQLAlchemy mechanism known as 
   :ref:`insertmanyvalues &lt;engine_insertmanyvalues&gt;`. 
 
The psycopg2 dialect retains the ability to use the psycopg2-specific 
``execute_batch()`` feature, although it is not expected that this is a widely 
used feature.  The use of this extension may be enabled using the 
``executemany_mode`` flag which may be passed to :func:`_sa.create_engine`:: 
 
    engine = create_engine( 
        &quot;postgresql+psycopg2://scott:tiger@host/dbname&quot;, 
        executemany_mode='values_plus_batch') 
 
 
Possible options for ``executemany_mode`` include: 
 
* ``values_only`` - this is the default value.  SQLAlchemy's native 
  :ref:`insertmanyvalues &lt;engine_insertmanyvalues&gt;` handler is used for qualifying 
  INSERT statements, assuming 
  :paramref:`_sa.create_engine.use_insertmanyvalues` is left at 
  its default value of ``True``.  This handler rewrites simple 
  INSERT statements to include multiple VALUES clauses so that many 
  parameter sets can be inserted with one statement. 
 
* ``'values_plus_batch'``- SQLAlchemy's native 
  :ref:`insertmanyvalues &lt;engine_insertmanyvalues&gt;` handler is used for qualifying 
  INSERT statements, assuming 
  :paramref:`_sa.create_engine.use_insertmanyvalues` is left at its default 
  value of ``True``. Then, psycopg2's ``execute_batch()`` handler is used for 
  qualifying UPDATE and DELETE statements when executed with multiple parameter 
  sets. When using this mode, the :attr:`_engine.CursorResult.rowcount` 
  attribute will not contain a value for executemany-style executions against 
  UPDATE and DELETE statements. 
 
.. versionchanged:: 2.0 Removed the ``'batch'`` and ``'None'`` options 
   from psycopg2 ``executemany_mode``.  Control over batching for INSERT 
   statements is now configured via the 
   :paramref:`_sa.create_engine.use_insertmanyvalues` engine-level parameter. 
 
The term &quot;qualifying statements&quot; refers to the statement being executed 
being a Core :func:`_expression.insert`, :func:`_expression.update` 
or :func:`_expression.delete` construct, and **not** a plain textual SQL 
string or one constructed using :func:`_expression.text`.  It also may **not** be 
a special &quot;extension&quot; statement such as an &quot;ON CONFLICT&quot; &quot;upsert&quot; statement. 
When using the ORM, all insert/update/delete statements used by the ORM flush process 
are qualifying. 
 
The &quot;page size&quot; for the psycopg2 &quot;batch&quot; strategy can be affected 
by using the ``executemany_batch_page_size`` parameter, which defaults to 
100. 
 
For the &quot;insertmanyvalues&quot; feature, the page size can be controlled using the 
:paramref:`_sa.create_engine.insertmanyvalues_page_size` parameter, 
which defaults to 1000.  An example of modifying both parameters 
is below:: 
 
    engine = create_engine( 
        &quot;postgresql+psycopg2://scott:tiger@host/dbname&quot;, 
        executemany_mode='values_plus_batch', 
        insertmanyvalues_page_size=5000, executemany_batch_page_size=500) 
 
.. seealso:: 
 
    :ref:`engine_insertmanyvalues` - background on &quot;insertmanyvalues&quot; 
 
    :ref:`tutorial_multiple_parameters` - General information on using the 
    :class:`_engine.Connection` 
    object to execute statements in such a way as to make 
    use of the DBAPI ``.executemany()`` method. 
 
 
.. _psycopg2_unicode: 
 
Unicode with Psycopg2 
---------------------- 
 
The psycopg2 DBAPI driver supports Unicode data transparently. 
 
The client character encoding can be controlled for the psycopg2 dialect 
in the following ways: 
 
* For PostgreSQL 9.1 and above, the ``client_encoding`` parameter may be 
  passed in the database URL; this parameter is consumed by the underlying 
  ``libpq`` PostgreSQL client library:: 
 
    engine = create_engine(&quot;postgresql+psycopg2://user:pass@host/dbname?client_encoding=utf8&quot;) 
 
  Alternatively, the above ``client_encoding`` value may be passed using 
  :paramref:`_sa.create_engine.connect_args` for programmatic establishment with 
  ``libpq``:: 
 
    engine = create_engine( 
        &quot;postgresql+psycopg2://user:pass@host/dbname&quot;, 
        connect_args={'client_encoding': 'utf8'} 
    ) 
 
* For all PostgreSQL versions, psycopg2 supports a client-side encoding 
  value that will be passed to database connections when they are first 
  established.  The SQLAlchemy psycopg2 dialect supports this using the 
  ``client_encoding`` parameter passed to :func:`_sa.create_engine`:: 
 
      engine = create_engine( 
          &quot;postgresql+psycopg2://user:pass@host/dbname&quot;, 
          client_encoding=&quot;utf8&quot; 
      ) 
 
  .. tip:: The above ``client_encoding`` parameter admittedly is very similar 
      in appearance to usage of the parameter within the 
      :paramref:`_sa.create_engine.connect_args` dictionary; the difference 
      above is that the parameter is consumed by psycopg2 and is 
      passed to the database connection using ``SET client_encoding TO 
      'utf8'``; in the previously mentioned style, the parameter is instead 
      passed through psycopg2 and consumed by the ``libpq`` library. 
 
* A common way to set up client encoding with PostgreSQL databases is to 
  ensure it is configured within the server-side postgresql.conf file; 
  this is the recommended way to set encoding for a server that is 
  consistently of one encoding in all databases:: 
 
    # postgresql.conf file 
 
    # client_encoding = sql_ascii # actually, defaults to database 
                                 # encoding 
    client_encoding = utf8 
 
 
 
Transactions 
------------ 
 
The psycopg2 dialect fully supports SAVEPOINT and two-phase commit operations. 
 
.. _psycopg2_isolation_level: 
 
Psycopg2 Transaction Isolation Level 
------------------------------------- 
 
As discussed in :ref:`postgresql_isolation_level`, 
all PostgreSQL dialects support setting of transaction isolation level 
both via the ``isolation_level`` parameter passed to :func:`_sa.create_engine` 
, 
as well as the ``isolation_level`` argument used by 
:meth:`_engine.Connection.execution_options`.  When using the psycopg2 dialect 
, these 
options make use of psycopg2's ``set_isolation_level()`` connection method, 
rather than emitting a PostgreSQL directive; this is because psycopg2's 
API-level setting is always emitted at the start of each transaction in any 
case. 
 
The psycopg2 dialect supports these constants for isolation level: 
 
* ``READ COMMITTED`` 
* ``READ UNCOMMITTED`` 
* ``REPEATABLE READ`` 
* ``SERIALIZABLE`` 
* ``AUTOCOMMIT`` 
 
.. seealso:: 
 
    :ref:`postgresql_isolation_level` 
 
    :ref:`pg8000_isolation_level` 
 
 
NOTICE logging 
--------------- 
 
The psycopg2 dialect will log PostgreSQL NOTICE messages 
via the ``sqlalchemy.dialects.postgresql`` logger.  When this logger 
is set to the ``logging.INFO`` level, notice messages will be logged:: 
 
    import logging 
 
    logging.getLogger('sqlalchemy.dialects.postgresql').setLevel(logging.INFO) 
 
Above, it is assumed that logging is configured externally.  If this is not 
the case, configuration such as ``logging.basicConfig()`` must be utilized:: 
 
    import logging 
 
    logging.basicConfig()   # log messages to stdout 
    logging.getLogger('sqlalchemy.dialects.postgresql').setLevel(logging.INFO) 
 
.. seealso:: 
 
    `Logging HOWTO &lt;https://docs.python.org/3/howto/logging.html&gt;`_ - on the python.org website 
 
.. _psycopg2_hstore: 
 
HSTORE type 
------------ 
 
The ``psycopg2`` DBAPI includes an extension to natively handle marshalling of 
the HSTORE type.   The SQLAlchemy psycopg2 dialect will enable this extension 
by default when psycopg2 version 2.4 or greater is used, and 
it is detected that the target database has the HSTORE type set up for use. 
In other words, when the dialect makes the first 
connection, a sequence like the following is performed: 
 
1. Request the available HSTORE oids using 
   ``psycopg2.extras.HstoreAdapter.get_oids()``. 
   If this function returns a list of HSTORE identifiers, we then determine 
   that the ``HSTORE`` extension is present. 
   This function is **skipped** if the version of psycopg2 installed is 
   less than version 2.4. 
 
2. If the ``use_native_hstore`` flag is at its default of ``True``, and 
   we've detected that ``HSTORE`` oids are available, the 
   ``psycopg2.extensions.register_hstore()`` extension is invoked for all 
   connections. 
 
The ``register_hstore()`` extension has the effect of **all Python 
dictionaries being accepted as parameters regardless of the type of target 
column in SQL**. The dictionaries are converted by this extension into a 
textual HSTORE expression.  If this behavior is not desired, disable the 
use of the hstore extension by setting ``use_native_hstore`` to ``False`` as 
follows:: 
 
    engine = create_engine(&quot;postgresql+psycopg2://scott:tiger@localhost/test&quot;, 
                use_native_hstore=False) 
 
The ``HSTORE`` type is **still supported** when the 
``psycopg2.extensions.register_hstore()`` extension is not used.  It merely 
means that the coercion between Python dictionaries and the HSTORE 
string format, on both the parameter side and the result side, will take 
place within SQLAlchemy's own marshalling logic, and not that of ``psycopg2`` 
which may be more performant. 
 
&quot;&quot;&quot;  </span><span class="s0"># noqa</span>
<span class="s3">from </span><span class="s1">__future__ </span><span class="s3">import </span><span class="s1">annotations</span>

<span class="s3">import </span><span class="s1">collections</span><span class="s4">.</span><span class="s1">abc </span><span class="s3">as </span><span class="s1">collections_abc</span>
<span class="s3">import </span><span class="s1">logging</span>
<span class="s3">import </span><span class="s1">re</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">cast</span>

<span class="s3">from </span><span class="s4">. </span><span class="s3">import </span><span class="s1">ranges</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">_psycopg_common </span><span class="s3">import </span><span class="s1">_PGDialect_common_psycopg</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">_psycopg_common </span><span class="s3">import </span><span class="s1">_PGExecutionContext_common_psycopg</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">base </span><span class="s3">import </span><span class="s1">PGIdentifierPreparer</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">json </span><span class="s3">import </span><span class="s1">JSON</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">json </span><span class="s3">import </span><span class="s1">JSONB</span>
<span class="s3">from </span><span class="s4">... </span><span class="s3">import </span><span class="s1">types </span><span class="s3">as </span><span class="s1">sqltypes</span>
<span class="s3">from </span><span class="s4">... </span><span class="s3">import </span><span class="s1">util</span>
<span class="s3">from </span><span class="s4">...</span><span class="s1">util </span><span class="s3">import </span><span class="s1">FastIntFlag</span>
<span class="s3">from </span><span class="s4">...</span><span class="s1">util </span><span class="s3">import </span><span class="s1">parse_user_argument_for_enum</span>

<span class="s1">logger </span><span class="s4">= </span><span class="s1">logging</span><span class="s4">.</span><span class="s1">getLogger</span><span class="s4">(</span><span class="s2">&quot;sqlalchemy.dialects.postgresql&quot;</span><span class="s4">)</span>


<span class="s3">class </span><span class="s1">_PGJSON</span><span class="s4">(</span><span class="s1">JSON</span><span class="s4">):</span>
    <span class="s3">def </span><span class="s1">result_processor</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">dialect</span><span class="s4">, </span><span class="s1">coltype</span><span class="s4">):</span>
        <span class="s3">return None</span>


<span class="s3">class </span><span class="s1">_PGJSONB</span><span class="s4">(</span><span class="s1">JSONB</span><span class="s4">):</span>
    <span class="s3">def </span><span class="s1">result_processor</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">dialect</span><span class="s4">, </span><span class="s1">coltype</span><span class="s4">):</span>
        <span class="s3">return None</span>


<span class="s3">class </span><span class="s1">_Psycopg2Range</span><span class="s4">(</span><span class="s1">ranges</span><span class="s4">.</span><span class="s1">AbstractSingleRangeImpl</span><span class="s4">):</span>
    <span class="s1">_psycopg2_range_cls </span><span class="s4">= </span><span class="s2">&quot;none&quot;</span>

    <span class="s3">def </span><span class="s1">bind_processor</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">dialect</span><span class="s4">):</span>
        <span class="s1">psycopg2_Range </span><span class="s4">= </span><span class="s1">getattr</span><span class="s4">(</span>
            <span class="s1">cast</span><span class="s4">(</span><span class="s1">PGDialect_psycopg2</span><span class="s4">, </span><span class="s1">dialect</span><span class="s4">).</span><span class="s1">_psycopg2_extras</span><span class="s4">,</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_psycopg2_range_cls</span><span class="s4">,</span>
        <span class="s4">)</span>

        <span class="s3">def </span><span class="s1">to_range</span><span class="s4">(</span><span class="s1">value</span><span class="s4">):</span>
            <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">value</span><span class="s4">, </span><span class="s1">ranges</span><span class="s4">.</span><span class="s1">Range</span><span class="s4">):</span>
                <span class="s1">value </span><span class="s4">= </span><span class="s1">psycopg2_Range</span><span class="s4">(</span>
                    <span class="s1">value</span><span class="s4">.</span><span class="s1">lower</span><span class="s4">, </span><span class="s1">value</span><span class="s4">.</span><span class="s1">upper</span><span class="s4">, </span><span class="s1">value</span><span class="s4">.</span><span class="s1">bounds</span><span class="s4">, </span><span class="s1">value</span><span class="s4">.</span><span class="s1">empty</span>
                <span class="s4">)</span>
            <span class="s3">return </span><span class="s1">value</span>

        <span class="s3">return </span><span class="s1">to_range</span>

    <span class="s3">def </span><span class="s1">result_processor</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">dialect</span><span class="s4">, </span><span class="s1">coltype</span><span class="s4">):</span>
        <span class="s3">def </span><span class="s1">to_range</span><span class="s4">(</span><span class="s1">value</span><span class="s4">):</span>
            <span class="s3">if </span><span class="s1">value </span><span class="s3">is not None</span><span class="s4">:</span>
                <span class="s1">value </span><span class="s4">= </span><span class="s1">ranges</span><span class="s4">.</span><span class="s1">Range</span><span class="s4">(</span>
                    <span class="s1">value</span><span class="s4">.</span><span class="s1">_lower</span><span class="s4">,</span>
                    <span class="s1">value</span><span class="s4">.</span><span class="s1">_upper</span><span class="s4">,</span>
                    <span class="s1">bounds</span><span class="s4">=</span><span class="s1">value</span><span class="s4">.</span><span class="s1">_bounds </span><span class="s3">if </span><span class="s1">value</span><span class="s4">.</span><span class="s1">_bounds </span><span class="s3">else </span><span class="s2">&quot;[)&quot;</span><span class="s4">,</span>
                    <span class="s1">empty</span><span class="s4">=</span><span class="s3">not </span><span class="s1">value</span><span class="s4">.</span><span class="s1">_bounds</span><span class="s4">,</span>
                <span class="s4">)</span>
            <span class="s3">return </span><span class="s1">value</span>

        <span class="s3">return </span><span class="s1">to_range</span>


<span class="s3">class </span><span class="s1">_Psycopg2NumericRange</span><span class="s4">(</span><span class="s1">_Psycopg2Range</span><span class="s4">):</span>
    <span class="s1">_psycopg2_range_cls </span><span class="s4">= </span><span class="s2">&quot;NumericRange&quot;</span>


<span class="s3">class </span><span class="s1">_Psycopg2DateRange</span><span class="s4">(</span><span class="s1">_Psycopg2Range</span><span class="s4">):</span>
    <span class="s1">_psycopg2_range_cls </span><span class="s4">= </span><span class="s2">&quot;DateRange&quot;</span>


<span class="s3">class </span><span class="s1">_Psycopg2DateTimeRange</span><span class="s4">(</span><span class="s1">_Psycopg2Range</span><span class="s4">):</span>
    <span class="s1">_psycopg2_range_cls </span><span class="s4">= </span><span class="s2">&quot;DateTimeRange&quot;</span>


<span class="s3">class </span><span class="s1">_Psycopg2DateTimeTZRange</span><span class="s4">(</span><span class="s1">_Psycopg2Range</span><span class="s4">):</span>
    <span class="s1">_psycopg2_range_cls </span><span class="s4">= </span><span class="s2">&quot;DateTimeTZRange&quot;</span>


<span class="s3">class </span><span class="s1">PGExecutionContext_psycopg2</span><span class="s4">(</span><span class="s1">_PGExecutionContext_common_psycopg</span><span class="s4">):</span>
    <span class="s1">_psycopg2_fetched_rows </span><span class="s4">= </span><span class="s3">None</span>

    <span class="s3">def </span><span class="s1">post_exec</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_log_notices</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">cursor</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_log_notices</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">cursor</span><span class="s4">):</span>
        <span class="s0"># check also that notices is an iterable, after it's already</span>
        <span class="s0"># established that we will be iterating through it.  This is to get</span>
        <span class="s0"># around test suites such as SQLAlchemy's using a Mock object for</span>
        <span class="s0"># cursor</span>
        <span class="s3">if not </span><span class="s1">cursor</span><span class="s4">.</span><span class="s1">connection</span><span class="s4">.</span><span class="s1">notices </span><span class="s3">or not </span><span class="s1">isinstance</span><span class="s4">(</span>
            <span class="s1">cursor</span><span class="s4">.</span><span class="s1">connection</span><span class="s4">.</span><span class="s1">notices</span><span class="s4">, </span><span class="s1">collections_abc</span><span class="s4">.</span><span class="s1">Iterable</span>
        <span class="s4">):</span>
            <span class="s3">return</span>

        <span class="s3">for </span><span class="s1">notice </span><span class="s3">in </span><span class="s1">cursor</span><span class="s4">.</span><span class="s1">connection</span><span class="s4">.</span><span class="s1">notices</span><span class="s4">:</span>
            <span class="s0"># NOTICE messages have a</span>
            <span class="s0"># newline character at the end</span>
            <span class="s1">logger</span><span class="s4">.</span><span class="s1">info</span><span class="s4">(</span><span class="s1">notice</span><span class="s4">.</span><span class="s1">rstrip</span><span class="s4">())</span>

        <span class="s1">cursor</span><span class="s4">.</span><span class="s1">connection</span><span class="s4">.</span><span class="s1">notices</span><span class="s4">[:] = []</span>


<span class="s3">class </span><span class="s1">PGIdentifierPreparer_psycopg2</span><span class="s4">(</span><span class="s1">PGIdentifierPreparer</span><span class="s4">):</span>
    <span class="s3">pass</span>


<span class="s3">class </span><span class="s1">ExecutemanyMode</span><span class="s4">(</span><span class="s1">FastIntFlag</span><span class="s4">):</span>
    <span class="s1">EXECUTEMANY_VALUES </span><span class="s4">= </span><span class="s5">0</span>
    <span class="s1">EXECUTEMANY_VALUES_PLUS_BATCH </span><span class="s4">= </span><span class="s5">1</span>


<span class="s4">(</span>
    <span class="s1">EXECUTEMANY_VALUES</span><span class="s4">,</span>
    <span class="s1">EXECUTEMANY_VALUES_PLUS_BATCH</span><span class="s4">,</span>
<span class="s4">) = </span><span class="s1">ExecutemanyMode</span><span class="s4">.</span><span class="s1">__members__</span><span class="s4">.</span><span class="s1">values</span><span class="s4">()</span>


<span class="s3">class </span><span class="s1">PGDialect_psycopg2</span><span class="s4">(</span><span class="s1">_PGDialect_common_psycopg</span><span class="s4">):</span>
    <span class="s1">driver </span><span class="s4">= </span><span class="s2">&quot;psycopg2&quot;</span>

    <span class="s1">supports_statement_cache </span><span class="s4">= </span><span class="s3">True</span>
    <span class="s1">supports_server_side_cursors </span><span class="s4">= </span><span class="s3">True</span>

    <span class="s1">default_paramstyle </span><span class="s4">= </span><span class="s2">&quot;pyformat&quot;</span>
    <span class="s0"># set to true based on psycopg2 version</span>
    <span class="s1">supports_sane_multi_rowcount </span><span class="s4">= </span><span class="s3">False</span>
    <span class="s1">execution_ctx_cls </span><span class="s4">= </span><span class="s1">PGExecutionContext_psycopg2</span>
    <span class="s1">preparer </span><span class="s4">= </span><span class="s1">PGIdentifierPreparer_psycopg2</span>
    <span class="s1">psycopg2_version </span><span class="s4">= (</span><span class="s5">0</span><span class="s4">, </span><span class="s5">0</span><span class="s4">)</span>
    <span class="s1">use_insertmanyvalues_wo_returning </span><span class="s4">= </span><span class="s3">True</span>

    <span class="s1">returns_native_bytes </span><span class="s4">= </span><span class="s3">False</span>

    <span class="s1">_has_native_hstore </span><span class="s4">= </span><span class="s3">True</span>

    <span class="s1">colspecs </span><span class="s4">= </span><span class="s1">util</span><span class="s4">.</span><span class="s1">update_copy</span><span class="s4">(</span>
        <span class="s1">_PGDialect_common_psycopg</span><span class="s4">.</span><span class="s1">colspecs</span><span class="s4">,</span>
        <span class="s4">{</span>
            <span class="s1">JSON</span><span class="s4">: </span><span class="s1">_PGJSON</span><span class="s4">,</span>
            <span class="s1">sqltypes</span><span class="s4">.</span><span class="s1">JSON</span><span class="s4">: </span><span class="s1">_PGJSON</span><span class="s4">,</span>
            <span class="s1">JSONB</span><span class="s4">: </span><span class="s1">_PGJSONB</span><span class="s4">,</span>
            <span class="s1">ranges</span><span class="s4">.</span><span class="s1">INT4RANGE</span><span class="s4">: </span><span class="s1">_Psycopg2NumericRange</span><span class="s4">,</span>
            <span class="s1">ranges</span><span class="s4">.</span><span class="s1">INT8RANGE</span><span class="s4">: </span><span class="s1">_Psycopg2NumericRange</span><span class="s4">,</span>
            <span class="s1">ranges</span><span class="s4">.</span><span class="s1">NUMRANGE</span><span class="s4">: </span><span class="s1">_Psycopg2NumericRange</span><span class="s4">,</span>
            <span class="s1">ranges</span><span class="s4">.</span><span class="s1">DATERANGE</span><span class="s4">: </span><span class="s1">_Psycopg2DateRange</span><span class="s4">,</span>
            <span class="s1">ranges</span><span class="s4">.</span><span class="s1">TSRANGE</span><span class="s4">: </span><span class="s1">_Psycopg2DateTimeRange</span><span class="s4">,</span>
            <span class="s1">ranges</span><span class="s4">.</span><span class="s1">TSTZRANGE</span><span class="s4">: </span><span class="s1">_Psycopg2DateTimeTZRange</span><span class="s4">,</span>
        <span class="s4">},</span>
    <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">executemany_mode</span><span class="s4">=</span><span class="s2">&quot;values_only&quot;</span><span class="s4">,</span>
        <span class="s1">executemany_batch_page_size</span><span class="s4">=</span><span class="s5">100</span><span class="s4">,</span>
        <span class="s4">**</span><span class="s1">kwargs</span><span class="s4">,</span>
    <span class="s4">):</span>
        <span class="s1">_PGDialect_common_psycopg</span><span class="s4">.</span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, **</span><span class="s1">kwargs</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_native_inet_types</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">(</span>
                <span class="s2">&quot;The psycopg2 dialect does not implement &quot;</span>
                <span class="s2">&quot;ipaddress type handling; native_inet_types cannot be set &quot;</span>
                <span class="s2">&quot;to ``True`` when using this dialect.&quot;</span>
            <span class="s4">)</span>

        <span class="s0"># Parse executemany_mode argument, allowing it to be only one of the</span>
        <span class="s0"># symbol names</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">executemany_mode </span><span class="s4">= </span><span class="s1">parse_user_argument_for_enum</span><span class="s4">(</span>
            <span class="s1">executemany_mode</span><span class="s4">,</span>
            <span class="s4">{</span>
                <span class="s1">EXECUTEMANY_VALUES</span><span class="s4">: [</span><span class="s2">&quot;values_only&quot;</span><span class="s4">],</span>
                <span class="s1">EXECUTEMANY_VALUES_PLUS_BATCH</span><span class="s4">: [</span><span class="s2">&quot;values_plus_batch&quot;</span><span class="s4">],</span>
            <span class="s4">},</span>
            <span class="s2">&quot;executemany_mode&quot;</span><span class="s4">,</span>
        <span class="s4">)</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">executemany_batch_page_size </span><span class="s4">= </span><span class="s1">executemany_batch_page_size</span>

        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">dbapi </span><span class="s3">and </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">dbapi</span><span class="s4">, </span><span class="s2">&quot;__version__&quot;</span><span class="s4">):</span>
            <span class="s1">m </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">match</span><span class="s4">(</span><span class="s2">r&quot;(\d+)\.(\d+)(?:\.(\d+))?&quot;</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">dbapi</span><span class="s4">.</span><span class="s1">__version__</span><span class="s4">)</span>
            <span class="s3">if </span><span class="s1">m</span><span class="s4">:</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">psycopg2_version </span><span class="s4">= </span><span class="s1">tuple</span><span class="s4">(</span>
                    <span class="s1">int</span><span class="s4">(</span><span class="s1">x</span><span class="s4">) </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">m</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s5">1</span><span class="s4">, </span><span class="s5">2</span><span class="s4">, </span><span class="s5">3</span><span class="s4">) </span><span class="s3">if </span><span class="s1">x </span><span class="s3">is not None</span>
                <span class="s4">)</span>

            <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">psycopg2_version </span><span class="s4">&lt; (</span><span class="s5">2</span><span class="s4">, </span><span class="s5">7</span><span class="s4">):</span>
                <span class="s3">raise </span><span class="s1">ImportError</span><span class="s4">(</span>
                    <span class="s2">&quot;psycopg2 version 2.7 or higher is required.&quot;</span>
                <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">initialize</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">connection</span><span class="s4">):</span>
        <span class="s1">super</span><span class="s4">().</span><span class="s1">initialize</span><span class="s4">(</span><span class="s1">connection</span><span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_has_native_hstore </span><span class="s4">= (</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">use_native_hstore</span>
            <span class="s3">and </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_hstore_oids</span><span class="s4">(</span><span class="s1">connection</span><span class="s4">.</span><span class="s1">connection</span><span class="s4">.</span><span class="s1">dbapi_connection</span><span class="s4">)</span>
            <span class="s3">is not None</span>
        <span class="s4">)</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">supports_sane_multi_rowcount </span><span class="s4">= (</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">executemany_mode </span><span class="s3">is not </span><span class="s1">EXECUTEMANY_VALUES_PLUS_BATCH</span>
        <span class="s4">)</span>

    <span class="s4">@</span><span class="s1">classmethod</span>
    <span class="s3">def </span><span class="s1">import_dbapi</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">):</span>
        <span class="s3">import </span><span class="s1">psycopg2</span>

        <span class="s3">return </span><span class="s1">psycopg2</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">memoized_property</span>
    <span class="s3">def </span><span class="s1">_psycopg2_extensions</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">):</span>
        <span class="s3">from </span><span class="s1">psycopg2 </span><span class="s3">import </span><span class="s1">extensions</span>

        <span class="s3">return </span><span class="s1">extensions</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">memoized_property</span>
    <span class="s3">def </span><span class="s1">_psycopg2_extras</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">):</span>
        <span class="s3">from </span><span class="s1">psycopg2 </span><span class="s3">import </span><span class="s1">extras</span>

        <span class="s3">return </span><span class="s1">extras</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">memoized_property</span>
    <span class="s3">def </span><span class="s1">_isolation_lookup</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s1">extensions </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_psycopg2_extensions</span>
        <span class="s3">return </span><span class="s4">{</span>
            <span class="s2">&quot;AUTOCOMMIT&quot;</span><span class="s4">: </span><span class="s1">extensions</span><span class="s4">.</span><span class="s1">ISOLATION_LEVEL_AUTOCOMMIT</span><span class="s4">,</span>
            <span class="s2">&quot;READ COMMITTED&quot;</span><span class="s4">: </span><span class="s1">extensions</span><span class="s4">.</span><span class="s1">ISOLATION_LEVEL_READ_COMMITTED</span><span class="s4">,</span>
            <span class="s2">&quot;READ UNCOMMITTED&quot;</span><span class="s4">: </span><span class="s1">extensions</span><span class="s4">.</span><span class="s1">ISOLATION_LEVEL_READ_UNCOMMITTED</span><span class="s4">,</span>
            <span class="s2">&quot;REPEATABLE READ&quot;</span><span class="s4">: </span><span class="s1">extensions</span><span class="s4">.</span><span class="s1">ISOLATION_LEVEL_REPEATABLE_READ</span><span class="s4">,</span>
            <span class="s2">&quot;SERIALIZABLE&quot;</span><span class="s4">: </span><span class="s1">extensions</span><span class="s4">.</span><span class="s1">ISOLATION_LEVEL_SERIALIZABLE</span><span class="s4">,</span>
        <span class="s4">}</span>

    <span class="s3">def </span><span class="s1">set_isolation_level</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">dbapi_connection</span><span class="s4">, </span><span class="s1">level</span><span class="s4">):</span>
        <span class="s1">dbapi_connection</span><span class="s4">.</span><span class="s1">set_isolation_level</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_isolation_lookup</span><span class="s4">[</span><span class="s1">level</span><span class="s4">])</span>

    <span class="s3">def </span><span class="s1">set_readonly</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">connection</span><span class="s4">, </span><span class="s1">value</span><span class="s4">):</span>
        <span class="s1">connection</span><span class="s4">.</span><span class="s1">readonly </span><span class="s4">= </span><span class="s1">value</span>

    <span class="s3">def </span><span class="s1">get_readonly</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">connection</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">connection</span><span class="s4">.</span><span class="s1">readonly</span>

    <span class="s3">def </span><span class="s1">set_deferrable</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">connection</span><span class="s4">, </span><span class="s1">value</span><span class="s4">):</span>
        <span class="s1">connection</span><span class="s4">.</span><span class="s1">deferrable </span><span class="s4">= </span><span class="s1">value</span>

    <span class="s3">def </span><span class="s1">get_deferrable</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">connection</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">connection</span><span class="s4">.</span><span class="s1">deferrable</span>

    <span class="s3">def </span><span class="s1">on_connect</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s1">extras </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_psycopg2_extras</span>

        <span class="s1">fns </span><span class="s4">= []</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">client_encoding </span><span class="s3">is not None</span><span class="s4">:</span>

            <span class="s3">def </span><span class="s1">on_connect</span><span class="s4">(</span><span class="s1">dbapi_conn</span><span class="s4">):</span>
                <span class="s1">dbapi_conn</span><span class="s4">.</span><span class="s1">set_client_encoding</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">client_encoding</span><span class="s4">)</span>

            <span class="s1">fns</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">on_connect</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">dbapi</span><span class="s4">:</span>

            <span class="s3">def </span><span class="s1">on_connect</span><span class="s4">(</span><span class="s1">dbapi_conn</span><span class="s4">):</span>
                <span class="s1">extras</span><span class="s4">.</span><span class="s1">register_uuid</span><span class="s4">(</span><span class="s3">None</span><span class="s4">, </span><span class="s1">dbapi_conn</span><span class="s4">)</span>

            <span class="s1">fns</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">on_connect</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">dbapi </span><span class="s3">and </span><span class="s1">self</span><span class="s4">.</span><span class="s1">use_native_hstore</span><span class="s4">:</span>

            <span class="s3">def </span><span class="s1">on_connect</span><span class="s4">(</span><span class="s1">dbapi_conn</span><span class="s4">):</span>
                <span class="s1">hstore_oids </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_hstore_oids</span><span class="s4">(</span><span class="s1">dbapi_conn</span><span class="s4">)</span>
                <span class="s3">if </span><span class="s1">hstore_oids </span><span class="s3">is not None</span><span class="s4">:</span>
                    <span class="s1">oid</span><span class="s4">, </span><span class="s1">array_oid </span><span class="s4">= </span><span class="s1">hstore_oids</span>
                    <span class="s1">kw </span><span class="s4">= {</span><span class="s2">&quot;oid&quot;</span><span class="s4">: </span><span class="s1">oid</span><span class="s4">}</span>
                    <span class="s1">kw</span><span class="s4">[</span><span class="s2">&quot;array_oid&quot;</span><span class="s4">] = </span><span class="s1">array_oid</span>
                    <span class="s1">extras</span><span class="s4">.</span><span class="s1">register_hstore</span><span class="s4">(</span><span class="s1">dbapi_conn</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">)</span>

            <span class="s1">fns</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">on_connect</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">dbapi </span><span class="s3">and </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_json_deserializer</span><span class="s4">:</span>

            <span class="s3">def </span><span class="s1">on_connect</span><span class="s4">(</span><span class="s1">dbapi_conn</span><span class="s4">):</span>
                <span class="s1">extras</span><span class="s4">.</span><span class="s1">register_default_json</span><span class="s4">(</span>
                    <span class="s1">dbapi_conn</span><span class="s4">, </span><span class="s1">loads</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_json_deserializer</span>
                <span class="s4">)</span>
                <span class="s1">extras</span><span class="s4">.</span><span class="s1">register_default_jsonb</span><span class="s4">(</span>
                    <span class="s1">dbapi_conn</span><span class="s4">, </span><span class="s1">loads</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_json_deserializer</span>
                <span class="s4">)</span>

            <span class="s1">fns</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">on_connect</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s1">fns</span><span class="s4">:</span>

            <span class="s3">def </span><span class="s1">on_connect</span><span class="s4">(</span><span class="s1">dbapi_conn</span><span class="s4">):</span>
                <span class="s3">for </span><span class="s1">fn </span><span class="s3">in </span><span class="s1">fns</span><span class="s4">:</span>
                    <span class="s1">fn</span><span class="s4">(</span><span class="s1">dbapi_conn</span><span class="s4">)</span>

            <span class="s3">return </span><span class="s1">on_connect</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return None</span>

    <span class="s3">def </span><span class="s1">do_executemany</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">cursor</span><span class="s4">, </span><span class="s1">statement</span><span class="s4">, </span><span class="s1">parameters</span><span class="s4">, </span><span class="s1">context</span><span class="s4">=</span><span class="s3">None</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">executemany_mode </span><span class="s3">is </span><span class="s1">EXECUTEMANY_VALUES_PLUS_BATCH</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">executemany_batch_page_size</span><span class="s4">:</span>
                <span class="s1">kwargs </span><span class="s4">= {</span><span class="s2">&quot;page_size&quot;</span><span class="s4">: </span><span class="s1">self</span><span class="s4">.</span><span class="s1">executemany_batch_page_size</span><span class="s4">}</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">kwargs </span><span class="s4">= {}</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_psycopg2_extras</span><span class="s4">.</span><span class="s1">execute_batch</span><span class="s4">(</span>
                <span class="s1">cursor</span><span class="s4">, </span><span class="s1">statement</span><span class="s4">, </span><span class="s1">parameters</span><span class="s4">, **</span><span class="s1">kwargs</span>
            <span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">cursor</span><span class="s4">.</span><span class="s1">executemany</span><span class="s4">(</span><span class="s1">statement</span><span class="s4">, </span><span class="s1">parameters</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">do_begin_twophase</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">connection</span><span class="s4">, </span><span class="s1">xid</span><span class="s4">):</span>
        <span class="s1">connection</span><span class="s4">.</span><span class="s1">connection</span><span class="s4">.</span><span class="s1">tpc_begin</span><span class="s4">(</span><span class="s1">xid</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">do_prepare_twophase</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">connection</span><span class="s4">, </span><span class="s1">xid</span><span class="s4">):</span>
        <span class="s1">connection</span><span class="s4">.</span><span class="s1">connection</span><span class="s4">.</span><span class="s1">tpc_prepare</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">_do_twophase</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">dbapi_conn</span><span class="s4">, </span><span class="s1">operation</span><span class="s4">, </span><span class="s1">xid</span><span class="s4">, </span><span class="s1">recover</span><span class="s4">=</span><span class="s3">False</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">recover</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">dbapi_conn</span><span class="s4">.</span><span class="s1">status </span><span class="s4">!= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_psycopg2_extensions</span><span class="s4">.</span><span class="s1">STATUS_READY</span><span class="s4">:</span>
                <span class="s1">dbapi_conn</span><span class="s4">.</span><span class="s1">rollback</span><span class="s4">()</span>
            <span class="s1">operation</span><span class="s4">(</span><span class="s1">xid</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">operation</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">do_rollback_twophase</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">connection</span><span class="s4">, </span><span class="s1">xid</span><span class="s4">, </span><span class="s1">is_prepared</span><span class="s4">=</span><span class="s3">True</span><span class="s4">, </span><span class="s1">recover</span><span class="s4">=</span><span class="s3">False</span>
    <span class="s4">):</span>
        <span class="s1">dbapi_conn </span><span class="s4">= </span><span class="s1">connection</span><span class="s4">.</span><span class="s1">connection</span><span class="s4">.</span><span class="s1">dbapi_connection</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_do_twophase</span><span class="s4">(</span>
            <span class="s1">dbapi_conn</span><span class="s4">, </span><span class="s1">dbapi_conn</span><span class="s4">.</span><span class="s1">tpc_rollback</span><span class="s4">, </span><span class="s1">xid</span><span class="s4">, </span><span class="s1">recover</span><span class="s4">=</span><span class="s1">recover</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">do_commit_twophase</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">connection</span><span class="s4">, </span><span class="s1">xid</span><span class="s4">, </span><span class="s1">is_prepared</span><span class="s4">=</span><span class="s3">True</span><span class="s4">, </span><span class="s1">recover</span><span class="s4">=</span><span class="s3">False</span>
    <span class="s4">):</span>
        <span class="s1">dbapi_conn </span><span class="s4">= </span><span class="s1">connection</span><span class="s4">.</span><span class="s1">connection</span><span class="s4">.</span><span class="s1">dbapi_connection</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_do_twophase</span><span class="s4">(</span>
            <span class="s1">dbapi_conn</span><span class="s4">, </span><span class="s1">dbapi_conn</span><span class="s4">.</span><span class="s1">tpc_commit</span><span class="s4">, </span><span class="s1">xid</span><span class="s4">, </span><span class="s1">recover</span><span class="s4">=</span><span class="s1">recover</span>
        <span class="s4">)</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">memoized_instancemethod</span>
    <span class="s3">def </span><span class="s1">_hstore_oids</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">dbapi_connection</span><span class="s4">):</span>
        <span class="s1">extras </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_psycopg2_extras</span>
        <span class="s1">oids </span><span class="s4">= </span><span class="s1">extras</span><span class="s4">.</span><span class="s1">HstoreAdapter</span><span class="s4">.</span><span class="s1">get_oids</span><span class="s4">(</span><span class="s1">dbapi_connection</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">oids </span><span class="s3">is not None and </span><span class="s1">oids</span><span class="s4">[</span><span class="s5">0</span><span class="s4">]:</span>
            <span class="s3">return </span><span class="s1">oids</span><span class="s4">[</span><span class="s5">0</span><span class="s4">:</span><span class="s5">2</span><span class="s4">]</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return None</span>

    <span class="s3">def </span><span class="s1">is_disconnect</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">e</span><span class="s4">, </span><span class="s1">connection</span><span class="s4">, </span><span class="s1">cursor</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">e</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">dbapi</span><span class="s4">.</span><span class="s1">Error</span><span class="s4">):</span>
            <span class="s0"># check the &quot;closed&quot; flag.  this might not be</span>
            <span class="s0"># present on old psycopg2 versions.   Also,</span>
            <span class="s0"># this flag doesn't actually help in a lot of disconnect</span>
            <span class="s0"># situations, so don't rely on it.</span>
            <span class="s3">if </span><span class="s1">getattr</span><span class="s4">(</span><span class="s1">connection</span><span class="s4">, </span><span class="s2">&quot;closed&quot;</span><span class="s4">, </span><span class="s3">False</span><span class="s4">):</span>
                <span class="s3">return True</span>

            <span class="s0"># checks based on strings.  in the case that .closed</span>
            <span class="s0"># didn't cut it, fall back onto these.</span>
            <span class="s1">str_e </span><span class="s4">= </span><span class="s1">str</span><span class="s4">(</span><span class="s1">e</span><span class="s4">).</span><span class="s1">partition</span><span class="s4">(</span><span class="s2">&quot;</span><span class="s3">\n</span><span class="s2">&quot;</span><span class="s4">)[</span><span class="s5">0</span><span class="s4">]</span>
            <span class="s3">for </span><span class="s1">msg </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_is_disconnect_messages</span><span class="s4">:</span>
                <span class="s1">idx </span><span class="s4">= </span><span class="s1">str_e</span><span class="s4">.</span><span class="s1">find</span><span class="s4">(</span><span class="s1">msg</span><span class="s4">)</span>
                <span class="s3">if </span><span class="s1">idx </span><span class="s4">&gt;= </span><span class="s5">0 </span><span class="s3">and </span><span class="s2">'&quot;' </span><span class="s3">not in </span><span class="s1">str_e</span><span class="s4">[:</span><span class="s1">idx</span><span class="s4">]:</span>
                    <span class="s3">return True</span>
        <span class="s3">return False</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">memoized_property</span>
    <span class="s3">def </span><span class="s1">_is_disconnect_messages</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s4">(</span>
            <span class="s0"># these error messages from libpq: interfaces/libpq/fe-misc.c</span>
            <span class="s0"># and interfaces/libpq/fe-secure.c.</span>
            <span class="s2">&quot;terminating connection&quot;</span><span class="s4">,</span>
            <span class="s2">&quot;closed the connection&quot;</span><span class="s4">,</span>
            <span class="s2">&quot;connection not open&quot;</span><span class="s4">,</span>
            <span class="s2">&quot;could not receive data from server&quot;</span><span class="s4">,</span>
            <span class="s2">&quot;could not send data to server&quot;</span><span class="s4">,</span>
            <span class="s0"># psycopg2 client errors, psycopg2/connection.h,</span>
            <span class="s0"># psycopg2/cursor.h</span>
            <span class="s2">&quot;connection already closed&quot;</span><span class="s4">,</span>
            <span class="s2">&quot;cursor already closed&quot;</span><span class="s4">,</span>
            <span class="s0"># not sure where this path is originally from, it may</span>
            <span class="s0"># be obsolete.   It really says &quot;losed&quot;, not &quot;closed&quot;.</span>
            <span class="s2">&quot;losed the connection unexpectedly&quot;</span><span class="s4">,</span>
            <span class="s0"># these can occur in newer SSL</span>
            <span class="s2">&quot;connection has been closed unexpectedly&quot;</span><span class="s4">,</span>
            <span class="s2">&quot;SSL error: decryption failed or bad record mac&quot;</span><span class="s4">,</span>
            <span class="s2">&quot;SSL SYSCALL error: Bad file descriptor&quot;</span><span class="s4">,</span>
            <span class="s2">&quot;SSL SYSCALL error: EOF detected&quot;</span><span class="s4">,</span>
            <span class="s2">&quot;SSL SYSCALL error: Operation timed out&quot;</span><span class="s4">,</span>
            <span class="s2">&quot;SSL SYSCALL error: Bad address&quot;</span><span class="s4">,</span>
            <span class="s0"># This can occur in OpenSSL 1 when an unexpected EOF occurs.</span>
            <span class="s0"># https://www.openssl.org/docs/man1.1.1/man3/SSL_get_error.html#BUGS</span>
            <span class="s0"># It may also occur in newer OpenSSL for a non-recoverable I/O</span>
            <span class="s0"># error as a result of a system call that does not set 'errno'</span>
            <span class="s0"># in libc.</span>
            <span class="s2">&quot;SSL SYSCALL error: Success&quot;</span><span class="s4">,</span>
        <span class="s4">)</span>


<span class="s1">dialect </span><span class="s4">= </span><span class="s1">PGDialect_psycopg2</span>
</pre>
</body>
</html>