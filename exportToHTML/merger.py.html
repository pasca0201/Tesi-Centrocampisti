<html>
<head>
<title>merger.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #6aab73;}
.s5 { color: #7a7e85;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
merger.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Merge OpenType Layout tables (GDEF / GPOS / GSUB). 
&quot;&quot;&quot;</span>

<span class="s2">import </span><span class="s1">os</span>
<span class="s2">import </span><span class="s1">copy</span>
<span class="s2">import </span><span class="s1">enum</span>
<span class="s2">from </span><span class="s1">operator </span><span class="s2">import </span><span class="s1">ior</span>
<span class="s2">import </span><span class="s1">logging</span>
<span class="s2">from </span><span class="s1">fontTools</span><span class="s3">.</span><span class="s1">colorLib</span><span class="s3">.</span><span class="s1">builder </span><span class="s2">import </span><span class="s1">MAX_PAINT_COLR_LAYER_COUNT</span><span class="s3">, </span><span class="s1">LayerReuseCache</span>
<span class="s2">from </span><span class="s1">fontTools</span><span class="s3">.</span><span class="s1">misc </span><span class="s2">import </span><span class="s1">classifyTools</span>
<span class="s2">from </span><span class="s1">fontTools</span><span class="s3">.</span><span class="s1">misc</span><span class="s3">.</span><span class="s1">roundTools </span><span class="s2">import </span><span class="s1">otRound</span>
<span class="s2">from </span><span class="s1">fontTools</span><span class="s3">.</span><span class="s1">misc</span><span class="s3">.</span><span class="s1">treeTools </span><span class="s2">import </span><span class="s1">build_n_ary_tree</span>
<span class="s2">from </span><span class="s1">fontTools</span><span class="s3">.</span><span class="s1">ttLib</span><span class="s3">.</span><span class="s1">tables </span><span class="s2">import </span><span class="s1">otTables </span><span class="s2">as </span><span class="s1">ot</span>
<span class="s2">from </span><span class="s1">fontTools</span><span class="s3">.</span><span class="s1">ttLib</span><span class="s3">.</span><span class="s1">tables </span><span class="s2">import </span><span class="s1">otBase </span><span class="s2">as </span><span class="s1">otBase</span>
<span class="s2">from </span><span class="s1">fontTools</span><span class="s3">.</span><span class="s1">ttLib</span><span class="s3">.</span><span class="s1">tables</span><span class="s3">.</span><span class="s1">otConverters </span><span class="s2">import </span><span class="s1">BaseFixedValue</span>
<span class="s2">from </span><span class="s1">fontTools</span><span class="s3">.</span><span class="s1">ttLib</span><span class="s3">.</span><span class="s1">tables</span><span class="s3">.</span><span class="s1">otTraverse </span><span class="s2">import </span><span class="s1">dfs_base_table</span>
<span class="s2">from </span><span class="s1">fontTools</span><span class="s3">.</span><span class="s1">ttLib</span><span class="s3">.</span><span class="s1">tables</span><span class="s3">.</span><span class="s1">DefaultTable </span><span class="s2">import </span><span class="s1">DefaultTable</span>
<span class="s2">from </span><span class="s1">fontTools</span><span class="s3">.</span><span class="s1">varLib </span><span class="s2">import </span><span class="s1">builder</span><span class="s3">, </span><span class="s1">models</span><span class="s3">, </span><span class="s1">varStore</span>
<span class="s2">from </span><span class="s1">fontTools</span><span class="s3">.</span><span class="s1">varLib</span><span class="s3">.</span><span class="s1">models </span><span class="s2">import </span><span class="s1">nonNone</span><span class="s3">, </span><span class="s1">allNone</span><span class="s3">, </span><span class="s1">allEqual</span><span class="s3">, </span><span class="s1">allEqualTo</span><span class="s3">, </span><span class="s1">subList</span>
<span class="s2">from </span><span class="s1">fontTools</span><span class="s3">.</span><span class="s1">varLib</span><span class="s3">.</span><span class="s1">varStore </span><span class="s2">import </span><span class="s1">VarStoreInstancer</span>
<span class="s2">from </span><span class="s1">functools </span><span class="s2">import </span><span class="s1">reduce</span>
<span class="s2">from </span><span class="s1">fontTools</span><span class="s3">.</span><span class="s1">otlLib</span><span class="s3">.</span><span class="s1">builder </span><span class="s2">import </span><span class="s1">buildSinglePos</span>
<span class="s2">from </span><span class="s1">fontTools</span><span class="s3">.</span><span class="s1">otlLib</span><span class="s3">.</span><span class="s1">optimize</span><span class="s3">.</span><span class="s1">gpos </span><span class="s2">import </span><span class="s3">(</span>
    <span class="s1">_compression_level_from_env</span><span class="s3">,</span>
    <span class="s1">compact_pair_pos</span><span class="s3">,</span>
<span class="s3">)</span>

<span class="s1">log </span><span class="s3">= </span><span class="s1">logging</span><span class="s3">.</span><span class="s1">getLogger</span><span class="s3">(</span><span class="s4">&quot;fontTools.varLib.merger&quot;</span><span class="s3">)</span>

<span class="s2">from </span><span class="s3">.</span><span class="s1">errors </span><span class="s2">import </span><span class="s3">(</span>
    <span class="s1">ShouldBeConstant</span><span class="s3">,</span>
    <span class="s1">FoundANone</span><span class="s3">,</span>
    <span class="s1">MismatchedTypes</span><span class="s3">,</span>
    <span class="s1">NotANone</span><span class="s3">,</span>
    <span class="s1">LengthsDiffer</span><span class="s3">,</span>
    <span class="s1">KeysDiffer</span><span class="s3">,</span>
    <span class="s1">InconsistentGlyphOrder</span><span class="s3">,</span>
    <span class="s1">InconsistentExtensions</span><span class="s3">,</span>
    <span class="s1">InconsistentFormats</span><span class="s3">,</span>
    <span class="s1">UnsupportedFormat</span><span class="s3">,</span>
    <span class="s1">VarLibMergeError</span><span class="s3">,</span>
<span class="s3">)</span>


<span class="s2">class </span><span class="s1">Merger</span><span class="s3">(</span><span class="s1">object</span><span class="s3">):</span>
    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">font</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">font </span><span class="s3">= </span><span class="s1">font</span>
        <span class="s5"># mergeTables populates this from the parent's master ttfs</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">ttfs </span><span class="s3">= </span><span class="s2">None</span>

    <span class="s3">@</span><span class="s1">classmethod</span>
    <span class="s2">def </span><span class="s1">merger</span><span class="s3">(</span><span class="s1">celf</span><span class="s3">, </span><span class="s1">clazzes</span><span class="s3">, </span><span class="s1">attrs</span><span class="s3">=(</span><span class="s2">None</span><span class="s3">,)):</span>
        <span class="s2">assert </span><span class="s1">celf </span><span class="s3">!= </span><span class="s1">Merger</span><span class="s3">, </span><span class="s4">&quot;Subclass Merger instead.&quot;</span>
        <span class="s2">if </span><span class="s4">&quot;mergers&quot; </span><span class="s2">not in </span><span class="s1">celf</span><span class="s3">.</span><span class="s1">__dict__</span><span class="s3">:</span>
            <span class="s1">celf</span><span class="s3">.</span><span class="s1">mergers </span><span class="s3">= {}</span>
        <span class="s2">if </span><span class="s1">type</span><span class="s3">(</span><span class="s1">clazzes</span><span class="s3">) </span><span class="s2">in </span><span class="s3">(</span><span class="s1">type</span><span class="s3">, </span><span class="s1">enum</span><span class="s3">.</span><span class="s1">EnumMeta</span><span class="s3">):</span>
            <span class="s1">clazzes </span><span class="s3">= (</span><span class="s1">clazzes</span><span class="s3">,)</span>
        <span class="s2">if </span><span class="s1">type</span><span class="s3">(</span><span class="s1">attrs</span><span class="s3">) == </span><span class="s1">str</span><span class="s3">:</span>
            <span class="s1">attrs </span><span class="s3">= (</span><span class="s1">attrs</span><span class="s3">,)</span>

        <span class="s2">def </span><span class="s1">wrapper</span><span class="s3">(</span><span class="s1">method</span><span class="s3">):</span>
            <span class="s2">assert </span><span class="s1">method</span><span class="s3">.</span><span class="s1">__name__ </span><span class="s3">== </span><span class="s4">&quot;merge&quot;</span>
            <span class="s1">done </span><span class="s3">= []</span>
            <span class="s2">for </span><span class="s1">clazz </span><span class="s2">in </span><span class="s1">clazzes</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">clazz </span><span class="s2">in </span><span class="s1">done</span><span class="s3">:</span>
                    <span class="s2">continue  </span><span class="s5"># Support multiple names of a clazz</span>
                <span class="s1">done</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">clazz</span><span class="s3">)</span>
                <span class="s1">mergers </span><span class="s3">= </span><span class="s1">celf</span><span class="s3">.</span><span class="s1">mergers</span><span class="s3">.</span><span class="s1">setdefault</span><span class="s3">(</span><span class="s1">clazz</span><span class="s3">, {})</span>
                <span class="s2">for </span><span class="s1">attr </span><span class="s2">in </span><span class="s1">attrs</span><span class="s3">:</span>
                    <span class="s2">assert </span><span class="s1">attr </span><span class="s2">not in </span><span class="s1">mergers</span><span class="s3">, (</span>
                        <span class="s4">&quot;Oops, class '%s' has merge function for '%s' defined already.&quot;</span>
                        <span class="s3">% (</span><span class="s1">clazz</span><span class="s3">.</span><span class="s1">__name__</span><span class="s3">, </span><span class="s1">attr</span><span class="s3">)</span>
                    <span class="s3">)</span>
                    <span class="s1">mergers</span><span class="s3">[</span><span class="s1">attr</span><span class="s3">] = </span><span class="s1">method</span>
            <span class="s2">return None</span>

        <span class="s2">return </span><span class="s1">wrapper</span>

    <span class="s3">@</span><span class="s1">classmethod</span>
    <span class="s2">def </span><span class="s1">mergersFor</span><span class="s3">(</span><span class="s1">celf</span><span class="s3">, </span><span class="s1">thing</span><span class="s3">, </span><span class="s1">_default</span><span class="s3">={}):</span>
        <span class="s1">typ </span><span class="s3">= </span><span class="s1">type</span><span class="s3">(</span><span class="s1">thing</span><span class="s3">)</span>

        <span class="s2">for </span><span class="s1">celf </span><span class="s2">in </span><span class="s1">celf</span><span class="s3">.</span><span class="s1">mro</span><span class="s3">():</span>
            <span class="s1">mergers </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">celf</span><span class="s3">, </span><span class="s4">&quot;mergers&quot;</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">mergers </span><span class="s2">is None</span><span class="s3">:</span>
                <span class="s2">break</span>

            <span class="s1">m </span><span class="s3">= </span><span class="s1">celf</span><span class="s3">.</span><span class="s1">mergers</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">typ</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">m </span><span class="s2">is not None</span><span class="s3">:</span>
                <span class="s2">return </span><span class="s1">m</span>

        <span class="s2">return </span><span class="s1">_default</span>

    <span class="s2">def </span><span class="s1">mergeObjects</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">out</span><span class="s3">, </span><span class="s1">lst</span><span class="s3">, </span><span class="s1">exclude</span><span class="s3">=()):</span>
        <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">out</span><span class="s3">, </span><span class="s4">&quot;ensureDecompiled&quot;</span><span class="s3">):</span>
            <span class="s1">out</span><span class="s3">.</span><span class="s1">ensureDecompiled</span><span class="s3">(</span><span class="s1">recurse</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
        <span class="s2">for </span><span class="s1">item </span><span class="s2">in </span><span class="s1">lst</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">item</span><span class="s3">, </span><span class="s4">&quot;ensureDecompiled&quot;</span><span class="s3">):</span>
                <span class="s1">item</span><span class="s3">.</span><span class="s1">ensureDecompiled</span><span class="s3">(</span><span class="s1">recurse</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
        <span class="s1">keys </span><span class="s3">= </span><span class="s1">sorted</span><span class="s3">(</span><span class="s1">vars</span><span class="s3">(</span><span class="s1">out</span><span class="s3">).</span><span class="s1">keys</span><span class="s3">())</span>
        <span class="s2">if not </span><span class="s1">all</span><span class="s3">(</span><span class="s1">keys </span><span class="s3">== </span><span class="s1">sorted</span><span class="s3">(</span><span class="s1">vars</span><span class="s3">(</span><span class="s1">v</span><span class="s3">).</span><span class="s1">keys</span><span class="s3">()) </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">lst</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">KeysDiffer</span><span class="s3">(</span>
                <span class="s1">self</span><span class="s3">, </span><span class="s1">expected</span><span class="s3">=</span><span class="s1">keys</span><span class="s3">, </span><span class="s1">got</span><span class="s3">=[</span><span class="s1">sorted</span><span class="s3">(</span><span class="s1">vars</span><span class="s3">(</span><span class="s1">v</span><span class="s3">).</span><span class="s1">keys</span><span class="s3">()) </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">lst</span><span class="s3">]</span>
            <span class="s3">)</span>
        <span class="s1">mergers </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">mergersFor</span><span class="s3">(</span><span class="s1">out</span><span class="s3">)</span>
        <span class="s1">defaultMerger </span><span class="s3">= </span><span class="s1">mergers</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">&quot;*&quot;</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__class__</span><span class="s3">.</span><span class="s1">mergeThings</span><span class="s3">)</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s2">for </span><span class="s1">key </span><span class="s2">in </span><span class="s1">keys</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">key </span><span class="s2">in </span><span class="s1">exclude</span><span class="s3">:</span>
                    <span class="s2">continue</span>
                <span class="s1">value </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">out</span><span class="s3">, </span><span class="s1">key</span><span class="s3">)</span>
                <span class="s1">values </span><span class="s3">= [</span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">table</span><span class="s3">, </span><span class="s1">key</span><span class="s3">) </span><span class="s2">for </span><span class="s1">table </span><span class="s2">in </span><span class="s1">lst</span><span class="s3">]</span>
                <span class="s1">mergerFunc </span><span class="s3">= </span><span class="s1">mergers</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">key</span><span class="s3">, </span><span class="s1">defaultMerger</span><span class="s3">)</span>
                <span class="s1">mergerFunc</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">values</span><span class="s3">)</span>
        <span class="s2">except </span><span class="s1">VarLibMergeError </span><span class="s2">as </span><span class="s1">e</span><span class="s3">:</span>
            <span class="s1">e</span><span class="s3">.</span><span class="s1">stack</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s4">&quot;.&quot; </span><span class="s3">+ </span><span class="s1">key</span><span class="s3">)</span>
            <span class="s2">raise</span>

    <span class="s2">def </span><span class="s1">mergeLists</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">out</span><span class="s3">, </span><span class="s1">lst</span><span class="s3">):</span>
        <span class="s2">if not </span><span class="s1">allEqualTo</span><span class="s3">(</span><span class="s1">out</span><span class="s3">, </span><span class="s1">lst</span><span class="s3">, </span><span class="s1">len</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">LengthsDiffer</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">expected</span><span class="s3">=</span><span class="s1">len</span><span class="s3">(</span><span class="s1">out</span><span class="s3">), </span><span class="s1">got</span><span class="s3">=[</span><span class="s1">len</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">lst</span><span class="s3">])</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s3">, (</span><span class="s1">value</span><span class="s3">, </span><span class="s1">values</span><span class="s3">) </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">zip</span><span class="s3">(</span><span class="s1">out</span><span class="s3">, </span><span class="s1">zip</span><span class="s3">(*</span><span class="s1">lst</span><span class="s3">))):</span>
            <span class="s2">try</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">mergeThings</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">values</span><span class="s3">)</span>
            <span class="s2">except </span><span class="s1">VarLibMergeError </span><span class="s2">as </span><span class="s1">e</span><span class="s3">:</span>
                <span class="s1">e</span><span class="s3">.</span><span class="s1">stack</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s4">&quot;[%d]&quot; </span><span class="s3">% </span><span class="s1">i</span><span class="s3">)</span>
                <span class="s2">raise</span>

    <span class="s2">def </span><span class="s1">mergeThings</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">out</span><span class="s3">, </span><span class="s1">lst</span><span class="s3">):</span>
        <span class="s2">if not </span><span class="s1">allEqualTo</span><span class="s3">(</span><span class="s1">out</span><span class="s3">, </span><span class="s1">lst</span><span class="s3">, </span><span class="s1">type</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">MismatchedTypes</span><span class="s3">(</span>
                <span class="s1">self</span><span class="s3">, </span><span class="s1">expected</span><span class="s3">=</span><span class="s1">type</span><span class="s3">(</span><span class="s1">out</span><span class="s3">).</span><span class="s1">__name__</span><span class="s3">, </span><span class="s1">got</span><span class="s3">=[</span><span class="s1">type</span><span class="s3">(</span><span class="s1">x</span><span class="s3">).</span><span class="s1">__name__ </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">lst</span><span class="s3">]</span>
            <span class="s3">)</span>
        <span class="s1">mergerFunc </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">mergersFor</span><span class="s3">(</span><span class="s1">out</span><span class="s3">).</span><span class="s1">get</span><span class="s3">(</span><span class="s2">None</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">mergerFunc </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s1">mergerFunc</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">out</span><span class="s3">, </span><span class="s1">lst</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">out</span><span class="s3">, </span><span class="s1">enum</span><span class="s3">.</span><span class="s1">Enum</span><span class="s3">):</span>
            <span class="s5"># need to special-case Enums as have __dict__ but are not regular 'objects',</span>
            <span class="s5"># otherwise mergeObjects/mergeThings get trapped in a RecursionError</span>
            <span class="s2">if not </span><span class="s1">allEqualTo</span><span class="s3">(</span><span class="s1">out</span><span class="s3">, </span><span class="s1">lst</span><span class="s3">):</span>
                <span class="s2">raise </span><span class="s1">ShouldBeConstant</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">expected</span><span class="s3">=</span><span class="s1">out</span><span class="s3">, </span><span class="s1">got</span><span class="s3">=</span><span class="s1">lst</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">out</span><span class="s3">, </span><span class="s4">&quot;__dict__&quot;</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">mergeObjects</span><span class="s3">(</span><span class="s1">out</span><span class="s3">, </span><span class="s1">lst</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">out</span><span class="s3">, </span><span class="s1">list</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">mergeLists</span><span class="s3">(</span><span class="s1">out</span><span class="s3">, </span><span class="s1">lst</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">if not </span><span class="s1">allEqualTo</span><span class="s3">(</span><span class="s1">out</span><span class="s3">, </span><span class="s1">lst</span><span class="s3">):</span>
                <span class="s2">raise </span><span class="s1">ShouldBeConstant</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">expected</span><span class="s3">=</span><span class="s1">out</span><span class="s3">, </span><span class="s1">got</span><span class="s3">=</span><span class="s1">lst</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">mergeTables</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">font</span><span class="s3">, </span><span class="s1">master_ttfs</span><span class="s3">, </span><span class="s1">tableTags</span><span class="s3">):</span>
        <span class="s2">for </span><span class="s1">tag </span><span class="s2">in </span><span class="s1">tableTags</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">tag </span><span class="s2">not in </span><span class="s1">font</span><span class="s3">:</span>
                <span class="s2">continue</span>
            <span class="s2">try</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">ttfs </span><span class="s3">= </span><span class="s1">master_ttfs</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">mergeThings</span><span class="s3">(</span><span class="s1">font</span><span class="s3">[</span><span class="s1">tag</span><span class="s3">], [</span><span class="s1">m</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">tag</span><span class="s3">) </span><span class="s2">for </span><span class="s1">m </span><span class="s2">in </span><span class="s1">master_ttfs</span><span class="s3">])</span>
            <span class="s2">except </span><span class="s1">VarLibMergeError </span><span class="s2">as </span><span class="s1">e</span><span class="s3">:</span>
                <span class="s1">e</span><span class="s3">.</span><span class="s1">stack</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">tag</span><span class="s3">)</span>
                <span class="s2">raise</span>


<span class="s5">#</span>
<span class="s5"># Aligning merger</span>
<span class="s5">#</span>
<span class="s2">class </span><span class="s1">AligningMerger</span><span class="s3">(</span><span class="s1">Merger</span><span class="s3">):</span>
    <span class="s2">pass</span>


<span class="s3">@</span><span class="s1">AligningMerger</span><span class="s3">.</span><span class="s1">merger</span><span class="s3">(</span><span class="s1">ot</span><span class="s3">.</span><span class="s1">GDEF</span><span class="s3">, </span><span class="s4">&quot;GlyphClassDef&quot;</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">merge</span><span class="s3">(</span><span class="s1">merger</span><span class="s3">, </span><span class="s1">self</span><span class="s3">, </span><span class="s1">lst</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">self </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s2">if not </span><span class="s1">allNone</span><span class="s3">(</span><span class="s1">lst</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">NotANone</span><span class="s3">(</span><span class="s1">merger</span><span class="s3">, </span><span class="s1">expected</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">got</span><span class="s3">=</span><span class="s1">lst</span><span class="s3">)</span>
        <span class="s2">return</span>

    <span class="s1">lst </span><span class="s3">= [</span><span class="s1">l</span><span class="s3">.</span><span class="s1">classDefs </span><span class="s2">for </span><span class="s1">l </span><span class="s2">in </span><span class="s1">lst</span><span class="s3">]</span>
    <span class="s1">self</span><span class="s3">.</span><span class="s1">classDefs </span><span class="s3">= {}</span>
    <span class="s5"># We only care about the .classDefs</span>
    <span class="s1">self </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">classDefs</span>

    <span class="s1">allKeys </span><span class="s3">= </span><span class="s1">set</span><span class="s3">()</span>
    <span class="s1">allKeys</span><span class="s3">.</span><span class="s1">update</span><span class="s3">(*[</span><span class="s1">l</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">() </span><span class="s2">for </span><span class="s1">l </span><span class="s2">in </span><span class="s1">lst</span><span class="s3">])</span>
    <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">allKeys</span><span class="s3">:</span>
        <span class="s1">allValues </span><span class="s3">= </span><span class="s1">nonNone</span><span class="s3">(</span><span class="s1">l</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">k</span><span class="s3">) </span><span class="s2">for </span><span class="s1">l </span><span class="s2">in </span><span class="s1">lst</span><span class="s3">)</span>
        <span class="s2">if not </span><span class="s1">allEqual</span><span class="s3">(</span><span class="s1">allValues</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">ShouldBeConstant</span><span class="s3">(</span>
                <span class="s1">merger</span><span class="s3">, </span><span class="s1">expected</span><span class="s3">=</span><span class="s1">allValues</span><span class="s3">[</span><span class="s6">0</span><span class="s3">], </span><span class="s1">got</span><span class="s3">=</span><span class="s1">lst</span><span class="s3">, </span><span class="s1">stack</span><span class="s3">=[</span><span class="s4">&quot;.&quot; </span><span class="s3">+ </span><span class="s1">k</span><span class="s3">]</span>
            <span class="s3">)</span>
        <span class="s2">if not </span><span class="s1">allValues</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">[</span><span class="s1">k</span><span class="s3">] = </span><span class="s2">None</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">[</span><span class="s1">k</span><span class="s3">] = </span><span class="s1">allValues</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]</span>


<span class="s2">def </span><span class="s1">_SinglePosUpgradeToFormat2</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">Format </span><span class="s3">== </span><span class="s6">2</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s1">ret </span><span class="s3">= </span><span class="s1">ot</span><span class="s3">.</span><span class="s1">SinglePos</span><span class="s3">()</span>
    <span class="s1">ret</span><span class="s3">.</span><span class="s1">Format </span><span class="s3">= </span><span class="s6">2</span>
    <span class="s1">ret</span><span class="s3">.</span><span class="s1">Coverage </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">Coverage</span>
    <span class="s1">ret</span><span class="s3">.</span><span class="s1">ValueFormat </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">ValueFormat</span>
    <span class="s1">ret</span><span class="s3">.</span><span class="s1">Value </span><span class="s3">= [</span><span class="s1">self</span><span class="s3">.</span><span class="s1">Value </span><span class="s2">for </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">ret</span><span class="s3">.</span><span class="s1">Coverage</span><span class="s3">.</span><span class="s1">glyphs</span><span class="s3">]</span>
    <span class="s1">ret</span><span class="s3">.</span><span class="s1">ValueCount </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">ret</span><span class="s3">.</span><span class="s1">Value</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">ret</span>


<span class="s2">def </span><span class="s1">_merge_GlyphOrders</span><span class="s3">(</span><span class="s1">font</span><span class="s3">, </span><span class="s1">lst</span><span class="s3">, </span><span class="s1">values_lst</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">default</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Takes font and list of glyph lists (must be sorted by glyph id), and returns 
    two things: 
    - Combined glyph list, 
    - If values_lst is None, return input glyph lists, but padded with None when a glyph 
      was missing in a list.  Otherwise, return values_lst list-of-list, padded with None 
      to match combined glyph lists. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">values_lst </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">dict_sets </span><span class="s3">= [</span><span class="s1">set</span><span class="s3">(</span><span class="s1">l</span><span class="s3">) </span><span class="s2">for </span><span class="s1">l </span><span class="s2">in </span><span class="s1">lst</span><span class="s3">]</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">dict_sets </span><span class="s3">= [{</span><span class="s1">g</span><span class="s3">: </span><span class="s1">v </span><span class="s2">for </span><span class="s1">g</span><span class="s3">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">l</span><span class="s3">, </span><span class="s1">vs</span><span class="s3">)} </span><span class="s2">for </span><span class="s1">l</span><span class="s3">, </span><span class="s1">vs </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">lst</span><span class="s3">, </span><span class="s1">values_lst</span><span class="s3">)]</span>
    <span class="s1">combined </span><span class="s3">= </span><span class="s1">set</span><span class="s3">()</span>
    <span class="s1">combined</span><span class="s3">.</span><span class="s1">update</span><span class="s3">(*</span><span class="s1">dict_sets</span><span class="s3">)</span>

    <span class="s1">sortKey </span><span class="s3">= </span><span class="s1">font</span><span class="s3">.</span><span class="s1">getReverseGlyphMap</span><span class="s3">().</span><span class="s1">__getitem__</span>
    <span class="s1">order </span><span class="s3">= </span><span class="s1">sorted</span><span class="s3">(</span><span class="s1">combined</span><span class="s3">, </span><span class="s1">key</span><span class="s3">=</span><span class="s1">sortKey</span><span class="s3">)</span>
    <span class="s5"># Make sure all input glyphsets were in proper order</span>
    <span class="s2">if not </span><span class="s1">all</span><span class="s3">(</span><span class="s1">sorted</span><span class="s3">(</span><span class="s1">vs</span><span class="s3">, </span><span class="s1">key</span><span class="s3">=</span><span class="s1">sortKey</span><span class="s3">) == </span><span class="s1">vs </span><span class="s2">for </span><span class="s1">vs </span><span class="s2">in </span><span class="s1">lst</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">InconsistentGlyphOrder</span><span class="s3">()</span>
    <span class="s2">del </span><span class="s1">combined</span>

    <span class="s1">paddedValues </span><span class="s3">= </span><span class="s2">None</span>
    <span class="s2">if </span><span class="s1">values_lst </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">padded </span><span class="s3">= [</span>
            <span class="s3">[</span><span class="s1">glyph </span><span class="s2">if </span><span class="s1">glyph </span><span class="s2">in </span><span class="s1">dict_set </span><span class="s2">else </span><span class="s1">default </span><span class="s2">for </span><span class="s1">glyph </span><span class="s2">in </span><span class="s1">order</span><span class="s3">]</span>
            <span class="s2">for </span><span class="s1">dict_set </span><span class="s2">in </span><span class="s1">dict_sets</span>
        <span class="s3">]</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">assert </span><span class="s1">len</span><span class="s3">(</span><span class="s1">lst</span><span class="s3">) == </span><span class="s1">len</span><span class="s3">(</span><span class="s1">values_lst</span><span class="s3">)</span>
        <span class="s1">padded </span><span class="s3">= [</span>
            <span class="s3">[</span><span class="s1">dict_set</span><span class="s3">[</span><span class="s1">glyph</span><span class="s3">] </span><span class="s2">if </span><span class="s1">glyph </span><span class="s2">in </span><span class="s1">dict_set </span><span class="s2">else </span><span class="s1">default </span><span class="s2">for </span><span class="s1">glyph </span><span class="s2">in </span><span class="s1">order</span><span class="s3">]</span>
            <span class="s2">for </span><span class="s1">dict_set </span><span class="s2">in </span><span class="s1">dict_sets</span>
        <span class="s3">]</span>
    <span class="s2">return </span><span class="s1">order</span><span class="s3">, </span><span class="s1">padded</span>


<span class="s3">@</span><span class="s1">AligningMerger</span><span class="s3">.</span><span class="s1">merger</span><span class="s3">(</span><span class="s1">otBase</span><span class="s3">.</span><span class="s1">ValueRecord</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">merge</span><span class="s3">(</span><span class="s1">merger</span><span class="s3">, </span><span class="s1">self</span><span class="s3">, </span><span class="s1">lst</span><span class="s3">):</span>
    <span class="s5"># Code below sometimes calls us with self being</span>
    <span class="s5"># a new object. Copy it from lst and recurse.</span>
    <span class="s1">self</span><span class="s3">.</span><span class="s1">__dict__ </span><span class="s3">= </span><span class="s1">lst</span><span class="s3">[</span><span class="s6">0</span><span class="s3">].</span><span class="s1">__dict__</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>
    <span class="s1">merger</span><span class="s3">.</span><span class="s1">mergeObjects</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">lst</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">AligningMerger</span><span class="s3">.</span><span class="s1">merger</span><span class="s3">(</span><span class="s1">ot</span><span class="s3">.</span><span class="s1">Anchor</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">merge</span><span class="s3">(</span><span class="s1">merger</span><span class="s3">, </span><span class="s1">self</span><span class="s3">, </span><span class="s1">lst</span><span class="s3">):</span>
    <span class="s5"># Code below sometimes calls us with self being</span>
    <span class="s5"># a new object. Copy it from lst and recurse.</span>
    <span class="s1">self</span><span class="s3">.</span><span class="s1">__dict__ </span><span class="s3">= </span><span class="s1">lst</span><span class="s3">[</span><span class="s6">0</span><span class="s3">].</span><span class="s1">__dict__</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>
    <span class="s1">merger</span><span class="s3">.</span><span class="s1">mergeObjects</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">lst</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">_Lookup_SinglePos_get_effective_value</span><span class="s3">(</span><span class="s1">merger</span><span class="s3">, </span><span class="s1">subtables</span><span class="s3">, </span><span class="s1">glyph</span><span class="s3">):</span>
    <span class="s2">for </span><span class="s1">self </span><span class="s2">in </span><span class="s1">subtables</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s3">(</span>
            <span class="s1">self </span><span class="s2">is None</span>
            <span class="s2">or </span><span class="s1">type</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) != </span><span class="s1">ot</span><span class="s3">.</span><span class="s1">SinglePos</span>
            <span class="s2">or </span><span class="s1">self</span><span class="s3">.</span><span class="s1">Coverage </span><span class="s2">is None</span>
            <span class="s2">or </span><span class="s1">glyph </span><span class="s2">not in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">Coverage</span><span class="s3">.</span><span class="s1">glyphs</span>
        <span class="s3">):</span>
            <span class="s2">continue</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">Format </span><span class="s3">== </span><span class="s6">1</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">Value</span>
        <span class="s2">elif </span><span class="s1">self</span><span class="s3">.</span><span class="s1">Format </span><span class="s3">== </span><span class="s6">2</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">Value</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">Coverage</span><span class="s3">.</span><span class="s1">glyphs</span><span class="s3">.</span><span class="s1">index</span><span class="s3">(</span><span class="s1">glyph</span><span class="s3">)]</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">UnsupportedFormat</span><span class="s3">(</span><span class="s1">merger</span><span class="s3">, </span><span class="s1">subtable</span><span class="s3">=</span><span class="s4">&quot;single positioning lookup&quot;</span><span class="s3">)</span>
    <span class="s2">return None</span>


<span class="s2">def </span><span class="s1">_Lookup_PairPos_get_effective_value_pair</span><span class="s3">(</span>
    <span class="s1">merger</span><span class="s3">, </span><span class="s1">subtables</span><span class="s3">, </span><span class="s1">firstGlyph</span><span class="s3">, </span><span class="s1">secondGlyph</span>
<span class="s3">):</span>
    <span class="s2">for </span><span class="s1">self </span><span class="s2">in </span><span class="s1">subtables</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s3">(</span>
            <span class="s1">self </span><span class="s2">is None</span>
            <span class="s2">or </span><span class="s1">type</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) != </span><span class="s1">ot</span><span class="s3">.</span><span class="s1">PairPos</span>
            <span class="s2">or </span><span class="s1">self</span><span class="s3">.</span><span class="s1">Coverage </span><span class="s2">is None</span>
            <span class="s2">or </span><span class="s1">firstGlyph </span><span class="s2">not in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">Coverage</span><span class="s3">.</span><span class="s1">glyphs</span>
        <span class="s3">):</span>
            <span class="s2">continue</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">Format </span><span class="s3">== </span><span class="s6">1</span><span class="s3">:</span>
            <span class="s1">ps </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">PairSet</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">Coverage</span><span class="s3">.</span><span class="s1">glyphs</span><span class="s3">.</span><span class="s1">index</span><span class="s3">(</span><span class="s1">firstGlyph</span><span class="s3">)]</span>
            <span class="s1">pvr </span><span class="s3">= </span><span class="s1">ps</span><span class="s3">.</span><span class="s1">PairValueRecord</span>
            <span class="s2">for </span><span class="s1">rec </span><span class="s2">in </span><span class="s1">pvr</span><span class="s3">:  </span><span class="s5"># TODO Speed up</span>
                <span class="s2">if </span><span class="s1">rec</span><span class="s3">.</span><span class="s1">SecondGlyph </span><span class="s3">== </span><span class="s1">secondGlyph</span><span class="s3">:</span>
                    <span class="s2">return </span><span class="s1">rec</span>
            <span class="s2">continue</span>
        <span class="s2">elif </span><span class="s1">self</span><span class="s3">.</span><span class="s1">Format </span><span class="s3">== </span><span class="s6">2</span><span class="s3">:</span>
            <span class="s1">klass1 </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">ClassDef1</span><span class="s3">.</span><span class="s1">classDefs</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">firstGlyph</span><span class="s3">, </span><span class="s6">0</span><span class="s3">)</span>
            <span class="s1">klass2 </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">ClassDef2</span><span class="s3">.</span><span class="s1">classDefs</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">secondGlyph</span><span class="s3">, </span><span class="s6">0</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">Class1Record</span><span class="s3">[</span><span class="s1">klass1</span><span class="s3">].</span><span class="s1">Class2Record</span><span class="s3">[</span><span class="s1">klass2</span><span class="s3">]</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">UnsupportedFormat</span><span class="s3">(</span><span class="s1">merger</span><span class="s3">, </span><span class="s1">subtable</span><span class="s3">=</span><span class="s4">&quot;pair positioning lookup&quot;</span><span class="s3">)</span>
    <span class="s2">return None</span>


<span class="s3">@</span><span class="s1">AligningMerger</span><span class="s3">.</span><span class="s1">merger</span><span class="s3">(</span><span class="s1">ot</span><span class="s3">.</span><span class="s1">SinglePos</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">merge</span><span class="s3">(</span><span class="s1">merger</span><span class="s3">, </span><span class="s1">self</span><span class="s3">, </span><span class="s1">lst</span><span class="s3">):</span>
    <span class="s1">self</span><span class="s3">.</span><span class="s1">ValueFormat </span><span class="s3">= </span><span class="s1">valueFormat </span><span class="s3">= </span><span class="s1">reduce</span><span class="s3">(</span><span class="s1">int</span><span class="s3">.</span><span class="s1">__or__</span><span class="s3">, [</span><span class="s1">l</span><span class="s3">.</span><span class="s1">ValueFormat </span><span class="s2">for </span><span class="s1">l </span><span class="s2">in </span><span class="s1">lst</span><span class="s3">], </span><span class="s6">0</span><span class="s3">)</span>
    <span class="s2">if not </span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">lst</span><span class="s3">) == </span><span class="s6">1 </span><span class="s2">or </span><span class="s3">(</span><span class="s1">valueFormat </span><span class="s3">&amp; ~</span><span class="s6">0xF </span><span class="s3">== </span><span class="s6">0</span><span class="s3">)):</span>
        <span class="s2">raise </span><span class="s1">UnsupportedFormat</span><span class="s3">(</span><span class="s1">merger</span><span class="s3">, </span><span class="s1">subtable</span><span class="s3">=</span><span class="s4">&quot;single positioning lookup&quot;</span><span class="s3">)</span>

    <span class="s5"># If all have same coverage table and all are format 1,</span>
    <span class="s1">coverageGlyphs </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">Coverage</span><span class="s3">.</span><span class="s1">glyphs</span>
    <span class="s2">if </span><span class="s1">all</span><span class="s3">(</span><span class="s1">v</span><span class="s3">.</span><span class="s1">Format </span><span class="s3">== </span><span class="s6">1 </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">lst</span><span class="s3">) </span><span class="s2">and </span><span class="s1">all</span><span class="s3">(</span>
        <span class="s1">coverageGlyphs </span><span class="s3">== </span><span class="s1">v</span><span class="s3">.</span><span class="s1">Coverage</span><span class="s3">.</span><span class="s1">glyphs </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">lst</span>
    <span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">Value </span><span class="s3">= </span><span class="s1">otBase</span><span class="s3">.</span><span class="s1">ValueRecord</span><span class="s3">(</span><span class="s1">valueFormat</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">Value</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">valueFormat </span><span class="s3">!= </span><span class="s6">0</span><span class="s3">:</span>
            <span class="s5"># If v.Value is None, it means a kerning of 0; we want</span>
            <span class="s5"># it to participate in the model still.</span>
            <span class="s5"># https://github.com/fonttools/fonttools/issues/3111</span>
            <span class="s1">merger</span><span class="s3">.</span><span class="s1">mergeThings</span><span class="s3">(</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">Value</span><span class="s3">,</span>
                <span class="s3">[</span><span class="s1">v</span><span class="s3">.</span><span class="s1">Value </span><span class="s2">if </span><span class="s1">v</span><span class="s3">.</span><span class="s1">Value </span><span class="s2">is not None else </span><span class="s1">otBase</span><span class="s3">.</span><span class="s1">ValueRecord</span><span class="s3">() </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">lst</span><span class="s3">],</span>
            <span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">ValueFormat </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">Value</span><span class="s3">.</span><span class="s1">getFormat</span><span class="s3">()</span>
        <span class="s2">return</span>

    <span class="s5"># Upgrade everything to Format=2</span>
    <span class="s1">self</span><span class="s3">.</span><span class="s1">Format </span><span class="s3">= </span><span class="s6">2</span>
    <span class="s1">lst </span><span class="s3">= [</span><span class="s1">_SinglePosUpgradeToFormat2</span><span class="s3">(</span><span class="s1">v</span><span class="s3">) </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">lst</span><span class="s3">]</span>

    <span class="s5"># Align them</span>
    <span class="s1">glyphs</span><span class="s3">, </span><span class="s1">padded </span><span class="s3">= </span><span class="s1">_merge_GlyphOrders</span><span class="s3">(</span>
        <span class="s1">merger</span><span class="s3">.</span><span class="s1">font</span><span class="s3">, [</span><span class="s1">v</span><span class="s3">.</span><span class="s1">Coverage</span><span class="s3">.</span><span class="s1">glyphs </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">lst</span><span class="s3">], [</span><span class="s1">v</span><span class="s3">.</span><span class="s1">Value </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">lst</span><span class="s3">]</span>
    <span class="s3">)</span>

    <span class="s1">self</span><span class="s3">.</span><span class="s1">Coverage</span><span class="s3">.</span><span class="s1">glyphs </span><span class="s3">= </span><span class="s1">glyphs</span>
    <span class="s1">self</span><span class="s3">.</span><span class="s1">Value </span><span class="s3">= [</span><span class="s1">otBase</span><span class="s3">.</span><span class="s1">ValueRecord</span><span class="s3">(</span><span class="s1">valueFormat</span><span class="s3">) </span><span class="s2">for </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">glyphs</span><span class="s3">]</span>
    <span class="s1">self</span><span class="s3">.</span><span class="s1">ValueCount </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">Value</span><span class="s3">)</span>

    <span class="s2">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">values </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">padded</span><span class="s3">):</span>
        <span class="s2">for </span><span class="s1">j</span><span class="s3">, </span><span class="s1">glyph </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">glyphs</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">values</span><span class="s3">[</span><span class="s1">j</span><span class="s3">] </span><span class="s2">is not None</span><span class="s3">:</span>
                <span class="s2">continue</span>
            <span class="s5"># Fill in value from other subtables</span>
            <span class="s5"># Note!!! This *might* result in behavior change if ValueFormat2-zeroedness</span>
            <span class="s5"># is different between used subtable and current subtable!</span>
            <span class="s5"># TODO(behdad) Check and warn if that happens?</span>
            <span class="s1">v </span><span class="s3">= </span><span class="s1">_Lookup_SinglePos_get_effective_value</span><span class="s3">(</span>
                <span class="s1">merger</span><span class="s3">, </span><span class="s1">merger</span><span class="s3">.</span><span class="s1">lookup_subtables</span><span class="s3">[</span><span class="s1">i</span><span class="s3">], </span><span class="s1">glyph</span>
            <span class="s3">)</span>
            <span class="s2">if </span><span class="s1">v </span><span class="s2">is None</span><span class="s3">:</span>
                <span class="s1">v </span><span class="s3">= </span><span class="s1">otBase</span><span class="s3">.</span><span class="s1">ValueRecord</span><span class="s3">(</span><span class="s1">valueFormat</span><span class="s3">)</span>
            <span class="s1">values</span><span class="s3">[</span><span class="s1">j</span><span class="s3">] = </span><span class="s1">v</span>

    <span class="s1">merger</span><span class="s3">.</span><span class="s1">mergeLists</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">Value</span><span class="s3">, </span><span class="s1">padded</span><span class="s3">)</span>

    <span class="s5"># Merge everything else; though, there shouldn't be anything else. :)</span>
    <span class="s1">merger</span><span class="s3">.</span><span class="s1">mergeObjects</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">lst</span><span class="s3">, </span><span class="s1">exclude</span><span class="s3">=(</span><span class="s4">&quot;Format&quot;</span><span class="s3">, </span><span class="s4">&quot;Coverage&quot;</span><span class="s3">, </span><span class="s4">&quot;Value&quot;</span><span class="s3">, </span><span class="s4">&quot;ValueCount&quot;</span><span class="s3">, </span><span class="s4">&quot;ValueFormat&quot;</span><span class="s3">)</span>
    <span class="s3">)</span>
    <span class="s1">self</span><span class="s3">.</span><span class="s1">ValueFormat </span><span class="s3">= </span><span class="s1">reduce</span><span class="s3">(</span>
        <span class="s1">int</span><span class="s3">.</span><span class="s1">__or__</span><span class="s3">, [</span><span class="s1">v</span><span class="s3">.</span><span class="s1">getEffectiveFormat</span><span class="s3">() </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">Value</span><span class="s3">], </span><span class="s6">0</span>
    <span class="s3">)</span>


<span class="s3">@</span><span class="s1">AligningMerger</span><span class="s3">.</span><span class="s1">merger</span><span class="s3">(</span><span class="s1">ot</span><span class="s3">.</span><span class="s1">PairSet</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">merge</span><span class="s3">(</span><span class="s1">merger</span><span class="s3">, </span><span class="s1">self</span><span class="s3">, </span><span class="s1">lst</span><span class="s3">):</span>
    <span class="s5"># Align them</span>
    <span class="s1">glyphs</span><span class="s3">, </span><span class="s1">padded </span><span class="s3">= </span><span class="s1">_merge_GlyphOrders</span><span class="s3">(</span>
        <span class="s1">merger</span><span class="s3">.</span><span class="s1">font</span><span class="s3">,</span>
        <span class="s3">[[</span><span class="s1">v</span><span class="s3">.</span><span class="s1">SecondGlyph </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">vs</span><span class="s3">.</span><span class="s1">PairValueRecord</span><span class="s3">] </span><span class="s2">for </span><span class="s1">vs </span><span class="s2">in </span><span class="s1">lst</span><span class="s3">],</span>
        <span class="s3">[</span><span class="s1">vs</span><span class="s3">.</span><span class="s1">PairValueRecord </span><span class="s2">for </span><span class="s1">vs </span><span class="s2">in </span><span class="s1">lst</span><span class="s3">],</span>
    <span class="s3">)</span>

    <span class="s1">self</span><span class="s3">.</span><span class="s1">PairValueRecord </span><span class="s3">= </span><span class="s1">pvrs </span><span class="s3">= []</span>
    <span class="s2">for </span><span class="s1">glyph </span><span class="s2">in </span><span class="s1">glyphs</span><span class="s3">:</span>
        <span class="s1">pvr </span><span class="s3">= </span><span class="s1">ot</span><span class="s3">.</span><span class="s1">PairValueRecord</span><span class="s3">()</span>
        <span class="s1">pvr</span><span class="s3">.</span><span class="s1">SecondGlyph </span><span class="s3">= </span><span class="s1">glyph</span>
        <span class="s1">pvr</span><span class="s3">.</span><span class="s1">Value1 </span><span class="s3">= (</span>
            <span class="s1">otBase</span><span class="s3">.</span><span class="s1">ValueRecord</span><span class="s3">(</span><span class="s1">merger</span><span class="s3">.</span><span class="s1">valueFormat1</span><span class="s3">) </span><span class="s2">if </span><span class="s1">merger</span><span class="s3">.</span><span class="s1">valueFormat1 </span><span class="s2">else None</span>
        <span class="s3">)</span>
        <span class="s1">pvr</span><span class="s3">.</span><span class="s1">Value2 </span><span class="s3">= (</span>
            <span class="s1">otBase</span><span class="s3">.</span><span class="s1">ValueRecord</span><span class="s3">(</span><span class="s1">merger</span><span class="s3">.</span><span class="s1">valueFormat2</span><span class="s3">) </span><span class="s2">if </span><span class="s1">merger</span><span class="s3">.</span><span class="s1">valueFormat2 </span><span class="s2">else None</span>
        <span class="s3">)</span>
        <span class="s1">pvrs</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">pvr</span><span class="s3">)</span>
    <span class="s1">self</span><span class="s3">.</span><span class="s1">PairValueCount </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">PairValueRecord</span><span class="s3">)</span>

    <span class="s2">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">values </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">padded</span><span class="s3">):</span>
        <span class="s2">for </span><span class="s1">j</span><span class="s3">, </span><span class="s1">glyph </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">glyphs</span><span class="s3">):</span>
            <span class="s5"># Fill in value from other subtables</span>
            <span class="s1">v </span><span class="s3">= </span><span class="s1">ot</span><span class="s3">.</span><span class="s1">PairValueRecord</span><span class="s3">()</span>
            <span class="s1">v</span><span class="s3">.</span><span class="s1">SecondGlyph </span><span class="s3">= </span><span class="s1">glyph</span>
            <span class="s2">if </span><span class="s1">values</span><span class="s3">[</span><span class="s1">j</span><span class="s3">] </span><span class="s2">is not None</span><span class="s3">:</span>
                <span class="s1">vpair </span><span class="s3">= </span><span class="s1">values</span><span class="s3">[</span><span class="s1">j</span><span class="s3">]</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">vpair </span><span class="s3">= </span><span class="s1">_Lookup_PairPos_get_effective_value_pair</span><span class="s3">(</span>
                    <span class="s1">merger</span><span class="s3">, </span><span class="s1">merger</span><span class="s3">.</span><span class="s1">lookup_subtables</span><span class="s3">[</span><span class="s1">i</span><span class="s3">], </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_firstGlyph</span><span class="s3">, </span><span class="s1">glyph</span>
                <span class="s3">)</span>
            <span class="s2">if </span><span class="s1">vpair </span><span class="s2">is None</span><span class="s3">:</span>
                <span class="s1">v1</span><span class="s3">, </span><span class="s1">v2 </span><span class="s3">= </span><span class="s2">None</span><span class="s3">, </span><span class="s2">None</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">v1 </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">vpair</span><span class="s3">, </span><span class="s4">&quot;Value1&quot;</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
                <span class="s1">v2 </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">vpair</span><span class="s3">, </span><span class="s4">&quot;Value2&quot;</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
            <span class="s1">v</span><span class="s3">.</span><span class="s1">Value1 </span><span class="s3">= (</span>
                <span class="s1">otBase</span><span class="s3">.</span><span class="s1">ValueRecord</span><span class="s3">(</span><span class="s1">merger</span><span class="s3">.</span><span class="s1">valueFormat1</span><span class="s3">, </span><span class="s1">src</span><span class="s3">=</span><span class="s1">v1</span><span class="s3">)</span>
                <span class="s2">if </span><span class="s1">merger</span><span class="s3">.</span><span class="s1">valueFormat1</span>
                <span class="s2">else None</span>
            <span class="s3">)</span>
            <span class="s1">v</span><span class="s3">.</span><span class="s1">Value2 </span><span class="s3">= (</span>
                <span class="s1">otBase</span><span class="s3">.</span><span class="s1">ValueRecord</span><span class="s3">(</span><span class="s1">merger</span><span class="s3">.</span><span class="s1">valueFormat2</span><span class="s3">, </span><span class="s1">src</span><span class="s3">=</span><span class="s1">v2</span><span class="s3">)</span>
                <span class="s2">if </span><span class="s1">merger</span><span class="s3">.</span><span class="s1">valueFormat2</span>
                <span class="s2">else None</span>
            <span class="s3">)</span>
            <span class="s1">values</span><span class="s3">[</span><span class="s1">j</span><span class="s3">] = </span><span class="s1">v</span>
    <span class="s2">del </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_firstGlyph</span>

    <span class="s1">merger</span><span class="s3">.</span><span class="s1">mergeLists</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">PairValueRecord</span><span class="s3">, </span><span class="s1">padded</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">_PairPosFormat1_merge</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">lst</span><span class="s3">, </span><span class="s1">merger</span><span class="s3">):</span>
    <span class="s2">assert </span><span class="s1">allEqual</span><span class="s3">(</span>
        <span class="s3">[</span><span class="s1">l</span><span class="s3">.</span><span class="s1">ValueFormat2 </span><span class="s3">== </span><span class="s6">0 </span><span class="s2">for </span><span class="s1">l </span><span class="s2">in </span><span class="s1">lst </span><span class="s2">if </span><span class="s1">l</span><span class="s3">.</span><span class="s1">PairSet</span><span class="s3">]</span>
    <span class="s3">), </span><span class="s4">&quot;Report bug against fonttools.&quot;</span>

    <span class="s5"># Merge everything else; makes sure Format is the same.</span>
    <span class="s1">merger</span><span class="s3">.</span><span class="s1">mergeObjects</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">lst</span><span class="s3">,</span>
        <span class="s1">exclude</span><span class="s3">=(</span><span class="s4">&quot;Coverage&quot;</span><span class="s3">, </span><span class="s4">&quot;PairSet&quot;</span><span class="s3">, </span><span class="s4">&quot;PairSetCount&quot;</span><span class="s3">, </span><span class="s4">&quot;ValueFormat1&quot;</span><span class="s3">, </span><span class="s4">&quot;ValueFormat2&quot;</span><span class="s3">),</span>
    <span class="s3">)</span>

    <span class="s1">empty </span><span class="s3">= </span><span class="s1">ot</span><span class="s3">.</span><span class="s1">PairSet</span><span class="s3">()</span>
    <span class="s1">empty</span><span class="s3">.</span><span class="s1">PairValueRecord </span><span class="s3">= []</span>
    <span class="s1">empty</span><span class="s3">.</span><span class="s1">PairValueCount </span><span class="s3">= </span><span class="s6">0</span>

    <span class="s5"># Align them</span>
    <span class="s1">glyphs</span><span class="s3">, </span><span class="s1">padded </span><span class="s3">= </span><span class="s1">_merge_GlyphOrders</span><span class="s3">(</span>
        <span class="s1">merger</span><span class="s3">.</span><span class="s1">font</span><span class="s3">,</span>
        <span class="s3">[</span><span class="s1">v</span><span class="s3">.</span><span class="s1">Coverage</span><span class="s3">.</span><span class="s1">glyphs </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">lst</span><span class="s3">],</span>
        <span class="s3">[</span><span class="s1">v</span><span class="s3">.</span><span class="s1">PairSet </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">lst</span><span class="s3">],</span>
        <span class="s1">default</span><span class="s3">=</span><span class="s1">empty</span><span class="s3">,</span>
    <span class="s3">)</span>

    <span class="s1">self</span><span class="s3">.</span><span class="s1">Coverage</span><span class="s3">.</span><span class="s1">glyphs </span><span class="s3">= </span><span class="s1">glyphs</span>
    <span class="s1">self</span><span class="s3">.</span><span class="s1">PairSet </span><span class="s3">= [</span><span class="s1">ot</span><span class="s3">.</span><span class="s1">PairSet</span><span class="s3">() </span><span class="s2">for </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">glyphs</span><span class="s3">]</span>
    <span class="s1">self</span><span class="s3">.</span><span class="s1">PairSetCount </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">PairSet</span><span class="s3">)</span>
    <span class="s2">for </span><span class="s1">glyph</span><span class="s3">, </span><span class="s1">ps </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">glyphs</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">PairSet</span><span class="s3">):</span>
        <span class="s1">ps</span><span class="s3">.</span><span class="s1">_firstGlyph </span><span class="s3">= </span><span class="s1">glyph</span>

    <span class="s1">merger</span><span class="s3">.</span><span class="s1">mergeLists</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">PairSet</span><span class="s3">, </span><span class="s1">padded</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">_ClassDef_invert</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">allGlyphs</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">dict</span><span class="s3">):</span>
        <span class="s1">classDefs </span><span class="s3">= </span><span class="s1">self</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">classDefs </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">classDefs </span><span class="s2">if </span><span class="s1">self </span><span class="s2">and </span><span class="s1">self</span><span class="s3">.</span><span class="s1">classDefs </span><span class="s2">else </span><span class="s3">{}</span>
    <span class="s1">m </span><span class="s3">= </span><span class="s1">max</span><span class="s3">(</span><span class="s1">classDefs</span><span class="s3">.</span><span class="s1">values</span><span class="s3">()) </span><span class="s2">if </span><span class="s1">classDefs </span><span class="s2">else </span><span class="s6">0</span>

    <span class="s1">ret </span><span class="s3">= []</span>
    <span class="s2">for </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">m </span><span class="s3">+ </span><span class="s6">1</span><span class="s3">):</span>
        <span class="s1">ret</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">set</span><span class="s3">())</span>

    <span class="s2">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">classDefs</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
        <span class="s1">ret</span><span class="s3">[</span><span class="s1">v</span><span class="s3">].</span><span class="s1">add</span><span class="s3">(</span><span class="s1">k</span><span class="s3">)</span>

    <span class="s5"># Class-0 is special.  It's &quot;everything else&quot;.</span>
    <span class="s2">if </span><span class="s1">allGlyphs </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">ret</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s2">None</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s5"># Limit all classes to glyphs in allGlyphs.</span>
        <span class="s5"># Collect anything without a non-zero class into class=zero.</span>
        <span class="s1">ret</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">class0 </span><span class="s3">= </span><span class="s1">set</span><span class="s3">(</span><span class="s1">allGlyphs</span><span class="s3">)</span>
        <span class="s2">for </span><span class="s1">s </span><span class="s2">in </span><span class="s1">ret</span><span class="s3">[</span><span class="s6">1</span><span class="s3">:]:</span>
            <span class="s1">s</span><span class="s3">.</span><span class="s1">intersection_update</span><span class="s3">(</span><span class="s1">class0</span><span class="s3">)</span>
            <span class="s1">class0</span><span class="s3">.</span><span class="s1">difference_update</span><span class="s3">(</span><span class="s1">s</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">ret</span>


<span class="s2">def </span><span class="s1">_ClassDef_merge_classify</span><span class="s3">(</span><span class="s1">lst</span><span class="s3">, </span><span class="s1">allGlyphses</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s1">self </span><span class="s3">= </span><span class="s1">ot</span><span class="s3">.</span><span class="s1">ClassDef</span><span class="s3">()</span>
    <span class="s1">self</span><span class="s3">.</span><span class="s1">classDefs </span><span class="s3">= </span><span class="s1">classDefs </span><span class="s3">= {}</span>
    <span class="s1">allGlyphsesWasNone </span><span class="s3">= </span><span class="s1">allGlyphses </span><span class="s2">is None</span>
    <span class="s2">if </span><span class="s1">allGlyphsesWasNone</span><span class="s3">:</span>
        <span class="s1">allGlyphses </span><span class="s3">= [</span><span class="s2">None</span><span class="s3">] * </span><span class="s1">len</span><span class="s3">(</span><span class="s1">lst</span><span class="s3">)</span>

    <span class="s1">classifier </span><span class="s3">= </span><span class="s1">classifyTools</span><span class="s3">.</span><span class="s1">Classifier</span><span class="s3">()</span>
    <span class="s2">for </span><span class="s1">classDef</span><span class="s3">, </span><span class="s1">allGlyphs </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">lst</span><span class="s3">, </span><span class="s1">allGlyphses</span><span class="s3">):</span>
        <span class="s1">sets </span><span class="s3">= </span><span class="s1">_ClassDef_invert</span><span class="s3">(</span><span class="s1">classDef</span><span class="s3">, </span><span class="s1">allGlyphs</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">allGlyphs </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s1">sets </span><span class="s3">= </span><span class="s1">sets</span><span class="s3">[</span><span class="s6">1</span><span class="s3">:]</span>
        <span class="s1">classifier</span><span class="s3">.</span><span class="s1">update</span><span class="s3">(</span><span class="s1">sets</span><span class="s3">)</span>
    <span class="s1">classes </span><span class="s3">= </span><span class="s1">classifier</span><span class="s3">.</span><span class="s1">getClasses</span><span class="s3">()</span>

    <span class="s2">if </span><span class="s1">allGlyphsesWasNone</span><span class="s3">:</span>
        <span class="s1">classes</span><span class="s3">.</span><span class="s1">insert</span><span class="s3">(</span><span class="s6">0</span><span class="s3">, </span><span class="s1">set</span><span class="s3">())</span>

    <span class="s2">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">classSet </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">classes</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">i </span><span class="s3">== </span><span class="s6">0</span><span class="s3">:</span>
            <span class="s2">continue</span>
        <span class="s2">for </span><span class="s1">g </span><span class="s2">in </span><span class="s1">classSet</span><span class="s3">:</span>
            <span class="s1">classDefs</span><span class="s3">[</span><span class="s1">g</span><span class="s3">] = </span><span class="s1">i</span>

    <span class="s2">return </span><span class="s1">self</span><span class="s3">, </span><span class="s1">classes</span>


<span class="s2">def </span><span class="s1">_PairPosFormat2_align_matrices</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">lst</span><span class="s3">, </span><span class="s1">font</span><span class="s3">, </span><span class="s1">transparent</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s1">matrices </span><span class="s3">= [</span><span class="s1">l</span><span class="s3">.</span><span class="s1">Class1Record </span><span class="s2">for </span><span class="s1">l </span><span class="s2">in </span><span class="s1">lst</span><span class="s3">]</span>

    <span class="s5"># Align first classes</span>
    <span class="s1">self</span><span class="s3">.</span><span class="s1">ClassDef1</span><span class="s3">, </span><span class="s1">classes </span><span class="s3">= </span><span class="s1">_ClassDef_merge_classify</span><span class="s3">(</span>
        <span class="s3">[</span><span class="s1">l</span><span class="s3">.</span><span class="s1">ClassDef1 </span><span class="s2">for </span><span class="s1">l </span><span class="s2">in </span><span class="s1">lst</span><span class="s3">], [</span><span class="s1">l</span><span class="s3">.</span><span class="s1">Coverage</span><span class="s3">.</span><span class="s1">glyphs </span><span class="s2">for </span><span class="s1">l </span><span class="s2">in </span><span class="s1">lst</span><span class="s3">]</span>
    <span class="s3">)</span>
    <span class="s1">self</span><span class="s3">.</span><span class="s1">Class1Count </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">classes</span><span class="s3">)</span>
    <span class="s1">new_matrices </span><span class="s3">= []</span>
    <span class="s2">for </span><span class="s1">l</span><span class="s3">, </span><span class="s1">matrix </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">lst</span><span class="s3">, </span><span class="s1">matrices</span><span class="s3">):</span>
        <span class="s1">nullRow </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s1">coverage </span><span class="s3">= </span><span class="s1">set</span><span class="s3">(</span><span class="s1">l</span><span class="s3">.</span><span class="s1">Coverage</span><span class="s3">.</span><span class="s1">glyphs</span><span class="s3">)</span>
        <span class="s1">classDef1 </span><span class="s3">= </span><span class="s1">l</span><span class="s3">.</span><span class="s1">ClassDef1</span><span class="s3">.</span><span class="s1">classDefs</span>
        <span class="s1">class1Records </span><span class="s3">= []</span>
        <span class="s2">for </span><span class="s1">classSet </span><span class="s2">in </span><span class="s1">classes</span><span class="s3">:</span>
            <span class="s1">exemplarGlyph </span><span class="s3">= </span><span class="s1">next</span><span class="s3">(</span><span class="s1">iter</span><span class="s3">(</span><span class="s1">classSet</span><span class="s3">))</span>
            <span class="s2">if </span><span class="s1">exemplarGlyph </span><span class="s2">not in </span><span class="s1">coverage</span><span class="s3">:</span>
                <span class="s5"># Follow-up to e6125b353e1f54a0280ded5434b8e40d042de69f,</span>
                <span class="s5"># Fixes https://github.com/googlei18n/fontmake/issues/470</span>
                <span class="s5"># Again, revert 8d441779e5afc664960d848f62c7acdbfc71d7b9</span>
                <span class="s5"># when merger becomes selfless.</span>
                <span class="s1">nullRow </span><span class="s3">= </span><span class="s2">None</span>
                <span class="s2">if </span><span class="s1">nullRow </span><span class="s2">is None</span><span class="s3">:</span>
                    <span class="s1">nullRow </span><span class="s3">= </span><span class="s1">ot</span><span class="s3">.</span><span class="s1">Class1Record</span><span class="s3">()</span>
                    <span class="s1">class2records </span><span class="s3">= </span><span class="s1">nullRow</span><span class="s3">.</span><span class="s1">Class2Record </span><span class="s3">= []</span>
                    <span class="s5"># TODO: When merger becomes selfless, revert e6125b353e1f54a0280ded5434b8e40d042de69f</span>
                    <span class="s2">for </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">l</span><span class="s3">.</span><span class="s1">Class2Count</span><span class="s3">):</span>
                        <span class="s2">if </span><span class="s1">transparent</span><span class="s3">:</span>
                            <span class="s1">rec2 </span><span class="s3">= </span><span class="s2">None</span>
                        <span class="s2">else</span><span class="s3">:</span>
                            <span class="s1">rec2 </span><span class="s3">= </span><span class="s1">ot</span><span class="s3">.</span><span class="s1">Class2Record</span><span class="s3">()</span>
                            <span class="s1">rec2</span><span class="s3">.</span><span class="s1">Value1 </span><span class="s3">= (</span>
                                <span class="s1">otBase</span><span class="s3">.</span><span class="s1">ValueRecord</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">ValueFormat1</span><span class="s3">)</span>
                                <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">ValueFormat1</span>
                                <span class="s2">else None</span>
                            <span class="s3">)</span>
                            <span class="s1">rec2</span><span class="s3">.</span><span class="s1">Value2 </span><span class="s3">= (</span>
                                <span class="s1">otBase</span><span class="s3">.</span><span class="s1">ValueRecord</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">ValueFormat2</span><span class="s3">)</span>
                                <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">ValueFormat2</span>
                                <span class="s2">else None</span>
                            <span class="s3">)</span>
                        <span class="s1">class2records</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">rec2</span><span class="s3">)</span>
                <span class="s1">rec1 </span><span class="s3">= </span><span class="s1">nullRow</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">klass </span><span class="s3">= </span><span class="s1">classDef1</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">exemplarGlyph</span><span class="s3">, </span><span class="s6">0</span><span class="s3">)</span>
                <span class="s1">rec1 </span><span class="s3">= </span><span class="s1">matrix</span><span class="s3">[</span><span class="s1">klass</span><span class="s3">]  </span><span class="s5"># TODO handle out-of-range?</span>
            <span class="s1">class1Records</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">rec1</span><span class="s3">)</span>
        <span class="s1">new_matrices</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">class1Records</span><span class="s3">)</span>
    <span class="s1">matrices </span><span class="s3">= </span><span class="s1">new_matrices</span>
    <span class="s2">del </span><span class="s1">new_matrices</span>

    <span class="s5"># Align second classes</span>
    <span class="s1">self</span><span class="s3">.</span><span class="s1">ClassDef2</span><span class="s3">, </span><span class="s1">classes </span><span class="s3">= </span><span class="s1">_ClassDef_merge_classify</span><span class="s3">([</span><span class="s1">l</span><span class="s3">.</span><span class="s1">ClassDef2 </span><span class="s2">for </span><span class="s1">l </span><span class="s2">in </span><span class="s1">lst</span><span class="s3">])</span>
    <span class="s1">self</span><span class="s3">.</span><span class="s1">Class2Count </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">classes</span><span class="s3">)</span>
    <span class="s1">new_matrices </span><span class="s3">= []</span>
    <span class="s2">for </span><span class="s1">l</span><span class="s3">, </span><span class="s1">matrix </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">lst</span><span class="s3">, </span><span class="s1">matrices</span><span class="s3">):</span>
        <span class="s1">classDef2 </span><span class="s3">= </span><span class="s1">l</span><span class="s3">.</span><span class="s1">ClassDef2</span><span class="s3">.</span><span class="s1">classDefs</span>
        <span class="s1">class1Records </span><span class="s3">= []</span>
        <span class="s2">for </span><span class="s1">rec1old </span><span class="s2">in </span><span class="s1">matrix</span><span class="s3">:</span>
            <span class="s1">oldClass2Records </span><span class="s3">= </span><span class="s1">rec1old</span><span class="s3">.</span><span class="s1">Class2Record</span>
            <span class="s1">rec1new </span><span class="s3">= </span><span class="s1">ot</span><span class="s3">.</span><span class="s1">Class1Record</span><span class="s3">()</span>
            <span class="s1">class2Records </span><span class="s3">= </span><span class="s1">rec1new</span><span class="s3">.</span><span class="s1">Class2Record </span><span class="s3">= []</span>
            <span class="s2">for </span><span class="s1">classSet </span><span class="s2">in </span><span class="s1">classes</span><span class="s3">:</span>
                <span class="s2">if not </span><span class="s1">classSet</span><span class="s3">:  </span><span class="s5"># class=0</span>
                    <span class="s1">rec2 </span><span class="s3">= </span><span class="s1">oldClass2Records</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">exemplarGlyph </span><span class="s3">= </span><span class="s1">next</span><span class="s3">(</span><span class="s1">iter</span><span class="s3">(</span><span class="s1">classSet</span><span class="s3">))</span>
                    <span class="s1">klass </span><span class="s3">= </span><span class="s1">classDef2</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">exemplarGlyph</span><span class="s3">, </span><span class="s6">0</span><span class="s3">)</span>
                    <span class="s1">rec2 </span><span class="s3">= </span><span class="s1">oldClass2Records</span><span class="s3">[</span><span class="s1">klass</span><span class="s3">]</span>
                <span class="s1">class2Records</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">copy</span><span class="s3">.</span><span class="s1">deepcopy</span><span class="s3">(</span><span class="s1">rec2</span><span class="s3">))</span>
            <span class="s1">class1Records</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">rec1new</span><span class="s3">)</span>
        <span class="s1">new_matrices</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">class1Records</span><span class="s3">)</span>
    <span class="s1">matrices </span><span class="s3">= </span><span class="s1">new_matrices</span>
    <span class="s2">del </span><span class="s1">new_matrices</span>

    <span class="s2">return </span><span class="s1">matrices</span>


<span class="s2">def </span><span class="s1">_PairPosFormat2_merge</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">lst</span><span class="s3">, </span><span class="s1">merger</span><span class="s3">):</span>
    <span class="s2">assert </span><span class="s1">allEqual</span><span class="s3">(</span>
        <span class="s3">[</span><span class="s1">l</span><span class="s3">.</span><span class="s1">ValueFormat2 </span><span class="s3">== </span><span class="s6">0 </span><span class="s2">for </span><span class="s1">l </span><span class="s2">in </span><span class="s1">lst </span><span class="s2">if </span><span class="s1">l</span><span class="s3">.</span><span class="s1">Class1Record</span><span class="s3">]</span>
    <span class="s3">), </span><span class="s4">&quot;Report bug against fonttools.&quot;</span>

    <span class="s1">merger</span><span class="s3">.</span><span class="s1">mergeObjects</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">lst</span><span class="s3">,</span>
        <span class="s1">exclude</span><span class="s3">=(</span>
            <span class="s4">&quot;Coverage&quot;</span><span class="s3">,</span>
            <span class="s4">&quot;ClassDef1&quot;</span><span class="s3">,</span>
            <span class="s4">&quot;Class1Count&quot;</span><span class="s3">,</span>
            <span class="s4">&quot;ClassDef2&quot;</span><span class="s3">,</span>
            <span class="s4">&quot;Class2Count&quot;</span><span class="s3">,</span>
            <span class="s4">&quot;Class1Record&quot;</span><span class="s3">,</span>
            <span class="s4">&quot;ValueFormat1&quot;</span><span class="s3">,</span>
            <span class="s4">&quot;ValueFormat2&quot;</span><span class="s3">,</span>
        <span class="s3">),</span>
    <span class="s3">)</span>

    <span class="s5"># Align coverages</span>
    <span class="s1">glyphs</span><span class="s3">, </span><span class="s1">_ </span><span class="s3">= </span><span class="s1">_merge_GlyphOrders</span><span class="s3">(</span><span class="s1">merger</span><span class="s3">.</span><span class="s1">font</span><span class="s3">, [</span><span class="s1">v</span><span class="s3">.</span><span class="s1">Coverage</span><span class="s3">.</span><span class="s1">glyphs </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">lst</span><span class="s3">])</span>
    <span class="s1">self</span><span class="s3">.</span><span class="s1">Coverage</span><span class="s3">.</span><span class="s1">glyphs </span><span class="s3">= </span><span class="s1">glyphs</span>

    <span class="s5"># Currently, if the coverage of PairPosFormat2 subtables are different,</span>
    <span class="s5"># we do NOT bother walking down the subtable list when filling in new</span>
    <span class="s5"># rows for alignment.  As such, this is only correct if current subtable</span>
    <span class="s5"># is the last subtable in the lookup.  Ensure that.</span>
    <span class="s5">#</span>
    <span class="s5"># Note that our canonicalization process merges trailing PairPosFormat2's,</span>
    <span class="s5"># so in reality this is rare.</span>
    <span class="s2">for </span><span class="s1">l</span><span class="s3">, </span><span class="s1">subtables </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">lst</span><span class="s3">, </span><span class="s1">merger</span><span class="s3">.</span><span class="s1">lookup_subtables</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">l</span><span class="s3">.</span><span class="s1">Coverage</span><span class="s3">.</span><span class="s1">glyphs </span><span class="s3">!= </span><span class="s1">glyphs</span><span class="s3">:</span>
            <span class="s2">assert </span><span class="s1">l </span><span class="s3">== </span><span class="s1">subtables</span><span class="s3">[-</span><span class="s6">1</span><span class="s3">]</span>

    <span class="s1">matrices </span><span class="s3">= </span><span class="s1">_PairPosFormat2_align_matrices</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">lst</span><span class="s3">, </span><span class="s1">merger</span><span class="s3">.</span><span class="s1">font</span><span class="s3">)</span>

    <span class="s1">self</span><span class="s3">.</span><span class="s1">Class1Record </span><span class="s3">= </span><span class="s1">list</span><span class="s3">(</span><span class="s1">matrices</span><span class="s3">[</span><span class="s6">0</span><span class="s3">])  </span><span class="s5"># TODO move merger to be selfless</span>
    <span class="s1">merger</span><span class="s3">.</span><span class="s1">mergeLists</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">Class1Record</span><span class="s3">, </span><span class="s1">matrices</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">AligningMerger</span><span class="s3">.</span><span class="s1">merger</span><span class="s3">(</span><span class="s1">ot</span><span class="s3">.</span><span class="s1">PairPos</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">merge</span><span class="s3">(</span><span class="s1">merger</span><span class="s3">, </span><span class="s1">self</span><span class="s3">, </span><span class="s1">lst</span><span class="s3">):</span>
    <span class="s1">merger</span><span class="s3">.</span><span class="s1">valueFormat1 </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">ValueFormat1 </span><span class="s3">= </span><span class="s1">reduce</span><span class="s3">(</span>
        <span class="s1">int</span><span class="s3">.</span><span class="s1">__or__</span><span class="s3">, [</span><span class="s1">l</span><span class="s3">.</span><span class="s1">ValueFormat1 </span><span class="s2">for </span><span class="s1">l </span><span class="s2">in </span><span class="s1">lst</span><span class="s3">], </span><span class="s6">0</span>
    <span class="s3">)</span>
    <span class="s1">merger</span><span class="s3">.</span><span class="s1">valueFormat2 </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">ValueFormat2 </span><span class="s3">= </span><span class="s1">reduce</span><span class="s3">(</span>
        <span class="s1">int</span><span class="s3">.</span><span class="s1">__or__</span><span class="s3">, [</span><span class="s1">l</span><span class="s3">.</span><span class="s1">ValueFormat2 </span><span class="s2">for </span><span class="s1">l </span><span class="s2">in </span><span class="s1">lst</span><span class="s3">], </span><span class="s6">0</span>
    <span class="s3">)</span>

    <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">Format </span><span class="s3">== </span><span class="s6">1</span><span class="s3">:</span>
        <span class="s1">_PairPosFormat1_merge</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">lst</span><span class="s3">, </span><span class="s1">merger</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">self</span><span class="s3">.</span><span class="s1">Format </span><span class="s3">== </span><span class="s6">2</span><span class="s3">:</span>
        <span class="s1">_PairPosFormat2_merge</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">lst</span><span class="s3">, </span><span class="s1">merger</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">UnsupportedFormat</span><span class="s3">(</span><span class="s1">merger</span><span class="s3">, </span><span class="s1">subtable</span><span class="s3">=</span><span class="s4">&quot;pair positioning lookup&quot;</span><span class="s3">)</span>

    <span class="s2">del </span><span class="s1">merger</span><span class="s3">.</span><span class="s1">valueFormat1</span><span class="s3">, </span><span class="s1">merger</span><span class="s3">.</span><span class="s1">valueFormat2</span>

    <span class="s5"># Now examine the list of value records, and update to the union of format values,</span>
    <span class="s5"># as merge might have created new values.</span>
    <span class="s1">vf1 </span><span class="s3">= </span><span class="s6">0</span>
    <span class="s1">vf2 </span><span class="s3">= </span><span class="s6">0</span>
    <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">Format </span><span class="s3">== </span><span class="s6">1</span><span class="s3">:</span>
        <span class="s2">for </span><span class="s1">pairSet </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">PairSet</span><span class="s3">:</span>
            <span class="s2">for </span><span class="s1">pairValueRecord </span><span class="s2">in </span><span class="s1">pairSet</span><span class="s3">.</span><span class="s1">PairValueRecord</span><span class="s3">:</span>
                <span class="s1">pv1 </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">pairValueRecord</span><span class="s3">, </span><span class="s4">&quot;Value1&quot;</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
                <span class="s2">if </span><span class="s1">pv1 </span><span class="s2">is not None</span><span class="s3">:</span>
                    <span class="s1">vf1 </span><span class="s3">|= </span><span class="s1">pv1</span><span class="s3">.</span><span class="s1">getFormat</span><span class="s3">()</span>
                <span class="s1">pv2 </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">pairValueRecord</span><span class="s3">, </span><span class="s4">&quot;Value2&quot;</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
                <span class="s2">if </span><span class="s1">pv2 </span><span class="s2">is not None</span><span class="s3">:</span>
                    <span class="s1">vf2 </span><span class="s3">|= </span><span class="s1">pv2</span><span class="s3">.</span><span class="s1">getFormat</span><span class="s3">()</span>
    <span class="s2">elif </span><span class="s1">self</span><span class="s3">.</span><span class="s1">Format </span><span class="s3">== </span><span class="s6">2</span><span class="s3">:</span>
        <span class="s2">for </span><span class="s1">class1Record </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">Class1Record</span><span class="s3">:</span>
            <span class="s2">for </span><span class="s1">class2Record </span><span class="s2">in </span><span class="s1">class1Record</span><span class="s3">.</span><span class="s1">Class2Record</span><span class="s3">:</span>
                <span class="s1">pv1 </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">class2Record</span><span class="s3">, </span><span class="s4">&quot;Value1&quot;</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
                <span class="s2">if </span><span class="s1">pv1 </span><span class="s2">is not None</span><span class="s3">:</span>
                    <span class="s1">vf1 </span><span class="s3">|= </span><span class="s1">pv1</span><span class="s3">.</span><span class="s1">getFormat</span><span class="s3">()</span>
                <span class="s1">pv2 </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">class2Record</span><span class="s3">, </span><span class="s4">&quot;Value2&quot;</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
                <span class="s2">if </span><span class="s1">pv2 </span><span class="s2">is not None</span><span class="s3">:</span>
                    <span class="s1">vf2 </span><span class="s3">|= </span><span class="s1">pv2</span><span class="s3">.</span><span class="s1">getFormat</span><span class="s3">()</span>
    <span class="s1">self</span><span class="s3">.</span><span class="s1">ValueFormat1 </span><span class="s3">= </span><span class="s1">vf1</span>
    <span class="s1">self</span><span class="s3">.</span><span class="s1">ValueFormat2 </span><span class="s3">= </span><span class="s1">vf2</span>


<span class="s2">def </span><span class="s1">_MarkBasePosFormat1_merge</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">lst</span><span class="s3">, </span><span class="s1">merger</span><span class="s3">, </span><span class="s1">Mark</span><span class="s3">=</span><span class="s4">&quot;Mark&quot;</span><span class="s3">, </span><span class="s1">Base</span><span class="s3">=</span><span class="s4">&quot;Base&quot;</span><span class="s3">):</span>
    <span class="s1">self</span><span class="s3">.</span><span class="s1">ClassCount </span><span class="s3">= </span><span class="s1">max</span><span class="s3">(</span><span class="s1">l</span><span class="s3">.</span><span class="s1">ClassCount </span><span class="s2">for </span><span class="s1">l </span><span class="s2">in </span><span class="s1">lst</span><span class="s3">)</span>

    <span class="s1">MarkCoverageGlyphs</span><span class="s3">, </span><span class="s1">MarkRecords </span><span class="s3">= </span><span class="s1">_merge_GlyphOrders</span><span class="s3">(</span>
        <span class="s1">merger</span><span class="s3">.</span><span class="s1">font</span><span class="s3">,</span>
        <span class="s3">[</span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">l</span><span class="s3">, </span><span class="s1">Mark </span><span class="s3">+ </span><span class="s4">&quot;Coverage&quot;</span><span class="s3">).</span><span class="s1">glyphs </span><span class="s2">for </span><span class="s1">l </span><span class="s2">in </span><span class="s1">lst</span><span class="s3">],</span>
        <span class="s3">[</span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">l</span><span class="s3">, </span><span class="s1">Mark </span><span class="s3">+ </span><span class="s4">&quot;Array&quot;</span><span class="s3">).</span><span class="s1">MarkRecord </span><span class="s2">for </span><span class="s1">l </span><span class="s2">in </span><span class="s1">lst</span><span class="s3">],</span>
    <span class="s3">)</span>
    <span class="s1">getattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">Mark </span><span class="s3">+ </span><span class="s4">&quot;Coverage&quot;</span><span class="s3">).</span><span class="s1">glyphs </span><span class="s3">= </span><span class="s1">MarkCoverageGlyphs</span>

    <span class="s1">BaseCoverageGlyphs</span><span class="s3">, </span><span class="s1">BaseRecords </span><span class="s3">= </span><span class="s1">_merge_GlyphOrders</span><span class="s3">(</span>
        <span class="s1">merger</span><span class="s3">.</span><span class="s1">font</span><span class="s3">,</span>
        <span class="s3">[</span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">l</span><span class="s3">, </span><span class="s1">Base </span><span class="s3">+ </span><span class="s4">&quot;Coverage&quot;</span><span class="s3">).</span><span class="s1">glyphs </span><span class="s2">for </span><span class="s1">l </span><span class="s2">in </span><span class="s1">lst</span><span class="s3">],</span>
        <span class="s3">[</span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">l</span><span class="s3">, </span><span class="s1">Base </span><span class="s3">+ </span><span class="s4">&quot;Array&quot;</span><span class="s3">), </span><span class="s1">Base </span><span class="s3">+ </span><span class="s4">&quot;Record&quot;</span><span class="s3">) </span><span class="s2">for </span><span class="s1">l </span><span class="s2">in </span><span class="s1">lst</span><span class="s3">],</span>
    <span class="s3">)</span>
    <span class="s1">getattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">Base </span><span class="s3">+ </span><span class="s4">&quot;Coverage&quot;</span><span class="s3">).</span><span class="s1">glyphs </span><span class="s3">= </span><span class="s1">BaseCoverageGlyphs</span>

    <span class="s5"># MarkArray</span>
    <span class="s1">records </span><span class="s3">= []</span>
    <span class="s2">for </span><span class="s1">g</span><span class="s3">, </span><span class="s1">glyphRecords </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">MarkCoverageGlyphs</span><span class="s3">, </span><span class="s1">zip</span><span class="s3">(*</span><span class="s1">MarkRecords</span><span class="s3">)):</span>
        <span class="s1">allClasses </span><span class="s3">= [</span><span class="s1">r</span><span class="s3">.</span><span class="s1">Class </span><span class="s2">for </span><span class="s1">r </span><span class="s2">in </span><span class="s1">glyphRecords </span><span class="s2">if </span><span class="s1">r </span><span class="s2">is not None</span><span class="s3">]</span>

        <span class="s5"># TODO Right now we require that all marks have same class in</span>
        <span class="s5"># all masters that cover them.  This is not required.</span>
        <span class="s5">#</span>
        <span class="s5"># We can relax that by just requiring that all marks that have</span>
        <span class="s5"># the same class in a master, have the same class in every other</span>
        <span class="s5"># master.  Indeed, if, say, a sparse master only covers one mark,</span>
        <span class="s5"># that mark probably will get class 0, which would possibly be</span>
        <span class="s5"># different from its class in other masters.</span>
        <span class="s5">#</span>
        <span class="s5"># We can even go further and reclassify marks to support any</span>
        <span class="s5"># input.  But, since, it's unlikely that two marks being both,</span>
        <span class="s5"># say, &quot;top&quot; in one master, and one being &quot;top&quot; and other being</span>
        <span class="s5"># &quot;top-right&quot; in another master, we shouldn't do that, as any</span>
        <span class="s5"># failures in that case will probably signify mistakes in the</span>
        <span class="s5"># input masters.</span>

        <span class="s2">if not </span><span class="s1">allEqual</span><span class="s3">(</span><span class="s1">allClasses</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">ShouldBeConstant</span><span class="s3">(</span><span class="s1">merger</span><span class="s3">, </span><span class="s1">expected</span><span class="s3">=</span><span class="s1">allClasses</span><span class="s3">[</span><span class="s6">0</span><span class="s3">], </span><span class="s1">got</span><span class="s3">=</span><span class="s1">allClasses</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">rec </span><span class="s3">= </span><span class="s1">ot</span><span class="s3">.</span><span class="s1">MarkRecord</span><span class="s3">()</span>
            <span class="s1">rec</span><span class="s3">.</span><span class="s1">Class </span><span class="s3">= </span><span class="s1">allClasses</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]</span>
            <span class="s1">allAnchors </span><span class="s3">= [</span><span class="s2">None if </span><span class="s1">r </span><span class="s2">is None else </span><span class="s1">r</span><span class="s3">.</span><span class="s1">MarkAnchor </span><span class="s2">for </span><span class="s1">r </span><span class="s2">in </span><span class="s1">glyphRecords</span><span class="s3">]</span>
            <span class="s2">if </span><span class="s1">allNone</span><span class="s3">(</span><span class="s1">allAnchors</span><span class="s3">):</span>
                <span class="s1">anchor </span><span class="s3">= </span><span class="s2">None</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">anchor </span><span class="s3">= </span><span class="s1">ot</span><span class="s3">.</span><span class="s1">Anchor</span><span class="s3">()</span>
                <span class="s1">anchor</span><span class="s3">.</span><span class="s1">Format </span><span class="s3">= </span><span class="s6">1</span>
                <span class="s1">merger</span><span class="s3">.</span><span class="s1">mergeThings</span><span class="s3">(</span><span class="s1">anchor</span><span class="s3">, </span><span class="s1">allAnchors</span><span class="s3">)</span>
            <span class="s1">rec</span><span class="s3">.</span><span class="s1">MarkAnchor </span><span class="s3">= </span><span class="s1">anchor</span>
        <span class="s1">records</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">rec</span><span class="s3">)</span>
    <span class="s1">array </span><span class="s3">= </span><span class="s1">ot</span><span class="s3">.</span><span class="s1">MarkArray</span><span class="s3">()</span>
    <span class="s1">array</span><span class="s3">.</span><span class="s1">MarkRecord </span><span class="s3">= </span><span class="s1">records</span>
    <span class="s1">array</span><span class="s3">.</span><span class="s1">MarkCount </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">records</span><span class="s3">)</span>
    <span class="s1">setattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">Mark </span><span class="s3">+ </span><span class="s4">&quot;Array&quot;</span><span class="s3">, </span><span class="s1">array</span><span class="s3">)</span>

    <span class="s5"># BaseArray</span>
    <span class="s1">records </span><span class="s3">= []</span>
    <span class="s2">for </span><span class="s1">g</span><span class="s3">, </span><span class="s1">glyphRecords </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">BaseCoverageGlyphs</span><span class="s3">, </span><span class="s1">zip</span><span class="s3">(*</span><span class="s1">BaseRecords</span><span class="s3">)):</span>
        <span class="s2">if </span><span class="s1">allNone</span><span class="s3">(</span><span class="s1">glyphRecords</span><span class="s3">):</span>
            <span class="s1">rec </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">rec </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">ot</span><span class="s3">, </span><span class="s1">Base </span><span class="s3">+ </span><span class="s4">&quot;Record&quot;</span><span class="s3">)()</span>
            <span class="s1">anchors </span><span class="s3">= []</span>
            <span class="s1">setattr</span><span class="s3">(</span><span class="s1">rec</span><span class="s3">, </span><span class="s1">Base </span><span class="s3">+ </span><span class="s4">&quot;Anchor&quot;</span><span class="s3">, </span><span class="s1">anchors</span><span class="s3">)</span>
            <span class="s1">glyphAnchors </span><span class="s3">= [</span>
                <span class="s3">[] </span><span class="s2">if </span><span class="s1">r </span><span class="s2">is None else </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">r</span><span class="s3">, </span><span class="s1">Base </span><span class="s3">+ </span><span class="s4">&quot;Anchor&quot;</span><span class="s3">) </span><span class="s2">for </span><span class="s1">r </span><span class="s2">in </span><span class="s1">glyphRecords</span>
            <span class="s3">]</span>
            <span class="s2">for </span><span class="s1">l </span><span class="s2">in </span><span class="s1">glyphAnchors</span><span class="s3">:</span>
                <span class="s1">l</span><span class="s3">.</span><span class="s1">extend</span><span class="s3">([</span><span class="s2">None</span><span class="s3">] * (</span><span class="s1">self</span><span class="s3">.</span><span class="s1">ClassCount </span><span class="s3">- </span><span class="s1">len</span><span class="s3">(</span><span class="s1">l</span><span class="s3">)))</span>
            <span class="s2">for </span><span class="s1">allAnchors </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(*</span><span class="s1">glyphAnchors</span><span class="s3">):</span>
                <span class="s2">if </span><span class="s1">allNone</span><span class="s3">(</span><span class="s1">allAnchors</span><span class="s3">):</span>
                    <span class="s1">anchor </span><span class="s3">= </span><span class="s2">None</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">anchor </span><span class="s3">= </span><span class="s1">ot</span><span class="s3">.</span><span class="s1">Anchor</span><span class="s3">()</span>
                    <span class="s1">anchor</span><span class="s3">.</span><span class="s1">Format </span><span class="s3">= </span><span class="s6">1</span>
                    <span class="s1">merger</span><span class="s3">.</span><span class="s1">mergeThings</span><span class="s3">(</span><span class="s1">anchor</span><span class="s3">, </span><span class="s1">allAnchors</span><span class="s3">)</span>
                <span class="s1">anchors</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">anchor</span><span class="s3">)</span>
        <span class="s1">records</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">rec</span><span class="s3">)</span>
    <span class="s1">array </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">ot</span><span class="s3">, </span><span class="s1">Base </span><span class="s3">+ </span><span class="s4">&quot;Array&quot;</span><span class="s3">)()</span>
    <span class="s1">setattr</span><span class="s3">(</span><span class="s1">array</span><span class="s3">, </span><span class="s1">Base </span><span class="s3">+ </span><span class="s4">&quot;Record&quot;</span><span class="s3">, </span><span class="s1">records</span><span class="s3">)</span>
    <span class="s1">setattr</span><span class="s3">(</span><span class="s1">array</span><span class="s3">, </span><span class="s1">Base </span><span class="s3">+ </span><span class="s4">&quot;Count&quot;</span><span class="s3">, </span><span class="s1">len</span><span class="s3">(</span><span class="s1">records</span><span class="s3">))</span>
    <span class="s1">setattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">Base </span><span class="s3">+ </span><span class="s4">&quot;Array&quot;</span><span class="s3">, </span><span class="s1">array</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">AligningMerger</span><span class="s3">.</span><span class="s1">merger</span><span class="s3">(</span><span class="s1">ot</span><span class="s3">.</span><span class="s1">MarkBasePos</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">merge</span><span class="s3">(</span><span class="s1">merger</span><span class="s3">, </span><span class="s1">self</span><span class="s3">, </span><span class="s1">lst</span><span class="s3">):</span>
    <span class="s2">if not </span><span class="s1">allEqualTo</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">Format</span><span class="s3">, (</span><span class="s1">l</span><span class="s3">.</span><span class="s1">Format </span><span class="s2">for </span><span class="s1">l </span><span class="s2">in </span><span class="s1">lst</span><span class="s3">)):</span>
        <span class="s2">raise </span><span class="s1">InconsistentFormats</span><span class="s3">(</span>
            <span class="s1">merger</span><span class="s3">,</span>
            <span class="s1">subtable</span><span class="s3">=</span><span class="s4">&quot;mark-to-base positioning lookup&quot;</span><span class="s3">,</span>
            <span class="s1">expected</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">Format</span><span class="s3">,</span>
            <span class="s1">got</span><span class="s3">=[</span><span class="s1">l</span><span class="s3">.</span><span class="s1">Format </span><span class="s2">for </span><span class="s1">l </span><span class="s2">in </span><span class="s1">lst</span><span class="s3">],</span>
        <span class="s3">)</span>
    <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">Format </span><span class="s3">== </span><span class="s6">1</span><span class="s3">:</span>
        <span class="s1">_MarkBasePosFormat1_merge</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">lst</span><span class="s3">, </span><span class="s1">merger</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">UnsupportedFormat</span><span class="s3">(</span><span class="s1">merger</span><span class="s3">, </span><span class="s1">subtable</span><span class="s3">=</span><span class="s4">&quot;mark-to-base positioning lookup&quot;</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">AligningMerger</span><span class="s3">.</span><span class="s1">merger</span><span class="s3">(</span><span class="s1">ot</span><span class="s3">.</span><span class="s1">MarkMarkPos</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">merge</span><span class="s3">(</span><span class="s1">merger</span><span class="s3">, </span><span class="s1">self</span><span class="s3">, </span><span class="s1">lst</span><span class="s3">):</span>
    <span class="s2">if not </span><span class="s1">allEqualTo</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">Format</span><span class="s3">, (</span><span class="s1">l</span><span class="s3">.</span><span class="s1">Format </span><span class="s2">for </span><span class="s1">l </span><span class="s2">in </span><span class="s1">lst</span><span class="s3">)):</span>
        <span class="s2">raise </span><span class="s1">InconsistentFormats</span><span class="s3">(</span>
            <span class="s1">merger</span><span class="s3">,</span>
            <span class="s1">subtable</span><span class="s3">=</span><span class="s4">&quot;mark-to-mark positioning lookup&quot;</span><span class="s3">,</span>
            <span class="s1">expected</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">Format</span><span class="s3">,</span>
            <span class="s1">got</span><span class="s3">=[</span><span class="s1">l</span><span class="s3">.</span><span class="s1">Format </span><span class="s2">for </span><span class="s1">l </span><span class="s2">in </span><span class="s1">lst</span><span class="s3">],</span>
        <span class="s3">)</span>
    <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">Format </span><span class="s3">== </span><span class="s6">1</span><span class="s3">:</span>
        <span class="s1">_MarkBasePosFormat1_merge</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">lst</span><span class="s3">, </span><span class="s1">merger</span><span class="s3">, </span><span class="s4">&quot;Mark1&quot;</span><span class="s3">, </span><span class="s4">&quot;Mark2&quot;</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">UnsupportedFormat</span><span class="s3">(</span><span class="s1">merger</span><span class="s3">, </span><span class="s1">subtable</span><span class="s3">=</span><span class="s4">&quot;mark-to-mark positioning lookup&quot;</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">_PairSet_flatten</span><span class="s3">(</span><span class="s1">lst</span><span class="s3">, </span><span class="s1">font</span><span class="s3">):</span>
    <span class="s1">self </span><span class="s3">= </span><span class="s1">ot</span><span class="s3">.</span><span class="s1">PairSet</span><span class="s3">()</span>
    <span class="s1">self</span><span class="s3">.</span><span class="s1">Coverage </span><span class="s3">= </span><span class="s1">ot</span><span class="s3">.</span><span class="s1">Coverage</span><span class="s3">()</span>

    <span class="s5"># Align them</span>
    <span class="s1">glyphs</span><span class="s3">, </span><span class="s1">padded </span><span class="s3">= </span><span class="s1">_merge_GlyphOrders</span><span class="s3">(</span>
        <span class="s1">font</span><span class="s3">,</span>
        <span class="s3">[[</span><span class="s1">v</span><span class="s3">.</span><span class="s1">SecondGlyph </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">vs</span><span class="s3">.</span><span class="s1">PairValueRecord</span><span class="s3">] </span><span class="s2">for </span><span class="s1">vs </span><span class="s2">in </span><span class="s1">lst</span><span class="s3">],</span>
        <span class="s3">[</span><span class="s1">vs</span><span class="s3">.</span><span class="s1">PairValueRecord </span><span class="s2">for </span><span class="s1">vs </span><span class="s2">in </span><span class="s1">lst</span><span class="s3">],</span>
    <span class="s3">)</span>

    <span class="s1">self</span><span class="s3">.</span><span class="s1">Coverage</span><span class="s3">.</span><span class="s1">glyphs </span><span class="s3">= </span><span class="s1">glyphs</span>
    <span class="s1">self</span><span class="s3">.</span><span class="s1">PairValueRecord </span><span class="s3">= </span><span class="s1">pvrs </span><span class="s3">= []</span>
    <span class="s2">for </span><span class="s1">values </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(*</span><span class="s1">padded</span><span class="s3">):</span>
        <span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">values</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">v </span><span class="s2">is not None</span><span class="s3">:</span>
                <span class="s1">pvrs</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">v</span><span class="s3">)</span>
                <span class="s2">break</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">assert False</span>
    <span class="s1">self</span><span class="s3">.</span><span class="s1">PairValueCount </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">PairValueRecord</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">self</span>


<span class="s2">def </span><span class="s1">_Lookup_PairPosFormat1_subtables_flatten</span><span class="s3">(</span><span class="s1">lst</span><span class="s3">, </span><span class="s1">font</span><span class="s3">):</span>
    <span class="s2">assert </span><span class="s1">allEqual</span><span class="s3">(</span>
        <span class="s3">[</span><span class="s1">l</span><span class="s3">.</span><span class="s1">ValueFormat2 </span><span class="s3">== </span><span class="s6">0 </span><span class="s2">for </span><span class="s1">l </span><span class="s2">in </span><span class="s1">lst </span><span class="s2">if </span><span class="s1">l</span><span class="s3">.</span><span class="s1">PairSet</span><span class="s3">]</span>
    <span class="s3">), </span><span class="s4">&quot;Report bug against fonttools.&quot;</span>

    <span class="s1">self </span><span class="s3">= </span><span class="s1">ot</span><span class="s3">.</span><span class="s1">PairPos</span><span class="s3">()</span>
    <span class="s1">self</span><span class="s3">.</span><span class="s1">Format </span><span class="s3">= </span><span class="s6">1</span>
    <span class="s1">self</span><span class="s3">.</span><span class="s1">Coverage </span><span class="s3">= </span><span class="s1">ot</span><span class="s3">.</span><span class="s1">Coverage</span><span class="s3">()</span>
    <span class="s1">self</span><span class="s3">.</span><span class="s1">ValueFormat1 </span><span class="s3">= </span><span class="s1">reduce</span><span class="s3">(</span><span class="s1">int</span><span class="s3">.</span><span class="s1">__or__</span><span class="s3">, [</span><span class="s1">l</span><span class="s3">.</span><span class="s1">ValueFormat1 </span><span class="s2">for </span><span class="s1">l </span><span class="s2">in </span><span class="s1">lst</span><span class="s3">], </span><span class="s6">0</span><span class="s3">)</span>
    <span class="s1">self</span><span class="s3">.</span><span class="s1">ValueFormat2 </span><span class="s3">= </span><span class="s1">reduce</span><span class="s3">(</span><span class="s1">int</span><span class="s3">.</span><span class="s1">__or__</span><span class="s3">, [</span><span class="s1">l</span><span class="s3">.</span><span class="s1">ValueFormat2 </span><span class="s2">for </span><span class="s1">l </span><span class="s2">in </span><span class="s1">lst</span><span class="s3">], </span><span class="s6">0</span><span class="s3">)</span>

    <span class="s5"># Align them</span>
    <span class="s1">glyphs</span><span class="s3">, </span><span class="s1">padded </span><span class="s3">= </span><span class="s1">_merge_GlyphOrders</span><span class="s3">(</span>
        <span class="s1">font</span><span class="s3">, [</span><span class="s1">v</span><span class="s3">.</span><span class="s1">Coverage</span><span class="s3">.</span><span class="s1">glyphs </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">lst</span><span class="s3">], [</span><span class="s1">v</span><span class="s3">.</span><span class="s1">PairSet </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">lst</span><span class="s3">]</span>
    <span class="s3">)</span>

    <span class="s1">self</span><span class="s3">.</span><span class="s1">Coverage</span><span class="s3">.</span><span class="s1">glyphs </span><span class="s3">= </span><span class="s1">glyphs</span>
    <span class="s1">self</span><span class="s3">.</span><span class="s1">PairSet </span><span class="s3">= [</span>
        <span class="s1">_PairSet_flatten</span><span class="s3">([</span><span class="s1">v </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">values </span><span class="s2">if </span><span class="s1">v </span><span class="s2">is not None</span><span class="s3">], </span><span class="s1">font</span><span class="s3">)</span>
        <span class="s2">for </span><span class="s1">values </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(*</span><span class="s1">padded</span><span class="s3">)</span>
    <span class="s3">]</span>
    <span class="s1">self</span><span class="s3">.</span><span class="s1">PairSetCount </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">PairSet</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">self</span>


<span class="s2">def </span><span class="s1">_Lookup_PairPosFormat2_subtables_flatten</span><span class="s3">(</span><span class="s1">lst</span><span class="s3">, </span><span class="s1">font</span><span class="s3">):</span>
    <span class="s2">assert </span><span class="s1">allEqual</span><span class="s3">(</span>
        <span class="s3">[</span><span class="s1">l</span><span class="s3">.</span><span class="s1">ValueFormat2 </span><span class="s3">== </span><span class="s6">0 </span><span class="s2">for </span><span class="s1">l </span><span class="s2">in </span><span class="s1">lst </span><span class="s2">if </span><span class="s1">l</span><span class="s3">.</span><span class="s1">Class1Record</span><span class="s3">]</span>
    <span class="s3">), </span><span class="s4">&quot;Report bug against fonttools.&quot;</span>

    <span class="s1">self </span><span class="s3">= </span><span class="s1">ot</span><span class="s3">.</span><span class="s1">PairPos</span><span class="s3">()</span>
    <span class="s1">self</span><span class="s3">.</span><span class="s1">Format </span><span class="s3">= </span><span class="s6">2</span>
    <span class="s1">self</span><span class="s3">.</span><span class="s1">Coverage </span><span class="s3">= </span><span class="s1">ot</span><span class="s3">.</span><span class="s1">Coverage</span><span class="s3">()</span>
    <span class="s1">self</span><span class="s3">.</span><span class="s1">ValueFormat1 </span><span class="s3">= </span><span class="s1">reduce</span><span class="s3">(</span><span class="s1">int</span><span class="s3">.</span><span class="s1">__or__</span><span class="s3">, [</span><span class="s1">l</span><span class="s3">.</span><span class="s1">ValueFormat1 </span><span class="s2">for </span><span class="s1">l </span><span class="s2">in </span><span class="s1">lst</span><span class="s3">], </span><span class="s6">0</span><span class="s3">)</span>
    <span class="s1">self</span><span class="s3">.</span><span class="s1">ValueFormat2 </span><span class="s3">= </span><span class="s1">reduce</span><span class="s3">(</span><span class="s1">int</span><span class="s3">.</span><span class="s1">__or__</span><span class="s3">, [</span><span class="s1">l</span><span class="s3">.</span><span class="s1">ValueFormat2 </span><span class="s2">for </span><span class="s1">l </span><span class="s2">in </span><span class="s1">lst</span><span class="s3">], </span><span class="s6">0</span><span class="s3">)</span>

    <span class="s5"># Align them</span>
    <span class="s1">glyphs</span><span class="s3">, </span><span class="s1">_ </span><span class="s3">= </span><span class="s1">_merge_GlyphOrders</span><span class="s3">(</span><span class="s1">font</span><span class="s3">, [</span><span class="s1">v</span><span class="s3">.</span><span class="s1">Coverage</span><span class="s3">.</span><span class="s1">glyphs </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">lst</span><span class="s3">])</span>
    <span class="s1">self</span><span class="s3">.</span><span class="s1">Coverage</span><span class="s3">.</span><span class="s1">glyphs </span><span class="s3">= </span><span class="s1">glyphs</span>

    <span class="s1">matrices </span><span class="s3">= </span><span class="s1">_PairPosFormat2_align_matrices</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">lst</span><span class="s3">, </span><span class="s1">font</span><span class="s3">, </span><span class="s1">transparent</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

    <span class="s1">matrix </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">Class1Record </span><span class="s3">= []</span>
    <span class="s2">for </span><span class="s1">rows </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(*</span><span class="s1">matrices</span><span class="s3">):</span>
        <span class="s1">row </span><span class="s3">= </span><span class="s1">ot</span><span class="s3">.</span><span class="s1">Class1Record</span><span class="s3">()</span>
        <span class="s1">matrix</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">row</span><span class="s3">)</span>
        <span class="s1">row</span><span class="s3">.</span><span class="s1">Class2Record </span><span class="s3">= []</span>
        <span class="s1">row </span><span class="s3">= </span><span class="s1">row</span><span class="s3">.</span><span class="s1">Class2Record</span>
        <span class="s2">for </span><span class="s1">cols </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(*</span><span class="s1">list</span><span class="s3">(</span><span class="s1">r</span><span class="s3">.</span><span class="s1">Class2Record </span><span class="s2">for </span><span class="s1">r </span><span class="s2">in </span><span class="s1">rows</span><span class="s3">)):</span>
            <span class="s1">col </span><span class="s3">= </span><span class="s1">next</span><span class="s3">(</span><span class="s1">iter</span><span class="s3">(</span><span class="s1">c </span><span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">cols </span><span class="s2">if </span><span class="s1">c </span><span class="s2">is not None</span><span class="s3">))</span>
            <span class="s1">row</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">col</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">self</span>


<span class="s2">def </span><span class="s1">_Lookup_PairPos_subtables_canonicalize</span><span class="s3">(</span><span class="s1">lst</span><span class="s3">, </span><span class="s1">font</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Merge multiple Format1 subtables at the beginning of lst, 
    and merge multiple consecutive Format2 subtables that have the same 
    Class2 (ie. were split because of offset overflows).  Returns new list.&quot;&quot;&quot;</span>
    <span class="s1">lst </span><span class="s3">= </span><span class="s1">list</span><span class="s3">(</span><span class="s1">lst</span><span class="s3">)</span>

    <span class="s1">l </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">lst</span><span class="s3">)</span>
    <span class="s1">i </span><span class="s3">= </span><span class="s6">0</span>
    <span class="s2">while </span><span class="s1">i </span><span class="s3">&lt; </span><span class="s1">l </span><span class="s2">and </span><span class="s1">lst</span><span class="s3">[</span><span class="s1">i</span><span class="s3">].</span><span class="s1">Format </span><span class="s3">== </span><span class="s6">1</span><span class="s3">:</span>
        <span class="s1">i </span><span class="s3">+= </span><span class="s6">1</span>
    <span class="s1">lst</span><span class="s3">[:</span><span class="s1">i</span><span class="s3">] = [</span><span class="s1">_Lookup_PairPosFormat1_subtables_flatten</span><span class="s3">(</span><span class="s1">lst</span><span class="s3">[:</span><span class="s1">i</span><span class="s3">], </span><span class="s1">font</span><span class="s3">)]</span>

    <span class="s1">l </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">lst</span><span class="s3">)</span>
    <span class="s1">i </span><span class="s3">= </span><span class="s1">l</span>
    <span class="s2">while </span><span class="s1">i </span><span class="s3">&gt; </span><span class="s6">0 </span><span class="s2">and </span><span class="s1">lst</span><span class="s3">[</span><span class="s1">i </span><span class="s3">- </span><span class="s6">1</span><span class="s3">].</span><span class="s1">Format </span><span class="s3">== </span><span class="s6">2</span><span class="s3">:</span>
        <span class="s1">i </span><span class="s3">-= </span><span class="s6">1</span>
    <span class="s1">lst</span><span class="s3">[</span><span class="s1">i</span><span class="s3">:] = [</span><span class="s1">_Lookup_PairPosFormat2_subtables_flatten</span><span class="s3">(</span><span class="s1">lst</span><span class="s3">[</span><span class="s1">i</span><span class="s3">:], </span><span class="s1">font</span><span class="s3">)]</span>

    <span class="s2">return </span><span class="s1">lst</span>


<span class="s2">def </span><span class="s1">_Lookup_SinglePos_subtables_flatten</span><span class="s3">(</span><span class="s1">lst</span><span class="s3">, </span><span class="s1">font</span><span class="s3">, </span><span class="s1">min_inclusive_rec_format</span><span class="s3">):</span>
    <span class="s1">glyphs</span><span class="s3">, </span><span class="s1">_ </span><span class="s3">= </span><span class="s1">_merge_GlyphOrders</span><span class="s3">(</span><span class="s1">font</span><span class="s3">, [</span><span class="s1">v</span><span class="s3">.</span><span class="s1">Coverage</span><span class="s3">.</span><span class="s1">glyphs </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">lst</span><span class="s3">], </span><span class="s2">None</span><span class="s3">)</span>
    <span class="s1">num_glyphs </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">glyphs</span><span class="s3">)</span>
    <span class="s1">new </span><span class="s3">= </span><span class="s1">ot</span><span class="s3">.</span><span class="s1">SinglePos</span><span class="s3">()</span>
    <span class="s1">new</span><span class="s3">.</span><span class="s1">Format </span><span class="s3">= </span><span class="s6">2</span>
    <span class="s1">new</span><span class="s3">.</span><span class="s1">ValueFormat </span><span class="s3">= </span><span class="s1">min_inclusive_rec_format</span>
    <span class="s1">new</span><span class="s3">.</span><span class="s1">Coverage </span><span class="s3">= </span><span class="s1">ot</span><span class="s3">.</span><span class="s1">Coverage</span><span class="s3">()</span>
    <span class="s1">new</span><span class="s3">.</span><span class="s1">Coverage</span><span class="s3">.</span><span class="s1">glyphs </span><span class="s3">= </span><span class="s1">glyphs</span>
    <span class="s1">new</span><span class="s3">.</span><span class="s1">ValueCount </span><span class="s3">= </span><span class="s1">num_glyphs</span>
    <span class="s1">new</span><span class="s3">.</span><span class="s1">Value </span><span class="s3">= [</span><span class="s2">None</span><span class="s3">] * </span><span class="s1">num_glyphs</span>
    <span class="s2">for </span><span class="s1">singlePos </span><span class="s2">in </span><span class="s1">lst</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">singlePos</span><span class="s3">.</span><span class="s1">Format </span><span class="s3">== </span><span class="s6">1</span><span class="s3">:</span>
            <span class="s1">val_rec </span><span class="s3">= </span><span class="s1">singlePos</span><span class="s3">.</span><span class="s1">Value</span>
            <span class="s2">for </span><span class="s1">gname </span><span class="s2">in </span><span class="s1">singlePos</span><span class="s3">.</span><span class="s1">Coverage</span><span class="s3">.</span><span class="s1">glyphs</span><span class="s3">:</span>
                <span class="s1">i </span><span class="s3">= </span><span class="s1">glyphs</span><span class="s3">.</span><span class="s1">index</span><span class="s3">(</span><span class="s1">gname</span><span class="s3">)</span>
                <span class="s1">new</span><span class="s3">.</span><span class="s1">Value</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">copy</span><span class="s3">.</span><span class="s1">deepcopy</span><span class="s3">(</span><span class="s1">val_rec</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">singlePos</span><span class="s3">.</span><span class="s1">Format </span><span class="s3">== </span><span class="s6">2</span><span class="s3">:</span>
            <span class="s2">for </span><span class="s1">j</span><span class="s3">, </span><span class="s1">gname </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">singlePos</span><span class="s3">.</span><span class="s1">Coverage</span><span class="s3">.</span><span class="s1">glyphs</span><span class="s3">):</span>
                <span class="s1">val_rec </span><span class="s3">= </span><span class="s1">singlePos</span><span class="s3">.</span><span class="s1">Value</span><span class="s3">[</span><span class="s1">j</span><span class="s3">]</span>
                <span class="s1">i </span><span class="s3">= </span><span class="s1">glyphs</span><span class="s3">.</span><span class="s1">index</span><span class="s3">(</span><span class="s1">gname</span><span class="s3">)</span>
                <span class="s1">new</span><span class="s3">.</span><span class="s1">Value</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">copy</span><span class="s3">.</span><span class="s1">deepcopy</span><span class="s3">(</span><span class="s1">val_rec</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s3">[</span><span class="s1">new</span><span class="s3">]</span>


<span class="s3">@</span><span class="s1">AligningMerger</span><span class="s3">.</span><span class="s1">merger</span><span class="s3">(</span><span class="s1">ot</span><span class="s3">.</span><span class="s1">CursivePos</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">merge</span><span class="s3">(</span><span class="s1">merger</span><span class="s3">, </span><span class="s1">self</span><span class="s3">, </span><span class="s1">lst</span><span class="s3">):</span>
    <span class="s5"># Align them</span>
    <span class="s1">glyphs</span><span class="s3">, </span><span class="s1">padded </span><span class="s3">= </span><span class="s1">_merge_GlyphOrders</span><span class="s3">(</span>
        <span class="s1">merger</span><span class="s3">.</span><span class="s1">font</span><span class="s3">,</span>
        <span class="s3">[</span><span class="s1">l</span><span class="s3">.</span><span class="s1">Coverage</span><span class="s3">.</span><span class="s1">glyphs </span><span class="s2">for </span><span class="s1">l </span><span class="s2">in </span><span class="s1">lst</span><span class="s3">],</span>
        <span class="s3">[</span><span class="s1">l</span><span class="s3">.</span><span class="s1">EntryExitRecord </span><span class="s2">for </span><span class="s1">l </span><span class="s2">in </span><span class="s1">lst</span><span class="s3">],</span>
    <span class="s3">)</span>

    <span class="s1">self</span><span class="s3">.</span><span class="s1">Format </span><span class="s3">= </span><span class="s6">1</span>
    <span class="s1">self</span><span class="s3">.</span><span class="s1">Coverage </span><span class="s3">= </span><span class="s1">ot</span><span class="s3">.</span><span class="s1">Coverage</span><span class="s3">()</span>
    <span class="s1">self</span><span class="s3">.</span><span class="s1">Coverage</span><span class="s3">.</span><span class="s1">glyphs </span><span class="s3">= </span><span class="s1">glyphs</span>
    <span class="s1">self</span><span class="s3">.</span><span class="s1">EntryExitRecord </span><span class="s3">= []</span>
    <span class="s2">for </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">glyphs</span><span class="s3">:</span>
        <span class="s1">rec </span><span class="s3">= </span><span class="s1">ot</span><span class="s3">.</span><span class="s1">EntryExitRecord</span><span class="s3">()</span>
        <span class="s1">rec</span><span class="s3">.</span><span class="s1">EntryAnchor </span><span class="s3">= </span><span class="s1">ot</span><span class="s3">.</span><span class="s1">Anchor</span><span class="s3">()</span>
        <span class="s1">rec</span><span class="s3">.</span><span class="s1">EntryAnchor</span><span class="s3">.</span><span class="s1">Format </span><span class="s3">= </span><span class="s6">1</span>
        <span class="s1">rec</span><span class="s3">.</span><span class="s1">ExitAnchor </span><span class="s3">= </span><span class="s1">ot</span><span class="s3">.</span><span class="s1">Anchor</span><span class="s3">()</span>
        <span class="s1">rec</span><span class="s3">.</span><span class="s1">ExitAnchor</span><span class="s3">.</span><span class="s1">Format </span><span class="s3">= </span><span class="s6">1</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">EntryExitRecord</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">rec</span><span class="s3">)</span>
    <span class="s1">merger</span><span class="s3">.</span><span class="s1">mergeLists</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">EntryExitRecord</span><span class="s3">, </span><span class="s1">padded</span><span class="s3">)</span>
    <span class="s1">self</span><span class="s3">.</span><span class="s1">EntryExitCount </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">EntryExitRecord</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">AligningMerger</span><span class="s3">.</span><span class="s1">merger</span><span class="s3">(</span><span class="s1">ot</span><span class="s3">.</span><span class="s1">EntryExitRecord</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">merge</span><span class="s3">(</span><span class="s1">merger</span><span class="s3">, </span><span class="s1">self</span><span class="s3">, </span><span class="s1">lst</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">all</span><span class="s3">(</span><span class="s1">master</span><span class="s3">.</span><span class="s1">EntryAnchor </span><span class="s2">is None for </span><span class="s1">master </span><span class="s2">in </span><span class="s1">lst</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">EntryAnchor </span><span class="s3">= </span><span class="s2">None</span>
    <span class="s2">if </span><span class="s1">all</span><span class="s3">(</span><span class="s1">master</span><span class="s3">.</span><span class="s1">ExitAnchor </span><span class="s2">is None for </span><span class="s1">master </span><span class="s2">in </span><span class="s1">lst</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">ExitAnchor </span><span class="s3">= </span><span class="s2">None</span>
    <span class="s1">merger</span><span class="s3">.</span><span class="s1">mergeObjects</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">lst</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">AligningMerger</span><span class="s3">.</span><span class="s1">merger</span><span class="s3">(</span><span class="s1">ot</span><span class="s3">.</span><span class="s1">Lookup</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">merge</span><span class="s3">(</span><span class="s1">merger</span><span class="s3">, </span><span class="s1">self</span><span class="s3">, </span><span class="s1">lst</span><span class="s3">):</span>
    <span class="s1">subtables </span><span class="s3">= </span><span class="s1">merger</span><span class="s3">.</span><span class="s1">lookup_subtables </span><span class="s3">= [</span><span class="s1">l</span><span class="s3">.</span><span class="s1">SubTable </span><span class="s2">for </span><span class="s1">l </span><span class="s2">in </span><span class="s1">lst</span><span class="s3">]</span>

    <span class="s5"># Remove Extension subtables</span>
    <span class="s2">for </span><span class="s1">l</span><span class="s3">, </span><span class="s1">sts </span><span class="s2">in </span><span class="s1">list</span><span class="s3">(</span><span class="s1">zip</span><span class="s3">(</span><span class="s1">lst</span><span class="s3">, </span><span class="s1">subtables</span><span class="s3">)) + [(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">SubTable</span><span class="s3">)]:</span>
        <span class="s2">if not </span><span class="s1">sts</span><span class="s3">:</span>
            <span class="s2">continue</span>
        <span class="s2">if </span><span class="s1">sts</span><span class="s3">[</span><span class="s6">0</span><span class="s3">].</span><span class="s1">__class__</span><span class="s3">.</span><span class="s1">__name__</span><span class="s3">.</span><span class="s1">startswith</span><span class="s3">(</span><span class="s4">&quot;Extension&quot;</span><span class="s3">):</span>
            <span class="s2">if not </span><span class="s1">allEqual</span><span class="s3">([</span><span class="s1">st</span><span class="s3">.</span><span class="s1">__class__ </span><span class="s2">for </span><span class="s1">st </span><span class="s2">in </span><span class="s1">sts</span><span class="s3">]):</span>
                <span class="s2">raise </span><span class="s1">InconsistentExtensions</span><span class="s3">(</span>
                    <span class="s1">merger</span><span class="s3">,</span>
                    <span class="s1">expected</span><span class="s3">=</span><span class="s4">&quot;Extension&quot;</span><span class="s3">,</span>
                    <span class="s1">got</span><span class="s3">=[</span><span class="s1">st</span><span class="s3">.</span><span class="s1">__class__</span><span class="s3">.</span><span class="s1">__name__ </span><span class="s2">for </span><span class="s1">st </span><span class="s2">in </span><span class="s1">sts</span><span class="s3">],</span>
                <span class="s3">)</span>
            <span class="s2">if not </span><span class="s1">allEqual</span><span class="s3">([</span><span class="s1">st</span><span class="s3">.</span><span class="s1">ExtensionLookupType </span><span class="s2">for </span><span class="s1">st </span><span class="s2">in </span><span class="s1">sts</span><span class="s3">]):</span>
                <span class="s2">raise </span><span class="s1">InconsistentExtensions</span><span class="s3">(</span><span class="s1">merger</span><span class="s3">)</span>
            <span class="s1">l</span><span class="s3">.</span><span class="s1">LookupType </span><span class="s3">= </span><span class="s1">sts</span><span class="s3">[</span><span class="s6">0</span><span class="s3">].</span><span class="s1">ExtensionLookupType</span>
            <span class="s1">new_sts </span><span class="s3">= [</span><span class="s1">st</span><span class="s3">.</span><span class="s1">ExtSubTable </span><span class="s2">for </span><span class="s1">st </span><span class="s2">in </span><span class="s1">sts</span><span class="s3">]</span>
            <span class="s2">del </span><span class="s1">sts</span><span class="s3">[:]</span>
            <span class="s1">sts</span><span class="s3">.</span><span class="s1">extend</span><span class="s3">(</span><span class="s1">new_sts</span><span class="s3">)</span>

    <span class="s1">isPairPos </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">SubTable </span><span class="s2">and </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">SubTable</span><span class="s3">[</span><span class="s6">0</span><span class="s3">], </span><span class="s1">ot</span><span class="s3">.</span><span class="s1">PairPos</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">isPairPos</span><span class="s3">:</span>
        <span class="s5"># AFDKO and feaLib sometimes generate two Format1 subtables instead of one.</span>
        <span class="s5"># Merge those before continuing.</span>
        <span class="s5"># https://github.com/fonttools/fonttools/issues/719</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">SubTable </span><span class="s3">= </span><span class="s1">_Lookup_PairPos_subtables_canonicalize</span><span class="s3">(</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">SubTable</span><span class="s3">, </span><span class="s1">merger</span><span class="s3">.</span><span class="s1">font</span>
        <span class="s3">)</span>
        <span class="s1">subtables </span><span class="s3">= </span><span class="s1">merger</span><span class="s3">.</span><span class="s1">lookup_subtables </span><span class="s3">= [</span>
            <span class="s1">_Lookup_PairPos_subtables_canonicalize</span><span class="s3">(</span><span class="s1">st</span><span class="s3">, </span><span class="s1">merger</span><span class="s3">.</span><span class="s1">font</span><span class="s3">) </span><span class="s2">for </span><span class="s1">st </span><span class="s2">in </span><span class="s1">subtables</span>
        <span class="s3">]</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">isSinglePos </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">SubTable </span><span class="s2">and </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">SubTable</span><span class="s3">[</span><span class="s6">0</span><span class="s3">], </span><span class="s1">ot</span><span class="s3">.</span><span class="s1">SinglePos</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">isSinglePos</span><span class="s3">:</span>
            <span class="s1">numSubtables </span><span class="s3">= [</span><span class="s1">len</span><span class="s3">(</span><span class="s1">st</span><span class="s3">) </span><span class="s2">for </span><span class="s1">st </span><span class="s2">in </span><span class="s1">subtables</span><span class="s3">]</span>
            <span class="s2">if not </span><span class="s1">all</span><span class="s3">([</span><span class="s1">nums </span><span class="s3">== </span><span class="s1">numSubtables</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] </span><span class="s2">for </span><span class="s1">nums </span><span class="s2">in </span><span class="s1">numSubtables</span><span class="s3">]):</span>
                <span class="s5"># Flatten list of SinglePos subtables to single Format 2 subtable,</span>
                <span class="s5"># with all value records set to the rec format type.</span>
                <span class="s5"># We use buildSinglePos() to optimize the lookup after merging.</span>
                <span class="s1">valueFormatList </span><span class="s3">= [</span><span class="s1">t</span><span class="s3">.</span><span class="s1">ValueFormat </span><span class="s2">for </span><span class="s1">st </span><span class="s2">in </span><span class="s1">subtables </span><span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">st</span><span class="s3">]</span>
                <span class="s5"># Find the minimum value record that can accomodate all the singlePos subtables.</span>
                <span class="s1">mirf </span><span class="s3">= </span><span class="s1">reduce</span><span class="s3">(</span><span class="s1">ior</span><span class="s3">, </span><span class="s1">valueFormatList</span><span class="s3">)</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">SubTable </span><span class="s3">= </span><span class="s1">_Lookup_SinglePos_subtables_flatten</span><span class="s3">(</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">SubTable</span><span class="s3">, </span><span class="s1">merger</span><span class="s3">.</span><span class="s1">font</span><span class="s3">, </span><span class="s1">mirf</span>
                <span class="s3">)</span>
                <span class="s1">subtables </span><span class="s3">= </span><span class="s1">merger</span><span class="s3">.</span><span class="s1">lookup_subtables </span><span class="s3">= [</span>
                    <span class="s1">_Lookup_SinglePos_subtables_flatten</span><span class="s3">(</span><span class="s1">st</span><span class="s3">, </span><span class="s1">merger</span><span class="s3">.</span><span class="s1">font</span><span class="s3">, </span><span class="s1">mirf</span><span class="s3">)</span>
                    <span class="s2">for </span><span class="s1">st </span><span class="s2">in </span><span class="s1">subtables</span>
                <span class="s3">]</span>
                <span class="s1">flattened </span><span class="s3">= </span><span class="s2">True</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">flattened </span><span class="s3">= </span><span class="s2">False</span>

    <span class="s1">merger</span><span class="s3">.</span><span class="s1">mergeLists</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">SubTable</span><span class="s3">, </span><span class="s1">subtables</span><span class="s3">)</span>
    <span class="s1">self</span><span class="s3">.</span><span class="s1">SubTableCount </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">SubTable</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">isPairPos</span><span class="s3">:</span>
        <span class="s5"># If format-1 subtable created during canonicalization is empty, remove it.</span>
        <span class="s2">assert </span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">SubTable</span><span class="s3">) &gt;= </span><span class="s6">1 </span><span class="s2">and </span><span class="s1">self</span><span class="s3">.</span><span class="s1">SubTable</span><span class="s3">[</span><span class="s6">0</span><span class="s3">].</span><span class="s1">Format </span><span class="s3">== </span><span class="s6">1</span>
        <span class="s2">if not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">SubTable</span><span class="s3">[</span><span class="s6">0</span><span class="s3">].</span><span class="s1">Coverage</span><span class="s3">.</span><span class="s1">glyphs</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">SubTable</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">(</span><span class="s6">0</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">SubTableCount </span><span class="s3">-= </span><span class="s6">1</span>

        <span class="s5"># If format-2 subtable created during canonicalization is empty, remove it.</span>
        <span class="s2">assert </span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">SubTable</span><span class="s3">) &gt;= </span><span class="s6">1 </span><span class="s2">and </span><span class="s1">self</span><span class="s3">.</span><span class="s1">SubTable</span><span class="s3">[-</span><span class="s6">1</span><span class="s3">].</span><span class="s1">Format </span><span class="s3">== </span><span class="s6">2</span>
        <span class="s2">if not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">SubTable</span><span class="s3">[-</span><span class="s6">1</span><span class="s3">].</span><span class="s1">Coverage</span><span class="s3">.</span><span class="s1">glyphs</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">SubTable</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">(-</span><span class="s6">1</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">SubTableCount </span><span class="s3">-= </span><span class="s6">1</span>

        <span class="s5"># Compact the merged subtables</span>
        <span class="s5"># This is a good moment to do it because the compaction should create</span>
        <span class="s5"># smaller subtables, which may prevent overflows from happening.</span>
        <span class="s5"># Keep reading the value from the ENV until ufo2ft switches to the config system</span>
        <span class="s1">level </span><span class="s3">= </span><span class="s1">merger</span><span class="s3">.</span><span class="s1">font</span><span class="s3">.</span><span class="s1">cfg</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span>
            <span class="s4">&quot;fontTools.otlLib.optimize.gpos:COMPRESSION_LEVEL&quot;</span><span class="s3">,</span>
            <span class="s1">default</span><span class="s3">=</span><span class="s1">_compression_level_from_env</span><span class="s3">(),</span>
        <span class="s3">)</span>
        <span class="s2">if </span><span class="s1">level </span><span class="s3">!= </span><span class="s6">0</span><span class="s3">:</span>
            <span class="s1">log</span><span class="s3">.</span><span class="s1">info</span><span class="s3">(</span><span class="s4">&quot;Compacting GPOS...&quot;</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">SubTable </span><span class="s3">= </span><span class="s1">compact_pair_pos</span><span class="s3">(</span><span class="s1">merger</span><span class="s3">.</span><span class="s1">font</span><span class="s3">, </span><span class="s1">level</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">SubTable</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">SubTableCount </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">SubTable</span><span class="s3">)</span>

    <span class="s2">elif </span><span class="s1">isSinglePos </span><span class="s2">and </span><span class="s1">flattened</span><span class="s3">:</span>
        <span class="s1">singlePosTable </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">SubTable</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]</span>
        <span class="s1">glyphs </span><span class="s3">= </span><span class="s1">singlePosTable</span><span class="s3">.</span><span class="s1">Coverage</span><span class="s3">.</span><span class="s1">glyphs</span>
        <span class="s5"># We know that singlePosTable is Format 2, as this is set</span>
        <span class="s5"># in _Lookup_SinglePos_subtables_flatten.</span>
        <span class="s1">singlePosMapping </span><span class="s3">= {</span>
            <span class="s1">gname</span><span class="s3">: </span><span class="s1">valRecord </span><span class="s2">for </span><span class="s1">gname</span><span class="s3">, </span><span class="s1">valRecord </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">glyphs</span><span class="s3">, </span><span class="s1">singlePosTable</span><span class="s3">.</span><span class="s1">Value</span><span class="s3">)</span>
        <span class="s3">}</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">SubTable </span><span class="s3">= </span><span class="s1">buildSinglePos</span><span class="s3">(</span>
            <span class="s1">singlePosMapping</span><span class="s3">, </span><span class="s1">merger</span><span class="s3">.</span><span class="s1">font</span><span class="s3">.</span><span class="s1">getReverseGlyphMap</span><span class="s3">()</span>
        <span class="s3">)</span>
    <span class="s1">merger</span><span class="s3">.</span><span class="s1">mergeObjects</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">lst</span><span class="s3">, </span><span class="s1">exclude</span><span class="s3">=[</span><span class="s4">&quot;SubTable&quot;</span><span class="s3">, </span><span class="s4">&quot;SubTableCount&quot;</span><span class="s3">])</span>

    <span class="s2">del </span><span class="s1">merger</span><span class="s3">.</span><span class="s1">lookup_subtables</span>


<span class="s5">#</span>
<span class="s5"># InstancerMerger</span>
<span class="s5">#</span>


<span class="s2">class </span><span class="s1">InstancerMerger</span><span class="s3">(</span><span class="s1">AligningMerger</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;A merger that takes multiple master fonts, and instantiates 
    an instance.&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">font</span><span class="s3">, </span><span class="s1">model</span><span class="s3">, </span><span class="s1">location</span><span class="s3">):</span>
        <span class="s1">Merger</span><span class="s3">.</span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">font</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">model </span><span class="s3">= </span><span class="s1">model</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">location </span><span class="s3">= </span><span class="s1">location</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">masterScalars </span><span class="s3">= </span><span class="s1">model</span><span class="s3">.</span><span class="s1">getMasterScalars</span><span class="s3">(</span><span class="s1">location</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">InstancerMerger</span><span class="s3">.</span><span class="s1">merger</span><span class="s3">(</span><span class="s1">ot</span><span class="s3">.</span><span class="s1">CaretValue</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">merge</span><span class="s3">(</span><span class="s1">merger</span><span class="s3">, </span><span class="s1">self</span><span class="s3">, </span><span class="s1">lst</span><span class="s3">):</span>
    <span class="s2">assert </span><span class="s1">self</span><span class="s3">.</span><span class="s1">Format </span><span class="s3">== </span><span class="s6">1</span>
    <span class="s1">Coords </span><span class="s3">= [</span><span class="s1">a</span><span class="s3">.</span><span class="s1">Coordinate </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">lst</span><span class="s3">]</span>
    <span class="s1">model </span><span class="s3">= </span><span class="s1">merger</span><span class="s3">.</span><span class="s1">model</span>
    <span class="s1">masterScalars </span><span class="s3">= </span><span class="s1">merger</span><span class="s3">.</span><span class="s1">masterScalars</span>
    <span class="s1">self</span><span class="s3">.</span><span class="s1">Coordinate </span><span class="s3">= </span><span class="s1">otRound</span><span class="s3">(</span>
        <span class="s1">model</span><span class="s3">.</span><span class="s1">interpolateFromValuesAndScalars</span><span class="s3">(</span><span class="s1">Coords</span><span class="s3">, </span><span class="s1">masterScalars</span><span class="s3">)</span>
    <span class="s3">)</span>


<span class="s3">@</span><span class="s1">InstancerMerger</span><span class="s3">.</span><span class="s1">merger</span><span class="s3">(</span><span class="s1">ot</span><span class="s3">.</span><span class="s1">Anchor</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">merge</span><span class="s3">(</span><span class="s1">merger</span><span class="s3">, </span><span class="s1">self</span><span class="s3">, </span><span class="s1">lst</span><span class="s3">):</span>
    <span class="s2">assert </span><span class="s1">self</span><span class="s3">.</span><span class="s1">Format </span><span class="s3">== </span><span class="s6">1</span>
    <span class="s1">XCoords </span><span class="s3">= [</span><span class="s1">a</span><span class="s3">.</span><span class="s1">XCoordinate </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">lst</span><span class="s3">]</span>
    <span class="s1">YCoords </span><span class="s3">= [</span><span class="s1">a</span><span class="s3">.</span><span class="s1">YCoordinate </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">lst</span><span class="s3">]</span>
    <span class="s1">model </span><span class="s3">= </span><span class="s1">merger</span><span class="s3">.</span><span class="s1">model</span>
    <span class="s1">masterScalars </span><span class="s3">= </span><span class="s1">merger</span><span class="s3">.</span><span class="s1">masterScalars</span>
    <span class="s1">self</span><span class="s3">.</span><span class="s1">XCoordinate </span><span class="s3">= </span><span class="s1">otRound</span><span class="s3">(</span>
        <span class="s1">model</span><span class="s3">.</span><span class="s1">interpolateFromValuesAndScalars</span><span class="s3">(</span><span class="s1">XCoords</span><span class="s3">, </span><span class="s1">masterScalars</span><span class="s3">)</span>
    <span class="s3">)</span>
    <span class="s1">self</span><span class="s3">.</span><span class="s1">YCoordinate </span><span class="s3">= </span><span class="s1">otRound</span><span class="s3">(</span>
        <span class="s1">model</span><span class="s3">.</span><span class="s1">interpolateFromValuesAndScalars</span><span class="s3">(</span><span class="s1">YCoords</span><span class="s3">, </span><span class="s1">masterScalars</span><span class="s3">)</span>
    <span class="s3">)</span>


<span class="s3">@</span><span class="s1">InstancerMerger</span><span class="s3">.</span><span class="s1">merger</span><span class="s3">(</span><span class="s1">otBase</span><span class="s3">.</span><span class="s1">ValueRecord</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">merge</span><span class="s3">(</span><span class="s1">merger</span><span class="s3">, </span><span class="s1">self</span><span class="s3">, </span><span class="s1">lst</span><span class="s3">):</span>
    <span class="s1">model </span><span class="s3">= </span><span class="s1">merger</span><span class="s3">.</span><span class="s1">model</span>
    <span class="s1">masterScalars </span><span class="s3">= </span><span class="s1">merger</span><span class="s3">.</span><span class="s1">masterScalars</span>
    <span class="s5"># TODO Handle differing valueformats</span>
    <span class="s2">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">tableName </span><span class="s2">in </span><span class="s3">[</span>
        <span class="s3">(</span><span class="s4">&quot;XAdvance&quot;</span><span class="s3">, </span><span class="s4">&quot;XAdvDevice&quot;</span><span class="s3">),</span>
        <span class="s3">(</span><span class="s4">&quot;YAdvance&quot;</span><span class="s3">, </span><span class="s4">&quot;YAdvDevice&quot;</span><span class="s3">),</span>
        <span class="s3">(</span><span class="s4">&quot;XPlacement&quot;</span><span class="s3">, </span><span class="s4">&quot;XPlaDevice&quot;</span><span class="s3">),</span>
        <span class="s3">(</span><span class="s4">&quot;YPlacement&quot;</span><span class="s3">, </span><span class="s4">&quot;YPlaDevice&quot;</span><span class="s3">),</span>
    <span class="s3">]:</span>
        <span class="s2">assert not </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">tableName</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">):</span>
            <span class="s1">values </span><span class="s3">= [</span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s6">0</span><span class="s3">) </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">lst</span><span class="s3">]</span>
            <span class="s1">value </span><span class="s3">= </span><span class="s1">otRound</span><span class="s3">(</span>
                <span class="s1">model</span><span class="s3">.</span><span class="s1">interpolateFromValuesAndScalars</span><span class="s3">(</span><span class="s1">values</span><span class="s3">, </span><span class="s1">masterScalars</span><span class="s3">)</span>
            <span class="s3">)</span>
            <span class="s1">setattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">value</span><span class="s3">)</span>


<span class="s5">#</span>
<span class="s5"># MutatorMerger</span>
<span class="s5">#</span>


<span class="s2">class </span><span class="s1">MutatorMerger</span><span class="s3">(</span><span class="s1">AligningMerger</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;A merger that takes a variable font, and instantiates 
    an instance.  While there's no &quot;merging&quot; to be done per se, 
    the operation can benefit from many operations that the 
    aligning merger does.&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">font</span><span class="s3">, </span><span class="s1">instancer</span><span class="s3">, </span><span class="s1">deleteVariations</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
        <span class="s1">Merger</span><span class="s3">.</span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">font</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">instancer </span><span class="s3">= </span><span class="s1">instancer</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">deleteVariations </span><span class="s3">= </span><span class="s1">deleteVariations</span>


<span class="s3">@</span><span class="s1">MutatorMerger</span><span class="s3">.</span><span class="s1">merger</span><span class="s3">(</span><span class="s1">ot</span><span class="s3">.</span><span class="s1">CaretValue</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">merge</span><span class="s3">(</span><span class="s1">merger</span><span class="s3">, </span><span class="s1">self</span><span class="s3">, </span><span class="s1">lst</span><span class="s3">):</span>
    <span class="s5"># Hack till we become selfless.</span>
    <span class="s1">self</span><span class="s3">.</span><span class="s1">__dict__ </span><span class="s3">= </span><span class="s1">lst</span><span class="s3">[</span><span class="s6">0</span><span class="s3">].</span><span class="s1">__dict__</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>

    <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">Format </span><span class="s3">!= </span><span class="s6">3</span><span class="s3">:</span>
        <span class="s2">return</span>

    <span class="s1">instancer </span><span class="s3">= </span><span class="s1">merger</span><span class="s3">.</span><span class="s1">instancer</span>
    <span class="s1">dev </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">DeviceTable</span>
    <span class="s2">if </span><span class="s1">merger</span><span class="s3">.</span><span class="s1">deleteVariations</span><span class="s3">:</span>
        <span class="s2">del </span><span class="s1">self</span><span class="s3">.</span><span class="s1">DeviceTable</span>
    <span class="s2">if </span><span class="s1">dev</span><span class="s3">:</span>
        <span class="s2">assert </span><span class="s1">dev</span><span class="s3">.</span><span class="s1">DeltaFormat </span><span class="s3">== </span><span class="s6">0x8000</span>
        <span class="s1">varidx </span><span class="s3">= (</span><span class="s1">dev</span><span class="s3">.</span><span class="s1">StartSize </span><span class="s3">&lt;&lt; </span><span class="s6">16</span><span class="s3">) + </span><span class="s1">dev</span><span class="s3">.</span><span class="s1">EndSize</span>
        <span class="s1">delta </span><span class="s3">= </span><span class="s1">otRound</span><span class="s3">(</span><span class="s1">instancer</span><span class="s3">[</span><span class="s1">varidx</span><span class="s3">])</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">Coordinate </span><span class="s3">+= </span><span class="s1">delta</span>

    <span class="s2">if </span><span class="s1">merger</span><span class="s3">.</span><span class="s1">deleteVariations</span><span class="s3">:</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">Format </span><span class="s3">= </span><span class="s6">1</span>


<span class="s3">@</span><span class="s1">MutatorMerger</span><span class="s3">.</span><span class="s1">merger</span><span class="s3">(</span><span class="s1">ot</span><span class="s3">.</span><span class="s1">Anchor</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">merge</span><span class="s3">(</span><span class="s1">merger</span><span class="s3">, </span><span class="s1">self</span><span class="s3">, </span><span class="s1">lst</span><span class="s3">):</span>
    <span class="s5"># Hack till we become selfless.</span>
    <span class="s1">self</span><span class="s3">.</span><span class="s1">__dict__ </span><span class="s3">= </span><span class="s1">lst</span><span class="s3">[</span><span class="s6">0</span><span class="s3">].</span><span class="s1">__dict__</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>

    <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">Format </span><span class="s3">!= </span><span class="s6">3</span><span class="s3">:</span>
        <span class="s2">return</span>

    <span class="s1">instancer </span><span class="s3">= </span><span class="s1">merger</span><span class="s3">.</span><span class="s1">instancer</span>
    <span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s4">&quot;XY&quot;</span><span class="s3">:</span>
        <span class="s1">tableName </span><span class="s3">= </span><span class="s1">v </span><span class="s3">+ </span><span class="s4">&quot;DeviceTable&quot;</span>
        <span class="s2">if not </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">tableName</span><span class="s3">):</span>
            <span class="s2">continue</span>
        <span class="s1">dev </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">tableName</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">merger</span><span class="s3">.</span><span class="s1">deleteVariations</span><span class="s3">:</span>
            <span class="s1">delattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">tableName</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">dev </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s2">continue</span>

        <span class="s2">assert </span><span class="s1">dev</span><span class="s3">.</span><span class="s1">DeltaFormat </span><span class="s3">== </span><span class="s6">0x8000</span>
        <span class="s1">varidx </span><span class="s3">= (</span><span class="s1">dev</span><span class="s3">.</span><span class="s1">StartSize </span><span class="s3">&lt;&lt; </span><span class="s6">16</span><span class="s3">) + </span><span class="s1">dev</span><span class="s3">.</span><span class="s1">EndSize</span>
        <span class="s1">delta </span><span class="s3">= </span><span class="s1">otRound</span><span class="s3">(</span><span class="s1">instancer</span><span class="s3">[</span><span class="s1">varidx</span><span class="s3">])</span>

        <span class="s1">attr </span><span class="s3">= </span><span class="s1">v </span><span class="s3">+ </span><span class="s4">&quot;Coordinate&quot;</span>
        <span class="s1">setattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">attr</span><span class="s3">, </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">attr</span><span class="s3">) + </span><span class="s1">delta</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">merger</span><span class="s3">.</span><span class="s1">deleteVariations</span><span class="s3">:</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">Format </span><span class="s3">= </span><span class="s6">1</span>


<span class="s3">@</span><span class="s1">MutatorMerger</span><span class="s3">.</span><span class="s1">merger</span><span class="s3">(</span><span class="s1">otBase</span><span class="s3">.</span><span class="s1">ValueRecord</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">merge</span><span class="s3">(</span><span class="s1">merger</span><span class="s3">, </span><span class="s1">self</span><span class="s3">, </span><span class="s1">lst</span><span class="s3">):</span>
    <span class="s5"># Hack till we become selfless.</span>
    <span class="s1">self</span><span class="s3">.</span><span class="s1">__dict__ </span><span class="s3">= </span><span class="s1">lst</span><span class="s3">[</span><span class="s6">0</span><span class="s3">].</span><span class="s1">__dict__</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>

    <span class="s1">instancer </span><span class="s3">= </span><span class="s1">merger</span><span class="s3">.</span><span class="s1">instancer</span>
    <span class="s2">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">tableName </span><span class="s2">in </span><span class="s3">[</span>
        <span class="s3">(</span><span class="s4">&quot;XAdvance&quot;</span><span class="s3">, </span><span class="s4">&quot;XAdvDevice&quot;</span><span class="s3">),</span>
        <span class="s3">(</span><span class="s4">&quot;YAdvance&quot;</span><span class="s3">, </span><span class="s4">&quot;YAdvDevice&quot;</span><span class="s3">),</span>
        <span class="s3">(</span><span class="s4">&quot;XPlacement&quot;</span><span class="s3">, </span><span class="s4">&quot;XPlaDevice&quot;</span><span class="s3">),</span>
        <span class="s3">(</span><span class="s4">&quot;YPlacement&quot;</span><span class="s3">, </span><span class="s4">&quot;YPlaDevice&quot;</span><span class="s3">),</span>
    <span class="s3">]:</span>
        <span class="s2">if not </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">tableName</span><span class="s3">):</span>
            <span class="s2">continue</span>
        <span class="s1">dev </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">tableName</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">merger</span><span class="s3">.</span><span class="s1">deleteVariations</span><span class="s3">:</span>
            <span class="s1">delattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">tableName</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">dev </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s2">continue</span>

        <span class="s2">assert </span><span class="s1">dev</span><span class="s3">.</span><span class="s1">DeltaFormat </span><span class="s3">== </span><span class="s6">0x8000</span>
        <span class="s1">varidx </span><span class="s3">= (</span><span class="s1">dev</span><span class="s3">.</span><span class="s1">StartSize </span><span class="s3">&lt;&lt; </span><span class="s6">16</span><span class="s3">) + </span><span class="s1">dev</span><span class="s3">.</span><span class="s1">EndSize</span>
        <span class="s1">delta </span><span class="s3">= </span><span class="s1">otRound</span><span class="s3">(</span><span class="s1">instancer</span><span class="s3">[</span><span class="s1">varidx</span><span class="s3">])</span>

        <span class="s1">setattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s6">0</span><span class="s3">) + </span><span class="s1">delta</span><span class="s3">)</span>


<span class="s5">#</span>
<span class="s5"># VariationMerger</span>
<span class="s5">#</span>


<span class="s2">class </span><span class="s1">VariationMerger</span><span class="s3">(</span><span class="s1">AligningMerger</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;A merger that takes multiple master fonts, and builds a 
    variable font.&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">model</span><span class="s3">, </span><span class="s1">axisTags</span><span class="s3">, </span><span class="s1">font</span><span class="s3">):</span>
        <span class="s1">Merger</span><span class="s3">.</span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">font</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">store_builder </span><span class="s3">= </span><span class="s1">varStore</span><span class="s3">.</span><span class="s1">OnlineVarStoreBuilder</span><span class="s3">(</span><span class="s1">axisTags</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">setModel</span><span class="s3">(</span><span class="s1">model</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">setModel</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">model</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">model </span><span class="s3">= </span><span class="s1">model</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">store_builder</span><span class="s3">.</span><span class="s1">setModel</span><span class="s3">(</span><span class="s1">model</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">mergeThings</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">out</span><span class="s3">, </span><span class="s1">lst</span><span class="s3">):</span>
        <span class="s1">masterModel </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s1">origTTFs </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s2">if None in </span><span class="s1">lst</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">allNone</span><span class="s3">(</span><span class="s1">lst</span><span class="s3">):</span>
                <span class="s2">if </span><span class="s1">out </span><span class="s2">is not None</span><span class="s3">:</span>
                    <span class="s2">raise </span><span class="s1">FoundANone</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">got</span><span class="s3">=</span><span class="s1">lst</span><span class="s3">)</span>
                <span class="s2">return</span>

            <span class="s5"># temporarily subset the list of master ttfs to the ones for which</span>
            <span class="s5"># master values are not None</span>
            <span class="s1">origTTFs </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">ttfs</span>
            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">ttfs</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">ttfs </span><span class="s3">= </span><span class="s1">subList</span><span class="s3">([</span><span class="s1">v </span><span class="s2">is not None for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">lst</span><span class="s3">], </span><span class="s1">self</span><span class="s3">.</span><span class="s1">ttfs</span><span class="s3">)</span>

            <span class="s1">masterModel </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">model</span>
            <span class="s1">model</span><span class="s3">, </span><span class="s1">lst </span><span class="s3">= </span><span class="s1">masterModel</span><span class="s3">.</span><span class="s1">getSubModel</span><span class="s3">(</span><span class="s1">lst</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">setModel</span><span class="s3">(</span><span class="s1">model</span><span class="s3">)</span>

        <span class="s1">super</span><span class="s3">(</span><span class="s1">VariationMerger</span><span class="s3">, </span><span class="s1">self</span><span class="s3">).</span><span class="s1">mergeThings</span><span class="s3">(</span><span class="s1">out</span><span class="s3">, </span><span class="s1">lst</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">masterModel</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">setModel</span><span class="s3">(</span><span class="s1">masterModel</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">origTTFs</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">ttfs </span><span class="s3">= </span><span class="s1">origTTFs</span>


<span class="s2">def </span><span class="s1">buildVarDevTable</span><span class="s3">(</span><span class="s1">store_builder</span><span class="s3">, </span><span class="s1">master_values</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">allEqual</span><span class="s3">(</span><span class="s1">master_values</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">master_values</span><span class="s3">[</span><span class="s6">0</span><span class="s3">], </span><span class="s2">None</span>
    <span class="s1">base</span><span class="s3">, </span><span class="s1">varIdx </span><span class="s3">= </span><span class="s1">store_builder</span><span class="s3">.</span><span class="s1">storeMasters</span><span class="s3">(</span><span class="s1">master_values</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">base</span><span class="s3">, </span><span class="s1">builder</span><span class="s3">.</span><span class="s1">buildVarDevTable</span><span class="s3">(</span><span class="s1">varIdx</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">VariationMerger</span><span class="s3">.</span><span class="s1">merger</span><span class="s3">(</span><span class="s1">ot</span><span class="s3">.</span><span class="s1">BaseCoord</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">merge</span><span class="s3">(</span><span class="s1">merger</span><span class="s3">, </span><span class="s1">self</span><span class="s3">, </span><span class="s1">lst</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">Format </span><span class="s3">!= </span><span class="s6">1</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">UnsupportedFormat</span><span class="s3">(</span><span class="s1">merger</span><span class="s3">, </span><span class="s1">subtable</span><span class="s3">=</span><span class="s4">&quot;a baseline coordinate&quot;</span><span class="s3">)</span>
    <span class="s1">self</span><span class="s3">.</span><span class="s1">Coordinate</span><span class="s3">, </span><span class="s1">DeviceTable </span><span class="s3">= </span><span class="s1">buildVarDevTable</span><span class="s3">(</span>
        <span class="s1">merger</span><span class="s3">.</span><span class="s1">store_builder</span><span class="s3">, [</span><span class="s1">a</span><span class="s3">.</span><span class="s1">Coordinate </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">lst</span><span class="s3">]</span>
    <span class="s3">)</span>
    <span class="s2">if </span><span class="s1">DeviceTable</span><span class="s3">:</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">Format </span><span class="s3">= </span><span class="s6">3</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">DeviceTable </span><span class="s3">= </span><span class="s1">DeviceTable</span>


<span class="s3">@</span><span class="s1">VariationMerger</span><span class="s3">.</span><span class="s1">merger</span><span class="s3">(</span><span class="s1">ot</span><span class="s3">.</span><span class="s1">CaretValue</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">merge</span><span class="s3">(</span><span class="s1">merger</span><span class="s3">, </span><span class="s1">self</span><span class="s3">, </span><span class="s1">lst</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">Format </span><span class="s3">!= </span><span class="s6">1</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">UnsupportedFormat</span><span class="s3">(</span><span class="s1">merger</span><span class="s3">, </span><span class="s1">subtable</span><span class="s3">=</span><span class="s4">&quot;a caret&quot;</span><span class="s3">)</span>
    <span class="s1">self</span><span class="s3">.</span><span class="s1">Coordinate</span><span class="s3">, </span><span class="s1">DeviceTable </span><span class="s3">= </span><span class="s1">buildVarDevTable</span><span class="s3">(</span>
        <span class="s1">merger</span><span class="s3">.</span><span class="s1">store_builder</span><span class="s3">, [</span><span class="s1">a</span><span class="s3">.</span><span class="s1">Coordinate </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">lst</span><span class="s3">]</span>
    <span class="s3">)</span>
    <span class="s2">if </span><span class="s1">DeviceTable</span><span class="s3">:</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">Format </span><span class="s3">= </span><span class="s6">3</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">DeviceTable </span><span class="s3">= </span><span class="s1">DeviceTable</span>


<span class="s3">@</span><span class="s1">VariationMerger</span><span class="s3">.</span><span class="s1">merger</span><span class="s3">(</span><span class="s1">ot</span><span class="s3">.</span><span class="s1">Anchor</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">merge</span><span class="s3">(</span><span class="s1">merger</span><span class="s3">, </span><span class="s1">self</span><span class="s3">, </span><span class="s1">lst</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">Format </span><span class="s3">!= </span><span class="s6">1</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">UnsupportedFormat</span><span class="s3">(</span><span class="s1">merger</span><span class="s3">, </span><span class="s1">subtable</span><span class="s3">=</span><span class="s4">&quot;an anchor&quot;</span><span class="s3">)</span>
    <span class="s1">self</span><span class="s3">.</span><span class="s1">XCoordinate</span><span class="s3">, </span><span class="s1">XDeviceTable </span><span class="s3">= </span><span class="s1">buildVarDevTable</span><span class="s3">(</span>
        <span class="s1">merger</span><span class="s3">.</span><span class="s1">store_builder</span><span class="s3">, [</span><span class="s1">a</span><span class="s3">.</span><span class="s1">XCoordinate </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">lst</span><span class="s3">]</span>
    <span class="s3">)</span>
    <span class="s1">self</span><span class="s3">.</span><span class="s1">YCoordinate</span><span class="s3">, </span><span class="s1">YDeviceTable </span><span class="s3">= </span><span class="s1">buildVarDevTable</span><span class="s3">(</span>
        <span class="s1">merger</span><span class="s3">.</span><span class="s1">store_builder</span><span class="s3">, [</span><span class="s1">a</span><span class="s3">.</span><span class="s1">YCoordinate </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">lst</span><span class="s3">]</span>
    <span class="s3">)</span>
    <span class="s2">if </span><span class="s1">XDeviceTable </span><span class="s2">or </span><span class="s1">YDeviceTable</span><span class="s3">:</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">Format </span><span class="s3">= </span><span class="s6">3</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">XDeviceTable </span><span class="s3">= </span><span class="s1">XDeviceTable</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">YDeviceTable </span><span class="s3">= </span><span class="s1">YDeviceTable</span>


<span class="s3">@</span><span class="s1">VariationMerger</span><span class="s3">.</span><span class="s1">merger</span><span class="s3">(</span><span class="s1">otBase</span><span class="s3">.</span><span class="s1">ValueRecord</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">merge</span><span class="s3">(</span><span class="s1">merger</span><span class="s3">, </span><span class="s1">self</span><span class="s3">, </span><span class="s1">lst</span><span class="s3">):</span>
    <span class="s2">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">tableName </span><span class="s2">in </span><span class="s3">[</span>
        <span class="s3">(</span><span class="s4">&quot;XAdvance&quot;</span><span class="s3">, </span><span class="s4">&quot;XAdvDevice&quot;</span><span class="s3">),</span>
        <span class="s3">(</span><span class="s4">&quot;YAdvance&quot;</span><span class="s3">, </span><span class="s4">&quot;YAdvDevice&quot;</span><span class="s3">),</span>
        <span class="s3">(</span><span class="s4">&quot;XPlacement&quot;</span><span class="s3">, </span><span class="s4">&quot;XPlaDevice&quot;</span><span class="s3">),</span>
        <span class="s3">(</span><span class="s4">&quot;YPlacement&quot;</span><span class="s3">, </span><span class="s4">&quot;YPlaDevice&quot;</span><span class="s3">),</span>
    <span class="s3">]:</span>
        <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">):</span>
            <span class="s1">value</span><span class="s3">, </span><span class="s1">deviceTable </span><span class="s3">= </span><span class="s1">buildVarDevTable</span><span class="s3">(</span>
                <span class="s1">merger</span><span class="s3">.</span><span class="s1">store_builder</span><span class="s3">, [</span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s6">0</span><span class="s3">) </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">lst</span><span class="s3">]</span>
            <span class="s3">)</span>
            <span class="s1">setattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">value</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">deviceTable</span><span class="s3">:</span>
                <span class="s1">setattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">tableName</span><span class="s3">, </span><span class="s1">deviceTable</span><span class="s3">)</span>


<span class="s2">class </span><span class="s1">COLRVariationMerger</span><span class="s3">(</span><span class="s1">VariationMerger</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;A specialized VariationMerger that takes multiple master fonts containing 
    COLRv1 tables, and builds a variable COLR font. 
 
    COLR tables are special in that variable subtables can be associated with 
    multiple delta-set indices (via VarIndexBase). 
    They also contain tables that must change their type (not simply the Format) 
    as they become variable (e.g. Affine2x3 -&gt; VarAffine2x3) so this merger takes 
    care of that too. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">model</span><span class="s3">, </span><span class="s1">axisTags</span><span class="s3">, </span><span class="s1">font</span><span class="s3">, </span><span class="s1">allowLayerReuse</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
        <span class="s1">VariationMerger</span><span class="s3">.</span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">model</span><span class="s3">, </span><span class="s1">axisTags</span><span class="s3">, </span><span class="s1">font</span><span class="s3">)</span>
        <span class="s5"># maps {tuple(varIdxes): VarIndexBase} to facilitate reuse of VarIndexBase</span>
        <span class="s5"># between variable tables with same varIdxes.</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">varIndexCache </span><span class="s3">= {}</span>
        <span class="s5"># flat list of all the varIdxes generated while merging</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">varIdxes </span><span class="s3">= []</span>
        <span class="s5"># set of id()s of the subtables that contain variations after merging</span>
        <span class="s5"># and need to be upgraded to the associated VarType.</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">varTableIds </span><span class="s3">= </span><span class="s1">set</span><span class="s3">()</span>
        <span class="s5"># we keep these around for rebuilding a LayerList while merging PaintColrLayers</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">layers </span><span class="s3">= []</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">layerReuseCache </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s2">if </span><span class="s1">allowLayerReuse</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">layerReuseCache </span><span class="s3">= </span><span class="s1">LayerReuseCache</span><span class="s3">()</span>
        <span class="s5"># flag to ensure BaseGlyphList is fully merged before LayerList gets processed</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_doneBaseGlyphs </span><span class="s3">= </span><span class="s2">False</span>

    <span class="s2">def </span><span class="s1">mergeTables</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">font</span><span class="s3">, </span><span class="s1">master_ttfs</span><span class="s3">, </span><span class="s1">tableTags</span><span class="s3">=(</span><span class="s4">&quot;COLR&quot;</span><span class="s3">,)):</span>
        <span class="s2">if </span><span class="s4">&quot;COLR&quot; </span><span class="s2">in </span><span class="s1">tableTags </span><span class="s2">and </span><span class="s4">&quot;COLR&quot; </span><span class="s2">in </span><span class="s1">font</span><span class="s3">:</span>
            <span class="s5"># The merger modifies the destination COLR table in-place. If this contains</span>
            <span class="s5"># multiple PaintColrLayers referencing the same layers from LayerList, it's</span>
            <span class="s5"># a problem because we may risk modifying the same paint more than once, or</span>
            <span class="s5"># worse, fail while attempting to do that.</span>
            <span class="s5"># We don't know whether the master COLR table was built with layer reuse</span>
            <span class="s5"># disabled, thus to be safe we rebuild its LayerList so that it contains only</span>
            <span class="s5"># unique layers referenced from non-overlapping PaintColrLayers throughout</span>
            <span class="s5"># the base paint graphs.</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">expandPaintColrLayers</span><span class="s3">(</span><span class="s1">font</span><span class="s3">[</span><span class="s4">&quot;COLR&quot;</span><span class="s3">].</span><span class="s1">table</span><span class="s3">)</span>
        <span class="s1">VariationMerger</span><span class="s3">.</span><span class="s1">mergeTables</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">font</span><span class="s3">, </span><span class="s1">master_ttfs</span><span class="s3">, </span><span class="s1">tableTags</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">checkFormatEnum</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">out</span><span class="s3">, </span><span class="s1">lst</span><span class="s3">, </span><span class="s1">validate</span><span class="s3">=</span><span class="s2">lambda </span><span class="s1">_</span><span class="s3">: </span><span class="s2">True</span><span class="s3">):</span>
        <span class="s1">fmt </span><span class="s3">= </span><span class="s1">out</span><span class="s3">.</span><span class="s1">Format</span>
        <span class="s1">formatEnum </span><span class="s3">= </span><span class="s1">out</span><span class="s3">.</span><span class="s1">formatEnum</span>
        <span class="s1">ok </span><span class="s3">= </span><span class="s2">False</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s1">fmt </span><span class="s3">= </span><span class="s1">formatEnum</span><span class="s3">(</span><span class="s1">fmt</span><span class="s3">)</span>
        <span class="s2">except </span><span class="s1">ValueError</span><span class="s3">:</span>
            <span class="s2">pass</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">ok </span><span class="s3">= </span><span class="s1">validate</span><span class="s3">(</span><span class="s1">fmt</span><span class="s3">)</span>
        <span class="s2">if not </span><span class="s1">ok</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">UnsupportedFormat</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">subtable</span><span class="s3">=</span><span class="s1">type</span><span class="s3">(</span><span class="s1">out</span><span class="s3">).</span><span class="s1">__name__</span><span class="s3">, </span><span class="s1">value</span><span class="s3">=</span><span class="s1">fmt</span><span class="s3">)</span>
        <span class="s1">expected </span><span class="s3">= </span><span class="s1">fmt</span>
        <span class="s1">got </span><span class="s3">= []</span>
        <span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">lst</span><span class="s3">:</span>
            <span class="s1">fmt </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">v</span><span class="s3">, </span><span class="s4">&quot;Format&quot;</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
            <span class="s2">try</span><span class="s3">:</span>
                <span class="s1">fmt </span><span class="s3">= </span><span class="s1">formatEnum</span><span class="s3">(</span><span class="s1">fmt</span><span class="s3">)</span>
            <span class="s2">except </span><span class="s1">ValueError</span><span class="s3">:</span>
                <span class="s2">pass</span>
            <span class="s1">got</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">fmt</span><span class="s3">)</span>
        <span class="s2">if not </span><span class="s1">allEqualTo</span><span class="s3">(</span><span class="s1">expected</span><span class="s3">, </span><span class="s1">got</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">InconsistentFormats</span><span class="s3">(</span>
                <span class="s1">self</span><span class="s3">,</span>
                <span class="s1">subtable</span><span class="s3">=</span><span class="s1">type</span><span class="s3">(</span><span class="s1">out</span><span class="s3">).</span><span class="s1">__name__</span><span class="s3">,</span>
                <span class="s1">expected</span><span class="s3">=</span><span class="s1">expected</span><span class="s3">,</span>
                <span class="s1">got</span><span class="s3">=</span><span class="s1">got</span><span class="s3">,</span>
            <span class="s3">)</span>
        <span class="s2">return </span><span class="s1">expected</span>

    <span class="s2">def </span><span class="s1">mergeSparseDict</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">out</span><span class="s3">, </span><span class="s1">lst</span><span class="s3">):</span>
        <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">out</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">():</span>
            <span class="s2">try</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">mergeThings</span><span class="s3">(</span><span class="s1">out</span><span class="s3">[</span><span class="s1">k</span><span class="s3">], [</span><span class="s1">v</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">k</span><span class="s3">) </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">lst</span><span class="s3">])</span>
            <span class="s2">except </span><span class="s1">VarLibMergeError </span><span class="s2">as </span><span class="s1">e</span><span class="s3">:</span>
                <span class="s1">e</span><span class="s3">.</span><span class="s1">stack</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s4">f&quot;[</span><span class="s2">{</span><span class="s1">k</span><span class="s2">!r}</span><span class="s4">]&quot;</span><span class="s3">)</span>
                <span class="s2">raise</span>

    <span class="s2">def </span><span class="s1">mergeAttrs</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">out</span><span class="s3">, </span><span class="s1">lst</span><span class="s3">, </span><span class="s1">attrs</span><span class="s3">):</span>
        <span class="s2">for </span><span class="s1">attr </span><span class="s2">in </span><span class="s1">attrs</span><span class="s3">:</span>
            <span class="s1">value </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">out</span><span class="s3">, </span><span class="s1">attr</span><span class="s3">)</span>
            <span class="s1">values </span><span class="s3">= [</span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">item</span><span class="s3">, </span><span class="s1">attr</span><span class="s3">) </span><span class="s2">for </span><span class="s1">item </span><span class="s2">in </span><span class="s1">lst</span><span class="s3">]</span>
            <span class="s2">try</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">mergeThings</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">values</span><span class="s3">)</span>
            <span class="s2">except </span><span class="s1">VarLibMergeError </span><span class="s2">as </span><span class="s1">e</span><span class="s3">:</span>
                <span class="s1">e</span><span class="s3">.</span><span class="s1">stack</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s4">f&quot;.</span><span class="s2">{</span><span class="s1">attr</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s3">)</span>
                <span class="s2">raise</span>

    <span class="s2">def </span><span class="s1">storeMastersForAttr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">out</span><span class="s3">, </span><span class="s1">lst</span><span class="s3">, </span><span class="s1">attr</span><span class="s3">):</span>
        <span class="s1">master_values </span><span class="s3">= [</span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">item</span><span class="s3">, </span><span class="s1">attr</span><span class="s3">) </span><span class="s2">for </span><span class="s1">item </span><span class="s2">in </span><span class="s1">lst</span><span class="s3">]</span>

        <span class="s5"># VarStore treats deltas for fixed-size floats as integers, so we</span>
        <span class="s5"># must convert master values to int before storing them in the builder</span>
        <span class="s5"># then back to float.</span>
        <span class="s1">is_fixed_size_float </span><span class="s3">= </span><span class="s2">False</span>
        <span class="s1">conv </span><span class="s3">= </span><span class="s1">out</span><span class="s3">.</span><span class="s1">getConverterByName</span><span class="s3">(</span><span class="s1">attr</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">conv</span><span class="s3">, </span><span class="s1">BaseFixedValue</span><span class="s3">):</span>
            <span class="s1">is_fixed_size_float </span><span class="s3">= </span><span class="s2">True</span>
            <span class="s1">master_values </span><span class="s3">= [</span><span class="s1">conv</span><span class="s3">.</span><span class="s1">toInt</span><span class="s3">(</span><span class="s1">v</span><span class="s3">) </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">master_values</span><span class="s3">]</span>

        <span class="s1">baseValue </span><span class="s3">= </span><span class="s1">master_values</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]</span>
        <span class="s1">varIdx </span><span class="s3">= </span><span class="s1">ot</span><span class="s3">.</span><span class="s1">NO_VARIATION_INDEX</span>
        <span class="s2">if not </span><span class="s1">allEqual</span><span class="s3">(</span><span class="s1">master_values</span><span class="s3">):</span>
            <span class="s1">baseValue</span><span class="s3">, </span><span class="s1">varIdx </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">store_builder</span><span class="s3">.</span><span class="s1">storeMasters</span><span class="s3">(</span><span class="s1">master_values</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">is_fixed_size_float</span><span class="s3">:</span>
            <span class="s1">baseValue </span><span class="s3">= </span><span class="s1">conv</span><span class="s3">.</span><span class="s1">fromInt</span><span class="s3">(</span><span class="s1">baseValue</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">baseValue</span><span class="s3">, </span><span class="s1">varIdx</span>

    <span class="s2">def </span><span class="s1">storeVariationIndices</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">varIdxes</span><span class="s3">) </span><span class="s1">-&gt; int</span><span class="s3">:</span>
        <span class="s5"># try to reuse an existing VarIndexBase for the same varIdxes, or else</span>
        <span class="s5"># create a new one</span>
        <span class="s1">key </span><span class="s3">= </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">varIdxes</span><span class="s3">)</span>
        <span class="s1">varIndexBase </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">varIndexCache</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">key</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">varIndexBase </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s5"># scan for a full match anywhere in the self.varIdxes</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">varIdxes</span><span class="s3">) - </span><span class="s1">len</span><span class="s3">(</span><span class="s1">varIdxes</span><span class="s3">) + </span><span class="s6">1</span><span class="s3">):</span>
                <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">varIdxes</span><span class="s3">[</span><span class="s1">i </span><span class="s3">: </span><span class="s1">i </span><span class="s3">+ </span><span class="s1">len</span><span class="s3">(</span><span class="s1">varIdxes</span><span class="s3">)] == </span><span class="s1">varIdxes</span><span class="s3">:</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">varIndexCache</span><span class="s3">[</span><span class="s1">key</span><span class="s3">] = </span><span class="s1">varIndexBase </span><span class="s3">= </span><span class="s1">i</span>
                    <span class="s2">break</span>

        <span class="s2">if </span><span class="s1">varIndexBase </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s5"># try find a partial match at the end of the self.varIdxes</span>
            <span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">varIdxes</span><span class="s3">) - </span><span class="s6">1</span><span class="s3">, </span><span class="s6">0</span><span class="s3">, -</span><span class="s6">1</span><span class="s3">):</span>
                <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">varIdxes</span><span class="s3">[-</span><span class="s1">n</span><span class="s3">:] == </span><span class="s1">varIdxes</span><span class="s3">[:</span><span class="s1">n</span><span class="s3">]:</span>
                    <span class="s1">varIndexBase </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">varIdxes</span><span class="s3">) - </span><span class="s1">n</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">varIndexCache</span><span class="s3">[</span><span class="s1">key</span><span class="s3">] = </span><span class="s1">varIndexBase</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">varIdxes</span><span class="s3">.</span><span class="s1">extend</span><span class="s3">(</span><span class="s1">varIdxes</span><span class="s3">[</span><span class="s1">n</span><span class="s3">:])</span>
                    <span class="s2">break</span>

        <span class="s2">if </span><span class="s1">varIndexBase </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s5"># no match found, append at the end</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">varIndexCache</span><span class="s3">[</span><span class="s1">key</span><span class="s3">] = </span><span class="s1">varIndexBase </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">varIdxes</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">varIdxes</span><span class="s3">.</span><span class="s1">extend</span><span class="s3">(</span><span class="s1">varIdxes</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">varIndexBase</span>

    <span class="s2">def </span><span class="s1">mergeVariableAttrs</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">out</span><span class="s3">, </span><span class="s1">lst</span><span class="s3">, </span><span class="s1">attrs</span><span class="s3">) </span><span class="s1">-&gt; int</span><span class="s3">:</span>
        <span class="s1">varIndexBase </span><span class="s3">= </span><span class="s1">ot</span><span class="s3">.</span><span class="s1">NO_VARIATION_INDEX</span>
        <span class="s1">varIdxes </span><span class="s3">= []</span>
        <span class="s2">for </span><span class="s1">attr </span><span class="s2">in </span><span class="s1">attrs</span><span class="s3">:</span>
            <span class="s1">baseValue</span><span class="s3">, </span><span class="s1">varIdx </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">storeMastersForAttr</span><span class="s3">(</span><span class="s1">out</span><span class="s3">, </span><span class="s1">lst</span><span class="s3">, </span><span class="s1">attr</span><span class="s3">)</span>
            <span class="s1">setattr</span><span class="s3">(</span><span class="s1">out</span><span class="s3">, </span><span class="s1">attr</span><span class="s3">, </span><span class="s1">baseValue</span><span class="s3">)</span>
            <span class="s1">varIdxes</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">varIdx</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">any</span><span class="s3">(</span><span class="s1">v </span><span class="s3">!= </span><span class="s1">ot</span><span class="s3">.</span><span class="s1">NO_VARIATION_INDEX </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">varIdxes</span><span class="s3">):</span>
            <span class="s1">varIndexBase </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">storeVariationIndices</span><span class="s3">(</span><span class="s1">varIdxes</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">varIndexBase</span>

    <span class="s3">@</span><span class="s1">classmethod</span>
    <span class="s2">def </span><span class="s1">convertSubTablesToVarType</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, </span><span class="s1">table</span><span class="s3">):</span>
        <span class="s2">for </span><span class="s1">path </span><span class="s2">in </span><span class="s1">dfs_base_table</span><span class="s3">(</span>
            <span class="s1">table</span><span class="s3">,</span>
            <span class="s1">skip_root</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
            <span class="s1">predicate</span><span class="s3">=</span><span class="s2">lambda </span><span class="s1">path</span><span class="s3">: (</span>
                <span class="s1">getattr</span><span class="s3">(</span><span class="s1">type</span><span class="s3">(</span><span class="s1">path</span><span class="s3">[-</span><span class="s6">1</span><span class="s3">].</span><span class="s1">value</span><span class="s3">), </span><span class="s4">&quot;VarType&quot;</span><span class="s3">, </span><span class="s2">None</span><span class="s3">) </span><span class="s2">is not None</span>
            <span class="s3">),</span>
        <span class="s3">):</span>
            <span class="s1">st </span><span class="s3">= </span><span class="s1">path</span><span class="s3">[-</span><span class="s6">1</span><span class="s3">]</span>
            <span class="s1">subTable </span><span class="s3">= </span><span class="s1">st</span><span class="s3">.</span><span class="s1">value</span>
            <span class="s1">varType </span><span class="s3">= </span><span class="s1">type</span><span class="s3">(</span><span class="s1">subTable</span><span class="s3">).</span><span class="s1">VarType</span>
            <span class="s1">newSubTable </span><span class="s3">= </span><span class="s1">varType</span><span class="s3">()</span>
            <span class="s1">newSubTable</span><span class="s3">.</span><span class="s1">__dict__</span><span class="s3">.</span><span class="s1">update</span><span class="s3">(</span><span class="s1">subTable</span><span class="s3">.</span><span class="s1">__dict__</span><span class="s3">)</span>
            <span class="s1">newSubTable</span><span class="s3">.</span><span class="s1">populateDefaults</span><span class="s3">()</span>
            <span class="s1">parent </span><span class="s3">= </span><span class="s1">path</span><span class="s3">[-</span><span class="s6">2</span><span class="s3">].</span><span class="s1">value</span>
            <span class="s2">if </span><span class="s1">st</span><span class="s3">.</span><span class="s1">index </span><span class="s2">is not None</span><span class="s3">:</span>
                <span class="s1">getattr</span><span class="s3">(</span><span class="s1">parent</span><span class="s3">, </span><span class="s1">st</span><span class="s3">.</span><span class="s1">name</span><span class="s3">)[</span><span class="s1">st</span><span class="s3">.</span><span class="s1">index</span><span class="s3">] = </span><span class="s1">newSubTable</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">setattr</span><span class="s3">(</span><span class="s1">parent</span><span class="s3">, </span><span class="s1">st</span><span class="s3">.</span><span class="s1">name</span><span class="s3">, </span><span class="s1">newSubTable</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">staticmethod</span>
    <span class="s2">def </span><span class="s1">expandPaintColrLayers</span><span class="s3">(</span><span class="s1">colr</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Rebuild LayerList without PaintColrLayers reuse. 
 
        Each base paint graph is fully DFS-traversed (with exception of PaintColrGlyph 
        which are irrelevant for this); any layers referenced via PaintColrLayers are 
        collected into a new LayerList and duplicated when reuse is detected, to ensure 
        that all paints are distinct objects at the end of the process. 
        PaintColrLayers's FirstLayerIndex/NumLayers are updated so that no overlap 
        is left. Also, any consecutively nested PaintColrLayers are flattened. 
        The COLR table's LayerList is replaced with the new unique layers. 
        A side effect is also that any layer from the old LayerList which is not 
        referenced by any PaintColrLayers is dropped. 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">colr</span><span class="s3">.</span><span class="s1">LayerList</span><span class="s3">:</span>
            <span class="s5"># if no LayerList, there's nothing to expand</span>
            <span class="s2">return</span>
        <span class="s1">uniqueLayerIDs </span><span class="s3">= </span><span class="s1">set</span><span class="s3">()</span>
        <span class="s1">newLayerList </span><span class="s3">= []</span>
        <span class="s2">for </span><span class="s1">rec </span><span class="s2">in </span><span class="s1">colr</span><span class="s3">.</span><span class="s1">BaseGlyphList</span><span class="s3">.</span><span class="s1">BaseGlyphPaintRecord</span><span class="s3">:</span>
            <span class="s1">frontier </span><span class="s3">= [</span><span class="s1">rec</span><span class="s3">.</span><span class="s1">Paint</span><span class="s3">]</span>
            <span class="s2">while </span><span class="s1">frontier</span><span class="s3">:</span>
                <span class="s1">paint </span><span class="s3">= </span><span class="s1">frontier</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">()</span>
                <span class="s2">if </span><span class="s1">paint</span><span class="s3">.</span><span class="s1">Format </span><span class="s3">== </span><span class="s1">ot</span><span class="s3">.</span><span class="s1">PaintFormat</span><span class="s3">.</span><span class="s1">PaintColrGlyph</span><span class="s3">:</span>
                    <span class="s5"># don't traverse these, we treat them as constant for merging</span>
                    <span class="s2">continue</span>
                <span class="s2">elif </span><span class="s1">paint</span><span class="s3">.</span><span class="s1">Format </span><span class="s3">== </span><span class="s1">ot</span><span class="s3">.</span><span class="s1">PaintFormat</span><span class="s3">.</span><span class="s1">PaintColrLayers</span><span class="s3">:</span>
                    <span class="s5"># de-treeify any nested PaintColrLayers, append unique copies to</span>
                    <span class="s5"># the new layer list and update PaintColrLayers index/count</span>
                    <span class="s1">children </span><span class="s3">= </span><span class="s1">list</span><span class="s3">(</span><span class="s1">_flatten_layers</span><span class="s3">(</span><span class="s1">paint</span><span class="s3">, </span><span class="s1">colr</span><span class="s3">))</span>
                    <span class="s1">first_layer_index </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">newLayerList</span><span class="s3">)</span>
                    <span class="s2">for </span><span class="s1">layer </span><span class="s2">in </span><span class="s1">children</span><span class="s3">:</span>
                        <span class="s2">if </span><span class="s1">id</span><span class="s3">(</span><span class="s1">layer</span><span class="s3">) </span><span class="s2">in </span><span class="s1">uniqueLayerIDs</span><span class="s3">:</span>
                            <span class="s1">layer </span><span class="s3">= </span><span class="s1">copy</span><span class="s3">.</span><span class="s1">deepcopy</span><span class="s3">(</span><span class="s1">layer</span><span class="s3">)</span>
                            <span class="s2">assert </span><span class="s1">id</span><span class="s3">(</span><span class="s1">layer</span><span class="s3">) </span><span class="s2">not in </span><span class="s1">uniqueLayerIDs</span>
                        <span class="s1">newLayerList</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">layer</span><span class="s3">)</span>
                        <span class="s1">uniqueLayerIDs</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">id</span><span class="s3">(</span><span class="s1">layer</span><span class="s3">))</span>
                    <span class="s1">paint</span><span class="s3">.</span><span class="s1">FirstLayerIndex </span><span class="s3">= </span><span class="s1">first_layer_index</span>
                    <span class="s1">paint</span><span class="s3">.</span><span class="s1">NumLayers </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">children</span><span class="s3">)</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">children </span><span class="s3">= </span><span class="s1">paint</span><span class="s3">.</span><span class="s1">getChildren</span><span class="s3">(</span><span class="s1">colr</span><span class="s3">)</span>
                <span class="s1">frontier</span><span class="s3">.</span><span class="s1">extend</span><span class="s3">(</span><span class="s1">reversed</span><span class="s3">(</span><span class="s1">children</span><span class="s3">))</span>
        <span class="s5"># sanity check all the new layers are distinct objects</span>
        <span class="s2">assert </span><span class="s1">len</span><span class="s3">(</span><span class="s1">newLayerList</span><span class="s3">) == </span><span class="s1">len</span><span class="s3">(</span><span class="s1">uniqueLayerIDs</span><span class="s3">)</span>
        <span class="s1">colr</span><span class="s3">.</span><span class="s1">LayerList</span><span class="s3">.</span><span class="s1">Paint </span><span class="s3">= </span><span class="s1">newLayerList</span>
        <span class="s1">colr</span><span class="s3">.</span><span class="s1">LayerList</span><span class="s3">.</span><span class="s1">LayerCount </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">newLayerList</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">COLRVariationMerger</span><span class="s3">.</span><span class="s1">merger</span><span class="s3">(</span><span class="s1">ot</span><span class="s3">.</span><span class="s1">BaseGlyphList</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">merge</span><span class="s3">(</span><span class="s1">merger</span><span class="s3">, </span><span class="s1">self</span><span class="s3">, </span><span class="s1">lst</span><span class="s3">):</span>
    <span class="s5"># ignore BaseGlyphCount, allow sparse glyph sets across masters</span>
    <span class="s1">out </span><span class="s3">= {</span><span class="s1">rec</span><span class="s3">.</span><span class="s1">BaseGlyph</span><span class="s3">: </span><span class="s1">rec </span><span class="s2">for </span><span class="s1">rec </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">BaseGlyphPaintRecord</span><span class="s3">}</span>
    <span class="s1">masters </span><span class="s3">= [{</span><span class="s1">rec</span><span class="s3">.</span><span class="s1">BaseGlyph</span><span class="s3">: </span><span class="s1">rec </span><span class="s2">for </span><span class="s1">rec </span><span class="s2">in </span><span class="s1">m</span><span class="s3">.</span><span class="s1">BaseGlyphPaintRecord</span><span class="s3">} </span><span class="s2">for </span><span class="s1">m </span><span class="s2">in </span><span class="s1">lst</span><span class="s3">]</span>

    <span class="s2">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">g </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">out</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">()):</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s5"># missing base glyphs don't participate in the merge</span>
            <span class="s1">merger</span><span class="s3">.</span><span class="s1">mergeThings</span><span class="s3">(</span><span class="s1">out</span><span class="s3">[</span><span class="s1">g</span><span class="s3">], [</span><span class="s1">v</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">g</span><span class="s3">) </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">masters</span><span class="s3">])</span>
        <span class="s2">except </span><span class="s1">VarLibMergeError </span><span class="s2">as </span><span class="s1">e</span><span class="s3">:</span>
            <span class="s1">e</span><span class="s3">.</span><span class="s1">stack</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s4">f&quot;.BaseGlyphPaintRecord[</span><span class="s2">{</span><span class="s1">i</span><span class="s2">}</span><span class="s4">]&quot;</span><span class="s3">)</span>
            <span class="s1">e</span><span class="s3">.</span><span class="s1">cause</span><span class="s3">[</span><span class="s4">&quot;location&quot;</span><span class="s3">] = </span><span class="s4">f&quot;base glyph </span><span class="s2">{</span><span class="s1">g</span><span class="s2">!r}</span><span class="s4">&quot;</span>
            <span class="s2">raise</span>

    <span class="s1">merger</span><span class="s3">.</span><span class="s1">_doneBaseGlyphs </span><span class="s3">= </span><span class="s2">True</span>


<span class="s3">@</span><span class="s1">COLRVariationMerger</span><span class="s3">.</span><span class="s1">merger</span><span class="s3">(</span><span class="s1">ot</span><span class="s3">.</span><span class="s1">LayerList</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">merge</span><span class="s3">(</span><span class="s1">merger</span><span class="s3">, </span><span class="s1">self</span><span class="s3">, </span><span class="s1">lst</span><span class="s3">):</span>
    <span class="s5"># nothing to merge for LayerList, assuming we have already merged all PaintColrLayers</span>
    <span class="s5"># found while traversing the paint graphs rooted at BaseGlyphPaintRecords.</span>
    <span class="s2">assert </span><span class="s1">merger</span><span class="s3">.</span><span class="s1">_doneBaseGlyphs</span><span class="s3">, </span><span class="s4">&quot;BaseGlyphList must be merged before LayerList&quot;</span>
    <span class="s5"># Simply flush the final list of layers and go home.</span>
    <span class="s1">self</span><span class="s3">.</span><span class="s1">LayerCount </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">merger</span><span class="s3">.</span><span class="s1">layers</span><span class="s3">)</span>
    <span class="s1">self</span><span class="s3">.</span><span class="s1">Paint </span><span class="s3">= </span><span class="s1">merger</span><span class="s3">.</span><span class="s1">layers</span>


<span class="s2">def </span><span class="s1">_flatten_layers</span><span class="s3">(</span><span class="s1">root</span><span class="s3">, </span><span class="s1">colr</span><span class="s3">):</span>
    <span class="s2">assert </span><span class="s1">root</span><span class="s3">.</span><span class="s1">Format </span><span class="s3">== </span><span class="s1">ot</span><span class="s3">.</span><span class="s1">PaintFormat</span><span class="s3">.</span><span class="s1">PaintColrLayers</span>
    <span class="s2">for </span><span class="s1">paint </span><span class="s2">in </span><span class="s1">root</span><span class="s3">.</span><span class="s1">getChildren</span><span class="s3">(</span><span class="s1">colr</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">paint</span><span class="s3">.</span><span class="s1">Format </span><span class="s3">== </span><span class="s1">ot</span><span class="s3">.</span><span class="s1">PaintFormat</span><span class="s3">.</span><span class="s1">PaintColrLayers</span><span class="s3">:</span>
            <span class="s2">yield from </span><span class="s1">_flatten_layers</span><span class="s3">(</span><span class="s1">paint</span><span class="s3">, </span><span class="s1">colr</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">yield </span><span class="s1">paint</span>


<span class="s2">def </span><span class="s1">_merge_PaintColrLayers</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">out</span><span class="s3">, </span><span class="s1">lst</span><span class="s3">):</span>
    <span class="s5"># we only enforce that the (flat) number of layers is the same across all masters</span>
    <span class="s5"># but we allow FirstLayerIndex to differ to acommodate for sparse glyph sets.</span>

    <span class="s1">out_layers </span><span class="s3">= </span><span class="s1">list</span><span class="s3">(</span><span class="s1">_flatten_layers</span><span class="s3">(</span><span class="s1">out</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">font</span><span class="s3">[</span><span class="s4">&quot;COLR&quot;</span><span class="s3">].</span><span class="s1">table</span><span class="s3">))</span>

    <span class="s5"># sanity check ttfs are subset to current values (see VariationMerger.mergeThings)</span>
    <span class="s5"># before matching each master PaintColrLayers to its respective COLR by position</span>
    <span class="s2">assert </span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">ttfs</span><span class="s3">) == </span><span class="s1">len</span><span class="s3">(</span><span class="s1">lst</span><span class="s3">)</span>
    <span class="s1">master_layerses </span><span class="s3">= [</span>
        <span class="s1">list</span><span class="s3">(</span><span class="s1">_flatten_layers</span><span class="s3">(</span><span class="s1">lst</span><span class="s3">[</span><span class="s1">i</span><span class="s3">], </span><span class="s1">self</span><span class="s3">.</span><span class="s1">ttfs</span><span class="s3">[</span><span class="s1">i</span><span class="s3">][</span><span class="s4">&quot;COLR&quot;</span><span class="s3">].</span><span class="s1">table</span><span class="s3">))</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">lst</span><span class="s3">))</span>
    <span class="s3">]</span>

    <span class="s2">try</span><span class="s3">:</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">mergeLists</span><span class="s3">(</span><span class="s1">out_layers</span><span class="s3">, </span><span class="s1">master_layerses</span><span class="s3">)</span>
    <span class="s2">except </span><span class="s1">VarLibMergeError </span><span class="s2">as </span><span class="s1">e</span><span class="s3">:</span>
        <span class="s5"># NOTE: This attribute doesn't actually exist in PaintColrLayers but it's</span>
        <span class="s5"># handy to have it in the stack trace for debugging.</span>
        <span class="s1">e</span><span class="s3">.</span><span class="s1">stack</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s4">&quot;.Layers&quot;</span><span class="s3">)</span>
        <span class="s2">raise</span>

    <span class="s5"># following block is very similar to LayerListBuilder._beforeBuildPaintColrLayers</span>
    <span class="s5"># but I couldn't find a nice way to share the code between the two...</span>

    <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">layerReuseCache </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s5"># successful reuse can make the list smaller</span>
        <span class="s1">out_layers </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">layerReuseCache</span><span class="s3">.</span><span class="s1">try_reuse</span><span class="s3">(</span><span class="s1">out_layers</span><span class="s3">)</span>

    <span class="s5"># if the list is still too big we need to tree-fy it</span>
    <span class="s1">is_tree </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">out_layers</span><span class="s3">) &gt; </span><span class="s1">MAX_PAINT_COLR_LAYER_COUNT</span>
    <span class="s1">out_layers </span><span class="s3">= </span><span class="s1">build_n_ary_tree</span><span class="s3">(</span><span class="s1">out_layers</span><span class="s3">, </span><span class="s1">n</span><span class="s3">=</span><span class="s1">MAX_PAINT_COLR_LAYER_COUNT</span><span class="s3">)</span>

    <span class="s5"># We now have a tree of sequences with Paint leaves.</span>
    <span class="s5"># Convert the sequences into PaintColrLayers.</span>
    <span class="s2">def </span><span class="s1">listToColrLayers</span><span class="s3">(</span><span class="s1">paint</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">paint</span><span class="s3">, </span><span class="s1">list</span><span class="s3">):</span>
            <span class="s1">layers </span><span class="s3">= [</span><span class="s1">listToColrLayers</span><span class="s3">(</span><span class="s1">l</span><span class="s3">) </span><span class="s2">for </span><span class="s1">l </span><span class="s2">in </span><span class="s1">paint</span><span class="s3">]</span>
            <span class="s1">paint </span><span class="s3">= </span><span class="s1">ot</span><span class="s3">.</span><span class="s1">Paint</span><span class="s3">()</span>
            <span class="s1">paint</span><span class="s3">.</span><span class="s1">Format </span><span class="s3">= </span><span class="s1">int</span><span class="s3">(</span><span class="s1">ot</span><span class="s3">.</span><span class="s1">PaintFormat</span><span class="s3">.</span><span class="s1">PaintColrLayers</span><span class="s3">)</span>
            <span class="s1">paint</span><span class="s3">.</span><span class="s1">NumLayers </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">layers</span><span class="s3">)</span>
            <span class="s1">paint</span><span class="s3">.</span><span class="s1">FirstLayerIndex </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">layers</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">layers</span><span class="s3">.</span><span class="s1">extend</span><span class="s3">(</span><span class="s1">layers</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">layerReuseCache </span><span class="s2">is not None</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">layerReuseCache</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">layers</span><span class="s3">, </span><span class="s1">paint</span><span class="s3">.</span><span class="s1">FirstLayerIndex</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">paint</span>

    <span class="s1">out_layers </span><span class="s3">= [</span><span class="s1">listToColrLayers</span><span class="s3">(</span><span class="s1">l</span><span class="s3">) </span><span class="s2">for </span><span class="s1">l </span><span class="s2">in </span><span class="s1">out_layers</span><span class="s3">]</span>

    <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">out_layers</span><span class="s3">) == </span><span class="s6">1 </span><span class="s2">and </span><span class="s1">out_layers</span><span class="s3">[</span><span class="s6">0</span><span class="s3">].</span><span class="s1">Format </span><span class="s3">== </span><span class="s1">ot</span><span class="s3">.</span><span class="s1">PaintFormat</span><span class="s3">.</span><span class="s1">PaintColrLayers</span><span class="s3">:</span>
        <span class="s5"># special case when the reuse cache finds a single perfect PaintColrLayers match</span>
        <span class="s5"># (it can only come from a successful reuse, _flatten_layers has gotten rid of</span>
        <span class="s5"># all nested PaintColrLayers already); we assign it directly and avoid creating</span>
        <span class="s5"># an extra table</span>
        <span class="s1">out</span><span class="s3">.</span><span class="s1">NumLayers </span><span class="s3">= </span><span class="s1">out_layers</span><span class="s3">[</span><span class="s6">0</span><span class="s3">].</span><span class="s1">NumLayers</span>
        <span class="s1">out</span><span class="s3">.</span><span class="s1">FirstLayerIndex </span><span class="s3">= </span><span class="s1">out_layers</span><span class="s3">[</span><span class="s6">0</span><span class="s3">].</span><span class="s1">FirstLayerIndex</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">out</span><span class="s3">.</span><span class="s1">NumLayers </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">out_layers</span><span class="s3">)</span>
        <span class="s1">out</span><span class="s3">.</span><span class="s1">FirstLayerIndex </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">layers</span><span class="s3">)</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">layers</span><span class="s3">.</span><span class="s1">extend</span><span class="s3">(</span><span class="s1">out_layers</span><span class="s3">)</span>

        <span class="s5"># Register our parts for reuse provided we aren't a tree</span>
        <span class="s5"># If we are a tree the leaves registered for reuse and that will suffice</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">layerReuseCache </span><span class="s2">is not None and not </span><span class="s1">is_tree</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">layerReuseCache</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">out_layers</span><span class="s3">, </span><span class="s1">out</span><span class="s3">.</span><span class="s1">FirstLayerIndex</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">COLRVariationMerger</span><span class="s3">.</span><span class="s1">merger</span><span class="s3">((</span><span class="s1">ot</span><span class="s3">.</span><span class="s1">Paint</span><span class="s3">, </span><span class="s1">ot</span><span class="s3">.</span><span class="s1">ClipBox</span><span class="s3">))</span>
<span class="s2">def </span><span class="s1">merge</span><span class="s3">(</span><span class="s1">merger</span><span class="s3">, </span><span class="s1">self</span><span class="s3">, </span><span class="s1">lst</span><span class="s3">):</span>
    <span class="s1">fmt </span><span class="s3">= </span><span class="s1">merger</span><span class="s3">.</span><span class="s1">checkFormatEnum</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">lst</span><span class="s3">, </span><span class="s2">lambda </span><span class="s1">fmt</span><span class="s3">: </span><span class="s2">not </span><span class="s1">fmt</span><span class="s3">.</span><span class="s1">is_variable</span><span class="s3">())</span>

    <span class="s2">if </span><span class="s1">fmt </span><span class="s2">is </span><span class="s1">ot</span><span class="s3">.</span><span class="s1">PaintFormat</span><span class="s3">.</span><span class="s1">PaintColrLayers</span><span class="s3">:</span>
        <span class="s1">_merge_PaintColrLayers</span><span class="s3">(</span><span class="s1">merger</span><span class="s3">, </span><span class="s1">self</span><span class="s3">, </span><span class="s1">lst</span><span class="s3">)</span>
        <span class="s2">return</span>

    <span class="s1">varFormat </span><span class="s3">= </span><span class="s1">fmt</span><span class="s3">.</span><span class="s1">as_variable</span><span class="s3">()</span>

    <span class="s1">varAttrs </span><span class="s3">= ()</span>
    <span class="s2">if </span><span class="s1">varFormat </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s1">varAttrs </span><span class="s3">= </span><span class="s1">otBase</span><span class="s3">.</span><span class="s1">getVariableAttrs</span><span class="s3">(</span><span class="s1">type</span><span class="s3">(</span><span class="s1">self</span><span class="s3">), </span><span class="s1">varFormat</span><span class="s3">)</span>
    <span class="s1">staticAttrs </span><span class="s3">= (</span><span class="s1">c</span><span class="s3">.</span><span class="s1">name </span><span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">getConverters</span><span class="s3">() </span><span class="s2">if </span><span class="s1">c</span><span class="s3">.</span><span class="s1">name </span><span class="s2">not in </span><span class="s1">varAttrs</span><span class="s3">)</span>

    <span class="s1">merger</span><span class="s3">.</span><span class="s1">mergeAttrs</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">lst</span><span class="s3">, </span><span class="s1">staticAttrs</span><span class="s3">)</span>

    <span class="s1">varIndexBase </span><span class="s3">= </span><span class="s1">merger</span><span class="s3">.</span><span class="s1">mergeVariableAttrs</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">lst</span><span class="s3">, </span><span class="s1">varAttrs</span><span class="s3">)</span>

    <span class="s1">subTables </span><span class="s3">= [</span><span class="s1">st</span><span class="s3">.</span><span class="s1">value </span><span class="s2">for </span><span class="s1">st </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">iterSubTables</span><span class="s3">()]</span>

    <span class="s5"># Convert table to variable if itself has variations or any subtables have</span>
    <span class="s1">isVariable </span><span class="s3">= </span><span class="s1">varIndexBase </span><span class="s3">!= </span><span class="s1">ot</span><span class="s3">.</span><span class="s1">NO_VARIATION_INDEX </span><span class="s2">or </span><span class="s1">any</span><span class="s3">(</span>
        <span class="s1">id</span><span class="s3">(</span><span class="s1">table</span><span class="s3">) </span><span class="s2">in </span><span class="s1">merger</span><span class="s3">.</span><span class="s1">varTableIds </span><span class="s2">for </span><span class="s1">table </span><span class="s2">in </span><span class="s1">subTables</span>
    <span class="s3">)</span>

    <span class="s2">if </span><span class="s1">isVariable</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">varAttrs</span><span class="s3">:</span>
            <span class="s5"># Some PaintVar* don't have any scalar attributes that can vary,</span>
            <span class="s5"># only indirect offsets to other variable subtables, thus have</span>
            <span class="s5"># no VarIndexBase of their own (e.g. PaintVarTransform)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">VarIndexBase </span><span class="s3">= </span><span class="s1">varIndexBase</span>

        <span class="s2">if </span><span class="s1">subTables</span><span class="s3">:</span>
            <span class="s5"># Convert Affine2x3 -&gt; VarAffine2x3, ColorLine -&gt; VarColorLine, etc.</span>
            <span class="s1">merger</span><span class="s3">.</span><span class="s1">convertSubTablesToVarType</span><span class="s3">(</span><span class="s1">self</span><span class="s3">)</span>

        <span class="s2">assert </span><span class="s1">varFormat </span><span class="s2">is not None</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">Format </span><span class="s3">= </span><span class="s1">int</span><span class="s3">(</span><span class="s1">varFormat</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">COLRVariationMerger</span><span class="s3">.</span><span class="s1">merger</span><span class="s3">((</span><span class="s1">ot</span><span class="s3">.</span><span class="s1">Affine2x3</span><span class="s3">, </span><span class="s1">ot</span><span class="s3">.</span><span class="s1">ColorStop</span><span class="s3">))</span>
<span class="s2">def </span><span class="s1">merge</span><span class="s3">(</span><span class="s1">merger</span><span class="s3">, </span><span class="s1">self</span><span class="s3">, </span><span class="s1">lst</span><span class="s3">):</span>
    <span class="s1">varType </span><span class="s3">= </span><span class="s1">type</span><span class="s3">(</span><span class="s1">self</span><span class="s3">).</span><span class="s1">VarType</span>

    <span class="s1">varAttrs </span><span class="s3">= </span><span class="s1">otBase</span><span class="s3">.</span><span class="s1">getVariableAttrs</span><span class="s3">(</span><span class="s1">varType</span><span class="s3">)</span>
    <span class="s1">staticAttrs </span><span class="s3">= (</span><span class="s1">c</span><span class="s3">.</span><span class="s1">name </span><span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">getConverters</span><span class="s3">() </span><span class="s2">if </span><span class="s1">c</span><span class="s3">.</span><span class="s1">name </span><span class="s2">not in </span><span class="s1">varAttrs</span><span class="s3">)</span>

    <span class="s1">merger</span><span class="s3">.</span><span class="s1">mergeAttrs</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">lst</span><span class="s3">, </span><span class="s1">staticAttrs</span><span class="s3">)</span>

    <span class="s1">varIndexBase </span><span class="s3">= </span><span class="s1">merger</span><span class="s3">.</span><span class="s1">mergeVariableAttrs</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">lst</span><span class="s3">, </span><span class="s1">varAttrs</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">varIndexBase </span><span class="s3">!= </span><span class="s1">ot</span><span class="s3">.</span><span class="s1">NO_VARIATION_INDEX</span><span class="s3">:</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">VarIndexBase </span><span class="s3">= </span><span class="s1">varIndexBase</span>
        <span class="s5"># mark as having variations so the parent table will convert to Var{Type}</span>
        <span class="s1">merger</span><span class="s3">.</span><span class="s1">varTableIds</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">id</span><span class="s3">(</span><span class="s1">self</span><span class="s3">))</span>


<span class="s3">@</span><span class="s1">COLRVariationMerger</span><span class="s3">.</span><span class="s1">merger</span><span class="s3">(</span><span class="s1">ot</span><span class="s3">.</span><span class="s1">ColorLine</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">merge</span><span class="s3">(</span><span class="s1">merger</span><span class="s3">, </span><span class="s1">self</span><span class="s3">, </span><span class="s1">lst</span><span class="s3">):</span>
    <span class="s1">merger</span><span class="s3">.</span><span class="s1">mergeAttrs</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">lst</span><span class="s3">, (</span><span class="s1">c</span><span class="s3">.</span><span class="s1">name </span><span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">getConverters</span><span class="s3">()))</span>

    <span class="s2">if </span><span class="s1">any</span><span class="s3">(</span><span class="s1">id</span><span class="s3">(</span><span class="s1">stop</span><span class="s3">) </span><span class="s2">in </span><span class="s1">merger</span><span class="s3">.</span><span class="s1">varTableIds </span><span class="s2">for </span><span class="s1">stop </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">ColorStop</span><span class="s3">):</span>
        <span class="s1">merger</span><span class="s3">.</span><span class="s1">convertSubTablesToVarType</span><span class="s3">(</span><span class="s1">self</span><span class="s3">)</span>
        <span class="s1">merger</span><span class="s3">.</span><span class="s1">varTableIds</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">id</span><span class="s3">(</span><span class="s1">self</span><span class="s3">))</span>


<span class="s3">@</span><span class="s1">COLRVariationMerger</span><span class="s3">.</span><span class="s1">merger</span><span class="s3">(</span><span class="s1">ot</span><span class="s3">.</span><span class="s1">ClipList</span><span class="s3">, </span><span class="s4">&quot;clips&quot;</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">merge</span><span class="s3">(</span><span class="s1">merger</span><span class="s3">, </span><span class="s1">self</span><span class="s3">, </span><span class="s1">lst</span><span class="s3">):</span>
    <span class="s5"># 'sparse' in that we allow non-default masters to omit ClipBox entries</span>
    <span class="s5"># for some/all glyphs (i.e. they don't participate)</span>
    <span class="s1">merger</span><span class="s3">.</span><span class="s1">mergeSparseDict</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">lst</span><span class="s3">)</span>
</pre>
</body>
</html>