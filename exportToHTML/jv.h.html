<html>
<head>
<title>jv.h</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #6aab73;}
.s4 { color: #c77dbb;}
.s5 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
jv.h</font>
</center></td></tr></table>
<pre><span class="s0">/* Translated into C++ by SciPy developers in 2024. 
 * Original header with Copyright information appears below. 
 */</span>

<span class="s0">/*                                                     jv.c 
 * 
 *     Bessel function of noninteger order 
 * 
 * 
 * 
 * SYNOPSIS: 
 * 
 * double v, x, y, jv(); 
 * 
 * y = jv( v, x ); 
 * 
 * 
 * 
 * DESCRIPTION: 
 * 
 * Returns Bessel function of order v of the argument, 
 * where v is real.  Negative x is allowed if v is an integer. 
 * 
 * Several expansions are included: the ascending power 
 * series, the Hankel expansion, and two transitional 
 * expansions for large v.  If v is not too large, it 
 * is reduced by recurrence to a region of best accuracy. 
 * The transitional expansions give 12D accuracy for v &gt; 500. 
 * 
 * 
 * 
 * ACCURACY: 
 * Results for integer v are indicated by *, where x and v 
 * both vary from -125 to +125.  Otherwise, 
 * x ranges from 0 to 125, v ranges as indicated by &quot;domain.&quot; 
 * Error criterion is absolute, except relative when |jv()| &gt; 1. 
 * 
 * arithmetic  v domain  x domain    # trials      peak       rms 
 *    IEEE      0,125     0,125      100000      4.6e-15    2.2e-16 
 *    IEEE   -125,0       0,125       40000      5.4e-11    3.7e-13 
 *    IEEE      0,500     0,500       20000      4.4e-15    4.0e-16 
 * Integer v: 
 *    IEEE   -125,125   -125,125      50000      3.5e-15*   1.9e-16* 
 * 
 */</span>

<span class="s0">/* 
 * Cephes Math Library Release 2.8:  June, 2000 
 * Copyright 1984, 1987, 1989, 1992, 2000 by Stephen L. Moshier 
 */</span>
<span class="s1">#pragma once</span>

<span class="s2">#include </span><span class="s3">&quot;../config.h&quot;</span>
<span class="s2">#include </span><span class="s3">&quot;../error.h&quot;</span>

<span class="s2">#include </span><span class="s3">&quot;airy.h&quot;</span>
<span class="s2">#include </span><span class="s3">&quot;cbrt.h&quot;</span>
<span class="s2">#include </span><span class="s3">&quot;gamma.h&quot;</span>
<span class="s2">#include </span><span class="s3">&quot;j0.h&quot;</span>
<span class="s2">#include </span><span class="s3">&quot;j1.h&quot;</span>
<span class="s2">#include </span><span class="s3">&quot;polevl.h&quot;</span>

<span class="s4">namespace </span><span class="s1">special {</span>
<span class="s4">namespace </span><span class="s1">cephes {</span>

    <span class="s4">namespace </span><span class="s1">detail {</span>

        <span class="s1">constexpr </span><span class="s2">double </span><span class="s1">jv_BIG = </span><span class="s5">1</span><span class="s1">.</span><span class="s5">44115188075855872</span><span class="s1">E+</span><span class="s5">17</span><span class="s1">;</span>

        <span class="s0">/* Reduce the order by backward recurrence. 
         * AMS55 #9.1.27 and 9.1.73. 
         */</span>

        <span class="s1">SPECFUN_HOST_DEVICE </span><span class="s4">inline </span><span class="s2">double </span><span class="s1">jv_recur(</span><span class="s2">double </span><span class="s1">*n, </span><span class="s2">double </span><span class="s1">x, </span><span class="s2">double </span><span class="s1">*newn, </span><span class="s2">int </span><span class="s1">cancel) {</span>
            <span class="s2">double </span><span class="s1">pkm2, pkm1, pk, qkm2, qkm1;</span>

            <span class="s0">/* double pkp1; */</span>
            <span class="s2">double </span><span class="s1">k, ans, qk, xk, yk, r, t, kf;</span>
            <span class="s1">constexpr </span><span class="s2">double </span><span class="s1">big = jv_BIG;</span>
            <span class="s2">int </span><span class="s1">nflag, ctr;</span>
            <span class="s2">int </span><span class="s1">miniter, maxiter;</span>

            <span class="s0">/* Continued fraction for Jn(x)/Jn-1(x) 
             * AMS 9.1.73 
             * 
             *    x       -x^2      -x^2 
             * ------  ---------  ---------   ... 
             * 2 n +   2(n+1) +   2(n+2) + 
             * 
             * Compute it with the simplest possible algorithm. 
             * 
             * This continued fraction starts to converge when (|n| + m) &gt; |x|. 
             * Hence, at least |x|-|n| iterations are necessary before convergence is 
             * achieved. There is a hard limit set below, m &lt;= 30000, which is chosen 
             * so that no branch in `jv` requires more iterations to converge. 
             * The exact maximum number is (500/3.6)^2 - 500 ~ 19000 
             */</span>

            <span class="s1">maxiter = </span><span class="s5">22000</span><span class="s1">;</span>
            <span class="s1">miniter = std::abs(x) - std::abs(*n);</span>
            <span class="s2">if </span><span class="s1">(miniter &lt; </span><span class="s5">1</span><span class="s1">) {</span>
                <span class="s1">miniter = </span><span class="s5">1</span><span class="s1">;</span>
            <span class="s1">}</span>

            <span class="s2">if </span><span class="s1">(*n &lt; </span><span class="s5">0.0</span><span class="s1">) {</span>
                <span class="s1">nflag = </span><span class="s5">1</span><span class="s1">;</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s1">nflag = </span><span class="s5">0</span><span class="s1">;</span>
            <span class="s1">}</span>

        <span class="s1">fstart:</span>
            <span class="s1">pkm2 = </span><span class="s5">0.0</span><span class="s1">;</span>
            <span class="s1">qkm2 = </span><span class="s5">1.0</span><span class="s1">;</span>
            <span class="s1">pkm1 = x;</span>
            <span class="s1">qkm1 = *n + *n;</span>
            <span class="s1">xk = -x * x;</span>
            <span class="s1">yk = qkm1;</span>
            <span class="s1">ans = </span><span class="s5">0.0</span><span class="s1">; </span><span class="s0">/* ans=0.0 ensures that t=1.0 in the first iteration */</span>
            <span class="s1">ctr = </span><span class="s5">0</span><span class="s1">;</span>
            <span class="s2">do </span><span class="s1">{</span>
                <span class="s1">yk += </span><span class="s5">2.0</span><span class="s1">;</span>
                <span class="s1">pk = pkm1 * yk + pkm2 * xk;</span>
                <span class="s1">qk = qkm1 * yk + qkm2 * xk;</span>
                <span class="s1">pkm2 = pkm1;</span>
                <span class="s1">pkm1 = pk;</span>
                <span class="s1">qkm2 = qkm1;</span>
                <span class="s1">qkm1 = qk;</span>

                <span class="s0">/* check convergence */</span>
                <span class="s2">if </span><span class="s1">(qk != </span><span class="s5">0 </span><span class="s1">&amp;&amp; ctr &gt; miniter)</span>
                    <span class="s1">r = pk / qk;</span>
                <span class="s2">else</span>
                    <span class="s1">r = </span><span class="s5">0.0</span><span class="s1">;</span>

                <span class="s2">if </span><span class="s1">(r != </span><span class="s5">0</span><span class="s1">) {</span>
                    <span class="s1">t = std::abs((ans - r) / r);</span>
                    <span class="s1">ans = r;</span>
                <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">t = </span><span class="s5">1.0</span><span class="s1">;</span>
                <span class="s1">}</span>

                <span class="s2">if </span><span class="s1">(++ctr &gt; maxiter) {</span>
                    <span class="s1">set_error(</span><span class="s3">&quot;jv&quot;</span><span class="s1">, SF_ERROR_UNDERFLOW, NULL);</span>
                    <span class="s2">goto </span><span class="s1">done;</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(t &lt; MACHEP) {</span>
                    <span class="s2">goto </span><span class="s1">done;</span>
                <span class="s1">}</span>

                <span class="s0">/* renormalize coefficients */</span>
                <span class="s2">if </span><span class="s1">(std::abs(pk) &gt; big) {</span>
                    <span class="s1">pkm2 /= big;</span>
                    <span class="s1">pkm1 /= big;</span>
                    <span class="s1">qkm2 /= big;</span>
                    <span class="s1">qkm1 /= big;</span>
                <span class="s1">}</span>
            <span class="s1">} </span><span class="s2">while </span><span class="s1">(t &gt; MACHEP);</span>

        <span class="s1">done:</span>
            <span class="s2">if </span><span class="s1">(ans == </span><span class="s5">0</span><span class="s1">)</span>
                <span class="s1">ans = </span><span class="s5">1.0</span><span class="s1">;</span>

            <span class="s0">/* Change n to n-1 if n &lt; 0 and the continued fraction is small */</span>
            <span class="s2">if </span><span class="s1">(nflag &gt; </span><span class="s5">0</span><span class="s1">) {</span>
                <span class="s2">if </span><span class="s1">(std::abs(ans) &lt; </span><span class="s5">0.125</span><span class="s1">) {</span>
                    <span class="s1">nflag = -</span><span class="s5">1</span><span class="s1">;</span>
                    <span class="s1">*n = *n - </span><span class="s5">1.0</span><span class="s1">;</span>
                    <span class="s2">goto </span><span class="s1">fstart;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>

            <span class="s1">kf = *newn;</span>

            <span class="s0">/* backward recurrence 
             *              2k 
             *  J   (x)  =  --- J (x)  -  J   (x) 
             *   k-1         x   k         k+1 
             */</span>

            <span class="s1">pk = </span><span class="s5">1.0</span><span class="s1">;</span>
            <span class="s1">pkm1 = </span><span class="s5">1.0 </span><span class="s1">/ ans;</span>
            <span class="s1">k = *n - </span><span class="s5">1.0</span><span class="s1">;</span>
            <span class="s1">r = </span><span class="s5">2 </span><span class="s1">* k;</span>
            <span class="s2">do </span><span class="s1">{</span>
                <span class="s1">pkm2 = (pkm1 * r - pk * x) / x;</span>
                <span class="s0">/*      pkp1 = pk; */</span>
                <span class="s1">pk = pkm1;</span>
                <span class="s1">pkm1 = pkm2;</span>
                <span class="s1">r -= </span><span class="s5">2.0</span><span class="s1">;</span>
                <span class="s0">/* 
                 * t = fabs(pkp1) + fabs(pk); 
                 * if( (k &gt; (kf + 2.5)) &amp;&amp; (fabs(pkm1) &lt; 0.25*t) ) 
                 * { 
                 * k -= 1.0; 
                 * t = x*x; 
                 * pkm2 = ( (r*(r+2.0)-t)*pk - r*x*pkp1 )/t; 
                 * pkp1 = pk; 
                 * pk = pkm1; 
                 * pkm1 = pkm2; 
                 * r -= 2.0; 
                 * } 
                 */</span>
                <span class="s1">k -= </span><span class="s5">1.0</span><span class="s1">;</span>
            <span class="s1">} </span><span class="s2">while </span><span class="s1">(k &gt; (kf + </span><span class="s5">0.5</span><span class="s1">));</span>

            <span class="s0">/* Take the larger of the last two iterates 
             * on the theory that it may have less cancellation error. 
             */</span>

            <span class="s2">if </span><span class="s1">(cancel) {</span>
                <span class="s2">if </span><span class="s1">((kf &gt;= </span><span class="s5">0.0</span><span class="s1">) &amp;&amp; (std::abs(pk) &gt; std::abs(pkm1))) {</span>
                    <span class="s1">k += </span><span class="s5">1.0</span><span class="s1">;</span>
                    <span class="s1">pkm2 = pk;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s1">*newn = k;</span>
            <span class="s2">return </span><span class="s1">(pkm2);</span>
        <span class="s1">}</span>

        <span class="s0">/* Ascending power series for Jv(x). 
         * AMS55 #9.1.10. 
         */</span>

        <span class="s1">SPECFUN_HOST_DEVICE </span><span class="s4">inline </span><span class="s2">double </span><span class="s1">jv_jvs(</span><span class="s2">double </span><span class="s1">n, </span><span class="s2">double </span><span class="s1">x) {</span>
            <span class="s2">double </span><span class="s1">t, u, y, z, k;</span>
            <span class="s2">int </span><span class="s1">ex, sgngam;</span>

            <span class="s1">z = -x * x / </span><span class="s5">4.0</span><span class="s1">;</span>
            <span class="s1">u = </span><span class="s5">1.0</span><span class="s1">;</span>
            <span class="s1">y = u;</span>
            <span class="s1">k = </span><span class="s5">1.0</span><span class="s1">;</span>
            <span class="s1">t = </span><span class="s5">1.0</span><span class="s1">;</span>

            <span class="s2">while </span><span class="s1">(t &gt; MACHEP) {</span>
                <span class="s1">u *= z / (k * (n + k));</span>
                <span class="s1">y += u;</span>
                <span class="s1">k += </span><span class="s5">1.0</span><span class="s1">;</span>
                <span class="s2">if </span><span class="s1">(y != </span><span class="s5">0</span><span class="s1">)</span>
                    <span class="s1">t = std::abs(u / y);</span>
            <span class="s1">}</span>
            <span class="s1">t = std::frexp(</span><span class="s5">0.5 </span><span class="s1">* x, &amp;ex);</span>
            <span class="s1">ex = ex * n;</span>
            <span class="s2">if </span><span class="s1">((ex &gt; -</span><span class="s5">1023</span><span class="s1">) &amp;&amp; (ex &lt; </span><span class="s5">1023</span><span class="s1">) &amp;&amp; (n &gt; </span><span class="s5">0.0</span><span class="s1">) &amp;&amp; (n &lt; (MAXGAM - </span><span class="s5">1.0</span><span class="s1">))) {</span>
                <span class="s1">t = std::pow(</span><span class="s5">0.5 </span><span class="s1">* x, n) / special::cephes::Gamma(n + </span><span class="s5">1.0</span><span class="s1">);</span>
                <span class="s1">y *= t;</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s1">t = n * std::log(</span><span class="s5">0.5 </span><span class="s1">* x) - lgam_sgn(n + </span><span class="s5">1.0</span><span class="s1">, &amp;sgngam);</span>
                <span class="s2">if </span><span class="s1">(y &lt; </span><span class="s5">0</span><span class="s1">) {</span>
                    <span class="s1">sgngam = -sgngam;</span>
                    <span class="s1">y = -y;</span>
                <span class="s1">}</span>
                <span class="s1">t += std::log(y);</span>
                <span class="s2">if </span><span class="s1">(t &lt; -MAXLOG) {</span>
                    <span class="s2">return </span><span class="s1">(</span><span class="s5">0.0</span><span class="s1">);</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(t &gt; MAXLOG) {</span>
                    <span class="s1">set_error(</span><span class="s3">&quot;Jv&quot;</span><span class="s1">, SF_ERROR_OVERFLOW, NULL);</span>
                    <span class="s2">return </span><span class="s1">(std::numeric_limits&lt;</span><span class="s2">double</span><span class="s1">&gt;::infinity());</span>
                <span class="s1">}</span>
                <span class="s1">y = sgngam * std::exp(t);</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">(y);</span>
        <span class="s1">}</span>

        <span class="s0">/* Hankel's asymptotic expansion 
         * for large x. 
         * AMS55 #9.2.5. 
         */</span>

        <span class="s1">SPECFUN_HOST_DEVICE </span><span class="s4">inline </span><span class="s2">double </span><span class="s1">jv_hankel(</span><span class="s2">double </span><span class="s1">n, </span><span class="s2">double </span><span class="s1">x) {</span>
            <span class="s2">double </span><span class="s1">t, u, z, k, sign, conv;</span>
            <span class="s2">double </span><span class="s1">p, q, j, m, pp, qq;</span>
            <span class="s2">int </span><span class="s1">flag;</span>

            <span class="s1">m = </span><span class="s5">4.0 </span><span class="s1">* n * n;</span>
            <span class="s1">j = </span><span class="s5">1.0</span><span class="s1">;</span>
            <span class="s1">z = </span><span class="s5">8.0 </span><span class="s1">* x;</span>
            <span class="s1">k = </span><span class="s5">1.0</span><span class="s1">;</span>
            <span class="s1">p = </span><span class="s5">1.0</span><span class="s1">;</span>
            <span class="s1">u = (m - </span><span class="s5">1.0</span><span class="s1">) / z;</span>
            <span class="s1">q = u;</span>
            <span class="s1">sign = </span><span class="s5">1.0</span><span class="s1">;</span>
            <span class="s1">conv = </span><span class="s5">1.0</span><span class="s1">;</span>
            <span class="s1">flag = </span><span class="s5">0</span><span class="s1">;</span>
            <span class="s1">t = </span><span class="s5">1.0</span><span class="s1">;</span>
            <span class="s1">pp = </span><span class="s5">1</span><span class="s1">.</span><span class="s5">0</span><span class="s1">e38;</span>
            <span class="s1">qq = </span><span class="s5">1</span><span class="s1">.</span><span class="s5">0</span><span class="s1">e38;</span>

            <span class="s2">while </span><span class="s1">(t &gt; MACHEP) {</span>
                <span class="s1">k += </span><span class="s5">2.0</span><span class="s1">;</span>
                <span class="s1">j += </span><span class="s5">1.0</span><span class="s1">;</span>
                <span class="s1">sign = -sign;</span>
                <span class="s1">u *= (m - k * k) / (j * z);</span>
                <span class="s1">p += sign * u;</span>
                <span class="s1">k += </span><span class="s5">2.0</span><span class="s1">;</span>
                <span class="s1">j += </span><span class="s5">1.0</span><span class="s1">;</span>
                <span class="s1">u *= (m - k * k) / (j * z);</span>
                <span class="s1">q += sign * u;</span>
                <span class="s1">t = std::abs(u / p);</span>
                <span class="s2">if </span><span class="s1">(t &lt; conv) {</span>
                    <span class="s1">conv = t;</span>
                    <span class="s1">qq = q;</span>
                    <span class="s1">pp = p;</span>
                    <span class="s1">flag = </span><span class="s5">1</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s0">/* stop if the terms start getting larger */</span>
                <span class="s2">if </span><span class="s1">((flag != </span><span class="s5">0</span><span class="s1">) &amp;&amp; (t &gt; conv)) {</span>
                    <span class="s2">goto </span><span class="s1">hank1;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>

        <span class="s1">hank1:</span>
            <span class="s1">u = x - (</span><span class="s5">0.5 </span><span class="s1">* n + </span><span class="s5">0.25</span><span class="s1">) * M_PI;</span>
            <span class="s1">t = std::sqrt(</span><span class="s5">2.0 </span><span class="s1">/ (M_PI * x)) * (pp * std::cos(u) - qq * std::sin(u));</span>
            <span class="s2">return </span><span class="s1">(t);</span>
        <span class="s1">}</span>

        <span class="s0">/* Asymptotic expansion for transition region, 
         * n large and x close to n. 
         * AMS55 #9.3.23. 
         */</span>

        <span class="s1">constexpr </span><span class="s2">double </span><span class="s1">jv_PF2[] = {-</span><span class="s5">9</span><span class="s1">.</span><span class="s5">0000000000000000000</span><span class="s1">e-2, </span><span class="s5">8</span><span class="s1">.</span><span class="s5">5714285714285714286</span><span class="s1">e-2};</span>

        <span class="s1">constexpr </span><span class="s2">double </span><span class="s1">jv_PF3[] = {</span><span class="s5">1</span><span class="s1">.</span><span class="s5">3671428571428571429</span><span class="s1">e-1, -</span><span class="s5">5</span><span class="s1">.</span><span class="s5">4920634920634920635</span><span class="s1">e-2, -</span><span class="s5">4</span><span class="s1">.</span><span class="s5">4444444444444444444</span><span class="s1">e-3};</span>

        <span class="s1">constexpr </span><span class="s2">double </span><span class="s1">jv_PF4[] = {</span><span class="s5">1</span><span class="s1">.</span><span class="s5">3500000000000000000</span><span class="s1">e-3, -</span><span class="s5">1</span><span class="s1">.</span><span class="s5">6036054421768707483</span><span class="s1">e-1, </span><span class="s5">4</span><span class="s1">.</span><span class="s5">2590187590187590188</span><span class="s1">e-2,</span>
                                     <span class="s5">2</span><span class="s1">.</span><span class="s5">7330447330447330447</span><span class="s1">e-3};</span>

        <span class="s1">constexpr </span><span class="s2">double </span><span class="s1">jv_PG1[] = {-</span><span class="s5">2</span><span class="s1">.</span><span class="s5">4285714285714285714</span><span class="s1">e-1, </span><span class="s5">1</span><span class="s1">.</span><span class="s5">4285714285714285714</span><span class="s1">e-2};</span>

        <span class="s1">constexpr </span><span class="s2">double </span><span class="s1">jv_PG2[] = {-</span><span class="s5">9</span><span class="s1">.</span><span class="s5">0000000000000000000</span><span class="s1">e-3, </span><span class="s5">1</span><span class="s1">.</span><span class="s5">9396825396825396825</span><span class="s1">e-1, -</span><span class="s5">1</span><span class="s1">.</span><span class="s5">1746031746031746032</span><span class="s1">e-2};</span>

        <span class="s1">constexpr </span><span class="s2">double </span><span class="s1">jv_PG3[] = {</span><span class="s5">1</span><span class="s1">.</span><span class="s5">9607142857142857143</span><span class="s1">e-2, -</span><span class="s5">1</span><span class="s1">.</span><span class="s5">5983694083694083694</span><span class="s1">e-1, </span><span class="s5">6</span><span class="s1">.</span><span class="s5">3838383838383838384</span><span class="s1">e-3};</span>

        <span class="s1">SPECFUN_HOST_DEVICE </span><span class="s4">inline </span><span class="s2">double </span><span class="s1">jv_jnt(</span><span class="s2">double </span><span class="s1">n, </span><span class="s2">double </span><span class="s1">x) {</span>
            <span class="s2">double </span><span class="s1">z, zz, z3;</span>
            <span class="s2">double </span><span class="s1">cbn, n23, cbtwo;</span>
            <span class="s2">double </span><span class="s1">ai, aip, bi, bip; </span><span class="s0">/* Airy functions */</span>
            <span class="s2">double </span><span class="s1">nk, fk, gk, pp, qq;</span>
            <span class="s2">double </span><span class="s1">F[</span><span class="s5">5</span><span class="s1">], G[</span><span class="s5">4</span><span class="s1">];</span>
            <span class="s2">int </span><span class="s1">k;</span>

            <span class="s1">cbn = cbrt(n);</span>
            <span class="s1">z = (x - n) / cbn;</span>
            <span class="s1">cbtwo = cbrt(</span><span class="s5">2.0</span><span class="s1">);</span>

            <span class="s0">/* Airy function */</span>
            <span class="s1">zz = -cbtwo * z;</span>
            <span class="s1">special::cephes::airy(zz, &amp;ai, &amp;aip, &amp;bi, &amp;bip);</span>

            <span class="s0">/* polynomials in expansion */</span>
            <span class="s1">zz = z * z;</span>
            <span class="s1">z3 = zz * z;</span>
            <span class="s1">F[</span><span class="s5">0</span><span class="s1">] = </span><span class="s5">1.0</span><span class="s1">;</span>
            <span class="s1">F[</span><span class="s5">1</span><span class="s1">] = -z / </span><span class="s5">5.0</span><span class="s1">;</span>
            <span class="s1">F[</span><span class="s5">2</span><span class="s1">] = special::cephes::polevl(z3, jv_PF2, </span><span class="s5">1</span><span class="s1">) * zz;</span>
            <span class="s1">F[</span><span class="s5">3</span><span class="s1">] = special::cephes::polevl(z3, jv_PF3, </span><span class="s5">2</span><span class="s1">);</span>
            <span class="s1">F[</span><span class="s5">4</span><span class="s1">] = special::cephes::polevl(z3, jv_PF4, </span><span class="s5">3</span><span class="s1">) * z;</span>
            <span class="s1">G[</span><span class="s5">0</span><span class="s1">] = </span><span class="s5">0.3 </span><span class="s1">* zz;</span>
            <span class="s1">G[</span><span class="s5">1</span><span class="s1">] = special::cephes::polevl(z3, jv_PG1, </span><span class="s5">1</span><span class="s1">);</span>
            <span class="s1">G[</span><span class="s5">2</span><span class="s1">] = special::cephes::polevl(z3, jv_PG2, </span><span class="s5">2</span><span class="s1">) * z;</span>
            <span class="s1">G[</span><span class="s5">3</span><span class="s1">] = special::cephes::polevl(z3, jv_PG3, </span><span class="s5">2</span><span class="s1">) * zz;</span>

            <span class="s1">pp = </span><span class="s5">0.0</span><span class="s1">;</span>
            <span class="s1">qq = </span><span class="s5">0.0</span><span class="s1">;</span>
            <span class="s1">nk = </span><span class="s5">1.0</span><span class="s1">;</span>
            <span class="s1">n23 = cbrt(n * n);</span>

            <span class="s2">for </span><span class="s1">(k = </span><span class="s5">0</span><span class="s1">; k &lt;= </span><span class="s5">4</span><span class="s1">; k++) {</span>
                <span class="s1">fk = F[k] * nk;</span>
                <span class="s1">pp += fk;</span>
                <span class="s2">if </span><span class="s1">(k != </span><span class="s5">4</span><span class="s1">) {</span>
                    <span class="s1">gk = G[k] * nk;</span>
                    <span class="s1">qq += gk;</span>
                <span class="s1">}</span>
                <span class="s1">nk /= n23;</span>
            <span class="s1">}</span>

            <span class="s1">fk = cbtwo * ai * pp / cbn + cbrt(</span><span class="s5">4.0</span><span class="s1">) * aip * qq / n;</span>
            <span class="s2">return </span><span class="s1">(fk);</span>
        <span class="s1">}</span>

        <span class="s0">/* Asymptotic expansion for large n. 
         * AMS55 #9.3.35. 
         */</span>

        <span class="s1">constexpr </span><span class="s2">double </span><span class="s1">jv_lambda[] = {</span><span class="s5">1.0</span><span class="s1">,</span>
                                        <span class="s5">1</span><span class="s1">.</span><span class="s5">041666666666666666666667</span><span class="s1">E-1,</span>
                                        <span class="s5">8</span><span class="s1">.</span><span class="s5">355034722222222222222222</span><span class="s1">E-2,</span>
                                        <span class="s5">1</span><span class="s1">.</span><span class="s5">282265745563271604938272</span><span class="s1">E-1,</span>
                                        <span class="s5">2</span><span class="s1">.</span><span class="s5">918490264641404642489712</span><span class="s1">E-1,</span>
                                        <span class="s5">8</span><span class="s1">.</span><span class="s5">816272674437576524187671</span><span class="s1">E-1,</span>
                                        <span class="s5">3</span><span class="s1">.</span><span class="s5">321408281862767544702647</span><span class="s1">E+</span><span class="s5">0</span><span class="s1">,</span>
                                        <span class="s5">1</span><span class="s1">.</span><span class="s5">499576298686255465867237</span><span class="s1">E+</span><span class="s5">1</span><span class="s1">,</span>
                                        <span class="s5">7</span><span class="s1">.</span><span class="s5">892301301158651813848139</span><span class="s1">E+</span><span class="s5">1</span><span class="s1">,</span>
                                        <span class="s5">4</span><span class="s1">.</span><span class="s5">744515388682643231611949</span><span class="s1">E+</span><span class="s5">2</span><span class="s1">,</span>
                                        <span class="s5">3</span><span class="s1">.</span><span class="s5">207490090890661934704328</span><span class="s1">E+</span><span class="s5">3</span><span class="s1">};</span>

        <span class="s1">constexpr </span><span class="s2">double </span><span class="s1">jv_mu[] = {</span><span class="s5">1.0</span><span class="s1">,</span>
                                    <span class="s1">-</span><span class="s5">1</span><span class="s1">.</span><span class="s5">458333333333333333333333</span><span class="s1">E-1,</span>
                                    <span class="s1">-</span><span class="s5">9</span><span class="s1">.</span><span class="s5">874131944444444444444444</span><span class="s1">E-2,</span>
                                    <span class="s1">-</span><span class="s5">1</span><span class="s1">.</span><span class="s5">433120539158950617283951</span><span class="s1">E-1,</span>
                                    <span class="s1">-</span><span class="s5">3</span><span class="s1">.</span><span class="s5">172272026784135480967078</span><span class="s1">E-1,</span>
                                    <span class="s1">-</span><span class="s5">9</span><span class="s1">.</span><span class="s5">424291479571202491373028</span><span class="s1">E-1,</span>
                                    <span class="s1">-</span><span class="s5">3</span><span class="s1">.</span><span class="s5">511203040826354261542798</span><span class="s1">E+</span><span class="s5">0</span><span class="s1">,</span>
                                    <span class="s1">-</span><span class="s5">1</span><span class="s1">.</span><span class="s5">572726362036804512982712</span><span class="s1">E+</span><span class="s5">1</span><span class="s1">,</span>
                                    <span class="s1">-</span><span class="s5">8</span><span class="s1">.</span><span class="s5">228143909718594444224656</span><span class="s1">E+</span><span class="s5">1</span><span class="s1">,</span>
                                    <span class="s1">-</span><span class="s5">4</span><span class="s1">.</span><span class="s5">923553705236705240352022</span><span class="s1">E+</span><span class="s5">2</span><span class="s1">,</span>
                                    <span class="s1">-</span><span class="s5">3</span><span class="s1">.</span><span class="s5">316218568547972508762102</span><span class="s1">E+</span><span class="s5">3</span><span class="s1">};</span>

        <span class="s1">constexpr </span><span class="s2">double </span><span class="s1">jv_P1[] = {-</span><span class="s5">2</span><span class="s1">.</span><span class="s5">083333333333333333333333</span><span class="s1">E-1, </span><span class="s5">1</span><span class="s1">.</span><span class="s5">250000000000000000000000</span><span class="s1">E-1};</span>

        <span class="s1">constexpr </span><span class="s2">double </span><span class="s1">jv_P2[] = {</span><span class="s5">3</span><span class="s1">.</span><span class="s5">342013888888888888888889</span><span class="s1">E-1, -</span><span class="s5">4</span><span class="s1">.</span><span class="s5">010416666666666666666667</span><span class="s1">E-1,</span>
                                    <span class="s5">7</span><span class="s1">.</span><span class="s5">031250000000000000000000</span><span class="s1">E-2};</span>

        <span class="s1">constexpr </span><span class="s2">double </span><span class="s1">jv_P3[] = {-</span><span class="s5">1</span><span class="s1">.</span><span class="s5">025812596450617283950617</span><span class="s1">E+</span><span class="s5">0</span><span class="s1">, </span><span class="s5">1</span><span class="s1">.</span><span class="s5">846462673611111111111111</span><span class="s1">E+</span><span class="s5">0</span><span class="s1">,</span>
                                    <span class="s1">-</span><span class="s5">8</span><span class="s1">.</span><span class="s5">912109375000000000000000</span><span class="s1">E-1, </span><span class="s5">7</span><span class="s1">.</span><span class="s5">324218750000000000000000</span><span class="s1">E-2};</span>

        <span class="s1">constexpr </span><span class="s2">double </span><span class="s1">jv_P4[] = {</span><span class="s5">4</span><span class="s1">.</span><span class="s5">669584423426247427983539</span><span class="s1">E+</span><span class="s5">0</span><span class="s1">, -</span><span class="s5">1</span><span class="s1">.</span><span class="s5">120700261622299382716049</span><span class="s1">E+</span><span class="s5">1</span><span class="s1">,</span>
                                    <span class="s5">8</span><span class="s1">.</span><span class="s5">789123535156250000000000</span><span class="s1">E+</span><span class="s5">0</span><span class="s1">, -</span><span class="s5">2</span><span class="s1">.</span><span class="s5">364086914062500000000000</span><span class="s1">E+</span><span class="s5">0</span><span class="s1">,</span>
                                    <span class="s5">1</span><span class="s1">.</span><span class="s5">121520996093750000000000</span><span class="s1">E-1};</span>

        <span class="s1">constexpr </span><span class="s2">double </span><span class="s1">jv_P5[] = {-</span><span class="s5">2</span><span class="s1">.</span><span class="s5">8212072558200244877</span><span class="s1">E1, </span><span class="s5">8</span><span class="s1">.</span><span class="s5">4636217674600734632</span><span class="s1">E1,  -</span><span class="s5">9</span><span class="s1">.</span><span class="s5">1818241543240017361</span><span class="s1">E1,</span>
                                    <span class="s5">4</span><span class="s1">.</span><span class="s5">2534998745388454861</span><span class="s1">E1,  -</span><span class="s5">7</span><span class="s1">.</span><span class="s5">3687943594796316964</span><span class="s1">E0, </span><span class="s5">2</span><span class="s1">.</span><span class="s5">27108001708984375</span><span class="s1">E-1};</span>

        <span class="s1">constexpr </span><span class="s2">double </span><span class="s1">jv_P6[] = {</span><span class="s5">2</span><span class="s1">.</span><span class="s5">1257013003921712286</span><span class="s1">E2,  -</span><span class="s5">7</span><span class="s1">.</span><span class="s5">6525246814118164230</span><span class="s1">E2, </span><span class="s5">1</span><span class="s1">.</span><span class="s5">0599904525279998779</span><span class="s1">E3,</span>
                                    <span class="s1">-</span><span class="s5">6</span><span class="s1">.</span><span class="s5">9957962737613254123</span><span class="s1">E2, </span><span class="s5">2</span><span class="s1">.</span><span class="s5">1819051174421159048</span><span class="s1">E2,  -</span><span class="s5">2</span><span class="s1">.</span><span class="s5">6491430486951555525</span><span class="s1">E1,</span>
                                    <span class="s5">5</span><span class="s1">.</span><span class="s5">7250142097473144531</span><span class="s1">E-1};</span>

        <span class="s1">constexpr </span><span class="s2">double </span><span class="s1">jv_P7[] = {-</span><span class="s5">1</span><span class="s1">.</span><span class="s5">9194576623184069963</span><span class="s1">E3, </span><span class="s5">8</span><span class="s1">.</span><span class="s5">0617221817373093845</span><span class="s1">E3,  -</span><span class="s5">1</span><span class="s1">.</span><span class="s5">3586550006434137439</span><span class="s1">E4,</span>
                                    <span class="s5">1</span><span class="s1">.</span><span class="s5">1655393336864533248</span><span class="s1">E4,  -</span><span class="s5">5</span><span class="s1">.</span><span class="s5">3056469786134031084</span><span class="s1">E3, </span><span class="s5">1</span><span class="s1">.</span><span class="s5">2009029132163524628</span><span class="s1">E3,</span>
                                    <span class="s1">-</span><span class="s5">1</span><span class="s1">.</span><span class="s5">0809091978839465550</span><span class="s1">E2, </span><span class="s5">1</span><span class="s1">.</span><span class="s5">7277275025844573975</span><span class="s1">E0};</span>

        <span class="s1">SPECFUN_HOST_DEVICE </span><span class="s4">inline </span><span class="s2">double </span><span class="s1">jv_jnx(</span><span class="s2">double </span><span class="s1">n, </span><span class="s2">double </span><span class="s1">x) {</span>
            <span class="s2">double </span><span class="s1">zeta, sqz, zz, zp, np;</span>
            <span class="s2">double </span><span class="s1">cbn, n23, t, z, sz;</span>
            <span class="s2">double </span><span class="s1">pp, qq, z32i, zzi;</span>
            <span class="s2">double </span><span class="s1">ak, bk, akl, bkl;</span>
            <span class="s2">int </span><span class="s1">sign, doa, dob, nflg, k, s, tk, tkp1, m;</span>
            <span class="s2">double </span><span class="s1">u[</span><span class="s5">8</span><span class="s1">];</span>
            <span class="s2">double </span><span class="s1">ai, aip, bi, bip;</span>

            <span class="s0">/* Test for x very close to n. Use expansion for transition region if so. */</span>
            <span class="s1">cbn = cbrt(n);</span>
            <span class="s1">z = (x - n) / cbn;</span>
            <span class="s2">if </span><span class="s1">(std::abs(z) &lt;= </span><span class="s5">0.7</span><span class="s1">) {</span>
                <span class="s2">return </span><span class="s1">(jv_jnt(n, x));</span>
            <span class="s1">}</span>

            <span class="s1">z = x / n;</span>
            <span class="s1">zz = </span><span class="s5">1.0 </span><span class="s1">- z * z;</span>
            <span class="s2">if </span><span class="s1">(zz == </span><span class="s5">0.0</span><span class="s1">) {</span>
                <span class="s2">return </span><span class="s1">(</span><span class="s5">0.0</span><span class="s1">);</span>
            <span class="s1">}</span>

            <span class="s2">if </span><span class="s1">(zz &gt; </span><span class="s5">0.0</span><span class="s1">) {</span>
                <span class="s1">sz = std::sqrt(zz);</span>
                <span class="s1">t = </span><span class="s5">1.5 </span><span class="s1">* (std::log((</span><span class="s5">1.0 </span><span class="s1">+ sz) / z) - sz); </span><span class="s0">/* zeta ** 3/2          */</span>
                <span class="s1">zeta = cbrt(t * t);</span>
                <span class="s1">nflg = </span><span class="s5">1</span><span class="s1">;</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s1">sz = std::sqrt(-zz);</span>
                <span class="s1">t = </span><span class="s5">1.5 </span><span class="s1">* (sz - std::acos(</span><span class="s5">1.0 </span><span class="s1">/ z));</span>
                <span class="s1">zeta = -cbrt(t * t);</span>
                <span class="s1">nflg = -</span><span class="s5">1</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s1">z32i = std::abs(</span><span class="s5">1.0 </span><span class="s1">/ t);</span>
            <span class="s1">sqz = cbrt(t);</span>

            <span class="s0">/* Airy function */</span>
            <span class="s1">n23 = cbrt(n * n);</span>
            <span class="s1">t = n23 * zeta;</span>

            <span class="s1">special::cephes::airy(t, &amp;ai, &amp;aip, &amp;bi, &amp;bip);</span>

            <span class="s0">/* polynomials in expansion */</span>
            <span class="s1">u[</span><span class="s5">0</span><span class="s1">] = </span><span class="s5">1.0</span><span class="s1">;</span>
            <span class="s1">zzi = </span><span class="s5">1.0 </span><span class="s1">/ zz;</span>
            <span class="s1">u[</span><span class="s5">1</span><span class="s1">] = special::cephes::polevl(zzi, jv_P1, </span><span class="s5">1</span><span class="s1">) / sz;</span>
            <span class="s1">u[</span><span class="s5">2</span><span class="s1">] = special::cephes::polevl(zzi, jv_P2, </span><span class="s5">2</span><span class="s1">) / zz;</span>
            <span class="s1">u[</span><span class="s5">3</span><span class="s1">] = special::cephes::polevl(zzi, jv_P3, </span><span class="s5">3</span><span class="s1">) / (sz * zz);</span>
            <span class="s1">pp = zz * zz;</span>
            <span class="s1">u[</span><span class="s5">4</span><span class="s1">] = special::cephes::polevl(zzi, jv_P4, </span><span class="s5">4</span><span class="s1">) / pp;</span>
            <span class="s1">u[</span><span class="s5">5</span><span class="s1">] = special::cephes::polevl(zzi, jv_P5, </span><span class="s5">5</span><span class="s1">) / (pp * sz);</span>
            <span class="s1">pp *= zz;</span>
            <span class="s1">u[</span><span class="s5">6</span><span class="s1">] = special::cephes::polevl(zzi, jv_P6, </span><span class="s5">6</span><span class="s1">) / pp;</span>
            <span class="s1">u[</span><span class="s5">7</span><span class="s1">] = special::cephes::polevl(zzi, jv_P7, </span><span class="s5">7</span><span class="s1">) / (pp * sz);</span>

            <span class="s1">pp = </span><span class="s5">0.0</span><span class="s1">;</span>
            <span class="s1">qq = </span><span class="s5">0.0</span><span class="s1">;</span>
            <span class="s1">np = </span><span class="s5">1.0</span><span class="s1">;</span>
            <span class="s0">/* flags to stop when terms get larger */</span>
            <span class="s1">doa = </span><span class="s5">1</span><span class="s1">;</span>
            <span class="s1">dob = </span><span class="s5">1</span><span class="s1">;</span>
            <span class="s1">akl = std::numeric_limits&lt;</span><span class="s2">double</span><span class="s1">&gt;::infinity();</span>
            <span class="s1">bkl = std::numeric_limits&lt;</span><span class="s2">double</span><span class="s1">&gt;::infinity();</span>

            <span class="s2">for </span><span class="s1">(k = </span><span class="s5">0</span><span class="s1">; k &lt;= </span><span class="s5">3</span><span class="s1">; k++) {</span>
                <span class="s1">tk = </span><span class="s5">2 </span><span class="s1">* k;</span>
                <span class="s1">tkp1 = tk + </span><span class="s5">1</span><span class="s1">;</span>
                <span class="s1">zp = </span><span class="s5">1.0</span><span class="s1">;</span>
                <span class="s1">ak = </span><span class="s5">0.0</span><span class="s1">;</span>
                <span class="s1">bk = </span><span class="s5">0.0</span><span class="s1">;</span>
                <span class="s2">for </span><span class="s1">(s = </span><span class="s5">0</span><span class="s1">; s &lt;= tk; s++) {</span>
                    <span class="s2">if </span><span class="s1">(doa) {</span>
                        <span class="s2">if </span><span class="s1">((s &amp; </span><span class="s5">3</span><span class="s1">) &gt; </span><span class="s5">1</span><span class="s1">)</span>
                            <span class="s1">sign = nflg;</span>
                        <span class="s2">else</span>
                            <span class="s1">sign = </span><span class="s5">1</span><span class="s1">;</span>
                        <span class="s1">ak += sign * jv_mu[s] * zp * u[tk - s];</span>
                    <span class="s1">}</span>

                    <span class="s2">if </span><span class="s1">(dob) {</span>
                        <span class="s1">m = tkp1 - s;</span>
                        <span class="s2">if </span><span class="s1">(((m + </span><span class="s5">1</span><span class="s1">) &amp; </span><span class="s5">3</span><span class="s1">) &gt; </span><span class="s5">1</span><span class="s1">)</span>
                            <span class="s1">sign = nflg;</span>
                        <span class="s2">else</span>
                            <span class="s1">sign = </span><span class="s5">1</span><span class="s1">;</span>
                        <span class="s1">bk += sign * jv_lambda[s] * zp * u[m];</span>
                    <span class="s1">}</span>
                    <span class="s1">zp *= z32i;</span>
                <span class="s1">}</span>

                <span class="s2">if </span><span class="s1">(doa) {</span>
                    <span class="s1">ak *= np;</span>
                    <span class="s1">t = std::abs(ak);</span>
                    <span class="s2">if </span><span class="s1">(t &lt; akl) {</span>
                        <span class="s1">akl = t;</span>
                        <span class="s1">pp += ak;</span>
                    <span class="s1">} </span><span class="s2">else</span>
                        <span class="s1">doa = </span><span class="s5">0</span><span class="s1">;</span>
                <span class="s1">}</span>

                <span class="s2">if </span><span class="s1">(dob) {</span>
                    <span class="s1">bk += jv_lambda[tkp1] * zp * u[</span><span class="s5">0</span><span class="s1">];</span>
                    <span class="s1">bk *= -np / sqz;</span>
                    <span class="s1">t = std::abs(bk);</span>
                    <span class="s2">if </span><span class="s1">(t &lt; bkl) {</span>
                        <span class="s1">bkl = t;</span>
                        <span class="s1">qq += bk;</span>
                    <span class="s1">} </span><span class="s2">else</span>
                        <span class="s1">dob = </span><span class="s5">0</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(np &lt; MACHEP)</span>
                    <span class="s2">break</span><span class="s1">;</span>
                <span class="s1">np /= n * n;</span>
            <span class="s1">}</span>

            <span class="s0">/* normalizing factor ( 4*zeta/(1 - z**2) )**1/4    */</span>
            <span class="s1">t = </span><span class="s5">4.0 </span><span class="s1">* zeta / zz;</span>
            <span class="s1">t = sqrt(sqrt(t));</span>

            <span class="s1">t *= ai * pp / cbrt(n) + aip * qq / (n23 * n);</span>
            <span class="s2">return </span><span class="s1">(t);</span>
        <span class="s1">}</span>

    <span class="s1">} </span><span class="s0">// namespace detail</span>

    <span class="s1">SPECFUN_HOST_DEVICE </span><span class="s4">inline </span><span class="s2">double </span><span class="s1">jv(</span><span class="s2">double </span><span class="s1">n, </span><span class="s2">double </span><span class="s1">x) {</span>
        <span class="s2">double </span><span class="s1">k, q, t, y, an;</span>
        <span class="s2">int </span><span class="s1">i, sign, nint;</span>

        <span class="s1">nint = </span><span class="s5">0</span><span class="s1">; </span><span class="s0">/* Flag for integer n */</span>
        <span class="s1">sign = </span><span class="s5">1</span><span class="s1">; </span><span class="s0">/* Flag for sign inversion */</span>
        <span class="s1">an = std::abs(n);</span>
        <span class="s1">y = std::floor(an);</span>
        <span class="s2">if </span><span class="s1">(y == an) {</span>
            <span class="s1">nint = </span><span class="s5">1</span><span class="s1">;</span>
            <span class="s1">i = an - </span><span class="s5">16384.0 </span><span class="s1">* std::floor(an / </span><span class="s5">16384.0</span><span class="s1">);</span>
            <span class="s2">if </span><span class="s1">(n &lt; </span><span class="s5">0.0</span><span class="s1">) {</span>
                <span class="s2">if </span><span class="s1">(i &amp; </span><span class="s5">1</span><span class="s1">)</span>
                    <span class="s1">sign = -sign;</span>
                <span class="s1">n = an;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(x &lt; </span><span class="s5">0.0</span><span class="s1">) {</span>
                <span class="s2">if </span><span class="s1">(i &amp; </span><span class="s5">1</span><span class="s1">)</span>
                    <span class="s1">sign = -sign;</span>
                <span class="s1">x = -x;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(n == </span><span class="s5">0.0</span><span class="s1">)</span>
                <span class="s2">return </span><span class="s1">(j0(x));</span>
            <span class="s2">if </span><span class="s1">(n == </span><span class="s5">1.0</span><span class="s1">)</span>
                <span class="s2">return </span><span class="s1">(sign * j1(x));</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">((x &lt; </span><span class="s5">0.0</span><span class="s1">) &amp;&amp; (y != an)) {</span>
            <span class="s1">set_error(</span><span class="s3">&quot;Jv&quot;</span><span class="s1">, SF_ERROR_DOMAIN, NULL);</span>
            <span class="s1">y = std::numeric_limits&lt;</span><span class="s2">double</span><span class="s1">&gt;::quiet_NaN();</span>
            <span class="s2">goto </span><span class="s1">done;</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">(x == </span><span class="s5">0 </span><span class="s1">&amp;&amp; n &lt; </span><span class="s5">0 </span><span class="s1">&amp;&amp; !nint) {</span>
            <span class="s1">set_error(</span><span class="s3">&quot;Jv&quot;</span><span class="s1">, SF_ERROR_OVERFLOW, NULL);</span>
            <span class="s2">return </span><span class="s1">std::numeric_limits&lt;</span><span class="s2">double</span><span class="s1">&gt;::infinity() / Gamma(n + </span><span class="s5">1</span><span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s1">y = std::abs(x);</span>

        <span class="s2">if </span><span class="s1">(y * y &lt; std::abs(n + </span><span class="s5">1</span><span class="s1">) * detail::MACHEP) {</span>
            <span class="s2">return </span><span class="s1">std::pow(</span><span class="s5">0.5 </span><span class="s1">* x, n) / Gamma(n + </span><span class="s5">1</span><span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s1">k = </span><span class="s5">3.6 </span><span class="s1">* std::sqrt(y);</span>
        <span class="s1">t = </span><span class="s5">3.6 </span><span class="s1">* std::sqrt(an);</span>
        <span class="s2">if </span><span class="s1">((y &lt; t) &amp;&amp; (an &gt; </span><span class="s5">21.0</span><span class="s1">)) {</span>
            <span class="s2">return </span><span class="s1">(sign * detail::jv_jvs(n, x));</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">((an &lt; k) &amp;&amp; (y &gt; </span><span class="s5">21.0</span><span class="s1">))</span>
            <span class="s2">return </span><span class="s1">(sign * detail::jv_hankel(n, x));</span>

        <span class="s2">if </span><span class="s1">(an &lt; </span><span class="s5">500.0</span><span class="s1">) {</span>
            <span class="s0">/* Note: if x is too large, the continued fraction will fail; but then the 
             * Hankel expansion can be used. */</span>
            <span class="s2">if </span><span class="s1">(nint != </span><span class="s5">0</span><span class="s1">) {</span>
                <span class="s1">k = </span><span class="s5">0.0</span><span class="s1">;</span>
                <span class="s1">q = detail::jv_recur(&amp;n, x, &amp;k, </span><span class="s5">1</span><span class="s1">);</span>
                <span class="s2">if </span><span class="s1">(k == </span><span class="s5">0.0</span><span class="s1">) {</span>
                    <span class="s1">y = j0(x) / q;</span>
                    <span class="s2">goto </span><span class="s1">done;</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(k == </span><span class="s5">1.0</span><span class="s1">) {</span>
                    <span class="s1">y = j1(x) / q;</span>
                    <span class="s2">goto </span><span class="s1">done;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>

            <span class="s2">if </span><span class="s1">(an &gt; </span><span class="s5">2.0 </span><span class="s1">* y)</span>
                <span class="s2">goto </span><span class="s1">rlarger;</span>

            <span class="s2">if </span><span class="s1">((n &gt;= </span><span class="s5">0.0</span><span class="s1">) &amp;&amp; (n &lt; </span><span class="s5">20.0</span><span class="s1">) &amp;&amp; (y &gt; </span><span class="s5">6.0</span><span class="s1">) &amp;&amp; (y &lt; </span><span class="s5">20.0</span><span class="s1">)) {</span>
                <span class="s0">/* Recur backwards from a larger value of n */</span>
            <span class="s1">rlarger:</span>
                <span class="s1">k = n;</span>

                <span class="s1">y = y + an + </span><span class="s5">1.0</span><span class="s1">;</span>
                <span class="s2">if </span><span class="s1">(y &lt; </span><span class="s5">30.0</span><span class="s1">)</span>
                    <span class="s1">y = </span><span class="s5">30.0</span><span class="s1">;</span>
                <span class="s1">y = n + std::floor(y - n);</span>
                <span class="s1">q = detail::jv_recur(&amp;y, x, &amp;k, </span><span class="s5">0</span><span class="s1">);</span>
                <span class="s1">y = detail::jv_jvs(y, x) * q;</span>
                <span class="s2">goto </span><span class="s1">done;</span>
            <span class="s1">}</span>

            <span class="s2">if </span><span class="s1">(k &lt;= </span><span class="s5">30.0</span><span class="s1">) {</span>
                <span class="s1">k = </span><span class="s5">2.0</span><span class="s1">;</span>
            <span class="s1">} </span><span class="s2">else if </span><span class="s1">(k &lt; </span><span class="s5">90.0</span><span class="s1">) {</span>
                <span class="s1">k = (</span><span class="s5">3 </span><span class="s1">* k) / </span><span class="s5">4</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(an &gt; (k + </span><span class="s5">3.0</span><span class="s1">)) {</span>
                <span class="s2">if </span><span class="s1">(n &lt; </span><span class="s5">0.0</span><span class="s1">) {</span>
                    <span class="s1">k = -k;</span>
                <span class="s1">}</span>
                <span class="s1">q = n - std::floor(n);</span>
                <span class="s1">k = std::floor(k) + q;</span>
                <span class="s2">if </span><span class="s1">(n &gt; </span><span class="s5">0.0</span><span class="s1">) {</span>
                    <span class="s1">q = detail::jv_recur(&amp;n, x, &amp;k, </span><span class="s5">1</span><span class="s1">);</span>
                <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">t = k;</span>
                    <span class="s1">k = n;</span>
                    <span class="s1">q = detail::jv_recur(&amp;t, x, &amp;k, </span><span class="s5">1</span><span class="s1">);</span>
                    <span class="s1">k = t;</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(q == </span><span class="s5">0.0</span><span class="s1">) {</span>
                    <span class="s1">y = </span><span class="s5">0.0</span><span class="s1">;</span>
                    <span class="s2">goto </span><span class="s1">done;</span>
                <span class="s1">}</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s1">k = n;</span>
                <span class="s1">q = </span><span class="s5">1.0</span><span class="s1">;</span>
            <span class="s1">}</span>

            <span class="s0">/* boundary between convergence of 
             * power series and Hankel expansion 
             */</span>
            <span class="s1">y = std::abs(k);</span>
            <span class="s2">if </span><span class="s1">(y &lt; </span><span class="s5">26.0</span><span class="s1">)</span>
                <span class="s1">t = (</span><span class="s5">0.0083 </span><span class="s1">* y + </span><span class="s5">0.09</span><span class="s1">) * y + </span><span class="s5">12.9</span><span class="s1">;</span>
            <span class="s2">else</span>
                <span class="s1">t = </span><span class="s5">0.9 </span><span class="s1">* y;</span>

            <span class="s2">if </span><span class="s1">(x &gt; t)</span>
                <span class="s1">y = detail::jv_hankel(k, x);</span>
            <span class="s2">else</span>
                <span class="s1">y = detail::jv_jvs(k, x);</span>
            <span class="s2">if </span><span class="s1">(n &gt; </span><span class="s5">0.0</span><span class="s1">)</span>
                <span class="s1">y /= q;</span>
            <span class="s2">else</span>
                <span class="s1">y *= q;</span>
        <span class="s1">}</span>

        <span class="s2">else </span><span class="s1">{</span>
            <span class="s0">/* For large n, use the uniform expansion or the transitional expansion. 
             * But if x is of the order of n**2, these may blow up, whereas the 
             * Hankel expansion will then work. 
             */</span>
            <span class="s2">if </span><span class="s1">(n &lt; </span><span class="s5">0.0</span><span class="s1">) {</span>
                <span class="s1">set_error(</span><span class="s3">&quot;jv&quot;</span><span class="s1">, SF_ERROR_LOSS, NULL);</span>
                <span class="s1">y = std::numeric_limits&lt;</span><span class="s2">double</span><span class="s1">&gt;::quiet_NaN();</span>
                <span class="s2">goto </span><span class="s1">done;</span>
            <span class="s1">}</span>
            <span class="s1">t = x / n;</span>
            <span class="s1">t /= n;</span>
            <span class="s2">if </span><span class="s1">(t &gt; </span><span class="s5">0.3</span><span class="s1">)</span>
                <span class="s1">y = detail::jv_hankel(n, x);</span>
            <span class="s2">else</span>
                <span class="s1">y = detail::jv_jnx(n, x);</span>
        <span class="s1">}</span>

    <span class="s1">done:</span>
        <span class="s2">return </span><span class="s1">(sign * y);</span>
    <span class="s1">}</span>

<span class="s1">} </span><span class="s0">// namespace cephes</span>
<span class="s1">} </span><span class="s0">// namespace special</span>
</pre>
</body>
</html>