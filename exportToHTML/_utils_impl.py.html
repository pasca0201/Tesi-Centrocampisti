<html>
<head>
<title>_utils_impl.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #6aab73;}
.s4 { color: #5f826b; font-style: italic;}
.s5 { color: #7a7e85;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_utils_impl.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">os</span>
<span class="s0">import </span><span class="s1">sys</span>
<span class="s0">import </span><span class="s1">textwrap</span>
<span class="s0">import </span><span class="s1">types</span>
<span class="s0">import </span><span class="s1">re</span>
<span class="s0">import </span><span class="s1">warnings</span>
<span class="s0">import </span><span class="s1">functools</span>
<span class="s0">import </span><span class="s1">platform</span>

<span class="s0">from </span><span class="s1">numpy</span><span class="s2">.</span><span class="s1">_core </span><span class="s0">import </span><span class="s1">ndarray</span>
<span class="s0">from </span><span class="s1">numpy</span><span class="s2">.</span><span class="s1">_utils </span><span class="s0">import </span><span class="s1">set_module</span>
<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>

<span class="s1">__all__ </span><span class="s2">= [</span>
    <span class="s3">'get_include'</span><span class="s2">, </span><span class="s3">'info'</span><span class="s2">, </span><span class="s3">'show_runtime'</span>
<span class="s2">]</span>


<span class="s2">@</span><span class="s1">set_module</span><span class="s2">(</span><span class="s3">'numpy'</span><span class="s2">)</span>
<span class="s0">def </span><span class="s1">show_runtime</span><span class="s2">():</span>
    <span class="s4">&quot;&quot;&quot; 
    Print information about various resources in the system 
    including available intrinsic support and BLAS/LAPACK library 
    in use 
 
    .. versionadded:: 1.24.0 
 
    See Also 
    -------- 
    show_config : Show libraries in the system on which NumPy was built. 
 
    Notes 
    ----- 
    1. Information is derived with the help of `threadpoolctl &lt;https://pypi.org/project/threadpoolctl/&gt;`_ 
       library if available. 
    2. SIMD related information is derived from ``__cpu_features__``, 
       ``__cpu_baseline__`` and ``__cpu_dispatch__`` 
 
    &quot;&quot;&quot;</span>
    <span class="s0">from </span><span class="s1">numpy</span><span class="s2">.</span><span class="s1">_core</span><span class="s2">.</span><span class="s1">_multiarray_umath </span><span class="s0">import </span><span class="s2">(</span>
        <span class="s1">__cpu_features__</span><span class="s2">, </span><span class="s1">__cpu_baseline__</span><span class="s2">, </span><span class="s1">__cpu_dispatch__</span>
    <span class="s2">)</span>
    <span class="s0">from </span><span class="s1">pprint </span><span class="s0">import </span><span class="s1">pprint</span>
    <span class="s1">config_found </span><span class="s2">= [{</span>
        <span class="s3">&quot;numpy_version&quot;</span><span class="s2">: </span><span class="s1">np</span><span class="s2">.</span><span class="s1">__version__</span><span class="s2">,</span>
        <span class="s3">&quot;python&quot;</span><span class="s2">: </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">version</span><span class="s2">,</span>
        <span class="s3">&quot;uname&quot;</span><span class="s2">: </span><span class="s1">platform</span><span class="s2">.</span><span class="s1">uname</span><span class="s2">(),</span>
        <span class="s2">}]</span>
    <span class="s1">features_found</span><span class="s2">, </span><span class="s1">features_not_found </span><span class="s2">= [], []</span>
    <span class="s0">for </span><span class="s1">feature </span><span class="s0">in </span><span class="s1">__cpu_dispatch__</span><span class="s2">:</span>
        <span class="s0">if </span><span class="s1">__cpu_features__</span><span class="s2">[</span><span class="s1">feature</span><span class="s2">]:</span>
            <span class="s1">features_found</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">feature</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">features_not_found</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">feature</span><span class="s2">)</span>
    <span class="s1">config_found</span><span class="s2">.</span><span class="s1">append</span><span class="s2">({</span>
        <span class="s3">&quot;simd_extensions&quot;</span><span class="s2">: {</span>
            <span class="s3">&quot;baseline&quot;</span><span class="s2">: </span><span class="s1">__cpu_baseline__</span><span class="s2">,</span>
            <span class="s3">&quot;found&quot;</span><span class="s2">: </span><span class="s1">features_found</span><span class="s2">,</span>
            <span class="s3">&quot;not_found&quot;</span><span class="s2">: </span><span class="s1">features_not_found</span>
        <span class="s2">}</span>
    <span class="s2">})</span>
    <span class="s0">try</span><span class="s2">:</span>
        <span class="s0">from </span><span class="s1">threadpoolctl </span><span class="s0">import </span><span class="s1">threadpool_info</span>
        <span class="s1">config_found</span><span class="s2">.</span><span class="s1">extend</span><span class="s2">(</span><span class="s1">threadpool_info</span><span class="s2">())</span>
    <span class="s0">except </span><span class="s1">ImportError</span><span class="s2">:</span>
        <span class="s1">print</span><span class="s2">(</span><span class="s3">&quot;WARNING: `threadpoolctl` not found in system!&quot;</span>
              <span class="s3">&quot; Install it by `pip install threadpoolctl`.&quot;</span>
              <span class="s3">&quot; Once installed, try `np.show_runtime` again&quot;</span>
              <span class="s3">&quot; for more detailed build information&quot;</span><span class="s2">)</span>
    <span class="s1">pprint</span><span class="s2">(</span><span class="s1">config_found</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">set_module</span><span class="s2">(</span><span class="s3">'numpy'</span><span class="s2">)</span>
<span class="s0">def </span><span class="s1">get_include</span><span class="s2">():</span>
    <span class="s4">&quot;&quot;&quot; 
    Return the directory that contains the NumPy \\*.h header files. 
 
    Extension modules that need to compile against NumPy may need to use this 
    function to locate the appropriate include directory. 
 
    Notes 
    ----- 
    When using ``setuptools``, for example in ``setup.py``:: 
 
        import numpy as np 
        ... 
        Extension('extension_name', ... 
                  include_dirs=[np.get_include()]) 
        ... 
 
    Note that a CLI tool ``numpy-config`` was introduced in NumPy 2.0, using 
    that is likely preferred for build systems other than ``setuptools``:: 
 
        $ numpy-config --cflags 
        -I/path/to/site-packages/numpy/_core/include 
 
        # Or rely on pkg-config: 
        $ export PKG_CONFIG_PATH=$(numpy-config --pkgconfigdir) 
        $ pkg-config --cflags 
        -I/path/to/site-packages/numpy/_core/include 
 
    Examples 
    -------- 
    &gt;&gt;&gt; np.get_include() 
    '.../site-packages/numpy/core/include'  # may vary 
 
    &quot;&quot;&quot;</span>
    <span class="s0">import </span><span class="s1">numpy</span>
    <span class="s0">if </span><span class="s1">numpy</span><span class="s2">.</span><span class="s1">show_config </span><span class="s0">is None</span><span class="s2">:</span>
        <span class="s5"># running from numpy source directory</span>
        <span class="s1">d </span><span class="s2">= </span><span class="s1">os</span><span class="s2">.</span><span class="s1">path</span><span class="s2">.</span><span class="s1">join</span><span class="s2">(</span><span class="s1">os</span><span class="s2">.</span><span class="s1">path</span><span class="s2">.</span><span class="s1">dirname</span><span class="s2">(</span><span class="s1">numpy</span><span class="s2">.</span><span class="s1">__file__</span><span class="s2">), </span><span class="s3">'_core'</span><span class="s2">, </span><span class="s3">'include'</span><span class="s2">)</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s5"># using installed numpy core headers</span>
        <span class="s0">import </span><span class="s1">numpy</span><span class="s2">.</span><span class="s1">_core </span><span class="s0">as </span><span class="s1">_core</span>
        <span class="s1">d </span><span class="s2">= </span><span class="s1">os</span><span class="s2">.</span><span class="s1">path</span><span class="s2">.</span><span class="s1">join</span><span class="s2">(</span><span class="s1">os</span><span class="s2">.</span><span class="s1">path</span><span class="s2">.</span><span class="s1">dirname</span><span class="s2">(</span><span class="s1">_core</span><span class="s2">.</span><span class="s1">__file__</span><span class="s2">), </span><span class="s3">'include'</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">d</span>


<span class="s0">class </span><span class="s1">_Deprecate</span><span class="s2">:</span>
    <span class="s4">&quot;&quot;&quot; 
    Decorator class to deprecate old functions. 
 
    Refer to `deprecate` for details. 
 
    See Also 
    -------- 
    deprecate 
 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">old_name</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">new_name</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">message</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">old_name </span><span class="s2">= </span><span class="s1">old_name</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">new_name </span><span class="s2">= </span><span class="s1">new_name</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">message </span><span class="s2">= </span><span class="s1">message</span>

    <span class="s0">def </span><span class="s1">__call__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">func</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Decorator call.  Refer to ``decorate``. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">old_name </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">old_name</span>
        <span class="s1">new_name </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">new_name</span>
        <span class="s1">message </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">message</span>

        <span class="s0">if </span><span class="s1">old_name </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s1">old_name </span><span class="s2">= </span><span class="s1">func</span><span class="s2">.</span><span class="s1">__name__</span>
        <span class="s0">if </span><span class="s1">new_name </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s1">depdoc </span><span class="s2">= </span><span class="s3">&quot;`%s` is deprecated!&quot; </span><span class="s2">% </span><span class="s1">old_name</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">depdoc </span><span class="s2">= </span><span class="s3">&quot;`%s` is deprecated, use `%s` instead!&quot; </span><span class="s2">% </span><span class="s1">\</span>
                     <span class="s2">(</span><span class="s1">old_name</span><span class="s2">, </span><span class="s1">new_name</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">message </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s1">depdoc </span><span class="s2">+= </span><span class="s3">&quot;</span><span class="s0">\n</span><span class="s3">&quot; </span><span class="s2">+ </span><span class="s1">message</span>

        <span class="s2">@</span><span class="s1">functools</span><span class="s2">.</span><span class="s1">wraps</span><span class="s2">(</span><span class="s1">func</span><span class="s2">)</span>
        <span class="s0">def </span><span class="s1">newfunc</span><span class="s2">(*</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwds</span><span class="s2">):</span>
            <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span><span class="s1">depdoc</span><span class="s2">, </span><span class="s1">DeprecationWarning</span><span class="s2">, </span><span class="s1">stacklevel</span><span class="s2">=</span><span class="s6">2</span><span class="s2">)</span>
            <span class="s0">return </span><span class="s1">func</span><span class="s2">(*</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwds</span><span class="s2">)</span>

        <span class="s1">newfunc</span><span class="s2">.</span><span class="s1">__name__ </span><span class="s2">= </span><span class="s1">old_name</span>
        <span class="s1">doc </span><span class="s2">= </span><span class="s1">func</span><span class="s2">.</span><span class="s1">__doc__</span>
        <span class="s0">if </span><span class="s1">doc </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s1">doc </span><span class="s2">= </span><span class="s1">depdoc</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">lines </span><span class="s2">= </span><span class="s1">doc</span><span class="s2">.</span><span class="s1">expandtabs</span><span class="s2">().</span><span class="s1">split</span><span class="s2">(</span><span class="s3">'</span><span class="s0">\n</span><span class="s3">'</span><span class="s2">)</span>
            <span class="s1">indent </span><span class="s2">= </span><span class="s1">_get_indent</span><span class="s2">(</span><span class="s1">lines</span><span class="s2">[</span><span class="s6">1</span><span class="s2">:])</span>
            <span class="s0">if </span><span class="s1">lines</span><span class="s2">[</span><span class="s6">0</span><span class="s2">].</span><span class="s1">lstrip</span><span class="s2">():</span>
                <span class="s5"># Indent the original first line to let inspect.cleandoc()</span>
                <span class="s5"># dedent the docstring despite the deprecation notice.</span>
                <span class="s1">doc </span><span class="s2">= </span><span class="s1">indent </span><span class="s2">* </span><span class="s3">' ' </span><span class="s2">+ </span><span class="s1">doc</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s5"># Remove the same leading blank lines as cleandoc() would.</span>
                <span class="s1">skip </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">lines</span><span class="s2">[</span><span class="s6">0</span><span class="s2">]) + </span><span class="s6">1</span>
                <span class="s0">for </span><span class="s1">line </span><span class="s0">in </span><span class="s1">lines</span><span class="s2">[</span><span class="s6">1</span><span class="s2">:]:</span>
                    <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">line</span><span class="s2">) &gt; </span><span class="s1">indent</span><span class="s2">:</span>
                        <span class="s0">break</span>
                    <span class="s1">skip </span><span class="s2">+= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">line</span><span class="s2">) + </span><span class="s6">1</span>
                <span class="s1">doc </span><span class="s2">= </span><span class="s1">doc</span><span class="s2">[</span><span class="s1">skip</span><span class="s2">:]</span>
            <span class="s1">depdoc </span><span class="s2">= </span><span class="s1">textwrap</span><span class="s2">.</span><span class="s1">indent</span><span class="s2">(</span><span class="s1">depdoc</span><span class="s2">, </span><span class="s3">' ' </span><span class="s2">* </span><span class="s1">indent</span><span class="s2">)</span>
            <span class="s1">doc </span><span class="s2">= </span><span class="s3">'</span><span class="s0">\n\n</span><span class="s3">'</span><span class="s2">.</span><span class="s1">join</span><span class="s2">([</span><span class="s1">depdoc</span><span class="s2">, </span><span class="s1">doc</span><span class="s2">])</span>
        <span class="s1">newfunc</span><span class="s2">.</span><span class="s1">__doc__ </span><span class="s2">= </span><span class="s1">doc</span>

        <span class="s0">return </span><span class="s1">newfunc</span>


<span class="s0">def </span><span class="s1">_get_indent</span><span class="s2">(</span><span class="s1">lines</span><span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot; 
    Determines the leading whitespace that could be removed from all the lines. 
    &quot;&quot;&quot;</span>
    <span class="s1">indent </span><span class="s2">= </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">maxsize</span>
    <span class="s0">for </span><span class="s1">line </span><span class="s0">in </span><span class="s1">lines</span><span class="s2">:</span>
        <span class="s1">content </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">line</span><span class="s2">.</span><span class="s1">lstrip</span><span class="s2">())</span>
        <span class="s0">if </span><span class="s1">content</span><span class="s2">:</span>
            <span class="s1">indent </span><span class="s2">= </span><span class="s1">min</span><span class="s2">(</span><span class="s1">indent</span><span class="s2">, </span><span class="s1">len</span><span class="s2">(</span><span class="s1">line</span><span class="s2">) - </span><span class="s1">content</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">indent </span><span class="s2">== </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">maxsize</span><span class="s2">:</span>
        <span class="s1">indent </span><span class="s2">= </span><span class="s6">0</span>
    <span class="s0">return </span><span class="s1">indent</span>


<span class="s0">def </span><span class="s1">deprecate</span><span class="s2">(*</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot; 
    Issues a DeprecationWarning, adds warning to `old_name`'s 
    docstring, rebinds ``old_name.__name__`` and returns the new 
    function object. 
 
    This function may also be used as a decorator. 
 
    .. deprecated:: 2.0 
        Use `~warnings.warn` with :exc:`DeprecationWarning` instead. 
 
    Parameters 
    ---------- 
    func : function 
        The function to be deprecated. 
    old_name : str, optional 
        The name of the function to be deprecated. Default is None, in 
        which case the name of `func` is used. 
    new_name : str, optional 
        The new name for the function. Default is None, in which case the 
        deprecation message is that `old_name` is deprecated. If given, the 
        deprecation message is that `old_name` is deprecated and `new_name` 
        should be used instead. 
    message : str, optional 
        Additional explanation of the deprecation.  Displayed in the 
        docstring after the warning. 
 
    Returns 
    ------- 
    old_func : function 
        The deprecated function. 
 
    Examples 
    -------- 
    Note that ``olduint`` returns a value after printing Deprecation 
    Warning: 
 
    &gt;&gt;&gt; olduint = np.lib.utils.deprecate(np.uint) 
    DeprecationWarning: `uint64` is deprecated! # may vary 
    &gt;&gt;&gt; olduint(6) 
    6 
 
    &quot;&quot;&quot;</span>
    <span class="s5"># Deprecate may be run as a function or as a decorator</span>
    <span class="s5"># If run as a function, we initialise the decorator class</span>
    <span class="s5"># and execute its __call__ method.</span>

    <span class="s5"># Deprecated in NumPy 2.0, 2023-07-11</span>
    <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span>
        <span class="s3">&quot;`deprecate` is deprecated, &quot;</span>
        <span class="s3">&quot;use `warn` with `DeprecationWarning` instead. &quot;</span>
        <span class="s3">&quot;(deprecated in NumPy 2.0)&quot;</span><span class="s2">,</span>
        <span class="s1">DeprecationWarning</span><span class="s2">,</span>
        <span class="s1">stacklevel</span><span class="s2">=</span><span class="s6">2</span>
    <span class="s2">)</span>

    <span class="s0">if </span><span class="s1">args</span><span class="s2">:</span>
        <span class="s1">fn </span><span class="s2">= </span><span class="s1">args</span><span class="s2">[</span><span class="s6">0</span><span class="s2">]</span>
        <span class="s1">args </span><span class="s2">= </span><span class="s1">args</span><span class="s2">[</span><span class="s6">1</span><span class="s2">:]</span>

        <span class="s0">return </span><span class="s1">_Deprecate</span><span class="s2">(*</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)(</span><span class="s1">fn</span><span class="s2">)</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">_Deprecate</span><span class="s2">(*</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">deprecate_with_doc</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot; 
    Deprecates a function and includes the deprecation in its docstring. 
 
    .. deprecated:: 2.0 
        Use `~warnings.warn` with :exc:`DeprecationWarning` instead. 
 
    This function is used as a decorator. It returns an object that can be 
    used to issue a DeprecationWarning, by passing the to-be decorated 
    function as argument, this adds warning to the to-be decorated function's 
    docstring and returns the new function object. 
 
    See Also 
    -------- 
    deprecate : Decorate a function such that it issues a 
                :exc:`DeprecationWarning` 
 
    Parameters 
    ---------- 
    msg : str 
        Additional explanation of the deprecation. Displayed in the 
        docstring after the warning. 
 
    Returns 
    ------- 
    obj : object 
 
    &quot;&quot;&quot;</span>

    <span class="s5"># Deprecated in NumPy 2.0, 2023-07-11</span>
    <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span>
        <span class="s3">&quot;`deprecate` is deprecated, &quot;</span>
        <span class="s3">&quot;use `warn` with `DeprecationWarning` instead. &quot;</span>
        <span class="s3">&quot;(deprecated in NumPy 2.0)&quot;</span><span class="s2">,</span>
        <span class="s1">DeprecationWarning</span><span class="s2">,</span>
        <span class="s1">stacklevel</span><span class="s2">=</span><span class="s6">2</span>
    <span class="s2">)</span>

    <span class="s0">return </span><span class="s1">_Deprecate</span><span class="s2">(</span><span class="s1">message</span><span class="s2">=</span><span class="s1">msg</span><span class="s2">)</span>


<span class="s5">#-----------------------------------------------------------------------------</span>


<span class="s5"># NOTE:  pydoc defines a help function which works similarly to this</span>
<span class="s5">#  except it uses a pager to take over the screen.</span>

<span class="s5"># combine name and arguments and split to multiple lines of width</span>
<span class="s5"># characters.  End lines on a comma and begin argument list indented with</span>
<span class="s5"># the rest of the arguments.</span>
<span class="s0">def </span><span class="s1">_split_line</span><span class="s2">(</span><span class="s1">name</span><span class="s2">, </span><span class="s1">arguments</span><span class="s2">, </span><span class="s1">width</span><span class="s2">):</span>
    <span class="s1">firstwidth </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">name</span><span class="s2">)</span>
    <span class="s1">k </span><span class="s2">= </span><span class="s1">firstwidth</span>
    <span class="s1">newstr </span><span class="s2">= </span><span class="s1">name</span>
    <span class="s1">sepstr </span><span class="s2">= </span><span class="s3">&quot;, &quot;</span>
    <span class="s1">arglist </span><span class="s2">= </span><span class="s1">arguments</span><span class="s2">.</span><span class="s1">split</span><span class="s2">(</span><span class="s1">sepstr</span><span class="s2">)</span>
    <span class="s0">for </span><span class="s1">argument </span><span class="s0">in </span><span class="s1">arglist</span><span class="s2">:</span>
        <span class="s0">if </span><span class="s1">k </span><span class="s2">== </span><span class="s1">firstwidth</span><span class="s2">:</span>
            <span class="s1">addstr </span><span class="s2">= </span><span class="s3">&quot;&quot;</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">addstr </span><span class="s2">= </span><span class="s1">sepstr</span>
        <span class="s1">k </span><span class="s2">= </span><span class="s1">k </span><span class="s2">+ </span><span class="s1">len</span><span class="s2">(</span><span class="s1">argument</span><span class="s2">) + </span><span class="s1">len</span><span class="s2">(</span><span class="s1">addstr</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">k </span><span class="s2">&gt; </span><span class="s1">width</span><span class="s2">:</span>
            <span class="s1">k </span><span class="s2">= </span><span class="s1">firstwidth </span><span class="s2">+ </span><span class="s6">1 </span><span class="s2">+ </span><span class="s1">len</span><span class="s2">(</span><span class="s1">argument</span><span class="s2">)</span>
            <span class="s1">newstr </span><span class="s2">= </span><span class="s1">newstr </span><span class="s2">+ </span><span class="s3">&quot;,</span><span class="s0">\n</span><span class="s3">&quot; </span><span class="s2">+ </span><span class="s3">&quot; &quot;</span><span class="s2">*(</span><span class="s1">firstwidth</span><span class="s2">+</span><span class="s6">2</span><span class="s2">) + </span><span class="s1">argument</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">newstr </span><span class="s2">= </span><span class="s1">newstr </span><span class="s2">+ </span><span class="s1">addstr </span><span class="s2">+ </span><span class="s1">argument</span>
    <span class="s0">return </span><span class="s1">newstr</span>

<span class="s1">_namedict </span><span class="s2">= </span><span class="s0">None</span>
<span class="s1">_dictlist </span><span class="s2">= </span><span class="s0">None</span>

<span class="s5"># Traverse all module directories underneath globals</span>
<span class="s5"># to see if something is defined</span>
<span class="s0">def </span><span class="s1">_makenamedict</span><span class="s2">(</span><span class="s1">module</span><span class="s2">=</span><span class="s3">'numpy'</span><span class="s2">):</span>
    <span class="s1">module </span><span class="s2">= </span><span class="s1">__import__</span><span class="s2">(</span><span class="s1">module</span><span class="s2">, </span><span class="s1">globals</span><span class="s2">(), </span><span class="s1">locals</span><span class="s2">(), [])</span>
    <span class="s1">thedict </span><span class="s2">= {</span><span class="s1">module</span><span class="s2">.</span><span class="s1">__name__</span><span class="s2">:</span><span class="s1">module</span><span class="s2">.</span><span class="s1">__dict__</span><span class="s2">}</span>
    <span class="s1">dictlist </span><span class="s2">= [</span><span class="s1">module</span><span class="s2">.</span><span class="s1">__name__</span><span class="s2">]</span>
    <span class="s1">totraverse </span><span class="s2">= [</span><span class="s1">module</span><span class="s2">.</span><span class="s1">__dict__</span><span class="s2">]</span>
    <span class="s0">while True</span><span class="s2">:</span>
        <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">totraverse</span><span class="s2">) == </span><span class="s6">0</span><span class="s2">:</span>
            <span class="s0">break</span>
        <span class="s1">thisdict </span><span class="s2">= </span><span class="s1">totraverse</span><span class="s2">.</span><span class="s1">pop</span><span class="s2">(</span><span class="s6">0</span><span class="s2">)</span>
        <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">thisdict</span><span class="s2">.</span><span class="s1">keys</span><span class="s2">():</span>
            <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">thisdict</span><span class="s2">[</span><span class="s1">x</span><span class="s2">], </span><span class="s1">types</span><span class="s2">.</span><span class="s1">ModuleType</span><span class="s2">):</span>
                <span class="s1">modname </span><span class="s2">= </span><span class="s1">thisdict</span><span class="s2">[</span><span class="s1">x</span><span class="s2">].</span><span class="s1">__name__</span>
                <span class="s0">if </span><span class="s1">modname </span><span class="s0">not in </span><span class="s1">dictlist</span><span class="s2">:</span>
                    <span class="s1">moddict </span><span class="s2">= </span><span class="s1">thisdict</span><span class="s2">[</span><span class="s1">x</span><span class="s2">].</span><span class="s1">__dict__</span>
                    <span class="s1">dictlist</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">modname</span><span class="s2">)</span>
                    <span class="s1">totraverse</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">moddict</span><span class="s2">)</span>
                    <span class="s1">thedict</span><span class="s2">[</span><span class="s1">modname</span><span class="s2">] = </span><span class="s1">moddict</span>
    <span class="s0">return </span><span class="s1">thedict</span><span class="s2">, </span><span class="s1">dictlist</span>


<span class="s0">def </span><span class="s1">_info</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">, </span><span class="s1">output</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot;Provide information about ndarray obj. 
 
    Parameters 
    ---------- 
    obj : ndarray 
        Must be ndarray, not checked. 
    output 
        Where printed output goes. 
 
    Notes 
    ----- 
    Copied over from the numarray module prior to its removal. 
    Adapted somewhat as only numpy is an option now. 
 
    Called by info. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">extra </span><span class="s2">= </span><span class="s3">&quot;&quot;</span>
    <span class="s1">tic </span><span class="s2">= </span><span class="s3">&quot;&quot;</span>
    <span class="s1">bp </span><span class="s2">= </span><span class="s0">lambda </span><span class="s1">x</span><span class="s2">: </span><span class="s1">x</span>
    <span class="s1">cls </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">, </span><span class="s3">'__class__'</span><span class="s2">, </span><span class="s1">type</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">))</span>
    <span class="s1">nm </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">, </span><span class="s3">'__name__'</span><span class="s2">, </span><span class="s1">cls</span><span class="s2">)</span>
    <span class="s1">strides </span><span class="s2">= </span><span class="s1">obj</span><span class="s2">.</span><span class="s1">strides</span>
    <span class="s1">endian </span><span class="s2">= </span><span class="s1">obj</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">byteorder</span>

    <span class="s0">if </span><span class="s1">output </span><span class="s0">is None</span><span class="s2">:</span>
        <span class="s1">output </span><span class="s2">= </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">stdout</span>

    <span class="s1">print</span><span class="s2">(</span><span class="s3">&quot;class: &quot;</span><span class="s2">, </span><span class="s1">nm</span><span class="s2">, </span><span class="s1">file</span><span class="s2">=</span><span class="s1">output</span><span class="s2">)</span>
    <span class="s1">print</span><span class="s2">(</span><span class="s3">&quot;shape: &quot;</span><span class="s2">, </span><span class="s1">obj</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">file</span><span class="s2">=</span><span class="s1">output</span><span class="s2">)</span>
    <span class="s1">print</span><span class="s2">(</span><span class="s3">&quot;strides: &quot;</span><span class="s2">, </span><span class="s1">strides</span><span class="s2">, </span><span class="s1">file</span><span class="s2">=</span><span class="s1">output</span><span class="s2">)</span>
    <span class="s1">print</span><span class="s2">(</span><span class="s3">&quot;itemsize: &quot;</span><span class="s2">, </span><span class="s1">obj</span><span class="s2">.</span><span class="s1">itemsize</span><span class="s2">, </span><span class="s1">file</span><span class="s2">=</span><span class="s1">output</span><span class="s2">)</span>
    <span class="s1">print</span><span class="s2">(</span><span class="s3">&quot;aligned: &quot;</span><span class="s2">, </span><span class="s1">bp</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">.</span><span class="s1">flags</span><span class="s2">.</span><span class="s1">aligned</span><span class="s2">), </span><span class="s1">file</span><span class="s2">=</span><span class="s1">output</span><span class="s2">)</span>
    <span class="s1">print</span><span class="s2">(</span><span class="s3">&quot;contiguous: &quot;</span><span class="s2">, </span><span class="s1">bp</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">.</span><span class="s1">flags</span><span class="s2">.</span><span class="s1">contiguous</span><span class="s2">), </span><span class="s1">file</span><span class="s2">=</span><span class="s1">output</span><span class="s2">)</span>
    <span class="s1">print</span><span class="s2">(</span><span class="s3">&quot;fortran: &quot;</span><span class="s2">, </span><span class="s1">obj</span><span class="s2">.</span><span class="s1">flags</span><span class="s2">.</span><span class="s1">fortran</span><span class="s2">, </span><span class="s1">file</span><span class="s2">=</span><span class="s1">output</span><span class="s2">)</span>
    <span class="s1">print</span><span class="s2">(</span>
        <span class="s3">&quot;data pointer: %s%s&quot; </span><span class="s2">% (</span><span class="s1">hex</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">.</span><span class="s1">ctypes</span><span class="s2">.</span><span class="s1">_as_parameter_</span><span class="s2">.</span><span class="s1">value</span><span class="s2">), </span><span class="s1">extra</span><span class="s2">),</span>
        <span class="s1">file</span><span class="s2">=</span><span class="s1">output</span>
        <span class="s2">)</span>
    <span class="s1">print</span><span class="s2">(</span><span class="s3">&quot;byteorder: &quot;</span><span class="s2">, </span><span class="s1">end</span><span class="s2">=</span><span class="s3">' '</span><span class="s2">, </span><span class="s1">file</span><span class="s2">=</span><span class="s1">output</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">endian </span><span class="s0">in </span><span class="s2">[</span><span class="s3">'|'</span><span class="s2">, </span><span class="s3">'='</span><span class="s2">]:</span>
        <span class="s1">print</span><span class="s2">(</span><span class="s3">&quot;%s%s%s&quot; </span><span class="s2">% (</span><span class="s1">tic</span><span class="s2">, </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">byteorder</span><span class="s2">, </span><span class="s1">tic</span><span class="s2">), </span><span class="s1">file</span><span class="s2">=</span><span class="s1">output</span><span class="s2">)</span>
        <span class="s1">byteswap </span><span class="s2">= </span><span class="s0">False</span>
    <span class="s0">elif </span><span class="s1">endian </span><span class="s2">== </span><span class="s3">'&gt;'</span><span class="s2">:</span>
        <span class="s1">print</span><span class="s2">(</span><span class="s3">&quot;%sbig%s&quot; </span><span class="s2">% (</span><span class="s1">tic</span><span class="s2">, </span><span class="s1">tic</span><span class="s2">), </span><span class="s1">file</span><span class="s2">=</span><span class="s1">output</span><span class="s2">)</span>
        <span class="s1">byteswap </span><span class="s2">= </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">byteorder </span><span class="s2">!= </span><span class="s3">&quot;big&quot;</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">print</span><span class="s2">(</span><span class="s3">&quot;%slittle%s&quot; </span><span class="s2">% (</span><span class="s1">tic</span><span class="s2">, </span><span class="s1">tic</span><span class="s2">), </span><span class="s1">file</span><span class="s2">=</span><span class="s1">output</span><span class="s2">)</span>
        <span class="s1">byteswap </span><span class="s2">= </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">byteorder </span><span class="s2">!= </span><span class="s3">&quot;little&quot;</span>
    <span class="s1">print</span><span class="s2">(</span><span class="s3">&quot;byteswap: &quot;</span><span class="s2">, </span><span class="s1">bp</span><span class="s2">(</span><span class="s1">byteswap</span><span class="s2">), </span><span class="s1">file</span><span class="s2">=</span><span class="s1">output</span><span class="s2">)</span>
    <span class="s1">print</span><span class="s2">(</span><span class="s3">&quot;type: %s&quot; </span><span class="s2">% </span><span class="s1">obj</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">file</span><span class="s2">=</span><span class="s1">output</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">set_module</span><span class="s2">(</span><span class="s3">'numpy'</span><span class="s2">)</span>
<span class="s0">def </span><span class="s1">info</span><span class="s2">(</span><span class="s1">object</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">maxwidth</span><span class="s2">=</span><span class="s6">76</span><span class="s2">, </span><span class="s1">output</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">toplevel</span><span class="s2">=</span><span class="s3">'numpy'</span><span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot; 
    Get help information for an array, function, class, or module. 
 
    Parameters 
    ---------- 
    object : object or str, optional 
        Input object or name to get information about. If `object` is 
        an `ndarray` instance, information about the array is printed. 
        If `object` is a numpy object, its docstring is given. If it is 
        a string, available modules are searched for matching objects. 
        If None, information about `info` itself is returned. 
    maxwidth : int, optional 
        Printing width. 
    output : file like object, optional 
        File like object that the output is written to, default is 
        ``None``, in which case ``sys.stdout`` will be used. 
        The object has to be opened in 'w' or 'a' mode. 
    toplevel : str, optional 
        Start search at this level. 
 
    Notes 
    ----- 
    When used interactively with an object, ``np.info(obj)`` is equivalent 
    to ``help(obj)`` on the Python prompt or ``obj?`` on the IPython 
    prompt. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; np.info(np.polyval) # doctest: +SKIP 
       polyval(p, x) 
         Evaluate the polynomial p at x. 
         ... 
 
    When using a string for `object` it is possible to get multiple results. 
 
    &gt;&gt;&gt; np.info('fft') # doctest: +SKIP 
         *** Found in numpy *** 
    Core FFT routines 
    ... 
         *** Found in numpy.fft *** 
     fft(a, n=None, axis=-1) 
    ... 
         *** Repeat reference found in numpy.fft.fftpack *** 
         *** Total of 3 references found. *** 
 
    When the argument is an array, information about the array is printed. 
 
    &gt;&gt;&gt; a = np.array([[1 + 2j, 3, -4], [-5j, 6, 0]], dtype=np.complex64) 
    &gt;&gt;&gt; np.info(a) 
    class:  ndarray 
    shape:  (2, 3) 
    strides:  (24, 8) 
    itemsize:  8 
    aligned:  True 
    contiguous:  True 
    fortran:  False 
    data pointer: 0x562b6e0d2860  # may vary 
    byteorder:  little 
    byteswap:  False 
    type: complex64 
 
    &quot;&quot;&quot;</span>
    <span class="s0">global </span><span class="s1">_namedict</span><span class="s2">, </span><span class="s1">_dictlist</span>
    <span class="s5"># Local import to speed up numpy's import time.</span>
    <span class="s0">import </span><span class="s1">pydoc</span>
    <span class="s0">import </span><span class="s1">inspect</span>

    <span class="s0">if </span><span class="s2">(</span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">object</span><span class="s2">, </span><span class="s3">'_ppimport_importer'</span><span class="s2">) </span><span class="s0">or</span>
           <span class="s1">hasattr</span><span class="s2">(</span><span class="s1">object</span><span class="s2">, </span><span class="s3">'_ppimport_module'</span><span class="s2">)):</span>
        <span class="s1">object </span><span class="s2">= </span><span class="s1">object</span><span class="s2">.</span><span class="s1">_ppimport_module</span>
    <span class="s0">elif </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">object</span><span class="s2">, </span><span class="s3">'_ppimport_attr'</span><span class="s2">):</span>
        <span class="s1">object </span><span class="s2">= </span><span class="s1">object</span><span class="s2">.</span><span class="s1">_ppimport_attr</span>

    <span class="s0">if </span><span class="s1">output </span><span class="s0">is None</span><span class="s2">:</span>
        <span class="s1">output </span><span class="s2">= </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">stdout</span>

    <span class="s0">if </span><span class="s1">object </span><span class="s0">is None</span><span class="s2">:</span>
        <span class="s1">info</span><span class="s2">(</span><span class="s1">info</span><span class="s2">)</span>
    <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">object</span><span class="s2">, </span><span class="s1">ndarray</span><span class="s2">):</span>
        <span class="s1">_info</span><span class="s2">(</span><span class="s1">object</span><span class="s2">, </span><span class="s1">output</span><span class="s2">=</span><span class="s1">output</span><span class="s2">)</span>
    <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">object</span><span class="s2">, </span><span class="s1">str</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">_namedict </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s1">_namedict</span><span class="s2">, </span><span class="s1">_dictlist </span><span class="s2">= </span><span class="s1">_makenamedict</span><span class="s2">(</span><span class="s1">toplevel</span><span class="s2">)</span>
        <span class="s1">numfound </span><span class="s2">= </span><span class="s6">0</span>
        <span class="s1">objlist </span><span class="s2">= []</span>
        <span class="s0">for </span><span class="s1">namestr </span><span class="s0">in </span><span class="s1">_dictlist</span><span class="s2">:</span>
            <span class="s0">try</span><span class="s2">:</span>
                <span class="s1">obj </span><span class="s2">= </span><span class="s1">_namedict</span><span class="s2">[</span><span class="s1">namestr</span><span class="s2">][</span><span class="s1">object</span><span class="s2">]</span>
                <span class="s0">if </span><span class="s1">id</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">) </span><span class="s0">in </span><span class="s1">objlist</span><span class="s2">:</span>
                    <span class="s1">print</span><span class="s2">(</span><span class="s3">&quot;</span><span class="s0">\n     </span><span class="s3">&quot;</span>
                          <span class="s3">&quot;*** Repeat reference found in %s *** &quot; </span><span class="s2">% </span><span class="s1">namestr</span><span class="s2">,</span>
                          <span class="s1">file</span><span class="s2">=</span><span class="s1">output</span>
                          <span class="s2">)</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s1">objlist</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">id</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">))</span>
                    <span class="s1">print</span><span class="s2">(</span><span class="s3">&quot;     *** Found in %s ***&quot; </span><span class="s2">% </span><span class="s1">namestr</span><span class="s2">, </span><span class="s1">file</span><span class="s2">=</span><span class="s1">output</span><span class="s2">)</span>
                    <span class="s1">info</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">)</span>
                    <span class="s1">print</span><span class="s2">(</span><span class="s3">&quot;-&quot;</span><span class="s2">*</span><span class="s1">maxwidth</span><span class="s2">, </span><span class="s1">file</span><span class="s2">=</span><span class="s1">output</span><span class="s2">)</span>
                <span class="s1">numfound </span><span class="s2">+= </span><span class="s6">1</span>
            <span class="s0">except </span><span class="s1">KeyError</span><span class="s2">:</span>
                <span class="s0">pass</span>
        <span class="s0">if </span><span class="s1">numfound </span><span class="s2">== </span><span class="s6">0</span><span class="s2">:</span>
            <span class="s1">print</span><span class="s2">(</span><span class="s3">&quot;Help for %s not found.&quot; </span><span class="s2">% </span><span class="s1">object</span><span class="s2">, </span><span class="s1">file</span><span class="s2">=</span><span class="s1">output</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">print</span><span class="s2">(</span><span class="s3">&quot;</span><span class="s0">\n     </span><span class="s3">&quot;</span>
                  <span class="s3">&quot;*** Total of %d references found. ***&quot; </span><span class="s2">% </span><span class="s1">numfound</span><span class="s2">,</span>
                  <span class="s1">file</span><span class="s2">=</span><span class="s1">output</span>
                  <span class="s2">)</span>

    <span class="s0">elif </span><span class="s1">inspect</span><span class="s2">.</span><span class="s1">isfunction</span><span class="s2">(</span><span class="s1">object</span><span class="s2">) </span><span class="s0">or </span><span class="s1">inspect</span><span class="s2">.</span><span class="s1">ismethod</span><span class="s2">(</span><span class="s1">object</span><span class="s2">):</span>
        <span class="s1">name </span><span class="s2">= </span><span class="s1">object</span><span class="s2">.</span><span class="s1">__name__</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s1">arguments </span><span class="s2">= </span><span class="s1">str</span><span class="s2">(</span><span class="s1">inspect</span><span class="s2">.</span><span class="s1">signature</span><span class="s2">(</span><span class="s1">object</span><span class="s2">))</span>
        <span class="s0">except </span><span class="s1">Exception</span><span class="s2">:</span>
            <span class="s1">arguments </span><span class="s2">= </span><span class="s3">&quot;()&quot;</span>

        <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">name</span><span class="s2">+</span><span class="s1">arguments</span><span class="s2">) &gt; </span><span class="s1">maxwidth</span><span class="s2">:</span>
            <span class="s1">argstr </span><span class="s2">= </span><span class="s1">_split_line</span><span class="s2">(</span><span class="s1">name</span><span class="s2">, </span><span class="s1">arguments</span><span class="s2">, </span><span class="s1">maxwidth</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">argstr </span><span class="s2">= </span><span class="s1">name </span><span class="s2">+ </span><span class="s1">arguments</span>

        <span class="s1">print</span><span class="s2">(</span><span class="s3">&quot; &quot; </span><span class="s2">+ </span><span class="s1">argstr </span><span class="s2">+ </span><span class="s3">&quot;</span><span class="s0">\n</span><span class="s3">&quot;</span><span class="s2">, </span><span class="s1">file</span><span class="s2">=</span><span class="s1">output</span><span class="s2">)</span>
        <span class="s1">print</span><span class="s2">(</span><span class="s1">inspect</span><span class="s2">.</span><span class="s1">getdoc</span><span class="s2">(</span><span class="s1">object</span><span class="s2">), </span><span class="s1">file</span><span class="s2">=</span><span class="s1">output</span><span class="s2">)</span>

    <span class="s0">elif </span><span class="s1">inspect</span><span class="s2">.</span><span class="s1">isclass</span><span class="s2">(</span><span class="s1">object</span><span class="s2">):</span>
        <span class="s1">name </span><span class="s2">= </span><span class="s1">object</span><span class="s2">.</span><span class="s1">__name__</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s1">arguments </span><span class="s2">= </span><span class="s1">str</span><span class="s2">(</span><span class="s1">inspect</span><span class="s2">.</span><span class="s1">signature</span><span class="s2">(</span><span class="s1">object</span><span class="s2">))</span>
        <span class="s0">except </span><span class="s1">Exception</span><span class="s2">:</span>
            <span class="s1">arguments </span><span class="s2">= </span><span class="s3">&quot;()&quot;</span>

        <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">name</span><span class="s2">+</span><span class="s1">arguments</span><span class="s2">) &gt; </span><span class="s1">maxwidth</span><span class="s2">:</span>
            <span class="s1">argstr </span><span class="s2">= </span><span class="s1">_split_line</span><span class="s2">(</span><span class="s1">name</span><span class="s2">, </span><span class="s1">arguments</span><span class="s2">, </span><span class="s1">maxwidth</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">argstr </span><span class="s2">= </span><span class="s1">name </span><span class="s2">+ </span><span class="s1">arguments</span>

        <span class="s1">print</span><span class="s2">(</span><span class="s3">&quot; &quot; </span><span class="s2">+ </span><span class="s1">argstr </span><span class="s2">+ </span><span class="s3">&quot;</span><span class="s0">\n</span><span class="s3">&quot;</span><span class="s2">, </span><span class="s1">file</span><span class="s2">=</span><span class="s1">output</span><span class="s2">)</span>
        <span class="s1">doc1 </span><span class="s2">= </span><span class="s1">inspect</span><span class="s2">.</span><span class="s1">getdoc</span><span class="s2">(</span><span class="s1">object</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">doc1 </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">object</span><span class="s2">, </span><span class="s3">'__init__'</span><span class="s2">):</span>
                <span class="s1">print</span><span class="s2">(</span><span class="s1">inspect</span><span class="s2">.</span><span class="s1">getdoc</span><span class="s2">(</span><span class="s1">object</span><span class="s2">.</span><span class="s1">__init__</span><span class="s2">), </span><span class="s1">file</span><span class="s2">=</span><span class="s1">output</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">print</span><span class="s2">(</span><span class="s1">inspect</span><span class="s2">.</span><span class="s1">getdoc</span><span class="s2">(</span><span class="s1">object</span><span class="s2">), </span><span class="s1">file</span><span class="s2">=</span><span class="s1">output</span><span class="s2">)</span>

        <span class="s1">methods </span><span class="s2">= </span><span class="s1">pydoc</span><span class="s2">.</span><span class="s1">allmethods</span><span class="s2">(</span><span class="s1">object</span><span class="s2">)</span>

        <span class="s1">public_methods </span><span class="s2">= [</span><span class="s1">meth </span><span class="s0">for </span><span class="s1">meth </span><span class="s0">in </span><span class="s1">methods </span><span class="s0">if </span><span class="s1">meth</span><span class="s2">[</span><span class="s6">0</span><span class="s2">] != </span><span class="s3">'_'</span><span class="s2">]</span>
        <span class="s0">if </span><span class="s1">public_methods</span><span class="s2">:</span>
            <span class="s1">print</span><span class="s2">(</span><span class="s3">&quot;</span><span class="s0">\n\n</span><span class="s3">Methods:</span><span class="s0">\n</span><span class="s3">&quot;</span><span class="s2">, </span><span class="s1">file</span><span class="s2">=</span><span class="s1">output</span><span class="s2">)</span>
            <span class="s0">for </span><span class="s1">meth </span><span class="s0">in </span><span class="s1">public_methods</span><span class="s2">:</span>
                <span class="s1">thisobj </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">object</span><span class="s2">, </span><span class="s1">meth</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>
                <span class="s0">if </span><span class="s1">thisobj </span><span class="s0">is not None</span><span class="s2">:</span>
                    <span class="s1">methstr</span><span class="s2">, </span><span class="s1">other </span><span class="s2">= </span><span class="s1">pydoc</span><span class="s2">.</span><span class="s1">splitdoc</span><span class="s2">(</span>
                            <span class="s1">inspect</span><span class="s2">.</span><span class="s1">getdoc</span><span class="s2">(</span><span class="s1">thisobj</span><span class="s2">) </span><span class="s0">or </span><span class="s3">&quot;None&quot;</span>
                            <span class="s2">)</span>
                <span class="s1">print</span><span class="s2">(</span><span class="s3">&quot;  %s  --  %s&quot; </span><span class="s2">% (</span><span class="s1">meth</span><span class="s2">, </span><span class="s1">methstr</span><span class="s2">), </span><span class="s1">file</span><span class="s2">=</span><span class="s1">output</span><span class="s2">)</span>

    <span class="s0">elif </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">object</span><span class="s2">, </span><span class="s3">'__doc__'</span><span class="s2">):</span>
        <span class="s1">print</span><span class="s2">(</span><span class="s1">inspect</span><span class="s2">.</span><span class="s1">getdoc</span><span class="s2">(</span><span class="s1">object</span><span class="s2">), </span><span class="s1">file</span><span class="s2">=</span><span class="s1">output</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">safe_eval</span><span class="s2">(</span><span class="s1">source</span><span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot; 
    Protected string evaluation. 
 
    .. deprecated:: 2.0 
        Use `ast.literal_eval` instead. 
 
    Evaluate a string containing a Python literal expression without 
    allowing the execution of arbitrary non-literal code. 
 
    .. warning:: 
 
        This function is identical to :py:meth:`ast.literal_eval` and 
        has the same security implications.  It may not always be safe 
        to evaluate large input strings. 
 
    Parameters 
    ---------- 
    source : str 
        The string to evaluate. 
 
    Returns 
    ------- 
    obj : object 
       The result of evaluating `source`. 
 
    Raises 
    ------ 
    SyntaxError 
        If the code has invalid Python syntax, or if it contains 
        non-literal code. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; np.safe_eval('1') 
    1 
    &gt;&gt;&gt; np.safe_eval('[1, 2, 3]') 
    [1, 2, 3] 
    &gt;&gt;&gt; np.safe_eval('{&quot;foo&quot;: (&quot;bar&quot;, 10.0)}') 
    {'foo': ('bar', 10.0)} 
 
    &gt;&gt;&gt; np.safe_eval('import os') 
    Traceback (most recent call last): 
      ... 
    SyntaxError: invalid syntax 
 
    &gt;&gt;&gt; np.safe_eval('open(&quot;/home/user/.ssh/id_dsa&quot;).read()') 
    Traceback (most recent call last): 
      ... 
    ValueError: malformed node or string: &lt;_ast.Call object at 0x...&gt; 
 
    &quot;&quot;&quot;</span>

    <span class="s5"># Deprecated in NumPy 2.0, 2023-07-11</span>
    <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span>
        <span class="s3">&quot;`safe_eval` is deprecated. Use `ast.literal_eval` instead. &quot;</span>
        <span class="s3">&quot;Be aware of security implications, such as memory exhaustion &quot;</span>
        <span class="s3">&quot;based attacks (deprecated in NumPy 2.0)&quot;</span><span class="s2">,</span>
        <span class="s1">DeprecationWarning</span><span class="s2">,</span>
        <span class="s1">stacklevel</span><span class="s2">=</span><span class="s6">2</span>
    <span class="s2">)</span>

    <span class="s5"># Local import to speed up numpy's import time.</span>
    <span class="s0">import </span><span class="s1">ast</span>
    <span class="s0">return </span><span class="s1">ast</span><span class="s2">.</span><span class="s1">literal_eval</span><span class="s2">(</span><span class="s1">source</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">_median_nancheck</span><span class="s2">(</span><span class="s1">data</span><span class="s2">, </span><span class="s1">result</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot; 
    Utility function to check median result from data for NaN values at the end 
    and return NaN in that case. Input result can also be a MaskedArray. 
 
    Parameters 
    ---------- 
    data : array 
        Sorted input data to median function 
    result : Array or MaskedArray 
        Result of median function. 
    axis : int 
        Axis along which the median was computed. 
 
    Returns 
    ------- 
    result : scalar or ndarray 
        Median or NaN in axes which contained NaN in the input.  If the input 
        was an array, NaN will be inserted in-place.  If a scalar, either the 
        input itself or a scalar NaN. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">data</span><span class="s2">.</span><span class="s1">size </span><span class="s2">== </span><span class="s6">0</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">result</span>
    <span class="s1">potential_nans </span><span class="s2">= </span><span class="s1">data</span><span class="s2">.</span><span class="s1">take</span><span class="s2">(-</span><span class="s6">1</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s1">axis</span><span class="s2">)</span>
    <span class="s1">n </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isnan</span><span class="s2">(</span><span class="s1">potential_nans</span><span class="s2">)</span>
    <span class="s5"># masked NaN values are ok, although for masked the copyto may fail for</span>
    <span class="s5"># unmasked ones (this was always broken) when the result is a scalar.</span>
    <span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ma</span><span class="s2">.</span><span class="s1">isMaskedArray</span><span class="s2">(</span><span class="s1">n</span><span class="s2">):</span>
        <span class="s1">n </span><span class="s2">= </span><span class="s1">n</span><span class="s2">.</span><span class="s1">filled</span><span class="s2">(</span><span class="s0">False</span><span class="s2">)</span>

    <span class="s0">if not </span><span class="s1">n</span><span class="s2">.</span><span class="s1">any</span><span class="s2">():</span>
        <span class="s0">return </span><span class="s1">result</span>

    <span class="s5"># Without given output, it is possible that the current result is a</span>
    <span class="s5"># numpy scalar, which is not writeable.  If so, just return nan.</span>
    <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">result</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">generic</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">potential_nans</span>

    <span class="s5"># Otherwise copy NaNs (if there are any)</span>
    <span class="s1">np</span><span class="s2">.</span><span class="s1">copyto</span><span class="s2">(</span><span class="s1">result</span><span class="s2">, </span><span class="s1">potential_nans</span><span class="s2">, </span><span class="s1">where</span><span class="s2">=</span><span class="s1">n</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">result</span>

<span class="s0">def </span><span class="s1">_opt_info</span><span class="s2">():</span>
    <span class="s4">&quot;&quot;&quot; 
    Returns a string containing the CPU features supported 
    by the current build. 
 
    The format of the string can be explained as follows: 
        - Dispatched features supported by the running machine end with `*`. 
        - Dispatched features not supported by the running machine 
          end with `?`. 
        - Remaining features represent the baseline. 
 
    Returns: 
        str: A formatted string indicating the supported CPU features. 
    &quot;&quot;&quot;</span>
    <span class="s0">from </span><span class="s1">numpy</span><span class="s2">.</span><span class="s1">_core</span><span class="s2">.</span><span class="s1">_multiarray_umath </span><span class="s0">import </span><span class="s2">(</span>
        <span class="s1">__cpu_features__</span><span class="s2">, </span><span class="s1">__cpu_baseline__</span><span class="s2">, </span><span class="s1">__cpu_dispatch__</span>
    <span class="s2">)</span>

    <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">__cpu_baseline__</span><span class="s2">) == </span><span class="s6">0 </span><span class="s0">and </span><span class="s1">len</span><span class="s2">(</span><span class="s1">__cpu_dispatch__</span><span class="s2">) == </span><span class="s6">0</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s3">''</span>

    <span class="s1">enabled_features </span><span class="s2">= </span><span class="s3">' '</span><span class="s2">.</span><span class="s1">join</span><span class="s2">(</span><span class="s1">__cpu_baseline__</span><span class="s2">)</span>
    <span class="s0">for </span><span class="s1">feature </span><span class="s0">in </span><span class="s1">__cpu_dispatch__</span><span class="s2">:</span>
        <span class="s0">if </span><span class="s1">__cpu_features__</span><span class="s2">[</span><span class="s1">feature</span><span class="s2">]:</span>
            <span class="s1">enabled_features </span><span class="s2">+= </span><span class="s3">f&quot; </span><span class="s0">{</span><span class="s1">feature</span><span class="s0">}</span><span class="s3">*&quot;</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">enabled_features </span><span class="s2">+= </span><span class="s3">f&quot; </span><span class="s0">{</span><span class="s1">feature</span><span class="s0">}</span><span class="s3">?&quot;</span>

    <span class="s0">return </span><span class="s1">enabled_features</span>

<span class="s0">def </span><span class="s1">drop_metadata</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">, /):</span>
    <span class="s4">&quot;&quot;&quot; 
    Returns the dtype unchanged if it contained no metadata or a copy of the 
    dtype if it (or any of its structure dtypes) contained metadata. 
 
    This utility is used by `np.save` and `np.savez` to drop metadata before 
    saving. 
 
    .. note:: 
 
        Due to its limitation this function may move to a more appropriate 
        home or change in the future and is considered semi-public API only. 
 
    .. warning:: 
 
        This function does not preserve more strange things like record dtypes 
        and user dtypes may simply return the wrong thing.  If you need to be 
        sure about the latter, check the result with: 
        ``np.can_cast(new_dtype, dtype, casting=&quot;no&quot;)``. 
 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">fields </span><span class="s0">is not None</span><span class="s2">:</span>
        <span class="s1">found_metadata </span><span class="s2">= </span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">metadata </span><span class="s0">is not None</span>

        <span class="s1">names </span><span class="s2">= []</span>
        <span class="s1">formats </span><span class="s2">= []</span>
        <span class="s1">offsets </span><span class="s2">= []</span>
        <span class="s1">titles </span><span class="s2">= []</span>
        <span class="s0">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">field </span><span class="s0">in </span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">fields</span><span class="s2">.</span><span class="s1">items</span><span class="s2">():</span>
            <span class="s1">field_dt </span><span class="s2">= </span><span class="s1">drop_metadata</span><span class="s2">(</span><span class="s1">field</span><span class="s2">[</span><span class="s6">0</span><span class="s2">])</span>
            <span class="s0">if </span><span class="s1">field_dt </span><span class="s0">is not </span><span class="s1">field</span><span class="s2">[</span><span class="s6">0</span><span class="s2">]:</span>
                <span class="s1">found_metadata </span><span class="s2">= </span><span class="s0">True</span>

            <span class="s1">names</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">name</span><span class="s2">)</span>
            <span class="s1">formats</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">field_dt</span><span class="s2">)</span>
            <span class="s1">offsets</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">field</span><span class="s2">[</span><span class="s6">1</span><span class="s2">])</span>
            <span class="s1">titles</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s0">None if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">field</span><span class="s2">) &lt; </span><span class="s6">3 </span><span class="s0">else </span><span class="s1">field</span><span class="s2">[</span><span class="s6">2</span><span class="s2">])</span>

        <span class="s0">if not </span><span class="s1">found_metadata</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">dtype</span>

        <span class="s1">structure </span><span class="s2">= </span><span class="s1">dict</span><span class="s2">(</span>
            <span class="s1">names</span><span class="s2">=</span><span class="s1">names</span><span class="s2">, </span><span class="s1">formats</span><span class="s2">=</span><span class="s1">formats</span><span class="s2">, </span><span class="s1">offsets</span><span class="s2">=</span><span class="s1">offsets</span><span class="s2">, </span><span class="s1">titles</span><span class="s2">=</span><span class="s1">titles</span><span class="s2">,</span>
            <span class="s1">itemsize</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">itemsize</span><span class="s2">)</span>

        <span class="s5"># NOTE: Could pass (dtype.type, structure) to preserve record dtypes...</span>
        <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">(</span><span class="s1">structure</span><span class="s2">, </span><span class="s1">align</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">isalignedstruct</span><span class="s2">)</span>
    <span class="s0">elif </span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">subdtype </span><span class="s0">is not None</span><span class="s2">:</span>
        <span class="s5"># subarray dtype</span>
        <span class="s1">subdtype</span><span class="s2">, </span><span class="s1">shape </span><span class="s2">= </span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">subdtype</span>
        <span class="s1">new_subdtype </span><span class="s2">= </span><span class="s1">drop_metadata</span><span class="s2">(</span><span class="s1">subdtype</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">metadata </span><span class="s0">is None and </span><span class="s1">new_subdtype </span><span class="s0">is </span><span class="s1">subdtype</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">dtype</span>

        <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">((</span><span class="s1">new_subdtype</span><span class="s2">, </span><span class="s1">shape</span><span class="s2">))</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s5"># Normal unstructured dtype</span>
        <span class="s0">if </span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">metadata </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">dtype</span>
        <span class="s5"># Note that `dt.str` doesn't round-trip e.g. for user-dtypes.</span>
        <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">str</span><span class="s2">)</span>
</pre>
</body>
</html>