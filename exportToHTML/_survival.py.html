<html>
<head>
<title>_survival.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #6aab73;}
.s4 { color: #5f826b; font-style: italic;}
.s5 { color: #7a7e85;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_survival.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">__future__ </span><span class="s0">import </span><span class="s1">annotations</span>

<span class="s0">from </span><span class="s1">dataclasses </span><span class="s0">import </span><span class="s1">dataclass</span><span class="s2">, </span><span class="s1">field</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">TYPE_CHECKING</span>
<span class="s0">import </span><span class="s1">warnings</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">from </span><span class="s1">scipy </span><span class="s0">import </span><span class="s1">special</span><span class="s2">, </span><span class="s1">interpolate</span><span class="s2">, </span><span class="s1">stats</span>
<span class="s0">from </span><span class="s1">scipy</span><span class="s2">.</span><span class="s1">stats</span><span class="s2">.</span><span class="s1">_censored_data </span><span class="s0">import </span><span class="s1">CensoredData</span>
<span class="s0">from </span><span class="s1">scipy</span><span class="s2">.</span><span class="s1">stats</span><span class="s2">.</span><span class="s1">_common </span><span class="s0">import </span><span class="s1">ConfidenceInterval</span>

<span class="s0">if </span><span class="s1">TYPE_CHECKING</span><span class="s2">:</span>
    <span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Literal</span>
    <span class="s0">import </span><span class="s1">numpy</span><span class="s2">.</span><span class="s1">typing </span><span class="s0">as </span><span class="s1">npt</span>


<span class="s1">__all__ </span><span class="s2">= [</span><span class="s3">'ecdf'</span><span class="s2">, </span><span class="s3">'logrank'</span><span class="s2">]</span>


<span class="s2">@</span><span class="s1">dataclass</span>
<span class="s0">class </span><span class="s1">EmpiricalDistributionFunction</span><span class="s2">:</span>
    <span class="s4">&quot;&quot;&quot;An empirical distribution function produced by `scipy.stats.ecdf` 
 
    Attributes 
    ---------- 
    quantiles : ndarray 
        The unique values of the sample from which the 
        `EmpiricalDistributionFunction` was estimated. 
    probabilities : ndarray 
        The point estimates of the cumulative distribution function (CDF) or 
        its complement, the survival function (SF), corresponding with 
        `quantiles`. 
    &quot;&quot;&quot;</span>
    <span class="s1">quantiles</span><span class="s2">: </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span>
    <span class="s1">probabilities</span><span class="s2">: </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span>
    <span class="s5"># Exclude these from __str__</span>
    <span class="s1">_n</span><span class="s2">: </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray </span><span class="s2">= </span><span class="s1">field</span><span class="s2">(</span><span class="s1">repr</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)  </span><span class="s5"># number &quot;at risk&quot;</span>
    <span class="s1">_d</span><span class="s2">: </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray </span><span class="s2">= </span><span class="s1">field</span><span class="s2">(</span><span class="s1">repr</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)  </span><span class="s5"># number of &quot;deaths&quot;</span>
    <span class="s1">_sf</span><span class="s2">: </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray </span><span class="s2">= </span><span class="s1">field</span><span class="s2">(</span><span class="s1">repr</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)  </span><span class="s5"># survival function for var estimate</span>
    <span class="s1">_kind</span><span class="s2">: </span><span class="s1">str </span><span class="s2">= </span><span class="s1">field</span><span class="s2">(</span><span class="s1">repr</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)  </span><span class="s5"># type of function: &quot;cdf&quot; or &quot;sf&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">q</span><span class="s2">, </span><span class="s1">p</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">d</span><span class="s2">, </span><span class="s1">kind</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">probabilities </span><span class="s2">= </span><span class="s1">p</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">quantiles </span><span class="s2">= </span><span class="s1">q</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_n </span><span class="s2">= </span><span class="s1">n</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_d </span><span class="s2">= </span><span class="s1">d</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_sf </span><span class="s2">= </span><span class="s1">p </span><span class="s0">if </span><span class="s1">kind </span><span class="s2">== </span><span class="s3">'sf' </span><span class="s0">else </span><span class="s6">1 </span><span class="s2">- </span><span class="s1">p</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_kind </span><span class="s2">= </span><span class="s1">kind</span>

        <span class="s1">f0 </span><span class="s2">= </span><span class="s6">1 </span><span class="s0">if </span><span class="s1">kind </span><span class="s2">== </span><span class="s3">'sf' </span><span class="s0">else </span><span class="s6">0  </span><span class="s5"># leftmost function value</span>
        <span class="s1">f1 </span><span class="s2">= </span><span class="s6">1 </span><span class="s2">- </span><span class="s1">f0</span>
        <span class="s5"># fill_value can't handle edge cases at infinity</span>
        <span class="s1">x </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">insert</span><span class="s2">(</span><span class="s1">q</span><span class="s2">, [</span><span class="s6">0</span><span class="s2">, </span><span class="s1">len</span><span class="s2">(</span><span class="s1">q</span><span class="s2">)], [-</span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span><span class="s2">])</span>
        <span class="s1">y </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">insert</span><span class="s2">(</span><span class="s1">p</span><span class="s2">, [</span><span class="s6">0</span><span class="s2">, </span><span class="s1">len</span><span class="s2">(</span><span class="s1">p</span><span class="s2">)], [</span><span class="s1">f0</span><span class="s2">, </span><span class="s1">f1</span><span class="s2">])</span>
        <span class="s5"># `or` conditions handle the case of empty x, points</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_f </span><span class="s2">= </span><span class="s1">interpolate</span><span class="s2">.</span><span class="s1">interp1d</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">kind</span><span class="s2">=</span><span class="s3">'previous'</span><span class="s2">,</span>
                                       <span class="s1">assume_sorted</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">evaluate</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot;Evaluate the empirical CDF/SF function at the input. 
 
        Parameters 
        ---------- 
        x : ndarray 
            Argument to the CDF/SF 
 
        Returns 
        ------- 
        y : ndarray 
            The CDF/SF evaluated at the input 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_f</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">plot</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">ax</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, **</span><span class="s1">matplotlib_kwargs</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot;Plot the empirical distribution function 
 
        Available only if ``matplotlib`` is installed. 
 
        Parameters 
        ---------- 
        ax : matplotlib.axes.Axes 
            Axes object to draw the plot onto, otherwise uses the current Axes. 
 
        **matplotlib_kwargs : dict, optional 
            Keyword arguments passed directly to `matplotlib.axes.Axes.step`. 
            Unless overridden, ``where='post'``. 
 
        Returns 
        ------- 
        lines : list of `matplotlib.lines.Line2D` 
            Objects representing the plotted data 
        &quot;&quot;&quot;</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s0">import </span><span class="s1">matplotlib  </span><span class="s5"># noqa: F401</span>
        <span class="s0">except </span><span class="s1">ModuleNotFoundError </span><span class="s0">as </span><span class="s1">exc</span><span class="s2">:</span>
            <span class="s1">message </span><span class="s2">= </span><span class="s3">&quot;matplotlib must be installed to use method `plot`.&quot;</span>
            <span class="s0">raise </span><span class="s1">ModuleNotFoundError</span><span class="s2">(</span><span class="s1">message</span><span class="s2">) </span><span class="s0">from </span><span class="s1">exc</span>

        <span class="s0">if </span><span class="s1">ax </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s0">import </span><span class="s1">matplotlib</span><span class="s2">.</span><span class="s1">pyplot </span><span class="s0">as </span><span class="s1">plt</span>
            <span class="s1">ax </span><span class="s2">= </span><span class="s1">plt</span><span class="s2">.</span><span class="s1">gca</span><span class="s2">()</span>

        <span class="s1">kwargs </span><span class="s2">= {</span><span class="s3">'where'</span><span class="s2">: </span><span class="s3">'post'</span><span class="s2">}</span>
        <span class="s1">kwargs</span><span class="s2">.</span><span class="s1">update</span><span class="s2">(</span><span class="s1">matplotlib_kwargs</span><span class="s2">)</span>

        <span class="s1">delta </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ptp</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">quantiles</span><span class="s2">)*</span><span class="s6">0.05  </span><span class="s5"># how far past sample edge to plot</span>
        <span class="s1">q </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">quantiles</span>
        <span class="s1">q </span><span class="s2">= [</span><span class="s1">q</span><span class="s2">[</span><span class="s6">0</span><span class="s2">] - </span><span class="s1">delta</span><span class="s2">] + </span><span class="s1">list</span><span class="s2">(</span><span class="s1">q</span><span class="s2">) + [</span><span class="s1">q</span><span class="s2">[-</span><span class="s6">1</span><span class="s2">] + </span><span class="s1">delta</span><span class="s2">]</span>

        <span class="s0">return </span><span class="s1">ax</span><span class="s2">.</span><span class="s1">step</span><span class="s2">(</span><span class="s1">q</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">evaluate</span><span class="s2">(</span><span class="s1">q</span><span class="s2">), **</span><span class="s1">kwargs</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">confidence_interval</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">confidence_level</span><span class="s2">=</span><span class="s6">0.95</span><span class="s2">, *, </span><span class="s1">method</span><span class="s2">=</span><span class="s3">'linear'</span><span class="s2">):</span>
        <span class="s4">&quot;&quot;&quot;Compute a confidence interval around the CDF/SF point estimate 
 
        Parameters 
        ---------- 
        confidence_level : float, default: 0.95 
            Confidence level for the computed confidence interval 
 
        method : str, {&quot;linear&quot;, &quot;log-log&quot;} 
            Method used to compute the confidence interval. Options are 
            &quot;linear&quot; for the conventional Greenwood confidence interval 
            (default)  and &quot;log-log&quot; for the &quot;exponential Greenwood&quot;, 
            log-negative-log-transformed confidence interval. 
 
        Returns 
        ------- 
        ci : ``ConfidenceInterval`` 
            An object with attributes ``low`` and ``high``, instances of 
            `~scipy.stats._result_classes.EmpiricalDistributionFunction` that 
            represent the lower and upper bounds (respectively) of the 
            confidence interval. 
 
        Notes 
        ----- 
        Confidence intervals are computed according to the Greenwood formula 
        (``method='linear'``) or the more recent &quot;exponential Greenwood&quot; 
        formula (``method='log-log'``) as described in [1]_. The conventional 
        Greenwood formula can result in lower confidence limits less than 0 
        and upper confidence limits greater than 1; these are clipped to the 
        unit interval. NaNs may be produced by either method; these are 
        features of the formulas. 
 
        References 
        ---------- 
        .. [1] Sawyer, Stanley. &quot;The Greenwood and Exponential Greenwood 
               Confidence Intervals in Survival Analysis.&quot; 
               https://www.math.wustl.edu/~sawyer/handouts/greenwood.pdf 
 
        &quot;&quot;&quot;</span>
        <span class="s1">message </span><span class="s2">= (</span><span class="s3">&quot;Confidence interval bounds do not implement a &quot;</span>
                   <span class="s3">&quot;`confidence_interval` method.&quot;</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_n </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">NotImplementedError</span><span class="s2">(</span><span class="s1">message</span><span class="s2">)</span>

        <span class="s1">methods </span><span class="s2">= {</span><span class="s3">'linear'</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_linear_ci</span><span class="s2">,</span>
                   <span class="s3">'log-log'</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_loglog_ci</span><span class="s2">}</span>

        <span class="s1">message </span><span class="s2">= </span><span class="s3">f&quot;`method` must be one of </span><span class="s0">{</span><span class="s1">set</span><span class="s2">(</span><span class="s1">methods</span><span class="s2">)</span><span class="s0">}</span><span class="s3">.&quot;</span>
        <span class="s0">if </span><span class="s1">method</span><span class="s2">.</span><span class="s1">lower</span><span class="s2">() </span><span class="s0">not in </span><span class="s1">methods</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s1">message</span><span class="s2">)</span>

        <span class="s1">message </span><span class="s2">= </span><span class="s3">&quot;`confidence_level` must be a scalar between 0 and 1.&quot;</span>
        <span class="s1">confidence_level </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">confidence_level</span><span class="s2">)[()]</span>
        <span class="s0">if </span><span class="s1">confidence_level</span><span class="s2">.</span><span class="s1">shape </span><span class="s0">or not </span><span class="s2">(</span><span class="s6">0 </span><span class="s2">&lt;= </span><span class="s1">confidence_level </span><span class="s2">&lt;= </span><span class="s6">1</span><span class="s2">):</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s1">message</span><span class="s2">)</span>

        <span class="s1">method_fun </span><span class="s2">= </span><span class="s1">methods</span><span class="s2">[</span><span class="s1">method</span><span class="s2">.</span><span class="s1">lower</span><span class="s2">()]</span>
        <span class="s1">low</span><span class="s2">, </span><span class="s1">high </span><span class="s2">= </span><span class="s1">method_fun</span><span class="s2">(</span><span class="s1">confidence_level</span><span class="s2">)</span>

        <span class="s1">message </span><span class="s2">= (</span><span class="s3">&quot;The confidence interval is undefined at some observations.&quot;</span>
                   <span class="s3">&quot; This is a feature of the mathematical formula used, not&quot;</span>
                   <span class="s3">&quot; an error in its implementation.&quot;</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">any</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">isnan</span><span class="s2">(</span><span class="s1">low</span><span class="s2">) | </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isnan</span><span class="s2">(</span><span class="s1">high</span><span class="s2">)):</span>
            <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span><span class="s1">message</span><span class="s2">, </span><span class="s1">RuntimeWarning</span><span class="s2">, </span><span class="s1">stacklevel</span><span class="s2">=</span><span class="s6">2</span><span class="s2">)</span>

        <span class="s1">low</span><span class="s2">, </span><span class="s1">high </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">clip</span><span class="s2">(</span><span class="s1">low</span><span class="s2">, </span><span class="s6">0</span><span class="s2">, </span><span class="s6">1</span><span class="s2">), </span><span class="s1">np</span><span class="s2">.</span><span class="s1">clip</span><span class="s2">(</span><span class="s1">high</span><span class="s2">, </span><span class="s6">0</span><span class="s2">, </span><span class="s6">1</span><span class="s2">)</span>
        <span class="s1">low </span><span class="s2">= </span><span class="s1">EmpiricalDistributionFunction</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">quantiles</span><span class="s2">, </span><span class="s1">low</span><span class="s2">, </span><span class="s0">None</span><span class="s2">, </span><span class="s0">None</span><span class="s2">,</span>
                                            <span class="s1">self</span><span class="s2">.</span><span class="s1">_kind</span><span class="s2">)</span>
        <span class="s1">high </span><span class="s2">= </span><span class="s1">EmpiricalDistributionFunction</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">quantiles</span><span class="s2">, </span><span class="s1">high</span><span class="s2">, </span><span class="s0">None</span><span class="s2">, </span><span class="s0">None</span><span class="s2">,</span>
                                             <span class="s1">self</span><span class="s2">.</span><span class="s1">_kind</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">ConfidenceInterval</span><span class="s2">(</span><span class="s1">low</span><span class="s2">, </span><span class="s1">high</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_linear_ci</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">confidence_level</span><span class="s2">):</span>
        <span class="s1">sf</span><span class="s2">, </span><span class="s1">d</span><span class="s2">, </span><span class="s1">n </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_sf</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_d</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_n</span>
        <span class="s5"># When n == d, Greenwood's formula divides by zero.</span>
        <span class="s5"># When s != 0, this can be ignored: var == inf, and CI is [0, 1]</span>
        <span class="s5"># When s == 0, this results in NaNs. Produce an informative warning.</span>
        <span class="s0">with </span><span class="s1">np</span><span class="s2">.</span><span class="s1">errstate</span><span class="s2">(</span><span class="s1">divide</span><span class="s2">=</span><span class="s3">'ignore'</span><span class="s2">, </span><span class="s1">invalid</span><span class="s2">=</span><span class="s3">'ignore'</span><span class="s2">):</span>
            <span class="s1">var </span><span class="s2">= </span><span class="s1">sf </span><span class="s2">** </span><span class="s6">2 </span><span class="s2">* </span><span class="s1">np</span><span class="s2">.</span><span class="s1">cumsum</span><span class="s2">(</span><span class="s1">d </span><span class="s2">/ (</span><span class="s1">n </span><span class="s2">* (</span><span class="s1">n </span><span class="s2">- </span><span class="s1">d</span><span class="s2">)))</span>

        <span class="s1">se </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sqrt</span><span class="s2">(</span><span class="s1">var</span><span class="s2">)</span>
        <span class="s1">z </span><span class="s2">= </span><span class="s1">special</span><span class="s2">.</span><span class="s1">ndtri</span><span class="s2">(</span><span class="s6">1 </span><span class="s2">/ </span><span class="s6">2 </span><span class="s2">+ </span><span class="s1">confidence_level </span><span class="s2">/ </span><span class="s6">2</span><span class="s2">)</span>

        <span class="s1">z_se </span><span class="s2">= </span><span class="s1">z </span><span class="s2">* </span><span class="s1">se</span>
        <span class="s1">low </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">probabilities </span><span class="s2">- </span><span class="s1">z_se</span>
        <span class="s1">high </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">probabilities </span><span class="s2">+ </span><span class="s1">z_se</span>

        <span class="s0">return </span><span class="s1">low</span><span class="s2">, </span><span class="s1">high</span>

    <span class="s0">def </span><span class="s1">_loglog_ci</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">confidence_level</span><span class="s2">):</span>
        <span class="s1">sf</span><span class="s2">, </span><span class="s1">d</span><span class="s2">, </span><span class="s1">n </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_sf</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_d</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_n</span>

        <span class="s0">with </span><span class="s1">np</span><span class="s2">.</span><span class="s1">errstate</span><span class="s2">(</span><span class="s1">divide</span><span class="s2">=</span><span class="s3">'ignore'</span><span class="s2">, </span><span class="s1">invalid</span><span class="s2">=</span><span class="s3">'ignore'</span><span class="s2">):</span>
            <span class="s1">var </span><span class="s2">= </span><span class="s6">1 </span><span class="s2">/ </span><span class="s1">np</span><span class="s2">.</span><span class="s1">log</span><span class="s2">(</span><span class="s1">sf</span><span class="s2">) ** </span><span class="s6">2 </span><span class="s2">* </span><span class="s1">np</span><span class="s2">.</span><span class="s1">cumsum</span><span class="s2">(</span><span class="s1">d </span><span class="s2">/ (</span><span class="s1">n </span><span class="s2">* (</span><span class="s1">n </span><span class="s2">- </span><span class="s1">d</span><span class="s2">)))</span>

        <span class="s1">se </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sqrt</span><span class="s2">(</span><span class="s1">var</span><span class="s2">)</span>
        <span class="s1">z </span><span class="s2">= </span><span class="s1">special</span><span class="s2">.</span><span class="s1">ndtri</span><span class="s2">(</span><span class="s6">1 </span><span class="s2">/ </span><span class="s6">2 </span><span class="s2">+ </span><span class="s1">confidence_level </span><span class="s2">/ </span><span class="s6">2</span><span class="s2">)</span>

        <span class="s0">with </span><span class="s1">np</span><span class="s2">.</span><span class="s1">errstate</span><span class="s2">(</span><span class="s1">divide</span><span class="s2">=</span><span class="s3">'ignore'</span><span class="s2">):</span>
            <span class="s1">lnl_points </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">log</span><span class="s2">(-</span><span class="s1">np</span><span class="s2">.</span><span class="s1">log</span><span class="s2">(</span><span class="s1">sf</span><span class="s2">))</span>

        <span class="s1">z_se </span><span class="s2">= </span><span class="s1">z </span><span class="s2">* </span><span class="s1">se</span>
        <span class="s1">low </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">exp</span><span class="s2">(-</span><span class="s1">np</span><span class="s2">.</span><span class="s1">exp</span><span class="s2">(</span><span class="s1">lnl_points </span><span class="s2">+ </span><span class="s1">z_se</span><span class="s2">))</span>
        <span class="s1">high </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">exp</span><span class="s2">(-</span><span class="s1">np</span><span class="s2">.</span><span class="s1">exp</span><span class="s2">(</span><span class="s1">lnl_points </span><span class="s2">- </span><span class="s1">z_se</span><span class="s2">))</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_kind </span><span class="s2">== </span><span class="s3">&quot;cdf&quot;</span><span class="s2">:</span>
            <span class="s1">low</span><span class="s2">, </span><span class="s1">high </span><span class="s2">= </span><span class="s6">1</span><span class="s2">-</span><span class="s1">high</span><span class="s2">, </span><span class="s6">1</span><span class="s2">-</span><span class="s1">low</span>

        <span class="s0">return </span><span class="s1">low</span><span class="s2">, </span><span class="s1">high</span>


<span class="s2">@</span><span class="s1">dataclass</span>
<span class="s0">class </span><span class="s1">ECDFResult</span><span class="s2">:</span>
    <span class="s4">&quot;&quot;&quot; Result object returned by `scipy.stats.ecdf` 
 
    Attributes 
    ---------- 
    cdf : `~scipy.stats._result_classes.EmpiricalDistributionFunction` 
        An object representing the empirical cumulative distribution function. 
    sf : `~scipy.stats._result_classes.EmpiricalDistributionFunction` 
        An object representing the complement of the empirical cumulative 
        distribution function. 
    &quot;&quot;&quot;</span>
    <span class="s1">cdf</span><span class="s2">: </span><span class="s1">EmpiricalDistributionFunction</span>
    <span class="s1">sf</span><span class="s2">: </span><span class="s1">EmpiricalDistributionFunction</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">q</span><span class="s2">, </span><span class="s1">cdf</span><span class="s2">, </span><span class="s1">sf</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">d</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">cdf </span><span class="s2">= </span><span class="s1">EmpiricalDistributionFunction</span><span class="s2">(</span><span class="s1">q</span><span class="s2">, </span><span class="s1">cdf</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">d</span><span class="s2">, </span><span class="s3">&quot;cdf&quot;</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">sf </span><span class="s2">= </span><span class="s1">EmpiricalDistributionFunction</span><span class="s2">(</span><span class="s1">q</span><span class="s2">, </span><span class="s1">sf</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">d</span><span class="s2">, </span><span class="s3">&quot;sf&quot;</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">_iv_CensoredData</span><span class="s2">(</span>
    <span class="s1">sample</span><span class="s2">: </span><span class="s1">npt</span><span class="s2">.</span><span class="s1">ArrayLike </span><span class="s2">| </span><span class="s1">CensoredData</span><span class="s2">, </span><span class="s1">param_name</span><span class="s2">: </span><span class="s1">str </span><span class="s2">= </span><span class="s3">'sample'</span>
<span class="s2">) </span><span class="s1">-&gt; CensoredData</span><span class="s2">:</span>
    <span class="s4">&quot;&quot;&quot;Attempt to convert `sample` to `CensoredData`.&quot;&quot;&quot;</span>
    <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">sample</span><span class="s2">, </span><span class="s1">CensoredData</span><span class="s2">):</span>
        <span class="s0">try</span><span class="s2">:  </span><span class="s5"># takes care of input standardization/validation</span>
            <span class="s1">sample </span><span class="s2">= </span><span class="s1">CensoredData</span><span class="s2">(</span><span class="s1">uncensored</span><span class="s2">=</span><span class="s1">sample</span><span class="s2">)</span>
        <span class="s0">except </span><span class="s1">ValueError </span><span class="s0">as </span><span class="s1">e</span><span class="s2">:</span>
            <span class="s1">message </span><span class="s2">= </span><span class="s1">str</span><span class="s2">(</span><span class="s1">e</span><span class="s2">).</span><span class="s1">replace</span><span class="s2">(</span><span class="s3">'uncensored'</span><span class="s2">, </span><span class="s1">param_name</span><span class="s2">)</span>
            <span class="s0">raise </span><span class="s1">type</span><span class="s2">(</span><span class="s1">e</span><span class="s2">)(</span><span class="s1">message</span><span class="s2">) </span><span class="s0">from </span><span class="s1">e</span>
    <span class="s0">return </span><span class="s1">sample</span>


<span class="s0">def </span><span class="s1">ecdf</span><span class="s2">(</span><span class="s1">sample</span><span class="s2">: </span><span class="s1">npt</span><span class="s2">.</span><span class="s1">ArrayLike </span><span class="s2">| </span><span class="s1">CensoredData</span><span class="s2">) </span><span class="s1">-&gt; ECDFResult</span><span class="s2">:</span>
    <span class="s4">&quot;&quot;&quot;Empirical cumulative distribution function of a sample. 
 
    The empirical cumulative distribution function (ECDF) is a step function 
    estimate of the CDF of the distribution underlying a sample. This function 
    returns objects representing both the empirical distribution function and 
    its complement, the empirical survival function. 
 
    Parameters 
    ---------- 
    sample : 1D array_like or `scipy.stats.CensoredData` 
        Besides array_like, instances of `scipy.stats.CensoredData` containing 
        uncensored and right-censored observations are supported. Currently, 
        other instances of `scipy.stats.CensoredData` will result in a 
        ``NotImplementedError``. 
 
    Returns 
    ------- 
    res : `~scipy.stats._result_classes.ECDFResult` 
        An object with the following attributes. 
 
        cdf : `~scipy.stats._result_classes.EmpiricalDistributionFunction` 
            An object representing the empirical cumulative distribution 
            function. 
        sf : `~scipy.stats._result_classes.EmpiricalDistributionFunction` 
            An object representing the empirical survival function. 
 
        The `cdf` and `sf` attributes themselves have the following attributes. 
 
        quantiles : ndarray 
            The unique values in the sample that defines the empirical CDF/SF. 
        probabilities : ndarray 
            The point estimates of the probabilities corresponding with 
            `quantiles`. 
 
        And the following methods: 
 
        evaluate(x) : 
            Evaluate the CDF/SF at the argument. 
 
        plot(ax) : 
            Plot the CDF/SF on the provided axes. 
 
        confidence_interval(confidence_level=0.95) : 
            Compute the confidence interval around the CDF/SF at the values in 
            `quantiles`. 
 
    Notes 
    ----- 
    When each observation of the sample is a precise measurement, the ECDF 
    steps up by ``1/len(sample)`` at each of the observations [1]_. 
 
    When observations are lower bounds, upper bounds, or both upper and lower 
    bounds, the data is said to be &quot;censored&quot;, and `sample` may be provided as 
    an instance of `scipy.stats.CensoredData`. 
 
    For right-censored data, the ECDF is given by the Kaplan-Meier estimator 
    [2]_; other forms of censoring are not supported at this time. 
 
    Confidence intervals are computed according to the Greenwood formula or the 
    more recent &quot;Exponential Greenwood&quot; formula as described in [4]_. 
 
    References 
    ---------- 
    .. [1] Conover, William Jay. Practical nonparametric statistics. Vol. 350. 
           John Wiley &amp; Sons, 1999. 
 
    .. [2] Kaplan, Edward L., and Paul Meier. &quot;Nonparametric estimation from 
           incomplete observations.&quot; Journal of the American statistical 
           association 53.282 (1958): 457-481. 
 
    .. [3] Goel, Manish Kumar, Pardeep Khanna, and Jugal Kishore. 
           &quot;Understanding survival analysis: Kaplan-Meier estimate.&quot; 
           International journal of Ayurveda research 1.4 (2010): 274. 
 
    .. [4] Sawyer, Stanley. &quot;The Greenwood and Exponential Greenwood Confidence 
           Intervals in Survival Analysis.&quot; 
           https://www.math.wustl.edu/~sawyer/handouts/greenwood.pdf 
 
    Examples 
    -------- 
    **Uncensored Data** 
 
    As in the example from [1]_ page 79, five boys were selected at random from 
    those in a single high school. Their one-mile run times were recorded as 
    follows. 
 
    &gt;&gt;&gt; sample = [6.23, 5.58, 7.06, 6.42, 5.20]  # one-mile run times (minutes) 
 
    The empirical distribution function, which approximates the distribution 
    function of one-mile run times of the population from which the boys were 
    sampled, is calculated as follows. 
 
    &gt;&gt;&gt; from scipy import stats 
    &gt;&gt;&gt; res = stats.ecdf(sample) 
    &gt;&gt;&gt; res.cdf.quantiles 
    array([5.2 , 5.58, 6.23, 6.42, 7.06]) 
    &gt;&gt;&gt; res.cdf.probabilities 
    array([0.2, 0.4, 0.6, 0.8, 1. ]) 
 
    To plot the result as a step function: 
 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; ax = plt.subplot() 
    &gt;&gt;&gt; res.cdf.plot(ax) 
    &gt;&gt;&gt; ax.set_xlabel('One-Mile Run Time (minutes)') 
    &gt;&gt;&gt; ax.set_ylabel('Empirical CDF') 
    &gt;&gt;&gt; plt.show() 
 
    **Right-censored Data** 
 
    As in the example from [1]_ page 91, the lives of ten car fanbelts were 
    tested. Five tests concluded because the fanbelt being tested broke, but 
    the remaining tests concluded for other reasons (e.g. the study ran out of 
    funding, but the fanbelt was still functional). The mileage driven 
    with the fanbelts were recorded as follows. 
 
    &gt;&gt;&gt; broken = [77, 47, 81, 56, 80]  # in thousands of miles driven 
    &gt;&gt;&gt; unbroken = [62, 60, 43, 71, 37] 
 
    Precise survival times of the fanbelts that were still functional at the 
    end of the tests are unknown, but they are known to exceed the values 
    recorded in ``unbroken``. Therefore, these observations are said to be 
    &quot;right-censored&quot;, and the data is represented using 
    `scipy.stats.CensoredData`. 
 
    &gt;&gt;&gt; sample = stats.CensoredData(uncensored=broken, right=unbroken) 
 
    The empirical survival function is calculated as follows. 
 
    &gt;&gt;&gt; res = stats.ecdf(sample) 
    &gt;&gt;&gt; res.sf.quantiles 
    array([37., 43., 47., 56., 60., 62., 71., 77., 80., 81.]) 
    &gt;&gt;&gt; res.sf.probabilities 
    array([1.   , 1.   , 0.875, 0.75 , 0.75 , 0.75 , 0.75 , 0.5  , 0.25 , 0.   ]) 
 
    To plot the result as a step function: 
 
    &gt;&gt;&gt; ax = plt.subplot() 
    &gt;&gt;&gt; res.cdf.plot(ax) 
    &gt;&gt;&gt; ax.set_xlabel('Fanbelt Survival Time (thousands of miles)') 
    &gt;&gt;&gt; ax.set_ylabel('Empirical SF') 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span>
    <span class="s1">sample </span><span class="s2">= </span><span class="s1">_iv_CensoredData</span><span class="s2">(</span><span class="s1">sample</span><span class="s2">)</span>

    <span class="s0">if </span><span class="s1">sample</span><span class="s2">.</span><span class="s1">num_censored</span><span class="s2">() == </span><span class="s6">0</span><span class="s2">:</span>
        <span class="s1">res </span><span class="s2">= </span><span class="s1">_ecdf_uncensored</span><span class="s2">(</span><span class="s1">sample</span><span class="s2">.</span><span class="s1">_uncensor</span><span class="s2">())</span>
    <span class="s0">elif </span><span class="s1">sample</span><span class="s2">.</span><span class="s1">num_censored</span><span class="s2">() == </span><span class="s1">sample</span><span class="s2">.</span><span class="s1">_right</span><span class="s2">.</span><span class="s1">size</span><span class="s2">:</span>
        <span class="s1">res </span><span class="s2">= </span><span class="s1">_ecdf_right_censored</span><span class="s2">(</span><span class="s1">sample</span><span class="s2">)</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s5"># Support additional censoring options in follow-up PRs</span>
        <span class="s1">message </span><span class="s2">= (</span><span class="s3">&quot;Currently, only uncensored and right-censored data is &quot;</span>
                   <span class="s3">&quot;supported.&quot;</span><span class="s2">)</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError</span><span class="s2">(</span><span class="s1">message</span><span class="s2">)</span>

    <span class="s1">t</span><span class="s2">, </span><span class="s1">cdf</span><span class="s2">, </span><span class="s1">sf</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">d </span><span class="s2">= </span><span class="s1">res</span>
    <span class="s0">return </span><span class="s1">ECDFResult</span><span class="s2">(</span><span class="s1">t</span><span class="s2">, </span><span class="s1">cdf</span><span class="s2">, </span><span class="s1">sf</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">d</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">_ecdf_uncensored</span><span class="s2">(</span><span class="s1">sample</span><span class="s2">):</span>
    <span class="s1">sample </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sort</span><span class="s2">(</span><span class="s1">sample</span><span class="s2">)</span>
    <span class="s1">x</span><span class="s2">, </span><span class="s1">counts </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">unique</span><span class="s2">(</span><span class="s1">sample</span><span class="s2">, </span><span class="s1">return_counts</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>

    <span class="s5"># [1].81 &quot;the fraction of [observations] that are less than or equal to x</span>
    <span class="s1">events </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">cumsum</span><span class="s2">(</span><span class="s1">counts</span><span class="s2">)</span>
    <span class="s1">n </span><span class="s2">= </span><span class="s1">sample</span><span class="s2">.</span><span class="s1">size</span>
    <span class="s1">cdf </span><span class="s2">= </span><span class="s1">events </span><span class="s2">/ </span><span class="s1">n</span>

    <span class="s5"># [1].89 &quot;the relative frequency of the sample that exceeds x in value&quot;</span>
    <span class="s1">sf </span><span class="s2">= </span><span class="s6">1 </span><span class="s2">- </span><span class="s1">cdf</span>

    <span class="s1">at_risk </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">concatenate</span><span class="s2">(([</span><span class="s1">n</span><span class="s2">], </span><span class="s1">n </span><span class="s2">- </span><span class="s1">events</span><span class="s2">[:-</span><span class="s6">1</span><span class="s2">]))</span>
    <span class="s0">return </span><span class="s1">x</span><span class="s2">, </span><span class="s1">cdf</span><span class="s2">, </span><span class="s1">sf</span><span class="s2">, </span><span class="s1">at_risk</span><span class="s2">, </span><span class="s1">counts</span>


<span class="s0">def </span><span class="s1">_ecdf_right_censored</span><span class="s2">(</span><span class="s1">sample</span><span class="s2">):</span>
    <span class="s5"># It is conventional to discuss right-censored data in terms of</span>
    <span class="s5"># &quot;survival time&quot;, &quot;death&quot;, and &quot;loss&quot; (e.g. [2]). We'll use that</span>
    <span class="s5"># terminology here.</span>
    <span class="s5"># This implementation was influenced by the references cited and also</span>
    <span class="s5"># https://www.youtube.com/watch?v=lxoWsVco_iM</span>
    <span class="s5"># https://en.wikipedia.org/wiki/Kaplan%E2%80%93Meier_estimator</span>
    <span class="s5"># In retrospect it is probably most easily compared against [3].</span>
    <span class="s5"># Ultimately, the data needs to be sorted, so this implementation is</span>
    <span class="s5"># written to avoid a separate call to `unique` after sorting. In hope of</span>
    <span class="s5"># better performance on large datasets, it also computes survival</span>
    <span class="s5"># probabilities at unique times only rather than at each observation.</span>
    <span class="s1">tod </span><span class="s2">= </span><span class="s1">sample</span><span class="s2">.</span><span class="s1">_uncensored  </span><span class="s5"># time of &quot;death&quot;</span>
    <span class="s1">tol </span><span class="s2">= </span><span class="s1">sample</span><span class="s2">.</span><span class="s1">_right  </span><span class="s5"># time of &quot;loss&quot;</span>
    <span class="s1">times </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">concatenate</span><span class="s2">((</span><span class="s1">tod</span><span class="s2">, </span><span class="s1">tol</span><span class="s2">))</span>
    <span class="s1">died </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">([</span><span class="s6">1</span><span class="s2">]*</span><span class="s1">tod</span><span class="s2">.</span><span class="s1">size </span><span class="s2">+ [</span><span class="s6">0</span><span class="s2">]*</span><span class="s1">tol</span><span class="s2">.</span><span class="s1">size</span><span class="s2">)</span>

    <span class="s5"># sort by times</span>
    <span class="s1">i </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">argsort</span><span class="s2">(</span><span class="s1">times</span><span class="s2">)</span>
    <span class="s1">times </span><span class="s2">= </span><span class="s1">times</span><span class="s2">[</span><span class="s1">i</span><span class="s2">]</span>
    <span class="s1">died </span><span class="s2">= </span><span class="s1">died</span><span class="s2">[</span><span class="s1">i</span><span class="s2">]</span>
    <span class="s1">at_risk </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(</span><span class="s1">times</span><span class="s2">.</span><span class="s1">size</span><span class="s2">, </span><span class="s6">0</span><span class="s2">, -</span><span class="s6">1</span><span class="s2">)</span>

    <span class="s5"># logical indices of unique times</span>
    <span class="s1">j </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">diff</span><span class="s2">(</span><span class="s1">times</span><span class="s2">, </span><span class="s1">prepend</span><span class="s2">=-</span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span><span class="s2">, </span><span class="s1">append</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span><span class="s2">) &gt; </span><span class="s6">0</span>
    <span class="s1">j_l </span><span class="s2">= </span><span class="s1">j</span><span class="s2">[:-</span><span class="s6">1</span><span class="s2">]  </span><span class="s5"># first instances of unique times</span>
    <span class="s1">j_r </span><span class="s2">= </span><span class="s1">j</span><span class="s2">[</span><span class="s6">1</span><span class="s2">:]  </span><span class="s5"># last instances of unique times</span>

    <span class="s5"># get number at risk and deaths at each unique time</span>
    <span class="s1">t </span><span class="s2">= </span><span class="s1">times</span><span class="s2">[</span><span class="s1">j_l</span><span class="s2">]  </span><span class="s5"># unique times</span>
    <span class="s1">n </span><span class="s2">= </span><span class="s1">at_risk</span><span class="s2">[</span><span class="s1">j_l</span><span class="s2">]  </span><span class="s5"># number at risk at each unique time</span>
    <span class="s1">cd </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">cumsum</span><span class="s2">(</span><span class="s1">died</span><span class="s2">)[</span><span class="s1">j_r</span><span class="s2">]  </span><span class="s5"># cumulative deaths up to/including unique times</span>
    <span class="s1">d </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">diff</span><span class="s2">(</span><span class="s1">cd</span><span class="s2">, </span><span class="s1">prepend</span><span class="s2">=</span><span class="s6">0</span><span class="s2">)  </span><span class="s5"># deaths at each unique time</span>

    <span class="s5"># compute survival function</span>
    <span class="s1">sf </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">cumprod</span><span class="s2">((</span><span class="s1">n </span><span class="s2">- </span><span class="s1">d</span><span class="s2">) / </span><span class="s1">n</span><span class="s2">)</span>
    <span class="s1">cdf </span><span class="s2">= </span><span class="s6">1 </span><span class="s2">- </span><span class="s1">sf</span>
    <span class="s0">return </span><span class="s1">t</span><span class="s2">, </span><span class="s1">cdf</span><span class="s2">, </span><span class="s1">sf</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">d</span>


<span class="s2">@</span><span class="s1">dataclass</span>
<span class="s0">class </span><span class="s1">LogRankResult</span><span class="s2">:</span>
    <span class="s4">&quot;&quot;&quot;Result object returned by `scipy.stats.logrank`. 
 
    Attributes 
    ---------- 
    statistic : float ndarray 
        The computed statistic (defined below). Its magnitude is the 
        square root of the magnitude returned by most other logrank test 
        implementations. 
    pvalue : float ndarray 
        The computed p-value of the test. 
    &quot;&quot;&quot;</span>
    <span class="s1">statistic</span><span class="s2">: </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span>
    <span class="s1">pvalue</span><span class="s2">: </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span>


<span class="s0">def </span><span class="s1">logrank</span><span class="s2">(</span>
    <span class="s1">x</span><span class="s2">: </span><span class="s1">npt</span><span class="s2">.</span><span class="s1">ArrayLike </span><span class="s2">| </span><span class="s1">CensoredData</span><span class="s2">,</span>
    <span class="s1">y</span><span class="s2">: </span><span class="s1">npt</span><span class="s2">.</span><span class="s1">ArrayLike </span><span class="s2">| </span><span class="s1">CensoredData</span><span class="s2">,</span>
    <span class="s1">alternative</span><span class="s2">: </span><span class="s1">Literal</span><span class="s2">[</span><span class="s3">'two-sided'</span><span class="s2">, </span><span class="s3">'less'</span><span class="s2">, </span><span class="s3">'greater'</span><span class="s2">] = </span><span class="s3">&quot;two-sided&quot;</span>
<span class="s2">) </span><span class="s1">-&gt; LogRankResult</span><span class="s2">:</span>
    <span class="s4">r&quot;&quot;&quot;Compare the survival distributions of two samples via the logrank test. 
 
    Parameters 
    ---------- 
    x, y : array_like or CensoredData 
        Samples to compare based on their empirical survival functions. 
    alternative : {'two-sided', 'less', 'greater'}, optional 
        Defines the alternative hypothesis. 
 
        The null hypothesis is that the survival distributions of the two 
        groups, say *X* and *Y*, are identical. 
 
        The following alternative hypotheses [4]_ are available (default is 
        'two-sided'): 
 
        * 'two-sided': the survival distributions of the two groups are not 
          identical. 
        * 'less': survival of group *X* is favored: the group *X* failure rate 
          function is less than the group *Y* failure rate function at some 
          times. 
        * 'greater': survival of group *Y* is favored: the group *X* failure 
          rate function is greater than the group *Y* failure rate function at 
          some times. 
 
    Returns 
    ------- 
    res : `~scipy.stats._result_classes.LogRankResult` 
        An object containing attributes: 
 
        statistic : float ndarray 
            The computed statistic (defined below). Its magnitude is the 
            square root of the magnitude returned by most other logrank test 
            implementations. 
        pvalue : float ndarray 
            The computed p-value of the test. 
 
    See Also 
    -------- 
    scipy.stats.ecdf 
 
    Notes 
    ----- 
    The logrank test [1]_ compares the observed number of events to 
    the expected number of events under the null hypothesis that the two 
    samples were drawn from the same distribution. The statistic is 
 
    .. math:: 
 
        Z_i = \frac{\sum_{j=1}^J(O_{i,j}-E_{i,j})}{\sqrt{\sum_{j=1}^J V_{i,j}}} 
        \rightarrow \mathcal{N}(0,1) 
 
    where 
 
    .. math:: 
 
        E_{i,j} = O_j \frac{N_{i,j}}{N_j}, 
        \qquad 
        V_{i,j} = E_{i,j} \left(\frac{N_j-O_j}{N_j}\right) 
        \left(\frac{N_j-N_{i,j}}{N_j-1}\right), 
 
    :math:`i` denotes the group (i.e. it may assume values :math:`x` or 
    :math:`y`, or it may be omitted to refer to the combined sample) 
    :math:`j` denotes the time (at which an event occurred), 
    :math:`N` is the number of subjects at risk just before an event occurred, 
    and :math:`O` is the observed number of events at that time. 
 
    The ``statistic`` :math:`Z_x` returned by `logrank` is the (signed) square 
    root of the statistic returned by many other implementations. Under the 
    null hypothesis, :math:`Z_x**2` is asymptotically distributed according to 
    the chi-squared distribution with one degree of freedom. Consequently, 
    :math:`Z_x` is asymptotically distributed according to the standard normal 
    distribution. The advantage of using :math:`Z_x` is that the sign 
    information (i.e. whether the observed number of events tends to be less 
    than or greater than the number expected under the null hypothesis) is 
    preserved, allowing `scipy.stats.logrank` to offer one-sided alternative 
    hypotheses. 
 
    References 
    ---------- 
    .. [1] Mantel N. &quot;Evaluation of survival data and two new rank order 
           statistics arising in its consideration.&quot; 
           Cancer Chemotherapy Reports, 50(3):163-170, PMID: 5910392, 1966 
    .. [2] Bland, Altman, &quot;The logrank test&quot;, BMJ, 328:1073, 
           :doi:`10.1136/bmj.328.7447.1073`, 2004 
    .. [3] &quot;Logrank test&quot;, Wikipedia, 
           https://en.wikipedia.org/wiki/Logrank_test 
    .. [4] Brown, Mark. &quot;On the choice of variance for the log rank test.&quot; 
           Biometrika 71.1 (1984): 65-74. 
    .. [5] Klein, John P., and Melvin L. Moeschberger. Survival analysis: 
           techniques for censored and truncated data. Vol. 1230. New York: 
           Springer, 2003. 
 
    Examples 
    -------- 
    Reference [2]_ compared the survival times of patients with two different 
    types of recurrent malignant gliomas. The samples below record the time 
    (number of weeks) for which each patient participated in the study. The 
    `scipy.stats.CensoredData` class is used because the data is 
    right-censored: the uncensored observations correspond with observed deaths 
    whereas the censored observations correspond with the patient leaving the 
    study for another reason. 
 
    &gt;&gt;&gt; from scipy import stats 
    &gt;&gt;&gt; x = stats.CensoredData( 
    ...     uncensored=[6, 13, 21, 30, 37, 38, 49, 50, 
    ...                 63, 79, 86, 98, 202, 219], 
    ...     right=[31, 47, 80, 82, 82, 149] 
    ... ) 
    &gt;&gt;&gt; y = stats.CensoredData( 
    ...     uncensored=[10, 10, 12, 13, 14, 15, 16, 17, 18, 20, 24, 24, 
    ...                 25, 28,30, 33, 35, 37, 40, 40, 46, 48, 76, 81, 
    ...                 82, 91, 112, 181], 
    ...     right=[34, 40, 70] 
    ... ) 
 
    We can calculate and visualize the empirical survival functions 
    of both groups as follows. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; ax = plt.subplot() 
    &gt;&gt;&gt; ecdf_x = stats.ecdf(x) 
    &gt;&gt;&gt; ecdf_x.sf.plot(ax, label='Astrocytoma') 
    &gt;&gt;&gt; ecdf_y = stats.ecdf(y) 
    &gt;&gt;&gt; ecdf_y.sf.plot(ax, label='Glioblastoma') 
    &gt;&gt;&gt; ax.set_xlabel('Time to death (weeks)') 
    &gt;&gt;&gt; ax.set_ylabel('Empirical SF') 
    &gt;&gt;&gt; plt.legend() 
    &gt;&gt;&gt; plt.show() 
 
    Visual inspection of the empirical survival functions suggests that the 
    survival times tend to be different between the two groups. To formally 
    assess whether the difference is significant at the 1% level, we use the 
    logrank test. 
 
    &gt;&gt;&gt; res = stats.logrank(x=x, y=y) 
    &gt;&gt;&gt; res.statistic 
    -2.73799 
    &gt;&gt;&gt; res.pvalue 
    0.00618 
 
    The p-value is less than 1%, so we can consider the data to be evidence 
    against the null hypothesis in favor of the alternative that there is a 
    difference between the two survival functions. 
 
    &quot;&quot;&quot;</span>
    <span class="s5"># Input validation. `alternative` IV handled in `_get_pvalue` below.</span>
    <span class="s1">x </span><span class="s2">= </span><span class="s1">_iv_CensoredData</span><span class="s2">(</span><span class="s1">sample</span><span class="s2">=</span><span class="s1">x</span><span class="s2">, </span><span class="s1">param_name</span><span class="s2">=</span><span class="s3">'x'</span><span class="s2">)</span>
    <span class="s1">y </span><span class="s2">= </span><span class="s1">_iv_CensoredData</span><span class="s2">(</span><span class="s1">sample</span><span class="s2">=</span><span class="s1">y</span><span class="s2">, </span><span class="s1">param_name</span><span class="s2">=</span><span class="s3">'y'</span><span class="s2">)</span>

    <span class="s5"># Combined sample. (Under H0, the two groups are identical.)</span>
    <span class="s1">xy </span><span class="s2">= </span><span class="s1">CensoredData</span><span class="s2">(</span>
        <span class="s1">uncensored</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">concatenate</span><span class="s2">((</span><span class="s1">x</span><span class="s2">.</span><span class="s1">_uncensored</span><span class="s2">, </span><span class="s1">y</span><span class="s2">.</span><span class="s1">_uncensored</span><span class="s2">)),</span>
        <span class="s1">right</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">concatenate</span><span class="s2">((</span><span class="s1">x</span><span class="s2">.</span><span class="s1">_right</span><span class="s2">, </span><span class="s1">y</span><span class="s2">.</span><span class="s1">_right</span><span class="s2">))</span>
    <span class="s2">)</span>

    <span class="s5"># Extract data from the combined sample</span>
    <span class="s1">res </span><span class="s2">= </span><span class="s1">ecdf</span><span class="s2">(</span><span class="s1">xy</span><span class="s2">)</span>
    <span class="s1">idx </span><span class="s2">= </span><span class="s1">res</span><span class="s2">.</span><span class="s1">sf</span><span class="s2">.</span><span class="s1">_d</span><span class="s2">.</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">bool</span><span class="s2">)  </span><span class="s5"># indices of observed events</span>
    <span class="s1">times_xy </span><span class="s2">= </span><span class="s1">res</span><span class="s2">.</span><span class="s1">sf</span><span class="s2">.</span><span class="s1">quantiles</span><span class="s2">[</span><span class="s1">idx</span><span class="s2">]  </span><span class="s5"># unique times of observed events</span>
    <span class="s1">at_risk_xy </span><span class="s2">= </span><span class="s1">res</span><span class="s2">.</span><span class="s1">sf</span><span class="s2">.</span><span class="s1">_n</span><span class="s2">[</span><span class="s1">idx</span><span class="s2">]  </span><span class="s5"># combined number of subjects at risk</span>
    <span class="s1">deaths_xy </span><span class="s2">= </span><span class="s1">res</span><span class="s2">.</span><span class="s1">sf</span><span class="s2">.</span><span class="s1">_d</span><span class="s2">[</span><span class="s1">idx</span><span class="s2">]  </span><span class="s5"># combined number of events</span>

    <span class="s5"># Get the number at risk within each sample.</span>
    <span class="s5"># First compute the number at risk in group X at each of the `times_xy`.</span>
    <span class="s5"># Could use `interpolate_1d`, but this is more compact.</span>
    <span class="s1">res_x </span><span class="s2">= </span><span class="s1">ecdf</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)</span>
    <span class="s1">i </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">searchsorted</span><span class="s2">(</span><span class="s1">res_x</span><span class="s2">.</span><span class="s1">sf</span><span class="s2">.</span><span class="s1">quantiles</span><span class="s2">, </span><span class="s1">times_xy</span><span class="s2">)</span>
    <span class="s1">at_risk_x </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">res_x</span><span class="s2">.</span><span class="s1">sf</span><span class="s2">.</span><span class="s1">_n</span><span class="s2">, </span><span class="s6">0</span><span class="s2">)[</span><span class="s1">i</span><span class="s2">]  </span><span class="s5"># 0 at risk after last time</span>
    <span class="s5"># Subtract from the combined number at risk to get number at risk in Y</span>
    <span class="s1">at_risk_y </span><span class="s2">= </span><span class="s1">at_risk_xy </span><span class="s2">- </span><span class="s1">at_risk_x</span>

    <span class="s5"># Compute the variance.</span>
    <span class="s1">num </span><span class="s2">= </span><span class="s1">at_risk_x </span><span class="s2">* </span><span class="s1">at_risk_y </span><span class="s2">* </span><span class="s1">deaths_xy </span><span class="s2">* (</span><span class="s1">at_risk_xy </span><span class="s2">- </span><span class="s1">deaths_xy</span><span class="s2">)</span>
    <span class="s1">den </span><span class="s2">= </span><span class="s1">at_risk_xy</span><span class="s2">**</span><span class="s6">2 </span><span class="s2">* (</span><span class="s1">at_risk_xy </span><span class="s2">- </span><span class="s6">1</span><span class="s2">)</span>
    <span class="s5"># Note: when `at_risk_xy == 1`, we would have `at_risk_xy - 1 == 0` in the</span>
    <span class="s5"># numerator and denominator. Simplifying the fraction symbolically, we</span>
    <span class="s5"># would always find the overall quotient to be zero, so don't compute it.</span>
    <span class="s1">i </span><span class="s2">= </span><span class="s1">at_risk_xy </span><span class="s2">&gt; </span><span class="s6">1</span>
    <span class="s1">sum_var </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sum</span><span class="s2">(</span><span class="s1">num</span><span class="s2">[</span><span class="s1">i</span><span class="s2">]/</span><span class="s1">den</span><span class="s2">[</span><span class="s1">i</span><span class="s2">])</span>

    <span class="s5"># Get the observed and expected number of deaths in group X</span>
    <span class="s1">n_died_x </span><span class="s2">= </span><span class="s1">x</span><span class="s2">.</span><span class="s1">_uncensored</span><span class="s2">.</span><span class="s1">size</span>
    <span class="s1">sum_exp_deaths_x </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sum</span><span class="s2">(</span><span class="s1">at_risk_x </span><span class="s2">* (</span><span class="s1">deaths_xy</span><span class="s2">/</span><span class="s1">at_risk_xy</span><span class="s2">))</span>

    <span class="s5"># Compute the statistic. This is the square root of that in references.</span>
    <span class="s1">statistic </span><span class="s2">= (</span><span class="s1">n_died_x </span><span class="s2">- </span><span class="s1">sum_exp_deaths_x</span><span class="s2">)/</span><span class="s1">np</span><span class="s2">.</span><span class="s1">sqrt</span><span class="s2">(</span><span class="s1">sum_var</span><span class="s2">)</span>

    <span class="s5"># Equivalent to chi2(df=1).sf(statistic**2) when alternative='two-sided'</span>
    <span class="s1">norm </span><span class="s2">= </span><span class="s1">stats</span><span class="s2">.</span><span class="s1">_stats_py</span><span class="s2">.</span><span class="s1">_SimpleNormal</span><span class="s2">()</span>
    <span class="s1">pvalue </span><span class="s2">= </span><span class="s1">stats</span><span class="s2">.</span><span class="s1">_stats_py</span><span class="s2">.</span><span class="s1">_get_pvalue</span><span class="s2">(</span><span class="s1">statistic</span><span class="s2">, </span><span class="s1">norm</span><span class="s2">, </span><span class="s1">alternative</span><span class="s2">, </span><span class="s1">xp</span><span class="s2">=</span><span class="s1">np</span><span class="s2">)</span>

    <span class="s0">return </span><span class="s1">LogRankResult</span><span class="s2">(</span><span class="s1">statistic</span><span class="s2">=</span><span class="s1">statistic</span><span class="s2">[()], </span><span class="s1">pvalue</span><span class="s2">=</span><span class="s1">pvalue</span><span class="s2">[()])</span>
</pre>
</body>
</html>