<html>
<head>
<title>optim.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #5f826b; font-style: italic;}
.s4 { color: #2aacb8;}
.s5 { color: #7a7e85;}
.s6 { color: #6aab73;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
optim.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">inspect</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">from </span><span class="s1">scipy</span><span class="s2">.</span><span class="s1">linalg </span><span class="s0">import </span><span class="s1">qr</span>

<span class="s0">from </span><span class="s2">..</span><span class="s1">utils </span><span class="s0">import </span><span class="s1">get_arrays_tol</span>


<span class="s1">TINY </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">finfo</span><span class="s2">(</span><span class="s1">float</span><span class="s2">).</span><span class="s1">tiny</span>
<span class="s1">EPS </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">finfo</span><span class="s2">(</span><span class="s1">float</span><span class="s2">).</span><span class="s1">eps</span>


<span class="s0">def </span><span class="s1">tangential_byrd_omojokun</span><span class="s2">(</span><span class="s1">grad</span><span class="s2">, </span><span class="s1">hess_prod</span><span class="s2">, </span><span class="s1">xl</span><span class="s2">, </span><span class="s1">xu</span><span class="s2">, </span><span class="s1">delta</span><span class="s2">, </span><span class="s1">debug</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
    <span class="s3">r&quot;&quot;&quot; 
    Minimize approximately a quadratic function subject to bound constraints in 
    a trust region. 
 
    This function solves approximately 
 
    .. math:: 
 
        \min_{s \in \mathbb{R}^n} \quad g^{\mathsf{T}} s + \frac{1}{2} 
        s^{\mathsf{T}} H s \quad \text{s.t.} \quad 
        \left\{ \begin{array}{l} 
            l \le s \le u\\ 
            \lVert s \rVert \le \Delta, 
        \end{array} \right. 
 
    using an active-set variation of the truncated conjugate gradient method. 
 
    Parameters 
    ---------- 
    grad : `numpy.ndarray`, shape (n,) 
        Gradient :math:`g` as shown above. 
    hess_prod : callable 
        Product of the Hessian matrix :math:`H` with any vector. 
 
            ``hess_prod(s) -&gt; `numpy.ndarray`, shape (n,)`` 
 
        returns the product :math:`H s`. 
    xl : `numpy.ndarray`, shape (n,) 
        Lower bounds :math:`l` as shown above. 
    xu : `numpy.ndarray`, shape (n,) 
        Upper bounds :math:`u` as shown above. 
    delta : float 
        Trust-region radius :math:`\Delta` as shown above. 
    debug : bool 
        Whether to make debugging tests during the execution. 
 
    Returns 
    ------- 
    `numpy.ndarray`, shape (n,) 
        Approximate solution :math:`s`. 
 
    Other Parameters 
    ---------------- 
    improve_tcg : bool, optional 
        If True, a solution generated by the truncated conjugate gradient 
        method that is on the boundary of the trust region is improved by 
        moving around the trust-region boundary on the two-dimensional space 
        spanned by the solution and the gradient of the quadratic function at 
        the solution (default is True). 
 
    Notes 
    ----- 
    This function implements Algorithm 6.2 of [1]_. It is assumed that the 
    origin is feasible with respect to the bound constraints and that `delta` 
    is finite and positive. 
 
    References 
    ---------- 
    .. [1] T. M. Ragonneau. *Model-Based Derivative-Free Optimization Methods 
       and Software*. PhD thesis, Department of Applied Mathematics, The Hong 
       Kong Polytechnic University, Hong Kong, China, 2022. URL: 
       https://theses.lib.polyu.edu.hk/handle/200/12294. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">debug</span><span class="s2">:</span>
        <span class="s0">assert </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">grad</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">) </span><span class="s0">and </span><span class="s1">grad</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s4">1</span>
        <span class="s0">assert </span><span class="s1">inspect</span><span class="s2">.</span><span class="s1">signature</span><span class="s2">(</span><span class="s1">hess_prod</span><span class="s2">).</span><span class="s1">bind</span><span class="s2">(</span><span class="s1">grad</span><span class="s2">)</span>
        <span class="s0">assert </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">xl</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">) </span><span class="s0">and </span><span class="s1">xl</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">== </span><span class="s1">grad</span><span class="s2">.</span><span class="s1">shape</span>
        <span class="s0">assert </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">xu</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">) </span><span class="s0">and </span><span class="s1">xu</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">== </span><span class="s1">grad</span><span class="s2">.</span><span class="s1">shape</span>
        <span class="s0">assert </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">delta</span><span class="s2">, </span><span class="s1">float</span><span class="s2">)</span>
        <span class="s0">assert </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">debug</span><span class="s2">, </span><span class="s1">bool</span><span class="s2">)</span>
        <span class="s1">tol </span><span class="s2">= </span><span class="s1">get_arrays_tol</span><span class="s2">(</span><span class="s1">xl</span><span class="s2">, </span><span class="s1">xu</span><span class="s2">)</span>
        <span class="s0">assert </span><span class="s1">np</span><span class="s2">.</span><span class="s1">all</span><span class="s2">(</span><span class="s1">xl </span><span class="s2">&lt;= </span><span class="s1">tol</span><span class="s2">)</span>
        <span class="s0">assert </span><span class="s1">np</span><span class="s2">.</span><span class="s1">all</span><span class="s2">(</span><span class="s1">xu </span><span class="s2">&gt;= -</span><span class="s1">tol</span><span class="s2">)</span>
        <span class="s0">assert </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isfinite</span><span class="s2">(</span><span class="s1">delta</span><span class="s2">) </span><span class="s0">and </span><span class="s1">delta </span><span class="s2">&gt; </span><span class="s4">0.0</span>
    <span class="s1">xl </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">minimum</span><span class="s2">(</span><span class="s1">xl</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">)</span>
    <span class="s1">xu </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">maximum</span><span class="s2">(</span><span class="s1">xu</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">)</span>

    <span class="s5"># Copy the arrays that may be modified by the code below.</span>
    <span class="s1">n </span><span class="s2">= </span><span class="s1">grad</span><span class="s2">.</span><span class="s1">size</span>
    <span class="s1">grad </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">(</span><span class="s1">grad</span><span class="s2">)</span>
    <span class="s1">grad_orig </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">(</span><span class="s1">grad</span><span class="s2">)</span>

    <span class="s5"># Calculate the initial active set.</span>
    <span class="s1">free_bd </span><span class="s2">= ((</span><span class="s1">xl </span><span class="s2">&lt; </span><span class="s4">0.0</span><span class="s2">) | (</span><span class="s1">grad </span><span class="s2">&lt; </span><span class="s4">0.0</span><span class="s2">)) &amp; ((</span><span class="s1">xu </span><span class="s2">&gt; </span><span class="s4">0.0</span><span class="s2">) | (</span><span class="s1">grad </span><span class="s2">&gt; </span><span class="s4">0.0</span><span class="s2">))</span>

    <span class="s5"># Set the initial iterate and the initial search direction.</span>
    <span class="s1">step </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros_like</span><span class="s2">(</span><span class="s1">grad</span><span class="s2">)</span>
    <span class="s1">sd </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros_like</span><span class="s2">(</span><span class="s1">step</span><span class="s2">)</span>
    <span class="s1">sd</span><span class="s2">[</span><span class="s1">free_bd</span><span class="s2">] = -</span><span class="s1">grad</span><span class="s2">[</span><span class="s1">free_bd</span><span class="s2">]</span>

    <span class="s1">k </span><span class="s2">= </span><span class="s4">0</span>
    <span class="s1">reduct </span><span class="s2">= </span><span class="s4">0.0</span>
    <span class="s1">boundary_reached </span><span class="s2">= </span><span class="s0">False</span>
    <span class="s0">while </span><span class="s1">k </span><span class="s2">&lt; </span><span class="s1">np</span><span class="s2">.</span><span class="s1">count_nonzero</span><span class="s2">(</span><span class="s1">free_bd</span><span class="s2">):</span>
        <span class="s5"># Stop the computations if sd is not a descent direction.</span>
        <span class="s1">grad_sd </span><span class="s2">= </span><span class="s1">grad </span><span class="s2">@ </span><span class="s1">sd</span>
        <span class="s0">if </span><span class="s1">grad_sd </span><span class="s2">&gt;= -</span><span class="s4">10.0 </span><span class="s2">* </span><span class="s1">EPS </span><span class="s2">* </span><span class="s1">n </span><span class="s2">* </span><span class="s1">max</span><span class="s2">(</span><span class="s4">1.0</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">norm</span><span class="s2">(</span><span class="s1">grad</span><span class="s2">)):</span>
            <span class="s0">break</span>

        <span class="s5"># Set alpha_tr to the step size for the trust-region constraint.</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s1">alpha_tr </span><span class="s2">= </span><span class="s1">_alpha_tr</span><span class="s2">(</span><span class="s1">step</span><span class="s2">, </span><span class="s1">sd</span><span class="s2">, </span><span class="s1">delta</span><span class="s2">)</span>
        <span class="s0">except </span><span class="s1">ZeroDivisionError</span><span class="s2">:</span>
            <span class="s0">break</span>

        <span class="s5"># Stop the computations if a step along sd is expected to give a</span>
        <span class="s5"># relatively small reduction in the objective function.</span>
        <span class="s0">if </span><span class="s2">-</span><span class="s1">alpha_tr </span><span class="s2">* </span><span class="s1">grad_sd </span><span class="s2">&lt;= </span><span class="s4">1e-8 </span><span class="s2">* </span><span class="s1">reduct</span><span class="s2">:</span>
            <span class="s0">break</span>

        <span class="s5"># Set alpha_quad to the step size for the minimization problem.</span>
        <span class="s1">hess_sd </span><span class="s2">= </span><span class="s1">hess_prod</span><span class="s2">(</span><span class="s1">sd</span><span class="s2">)</span>
        <span class="s1">curv_sd </span><span class="s2">= </span><span class="s1">sd </span><span class="s2">@ </span><span class="s1">hess_sd</span>
        <span class="s0">if </span><span class="s1">curv_sd </span><span class="s2">&gt; </span><span class="s1">TINY </span><span class="s2">* </span><span class="s1">abs</span><span class="s2">(</span><span class="s1">grad_sd</span><span class="s2">):</span>
            <span class="s1">alpha_quad </span><span class="s2">= </span><span class="s1">max</span><span class="s2">(-</span><span class="s1">grad_sd </span><span class="s2">/ </span><span class="s1">curv_sd</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">alpha_quad </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span>

        <span class="s5"># Stop the computations if the reduction in the objective function</span>
        <span class="s5"># provided by an unconstrained step is small.</span>
        <span class="s1">alpha </span><span class="s2">= </span><span class="s1">min</span><span class="s2">(</span><span class="s1">alpha_tr</span><span class="s2">, </span><span class="s1">alpha_quad</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s2">-</span><span class="s1">alpha </span><span class="s2">* (</span><span class="s1">grad_sd </span><span class="s2">+ </span><span class="s4">0.5 </span><span class="s2">* </span><span class="s1">alpha </span><span class="s2">* </span><span class="s1">curv_sd</span><span class="s2">) &lt;= </span><span class="s4">1e-8 </span><span class="s2">* </span><span class="s1">reduct</span><span class="s2">:</span>
            <span class="s0">break</span>

        <span class="s5"># Set alpha_bd to the step size for the bound constraints.</span>
        <span class="s1">i_xl </span><span class="s2">= (</span><span class="s1">xl </span><span class="s2">&gt; -</span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span><span class="s2">) &amp; (</span><span class="s1">sd </span><span class="s2">&lt; -</span><span class="s1">TINY </span><span class="s2">* </span><span class="s1">np</span><span class="s2">.</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">xl </span><span class="s2">- </span><span class="s1">step</span><span class="s2">))</span>
        <span class="s1">i_xu </span><span class="s2">= (</span><span class="s1">xu </span><span class="s2">&lt; </span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span><span class="s2">) &amp; (</span><span class="s1">sd </span><span class="s2">&gt; </span><span class="s1">TINY </span><span class="s2">* </span><span class="s1">np</span><span class="s2">.</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">xu </span><span class="s2">- </span><span class="s1">step</span><span class="s2">))</span>
        <span class="s1">all_alpha_xl </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">full_like</span><span class="s2">(</span><span class="s1">step</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span><span class="s2">)</span>
        <span class="s1">all_alpha_xu </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">full_like</span><span class="s2">(</span><span class="s1">step</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span><span class="s2">)</span>
        <span class="s1">all_alpha_xl</span><span class="s2">[</span><span class="s1">i_xl</span><span class="s2">] = </span><span class="s1">np</span><span class="s2">.</span><span class="s1">maximum</span><span class="s2">(</span>
            <span class="s2">(</span><span class="s1">xl</span><span class="s2">[</span><span class="s1">i_xl</span><span class="s2">] - </span><span class="s1">step</span><span class="s2">[</span><span class="s1">i_xl</span><span class="s2">]) / </span><span class="s1">sd</span><span class="s2">[</span><span class="s1">i_xl</span><span class="s2">],</span>
            <span class="s4">0.0</span><span class="s2">,</span>
        <span class="s2">)</span>
        <span class="s1">all_alpha_xu</span><span class="s2">[</span><span class="s1">i_xu</span><span class="s2">] = </span><span class="s1">np</span><span class="s2">.</span><span class="s1">maximum</span><span class="s2">(</span>
            <span class="s2">(</span><span class="s1">xu</span><span class="s2">[</span><span class="s1">i_xu</span><span class="s2">] - </span><span class="s1">step</span><span class="s2">[</span><span class="s1">i_xu</span><span class="s2">]) / </span><span class="s1">sd</span><span class="s2">[</span><span class="s1">i_xu</span><span class="s2">],</span>
            <span class="s4">0.0</span><span class="s2">,</span>
        <span class="s2">)</span>
        <span class="s1">alpha_xl </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">min</span><span class="s2">(</span><span class="s1">all_alpha_xl</span><span class="s2">)</span>
        <span class="s1">alpha_xu </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">min</span><span class="s2">(</span><span class="s1">all_alpha_xu</span><span class="s2">)</span>
        <span class="s1">alpha_bd </span><span class="s2">= </span><span class="s1">min</span><span class="s2">(</span><span class="s1">alpha_xl</span><span class="s2">, </span><span class="s1">alpha_xu</span><span class="s2">)</span>

        <span class="s5"># Update the iterate.</span>
        <span class="s1">alpha </span><span class="s2">= </span><span class="s1">min</span><span class="s2">(</span><span class="s1">alpha</span><span class="s2">, </span><span class="s1">alpha_bd</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">alpha </span><span class="s2">&gt; </span><span class="s4">0.0</span><span class="s2">:</span>
            <span class="s1">step</span><span class="s2">[</span><span class="s1">free_bd</span><span class="s2">] = </span><span class="s1">np</span><span class="s2">.</span><span class="s1">clip</span><span class="s2">(</span>
                <span class="s1">step</span><span class="s2">[</span><span class="s1">free_bd</span><span class="s2">] + </span><span class="s1">alpha </span><span class="s2">* </span><span class="s1">sd</span><span class="s2">[</span><span class="s1">free_bd</span><span class="s2">],</span>
                <span class="s1">xl</span><span class="s2">[</span><span class="s1">free_bd</span><span class="s2">],</span>
                <span class="s1">xu</span><span class="s2">[</span><span class="s1">free_bd</span><span class="s2">],</span>
            <span class="s2">)</span>
            <span class="s1">grad </span><span class="s2">+= </span><span class="s1">alpha </span><span class="s2">* </span><span class="s1">hess_sd</span>
            <span class="s1">reduct </span><span class="s2">-= </span><span class="s1">alpha </span><span class="s2">* (</span><span class="s1">grad_sd </span><span class="s2">+ </span><span class="s4">0.5 </span><span class="s2">* </span><span class="s1">alpha </span><span class="s2">* </span><span class="s1">curv_sd</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">alpha </span><span class="s2">&lt; </span><span class="s1">min</span><span class="s2">(</span><span class="s1">alpha_tr</span><span class="s2">, </span><span class="s1">alpha_bd</span><span class="s2">):</span>
            <span class="s5"># The current iteration is a conjugate gradient iteration. Update</span>
            <span class="s5"># the search direction so that it is conjugate (with respect to H)</span>
            <span class="s5"># to all the previous search directions.</span>
            <span class="s1">beta </span><span class="s2">= (</span><span class="s1">grad</span><span class="s2">[</span><span class="s1">free_bd</span><span class="s2">] @ </span><span class="s1">hess_sd</span><span class="s2">[</span><span class="s1">free_bd</span><span class="s2">]) / </span><span class="s1">curv_sd</span>
            <span class="s1">sd</span><span class="s2">[</span><span class="s1">free_bd</span><span class="s2">] = </span><span class="s1">beta </span><span class="s2">* </span><span class="s1">sd</span><span class="s2">[</span><span class="s1">free_bd</span><span class="s2">] - </span><span class="s1">grad</span><span class="s2">[</span><span class="s1">free_bd</span><span class="s2">]</span>
            <span class="s1">sd</span><span class="s2">[~</span><span class="s1">free_bd</span><span class="s2">] = </span><span class="s4">0.0</span>
            <span class="s1">k </span><span class="s2">+= </span><span class="s4">1</span>
        <span class="s0">elif </span><span class="s1">alpha </span><span class="s2">&lt; </span><span class="s1">alpha_tr</span><span class="s2">:</span>
            <span class="s5"># The iterate is restricted by a bound constraint. Add this bound</span>
            <span class="s5"># constraint to the active set, and restart the calculations.</span>
            <span class="s0">if </span><span class="s1">alpha_xl </span><span class="s2">&lt;= </span><span class="s1">alpha</span><span class="s2">:</span>
                <span class="s1">i_new </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">argmin</span><span class="s2">(</span><span class="s1">all_alpha_xl</span><span class="s2">)</span>
                <span class="s1">step</span><span class="s2">[</span><span class="s1">i_new</span><span class="s2">] = </span><span class="s1">xl</span><span class="s2">[</span><span class="s1">i_new</span><span class="s2">]</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">i_new </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">argmin</span><span class="s2">(</span><span class="s1">all_alpha_xu</span><span class="s2">)</span>
                <span class="s1">step</span><span class="s2">[</span><span class="s1">i_new</span><span class="s2">] = </span><span class="s1">xu</span><span class="s2">[</span><span class="s1">i_new</span><span class="s2">]</span>
            <span class="s1">free_bd</span><span class="s2">[</span><span class="s1">i_new</span><span class="s2">] = </span><span class="s0">False</span>
            <span class="s1">sd</span><span class="s2">[</span><span class="s1">free_bd</span><span class="s2">] = -</span><span class="s1">grad</span><span class="s2">[</span><span class="s1">free_bd</span><span class="s2">]</span>
            <span class="s1">sd</span><span class="s2">[~</span><span class="s1">free_bd</span><span class="s2">] = </span><span class="s4">0.0</span>
            <span class="s1">k </span><span class="s2">= </span><span class="s4">0</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s5"># The current iterate is on the trust-region boundary. Add all the</span>
            <span class="s5"># active bounds to the working set to prepare for the improvement</span>
            <span class="s5"># of the solution, and stop the iterations.</span>
            <span class="s0">if </span><span class="s1">alpha_xl </span><span class="s2">&lt;= </span><span class="s1">alpha</span><span class="s2">:</span>
                <span class="s1">i_new </span><span class="s2">= </span><span class="s1">_argmin</span><span class="s2">(</span><span class="s1">all_alpha_xl</span><span class="s2">)</span>
                <span class="s1">step</span><span class="s2">[</span><span class="s1">i_new</span><span class="s2">] = </span><span class="s1">xl</span><span class="s2">[</span><span class="s1">i_new</span><span class="s2">]</span>
                <span class="s1">free_bd</span><span class="s2">[</span><span class="s1">i_new</span><span class="s2">] = </span><span class="s0">False</span>
            <span class="s0">if </span><span class="s1">alpha_xu </span><span class="s2">&lt;= </span><span class="s1">alpha</span><span class="s2">:</span>
                <span class="s1">i_new </span><span class="s2">= </span><span class="s1">_argmin</span><span class="s2">(</span><span class="s1">all_alpha_xu</span><span class="s2">)</span>
                <span class="s1">step</span><span class="s2">[</span><span class="s1">i_new</span><span class="s2">] = </span><span class="s1">xu</span><span class="s2">[</span><span class="s1">i_new</span><span class="s2">]</span>
                <span class="s1">free_bd</span><span class="s2">[</span><span class="s1">i_new</span><span class="s2">] = </span><span class="s0">False</span>
            <span class="s1">boundary_reached </span><span class="s2">= </span><span class="s0">True</span>
            <span class="s0">break</span>

    <span class="s5"># Attempt to improve the solution on the trust-region boundary.</span>
    <span class="s0">if </span><span class="s1">kwargs</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s6">&quot;improve_tcg&quot;</span><span class="s2">, </span><span class="s0">True</span><span class="s2">) </span><span class="s0">and </span><span class="s1">boundary_reached</span><span class="s2">:</span>
        <span class="s1">step_base </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">(</span><span class="s1">step</span><span class="s2">)</span>
        <span class="s1">step_comparator </span><span class="s2">= </span><span class="s1">grad_orig </span><span class="s2">@ </span><span class="s1">step_base </span><span class="s2">+ </span><span class="s4">0.5 </span><span class="s2">* </span><span class="s1">step_base </span><span class="s2">@ </span><span class="s1">hess_prod</span><span class="s2">(</span>
            <span class="s1">step_base</span>
        <span class="s2">)</span>

        <span class="s0">while </span><span class="s1">np</span><span class="s2">.</span><span class="s1">count_nonzero</span><span class="s2">(</span><span class="s1">free_bd</span><span class="s2">) &gt; </span><span class="s4">0</span><span class="s2">:</span>
            <span class="s5"># Check whether a substantial reduction in the objective function</span>
            <span class="s5"># is possible, and set the search direction.</span>
            <span class="s1">step_sq </span><span class="s2">= </span><span class="s1">step</span><span class="s2">[</span><span class="s1">free_bd</span><span class="s2">] @ </span><span class="s1">step</span><span class="s2">[</span><span class="s1">free_bd</span><span class="s2">]</span>
            <span class="s1">grad_sq </span><span class="s2">= </span><span class="s1">grad</span><span class="s2">[</span><span class="s1">free_bd</span><span class="s2">] @ </span><span class="s1">grad</span><span class="s2">[</span><span class="s1">free_bd</span><span class="s2">]</span>
            <span class="s1">grad_step </span><span class="s2">= </span><span class="s1">grad</span><span class="s2">[</span><span class="s1">free_bd</span><span class="s2">] @ </span><span class="s1">step</span><span class="s2">[</span><span class="s1">free_bd</span><span class="s2">]</span>
            <span class="s1">grad_sd </span><span class="s2">= -</span><span class="s1">np</span><span class="s2">.</span><span class="s1">sqrt</span><span class="s2">(</span><span class="s1">max</span><span class="s2">(</span><span class="s1">step_sq </span><span class="s2">* </span><span class="s1">grad_sq </span><span class="s2">- </span><span class="s1">grad_step</span><span class="s2">**</span><span class="s4">2.0</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">))</span>
            <span class="s1">sd</span><span class="s2">[</span><span class="s1">free_bd</span><span class="s2">] = </span><span class="s1">grad_step </span><span class="s2">* </span><span class="s1">step</span><span class="s2">[</span><span class="s1">free_bd</span><span class="s2">] - </span><span class="s1">step_sq </span><span class="s2">* </span><span class="s1">grad</span><span class="s2">[</span><span class="s1">free_bd</span><span class="s2">]</span>
            <span class="s1">sd</span><span class="s2">[~</span><span class="s1">free_bd</span><span class="s2">] = </span><span class="s4">0.0</span>
            <span class="s0">if </span><span class="s1">grad_sd </span><span class="s2">&gt;= -</span><span class="s4">1e-8 </span><span class="s2">* </span><span class="s1">reduct </span><span class="s0">or </span><span class="s1">np</span><span class="s2">.</span><span class="s1">any</span><span class="s2">(</span>
                <span class="s1">grad_sd </span><span class="s2">&gt;= -</span><span class="s1">TINY </span><span class="s2">* </span><span class="s1">np</span><span class="s2">.</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">sd</span><span class="s2">[</span><span class="s1">free_bd</span><span class="s2">])</span>
            <span class="s2">):</span>
                <span class="s0">break</span>
            <span class="s1">sd</span><span class="s2">[</span><span class="s1">free_bd</span><span class="s2">] /= -</span><span class="s1">grad_sd</span>

            <span class="s5"># Calculate an upper bound for the tangent of half the angle theta</span>
            <span class="s5"># of this alternative iteration. The step will be updated as:</span>
            <span class="s5"># step = cos(theta) * step + sin(theta) * sd.</span>
            <span class="s1">temp_xl </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">(</span><span class="s1">n</span><span class="s2">)</span>
            <span class="s1">temp_xu </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">(</span><span class="s1">n</span><span class="s2">)</span>
            <span class="s1">temp_xl</span><span class="s2">[</span><span class="s1">free_bd</span><span class="s2">] = (</span>
                <span class="s1">step</span><span class="s2">[</span><span class="s1">free_bd</span><span class="s2">] ** </span><span class="s4">2.0 </span><span class="s2">+ </span><span class="s1">sd</span><span class="s2">[</span><span class="s1">free_bd</span><span class="s2">] ** </span><span class="s4">2.0 </span><span class="s2">- </span><span class="s1">xl</span><span class="s2">[</span><span class="s1">free_bd</span><span class="s2">] ** </span><span class="s4">2.0</span>
            <span class="s2">)</span>
            <span class="s1">temp_xu</span><span class="s2">[</span><span class="s1">free_bd</span><span class="s2">] = (</span>
                <span class="s1">step</span><span class="s2">[</span><span class="s1">free_bd</span><span class="s2">] ** </span><span class="s4">2.0 </span><span class="s2">+ </span><span class="s1">sd</span><span class="s2">[</span><span class="s1">free_bd</span><span class="s2">] ** </span><span class="s4">2.0 </span><span class="s2">- </span><span class="s1">xu</span><span class="s2">[</span><span class="s1">free_bd</span><span class="s2">] ** </span><span class="s4">2.0</span>
            <span class="s2">)</span>
            <span class="s1">temp_xl</span><span class="s2">[</span><span class="s1">temp_xl </span><span class="s2">&gt; </span><span class="s4">0.0</span><span class="s2">] = (</span>
                <span class="s1">np</span><span class="s2">.</span><span class="s1">sqrt</span><span class="s2">(</span><span class="s1">temp_xl</span><span class="s2">[</span><span class="s1">temp_xl </span><span class="s2">&gt; </span><span class="s4">0.0</span><span class="s2">]) - </span><span class="s1">sd</span><span class="s2">[</span><span class="s1">temp_xl </span><span class="s2">&gt; </span><span class="s4">0.0</span><span class="s2">]</span>
            <span class="s2">)</span>
            <span class="s1">temp_xu</span><span class="s2">[</span><span class="s1">temp_xu </span><span class="s2">&gt; </span><span class="s4">0.0</span><span class="s2">] = (</span>
                <span class="s1">np</span><span class="s2">.</span><span class="s1">sqrt</span><span class="s2">(</span><span class="s1">temp_xu</span><span class="s2">[</span><span class="s1">temp_xu </span><span class="s2">&gt; </span><span class="s4">0.0</span><span class="s2">]) + </span><span class="s1">sd</span><span class="s2">[</span><span class="s1">temp_xu </span><span class="s2">&gt; </span><span class="s4">0.0</span><span class="s2">]</span>
            <span class="s2">)</span>
            <span class="s1">dist_xl </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">maximum</span><span class="s2">(</span><span class="s1">step </span><span class="s2">- </span><span class="s1">xl</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">)</span>
            <span class="s1">dist_xu </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">maximum</span><span class="s2">(</span><span class="s1">xu </span><span class="s2">- </span><span class="s1">step</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">)</span>
            <span class="s1">i_xl </span><span class="s2">= </span><span class="s1">temp_xl </span><span class="s2">&gt; </span><span class="s1">TINY </span><span class="s2">* </span><span class="s1">dist_xl</span>
            <span class="s1">i_xu </span><span class="s2">= </span><span class="s1">temp_xu </span><span class="s2">&gt; </span><span class="s1">TINY </span><span class="s2">* </span><span class="s1">dist_xu</span>
            <span class="s1">all_t_xl </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">(</span><span class="s1">n</span><span class="s2">)</span>
            <span class="s1">all_t_xu </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">(</span><span class="s1">n</span><span class="s2">)</span>
            <span class="s1">all_t_xl</span><span class="s2">[</span><span class="s1">i_xl</span><span class="s2">] = </span><span class="s1">np</span><span class="s2">.</span><span class="s1">minimum</span><span class="s2">(</span>
                <span class="s1">all_t_xl</span><span class="s2">[</span><span class="s1">i_xl</span><span class="s2">],</span>
                <span class="s1">dist_xl</span><span class="s2">[</span><span class="s1">i_xl</span><span class="s2">] / </span><span class="s1">temp_xl</span><span class="s2">[</span><span class="s1">i_xl</span><span class="s2">],</span>
            <span class="s2">)</span>
            <span class="s1">all_t_xu</span><span class="s2">[</span><span class="s1">i_xu</span><span class="s2">] = </span><span class="s1">np</span><span class="s2">.</span><span class="s1">minimum</span><span class="s2">(</span>
                <span class="s1">all_t_xu</span><span class="s2">[</span><span class="s1">i_xu</span><span class="s2">],</span>
                <span class="s1">dist_xu</span><span class="s2">[</span><span class="s1">i_xu</span><span class="s2">] / </span><span class="s1">temp_xu</span><span class="s2">[</span><span class="s1">i_xu</span><span class="s2">],</span>
            <span class="s2">)</span>
            <span class="s1">t_xl </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">min</span><span class="s2">(</span><span class="s1">all_t_xl</span><span class="s2">)</span>
            <span class="s1">t_xu </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">min</span><span class="s2">(</span><span class="s1">all_t_xu</span><span class="s2">)</span>
            <span class="s1">t_bd </span><span class="s2">= </span><span class="s1">min</span><span class="s2">(</span><span class="s1">t_xl</span><span class="s2">, </span><span class="s1">t_xu</span><span class="s2">)</span>

            <span class="s5"># Calculate some curvature information.</span>
            <span class="s1">hess_step </span><span class="s2">= </span><span class="s1">hess_prod</span><span class="s2">(</span><span class="s1">step</span><span class="s2">)</span>
            <span class="s1">hess_sd </span><span class="s2">= </span><span class="s1">hess_prod</span><span class="s2">(</span><span class="s1">sd</span><span class="s2">)</span>
            <span class="s1">curv_step </span><span class="s2">= </span><span class="s1">step </span><span class="s2">@ </span><span class="s1">hess_step</span>
            <span class="s1">curv_sd </span><span class="s2">= </span><span class="s1">sd </span><span class="s2">@ </span><span class="s1">hess_sd</span>
            <span class="s1">curv_step_sd </span><span class="s2">= </span><span class="s1">step </span><span class="s2">@ </span><span class="s1">hess_sd</span>

            <span class="s5"># For a range of equally spaced values of tan(0.5 * theta),</span>
            <span class="s5"># calculate the reduction in the objective function that would be</span>
            <span class="s5"># obtained by accepting the corresponding angle.</span>
            <span class="s1">n_samples </span><span class="s2">= </span><span class="s4">20</span>
            <span class="s1">n_samples </span><span class="s2">= </span><span class="s1">int</span><span class="s2">((</span><span class="s1">n_samples </span><span class="s2">- </span><span class="s4">3</span><span class="s2">) * </span><span class="s1">t_bd </span><span class="s2">+ </span><span class="s4">3</span><span class="s2">)</span>
            <span class="s1">t_samples </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linspace</span><span class="s2">(</span><span class="s1">t_bd </span><span class="s2">/ </span><span class="s1">n_samples</span><span class="s2">, </span><span class="s1">t_bd</span><span class="s2">, </span><span class="s1">n_samples</span><span class="s2">)</span>
            <span class="s1">sin_values </span><span class="s2">= </span><span class="s4">2.0 </span><span class="s2">* </span><span class="s1">t_samples </span><span class="s2">/ (</span><span class="s4">1.0 </span><span class="s2">+ </span><span class="s1">t_samples</span><span class="s2">**</span><span class="s4">2.0</span><span class="s2">)</span>
            <span class="s1">all_reduct </span><span class="s2">= </span><span class="s1">sin_values </span><span class="s2">* (</span>
                <span class="s1">grad_step </span><span class="s2">* </span><span class="s1">t_samples</span>
                <span class="s2">- </span><span class="s1">grad_sd</span>
                <span class="s2">- </span><span class="s1">t_samples </span><span class="s2">* </span><span class="s1">curv_step</span>
                <span class="s2">+ </span><span class="s1">sin_values</span>
                <span class="s2">* (</span><span class="s1">t_samples </span><span class="s2">* </span><span class="s1">curv_step_sd </span><span class="s2">- </span><span class="s4">0.5 </span><span class="s2">* (</span><span class="s1">curv_sd </span><span class="s2">- </span><span class="s1">curv_step</span><span class="s2">))</span>
            <span class="s2">)</span>
            <span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">all</span><span class="s2">(</span><span class="s1">all_reduct </span><span class="s2">&lt;= </span><span class="s4">0.0</span><span class="s2">):</span>
                <span class="s5"># No reduction in the objective function is obtained.</span>
                <span class="s0">break</span>

            <span class="s5"># Accept the angle that provides the largest reduction in the</span>
            <span class="s5"># objective function, and update the iterate.</span>
            <span class="s1">i_max </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">argmax</span><span class="s2">(</span><span class="s1">all_reduct</span><span class="s2">)</span>
            <span class="s1">cos_value </span><span class="s2">= (</span><span class="s4">1.0 </span><span class="s2">- </span><span class="s1">t_samples</span><span class="s2">[</span><span class="s1">i_max</span><span class="s2">] ** </span><span class="s4">2.0</span><span class="s2">) / (</span>
                <span class="s4">1.0 </span><span class="s2">+ </span><span class="s1">t_samples</span><span class="s2">[</span><span class="s1">i_max</span><span class="s2">] ** </span><span class="s4">2.0</span>
            <span class="s2">)</span>
            <span class="s1">step</span><span class="s2">[</span><span class="s1">free_bd</span><span class="s2">] = (</span>
                <span class="s1">cos_value </span><span class="s2">* </span><span class="s1">step</span><span class="s2">[</span><span class="s1">free_bd</span><span class="s2">] + </span><span class="s1">sin_values</span><span class="s2">[</span><span class="s1">i_max</span><span class="s2">] * </span><span class="s1">sd</span><span class="s2">[</span><span class="s1">free_bd</span><span class="s2">]</span>
            <span class="s2">)</span>
            <span class="s1">grad </span><span class="s2">+= (</span><span class="s1">cos_value </span><span class="s2">- </span><span class="s4">1.0</span><span class="s2">) * </span><span class="s1">hess_step </span><span class="s2">+ </span><span class="s1">sin_values</span><span class="s2">[</span><span class="s1">i_max</span><span class="s2">] * </span><span class="s1">hess_sd</span>
            <span class="s1">reduct </span><span class="s2">+= </span><span class="s1">all_reduct</span><span class="s2">[</span><span class="s1">i_max</span><span class="s2">]</span>

            <span class="s5"># If the above angle is restricted by bound constraints, add them</span>
            <span class="s5"># to the working set, and restart the alternative iteration.</span>
            <span class="s5"># Otherwise, the calculations are terminated.</span>
            <span class="s0">if </span><span class="s1">t_bd </span><span class="s2">&lt; </span><span class="s4">1.0 </span><span class="s0">and </span><span class="s1">i_max </span><span class="s2">== </span><span class="s1">n_samples </span><span class="s2">- </span><span class="s4">1</span><span class="s2">:</span>
                <span class="s0">if </span><span class="s1">t_xl </span><span class="s2">&lt;= </span><span class="s1">t_bd</span><span class="s2">:</span>
                    <span class="s1">i_new </span><span class="s2">= </span><span class="s1">_argmin</span><span class="s2">(</span><span class="s1">all_t_xl</span><span class="s2">)</span>
                    <span class="s1">step</span><span class="s2">[</span><span class="s1">i_new</span><span class="s2">] = </span><span class="s1">xl</span><span class="s2">[</span><span class="s1">i_new</span><span class="s2">]</span>
                    <span class="s1">free_bd</span><span class="s2">[</span><span class="s1">i_new</span><span class="s2">] = </span><span class="s0">False</span>
                <span class="s0">if </span><span class="s1">t_xu </span><span class="s2">&lt;= </span><span class="s1">t_bd</span><span class="s2">:</span>
                    <span class="s1">i_new </span><span class="s2">= </span><span class="s1">_argmin</span><span class="s2">(</span><span class="s1">all_t_xu</span><span class="s2">)</span>
                    <span class="s1">step</span><span class="s2">[</span><span class="s1">i_new</span><span class="s2">] = </span><span class="s1">xu</span><span class="s2">[</span><span class="s1">i_new</span><span class="s2">]</span>
                    <span class="s1">free_bd</span><span class="s2">[</span><span class="s1">i_new</span><span class="s2">] = </span><span class="s0">False</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s0">break</span>

        <span class="s5"># Ensure that the alternative iteration improves the objective</span>
        <span class="s5"># function.</span>
        <span class="s0">if </span><span class="s1">grad_orig </span><span class="s2">@ </span><span class="s1">step </span><span class="s2">+ </span><span class="s4">0.5 </span><span class="s2">* </span><span class="s1">step </span><span class="s2">@ </span><span class="s1">hess_prod</span><span class="s2">(</span><span class="s1">step</span><span class="s2">) &gt; </span><span class="s1">step_comparator</span><span class="s2">:</span>
            <span class="s1">step </span><span class="s2">= </span><span class="s1">step_base</span>

    <span class="s0">if </span><span class="s1">debug</span><span class="s2">:</span>
        <span class="s0">assert </span><span class="s1">np</span><span class="s2">.</span><span class="s1">all</span><span class="s2">(</span><span class="s1">xl </span><span class="s2">&lt;= </span><span class="s1">step</span><span class="s2">)</span>
        <span class="s0">assert </span><span class="s1">np</span><span class="s2">.</span><span class="s1">all</span><span class="s2">(</span><span class="s1">step </span><span class="s2">&lt;= </span><span class="s1">xu</span><span class="s2">)</span>
        <span class="s0">assert </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">norm</span><span class="s2">(</span><span class="s1">step</span><span class="s2">) &lt; </span><span class="s4">1.1 </span><span class="s2">* </span><span class="s1">delta</span>
    <span class="s0">return </span><span class="s1">step</span>


<span class="s0">def </span><span class="s1">constrained_tangential_byrd_omojokun</span><span class="s2">(</span>
    <span class="s1">grad</span><span class="s2">,</span>
    <span class="s1">hess_prod</span><span class="s2">,</span>
    <span class="s1">xl</span><span class="s2">,</span>
    <span class="s1">xu</span><span class="s2">,</span>
    <span class="s1">aub</span><span class="s2">,</span>
    <span class="s1">bub</span><span class="s2">,</span>
    <span class="s1">aeq</span><span class="s2">,</span>
    <span class="s1">delta</span><span class="s2">,</span>
    <span class="s1">debug</span><span class="s2">,</span>
    <span class="s2">**</span><span class="s1">kwargs</span><span class="s2">,</span>
<span class="s2">):</span>
    <span class="s3">r&quot;&quot;&quot; 
    Minimize approximately a quadratic function subject to bound and linear 
    constraints in a trust region. 
 
    This function solves approximately 
 
    .. math:: 
 
        \min_{s \in \mathbb{R}^n} \quad g^{\mathsf{T}} s + \frac{1}{2} 
        s^{\mathsf{T}} H s \quad \text{s.t.} \quad 
        \left\{ \begin{array}{l} 
            l \le s \le u,\\ 
            A_{\scriptscriptstyle I} s \le b_{\scriptscriptstyle I},\\ 
            A_{\scriptscriptstyle E} s = 0,\\ 
            \lVert s \rVert \le \Delta, 
        \end{array} \right. 
 
    using an active-set variation of the truncated conjugate gradient method. 
 
    Parameters 
    ---------- 
    grad : `numpy.ndarray`, shape (n,) 
        Gradient :math:`g` as shown above. 
    hess_prod : callable 
        Product of the Hessian matrix :math:`H` with any vector. 
 
            ``hess_prod(s) -&gt; `numpy.ndarray`, shape (n,)`` 
 
        returns the product :math:`H s`. 
    xl : `numpy.ndarray`, shape (n,) 
        Lower bounds :math:`l` as shown above. 
    xu : `numpy.ndarray`, shape (n,) 
        Upper bounds :math:`u` as shown above. 
    aub : `numpy.ndarray`, shape (m_linear_ub, n) 
        Coefficient matrix :math:`A_{\scriptscriptstyle I}` as shown above. 
    bub : `numpy.ndarray`, shape (m_linear_ub,) 
        Right-hand side :math:`b_{\scriptscriptstyle I}` as shown above. 
    aeq : `numpy.ndarray`, shape (m_linear_eq, n) 
        Coefficient matrix :math:`A_{\scriptscriptstyle E}` as shown above. 
    delta : float 
        Trust-region radius :math:`\Delta` as shown above. 
    debug : bool 
        Whether to make debugging tests during the execution. 
 
    Returns 
    ------- 
    `numpy.ndarray`, shape (n,) 
        Approximate solution :math:`s`. 
 
    Other Parameters 
    ---------------- 
    improve_tcg : bool, optional 
        If True, a solution generated by the truncated conjugate gradient 
        method that is on the boundary of the trust region is improved by 
        moving around the trust-region boundary on the two-dimensional space 
        spanned by the solution and the gradient of the quadratic function at 
        the solution (default is True). 
 
    Notes 
    ----- 
    This function implements Algorithm 6.3 of [1]_. It is assumed that the 
    origin is feasible with respect to the bound and linear constraints, and 
    that `delta` is finite and positive. 
 
    References 
    ---------- 
    .. [1] T. M. Ragonneau. *Model-Based Derivative-Free Optimization Methods 
       and Software*. PhD thesis, Department of Applied Mathematics, The Hong 
       Kong Polytechnic University, Hong Kong, China, 2022. URL: 
       https://theses.lib.polyu.edu.hk/handle/200/12294. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">debug</span><span class="s2">:</span>
        <span class="s0">assert </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">grad</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">) </span><span class="s0">and </span><span class="s1">grad</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s4">1</span>
        <span class="s0">assert </span><span class="s1">inspect</span><span class="s2">.</span><span class="s1">signature</span><span class="s2">(</span><span class="s1">hess_prod</span><span class="s2">).</span><span class="s1">bind</span><span class="s2">(</span><span class="s1">grad</span><span class="s2">)</span>
        <span class="s0">assert </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">xl</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">) </span><span class="s0">and </span><span class="s1">xl</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">== </span><span class="s1">grad</span><span class="s2">.</span><span class="s1">shape</span>
        <span class="s0">assert </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">xu</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">) </span><span class="s0">and </span><span class="s1">xu</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">== </span><span class="s1">grad</span><span class="s2">.</span><span class="s1">shape</span>
        <span class="s0">assert </span><span class="s2">(</span>
            <span class="s1">isinstance</span><span class="s2">(</span><span class="s1">aub</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">)</span>
            <span class="s0">and </span><span class="s1">aub</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s4">2</span>
            <span class="s0">and </span><span class="s1">aub</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s4">1</span><span class="s2">] == </span><span class="s1">grad</span><span class="s2">.</span><span class="s1">size</span>
        <span class="s2">)</span>
        <span class="s0">assert </span><span class="s2">(</span>
            <span class="s1">isinstance</span><span class="s2">(</span><span class="s1">bub</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">)</span>
            <span class="s0">and </span><span class="s1">bub</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s4">1</span>
            <span class="s0">and </span><span class="s1">bub</span><span class="s2">.</span><span class="s1">size </span><span class="s2">== </span><span class="s1">aub</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s4">0</span><span class="s2">]</span>
        <span class="s2">)</span>
        <span class="s0">assert </span><span class="s2">(</span>
            <span class="s1">isinstance</span><span class="s2">(</span><span class="s1">aeq</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">)</span>
            <span class="s0">and </span><span class="s1">aeq</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s4">2</span>
            <span class="s0">and </span><span class="s1">aeq</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s4">1</span><span class="s2">] == </span><span class="s1">grad</span><span class="s2">.</span><span class="s1">size</span>
        <span class="s2">)</span>
        <span class="s0">assert </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">delta</span><span class="s2">, </span><span class="s1">float</span><span class="s2">)</span>
        <span class="s0">assert </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">debug</span><span class="s2">, </span><span class="s1">bool</span><span class="s2">)</span>
        <span class="s1">tol </span><span class="s2">= </span><span class="s1">get_arrays_tol</span><span class="s2">(</span><span class="s1">xl</span><span class="s2">, </span><span class="s1">xu</span><span class="s2">)</span>
        <span class="s0">assert </span><span class="s1">np</span><span class="s2">.</span><span class="s1">all</span><span class="s2">(</span><span class="s1">xl </span><span class="s2">&lt;= </span><span class="s1">tol</span><span class="s2">)</span>
        <span class="s0">assert </span><span class="s1">np</span><span class="s2">.</span><span class="s1">all</span><span class="s2">(</span><span class="s1">xu </span><span class="s2">&gt;= -</span><span class="s1">tol</span><span class="s2">)</span>
        <span class="s0">assert </span><span class="s1">np</span><span class="s2">.</span><span class="s1">all</span><span class="s2">(</span><span class="s1">bub </span><span class="s2">&gt;= -</span><span class="s1">tol</span><span class="s2">)</span>
        <span class="s0">assert </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isfinite</span><span class="s2">(</span><span class="s1">delta</span><span class="s2">) </span><span class="s0">and </span><span class="s1">delta </span><span class="s2">&gt; </span><span class="s4">0.0</span>
    <span class="s1">xl </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">minimum</span><span class="s2">(</span><span class="s1">xl</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">)</span>
    <span class="s1">xu </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">maximum</span><span class="s2">(</span><span class="s1">xu</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">)</span>
    <span class="s1">bub </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">maximum</span><span class="s2">(</span><span class="s1">bub</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">)</span>

    <span class="s5"># Copy the arrays that may be modified by the code below.</span>
    <span class="s1">n </span><span class="s2">= </span><span class="s1">grad</span><span class="s2">.</span><span class="s1">size</span>
    <span class="s1">grad </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">(</span><span class="s1">grad</span><span class="s2">)</span>
    <span class="s1">grad_orig </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">(</span><span class="s1">grad</span><span class="s2">)</span>

    <span class="s5"># Calculate the initial active set.</span>
    <span class="s1">free_xl </span><span class="s2">= (</span><span class="s1">xl </span><span class="s2">&lt; </span><span class="s4">0.0</span><span class="s2">) | (</span><span class="s1">grad </span><span class="s2">&lt; </span><span class="s4">0.0</span><span class="s2">)</span>
    <span class="s1">free_xu </span><span class="s2">= (</span><span class="s1">xu </span><span class="s2">&gt; </span><span class="s4">0.0</span><span class="s2">) | (</span><span class="s1">grad </span><span class="s2">&gt; </span><span class="s4">0.0</span><span class="s2">)</span>
    <span class="s1">free_ub </span><span class="s2">= (</span><span class="s1">bub </span><span class="s2">&gt; </span><span class="s4">0.0</span><span class="s2">) | (</span><span class="s1">aub </span><span class="s2">@ </span><span class="s1">grad </span><span class="s2">&gt; </span><span class="s4">0.0</span><span class="s2">)</span>
    <span class="s1">n_act</span><span class="s2">, </span><span class="s1">q </span><span class="s2">= </span><span class="s1">qr_tangential_byrd_omojokun</span><span class="s2">(</span><span class="s1">aub</span><span class="s2">, </span><span class="s1">aeq</span><span class="s2">, </span><span class="s1">free_xl</span><span class="s2">, </span><span class="s1">free_xu</span><span class="s2">, </span><span class="s1">free_ub</span><span class="s2">)</span>

    <span class="s5"># Set the initial iterate and the initial search direction.</span>
    <span class="s1">step </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros_like</span><span class="s2">(</span><span class="s1">grad</span><span class="s2">)</span>
    <span class="s1">sd </span><span class="s2">= -</span><span class="s1">q</span><span class="s2">[:, </span><span class="s1">n_act</span><span class="s2">:] @ (</span><span class="s1">q</span><span class="s2">[:, </span><span class="s1">n_act</span><span class="s2">:].</span><span class="s1">T </span><span class="s2">@ </span><span class="s1">grad</span><span class="s2">)</span>
    <span class="s1">resid </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">(</span><span class="s1">bub</span><span class="s2">)</span>

    <span class="s1">k </span><span class="s2">= </span><span class="s4">0</span>
    <span class="s1">reduct </span><span class="s2">= </span><span class="s4">0.0</span>
    <span class="s1">boundary_reached </span><span class="s2">= </span><span class="s0">False</span>
    <span class="s0">while </span><span class="s1">k </span><span class="s2">&lt; </span><span class="s1">n </span><span class="s2">- </span><span class="s1">n_act</span><span class="s2">:</span>
        <span class="s5"># Stop the computations if sd is not a descent direction.</span>
        <span class="s1">grad_sd </span><span class="s2">= </span><span class="s1">grad </span><span class="s2">@ </span><span class="s1">sd</span>
        <span class="s0">if </span><span class="s1">grad_sd </span><span class="s2">&gt;= -</span><span class="s4">10.0 </span><span class="s2">* </span><span class="s1">EPS </span><span class="s2">* </span><span class="s1">n </span><span class="s2">* </span><span class="s1">max</span><span class="s2">(</span><span class="s4">1.0</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">norm</span><span class="s2">(</span><span class="s1">grad</span><span class="s2">)):</span>
            <span class="s0">break</span>

        <span class="s5"># Set alpha_tr to the step size for the trust-region constraint.</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s1">alpha_tr </span><span class="s2">= </span><span class="s1">_alpha_tr</span><span class="s2">(</span><span class="s1">step</span><span class="s2">, </span><span class="s1">sd</span><span class="s2">, </span><span class="s1">delta</span><span class="s2">)</span>
        <span class="s0">except </span><span class="s1">ZeroDivisionError</span><span class="s2">:</span>
            <span class="s0">break</span>

        <span class="s5"># Stop the computations if a step along sd is expected to give a</span>
        <span class="s5"># relatively small reduction in the objective function.</span>
        <span class="s0">if </span><span class="s2">-</span><span class="s1">alpha_tr </span><span class="s2">* </span><span class="s1">grad_sd </span><span class="s2">&lt;= </span><span class="s4">1e-8 </span><span class="s2">* </span><span class="s1">reduct</span><span class="s2">:</span>
            <span class="s0">break</span>

        <span class="s5"># Set alpha_quad to the step size for the minimization problem.</span>
        <span class="s1">hess_sd </span><span class="s2">= </span><span class="s1">hess_prod</span><span class="s2">(</span><span class="s1">sd</span><span class="s2">)</span>
        <span class="s1">curv_sd </span><span class="s2">= </span><span class="s1">sd </span><span class="s2">@ </span><span class="s1">hess_sd</span>
        <span class="s0">if </span><span class="s1">curv_sd </span><span class="s2">&gt; </span><span class="s1">TINY </span><span class="s2">* </span><span class="s1">abs</span><span class="s2">(</span><span class="s1">grad_sd</span><span class="s2">):</span>
            <span class="s1">alpha_quad </span><span class="s2">= </span><span class="s1">max</span><span class="s2">(-</span><span class="s1">grad_sd </span><span class="s2">/ </span><span class="s1">curv_sd</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">alpha_quad </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span>

        <span class="s5"># Stop the computations if the reduction in the objective function</span>
        <span class="s5"># provided by an unconstrained step is small.</span>
        <span class="s1">alpha </span><span class="s2">= </span><span class="s1">min</span><span class="s2">(</span><span class="s1">alpha_tr</span><span class="s2">, </span><span class="s1">alpha_quad</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s2">-</span><span class="s1">alpha </span><span class="s2">* (</span><span class="s1">grad_sd </span><span class="s2">+ </span><span class="s4">0.5 </span><span class="s2">* </span><span class="s1">alpha </span><span class="s2">* </span><span class="s1">curv_sd</span><span class="s2">) &lt;= </span><span class="s4">1e-8 </span><span class="s2">* </span><span class="s1">reduct</span><span class="s2">:</span>
            <span class="s0">break</span>

        <span class="s5"># Set alpha_bd to the step size for the bound constraints.</span>
        <span class="s1">i_xl </span><span class="s2">= </span><span class="s1">free_xl </span><span class="s2">&amp; (</span><span class="s1">xl </span><span class="s2">&gt; -</span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span><span class="s2">) &amp; (</span><span class="s1">sd </span><span class="s2">&lt; -</span><span class="s1">TINY </span><span class="s2">* </span><span class="s1">np</span><span class="s2">.</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">xl </span><span class="s2">- </span><span class="s1">step</span><span class="s2">))</span>
        <span class="s1">i_xu </span><span class="s2">= </span><span class="s1">free_xu </span><span class="s2">&amp; (</span><span class="s1">xu </span><span class="s2">&lt; </span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span><span class="s2">) &amp; (</span><span class="s1">sd </span><span class="s2">&gt; </span><span class="s1">TINY </span><span class="s2">* </span><span class="s1">np</span><span class="s2">.</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">xu </span><span class="s2">- </span><span class="s1">step</span><span class="s2">))</span>
        <span class="s1">all_alpha_xl </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">full_like</span><span class="s2">(</span><span class="s1">step</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span><span class="s2">)</span>
        <span class="s1">all_alpha_xu </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">full_like</span><span class="s2">(</span><span class="s1">step</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span><span class="s2">)</span>
        <span class="s1">all_alpha_xl</span><span class="s2">[</span><span class="s1">i_xl</span><span class="s2">] = </span><span class="s1">np</span><span class="s2">.</span><span class="s1">maximum</span><span class="s2">(</span>
            <span class="s2">(</span><span class="s1">xl</span><span class="s2">[</span><span class="s1">i_xl</span><span class="s2">] - </span><span class="s1">step</span><span class="s2">[</span><span class="s1">i_xl</span><span class="s2">]) / </span><span class="s1">sd</span><span class="s2">[</span><span class="s1">i_xl</span><span class="s2">],</span>
            <span class="s4">0.0</span><span class="s2">,</span>
        <span class="s2">)</span>
        <span class="s1">all_alpha_xu</span><span class="s2">[</span><span class="s1">i_xu</span><span class="s2">] = </span><span class="s1">np</span><span class="s2">.</span><span class="s1">maximum</span><span class="s2">(</span>
            <span class="s2">(</span><span class="s1">xu</span><span class="s2">[</span><span class="s1">i_xu</span><span class="s2">] - </span><span class="s1">step</span><span class="s2">[</span><span class="s1">i_xu</span><span class="s2">]) / </span><span class="s1">sd</span><span class="s2">[</span><span class="s1">i_xu</span><span class="s2">],</span>
            <span class="s4">0.0</span><span class="s2">,</span>
        <span class="s2">)</span>
        <span class="s1">alpha_xl </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">min</span><span class="s2">(</span><span class="s1">all_alpha_xl</span><span class="s2">)</span>
        <span class="s1">alpha_xu </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">min</span><span class="s2">(</span><span class="s1">all_alpha_xu</span><span class="s2">)</span>
        <span class="s1">alpha_bd </span><span class="s2">= </span><span class="s1">min</span><span class="s2">(</span><span class="s1">alpha_xl</span><span class="s2">, </span><span class="s1">alpha_xu</span><span class="s2">)</span>

        <span class="s5"># Set alpha_ub to the step size for the linear constraints.</span>
        <span class="s1">aub_sd </span><span class="s2">= </span><span class="s1">aub </span><span class="s2">@ </span><span class="s1">sd</span>
        <span class="s1">i_ub </span><span class="s2">= </span><span class="s1">free_ub </span><span class="s2">&amp; (</span><span class="s1">aub_sd </span><span class="s2">&gt; </span><span class="s1">TINY </span><span class="s2">* </span><span class="s1">np</span><span class="s2">.</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">resid</span><span class="s2">))</span>
        <span class="s1">all_alpha_ub </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">full_like</span><span class="s2">(</span><span class="s1">bub</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span><span class="s2">)</span>
        <span class="s1">all_alpha_ub</span><span class="s2">[</span><span class="s1">i_ub</span><span class="s2">] = </span><span class="s1">resid</span><span class="s2">[</span><span class="s1">i_ub</span><span class="s2">] / </span><span class="s1">aub_sd</span><span class="s2">[</span><span class="s1">i_ub</span><span class="s2">]</span>
        <span class="s1">alpha_ub </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">min</span><span class="s2">(</span><span class="s1">all_alpha_ub</span><span class="s2">, </span><span class="s1">initial</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span><span class="s2">)</span>

        <span class="s5"># Update the iterate.</span>
        <span class="s1">alpha </span><span class="s2">= </span><span class="s1">min</span><span class="s2">(</span><span class="s1">alpha</span><span class="s2">, </span><span class="s1">alpha_bd</span><span class="s2">, </span><span class="s1">alpha_ub</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">alpha </span><span class="s2">&gt; </span><span class="s4">0.0</span><span class="s2">:</span>
            <span class="s1">step </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">clip</span><span class="s2">(</span><span class="s1">step </span><span class="s2">+ </span><span class="s1">alpha </span><span class="s2">* </span><span class="s1">sd</span><span class="s2">, </span><span class="s1">xl</span><span class="s2">, </span><span class="s1">xu</span><span class="s2">)</span>
            <span class="s1">grad </span><span class="s2">+= </span><span class="s1">alpha </span><span class="s2">* </span><span class="s1">hess_sd</span>
            <span class="s1">resid </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">maximum</span><span class="s2">(</span><span class="s4">0.0</span><span class="s2">, </span><span class="s1">resid </span><span class="s2">- </span><span class="s1">alpha </span><span class="s2">* </span><span class="s1">aub_sd</span><span class="s2">)</span>
            <span class="s1">reduct </span><span class="s2">-= </span><span class="s1">alpha </span><span class="s2">* (</span><span class="s1">grad_sd </span><span class="s2">+ </span><span class="s4">0.5 </span><span class="s2">* </span><span class="s1">alpha </span><span class="s2">* </span><span class="s1">curv_sd</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">alpha </span><span class="s2">&lt; </span><span class="s1">min</span><span class="s2">(</span><span class="s1">alpha_tr</span><span class="s2">, </span><span class="s1">alpha_bd</span><span class="s2">, </span><span class="s1">alpha_ub</span><span class="s2">):</span>
            <span class="s5"># The current iteration is a conjugate gradient iteration. Update</span>
            <span class="s5"># the search direction so that it is conjugate (with respect to H)</span>
            <span class="s5"># to all the previous search directions.</span>
            <span class="s1">grad_proj </span><span class="s2">= </span><span class="s1">q</span><span class="s2">[:, </span><span class="s1">n_act</span><span class="s2">:] @ (</span><span class="s1">q</span><span class="s2">[:, </span><span class="s1">n_act</span><span class="s2">:].</span><span class="s1">T </span><span class="s2">@ </span><span class="s1">grad</span><span class="s2">)</span>
            <span class="s1">beta </span><span class="s2">= (</span><span class="s1">grad_proj </span><span class="s2">@ </span><span class="s1">hess_sd</span><span class="s2">) / </span><span class="s1">curv_sd</span>
            <span class="s1">sd </span><span class="s2">= </span><span class="s1">beta </span><span class="s2">* </span><span class="s1">sd </span><span class="s2">- </span><span class="s1">grad_proj</span>
            <span class="s1">k </span><span class="s2">+= </span><span class="s4">1</span>
        <span class="s0">elif </span><span class="s1">alpha </span><span class="s2">&lt; </span><span class="s1">alpha_tr</span><span class="s2">:</span>
            <span class="s5"># The iterate is restricted by a bound/linear constraint. Add this</span>
            <span class="s5"># constraint to the active set, and restart the calculations.</span>
            <span class="s0">if </span><span class="s1">alpha_xl </span><span class="s2">&lt;= </span><span class="s1">alpha</span><span class="s2">:</span>
                <span class="s1">i_new </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">argmin</span><span class="s2">(</span><span class="s1">all_alpha_xl</span><span class="s2">)</span>
                <span class="s1">step</span><span class="s2">[</span><span class="s1">i_new</span><span class="s2">] = </span><span class="s1">xl</span><span class="s2">[</span><span class="s1">i_new</span><span class="s2">]</span>
                <span class="s1">free_xl</span><span class="s2">[</span><span class="s1">i_new</span><span class="s2">] = </span><span class="s0">False</span>
            <span class="s0">elif </span><span class="s1">alpha_xu </span><span class="s2">&lt;= </span><span class="s1">alpha</span><span class="s2">:</span>
                <span class="s1">i_new </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">argmin</span><span class="s2">(</span><span class="s1">all_alpha_xu</span><span class="s2">)</span>
                <span class="s1">step</span><span class="s2">[</span><span class="s1">i_new</span><span class="s2">] = </span><span class="s1">xu</span><span class="s2">[</span><span class="s1">i_new</span><span class="s2">]</span>
                <span class="s1">free_xu</span><span class="s2">[</span><span class="s1">i_new</span><span class="s2">] = </span><span class="s0">False</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">i_new </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">argmin</span><span class="s2">(</span><span class="s1">all_alpha_ub</span><span class="s2">)</span>
                <span class="s1">free_ub</span><span class="s2">[</span><span class="s1">i_new</span><span class="s2">] = </span><span class="s0">False</span>
            <span class="s1">n_act</span><span class="s2">, </span><span class="s1">q </span><span class="s2">= </span><span class="s1">qr_tangential_byrd_omojokun</span><span class="s2">(</span>
                <span class="s1">aub</span><span class="s2">,</span>
                <span class="s1">aeq</span><span class="s2">,</span>
                <span class="s1">free_xl</span><span class="s2">,</span>
                <span class="s1">free_xu</span><span class="s2">,</span>
                <span class="s1">free_ub</span><span class="s2">,</span>
            <span class="s2">)</span>
            <span class="s1">sd </span><span class="s2">= -</span><span class="s1">q</span><span class="s2">[:, </span><span class="s1">n_act</span><span class="s2">:] @ (</span><span class="s1">q</span><span class="s2">[:, </span><span class="s1">n_act</span><span class="s2">:].</span><span class="s1">T </span><span class="s2">@ </span><span class="s1">grad</span><span class="s2">)</span>
            <span class="s1">k </span><span class="s2">= </span><span class="s4">0</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s5"># The current iterate is on the trust-region boundary. Add all the</span>
            <span class="s5"># active bound/linear constraints to the working set to prepare for</span>
            <span class="s5"># the improvement of the solution, and stop the iterations.</span>
            <span class="s0">if </span><span class="s1">alpha_xl </span><span class="s2">&lt;= </span><span class="s1">alpha</span><span class="s2">:</span>
                <span class="s1">i_new </span><span class="s2">= </span><span class="s1">_argmin</span><span class="s2">(</span><span class="s1">all_alpha_xl</span><span class="s2">)</span>
                <span class="s1">step</span><span class="s2">[</span><span class="s1">i_new</span><span class="s2">] = </span><span class="s1">xl</span><span class="s2">[</span><span class="s1">i_new</span><span class="s2">]</span>
                <span class="s1">free_xl</span><span class="s2">[</span><span class="s1">i_new</span><span class="s2">] = </span><span class="s0">False</span>
            <span class="s0">if </span><span class="s1">alpha_xu </span><span class="s2">&lt;= </span><span class="s1">alpha</span><span class="s2">:</span>
                <span class="s1">i_new </span><span class="s2">= </span><span class="s1">_argmin</span><span class="s2">(</span><span class="s1">all_alpha_xu</span><span class="s2">)</span>
                <span class="s1">step</span><span class="s2">[</span><span class="s1">i_new</span><span class="s2">] = </span><span class="s1">xu</span><span class="s2">[</span><span class="s1">i_new</span><span class="s2">]</span>
                <span class="s1">free_xu</span><span class="s2">[</span><span class="s1">i_new</span><span class="s2">] = </span><span class="s0">False</span>
            <span class="s0">if </span><span class="s1">alpha_ub </span><span class="s2">&lt;= </span><span class="s1">alpha</span><span class="s2">:</span>
                <span class="s1">i_new </span><span class="s2">= </span><span class="s1">_argmin</span><span class="s2">(</span><span class="s1">all_alpha_ub</span><span class="s2">)</span>
                <span class="s1">free_ub</span><span class="s2">[</span><span class="s1">i_new</span><span class="s2">] = </span><span class="s0">False</span>
            <span class="s1">n_act</span><span class="s2">, </span><span class="s1">q </span><span class="s2">= </span><span class="s1">qr_tangential_byrd_omojokun</span><span class="s2">(</span>
                <span class="s1">aub</span><span class="s2">,</span>
                <span class="s1">aeq</span><span class="s2">,</span>
                <span class="s1">free_xl</span><span class="s2">,</span>
                <span class="s1">free_xu</span><span class="s2">,</span>
                <span class="s1">free_ub</span><span class="s2">,</span>
            <span class="s2">)</span>
            <span class="s1">boundary_reached </span><span class="s2">= </span><span class="s0">True</span>
            <span class="s0">break</span>

    <span class="s5"># Attempt to improve the solution on the trust-region boundary.</span>
    <span class="s0">if </span><span class="s1">kwargs</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s6">&quot;improve_tcg&quot;</span><span class="s2">, </span><span class="s0">True</span><span class="s2">) </span><span class="s0">and </span><span class="s1">boundary_reached </span><span class="s0">and </span><span class="s1">n_act </span><span class="s2">&lt; </span><span class="s1">n</span><span class="s2">:</span>
        <span class="s1">step_base </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">(</span><span class="s1">step</span><span class="s2">)</span>
        <span class="s0">while </span><span class="s1">n_act </span><span class="s2">&lt; </span><span class="s1">n</span><span class="s2">:</span>
            <span class="s5"># Check whether a substantial reduction in the objective function</span>
            <span class="s5"># is possible, and set the search direction.</span>
            <span class="s1">step_proj </span><span class="s2">= </span><span class="s1">q</span><span class="s2">[:, </span><span class="s1">n_act</span><span class="s2">:] @ (</span><span class="s1">q</span><span class="s2">[:, </span><span class="s1">n_act</span><span class="s2">:].</span><span class="s1">T </span><span class="s2">@ </span><span class="s1">step</span><span class="s2">)</span>
            <span class="s1">grad_proj </span><span class="s2">= </span><span class="s1">q</span><span class="s2">[:, </span><span class="s1">n_act</span><span class="s2">:] @ (</span><span class="s1">q</span><span class="s2">[:, </span><span class="s1">n_act</span><span class="s2">:].</span><span class="s1">T </span><span class="s2">@ </span><span class="s1">grad</span><span class="s2">)</span>
            <span class="s1">step_sq </span><span class="s2">= </span><span class="s1">step_proj </span><span class="s2">@ </span><span class="s1">step_proj</span>
            <span class="s1">grad_sq </span><span class="s2">= </span><span class="s1">grad_proj </span><span class="s2">@ </span><span class="s1">grad_proj</span>
            <span class="s1">grad_step </span><span class="s2">= </span><span class="s1">grad_proj </span><span class="s2">@ </span><span class="s1">step_proj</span>
            <span class="s1">grad_sd </span><span class="s2">= -</span><span class="s1">np</span><span class="s2">.</span><span class="s1">sqrt</span><span class="s2">(</span><span class="s1">max</span><span class="s2">(</span><span class="s1">step_sq </span><span class="s2">* </span><span class="s1">grad_sq </span><span class="s2">- </span><span class="s1">grad_step</span><span class="s2">**</span><span class="s4">2.0</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">))</span>
            <span class="s1">sd </span><span class="s2">= </span><span class="s1">q</span><span class="s2">[:, </span><span class="s1">n_act</span><span class="s2">:] @ (</span>
                <span class="s1">q</span><span class="s2">[:, </span><span class="s1">n_act</span><span class="s2">:].</span><span class="s1">T </span><span class="s2">@ (</span><span class="s1">grad_step </span><span class="s2">* </span><span class="s1">step </span><span class="s2">- </span><span class="s1">step_sq </span><span class="s2">* </span><span class="s1">grad</span><span class="s2">)</span>
            <span class="s2">)</span>
            <span class="s0">if </span><span class="s1">grad_sd </span><span class="s2">&gt;= -</span><span class="s4">1e-8 </span><span class="s2">* </span><span class="s1">reduct </span><span class="s0">or </span><span class="s1">np</span><span class="s2">.</span><span class="s1">any</span><span class="s2">(</span>
                <span class="s1">grad_sd </span><span class="s2">&gt;= -</span><span class="s1">TINY </span><span class="s2">* </span><span class="s1">np</span><span class="s2">.</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">sd</span><span class="s2">)</span>
            <span class="s2">):</span>
                <span class="s0">break</span>
            <span class="s1">sd </span><span class="s2">/= -</span><span class="s1">grad_sd</span>

            <span class="s5"># Calculate an upper bound for the tangent of half the angle theta</span>
            <span class="s5"># of this alternative iteration for the bound constraints. The step</span>
            <span class="s5"># will be updated as:</span>
            <span class="s5"># step += (cos(theta) - 1) * step_proj + sin(theta) * sd.</span>
            <span class="s1">temp_xl </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">(</span><span class="s1">n</span><span class="s2">)</span>
            <span class="s1">temp_xu </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">(</span><span class="s1">n</span><span class="s2">)</span>
            <span class="s1">dist_xl </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">maximum</span><span class="s2">(</span><span class="s1">step </span><span class="s2">- </span><span class="s1">xl</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">)</span>
            <span class="s1">dist_xu </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">maximum</span><span class="s2">(</span><span class="s1">xu </span><span class="s2">- </span><span class="s1">step</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">)</span>
            <span class="s1">temp_xl</span><span class="s2">[</span><span class="s1">free_xl</span><span class="s2">] = </span><span class="s1">sd</span><span class="s2">[</span><span class="s1">free_xl</span><span class="s2">] ** </span><span class="s4">2.0 </span><span class="s2">- </span><span class="s1">dist_xl</span><span class="s2">[</span><span class="s1">free_xl</span><span class="s2">] * (</span>
                <span class="s1">dist_xl</span><span class="s2">[</span><span class="s1">free_xl</span><span class="s2">] - </span><span class="s4">2.0 </span><span class="s2">* </span><span class="s1">step_proj</span><span class="s2">[</span><span class="s1">free_xl</span><span class="s2">]</span>
            <span class="s2">)</span>
            <span class="s1">temp_xu</span><span class="s2">[</span><span class="s1">free_xu</span><span class="s2">] = </span><span class="s1">sd</span><span class="s2">[</span><span class="s1">free_xu</span><span class="s2">] ** </span><span class="s4">2.0 </span><span class="s2">- </span><span class="s1">dist_xu</span><span class="s2">[</span><span class="s1">free_xu</span><span class="s2">] * (</span>
                <span class="s1">dist_xu</span><span class="s2">[</span><span class="s1">free_xu</span><span class="s2">] + </span><span class="s4">2.0 </span><span class="s2">* </span><span class="s1">step_proj</span><span class="s2">[</span><span class="s1">free_xu</span><span class="s2">]</span>
            <span class="s2">)</span>
            <span class="s1">temp_xl</span><span class="s2">[</span><span class="s1">temp_xl </span><span class="s2">&gt; </span><span class="s4">0.0</span><span class="s2">] = (</span>
                <span class="s1">np</span><span class="s2">.</span><span class="s1">sqrt</span><span class="s2">(</span><span class="s1">temp_xl</span><span class="s2">[</span><span class="s1">temp_xl </span><span class="s2">&gt; </span><span class="s4">0.0</span><span class="s2">]) - </span><span class="s1">sd</span><span class="s2">[</span><span class="s1">temp_xl </span><span class="s2">&gt; </span><span class="s4">0.0</span><span class="s2">]</span>
            <span class="s2">)</span>
            <span class="s1">temp_xu</span><span class="s2">[</span><span class="s1">temp_xu </span><span class="s2">&gt; </span><span class="s4">0.0</span><span class="s2">] = (</span>
                <span class="s1">np</span><span class="s2">.</span><span class="s1">sqrt</span><span class="s2">(</span><span class="s1">temp_xu</span><span class="s2">[</span><span class="s1">temp_xu </span><span class="s2">&gt; </span><span class="s4">0.0</span><span class="s2">]) + </span><span class="s1">sd</span><span class="s2">[</span><span class="s1">temp_xu </span><span class="s2">&gt; </span><span class="s4">0.0</span><span class="s2">]</span>
            <span class="s2">)</span>
            <span class="s1">i_xl </span><span class="s2">= </span><span class="s1">temp_xl </span><span class="s2">&gt; </span><span class="s1">TINY </span><span class="s2">* </span><span class="s1">dist_xl</span>
            <span class="s1">i_xu </span><span class="s2">= </span><span class="s1">temp_xu </span><span class="s2">&gt; </span><span class="s1">TINY </span><span class="s2">* </span><span class="s1">dist_xu</span>
            <span class="s1">all_t_xl </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">(</span><span class="s1">n</span><span class="s2">)</span>
            <span class="s1">all_t_xu </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">(</span><span class="s1">n</span><span class="s2">)</span>
            <span class="s1">all_t_xl</span><span class="s2">[</span><span class="s1">i_xl</span><span class="s2">] = </span><span class="s1">np</span><span class="s2">.</span><span class="s1">minimum</span><span class="s2">(</span>
                <span class="s1">all_t_xl</span><span class="s2">[</span><span class="s1">i_xl</span><span class="s2">],</span>
                <span class="s1">dist_xl</span><span class="s2">[</span><span class="s1">i_xl</span><span class="s2">] / </span><span class="s1">temp_xl</span><span class="s2">[</span><span class="s1">i_xl</span><span class="s2">],</span>
            <span class="s2">)</span>
            <span class="s1">all_t_xu</span><span class="s2">[</span><span class="s1">i_xu</span><span class="s2">] = </span><span class="s1">np</span><span class="s2">.</span><span class="s1">minimum</span><span class="s2">(</span>
                <span class="s1">all_t_xu</span><span class="s2">[</span><span class="s1">i_xu</span><span class="s2">],</span>
                <span class="s1">dist_xu</span><span class="s2">[</span><span class="s1">i_xu</span><span class="s2">] / </span><span class="s1">temp_xu</span><span class="s2">[</span><span class="s1">i_xu</span><span class="s2">],</span>
            <span class="s2">)</span>
            <span class="s1">t_xl </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">min</span><span class="s2">(</span><span class="s1">all_t_xl</span><span class="s2">)</span>
            <span class="s1">t_xu </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">min</span><span class="s2">(</span><span class="s1">all_t_xu</span><span class="s2">)</span>
            <span class="s1">t_bd </span><span class="s2">= </span><span class="s1">min</span><span class="s2">(</span><span class="s1">t_xl</span><span class="s2">, </span><span class="s1">t_xu</span><span class="s2">)</span>

            <span class="s5"># Calculate an upper bound for the tangent of half the angle theta</span>
            <span class="s5"># of this alternative iteration for the linear constraints.</span>
            <span class="s1">temp_ub </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros_like</span><span class="s2">(</span><span class="s1">resid</span><span class="s2">)</span>
            <span class="s1">aub_step </span><span class="s2">= </span><span class="s1">aub </span><span class="s2">@ </span><span class="s1">step_proj</span>
            <span class="s1">aub_sd </span><span class="s2">= </span><span class="s1">aub </span><span class="s2">@ </span><span class="s1">sd</span>
            <span class="s1">temp_ub</span><span class="s2">[</span><span class="s1">free_ub</span><span class="s2">] = </span><span class="s1">aub_sd</span><span class="s2">[</span><span class="s1">free_ub</span><span class="s2">] ** </span><span class="s4">2.0 </span><span class="s2">- </span><span class="s1">resid</span><span class="s2">[</span><span class="s1">free_ub</span><span class="s2">] * (</span>
                <span class="s1">resid</span><span class="s2">[</span><span class="s1">free_ub</span><span class="s2">] + </span><span class="s4">2.0 </span><span class="s2">* </span><span class="s1">aub_step</span><span class="s2">[</span><span class="s1">free_ub</span><span class="s2">]</span>
            <span class="s2">)</span>
            <span class="s1">temp_ub</span><span class="s2">[</span><span class="s1">temp_ub </span><span class="s2">&gt; </span><span class="s4">0.0</span><span class="s2">] = (</span>
                <span class="s1">np</span><span class="s2">.</span><span class="s1">sqrt</span><span class="s2">(</span><span class="s1">temp_ub</span><span class="s2">[</span><span class="s1">temp_ub </span><span class="s2">&gt; </span><span class="s4">0.0</span><span class="s2">]) + </span><span class="s1">aub_sd</span><span class="s2">[</span><span class="s1">temp_ub </span><span class="s2">&gt; </span><span class="s4">0.0</span><span class="s2">]</span>
            <span class="s2">)</span>
            <span class="s1">i_ub </span><span class="s2">= </span><span class="s1">temp_ub </span><span class="s2">&gt; </span><span class="s1">TINY </span><span class="s2">* </span><span class="s1">resid</span>
            <span class="s1">all_t_ub </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones_like</span><span class="s2">(</span><span class="s1">resid</span><span class="s2">)</span>
            <span class="s1">all_t_ub</span><span class="s2">[</span><span class="s1">i_ub</span><span class="s2">] = </span><span class="s1">np</span><span class="s2">.</span><span class="s1">minimum</span><span class="s2">(</span>
                <span class="s1">all_t_ub</span><span class="s2">[</span><span class="s1">i_ub</span><span class="s2">],</span>
                <span class="s1">resid</span><span class="s2">[</span><span class="s1">i_ub</span><span class="s2">] / </span><span class="s1">temp_ub</span><span class="s2">[</span><span class="s1">i_ub</span><span class="s2">],</span>
            <span class="s2">)</span>
            <span class="s1">t_ub </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">min</span><span class="s2">(</span><span class="s1">all_t_ub</span><span class="s2">, </span><span class="s1">initial</span><span class="s2">=</span><span class="s4">1.0</span><span class="s2">)</span>
            <span class="s1">t_min </span><span class="s2">= </span><span class="s1">min</span><span class="s2">(</span><span class="s1">t_bd</span><span class="s2">, </span><span class="s1">t_ub</span><span class="s2">)</span>

            <span class="s5"># Calculate some curvature information.</span>
            <span class="s1">hess_step </span><span class="s2">= </span><span class="s1">hess_prod</span><span class="s2">(</span><span class="s1">step_proj</span><span class="s2">)</span>
            <span class="s1">hess_sd </span><span class="s2">= </span><span class="s1">hess_prod</span><span class="s2">(</span><span class="s1">sd</span><span class="s2">)</span>
            <span class="s1">curv_step </span><span class="s2">= </span><span class="s1">step_proj </span><span class="s2">@ </span><span class="s1">hess_step</span>
            <span class="s1">curv_sd </span><span class="s2">= </span><span class="s1">sd </span><span class="s2">@ </span><span class="s1">hess_sd</span>
            <span class="s1">curv_step_sd </span><span class="s2">= </span><span class="s1">step_proj </span><span class="s2">@ </span><span class="s1">hess_sd</span>

            <span class="s5"># For a range of equally spaced values of tan(0.5 * theta),</span>
            <span class="s5"># calculate the reduction in the objective function that would be</span>
            <span class="s5"># obtained by accepting the corresponding angle.</span>
            <span class="s1">n_samples </span><span class="s2">= </span><span class="s4">20</span>
            <span class="s1">n_samples </span><span class="s2">= </span><span class="s1">int</span><span class="s2">((</span><span class="s1">n_samples </span><span class="s2">- </span><span class="s4">3</span><span class="s2">) * </span><span class="s1">t_min </span><span class="s2">+ </span><span class="s4">3</span><span class="s2">)</span>
            <span class="s1">t_samples </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linspace</span><span class="s2">(</span><span class="s1">t_min </span><span class="s2">/ </span><span class="s1">n_samples</span><span class="s2">, </span><span class="s1">t_min</span><span class="s2">, </span><span class="s1">n_samples</span><span class="s2">)</span>
            <span class="s1">sin_values </span><span class="s2">= </span><span class="s4">2.0 </span><span class="s2">* </span><span class="s1">t_samples </span><span class="s2">/ (</span><span class="s4">1.0 </span><span class="s2">+ </span><span class="s1">t_samples</span><span class="s2">**</span><span class="s4">2.0</span><span class="s2">)</span>
            <span class="s1">all_reduct </span><span class="s2">= </span><span class="s1">sin_values </span><span class="s2">* (</span>
                <span class="s1">grad_step </span><span class="s2">* </span><span class="s1">t_samples</span>
                <span class="s2">- </span><span class="s1">grad_sd</span>
                <span class="s2">- </span><span class="s1">sin_values</span>
                <span class="s2">* (</span>
                    <span class="s4">0.5 </span><span class="s2">* </span><span class="s1">t_samples</span><span class="s2">**</span><span class="s4">2.0 </span><span class="s2">* </span><span class="s1">curv_step</span>
                    <span class="s2">- </span><span class="s4">2.0 </span><span class="s2">* </span><span class="s1">t_samples </span><span class="s2">* </span><span class="s1">curv_step_sd</span>
                    <span class="s2">+ </span><span class="s4">0.5 </span><span class="s2">* </span><span class="s1">curv_sd</span>
                <span class="s2">)</span>
            <span class="s2">)</span>
            <span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">all</span><span class="s2">(</span><span class="s1">all_reduct </span><span class="s2">&lt;= </span><span class="s4">0.0</span><span class="s2">):</span>
                <span class="s5"># No reduction in the objective function is obtained.</span>
                <span class="s0">break</span>

            <span class="s5"># Accept the angle that provides the largest reduction in the</span>
            <span class="s5"># objective function, and update the iterate.</span>
            <span class="s1">i_max </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">argmax</span><span class="s2">(</span><span class="s1">all_reduct</span><span class="s2">)</span>
            <span class="s1">cos_value </span><span class="s2">= (</span><span class="s4">1.0 </span><span class="s2">- </span><span class="s1">t_samples</span><span class="s2">[</span><span class="s1">i_max</span><span class="s2">] ** </span><span class="s4">2.0</span><span class="s2">) / (</span>
                <span class="s4">1.0 </span><span class="s2">+ </span><span class="s1">t_samples</span><span class="s2">[</span><span class="s1">i_max</span><span class="s2">] ** </span><span class="s4">2.0</span>
            <span class="s2">)</span>
            <span class="s1">step </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">clip</span><span class="s2">(</span>
                <span class="s1">step </span><span class="s2">+ (</span><span class="s1">cos_value </span><span class="s2">- </span><span class="s4">1.0</span><span class="s2">) * </span><span class="s1">step_proj </span><span class="s2">+ </span><span class="s1">sin_values</span><span class="s2">[</span><span class="s1">i_max</span><span class="s2">] * </span><span class="s1">sd</span><span class="s2">,</span>
                <span class="s1">xl</span><span class="s2">,</span>
                <span class="s1">xu</span><span class="s2">,</span>
            <span class="s2">)</span>
            <span class="s1">grad </span><span class="s2">+= (</span><span class="s1">cos_value </span><span class="s2">- </span><span class="s4">1.0</span><span class="s2">) * </span><span class="s1">hess_step </span><span class="s2">+ </span><span class="s1">sin_values</span><span class="s2">[</span><span class="s1">i_max</span><span class="s2">] * </span><span class="s1">hess_sd</span>
            <span class="s1">resid </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">maximum</span><span class="s2">(</span>
                <span class="s4">0.0</span><span class="s2">,</span>
                <span class="s1">resid</span>
                <span class="s2">- (</span><span class="s1">cos_value </span><span class="s2">- </span><span class="s4">1.0</span><span class="s2">) * </span><span class="s1">aub_step</span>
                <span class="s2">- </span><span class="s1">sin_values</span><span class="s2">[</span><span class="s1">i_max</span><span class="s2">] * </span><span class="s1">aub_sd</span><span class="s2">,</span>
            <span class="s2">)</span>
            <span class="s1">reduct </span><span class="s2">+= </span><span class="s1">all_reduct</span><span class="s2">[</span><span class="s1">i_max</span><span class="s2">]</span>

            <span class="s5"># If the above angle is restricted by bound constraints, add them</span>
            <span class="s5"># to the working set, and restart the alternative iteration.</span>
            <span class="s5"># Otherwise, the calculations are terminated.</span>
            <span class="s0">if </span><span class="s1">t_min </span><span class="s2">&lt; </span><span class="s4">1.0 </span><span class="s0">and </span><span class="s1">i_max </span><span class="s2">== </span><span class="s1">n_samples </span><span class="s2">- </span><span class="s4">1</span><span class="s2">:</span>
                <span class="s0">if </span><span class="s1">t_xl </span><span class="s2">&lt;= </span><span class="s1">t_min</span><span class="s2">:</span>
                    <span class="s1">i_new </span><span class="s2">= </span><span class="s1">_argmin</span><span class="s2">(</span><span class="s1">all_t_xl</span><span class="s2">)</span>
                    <span class="s1">step</span><span class="s2">[</span><span class="s1">i_new</span><span class="s2">] = </span><span class="s1">xl</span><span class="s2">[</span><span class="s1">i_new</span><span class="s2">]</span>
                    <span class="s1">free_xl</span><span class="s2">[</span><span class="s1">i_new</span><span class="s2">] = </span><span class="s0">False</span>
                <span class="s0">if </span><span class="s1">t_xu </span><span class="s2">&lt;= </span><span class="s1">t_min</span><span class="s2">:</span>
                    <span class="s1">i_new </span><span class="s2">= </span><span class="s1">_argmin</span><span class="s2">(</span><span class="s1">all_t_xu</span><span class="s2">)</span>
                    <span class="s1">step</span><span class="s2">[</span><span class="s1">i_new</span><span class="s2">] = </span><span class="s1">xu</span><span class="s2">[</span><span class="s1">i_new</span><span class="s2">]</span>
                    <span class="s1">free_xl</span><span class="s2">[</span><span class="s1">i_new</span><span class="s2">] = </span><span class="s0">False</span>
                <span class="s0">if </span><span class="s1">t_ub </span><span class="s2">&lt;= </span><span class="s1">t_min</span><span class="s2">:</span>
                    <span class="s1">i_new </span><span class="s2">= </span><span class="s1">_argmin</span><span class="s2">(</span><span class="s1">all_t_ub</span><span class="s2">)</span>
                    <span class="s1">free_ub</span><span class="s2">[</span><span class="s1">i_new</span><span class="s2">] = </span><span class="s0">False</span>
                <span class="s1">n_act</span><span class="s2">, </span><span class="s1">q </span><span class="s2">= </span><span class="s1">qr_tangential_byrd_omojokun</span><span class="s2">(</span>
                    <span class="s1">aub</span><span class="s2">,</span>
                    <span class="s1">aeq</span><span class="s2">,</span>
                    <span class="s1">free_xl</span><span class="s2">,</span>
                    <span class="s1">free_xu</span><span class="s2">,</span>
                    <span class="s1">free_ub</span><span class="s2">,</span>
                <span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s0">break</span>

        <span class="s5"># Ensure that the alternative iteration improves the objective</span>
        <span class="s5"># function.</span>
        <span class="s0">if </span><span class="s1">grad_orig </span><span class="s2">@ </span><span class="s1">step </span><span class="s2">+ </span><span class="s4">0.5 </span><span class="s2">* </span><span class="s1">step </span><span class="s2">@ </span><span class="s1">hess_prod</span><span class="s2">(</span>
            <span class="s1">step</span>
        <span class="s2">) &gt; </span><span class="s1">grad_orig </span><span class="s2">@ </span><span class="s1">step_base </span><span class="s2">+ </span><span class="s4">0.5 </span><span class="s2">* </span><span class="s1">step_base </span><span class="s2">@ </span><span class="s1">hess_prod</span><span class="s2">(</span><span class="s1">step_base</span><span class="s2">):</span>
            <span class="s1">step </span><span class="s2">= </span><span class="s1">step_base</span>

    <span class="s0">if </span><span class="s1">debug</span><span class="s2">:</span>
        <span class="s1">tol </span><span class="s2">= </span><span class="s1">get_arrays_tol</span><span class="s2">(</span><span class="s1">xl</span><span class="s2">, </span><span class="s1">xu</span><span class="s2">)</span>
        <span class="s0">assert </span><span class="s1">np</span><span class="s2">.</span><span class="s1">all</span><span class="s2">(</span><span class="s1">xl </span><span class="s2">&lt;= </span><span class="s1">step</span><span class="s2">)</span>
        <span class="s0">assert </span><span class="s1">np</span><span class="s2">.</span><span class="s1">all</span><span class="s2">(</span><span class="s1">step </span><span class="s2">&lt;= </span><span class="s1">xu</span><span class="s2">)</span>
        <span class="s0">assert </span><span class="s1">np</span><span class="s2">.</span><span class="s1">all</span><span class="s2">(</span><span class="s1">aub </span><span class="s2">@ </span><span class="s1">step </span><span class="s2">&lt;= </span><span class="s1">bub </span><span class="s2">+ </span><span class="s1">tol</span><span class="s2">)</span>
        <span class="s0">assert </span><span class="s1">np</span><span class="s2">.</span><span class="s1">all</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">aeq </span><span class="s2">@ </span><span class="s1">step</span><span class="s2">) &lt;= </span><span class="s1">tol</span><span class="s2">)</span>
        <span class="s0">assert </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">norm</span><span class="s2">(</span><span class="s1">step</span><span class="s2">) &lt; </span><span class="s4">1.1 </span><span class="s2">* </span><span class="s1">delta</span>
    <span class="s0">return </span><span class="s1">step</span>


<span class="s0">def </span><span class="s1">normal_byrd_omojokun</span><span class="s2">(</span><span class="s1">aub</span><span class="s2">, </span><span class="s1">bub</span><span class="s2">, </span><span class="s1">aeq</span><span class="s2">, </span><span class="s1">beq</span><span class="s2">, </span><span class="s1">xl</span><span class="s2">, </span><span class="s1">xu</span><span class="s2">, </span><span class="s1">delta</span><span class="s2">, </span><span class="s1">debug</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
    <span class="s3">r&quot;&quot;&quot; 
    Minimize approximately a linear constraint violation subject to bound 
    constraints in a trust region. 
 
    This function solves approximately 
 
    .. math:: 
 
        \min_{s \in \mathbb{R}^n} \quad \frac{1}{2} \big( \lVert \max \{ 
        A_{\scriptscriptstyle I} s - b_{\scriptscriptstyle I}, 0 \} \rVert^2 + 
        \lVert A_{\scriptscriptstyle E} s - b_{\scriptscriptstyle E} \rVert^2 
        \big) \quad \text{s.t.} 
        \quad 
        \left\{ \begin{array}{l} 
            l \le s \le u,\\ 
            \lVert s \rVert \le \Delta, 
        \end{array} \right. 
 
    using a variation of the truncated conjugate gradient method. 
 
    Parameters 
    ---------- 
    aub : `numpy.ndarray`, shape (m_linear_ub, n) 
        Matrix :math:`A_{\scriptscriptstyle I}` as shown above. 
    bub : `numpy.ndarray`, shape (m_linear_ub,) 
        Vector :math:`b_{\scriptscriptstyle I}` as shown above. 
    aeq : `numpy.ndarray`, shape (m_linear_eq, n) 
        Matrix :math:`A_{\scriptscriptstyle E}` as shown above. 
    beq : `numpy.ndarray`, shape (m_linear_eq,) 
        Vector :math:`b_{\scriptscriptstyle E}` as shown above. 
    xl : `numpy.ndarray`, shape (n,) 
        Lower bounds :math:`l` as shown above. 
    xu : `numpy.ndarray`, shape (n,) 
        Upper bounds :math:`u` as shown above. 
    delta : float 
        Trust-region radius :math:`\Delta` as shown above. 
    debug : bool 
        Whether to make debugging tests during the execution. 
 
    Returns 
    ------- 
    `numpy.ndarray`, shape (n,) 
        Approximate solution :math:`s`. 
 
    Other Parameters 
    ---------------- 
    improve_tcg : bool, optional 
        If True, a solution generated by the truncated conjugate gradient 
        method that is on the boundary of the trust region is improved by 
        moving around the trust-region boundary on the two-dimensional space 
        spanned by the solution and the gradient of the quadratic function at 
        the solution (default is True). 
 
    Notes 
    ----- 
    This function implements Algorithm 6.4 of [1]_. It is assumed that the 
    origin is feasible with respect to the bound constraints and that `delta` 
    is finite and positive. 
 
    References 
    ---------- 
    .. [1] T. M. Ragonneau. *Model-Based Derivative-Free Optimization Methods 
       and Software*. PhD thesis, Department of Applied Mathematics, The Hong 
       Kong Polytechnic University, Hong Kong, China, 2022. URL: 
       https://theses.lib.polyu.edu.hk/handle/200/12294. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">debug</span><span class="s2">:</span>
        <span class="s0">assert </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">aub</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">) </span><span class="s0">and </span><span class="s1">aub</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s4">2</span>
        <span class="s0">assert </span><span class="s2">(</span>
            <span class="s1">isinstance</span><span class="s2">(</span><span class="s1">bub</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">)</span>
            <span class="s0">and </span><span class="s1">bub</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s4">1</span>
            <span class="s0">and </span><span class="s1">bub</span><span class="s2">.</span><span class="s1">size </span><span class="s2">== </span><span class="s1">aub</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s4">0</span><span class="s2">]</span>
        <span class="s2">)</span>
        <span class="s0">assert </span><span class="s2">(</span>
            <span class="s1">isinstance</span><span class="s2">(</span><span class="s1">aeq</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">)</span>
            <span class="s0">and </span><span class="s1">aeq</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s4">2</span>
            <span class="s0">and </span><span class="s1">aeq</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s4">1</span><span class="s2">] == </span><span class="s1">aub</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s4">1</span><span class="s2">]</span>
        <span class="s2">)</span>
        <span class="s0">assert </span><span class="s2">(</span>
            <span class="s1">isinstance</span><span class="s2">(</span><span class="s1">beq</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">)</span>
            <span class="s0">and </span><span class="s1">beq</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s4">1</span>
            <span class="s0">and </span><span class="s1">beq</span><span class="s2">.</span><span class="s1">size </span><span class="s2">== </span><span class="s1">aeq</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s4">0</span><span class="s2">]</span>
        <span class="s2">)</span>
        <span class="s0">assert </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">xl</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">) </span><span class="s0">and </span><span class="s1">xl</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">== (</span><span class="s1">aub</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s4">1</span><span class="s2">],)</span>
        <span class="s0">assert </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">xu</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">) </span><span class="s0">and </span><span class="s1">xu</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">== (</span><span class="s1">aub</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s4">1</span><span class="s2">],)</span>
        <span class="s0">assert </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">delta</span><span class="s2">, </span><span class="s1">float</span><span class="s2">)</span>
        <span class="s0">assert </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">debug</span><span class="s2">, </span><span class="s1">bool</span><span class="s2">)</span>
        <span class="s1">tol </span><span class="s2">= </span><span class="s1">get_arrays_tol</span><span class="s2">(</span><span class="s1">xl</span><span class="s2">, </span><span class="s1">xu</span><span class="s2">)</span>
        <span class="s0">assert </span><span class="s1">np</span><span class="s2">.</span><span class="s1">all</span><span class="s2">(</span><span class="s1">xl </span><span class="s2">&lt;= </span><span class="s1">tol</span><span class="s2">)</span>
        <span class="s0">assert </span><span class="s1">np</span><span class="s2">.</span><span class="s1">all</span><span class="s2">(</span><span class="s1">xu </span><span class="s2">&gt;= -</span><span class="s1">tol</span><span class="s2">)</span>
        <span class="s0">assert </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isfinite</span><span class="s2">(</span><span class="s1">delta</span><span class="s2">) </span><span class="s0">and </span><span class="s1">delta </span><span class="s2">&gt; </span><span class="s4">0.0</span>
    <span class="s1">xl </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">minimum</span><span class="s2">(</span><span class="s1">xl</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">)</span>
    <span class="s1">xu </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">maximum</span><span class="s2">(</span><span class="s1">xu</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">)</span>

    <span class="s5"># Calculate the initial active set.</span>
    <span class="s1">m_linear_ub</span><span class="s2">, </span><span class="s1">n </span><span class="s2">= </span><span class="s1">aub</span><span class="s2">.</span><span class="s1">shape</span>
    <span class="s1">grad </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">r_</span><span class="s2">[</span><span class="s1">aeq</span><span class="s2">.</span><span class="s1">T </span><span class="s2">@ -</span><span class="s1">beq</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">maximum</span><span class="s2">(</span><span class="s4">0.0</span><span class="s2">, -</span><span class="s1">bub</span><span class="s2">)]</span>
    <span class="s1">free_xl </span><span class="s2">= (</span><span class="s1">xl </span><span class="s2">&lt; </span><span class="s4">0.0</span><span class="s2">) | (</span><span class="s1">grad</span><span class="s2">[:</span><span class="s1">n</span><span class="s2">] &lt; </span><span class="s4">0.0</span><span class="s2">)</span>
    <span class="s1">free_xu </span><span class="s2">= (</span><span class="s1">xu </span><span class="s2">&gt; </span><span class="s4">0.0</span><span class="s2">) | (</span><span class="s1">grad</span><span class="s2">[:</span><span class="s1">n</span><span class="s2">] &gt; </span><span class="s4">0.0</span><span class="s2">)</span>
    <span class="s1">free_slack </span><span class="s2">= </span><span class="s1">bub </span><span class="s2">&lt; </span><span class="s4">0.0</span>
    <span class="s1">free_ub </span><span class="s2">= (</span><span class="s1">bub </span><span class="s2">&gt; </span><span class="s4">0.0</span><span class="s2">) | (</span><span class="s1">aub </span><span class="s2">@ </span><span class="s1">grad</span><span class="s2">[:</span><span class="s1">n</span><span class="s2">] - </span><span class="s1">grad</span><span class="s2">[</span><span class="s1">n</span><span class="s2">:] &gt; </span><span class="s4">0.0</span><span class="s2">)</span>
    <span class="s1">n_act</span><span class="s2">, </span><span class="s1">q </span><span class="s2">= </span><span class="s1">qr_normal_byrd_omojokun</span><span class="s2">(</span>
        <span class="s1">aub</span><span class="s2">,</span>
        <span class="s1">free_xl</span><span class="s2">,</span>
        <span class="s1">free_xu</span><span class="s2">,</span>
        <span class="s1">free_slack</span><span class="s2">,</span>
        <span class="s1">free_ub</span><span class="s2">,</span>
    <span class="s2">)</span>

    <span class="s5"># Calculate an upper bound on the norm of the slack variables. It is not</span>
    <span class="s5"># used in the original algorithm, but it may prevent undesired behaviors</span>
    <span class="s5"># engendered by computer rounding errors.</span>
    <span class="s1">delta_slack </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sqrt</span><span class="s2">(</span><span class="s1">beq </span><span class="s2">@ </span><span class="s1">beq </span><span class="s2">+ </span><span class="s1">grad</span><span class="s2">[</span><span class="s1">n</span><span class="s2">:] @ </span><span class="s1">grad</span><span class="s2">[</span><span class="s1">n</span><span class="s2">:])</span>

    <span class="s5"># Set the initial iterate and the initial search direction.</span>
    <span class="s1">step </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">(</span><span class="s1">n</span><span class="s2">)</span>
    <span class="s1">sd </span><span class="s2">= -</span><span class="s1">q</span><span class="s2">[:, </span><span class="s1">n_act</span><span class="s2">:] @ (</span><span class="s1">q</span><span class="s2">[:, </span><span class="s1">n_act</span><span class="s2">:].</span><span class="s1">T </span><span class="s2">@ </span><span class="s1">grad</span><span class="s2">)</span>
    <span class="s1">resid </span><span class="s2">= </span><span class="s1">bub </span><span class="s2">+ </span><span class="s1">grad</span><span class="s2">[</span><span class="s1">n</span><span class="s2">:]</span>

    <span class="s1">k </span><span class="s2">= </span><span class="s4">0</span>
    <span class="s1">reduct </span><span class="s2">= </span><span class="s4">0.0</span>
    <span class="s1">boundary_reached </span><span class="s2">= </span><span class="s0">False</span>
    <span class="s0">while </span><span class="s1">k </span><span class="s2">&lt; </span><span class="s1">n </span><span class="s2">+ </span><span class="s1">m_linear_ub </span><span class="s2">- </span><span class="s1">n_act</span><span class="s2">:</span>
        <span class="s5"># Stop the computations if sd is not a descent direction.</span>
        <span class="s1">grad_sd </span><span class="s2">= </span><span class="s1">grad </span><span class="s2">@ </span><span class="s1">sd</span>
        <span class="s0">if </span><span class="s1">grad_sd </span><span class="s2">&gt;= -</span><span class="s4">10.0 </span><span class="s2">* </span><span class="s1">EPS </span><span class="s2">* </span><span class="s1">n </span><span class="s2">* </span><span class="s1">max</span><span class="s2">(</span><span class="s4">1.0</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">norm</span><span class="s2">(</span><span class="s1">grad</span><span class="s2">)):</span>
            <span class="s0">break</span>

        <span class="s5"># Set alpha_tr to the step size for the trust-region constraint.</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s1">alpha_tr </span><span class="s2">= </span><span class="s1">_alpha_tr</span><span class="s2">(</span><span class="s1">step</span><span class="s2">, </span><span class="s1">sd</span><span class="s2">[:</span><span class="s1">n</span><span class="s2">], </span><span class="s1">delta</span><span class="s2">)</span>
        <span class="s0">except </span><span class="s1">ZeroDivisionError</span><span class="s2">:</span>
            <span class="s1">alpha_tr </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span>

        <span class="s5"># Prevent undesired behaviors engendered by computer rounding errors by</span>
        <span class="s5"># considering the trust-region constraint on the slack variables.</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s1">alpha_tr </span><span class="s2">= </span><span class="s1">min</span><span class="s2">(</span><span class="s1">alpha_tr</span><span class="s2">, </span><span class="s1">_alpha_tr</span><span class="s2">(</span><span class="s1">grad</span><span class="s2">[</span><span class="s1">n</span><span class="s2">:], </span><span class="s1">sd</span><span class="s2">[</span><span class="s1">n</span><span class="s2">:], </span><span class="s1">delta_slack</span><span class="s2">))</span>
        <span class="s0">except </span><span class="s1">ZeroDivisionError</span><span class="s2">:</span>
            <span class="s0">pass</span>

        <span class="s5"># Stop the computations if a step along sd is expected to give a</span>
        <span class="s5"># relatively small reduction in the objective function.</span>
        <span class="s0">if </span><span class="s2">-</span><span class="s1">alpha_tr </span><span class="s2">* </span><span class="s1">grad_sd </span><span class="s2">&lt;= </span><span class="s4">1e-8 </span><span class="s2">* </span><span class="s1">reduct</span><span class="s2">:</span>
            <span class="s0">break</span>

        <span class="s5"># Set alpha_quad to the step size for the minimization problem.</span>
        <span class="s1">hess_sd </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">r_</span><span class="s2">[</span><span class="s1">aeq</span><span class="s2">.</span><span class="s1">T </span><span class="s2">@ (</span><span class="s1">aeq </span><span class="s2">@ </span><span class="s1">sd</span><span class="s2">[:</span><span class="s1">n</span><span class="s2">]), </span><span class="s1">sd</span><span class="s2">[</span><span class="s1">n</span><span class="s2">:]]</span>
        <span class="s1">curv_sd </span><span class="s2">= </span><span class="s1">sd </span><span class="s2">@ </span><span class="s1">hess_sd</span>
        <span class="s0">if </span><span class="s1">curv_sd </span><span class="s2">&gt; </span><span class="s1">TINY </span><span class="s2">* </span><span class="s1">abs</span><span class="s2">(</span><span class="s1">grad_sd</span><span class="s2">):</span>
            <span class="s1">alpha_quad </span><span class="s2">= </span><span class="s1">max</span><span class="s2">(-</span><span class="s1">grad_sd </span><span class="s2">/ </span><span class="s1">curv_sd</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">alpha_quad </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span>

        <span class="s5"># Stop the computations if the reduction in the objective function</span>
        <span class="s5"># provided by an unconstrained step is small.</span>
        <span class="s1">alpha </span><span class="s2">= </span><span class="s1">min</span><span class="s2">(</span><span class="s1">alpha_tr</span><span class="s2">, </span><span class="s1">alpha_quad</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s2">-</span><span class="s1">alpha </span><span class="s2">* (</span><span class="s1">grad_sd </span><span class="s2">+ </span><span class="s4">0.5 </span><span class="s2">* </span><span class="s1">alpha </span><span class="s2">* </span><span class="s1">curv_sd</span><span class="s2">) &lt;= </span><span class="s4">1e-8 </span><span class="s2">* </span><span class="s1">reduct</span><span class="s2">:</span>
            <span class="s0">break</span>

        <span class="s5"># Set alpha_bd to the step size for the bound constraints.</span>
        <span class="s1">i_xl </span><span class="s2">= </span><span class="s1">free_xl </span><span class="s2">&amp; (</span><span class="s1">xl </span><span class="s2">&gt; -</span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span><span class="s2">) &amp; (</span><span class="s1">sd</span><span class="s2">[:</span><span class="s1">n</span><span class="s2">] &lt; -</span><span class="s1">TINY </span><span class="s2">* </span><span class="s1">np</span><span class="s2">.</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">xl </span><span class="s2">- </span><span class="s1">step</span><span class="s2">))</span>
        <span class="s1">i_xu </span><span class="s2">= </span><span class="s1">free_xu </span><span class="s2">&amp; (</span><span class="s1">xu </span><span class="s2">&lt; </span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span><span class="s2">) &amp; (</span><span class="s1">sd</span><span class="s2">[:</span><span class="s1">n</span><span class="s2">] &gt; </span><span class="s1">TINY </span><span class="s2">* </span><span class="s1">np</span><span class="s2">.</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">xu </span><span class="s2">- </span><span class="s1">step</span><span class="s2">))</span>
        <span class="s1">i_slack </span><span class="s2">= </span><span class="s1">free_slack </span><span class="s2">&amp; (</span><span class="s1">sd</span><span class="s2">[</span><span class="s1">n</span><span class="s2">:] &lt; -</span><span class="s1">TINY </span><span class="s2">* </span><span class="s1">np</span><span class="s2">.</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">grad</span><span class="s2">[</span><span class="s1">n</span><span class="s2">:]))</span>
        <span class="s1">all_alpha_xl </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">full_like</span><span class="s2">(</span><span class="s1">step</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span><span class="s2">)</span>
        <span class="s1">all_alpha_xu </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">full_like</span><span class="s2">(</span><span class="s1">step</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span><span class="s2">)</span>
        <span class="s1">all_alpha_slack </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">full_like</span><span class="s2">(</span><span class="s1">bub</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span><span class="s2">)</span>
        <span class="s1">all_alpha_xl</span><span class="s2">[</span><span class="s1">i_xl</span><span class="s2">] = </span><span class="s1">np</span><span class="s2">.</span><span class="s1">maximum</span><span class="s2">(</span>
            <span class="s2">(</span><span class="s1">xl</span><span class="s2">[</span><span class="s1">i_xl</span><span class="s2">] - </span><span class="s1">step</span><span class="s2">[</span><span class="s1">i_xl</span><span class="s2">]) / </span><span class="s1">sd</span><span class="s2">[:</span><span class="s1">n</span><span class="s2">][</span><span class="s1">i_xl</span><span class="s2">],</span>
            <span class="s4">0.0</span><span class="s2">,</span>
        <span class="s2">)</span>
        <span class="s1">all_alpha_xu</span><span class="s2">[</span><span class="s1">i_xu</span><span class="s2">] = </span><span class="s1">np</span><span class="s2">.</span><span class="s1">maximum</span><span class="s2">(</span>
            <span class="s2">(</span><span class="s1">xu</span><span class="s2">[</span><span class="s1">i_xu</span><span class="s2">] - </span><span class="s1">step</span><span class="s2">[</span><span class="s1">i_xu</span><span class="s2">]) / </span><span class="s1">sd</span><span class="s2">[:</span><span class="s1">n</span><span class="s2">][</span><span class="s1">i_xu</span><span class="s2">],</span>
            <span class="s4">0.0</span><span class="s2">,</span>
        <span class="s2">)</span>
        <span class="s1">all_alpha_slack</span><span class="s2">[</span><span class="s1">i_slack</span><span class="s2">] = </span><span class="s1">np</span><span class="s2">.</span><span class="s1">maximum</span><span class="s2">(</span>
            <span class="s2">-</span><span class="s1">grad</span><span class="s2">[</span><span class="s1">n</span><span class="s2">:][</span><span class="s1">i_slack</span><span class="s2">] / </span><span class="s1">sd</span><span class="s2">[</span><span class="s1">n</span><span class="s2">:][</span><span class="s1">i_slack</span><span class="s2">],</span>
            <span class="s4">0.0</span><span class="s2">,</span>
        <span class="s2">)</span>
        <span class="s1">alpha_xl </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">min</span><span class="s2">(</span><span class="s1">all_alpha_xl</span><span class="s2">)</span>
        <span class="s1">alpha_xu </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">min</span><span class="s2">(</span><span class="s1">all_alpha_xu</span><span class="s2">)</span>
        <span class="s1">alpha_slack </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">min</span><span class="s2">(</span><span class="s1">all_alpha_slack</span><span class="s2">, </span><span class="s1">initial</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span><span class="s2">)</span>
        <span class="s1">alpha_bd </span><span class="s2">= </span><span class="s1">min</span><span class="s2">(</span><span class="s1">alpha_xl</span><span class="s2">, </span><span class="s1">alpha_xu</span><span class="s2">, </span><span class="s1">alpha_slack</span><span class="s2">)</span>

        <span class="s5"># Set alpha_ub to the step size for the linear constraints.</span>
        <span class="s1">aub_sd </span><span class="s2">= </span><span class="s1">aub </span><span class="s2">@ </span><span class="s1">sd</span><span class="s2">[:</span><span class="s1">n</span><span class="s2">] - </span><span class="s1">sd</span><span class="s2">[</span><span class="s1">n</span><span class="s2">:]</span>
        <span class="s1">i_ub </span><span class="s2">= </span><span class="s1">free_ub </span><span class="s2">&amp; (</span><span class="s1">aub_sd </span><span class="s2">&gt; </span><span class="s1">TINY </span><span class="s2">* </span><span class="s1">np</span><span class="s2">.</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">resid</span><span class="s2">))</span>
        <span class="s1">all_alpha_ub </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">full_like</span><span class="s2">(</span><span class="s1">bub</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span><span class="s2">)</span>
        <span class="s1">all_alpha_ub</span><span class="s2">[</span><span class="s1">i_ub</span><span class="s2">] = </span><span class="s1">resid</span><span class="s2">[</span><span class="s1">i_ub</span><span class="s2">] / </span><span class="s1">aub_sd</span><span class="s2">[</span><span class="s1">i_ub</span><span class="s2">]</span>
        <span class="s1">alpha_ub </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">min</span><span class="s2">(</span><span class="s1">all_alpha_ub</span><span class="s2">, </span><span class="s1">initial</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span><span class="s2">)</span>

        <span class="s5"># Update the iterate.</span>
        <span class="s1">alpha </span><span class="s2">= </span><span class="s1">min</span><span class="s2">(</span><span class="s1">alpha</span><span class="s2">, </span><span class="s1">alpha_bd</span><span class="s2">, </span><span class="s1">alpha_ub</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">alpha </span><span class="s2">&gt; </span><span class="s4">0.0</span><span class="s2">:</span>
            <span class="s1">step </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">clip</span><span class="s2">(</span><span class="s1">step </span><span class="s2">+ </span><span class="s1">alpha </span><span class="s2">* </span><span class="s1">sd</span><span class="s2">[:</span><span class="s1">n</span><span class="s2">], </span><span class="s1">xl</span><span class="s2">, </span><span class="s1">xu</span><span class="s2">)</span>
            <span class="s1">grad </span><span class="s2">+= </span><span class="s1">alpha </span><span class="s2">* </span><span class="s1">hess_sd</span>
            <span class="s1">resid </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">maximum</span><span class="s2">(</span><span class="s4">0.0</span><span class="s2">, </span><span class="s1">resid </span><span class="s2">- </span><span class="s1">alpha </span><span class="s2">* </span><span class="s1">aub_sd</span><span class="s2">)</span>
            <span class="s1">reduct </span><span class="s2">-= </span><span class="s1">alpha </span><span class="s2">* (</span><span class="s1">grad_sd </span><span class="s2">+ </span><span class="s4">0.5 </span><span class="s2">* </span><span class="s1">alpha </span><span class="s2">* </span><span class="s1">curv_sd</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">alpha </span><span class="s2">&lt; </span><span class="s1">min</span><span class="s2">(</span><span class="s1">alpha_tr</span><span class="s2">, </span><span class="s1">alpha_bd</span><span class="s2">, </span><span class="s1">alpha_ub</span><span class="s2">):</span>
            <span class="s5"># The current iteration is a conjugate gradient iteration. Update</span>
            <span class="s5"># the search direction so that it is conjugate (with respect to H)</span>
            <span class="s5"># to all the previous search directions.</span>
            <span class="s1">grad_proj </span><span class="s2">= </span><span class="s1">q</span><span class="s2">[:, </span><span class="s1">n_act</span><span class="s2">:] @ (</span><span class="s1">q</span><span class="s2">[:, </span><span class="s1">n_act</span><span class="s2">:].</span><span class="s1">T </span><span class="s2">@ </span><span class="s1">grad</span><span class="s2">)</span>
            <span class="s1">beta </span><span class="s2">= (</span><span class="s1">grad_proj </span><span class="s2">@ </span><span class="s1">hess_sd</span><span class="s2">) / </span><span class="s1">curv_sd</span>
            <span class="s1">sd </span><span class="s2">= </span><span class="s1">beta </span><span class="s2">* </span><span class="s1">sd </span><span class="s2">- </span><span class="s1">grad_proj</span>
            <span class="s1">k </span><span class="s2">+= </span><span class="s4">1</span>
        <span class="s0">elif </span><span class="s1">alpha </span><span class="s2">&lt; </span><span class="s1">alpha_tr</span><span class="s2">:</span>
            <span class="s5"># The iterate is restricted by a bound/linear constraint. Add this</span>
            <span class="s5"># constraint to the active set, and restart the calculations.</span>
            <span class="s0">if </span><span class="s1">alpha_xl </span><span class="s2">&lt;= </span><span class="s1">alpha</span><span class="s2">:</span>
                <span class="s1">i_new </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">argmin</span><span class="s2">(</span><span class="s1">all_alpha_xl</span><span class="s2">)</span>
                <span class="s1">step</span><span class="s2">[</span><span class="s1">i_new</span><span class="s2">] = </span><span class="s1">xl</span><span class="s2">[</span><span class="s1">i_new</span><span class="s2">]</span>
                <span class="s1">free_xl</span><span class="s2">[</span><span class="s1">i_new</span><span class="s2">] = </span><span class="s0">False</span>
            <span class="s0">elif </span><span class="s1">alpha_xu </span><span class="s2">&lt;= </span><span class="s1">alpha</span><span class="s2">:</span>
                <span class="s1">i_new </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">argmin</span><span class="s2">(</span><span class="s1">all_alpha_xu</span><span class="s2">)</span>
                <span class="s1">step</span><span class="s2">[</span><span class="s1">i_new</span><span class="s2">] = </span><span class="s1">xu</span><span class="s2">[</span><span class="s1">i_new</span><span class="s2">]</span>
                <span class="s1">free_xu</span><span class="s2">[</span><span class="s1">i_new</span><span class="s2">] = </span><span class="s0">False</span>
            <span class="s0">elif </span><span class="s1">alpha_slack </span><span class="s2">&lt;= </span><span class="s1">alpha</span><span class="s2">:</span>
                <span class="s1">i_new </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">argmin</span><span class="s2">(</span><span class="s1">all_alpha_slack</span><span class="s2">)</span>
                <span class="s1">free_slack</span><span class="s2">[</span><span class="s1">i_new</span><span class="s2">] = </span><span class="s0">False</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">i_new </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">argmin</span><span class="s2">(</span><span class="s1">all_alpha_ub</span><span class="s2">)</span>
                <span class="s1">free_ub</span><span class="s2">[</span><span class="s1">i_new</span><span class="s2">] = </span><span class="s0">False</span>
            <span class="s1">n_act</span><span class="s2">, </span><span class="s1">q </span><span class="s2">= </span><span class="s1">qr_normal_byrd_omojokun</span><span class="s2">(</span>
                <span class="s1">aub</span><span class="s2">, </span><span class="s1">free_xl</span><span class="s2">, </span><span class="s1">free_xu</span><span class="s2">, </span><span class="s1">free_slack</span><span class="s2">, </span><span class="s1">free_ub</span>
            <span class="s2">)</span>
            <span class="s1">sd </span><span class="s2">= -</span><span class="s1">q</span><span class="s2">[:, </span><span class="s1">n_act</span><span class="s2">:] @ (</span><span class="s1">q</span><span class="s2">[:, </span><span class="s1">n_act</span><span class="s2">:].</span><span class="s1">T </span><span class="s2">@ </span><span class="s1">grad</span><span class="s2">)</span>
            <span class="s1">k </span><span class="s2">= </span><span class="s4">0</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s5"># The current iterate is on the trust-region boundary. Add all the</span>
            <span class="s5"># active bound constraints to the working set to prepare for the</span>
            <span class="s5"># improvement of the solution, and stop the iterations.</span>
            <span class="s0">if </span><span class="s1">alpha_xl </span><span class="s2">&lt;= </span><span class="s1">alpha</span><span class="s2">:</span>
                <span class="s1">i_new </span><span class="s2">= </span><span class="s1">_argmin</span><span class="s2">(</span><span class="s1">all_alpha_xl</span><span class="s2">)</span>
                <span class="s1">step</span><span class="s2">[</span><span class="s1">i_new</span><span class="s2">] = </span><span class="s1">xl</span><span class="s2">[</span><span class="s1">i_new</span><span class="s2">]</span>
                <span class="s1">free_xl</span><span class="s2">[</span><span class="s1">i_new</span><span class="s2">] = </span><span class="s0">False</span>
            <span class="s0">if </span><span class="s1">alpha_xu </span><span class="s2">&lt;= </span><span class="s1">alpha</span><span class="s2">:</span>
                <span class="s1">i_new </span><span class="s2">= </span><span class="s1">_argmin</span><span class="s2">(</span><span class="s1">all_alpha_xu</span><span class="s2">)</span>
                <span class="s1">step</span><span class="s2">[</span><span class="s1">i_new</span><span class="s2">] = </span><span class="s1">xu</span><span class="s2">[</span><span class="s1">i_new</span><span class="s2">]</span>
                <span class="s1">free_xu</span><span class="s2">[</span><span class="s1">i_new</span><span class="s2">] = </span><span class="s0">False</span>
            <span class="s1">boundary_reached </span><span class="s2">= </span><span class="s0">True</span>
            <span class="s0">break</span>

    <span class="s5"># Attempt to improve the solution on the trust-region boundary.</span>
    <span class="s0">if </span><span class="s1">kwargs</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s6">&quot;improve_tcg&quot;</span><span class="s2">, </span><span class="s0">True</span><span class="s2">) </span><span class="s0">and </span><span class="s1">boundary_reached</span><span class="s2">:</span>
        <span class="s1">step_base </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">(</span><span class="s1">step</span><span class="s2">)</span>
        <span class="s1">free_bd </span><span class="s2">= </span><span class="s1">free_xl </span><span class="s2">&amp; </span><span class="s1">free_xu</span>
        <span class="s1">grad </span><span class="s2">= </span><span class="s1">aub</span><span class="s2">.</span><span class="s1">T </span><span class="s2">@ </span><span class="s1">np</span><span class="s2">.</span><span class="s1">maximum</span><span class="s2">(</span><span class="s1">aub </span><span class="s2">@ </span><span class="s1">step </span><span class="s2">- </span><span class="s1">bub</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">) + </span><span class="s1">aeq</span><span class="s2">.</span><span class="s1">T </span><span class="s2">@ (</span>
            <span class="s1">aeq </span><span class="s2">@ </span><span class="s1">step </span><span class="s2">- </span><span class="s1">beq</span>
        <span class="s2">)</span>
        <span class="s1">sd </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">(</span><span class="s1">n</span><span class="s2">)</span>
        <span class="s0">while </span><span class="s1">np</span><span class="s2">.</span><span class="s1">count_nonzero</span><span class="s2">(</span><span class="s1">free_bd</span><span class="s2">) &gt; </span><span class="s4">0</span><span class="s2">:</span>
            <span class="s5"># Check whether a substantial reduction in the objective function</span>
            <span class="s5"># is possible, and set the search direction.</span>
            <span class="s1">step_sq </span><span class="s2">= </span><span class="s1">step</span><span class="s2">[</span><span class="s1">free_bd</span><span class="s2">] @ </span><span class="s1">step</span><span class="s2">[</span><span class="s1">free_bd</span><span class="s2">]</span>
            <span class="s1">grad_sq </span><span class="s2">= </span><span class="s1">grad</span><span class="s2">[</span><span class="s1">free_bd</span><span class="s2">] @ </span><span class="s1">grad</span><span class="s2">[</span><span class="s1">free_bd</span><span class="s2">]</span>
            <span class="s1">grad_step </span><span class="s2">= </span><span class="s1">grad</span><span class="s2">[</span><span class="s1">free_bd</span><span class="s2">] @ </span><span class="s1">step</span><span class="s2">[</span><span class="s1">free_bd</span><span class="s2">]</span>
            <span class="s1">grad_sd </span><span class="s2">= -</span><span class="s1">np</span><span class="s2">.</span><span class="s1">sqrt</span><span class="s2">(</span><span class="s1">max</span><span class="s2">(</span><span class="s1">step_sq </span><span class="s2">* </span><span class="s1">grad_sq </span><span class="s2">- </span><span class="s1">grad_step</span><span class="s2">**</span><span class="s4">2.0</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">))</span>
            <span class="s1">sd</span><span class="s2">[</span><span class="s1">free_bd</span><span class="s2">] = </span><span class="s1">grad_step </span><span class="s2">* </span><span class="s1">step</span><span class="s2">[</span><span class="s1">free_bd</span><span class="s2">] - </span><span class="s1">step_sq </span><span class="s2">* </span><span class="s1">grad</span><span class="s2">[</span><span class="s1">free_bd</span><span class="s2">]</span>
            <span class="s1">sd</span><span class="s2">[~</span><span class="s1">free_bd</span><span class="s2">] = </span><span class="s4">0.0</span>
            <span class="s0">if </span><span class="s1">grad_sd </span><span class="s2">&gt;= -</span><span class="s4">1e-8 </span><span class="s2">* </span><span class="s1">reduct </span><span class="s0">or </span><span class="s1">np</span><span class="s2">.</span><span class="s1">any</span><span class="s2">(</span>
                <span class="s1">grad_sd </span><span class="s2">&gt;= -</span><span class="s1">TINY </span><span class="s2">* </span><span class="s1">np</span><span class="s2">.</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">sd</span><span class="s2">[</span><span class="s1">free_bd</span><span class="s2">])</span>
            <span class="s2">):</span>
                <span class="s0">break</span>
            <span class="s1">sd</span><span class="s2">[</span><span class="s1">free_bd</span><span class="s2">] /= -</span><span class="s1">grad_sd</span>

            <span class="s5"># Calculate an upper bound for the tangent of half the angle theta</span>
            <span class="s5"># of this alternative iteration. The step will be updated as:</span>
            <span class="s5"># step = cos(theta) * step + sin(theta) * sd.</span>
            <span class="s1">temp_xl </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">(</span><span class="s1">n</span><span class="s2">)</span>
            <span class="s1">temp_xu </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">(</span><span class="s1">n</span><span class="s2">)</span>
            <span class="s1">temp_xl</span><span class="s2">[</span><span class="s1">free_bd</span><span class="s2">] = (</span>
                <span class="s1">step</span><span class="s2">[</span><span class="s1">free_bd</span><span class="s2">] ** </span><span class="s4">2.0 </span><span class="s2">+ </span><span class="s1">sd</span><span class="s2">[</span><span class="s1">free_bd</span><span class="s2">] ** </span><span class="s4">2.0 </span><span class="s2">- </span><span class="s1">xl</span><span class="s2">[</span><span class="s1">free_bd</span><span class="s2">] ** </span><span class="s4">2.0</span>
            <span class="s2">)</span>
            <span class="s1">temp_xu</span><span class="s2">[</span><span class="s1">free_bd</span><span class="s2">] = (</span>
                <span class="s1">step</span><span class="s2">[</span><span class="s1">free_bd</span><span class="s2">] ** </span><span class="s4">2.0 </span><span class="s2">+ </span><span class="s1">sd</span><span class="s2">[</span><span class="s1">free_bd</span><span class="s2">] ** </span><span class="s4">2.0 </span><span class="s2">- </span><span class="s1">xu</span><span class="s2">[</span><span class="s1">free_bd</span><span class="s2">] ** </span><span class="s4">2.0</span>
            <span class="s2">)</span>
            <span class="s1">temp_xl</span><span class="s2">[</span><span class="s1">temp_xl </span><span class="s2">&gt; </span><span class="s4">0.0</span><span class="s2">] = (</span>
                <span class="s1">np</span><span class="s2">.</span><span class="s1">sqrt</span><span class="s2">(</span><span class="s1">temp_xl</span><span class="s2">[</span><span class="s1">temp_xl </span><span class="s2">&gt; </span><span class="s4">0.0</span><span class="s2">]) - </span><span class="s1">sd</span><span class="s2">[</span><span class="s1">temp_xl </span><span class="s2">&gt; </span><span class="s4">0.0</span><span class="s2">]</span>
            <span class="s2">)</span>
            <span class="s1">temp_xu</span><span class="s2">[</span><span class="s1">temp_xu </span><span class="s2">&gt; </span><span class="s4">0.0</span><span class="s2">] = (</span>
                <span class="s1">np</span><span class="s2">.</span><span class="s1">sqrt</span><span class="s2">(</span><span class="s1">temp_xu</span><span class="s2">[</span><span class="s1">temp_xu </span><span class="s2">&gt; </span><span class="s4">0.0</span><span class="s2">]) + </span><span class="s1">sd</span><span class="s2">[</span><span class="s1">temp_xu </span><span class="s2">&gt; </span><span class="s4">0.0</span><span class="s2">]</span>
            <span class="s2">)</span>
            <span class="s1">dist_xl </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">maximum</span><span class="s2">(</span><span class="s1">step </span><span class="s2">- </span><span class="s1">xl</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">)</span>
            <span class="s1">dist_xu </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">maximum</span><span class="s2">(</span><span class="s1">xu </span><span class="s2">- </span><span class="s1">step</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">)</span>
            <span class="s1">i_xl </span><span class="s2">= </span><span class="s1">temp_xl </span><span class="s2">&gt; </span><span class="s1">TINY </span><span class="s2">* </span><span class="s1">dist_xl</span>
            <span class="s1">i_xu </span><span class="s2">= </span><span class="s1">temp_xu </span><span class="s2">&gt; </span><span class="s1">TINY </span><span class="s2">* </span><span class="s1">dist_xu</span>
            <span class="s1">all_t_xl </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">(</span><span class="s1">n</span><span class="s2">)</span>
            <span class="s1">all_t_xu </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">(</span><span class="s1">n</span><span class="s2">)</span>
            <span class="s1">all_t_xl</span><span class="s2">[</span><span class="s1">i_xl</span><span class="s2">] = </span><span class="s1">np</span><span class="s2">.</span><span class="s1">minimum</span><span class="s2">(</span>
                <span class="s1">all_t_xl</span><span class="s2">[</span><span class="s1">i_xl</span><span class="s2">],</span>
                <span class="s1">dist_xl</span><span class="s2">[</span><span class="s1">i_xl</span><span class="s2">] / </span><span class="s1">temp_xl</span><span class="s2">[</span><span class="s1">i_xl</span><span class="s2">],</span>
            <span class="s2">)</span>
            <span class="s1">all_t_xu</span><span class="s2">[</span><span class="s1">i_xu</span><span class="s2">] = </span><span class="s1">np</span><span class="s2">.</span><span class="s1">minimum</span><span class="s2">(</span>
                <span class="s1">all_t_xu</span><span class="s2">[</span><span class="s1">i_xu</span><span class="s2">],</span>
                <span class="s1">dist_xu</span><span class="s2">[</span><span class="s1">i_xu</span><span class="s2">] / </span><span class="s1">temp_xu</span><span class="s2">[</span><span class="s1">i_xu</span><span class="s2">],</span>
            <span class="s2">)</span>
            <span class="s1">t_xl </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">min</span><span class="s2">(</span><span class="s1">all_t_xl</span><span class="s2">)</span>
            <span class="s1">t_xu </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">min</span><span class="s2">(</span><span class="s1">all_t_xu</span><span class="s2">)</span>
            <span class="s1">t_bd </span><span class="s2">= </span><span class="s1">min</span><span class="s2">(</span><span class="s1">t_xl</span><span class="s2">, </span><span class="s1">t_xu</span><span class="s2">)</span>

            <span class="s5"># For a range of equally spaced values of tan(0.5 * theta),</span>
            <span class="s5"># calculate the reduction in the objective function that would be</span>
            <span class="s5"># obtained by accepting the corresponding angle.</span>
            <span class="s1">n_samples </span><span class="s2">= </span><span class="s4">20</span>
            <span class="s1">n_samples </span><span class="s2">= </span><span class="s1">int</span><span class="s2">((</span><span class="s1">n_samples </span><span class="s2">- </span><span class="s4">3</span><span class="s2">) * </span><span class="s1">t_bd </span><span class="s2">+ </span><span class="s4">3</span><span class="s2">)</span>
            <span class="s1">t_samples </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linspace</span><span class="s2">(</span><span class="s1">t_bd </span><span class="s2">/ </span><span class="s1">n_samples</span><span class="s2">, </span><span class="s1">t_bd</span><span class="s2">, </span><span class="s1">n_samples</span><span class="s2">)</span>
            <span class="s1">resid_ub </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">maximum</span><span class="s2">(</span><span class="s1">aub </span><span class="s2">@ </span><span class="s1">step </span><span class="s2">- </span><span class="s1">bub</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">)</span>
            <span class="s1">resid_eq </span><span class="s2">= </span><span class="s1">aeq </span><span class="s2">@ </span><span class="s1">step </span><span class="s2">- </span><span class="s1">beq</span>
            <span class="s1">step_proj </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">(</span><span class="s1">step</span><span class="s2">)</span>
            <span class="s1">step_proj</span><span class="s2">[~</span><span class="s1">free_bd</span><span class="s2">] = </span><span class="s4">0.0</span>
            <span class="s1">all_reduct </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">(</span><span class="s1">n_samples</span><span class="s2">)</span>
            <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">n_samples</span><span class="s2">):</span>
                <span class="s1">sin_value </span><span class="s2">= </span><span class="s4">2.0 </span><span class="s2">* </span><span class="s1">t_samples</span><span class="s2">[</span><span class="s1">i</span><span class="s2">] / (</span><span class="s4">1.0 </span><span class="s2">+ </span><span class="s1">t_samples</span><span class="s2">[</span><span class="s1">i</span><span class="s2">] ** </span><span class="s4">2.0</span><span class="s2">)</span>
                <span class="s1">step_alt </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">clip</span><span class="s2">(</span>
                    <span class="s1">step </span><span class="s2">+ </span><span class="s1">sin_value </span><span class="s2">* (</span><span class="s1">sd </span><span class="s2">- </span><span class="s1">t_samples</span><span class="s2">[</span><span class="s1">i</span><span class="s2">] * </span><span class="s1">step_proj</span><span class="s2">),</span>
                    <span class="s1">xl</span><span class="s2">,</span>
                    <span class="s1">xu</span><span class="s2">,</span>
                <span class="s2">)</span>
                <span class="s1">resid_ub_alt </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">maximum</span><span class="s2">(</span><span class="s1">aub </span><span class="s2">@ </span><span class="s1">step_alt </span><span class="s2">- </span><span class="s1">bub</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">)</span>
                <span class="s1">resid_eq_alt </span><span class="s2">= </span><span class="s1">aeq </span><span class="s2">@ </span><span class="s1">step_alt </span><span class="s2">- </span><span class="s1">beq</span>
                <span class="s1">all_reduct</span><span class="s2">[</span><span class="s1">i</span><span class="s2">] = </span><span class="s4">0.5 </span><span class="s2">* (</span>
                    <span class="s1">resid_ub </span><span class="s2">@ </span><span class="s1">resid_ub</span>
                    <span class="s2">+ </span><span class="s1">resid_eq </span><span class="s2">@ </span><span class="s1">resid_eq</span>
                    <span class="s2">- </span><span class="s1">resid_ub_alt </span><span class="s2">@ </span><span class="s1">resid_ub_alt</span>
                    <span class="s2">- </span><span class="s1">resid_eq_alt </span><span class="s2">@ </span><span class="s1">resid_eq_alt</span>
                <span class="s2">)</span>
            <span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">all</span><span class="s2">(</span><span class="s1">all_reduct </span><span class="s2">&lt;= </span><span class="s4">0.0</span><span class="s2">):</span>
                <span class="s5"># No reduction in the objective function is obtained.</span>
                <span class="s0">break</span>

            <span class="s5"># Accept the angle that provides the largest reduction in the</span>
            <span class="s5"># objective function, and update the iterate.</span>
            <span class="s1">i_max </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">argmax</span><span class="s2">(</span><span class="s1">all_reduct</span><span class="s2">)</span>
            <span class="s1">cos_value </span><span class="s2">= (</span><span class="s4">1.0 </span><span class="s2">- </span><span class="s1">t_samples</span><span class="s2">[</span><span class="s1">i_max</span><span class="s2">] ** </span><span class="s4">2.0</span><span class="s2">) / (</span>
                <span class="s4">1.0 </span><span class="s2">+ </span><span class="s1">t_samples</span><span class="s2">[</span><span class="s1">i_max</span><span class="s2">] ** </span><span class="s4">2.0</span>
            <span class="s2">)</span>
            <span class="s1">sin_value </span><span class="s2">= (</span><span class="s4">2.0 </span><span class="s2">* </span><span class="s1">t_samples</span><span class="s2">[</span><span class="s1">i_max</span><span class="s2">]</span>
                         <span class="s2">/ (</span><span class="s4">1.0 </span><span class="s2">+ </span><span class="s1">t_samples</span><span class="s2">[</span><span class="s1">i_max</span><span class="s2">] ** </span><span class="s4">2.0</span><span class="s2">))</span>
            <span class="s1">step</span><span class="s2">[</span><span class="s1">free_bd</span><span class="s2">] = </span><span class="s1">cos_value </span><span class="s2">* </span><span class="s1">step</span><span class="s2">[</span><span class="s1">free_bd</span><span class="s2">] + </span><span class="s1">sin_value </span><span class="s2">* </span><span class="s1">sd</span><span class="s2">[</span><span class="s1">free_bd</span><span class="s2">]</span>
            <span class="s1">grad </span><span class="s2">= </span><span class="s1">aub</span><span class="s2">.</span><span class="s1">T </span><span class="s2">@ </span><span class="s1">np</span><span class="s2">.</span><span class="s1">maximum</span><span class="s2">(</span><span class="s1">aub </span><span class="s2">@ </span><span class="s1">step </span><span class="s2">- </span><span class="s1">bub</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">) + </span><span class="s1">aeq</span><span class="s2">.</span><span class="s1">T </span><span class="s2">@ (</span>
                <span class="s1">aeq </span><span class="s2">@ </span><span class="s1">step </span><span class="s2">- </span><span class="s1">beq</span>
            <span class="s2">)</span>
            <span class="s1">reduct </span><span class="s2">+= </span><span class="s1">all_reduct</span><span class="s2">[</span><span class="s1">i_max</span><span class="s2">]</span>

            <span class="s5"># If the above angle is restricted by bound constraints, add them</span>
            <span class="s5"># to the working set, and restart the alternative iteration.</span>
            <span class="s5"># Otherwise, the calculations are terminated.</span>
            <span class="s0">if </span><span class="s1">t_bd </span><span class="s2">&lt; </span><span class="s4">1.0 </span><span class="s0">and </span><span class="s1">i_max </span><span class="s2">== </span><span class="s1">n_samples </span><span class="s2">- </span><span class="s4">1</span><span class="s2">:</span>
                <span class="s0">if </span><span class="s1">t_xl </span><span class="s2">&lt;= </span><span class="s1">t_bd</span><span class="s2">:</span>
                    <span class="s1">i_new </span><span class="s2">= </span><span class="s1">_argmin</span><span class="s2">(</span><span class="s1">all_t_xl</span><span class="s2">)</span>
                    <span class="s1">step</span><span class="s2">[</span><span class="s1">i_new</span><span class="s2">] = </span><span class="s1">xl</span><span class="s2">[</span><span class="s1">i_new</span><span class="s2">]</span>
                    <span class="s1">free_bd</span><span class="s2">[</span><span class="s1">i_new</span><span class="s2">] = </span><span class="s0">False</span>
                <span class="s0">if </span><span class="s1">t_xu </span><span class="s2">&lt;= </span><span class="s1">t_bd</span><span class="s2">:</span>
                    <span class="s1">i_new </span><span class="s2">= </span><span class="s1">_argmin</span><span class="s2">(</span><span class="s1">all_t_xu</span><span class="s2">)</span>
                    <span class="s1">step</span><span class="s2">[</span><span class="s1">i_new</span><span class="s2">] = </span><span class="s1">xu</span><span class="s2">[</span><span class="s1">i_new</span><span class="s2">]</span>
                    <span class="s1">free_bd</span><span class="s2">[</span><span class="s1">i_new</span><span class="s2">] = </span><span class="s0">False</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s0">break</span>

        <span class="s5"># Ensure that the alternative iteration improves the objective</span>
        <span class="s5"># function.</span>
        <span class="s1">resid_ub </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">maximum</span><span class="s2">(</span><span class="s1">aub </span><span class="s2">@ </span><span class="s1">step </span><span class="s2">- </span><span class="s1">bub</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">)</span>
        <span class="s1">resid_ub_base </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">maximum</span><span class="s2">(</span><span class="s1">aub </span><span class="s2">@ </span><span class="s1">step_base </span><span class="s2">- </span><span class="s1">bub</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">)</span>
        <span class="s1">resid_eq </span><span class="s2">= </span><span class="s1">aeq </span><span class="s2">@ </span><span class="s1">step </span><span class="s2">- </span><span class="s1">beq</span>
        <span class="s1">resid_eq_base </span><span class="s2">= </span><span class="s1">aeq </span><span class="s2">@ </span><span class="s1">step_base </span><span class="s2">- </span><span class="s1">beq</span>
        <span class="s0">if </span><span class="s2">(</span>
            <span class="s1">resid_ub </span><span class="s2">@ </span><span class="s1">resid_ub </span><span class="s2">+ </span><span class="s1">resid_eq </span><span class="s2">@ </span><span class="s1">resid_eq</span>
            <span class="s2">&gt; </span><span class="s1">resid_ub_base </span><span class="s2">@ </span><span class="s1">resid_ub_base </span><span class="s2">+ </span><span class="s1">resid_eq_base </span><span class="s2">@ </span><span class="s1">resid_eq_base</span>
        <span class="s2">):</span>
            <span class="s1">step </span><span class="s2">= </span><span class="s1">step_base</span>

    <span class="s0">if </span><span class="s1">debug</span><span class="s2">:</span>
        <span class="s0">assert </span><span class="s1">np</span><span class="s2">.</span><span class="s1">all</span><span class="s2">(</span><span class="s1">xl </span><span class="s2">&lt;= </span><span class="s1">step</span><span class="s2">)</span>
        <span class="s0">assert </span><span class="s1">np</span><span class="s2">.</span><span class="s1">all</span><span class="s2">(</span><span class="s1">step </span><span class="s2">&lt;= </span><span class="s1">xu</span><span class="s2">)</span>
        <span class="s0">assert </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">norm</span><span class="s2">(</span><span class="s1">step</span><span class="s2">) &lt; </span><span class="s4">1.1 </span><span class="s2">* </span><span class="s1">delta</span>
    <span class="s0">return </span><span class="s1">step</span>


<span class="s0">def </span><span class="s1">qr_tangential_byrd_omojokun</span><span class="s2">(</span><span class="s1">aub</span><span class="s2">, </span><span class="s1">aeq</span><span class="s2">, </span><span class="s1">free_xl</span><span class="s2">, </span><span class="s1">free_xu</span><span class="s2">, </span><span class="s1">free_ub</span><span class="s2">):</span>
    <span class="s1">n </span><span class="s2">= </span><span class="s1">free_xl</span><span class="s2">.</span><span class="s1">size</span>
    <span class="s1">identity </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">eye</span><span class="s2">(</span><span class="s1">n</span><span class="s2">)</span>
    <span class="s1">q</span><span class="s2">, </span><span class="s1">r</span><span class="s2">, </span><span class="s1">_ </span><span class="s2">= </span><span class="s1">qr</span><span class="s2">(</span>
        <span class="s1">np</span><span class="s2">.</span><span class="s1">block</span><span class="s2">(</span>
            <span class="s2">[</span>
                <span class="s2">[</span><span class="s1">aeq</span><span class="s2">],</span>
                <span class="s2">[</span><span class="s1">aub</span><span class="s2">[~</span><span class="s1">free_ub</span><span class="s2">, :]],</span>
                <span class="s2">[-</span><span class="s1">identity</span><span class="s2">[~</span><span class="s1">free_xl</span><span class="s2">, :]],</span>
                <span class="s2">[</span><span class="s1">identity</span><span class="s2">[~</span><span class="s1">free_xu</span><span class="s2">, :]],</span>
            <span class="s2">]</span>
        <span class="s2">).</span><span class="s1">T</span><span class="s2">,</span>
        <span class="s1">pivoting</span><span class="s2">=</span><span class="s0">True</span><span class="s2">,</span>
    <span class="s2">)</span>
    <span class="s1">n_act </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">count_nonzero</span><span class="s2">(</span>
        <span class="s1">np</span><span class="s2">.</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">diag</span><span class="s2">(</span><span class="s1">r</span><span class="s2">))</span>
        <span class="s2">&gt;= </span><span class="s4">10.0</span>
        <span class="s2">* </span><span class="s1">EPS</span>
        <span class="s2">* </span><span class="s1">n</span>
        <span class="s2">* </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">norm</span><span class="s2">(</span><span class="s1">r</span><span class="s2">[: </span><span class="s1">np</span><span class="s2">.</span><span class="s1">min</span><span class="s2">(</span><span class="s1">r</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">), : </span><span class="s1">np</span><span class="s2">.</span><span class="s1">min</span><span class="s2">(</span><span class="s1">r</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">)], </span><span class="s1">axis</span><span class="s2">=</span><span class="s4">0</span><span class="s2">)</span>
    <span class="s2">)</span>
    <span class="s0">return </span><span class="s1">n_act</span><span class="s2">, </span><span class="s1">q</span>


<span class="s0">def </span><span class="s1">qr_normal_byrd_omojokun</span><span class="s2">(</span><span class="s1">aub</span><span class="s2">, </span><span class="s1">free_xl</span><span class="s2">, </span><span class="s1">free_xu</span><span class="s2">, </span><span class="s1">free_slack</span><span class="s2">, </span><span class="s1">free_ub</span><span class="s2">):</span>
    <span class="s1">m_linear_ub</span><span class="s2">, </span><span class="s1">n </span><span class="s2">= </span><span class="s1">aub</span><span class="s2">.</span><span class="s1">shape</span>
    <span class="s1">identity_n </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">eye</span><span class="s2">(</span><span class="s1">n</span><span class="s2">)</span>
    <span class="s1">identity_m </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">eye</span><span class="s2">(</span><span class="s1">m_linear_ub</span><span class="s2">)</span>
    <span class="s1">q</span><span class="s2">, </span><span class="s1">r</span><span class="s2">, </span><span class="s1">_ </span><span class="s2">= </span><span class="s1">qr</span><span class="s2">(</span>
        <span class="s1">np</span><span class="s2">.</span><span class="s1">block</span><span class="s2">(</span>
            <span class="s2">[</span>
                <span class="s2">[</span>
                    <span class="s1">aub</span><span class="s2">[~</span><span class="s1">free_ub</span><span class="s2">, :],</span>
                    <span class="s2">-</span><span class="s1">identity_m</span><span class="s2">[~</span><span class="s1">free_ub</span><span class="s2">, :],</span>
                <span class="s2">],</span>
                <span class="s2">[</span>
                    <span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">((</span><span class="s1">m_linear_ub </span><span class="s2">- </span><span class="s1">np</span><span class="s2">.</span><span class="s1">count_nonzero</span><span class="s2">(</span><span class="s1">free_slack</span><span class="s2">), </span><span class="s1">n</span><span class="s2">)),</span>
                    <span class="s2">-</span><span class="s1">identity_m</span><span class="s2">[~</span><span class="s1">free_slack</span><span class="s2">, :],</span>
                <span class="s2">],</span>
                <span class="s2">[</span>
                    <span class="s2">-</span><span class="s1">identity_n</span><span class="s2">[~</span><span class="s1">free_xl</span><span class="s2">, :],</span>
                    <span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">((</span><span class="s1">n </span><span class="s2">- </span><span class="s1">np</span><span class="s2">.</span><span class="s1">count_nonzero</span><span class="s2">(</span><span class="s1">free_xl</span><span class="s2">), </span><span class="s1">m_linear_ub</span><span class="s2">)),</span>
                <span class="s2">],</span>
                <span class="s2">[</span>
                    <span class="s1">identity_n</span><span class="s2">[~</span><span class="s1">free_xu</span><span class="s2">, :],</span>
                    <span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">((</span><span class="s1">n </span><span class="s2">- </span><span class="s1">np</span><span class="s2">.</span><span class="s1">count_nonzero</span><span class="s2">(</span><span class="s1">free_xu</span><span class="s2">), </span><span class="s1">m_linear_ub</span><span class="s2">)),</span>
                <span class="s2">],</span>
            <span class="s2">]</span>
        <span class="s2">).</span><span class="s1">T</span><span class="s2">,</span>
        <span class="s1">pivoting</span><span class="s2">=</span><span class="s0">True</span><span class="s2">,</span>
    <span class="s2">)</span>
    <span class="s1">n_act </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">count_nonzero</span><span class="s2">(</span>
        <span class="s1">np</span><span class="s2">.</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">diag</span><span class="s2">(</span><span class="s1">r</span><span class="s2">))</span>
        <span class="s2">&gt;= </span><span class="s4">10.0</span>
        <span class="s2">* </span><span class="s1">EPS</span>
        <span class="s2">* (</span><span class="s1">n </span><span class="s2">+ </span><span class="s1">m_linear_ub</span><span class="s2">)</span>
        <span class="s2">* </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">norm</span><span class="s2">(</span><span class="s1">r</span><span class="s2">[: </span><span class="s1">np</span><span class="s2">.</span><span class="s1">min</span><span class="s2">(</span><span class="s1">r</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">), : </span><span class="s1">np</span><span class="s2">.</span><span class="s1">min</span><span class="s2">(</span><span class="s1">r</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">)], </span><span class="s1">axis</span><span class="s2">=</span><span class="s4">0</span><span class="s2">)</span>
    <span class="s2">)</span>
    <span class="s0">return </span><span class="s1">n_act</span><span class="s2">, </span><span class="s1">q</span>


<span class="s0">def </span><span class="s1">_alpha_tr</span><span class="s2">(</span><span class="s1">step</span><span class="s2">, </span><span class="s1">sd</span><span class="s2">, </span><span class="s1">delta</span><span class="s2">):</span>
    <span class="s1">step_sd </span><span class="s2">= </span><span class="s1">step </span><span class="s2">@ </span><span class="s1">sd</span>
    <span class="s1">sd_sq </span><span class="s2">= </span><span class="s1">sd </span><span class="s2">@ </span><span class="s1">sd</span>
    <span class="s1">dist_tr_sq </span><span class="s2">= </span><span class="s1">delta</span><span class="s2">**</span><span class="s4">2.0 </span><span class="s2">- </span><span class="s1">step </span><span class="s2">@ </span><span class="s1">step</span>
    <span class="s1">temp </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sqrt</span><span class="s2">(</span><span class="s1">max</span><span class="s2">(</span><span class="s1">step_sd</span><span class="s2">**</span><span class="s4">2.0 </span><span class="s2">+ </span><span class="s1">sd_sq </span><span class="s2">* </span><span class="s1">dist_tr_sq</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">))</span>
    <span class="s0">if </span><span class="s1">step_sd </span><span class="s2">&lt;= </span><span class="s4">0.0 </span><span class="s0">and </span><span class="s1">sd_sq </span><span class="s2">&gt; </span><span class="s1">TINY </span><span class="s2">* </span><span class="s1">abs</span><span class="s2">(</span><span class="s1">temp </span><span class="s2">- </span><span class="s1">step_sd</span><span class="s2">):</span>
        <span class="s1">alpha_tr </span><span class="s2">= </span><span class="s1">max</span><span class="s2">((</span><span class="s1">temp </span><span class="s2">- </span><span class="s1">step_sd</span><span class="s2">) / </span><span class="s1">sd_sq</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">)</span>
    <span class="s0">elif </span><span class="s1">abs</span><span class="s2">(</span><span class="s1">temp </span><span class="s2">+ </span><span class="s1">step_sd</span><span class="s2">) &gt; </span><span class="s1">TINY </span><span class="s2">* </span><span class="s1">dist_tr_sq</span><span class="s2">:</span>
        <span class="s1">alpha_tr </span><span class="s2">= </span><span class="s1">max</span><span class="s2">(</span><span class="s1">dist_tr_sq </span><span class="s2">/ (</span><span class="s1">temp </span><span class="s2">+ </span><span class="s1">step_sd</span><span class="s2">), </span><span class="s4">0.0</span><span class="s2">)</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">ZeroDivisionError</span>
    <span class="s0">return </span><span class="s1">alpha_tr</span>


<span class="s0">def </span><span class="s1">_argmax</span><span class="s2">(</span><span class="s1">x</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">flatnonzero</span><span class="s2">(</span><span class="s1">x </span><span class="s2">&gt;= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">max</span><span class="s2">(</span><span class="s1">x</span><span class="s2">))</span>


<span class="s0">def </span><span class="s1">_argmin</span><span class="s2">(</span><span class="s1">x</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">flatnonzero</span><span class="s2">(</span><span class="s1">x </span><span class="s2">&lt;= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">min</span><span class="s2">(</span><span class="s1">x</span><span class="s2">))</span>
</pre>
</body>
</html>