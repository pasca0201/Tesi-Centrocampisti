<html>
<head>
<title>grouper.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #6aab73;}
.s5 { color: #7a7e85;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
grouper.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Provide user facing operators for doing the split part of the 
split-apply-combine paradigm. 
&quot;&quot;&quot;</span>
<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">annotations</span>

<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s3">(</span>
    <span class="s1">TYPE_CHECKING</span><span class="s3">,</span>
    <span class="s1">final</span><span class="s3">,</span>
<span class="s3">)</span>
<span class="s2">import </span><span class="s1">warnings</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>

<span class="s2">from </span><span class="s1">pandas</span><span class="s3">.</span><span class="s1">_config </span><span class="s2">import </span><span class="s3">(</span>
    <span class="s1">using_copy_on_write</span><span class="s3">,</span>
    <span class="s1">warn_copy_on_write</span><span class="s3">,</span>
<span class="s3">)</span>

<span class="s2">from </span><span class="s1">pandas</span><span class="s3">.</span><span class="s1">_libs </span><span class="s2">import </span><span class="s1">lib</span>
<span class="s2">from </span><span class="s1">pandas</span><span class="s3">.</span><span class="s1">_libs</span><span class="s3">.</span><span class="s1">tslibs </span><span class="s2">import </span><span class="s1">OutOfBoundsDatetime</span>
<span class="s2">from </span><span class="s1">pandas</span><span class="s3">.</span><span class="s1">errors </span><span class="s2">import </span><span class="s1">InvalidIndexError</span>
<span class="s2">from </span><span class="s1">pandas</span><span class="s3">.</span><span class="s1">util</span><span class="s3">.</span><span class="s1">_decorators </span><span class="s2">import </span><span class="s1">cache_readonly</span>
<span class="s2">from </span><span class="s1">pandas</span><span class="s3">.</span><span class="s1">util</span><span class="s3">.</span><span class="s1">_exceptions </span><span class="s2">import </span><span class="s1">find_stack_level</span>

<span class="s2">from </span><span class="s1">pandas</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">dtypes</span><span class="s3">.</span><span class="s1">common </span><span class="s2">import </span><span class="s3">(</span>
    <span class="s1">is_list_like</span><span class="s3">,</span>
    <span class="s1">is_scalar</span><span class="s3">,</span>
<span class="s3">)</span>
<span class="s2">from </span><span class="s1">pandas</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">dtypes</span><span class="s3">.</span><span class="s1">dtypes </span><span class="s2">import </span><span class="s1">CategoricalDtype</span>

<span class="s2">from </span><span class="s1">pandas</span><span class="s3">.</span><span class="s1">core </span><span class="s2">import </span><span class="s1">algorithms</span>
<span class="s2">from </span><span class="s1">pandas</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">arrays </span><span class="s2">import </span><span class="s3">(</span>
    <span class="s1">Categorical</span><span class="s3">,</span>
    <span class="s1">ExtensionArray</span><span class="s3">,</span>
<span class="s3">)</span>
<span class="s2">import </span><span class="s1">pandas</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">common </span><span class="s2">as </span><span class="s1">com</span>
<span class="s2">from </span><span class="s1">pandas</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">frame </span><span class="s2">import </span><span class="s1">DataFrame</span>
<span class="s2">from </span><span class="s1">pandas</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">groupby </span><span class="s2">import </span><span class="s1">ops</span>
<span class="s2">from </span><span class="s1">pandas</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">groupby</span><span class="s3">.</span><span class="s1">categorical </span><span class="s2">import </span><span class="s1">recode_for_groupby</span>
<span class="s2">from </span><span class="s1">pandas</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">indexes</span><span class="s3">.</span><span class="s1">api </span><span class="s2">import </span><span class="s3">(</span>
    <span class="s1">CategoricalIndex</span><span class="s3">,</span>
    <span class="s1">Index</span><span class="s3">,</span>
    <span class="s1">MultiIndex</span><span class="s3">,</span>
<span class="s3">)</span>
<span class="s2">from </span><span class="s1">pandas</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">series </span><span class="s2">import </span><span class="s1">Series</span>

<span class="s2">from </span><span class="s1">pandas</span><span class="s3">.</span><span class="s1">io</span><span class="s3">.</span><span class="s1">formats</span><span class="s3">.</span><span class="s1">printing </span><span class="s2">import </span><span class="s1">pprint_thing</span>

<span class="s2">if </span><span class="s1">TYPE_CHECKING</span><span class="s3">:</span>
    <span class="s2">from </span><span class="s1">collections</span><span class="s3">.</span><span class="s1">abc </span><span class="s2">import </span><span class="s3">(</span>
        <span class="s1">Hashable</span><span class="s3">,</span>
        <span class="s1">Iterator</span><span class="s3">,</span>
    <span class="s3">)</span>

    <span class="s2">from </span><span class="s1">pandas</span><span class="s3">.</span><span class="s1">_typing </span><span class="s2">import </span><span class="s3">(</span>
        <span class="s1">ArrayLike</span><span class="s3">,</span>
        <span class="s1">Axis</span><span class="s3">,</span>
        <span class="s1">NDFrameT</span><span class="s3">,</span>
        <span class="s1">npt</span><span class="s3">,</span>
    <span class="s3">)</span>

    <span class="s2">from </span><span class="s1">pandas</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">generic </span><span class="s2">import </span><span class="s1">NDFrame</span>


<span class="s2">class </span><span class="s1">Grouper</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot; 
    A Grouper allows the user to specify a groupby instruction for an object. 
 
    This specification will select a column via the key parameter, or if the 
    level and/or axis parameters are given, a level of the index of the target 
    object. 
 
    If `axis` and/or `level` are passed as keywords to both `Grouper` and 
    `groupby`, the values passed to `Grouper` take precedence. 
 
    Parameters 
    ---------- 
    key : str, defaults to None 
        Groupby key, which selects the grouping column of the target. 
    level : name/number, defaults to None 
        The level for the target index. 
    freq : str / frequency object, defaults to None 
        This will groupby the specified frequency if the target selection 
        (via key or level) is a datetime-like object. For full specification 
        of available frequencies, please see `here 
        &lt;https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases&gt;`_. 
    axis : str, int, defaults to 0 
        Number/name of the axis. 
    sort : bool, default to False 
        Whether to sort the resulting labels. 
    closed : {'left' or 'right'} 
        Closed end of interval. Only when `freq` parameter is passed. 
    label : {'left' or 'right'} 
        Interval boundary to use for labeling. 
        Only when `freq` parameter is passed. 
    convention : {'start', 'end', 'e', 's'} 
        If grouper is PeriodIndex and `freq` parameter is passed. 
 
    origin : Timestamp or str, default 'start_day' 
        The timestamp on which to adjust the grouping. The timezone of origin must 
        match the timezone of the index. 
        If string, must be one of the following: 
 
        - 'epoch': `origin` is 1970-01-01 
        - 'start': `origin` is the first value of the timeseries 
        - 'start_day': `origin` is the first day at midnight of the timeseries 
 
        - 'end': `origin` is the last value of the timeseries 
        - 'end_day': `origin` is the ceiling midnight of the last day 
 
        .. versionadded:: 1.3.0 
 
    offset : Timedelta or str, default is None 
        An offset timedelta added to the origin. 
 
    dropna : bool, default True 
        If True, and if group keys contain NA values, NA values together with 
        row/column will be dropped. If False, NA values will also be treated as 
        the key in groups. 
 
    Returns 
    ------- 
    Grouper or pandas.api.typing.TimeGrouper 
        A TimeGrouper is returned if ``freq`` is not ``None``. Otherwise, a Grouper 
        is returned. 
 
    Examples 
    -------- 
    ``df.groupby(pd.Grouper(key=&quot;Animal&quot;))`` is equivalent to ``df.groupby('Animal')`` 
 
    &gt;&gt;&gt; df = pd.DataFrame( 
    ...     { 
    ...         &quot;Animal&quot;: [&quot;Falcon&quot;, &quot;Parrot&quot;, &quot;Falcon&quot;, &quot;Falcon&quot;, &quot;Parrot&quot;], 
    ...         &quot;Speed&quot;: [100, 5, 200, 300, 15], 
    ...     } 
    ... ) 
    &gt;&gt;&gt; df 
       Animal  Speed 
    0  Falcon    100 
    1  Parrot      5 
    2  Falcon    200 
    3  Falcon    300 
    4  Parrot     15 
    &gt;&gt;&gt; df.groupby(pd.Grouper(key=&quot;Animal&quot;)).mean() 
            Speed 
    Animal 
    Falcon  200.0 
    Parrot   10.0 
 
    Specify a resample operation on the column 'Publish date' 
 
    &gt;&gt;&gt; df = pd.DataFrame( 
    ...    { 
    ...        &quot;Publish date&quot;: [ 
    ...             pd.Timestamp(&quot;2000-01-02&quot;), 
    ...             pd.Timestamp(&quot;2000-01-02&quot;), 
    ...             pd.Timestamp(&quot;2000-01-09&quot;), 
    ...             pd.Timestamp(&quot;2000-01-16&quot;) 
    ...         ], 
    ...         &quot;ID&quot;: [0, 1, 2, 3], 
    ...         &quot;Price&quot;: [10, 20, 30, 40] 
    ...     } 
    ... ) 
    &gt;&gt;&gt; df 
      Publish date  ID  Price 
    0   2000-01-02   0     10 
    1   2000-01-02   1     20 
    2   2000-01-09   2     30 
    3   2000-01-16   3     40 
    &gt;&gt;&gt; df.groupby(pd.Grouper(key=&quot;Publish date&quot;, freq=&quot;1W&quot;)).mean() 
                   ID  Price 
    Publish date 
    2000-01-02    0.5   15.0 
    2000-01-09    2.0   30.0 
    2000-01-16    3.0   40.0 
 
    If you want to adjust the start of the bins based on a fixed timestamp: 
 
    &gt;&gt;&gt; start, end = '2000-10-01 23:30:00', '2000-10-02 00:30:00' 
    &gt;&gt;&gt; rng = pd.date_range(start, end, freq='7min') 
    &gt;&gt;&gt; ts = pd.Series(np.arange(len(rng)) * 3, index=rng) 
    &gt;&gt;&gt; ts 
    2000-10-01 23:30:00     0 
    2000-10-01 23:37:00     3 
    2000-10-01 23:44:00     6 
    2000-10-01 23:51:00     9 
    2000-10-01 23:58:00    12 
    2000-10-02 00:05:00    15 
    2000-10-02 00:12:00    18 
    2000-10-02 00:19:00    21 
    2000-10-02 00:26:00    24 
    Freq: 7min, dtype: int64 
 
    &gt;&gt;&gt; ts.groupby(pd.Grouper(freq='17min')).sum() 
    2000-10-01 23:14:00     0 
    2000-10-01 23:31:00     9 
    2000-10-01 23:48:00    21 
    2000-10-02 00:05:00    54 
    2000-10-02 00:22:00    24 
    Freq: 17min, dtype: int64 
 
    &gt;&gt;&gt; ts.groupby(pd.Grouper(freq='17min', origin='epoch')).sum() 
    2000-10-01 23:18:00     0 
    2000-10-01 23:35:00    18 
    2000-10-01 23:52:00    27 
    2000-10-02 00:09:00    39 
    2000-10-02 00:26:00    24 
    Freq: 17min, dtype: int64 
 
    &gt;&gt;&gt; ts.groupby(pd.Grouper(freq='17min', origin='2000-01-01')).sum() 
    2000-10-01 23:24:00     3 
    2000-10-01 23:41:00    15 
    2000-10-01 23:58:00    45 
    2000-10-02 00:15:00    45 
    Freq: 17min, dtype: int64 
 
    If you want to adjust the start of the bins with an `offset` Timedelta, the two 
    following lines are equivalent: 
 
    &gt;&gt;&gt; ts.groupby(pd.Grouper(freq='17min', origin='start')).sum() 
    2000-10-01 23:30:00     9 
    2000-10-01 23:47:00    21 
    2000-10-02 00:04:00    54 
    2000-10-02 00:21:00    24 
    Freq: 17min, dtype: int64 
 
    &gt;&gt;&gt; ts.groupby(pd.Grouper(freq='17min', offset='23h30min')).sum() 
    2000-10-01 23:30:00     9 
    2000-10-01 23:47:00    21 
    2000-10-02 00:04:00    54 
    2000-10-02 00:21:00    24 
    Freq: 17min, dtype: int64 
 
    To replace the use of the deprecated `base` argument, you can now use `offset`, 
    in this example it is equivalent to have `base=2`: 
 
    &gt;&gt;&gt; ts.groupby(pd.Grouper(freq='17min', offset='2min')).sum() 
    2000-10-01 23:16:00     0 
    2000-10-01 23:33:00     9 
    2000-10-01 23:50:00    36 
    2000-10-02 00:07:00    39 
    2000-10-02 00:24:00    24 
    Freq: 17min, dtype: int64 
    &quot;&quot;&quot;</span>

    <span class="s1">sort</span><span class="s3">: </span><span class="s1">bool</span>
    <span class="s1">dropna</span><span class="s3">: </span><span class="s1">bool</span>
    <span class="s1">_gpr_index</span><span class="s3">: </span><span class="s1">Index </span><span class="s3">| </span><span class="s2">None</span>
    <span class="s1">_grouper</span><span class="s3">: </span><span class="s1">Index </span><span class="s3">| </span><span class="s2">None</span>

    <span class="s1">_attributes</span><span class="s3">: </span><span class="s1">tuple</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, ...] = (</span><span class="s4">&quot;key&quot;</span><span class="s3">, </span><span class="s4">&quot;level&quot;</span><span class="s3">, </span><span class="s4">&quot;freq&quot;</span><span class="s3">, </span><span class="s4">&quot;axis&quot;</span><span class="s3">, </span><span class="s4">&quot;sort&quot;</span><span class="s3">, </span><span class="s4">&quot;dropna&quot;</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__new__</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">kwargs</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">&quot;freq&quot;</span><span class="s3">) </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s2">from </span><span class="s1">pandas</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">resample </span><span class="s2">import </span><span class="s1">TimeGrouper</span>

            <span class="s1">cls </span><span class="s3">= </span><span class="s1">TimeGrouper</span>
        <span class="s2">return </span><span class="s1">super</span><span class="s3">().</span><span class="s1">__new__</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">key</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">level</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">freq</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">axis</span><span class="s3">: </span><span class="s1">Axis </span><span class="s3">| </span><span class="s1">lib</span><span class="s3">.</span><span class="s1">NoDefault </span><span class="s3">= </span><span class="s1">lib</span><span class="s3">.</span><span class="s1">no_default</span><span class="s3">,</span>
        <span class="s1">sort</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span><span class="s3">,</span>
        <span class="s1">dropna</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">True</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">type</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s2">is </span><span class="s1">Grouper</span><span class="s3">:</span>
            <span class="s5"># i.e. not TimeGrouper</span>
            <span class="s2">if </span><span class="s1">axis </span><span class="s2">is not </span><span class="s1">lib</span><span class="s3">.</span><span class="s1">no_default</span><span class="s3">:</span>
                <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span>
                    <span class="s4">&quot;Grouper axis keyword is deprecated and will be removed in a &quot;</span>
                    <span class="s4">&quot;future version. To group on axis=1, use obj.T.groupby(...) &quot;</span>
                    <span class="s4">&quot;instead&quot;</span><span class="s3">,</span>
                    <span class="s1">FutureWarning</span><span class="s3">,</span>
                    <span class="s1">stacklevel</span><span class="s3">=</span><span class="s1">find_stack_level</span><span class="s3">(),</span>
                <span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">axis </span><span class="s3">= </span><span class="s6">0</span>
        <span class="s2">if </span><span class="s1">axis </span><span class="s2">is </span><span class="s1">lib</span><span class="s3">.</span><span class="s1">no_default</span><span class="s3">:</span>
            <span class="s1">axis </span><span class="s3">= </span><span class="s6">0</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">key </span><span class="s3">= </span><span class="s1">key</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">level </span><span class="s3">= </span><span class="s1">level</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">freq </span><span class="s3">= </span><span class="s1">freq</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">axis </span><span class="s3">= </span><span class="s1">axis</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">sort </span><span class="s3">= </span><span class="s1">sort</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">dropna </span><span class="s3">= </span><span class="s1">dropna</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">_grouper_deprecated </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_indexer_deprecated</span><span class="s3">: </span><span class="s1">npt</span><span class="s3">.</span><span class="s1">NDArray</span><span class="s3">[</span><span class="s1">np</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_obj_deprecated </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_gpr_index </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">binner </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_grouper </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_indexer</span><span class="s3">: </span><span class="s1">npt</span><span class="s3">.</span><span class="s1">NDArray</span><span class="s3">[</span><span class="s1">np</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">_get_grouper</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">obj</span><span class="s3">: </span><span class="s1">NDFrameT</span><span class="s3">, </span><span class="s1">validate</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">True</span>
    <span class="s3">) </span><span class="s1">-&gt; tuple</span><span class="s3">[</span><span class="s1">ops</span><span class="s3">.</span><span class="s1">BaseGrouper</span><span class="s3">, </span><span class="s1">NDFrameT</span><span class="s3">]:</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        obj : Series or DataFrame 
        validate : bool, default True 
            if True, validate the grouper 
 
        Returns 
        ------- 
        a tuple of grouper, obj (possibly sorted) 
        &quot;&quot;&quot;</span>
        <span class="s1">obj</span><span class="s3">, </span><span class="s1">_</span><span class="s3">, </span><span class="s1">_ </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_set_grouper</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">)</span>
        <span class="s1">grouper</span><span class="s3">, </span><span class="s1">_</span><span class="s3">, </span><span class="s1">obj </span><span class="s3">= </span><span class="s1">get_grouper</span><span class="s3">(</span>
            <span class="s1">obj</span><span class="s3">,</span>
            <span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">key</span><span class="s3">],</span>
            <span class="s1">axis</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">axis</span><span class="s3">,</span>
            <span class="s1">level</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">level</span><span class="s3">,</span>
            <span class="s1">sort</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">sort</span><span class="s3">,</span>
            <span class="s1">validate</span><span class="s3">=</span><span class="s1">validate</span><span class="s3">,</span>
            <span class="s1">dropna</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">dropna</span><span class="s3">,</span>
        <span class="s3">)</span>
        <span class="s5"># Without setting this, subsequent lookups to .groups raise</span>
        <span class="s5"># error: Incompatible types in assignment (expression has type &quot;BaseGrouper&quot;,</span>
        <span class="s5"># variable has type &quot;None&quot;)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_grouper_deprecated </span><span class="s3">= </span><span class="s1">grouper  </span><span class="s5"># type: ignore[assignment]</span>

        <span class="s2">return </span><span class="s1">grouper</span><span class="s3">, </span><span class="s1">obj</span>

    <span class="s2">def </span><span class="s1">_set_grouper</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">obj</span><span class="s3">: </span><span class="s1">NDFrameT</span><span class="s3">, </span><span class="s1">sort</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span><span class="s3">, *, </span><span class="s1">gpr_index</span><span class="s3">: </span><span class="s1">Index </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span>
    <span class="s3">) </span><span class="s1">-&gt; tuple</span><span class="s3">[</span><span class="s1">NDFrameT</span><span class="s3">, </span><span class="s1">Index</span><span class="s3">, </span><span class="s1">npt</span><span class="s3">.</span><span class="s1">NDArray</span><span class="s3">[</span><span class="s1">np</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">] | </span><span class="s2">None</span><span class="s3">]:</span>
        <span class="s0">&quot;&quot;&quot; 
        given an object and the specifications, setup the internal grouper 
        for this particular specification 
 
        Parameters 
        ---------- 
        obj : Series or DataFrame 
        sort : bool, default False 
            whether the resulting grouper should be sorted 
        gpr_index : Index or None, default None 
 
        Returns 
        ------- 
        NDFrame 
        Index 
        np.ndarray[np.intp] | None 
        &quot;&quot;&quot;</span>
        <span class="s2">assert </span><span class="s1">obj </span><span class="s2">is not None</span>

        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">key </span><span class="s2">is not None and </span><span class="s1">self</span><span class="s3">.</span><span class="s1">level </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;The Grouper cannot specify both a key and a level!&quot;</span><span class="s3">)</span>

        <span class="s5"># Keep self._grouper value before overriding</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_grouper </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s5"># TODO: What are we assuming about subsequent calls?</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_grouper </span><span class="s3">= </span><span class="s1">gpr_index</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_indexer </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_indexer_deprecated</span>

        <span class="s5"># the key must be a valid info item</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">key </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s1">key </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">key</span>
            <span class="s5"># The 'on' is already defined</span>
            <span class="s2">if </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">gpr_index</span><span class="s3">, </span><span class="s4">&quot;name&quot;</span><span class="s3">, </span><span class="s2">None</span><span class="s3">) == </span><span class="s1">key </span><span class="s2">and </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">Series</span><span class="s3">):</span>
                <span class="s5"># Sometimes self._grouper will have been resorted while</span>
                <span class="s5"># obj has not. In this case there is a mismatch when we</span>
                <span class="s5"># call self._grouper.take(obj.index) so we need to undo the sorting</span>
                <span class="s5"># before we call _grouper.take.</span>
                <span class="s2">assert </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_grouper </span><span class="s2">is not None</span>
                <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_indexer </span><span class="s2">is not None</span><span class="s3">:</span>
                    <span class="s1">reverse_indexer </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_indexer</span><span class="s3">.</span><span class="s1">argsort</span><span class="s3">()</span>
                    <span class="s1">unsorted_ax </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_grouper</span><span class="s3">.</span><span class="s1">take</span><span class="s3">(</span><span class="s1">reverse_indexer</span><span class="s3">)</span>
                    <span class="s1">ax </span><span class="s3">= </span><span class="s1">unsorted_ax</span><span class="s3">.</span><span class="s1">take</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">.</span><span class="s1">index</span><span class="s3">)</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">ax </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_grouper</span><span class="s3">.</span><span class="s1">take</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">.</span><span class="s1">index</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">key </span><span class="s2">not in </span><span class="s1">obj</span><span class="s3">.</span><span class="s1">_info_axis</span><span class="s3">:</span>
                    <span class="s2">raise </span><span class="s1">KeyError</span><span class="s3">(</span><span class="s4">f&quot;The grouper name </span><span class="s2">{</span><span class="s1">key</span><span class="s2">} </span><span class="s4">is not found&quot;</span><span class="s3">)</span>
                <span class="s1">ax </span><span class="s3">= </span><span class="s1">Index</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">[</span><span class="s1">key</span><span class="s3">], </span><span class="s1">name</span><span class="s3">=</span><span class="s1">key</span><span class="s3">)</span>

        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">ax </span><span class="s3">= </span><span class="s1">obj</span><span class="s3">.</span><span class="s1">_get_axis</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">axis</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">level </span><span class="s2">is not None</span><span class="s3">:</span>
                <span class="s1">level </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">level</span>

                <span class="s5"># if a level is given it must be a mi level or</span>
                <span class="s5"># equivalent to the axis name</span>
                <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">ax</span><span class="s3">, </span><span class="s1">MultiIndex</span><span class="s3">):</span>
                    <span class="s1">level </span><span class="s3">= </span><span class="s1">ax</span><span class="s3">.</span><span class="s1">_get_level_number</span><span class="s3">(</span><span class="s1">level</span><span class="s3">)</span>
                    <span class="s1">ax </span><span class="s3">= </span><span class="s1">Index</span><span class="s3">(</span><span class="s1">ax</span><span class="s3">.</span><span class="s1">_get_level_values</span><span class="s3">(</span><span class="s1">level</span><span class="s3">), </span><span class="s1">name</span><span class="s3">=</span><span class="s1">ax</span><span class="s3">.</span><span class="s1">names</span><span class="s3">[</span><span class="s1">level</span><span class="s3">])</span>

                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s2">if </span><span class="s1">level </span><span class="s2">not in </span><span class="s3">(</span><span class="s6">0</span><span class="s3">, </span><span class="s1">ax</span><span class="s3">.</span><span class="s1">name</span><span class="s3">):</span>
                        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">f&quot;The level </span><span class="s2">{</span><span class="s1">level</span><span class="s2">} </span><span class="s4">is not valid&quot;</span><span class="s3">)</span>

        <span class="s5"># possibly sort</span>
        <span class="s1">indexer</span><span class="s3">: </span><span class="s1">npt</span><span class="s3">.</span><span class="s1">NDArray</span><span class="s3">[</span><span class="s1">np</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s2">if </span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">sort </span><span class="s2">or </span><span class="s1">sort</span><span class="s3">) </span><span class="s2">and not </span><span class="s1">ax</span><span class="s3">.</span><span class="s1">is_monotonic_increasing</span><span class="s3">:</span>
            <span class="s5"># use stable sort to support first, last, nth</span>
            <span class="s5"># TODO: why does putting na_position=&quot;first&quot; fix datetimelike cases?</span>
            <span class="s1">indexer </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_indexer_deprecated </span><span class="s3">= </span><span class="s1">ax</span><span class="s3">.</span><span class="s1">array</span><span class="s3">.</span><span class="s1">argsort</span><span class="s3">(</span>
                <span class="s1">kind</span><span class="s3">=</span><span class="s4">&quot;mergesort&quot;</span><span class="s3">, </span><span class="s1">na_position</span><span class="s3">=</span><span class="s4">&quot;first&quot;</span>
            <span class="s3">)</span>
            <span class="s1">ax </span><span class="s3">= </span><span class="s1">ax</span><span class="s3">.</span><span class="s1">take</span><span class="s3">(</span><span class="s1">indexer</span><span class="s3">)</span>
            <span class="s1">obj </span><span class="s3">= </span><span class="s1">obj</span><span class="s3">.</span><span class="s1">take</span><span class="s3">(</span><span class="s1">indexer</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">axis</span><span class="s3">)</span>

        <span class="s5"># error: Incompatible types in assignment (expression has type</span>
        <span class="s5"># &quot;NDFrameT&quot;, variable has type &quot;None&quot;)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_obj_deprecated </span><span class="s3">= </span><span class="s1">obj  </span><span class="s5"># type: ignore[assignment]</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_gpr_index </span><span class="s3">= </span><span class="s1">ax</span>
        <span class="s2">return </span><span class="s1">obj</span><span class="s3">, </span><span class="s1">ax</span><span class="s3">, </span><span class="s1">indexer</span>

    <span class="s3">@</span><span class="s1">final</span>
    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">ax</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; Index</span><span class="s3">:</span>
        <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span>
            <span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">type</span><span class="s3">(</span><span class="s1">self</span><span class="s3">).</span><span class="s1">__name__</span><span class="s2">}</span><span class="s4">.ax is deprecated and will be removed in a &quot;</span>
            <span class="s4">&quot;future version. Use Resampler.ax instead&quot;</span><span class="s3">,</span>
            <span class="s1">FutureWarning</span><span class="s3">,</span>
            <span class="s1">stacklevel</span><span class="s3">=</span><span class="s1">find_stack_level</span><span class="s3">(),</span>
        <span class="s3">)</span>
        <span class="s1">index </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_gpr_index</span>
        <span class="s2">if </span><span class="s1">index </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;_set_grouper must be called before ax is accessed&quot;</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">index</span>

    <span class="s3">@</span><span class="s1">final</span>
    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">indexer</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span>
            <span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">type</span><span class="s3">(</span><span class="s1">self</span><span class="s3">).</span><span class="s1">__name__</span><span class="s2">}</span><span class="s4">.indexer is deprecated and will be removed &quot;</span>
            <span class="s4">&quot;in a future version. Use Resampler.indexer instead.&quot;</span><span class="s3">,</span>
            <span class="s1">FutureWarning</span><span class="s3">,</span>
            <span class="s1">stacklevel</span><span class="s3">=</span><span class="s1">find_stack_level</span><span class="s3">(),</span>
        <span class="s3">)</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_indexer_deprecated</span>

    <span class="s3">@</span><span class="s1">final</span>
    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">obj</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s5"># TODO(3.0): enforcing these deprecations on Grouper should close</span>
        <span class="s5">#  GH#25564, GH#41930</span>
        <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span>
            <span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">type</span><span class="s3">(</span><span class="s1">self</span><span class="s3">).</span><span class="s1">__name__</span><span class="s2">}</span><span class="s4">.obj is deprecated and will be removed &quot;</span>
            <span class="s4">&quot;in a future version. Use GroupBy.indexer instead.&quot;</span><span class="s3">,</span>
            <span class="s1">FutureWarning</span><span class="s3">,</span>
            <span class="s1">stacklevel</span><span class="s3">=</span><span class="s1">find_stack_level</span><span class="s3">(),</span>
        <span class="s3">)</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_obj_deprecated</span>

    <span class="s3">@</span><span class="s1">final</span>
    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">grouper</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span>
            <span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">type</span><span class="s3">(</span><span class="s1">self</span><span class="s3">).</span><span class="s1">__name__</span><span class="s2">}</span><span class="s4">.grouper is deprecated and will be removed &quot;</span>
            <span class="s4">&quot;in a future version. Use GroupBy.grouper instead.&quot;</span><span class="s3">,</span>
            <span class="s1">FutureWarning</span><span class="s3">,</span>
            <span class="s1">stacklevel</span><span class="s3">=</span><span class="s1">find_stack_level</span><span class="s3">(),</span>
        <span class="s3">)</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_grouper_deprecated</span>

    <span class="s3">@</span><span class="s1">final</span>
    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">groups</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span>
            <span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">type</span><span class="s3">(</span><span class="s1">self</span><span class="s3">).</span><span class="s1">__name__</span><span class="s2">}</span><span class="s4">.groups is deprecated and will be removed &quot;</span>
            <span class="s4">&quot;in a future version. Use GroupBy.groups instead.&quot;</span><span class="s3">,</span>
            <span class="s1">FutureWarning</span><span class="s3">,</span>
            <span class="s1">stacklevel</span><span class="s3">=</span><span class="s1">find_stack_level</span><span class="s3">(),</span>
        <span class="s3">)</span>
        <span class="s5"># error: &quot;None&quot; has no attribute &quot;groups&quot;</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_grouper_deprecated</span><span class="s3">.</span><span class="s1">groups  </span><span class="s5"># type: ignore[attr-defined]</span>

    <span class="s3">@</span><span class="s1">final</span>
    <span class="s2">def </span><span class="s1">__repr__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; str</span><span class="s3">:</span>
        <span class="s1">attrs_list </span><span class="s3">= (</span>
            <span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">attr_name</span><span class="s2">}</span><span class="s4">=</span><span class="s2">{</span><span class="s1">repr</span><span class="s3">(</span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">attr_name</span><span class="s3">))</span><span class="s2">}</span><span class="s4">&quot;</span>
            <span class="s2">for </span><span class="s1">attr_name </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_attributes</span>
            <span class="s2">if </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">attr_name</span><span class="s3">) </span><span class="s2">is not None</span>
        <span class="s3">)</span>
        <span class="s1">attrs </span><span class="s3">= </span><span class="s4">&quot;, &quot;</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">attrs_list</span><span class="s3">)</span>
        <span class="s1">cls_name </span><span class="s3">= </span><span class="s1">type</span><span class="s3">(</span><span class="s1">self</span><span class="s3">).</span><span class="s1">__name__</span>
        <span class="s2">return </span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">cls_name</span><span class="s2">}</span><span class="s4">(</span><span class="s2">{</span><span class="s1">attrs</span><span class="s2">}</span><span class="s4">)&quot;</span>


<span class="s3">@</span><span class="s1">final</span>
<span class="s2">class </span><span class="s1">Grouping</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot; 
    Holds the grouping information for a single key 
 
    Parameters 
    ---------- 
    index : Index 
    grouper : 
    obj : DataFrame or Series 
    name : Label 
    level : 
    observed : bool, default False 
        If we are a Categorical, use the observed values 
    in_axis : if the Grouping is a column in self.obj and hence among 
        Groupby.exclusions list 
    dropna : bool, default True 
        Whether to drop NA groups. 
    uniques : Array-like, optional 
        When specified, will be used for unique values. Enables including empty groups 
        in the result for a BinGrouper. Must not contain duplicates. 
 
    Attributes 
    ------- 
    indices : dict 
        Mapping of {group -&gt; index_list} 
    codes : ndarray 
        Group codes 
    group_index : Index or None 
        unique groups 
    groups : dict 
        Mapping of {group -&gt; label_list} 
    &quot;&quot;&quot;</span>

    <span class="s1">_codes</span><span class="s3">: </span><span class="s1">npt</span><span class="s3">.</span><span class="s1">NDArray</span><span class="s3">[</span><span class="s1">np</span><span class="s3">.</span><span class="s1">signedinteger</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span>
    <span class="s1">_all_grouper</span><span class="s3">: </span><span class="s1">Categorical </span><span class="s3">| </span><span class="s2">None</span>
    <span class="s1">_orig_cats</span><span class="s3">: </span><span class="s1">Index </span><span class="s3">| </span><span class="s2">None</span>
    <span class="s1">_index</span><span class="s3">: </span><span class="s1">Index</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">index</span><span class="s3">: </span><span class="s1">Index</span><span class="s3">,</span>
        <span class="s1">grouper</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">obj</span><span class="s3">: </span><span class="s1">NDFrame </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">level</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">sort</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">True</span><span class="s3">,</span>
        <span class="s1">observed</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span><span class="s3">,</span>
        <span class="s1">in_axis</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span><span class="s3">,</span>
        <span class="s1">dropna</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">True</span><span class="s3">,</span>
        <span class="s1">uniques</span><span class="s3">: </span><span class="s1">ArrayLike </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">level </span><span class="s3">= </span><span class="s1">level</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_orig_grouper </span><span class="s3">= </span><span class="s1">grouper</span>
        <span class="s1">grouping_vector </span><span class="s3">= </span><span class="s1">_convert_grouper</span><span class="s3">(</span><span class="s1">index</span><span class="s3">, </span><span class="s1">grouper</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_all_grouper </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_orig_cats </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_index </span><span class="s3">= </span><span class="s1">index</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_sort </span><span class="s3">= </span><span class="s1">sort</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">obj </span><span class="s3">= </span><span class="s1">obj</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_observed </span><span class="s3">= </span><span class="s1">observed</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">in_axis </span><span class="s3">= </span><span class="s1">in_axis</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_dropna </span><span class="s3">= </span><span class="s1">dropna</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_uniques </span><span class="s3">= </span><span class="s1">uniques</span>

        <span class="s5"># we have a single grouper which may be a myriad of things,</span>
        <span class="s5"># some of which are dependent on the passing in level</span>

        <span class="s1">ilevel </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_ilevel</span>
        <span class="s2">if </span><span class="s1">ilevel </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s5"># In extant tests, the new self.grouping_vector matches</span>
            <span class="s5">#  `index.get_level_values(ilevel)` whenever</span>
            <span class="s5">#  mapper is None and isinstance(index, MultiIndex)</span>
            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">index</span><span class="s3">, </span><span class="s1">MultiIndex</span><span class="s3">):</span>
                <span class="s1">index_level </span><span class="s3">= </span><span class="s1">index</span><span class="s3">.</span><span class="s1">get_level_values</span><span class="s3">(</span><span class="s1">ilevel</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">index_level </span><span class="s3">= </span><span class="s1">index</span>

            <span class="s2">if </span><span class="s1">grouping_vector </span><span class="s2">is None</span><span class="s3">:</span>
                <span class="s1">grouping_vector </span><span class="s3">= </span><span class="s1">index_level</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">mapper </span><span class="s3">= </span><span class="s1">grouping_vector</span>
                <span class="s1">grouping_vector </span><span class="s3">= </span><span class="s1">index_level</span><span class="s3">.</span><span class="s1">map</span><span class="s3">(</span><span class="s1">mapper</span><span class="s3">)</span>

        <span class="s5"># a passed Grouper like, directly get the grouper in the same way</span>
        <span class="s5"># as single grouper groupby, use the group_info to get codes</span>
        <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">grouping_vector</span><span class="s3">, </span><span class="s1">Grouper</span><span class="s3">):</span>
            <span class="s5"># get the new grouper; we already have disambiguated</span>
            <span class="s5"># what key/level refer to exactly, don't need to</span>
            <span class="s5"># check again as we have by this point converted these</span>
            <span class="s5"># to an actual value (rather than a pd.Grouper)</span>
            <span class="s2">assert </span><span class="s1">self</span><span class="s3">.</span><span class="s1">obj </span><span class="s2">is not None  </span><span class="s5"># for mypy</span>
            <span class="s1">newgrouper</span><span class="s3">, </span><span class="s1">newobj </span><span class="s3">= </span><span class="s1">grouping_vector</span><span class="s3">.</span><span class="s1">_get_grouper</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">validate</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">obj </span><span class="s3">= </span><span class="s1">newobj</span>

            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">newgrouper</span><span class="s3">, </span><span class="s1">ops</span><span class="s3">.</span><span class="s1">BinGrouper</span><span class="s3">):</span>
                <span class="s5"># TODO: can we unwrap this and get a tighter typing</span>
                <span class="s5">#  for self.grouping_vector?</span>
                <span class="s1">grouping_vector </span><span class="s3">= </span><span class="s1">newgrouper</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s5"># ops.BaseGrouper</span>
                <span class="s5"># TODO: 2023-02-03 no test cases with len(newgrouper.groupings) &gt; 1.</span>
                <span class="s5">#  If that were to occur, would we be throwing out information?</span>
                <span class="s5"># error: Cannot determine type of &quot;grouping_vector&quot;  [has-type]</span>
                <span class="s1">ng </span><span class="s3">= </span><span class="s1">newgrouper</span><span class="s3">.</span><span class="s1">groupings</span><span class="s3">[</span><span class="s6">0</span><span class="s3">].</span><span class="s1">grouping_vector  </span><span class="s5"># type: ignore[has-type]</span>
                <span class="s5"># use Index instead of ndarray so we can recover the name</span>
                <span class="s1">grouping_vector </span><span class="s3">= </span><span class="s1">Index</span><span class="s3">(</span><span class="s1">ng</span><span class="s3">, </span><span class="s1">name</span><span class="s3">=</span><span class="s1">newgrouper</span><span class="s3">.</span><span class="s1">result_index</span><span class="s3">.</span><span class="s1">name</span><span class="s3">)</span>

        <span class="s2">elif not </span><span class="s1">isinstance</span><span class="s3">(</span>
            <span class="s1">grouping_vector</span><span class="s3">, (</span><span class="s1">Series</span><span class="s3">, </span><span class="s1">Index</span><span class="s3">, </span><span class="s1">ExtensionArray</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndarray</span><span class="s3">)</span>
        <span class="s3">):</span>
            <span class="s5"># no level passed</span>
            <span class="s2">if </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">grouping_vector</span><span class="s3">, </span><span class="s4">&quot;ndim&quot;</span><span class="s3">, </span><span class="s6">1</span><span class="s3">) != </span><span class="s6">1</span><span class="s3">:</span>
                <span class="s1">t </span><span class="s3">= </span><span class="s1">str</span><span class="s3">(</span><span class="s1">type</span><span class="s3">(</span><span class="s1">grouping_vector</span><span class="s3">))</span>
                <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">f&quot;Grouper for '</span><span class="s2">{</span><span class="s1">t</span><span class="s2">}</span><span class="s4">' not 1-dimensional&quot;</span><span class="s3">)</span>

            <span class="s1">grouping_vector </span><span class="s3">= </span><span class="s1">index</span><span class="s3">.</span><span class="s1">map</span><span class="s3">(</span><span class="s1">grouping_vector</span><span class="s3">)</span>

            <span class="s2">if not </span><span class="s3">(</span>
                <span class="s1">hasattr</span><span class="s3">(</span><span class="s1">grouping_vector</span><span class="s3">, </span><span class="s4">&quot;__len__&quot;</span><span class="s3">)</span>
                <span class="s2">and </span><span class="s1">len</span><span class="s3">(</span><span class="s1">grouping_vector</span><span class="s3">) == </span><span class="s1">len</span><span class="s3">(</span><span class="s1">index</span><span class="s3">)</span>
            <span class="s3">):</span>
                <span class="s1">grper </span><span class="s3">= </span><span class="s1">pprint_thing</span><span class="s3">(</span><span class="s1">grouping_vector</span><span class="s3">)</span>
                <span class="s1">errmsg </span><span class="s3">= (</span>
                    <span class="s4">&quot;Grouper result violates len(labels) == &quot;</span>
                    <span class="s4">f&quot;len(data)</span><span class="s2">\n</span><span class="s4">result: </span><span class="s2">{</span><span class="s1">grper</span><span class="s2">}</span><span class="s4">&quot;</span>
                <span class="s3">)</span>
                <span class="s2">raise </span><span class="s1">AssertionError</span><span class="s3">(</span><span class="s1">errmsg</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">grouping_vector</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndarray</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">grouping_vector</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">kind </span><span class="s2">in </span><span class="s4">&quot;mM&quot;</span><span class="s3">:</span>
                <span class="s5"># if we have a date/time-like grouper, make sure that we have</span>
                <span class="s5"># Timestamps like</span>
                <span class="s5"># TODO 2022-10-08 we only have one test that gets here and</span>
                <span class="s5">#  values are already in nanoseconds in that case.</span>
                <span class="s1">grouping_vector </span><span class="s3">= </span><span class="s1">Series</span><span class="s3">(</span><span class="s1">grouping_vector</span><span class="s3">).</span><span class="s1">to_numpy</span><span class="s3">()</span>
        <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">grouping_vector</span><span class="s3">, </span><span class="s4">&quot;dtype&quot;</span><span class="s3">, </span><span class="s2">None</span><span class="s3">), </span><span class="s1">CategoricalDtype</span><span class="s3">):</span>
            <span class="s5"># a passed Categorical</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_orig_cats </span><span class="s3">= </span><span class="s1">grouping_vector</span><span class="s3">.</span><span class="s1">categories</span>
            <span class="s1">grouping_vector</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_all_grouper </span><span class="s3">= </span><span class="s1">recode_for_groupby</span><span class="s3">(</span>
                <span class="s1">grouping_vector</span><span class="s3">, </span><span class="s1">sort</span><span class="s3">, </span><span class="s1">observed</span>
            <span class="s3">)</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">grouping_vector </span><span class="s3">= </span><span class="s1">grouping_vector</span>

    <span class="s2">def </span><span class="s1">__repr__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; str</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s4">f&quot;Grouping(</span><span class="s2">{</span><span class="s1">self</span><span class="s3">.</span><span class="s1">name</span><span class="s2">}</span><span class="s4">)&quot;</span>

    <span class="s2">def </span><span class="s1">__iter__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; Iterator</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">iter</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">indices</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">cache_readonly</span>
    <span class="s2">def </span><span class="s1">_passed_categorical</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
        <span class="s1">dtype </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">grouping_vector</span><span class="s3">, </span><span class="s4">&quot;dtype&quot;</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">CategoricalDtype</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">cache_readonly</span>
    <span class="s2">def </span><span class="s1">name</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; Hashable</span><span class="s3">:</span>
        <span class="s1">ilevel </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_ilevel</span>
        <span class="s2">if </span><span class="s1">ilevel </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_index</span><span class="s3">.</span><span class="s1">names</span><span class="s3">[</span><span class="s1">ilevel</span><span class="s3">]</span>

        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_orig_grouper</span><span class="s3">, (</span><span class="s1">Index</span><span class="s3">, </span><span class="s1">Series</span><span class="s3">)):</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_orig_grouper</span><span class="s3">.</span><span class="s1">name</span>

        <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">grouping_vector</span><span class="s3">, </span><span class="s1">ops</span><span class="s3">.</span><span class="s1">BaseGrouper</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">grouping_vector</span><span class="s3">.</span><span class="s1">result_index</span><span class="s3">.</span><span class="s1">name</span>

        <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">grouping_vector</span><span class="s3">, </span><span class="s1">Index</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">grouping_vector</span><span class="s3">.</span><span class="s1">name</span>

        <span class="s5"># otherwise we have ndarray or ExtensionArray -&gt; no name</span>
        <span class="s2">return None</span>

    <span class="s3">@</span><span class="s1">cache_readonly</span>
    <span class="s2">def </span><span class="s1">_ilevel</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; int </span><span class="s3">| </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot; 
        If necessary, converted index level name to index level position. 
        &quot;&quot;&quot;</span>
        <span class="s1">level </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">level</span>
        <span class="s2">if </span><span class="s1">level </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s2">return None</span>
        <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">level</span><span class="s3">, </span><span class="s1">int</span><span class="s3">):</span>
            <span class="s1">index </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_index</span>
            <span class="s2">if </span><span class="s1">level </span><span class="s2">not in </span><span class="s1">index</span><span class="s3">.</span><span class="s1">names</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">AssertionError</span><span class="s3">(</span><span class="s4">f&quot;Level </span><span class="s2">{</span><span class="s1">level</span><span class="s2">} </span><span class="s4">not in index&quot;</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">index</span><span class="s3">.</span><span class="s1">names</span><span class="s3">.</span><span class="s1">index</span><span class="s3">(</span><span class="s1">level</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">level</span>

    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">ngroups</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; int</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_group_index</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">cache_readonly</span>
    <span class="s2">def </span><span class="s1">indices</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; dict</span><span class="s3">[</span><span class="s1">Hashable</span><span class="s3">, </span><span class="s1">npt</span><span class="s3">.</span><span class="s1">NDArray</span><span class="s3">[</span><span class="s1">np</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">]]:</span>
        <span class="s5"># we have a list of groupers</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">grouping_vector</span><span class="s3">, </span><span class="s1">ops</span><span class="s3">.</span><span class="s1">BaseGrouper</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">grouping_vector</span><span class="s3">.</span><span class="s1">indices</span>

        <span class="s1">values </span><span class="s3">= </span><span class="s1">Categorical</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">grouping_vector</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">values</span><span class="s3">.</span><span class="s1">_reverse_indexer</span><span class="s3">()</span>

    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">codes</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; npt</span><span class="s3">.</span><span class="s1">NDArray</span><span class="s3">[</span><span class="s1">np</span><span class="s3">.</span><span class="s1">signedinteger</span><span class="s3">]:</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_codes_and_uniques</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]</span>

    <span class="s3">@</span><span class="s1">cache_readonly</span>
    <span class="s2">def </span><span class="s1">_group_arraylike</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; ArrayLike</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Analogous to result_index, but holding an ArrayLike to ensure 
        we can retain ExtensionDtypes. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_all_grouper </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s5"># retain dtype for categories, including unobserved ones</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_result_index</span><span class="s3">.</span><span class="s1">_values</span>

        <span class="s2">elif </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_passed_categorical</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_group_index</span><span class="s3">.</span><span class="s1">_values</span>

        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_codes_and_uniques</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]</span>

    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">group_arraylike</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; ArrayLike</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Analogous to result_index, but holding an ArrayLike to ensure 
        we can retain ExtensionDtypes. 
        &quot;&quot;&quot;</span>
        <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span>
            <span class="s4">&quot;group_arraylike is deprecated and will be removed in a future &quot;</span>
            <span class="s4">&quot;version of pandas&quot;</span><span class="s3">,</span>
            <span class="s1">category</span><span class="s3">=</span><span class="s1">FutureWarning</span><span class="s3">,</span>
            <span class="s1">stacklevel</span><span class="s3">=</span><span class="s1">find_stack_level</span><span class="s3">(),</span>
        <span class="s3">)</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_group_arraylike</span>

    <span class="s3">@</span><span class="s1">cache_readonly</span>
    <span class="s2">def </span><span class="s1">_result_index</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; Index</span><span class="s3">:</span>
        <span class="s5"># result_index retains dtype for categories, including unobserved ones,</span>
        <span class="s5">#  which group_index does not</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_all_grouper </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s1">group_idx </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_group_index</span>
            <span class="s2">assert </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">group_idx</span><span class="s3">, </span><span class="s1">CategoricalIndex</span><span class="s3">)</span>
            <span class="s1">cats </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_orig_cats</span>
            <span class="s5"># set_categories is dynamically added</span>
            <span class="s2">return </span><span class="s1">group_idx</span><span class="s3">.</span><span class="s1">set_categories</span><span class="s3">(</span><span class="s1">cats</span><span class="s3">)  </span><span class="s5"># type: ignore[attr-defined]</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_group_index</span>

    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">result_index</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; Index</span><span class="s3">:</span>
        <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span>
            <span class="s4">&quot;result_index is deprecated and will be removed in a future &quot;</span>
            <span class="s4">&quot;version of pandas&quot;</span><span class="s3">,</span>
            <span class="s1">category</span><span class="s3">=</span><span class="s1">FutureWarning</span><span class="s3">,</span>
            <span class="s1">stacklevel</span><span class="s3">=</span><span class="s1">find_stack_level</span><span class="s3">(),</span>
        <span class="s3">)</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_result_index</span>

    <span class="s3">@</span><span class="s1">cache_readonly</span>
    <span class="s2">def </span><span class="s1">_group_index</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; Index</span><span class="s3">:</span>
        <span class="s1">codes</span><span class="s3">, </span><span class="s1">uniques </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_codes_and_uniques</span>
        <span class="s2">if not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_dropna </span><span class="s2">and </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_passed_categorical</span><span class="s3">:</span>
            <span class="s2">assert </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">uniques</span><span class="s3">, </span><span class="s1">Categorical</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_sort </span><span class="s2">and </span><span class="s3">(</span><span class="s1">codes </span><span class="s3">== </span><span class="s1">len</span><span class="s3">(</span><span class="s1">uniques</span><span class="s3">)).</span><span class="s1">any</span><span class="s3">():</span>
                <span class="s5"># Add NA value on the end when sorting</span>
                <span class="s1">uniques </span><span class="s3">= </span><span class="s1">Categorical</span><span class="s3">.</span><span class="s1">from_codes</span><span class="s3">(</span>
                    <span class="s1">np</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">uniques</span><span class="s3">.</span><span class="s1">codes</span><span class="s3">, [-</span><span class="s6">1</span><span class="s3">]), </span><span class="s1">uniques</span><span class="s3">.</span><span class="s1">categories</span><span class="s3">, </span><span class="s1">validate</span><span class="s3">=</span><span class="s2">False</span>
                <span class="s3">)</span>
            <span class="s2">elif </span><span class="s1">len</span><span class="s3">(</span><span class="s1">codes</span><span class="s3">) &gt; </span><span class="s6">0</span><span class="s3">:</span>
                <span class="s5"># Need to determine proper placement of NA value when not sorting</span>
                <span class="s1">cat </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">grouping_vector</span>
                <span class="s1">na_idx </span><span class="s3">= (</span><span class="s1">cat</span><span class="s3">.</span><span class="s1">codes </span><span class="s3">&lt; </span><span class="s6">0</span><span class="s3">).</span><span class="s1">argmax</span><span class="s3">()</span>
                <span class="s2">if </span><span class="s1">cat</span><span class="s3">.</span><span class="s1">codes</span><span class="s3">[</span><span class="s1">na_idx</span><span class="s3">] &lt; </span><span class="s6">0</span><span class="s3">:</span>
                    <span class="s5"># count number of unique codes that comes before the nan value</span>
                    <span class="s1">na_unique_idx </span><span class="s3">= </span><span class="s1">algorithms</span><span class="s3">.</span><span class="s1">nunique_ints</span><span class="s3">(</span><span class="s1">cat</span><span class="s3">.</span><span class="s1">codes</span><span class="s3">[:</span><span class="s1">na_idx</span><span class="s3">])</span>
                    <span class="s1">new_codes </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">insert</span><span class="s3">(</span><span class="s1">uniques</span><span class="s3">.</span><span class="s1">codes</span><span class="s3">, </span><span class="s1">na_unique_idx</span><span class="s3">, -</span><span class="s6">1</span><span class="s3">)</span>
                    <span class="s1">uniques </span><span class="s3">= </span><span class="s1">Categorical</span><span class="s3">.</span><span class="s1">from_codes</span><span class="s3">(</span>
                        <span class="s1">new_codes</span><span class="s3">, </span><span class="s1">uniques</span><span class="s3">.</span><span class="s1">categories</span><span class="s3">, </span><span class="s1">validate</span><span class="s3">=</span><span class="s2">False</span>
                    <span class="s3">)</span>
        <span class="s2">return </span><span class="s1">Index</span><span class="s3">.</span><span class="s1">_with_infer</span><span class="s3">(</span><span class="s1">uniques</span><span class="s3">, </span><span class="s1">name</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">name</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">group_index</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; Index</span><span class="s3">:</span>
        <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span>
            <span class="s4">&quot;group_index is deprecated and will be removed in a future &quot;</span>
            <span class="s4">&quot;version of pandas&quot;</span><span class="s3">,</span>
            <span class="s1">category</span><span class="s3">=</span><span class="s1">FutureWarning</span><span class="s3">,</span>
            <span class="s1">stacklevel</span><span class="s3">=</span><span class="s1">find_stack_level</span><span class="s3">(),</span>
        <span class="s3">)</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_group_index</span>

    <span class="s3">@</span><span class="s1">cache_readonly</span>
    <span class="s2">def </span><span class="s1">_codes_and_uniques</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; tuple</span><span class="s3">[</span><span class="s1">npt</span><span class="s3">.</span><span class="s1">NDArray</span><span class="s3">[</span><span class="s1">np</span><span class="s3">.</span><span class="s1">signedinteger</span><span class="s3">], </span><span class="s1">ArrayLike</span><span class="s3">]:</span>
        <span class="s1">uniques</span><span class="s3">: </span><span class="s1">ArrayLike</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_passed_categorical</span><span class="s3">:</span>
            <span class="s5"># we make a CategoricalIndex out of the cat grouper</span>
            <span class="s5"># preserving the categories / ordered attributes;</span>
            <span class="s5"># doesn't (yet - GH#46909) handle dropna=False</span>
            <span class="s1">cat </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">grouping_vector</span>
            <span class="s1">categories </span><span class="s3">= </span><span class="s1">cat</span><span class="s3">.</span><span class="s1">categories</span>

            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_observed</span><span class="s3">:</span>
                <span class="s1">ucodes </span><span class="s3">= </span><span class="s1">algorithms</span><span class="s3">.</span><span class="s1">unique1d</span><span class="s3">(</span><span class="s1">cat</span><span class="s3">.</span><span class="s1">codes</span><span class="s3">)</span>
                <span class="s1">ucodes </span><span class="s3">= </span><span class="s1">ucodes</span><span class="s3">[</span><span class="s1">ucodes </span><span class="s3">!= -</span><span class="s6">1</span><span class="s3">]</span>
                <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_sort</span><span class="s3">:</span>
                    <span class="s1">ucodes </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sort</span><span class="s3">(</span><span class="s1">ucodes</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">ucodes </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">categories</span><span class="s3">))</span>

            <span class="s1">uniques </span><span class="s3">= </span><span class="s1">Categorical</span><span class="s3">.</span><span class="s1">from_codes</span><span class="s3">(</span>
                <span class="s1">codes</span><span class="s3">=</span><span class="s1">ucodes</span><span class="s3">, </span><span class="s1">categories</span><span class="s3">=</span><span class="s1">categories</span><span class="s3">, </span><span class="s1">ordered</span><span class="s3">=</span><span class="s1">cat</span><span class="s3">.</span><span class="s1">ordered</span><span class="s3">, </span><span class="s1">validate</span><span class="s3">=</span><span class="s2">False</span>
            <span class="s3">)</span>

            <span class="s1">codes </span><span class="s3">= </span><span class="s1">cat</span><span class="s3">.</span><span class="s1">codes</span>
            <span class="s2">if not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_dropna</span><span class="s3">:</span>
                <span class="s1">na_mask </span><span class="s3">= </span><span class="s1">codes </span><span class="s3">&lt; </span><span class="s6">0</span>
                <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">any</span><span class="s3">(</span><span class="s1">na_mask</span><span class="s3">):</span>
                    <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_sort</span><span class="s3">:</span>
                        <span class="s5"># Replace NA codes with `largest code + 1`</span>
                        <span class="s1">na_code </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">categories</span><span class="s3">)</span>
                        <span class="s1">codes </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">where</span><span class="s3">(</span><span class="s1">na_mask</span><span class="s3">, </span><span class="s1">na_code</span><span class="s3">, </span><span class="s1">codes</span><span class="s3">)</span>
                    <span class="s2">else</span><span class="s3">:</span>
                        <span class="s5"># Insert NA code into the codes based on first appearance</span>
                        <span class="s5"># A negative code must exist, no need to check codes[na_idx] &lt; 0</span>
                        <span class="s1">na_idx </span><span class="s3">= </span><span class="s1">na_mask</span><span class="s3">.</span><span class="s1">argmax</span><span class="s3">()</span>
                        <span class="s5"># count number of unique codes that comes before the nan value</span>
                        <span class="s1">na_code </span><span class="s3">= </span><span class="s1">algorithms</span><span class="s3">.</span><span class="s1">nunique_ints</span><span class="s3">(</span><span class="s1">codes</span><span class="s3">[:</span><span class="s1">na_idx</span><span class="s3">])</span>
                        <span class="s1">codes </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">where</span><span class="s3">(</span><span class="s1">codes </span><span class="s3">&gt;= </span><span class="s1">na_code</span><span class="s3">, </span><span class="s1">codes </span><span class="s3">+ </span><span class="s6">1</span><span class="s3">, </span><span class="s1">codes</span><span class="s3">)</span>
                        <span class="s1">codes </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">where</span><span class="s3">(</span><span class="s1">na_mask</span><span class="s3">, </span><span class="s1">na_code</span><span class="s3">, </span><span class="s1">codes</span><span class="s3">)</span>

            <span class="s2">if not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_observed</span><span class="s3">:</span>
                <span class="s1">uniques </span><span class="s3">= </span><span class="s1">uniques</span><span class="s3">.</span><span class="s1">reorder_categories</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_orig_cats</span><span class="s3">)</span>

            <span class="s2">return </span><span class="s1">codes</span><span class="s3">, </span><span class="s1">uniques</span>

        <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">grouping_vector</span><span class="s3">, </span><span class="s1">ops</span><span class="s3">.</span><span class="s1">BaseGrouper</span><span class="s3">):</span>
            <span class="s5"># we have a list of groupers</span>
            <span class="s1">codes </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">grouping_vector</span><span class="s3">.</span><span class="s1">codes_info</span>
            <span class="s1">uniques </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">grouping_vector</span><span class="s3">.</span><span class="s1">result_index</span><span class="s3">.</span><span class="s1">_values</span>
        <span class="s2">elif </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_uniques </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s5"># GH#50486 Code grouping_vector using _uniques; allows</span>
            <span class="s5"># including uniques that are not present in grouping_vector.</span>
            <span class="s1">cat </span><span class="s3">= </span><span class="s1">Categorical</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">grouping_vector</span><span class="s3">, </span><span class="s1">categories</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_uniques</span><span class="s3">)</span>
            <span class="s1">codes </span><span class="s3">= </span><span class="s1">cat</span><span class="s3">.</span><span class="s1">codes</span>
            <span class="s1">uniques </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_uniques</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s5"># GH35667, replace dropna=False with use_na_sentinel=False</span>
            <span class="s5"># error: Incompatible types in assignment (expression has type &quot;Union[</span>
            <span class="s5"># ndarray[Any, Any], Index]&quot;, variable has type &quot;Categorical&quot;)</span>
            <span class="s1">codes</span><span class="s3">, </span><span class="s1">uniques </span><span class="s3">= </span><span class="s1">algorithms</span><span class="s3">.</span><span class="s1">factorize</span><span class="s3">(  </span><span class="s5"># type: ignore[assignment]</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">grouping_vector</span><span class="s3">, </span><span class="s1">sort</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_sort</span><span class="s3">, </span><span class="s1">use_na_sentinel</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_dropna</span>
            <span class="s3">)</span>
        <span class="s2">return </span><span class="s1">codes</span><span class="s3">, </span><span class="s1">uniques</span>

    <span class="s3">@</span><span class="s1">cache_readonly</span>
    <span class="s2">def </span><span class="s1">groups</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; dict</span><span class="s3">[</span><span class="s1">Hashable</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndarray</span><span class="s3">]:</span>
        <span class="s1">cats </span><span class="s3">= </span><span class="s1">Categorical</span><span class="s3">.</span><span class="s1">from_codes</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">codes</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_group_index</span><span class="s3">, </span><span class="s1">validate</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_index</span><span class="s3">.</span><span class="s1">groupby</span><span class="s3">(</span><span class="s1">cats</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">get_grouper</span><span class="s3">(</span>
    <span class="s1">obj</span><span class="s3">: </span><span class="s1">NDFrameT</span><span class="s3">,</span>
    <span class="s1">key</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">axis</span><span class="s3">: </span><span class="s1">Axis </span><span class="s3">= </span><span class="s6">0</span><span class="s3">,</span>
    <span class="s1">level</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">sort</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">True</span><span class="s3">,</span>
    <span class="s1">observed</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span><span class="s3">,</span>
    <span class="s1">validate</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">True</span><span class="s3">,</span>
    <span class="s1">dropna</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">True</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; tuple</span><span class="s3">[</span><span class="s1">ops</span><span class="s3">.</span><span class="s1">BaseGrouper</span><span class="s3">, </span><span class="s1">frozenset</span><span class="s3">[</span><span class="s1">Hashable</span><span class="s3">], </span><span class="s1">NDFrameT</span><span class="s3">]:</span>
    <span class="s0">&quot;&quot;&quot; 
    Create and return a BaseGrouper, which is an internal 
    mapping of how to create the grouper indexers. 
    This may be composed of multiple Grouping objects, indicating 
    multiple groupers 
 
    Groupers are ultimately index mappings. They can originate as: 
    index mappings, keys to columns, functions, or Groupers 
 
    Groupers enable local references to axis,level,sort, while 
    the passed in axis, level, and sort are 'global'. 
 
    This routine tries to figure out what the passing in references 
    are and then creates a Grouping for each one, combined into 
    a BaseGrouper. 
 
    If observed &amp; we have a categorical grouper, only show the observed 
    values. 
 
    If validate, then check for key/level overlaps. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">group_axis </span><span class="s3">= </span><span class="s1">obj</span><span class="s3">.</span><span class="s1">_get_axis</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">)</span>

    <span class="s5"># validate that the passed single level is compatible with the passed</span>
    <span class="s5"># axis of the object</span>
    <span class="s2">if </span><span class="s1">level </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s5"># TODO: These if-block and else-block are almost same.</span>
        <span class="s5"># MultiIndex instance check is removable, but it seems that there are</span>
        <span class="s5"># some processes only for non-MultiIndex in else-block,</span>
        <span class="s5"># eg. `obj.index.name != level`. We have to consider carefully whether</span>
        <span class="s5"># these are applicable for MultiIndex. Even if these are applicable,</span>
        <span class="s5"># we need to check if it makes no side effect to subsequent processes</span>
        <span class="s5"># on the outside of this condition.</span>
        <span class="s5"># (GH 17621)</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">group_axis</span><span class="s3">, </span><span class="s1">MultiIndex</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">is_list_like</span><span class="s3">(</span><span class="s1">level</span><span class="s3">) </span><span class="s2">and </span><span class="s1">len</span><span class="s3">(</span><span class="s1">level</span><span class="s3">) == </span><span class="s6">1</span><span class="s3">:</span>
                <span class="s1">level </span><span class="s3">= </span><span class="s1">level</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]</span>

            <span class="s2">if </span><span class="s1">key </span><span class="s2">is None and </span><span class="s1">is_scalar</span><span class="s3">(</span><span class="s1">level</span><span class="s3">):</span>
                <span class="s5"># Get the level values from group_axis</span>
                <span class="s1">key </span><span class="s3">= </span><span class="s1">group_axis</span><span class="s3">.</span><span class="s1">get_level_values</span><span class="s3">(</span><span class="s1">level</span><span class="s3">)</span>
                <span class="s1">level </span><span class="s3">= </span><span class="s2">None</span>

        <span class="s2">else</span><span class="s3">:</span>
            <span class="s5"># allow level to be a length-one list-like object</span>
            <span class="s5"># (e.g., level=[0])</span>
            <span class="s5"># GH 13901</span>
            <span class="s2">if </span><span class="s1">is_list_like</span><span class="s3">(</span><span class="s1">level</span><span class="s3">):</span>
                <span class="s1">nlevels </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">level</span><span class="s3">)</span>
                <span class="s2">if </span><span class="s1">nlevels </span><span class="s3">== </span><span class="s6">1</span><span class="s3">:</span>
                    <span class="s1">level </span><span class="s3">= </span><span class="s1">level</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]</span>
                <span class="s2">elif </span><span class="s1">nlevels </span><span class="s3">== </span><span class="s6">0</span><span class="s3">:</span>
                    <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;No group keys passed!&quot;</span><span class="s3">)</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;multiple levels only valid with MultiIndex&quot;</span><span class="s3">)</span>

            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">level</span><span class="s3">, </span><span class="s1">str</span><span class="s3">):</span>
                <span class="s2">if </span><span class="s1">obj</span><span class="s3">.</span><span class="s1">_get_axis</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">).</span><span class="s1">name </span><span class="s3">!= </span><span class="s1">level</span><span class="s3">:</span>
                    <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span>
                        <span class="s4">f&quot;level name </span><span class="s2">{</span><span class="s1">level</span><span class="s2">} </span><span class="s4">is not the name &quot;</span>
                        <span class="s4">f&quot;of the </span><span class="s2">{</span><span class="s1">obj</span><span class="s3">.</span><span class="s1">_get_axis_name</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">)</span><span class="s2">}</span><span class="s4">&quot;</span>
                    <span class="s3">)</span>
            <span class="s2">elif </span><span class="s1">level </span><span class="s3">&gt; </span><span class="s6">0 </span><span class="s2">or </span><span class="s1">level </span><span class="s3">&lt; -</span><span class="s6">1</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;level &gt; 0 or level &lt; -1 only valid with MultiIndex&quot;</span><span class="s3">)</span>

            <span class="s5"># NOTE: `group_axis` and `group_axis.get_level_values(level)`</span>
            <span class="s5"># are same in this section.</span>
            <span class="s1">level </span><span class="s3">= </span><span class="s2">None</span>
            <span class="s1">key </span><span class="s3">= </span><span class="s1">group_axis</span>

    <span class="s5"># a passed-in Grouper, directly convert</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">key</span><span class="s3">, </span><span class="s1">Grouper</span><span class="s3">):</span>
        <span class="s1">grouper</span><span class="s3">, </span><span class="s1">obj </span><span class="s3">= </span><span class="s1">key</span><span class="s3">.</span><span class="s1">_get_grouper</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">validate</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">key</span><span class="s3">.</span><span class="s1">key </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">grouper</span><span class="s3">, </span><span class="s1">frozenset</span><span class="s3">(), </span><span class="s1">obj</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">grouper</span><span class="s3">, </span><span class="s1">frozenset</span><span class="s3">({</span><span class="s1">key</span><span class="s3">.</span><span class="s1">key</span><span class="s3">}), </span><span class="s1">obj</span>

    <span class="s5"># already have a BaseGrouper, just return it</span>
    <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">key</span><span class="s3">, </span><span class="s1">ops</span><span class="s3">.</span><span class="s1">BaseGrouper</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">key</span><span class="s3">, </span><span class="s1">frozenset</span><span class="s3">(), </span><span class="s1">obj</span>

    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">key</span><span class="s3">, </span><span class="s1">list</span><span class="s3">):</span>
        <span class="s1">keys </span><span class="s3">= [</span><span class="s1">key</span><span class="s3">]</span>
        <span class="s1">match_axis_length </span><span class="s3">= </span><span class="s2">False</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">keys </span><span class="s3">= </span><span class="s1">key</span>
        <span class="s1">match_axis_length </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">keys</span><span class="s3">) == </span><span class="s1">len</span><span class="s3">(</span><span class="s1">group_axis</span><span class="s3">)</span>

    <span class="s5"># what are we after, exactly?</span>
    <span class="s1">any_callable </span><span class="s3">= </span><span class="s1">any</span><span class="s3">(</span><span class="s1">callable</span><span class="s3">(</span><span class="s1">g</span><span class="s3">) </span><span class="s2">or </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">g</span><span class="s3">, </span><span class="s1">dict</span><span class="s3">) </span><span class="s2">for </span><span class="s1">g </span><span class="s2">in </span><span class="s1">keys</span><span class="s3">)</span>
    <span class="s1">any_groupers </span><span class="s3">= </span><span class="s1">any</span><span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">g</span><span class="s3">, (</span><span class="s1">Grouper</span><span class="s3">, </span><span class="s1">Grouping</span><span class="s3">)) </span><span class="s2">for </span><span class="s1">g </span><span class="s2">in </span><span class="s1">keys</span><span class="s3">)</span>
    <span class="s1">any_arraylike </span><span class="s3">= </span><span class="s1">any</span><span class="s3">(</span>
        <span class="s1">isinstance</span><span class="s3">(</span><span class="s1">g</span><span class="s3">, (</span><span class="s1">list</span><span class="s3">, </span><span class="s1">tuple</span><span class="s3">, </span><span class="s1">Series</span><span class="s3">, </span><span class="s1">Index</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndarray</span><span class="s3">)) </span><span class="s2">for </span><span class="s1">g </span><span class="s2">in </span><span class="s1">keys</span>
    <span class="s3">)</span>

    <span class="s5"># is this an index replacement?</span>
    <span class="s2">if </span><span class="s3">(</span>
        <span class="s2">not </span><span class="s1">any_callable</span>
        <span class="s2">and not </span><span class="s1">any_arraylike</span>
        <span class="s2">and not </span><span class="s1">any_groupers</span>
        <span class="s2">and </span><span class="s1">match_axis_length</span>
        <span class="s2">and </span><span class="s1">level </span><span class="s2">is None</span>
    <span class="s3">):</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">DataFrame</span><span class="s3">):</span>
            <span class="s1">all_in_columns_index </span><span class="s3">= </span><span class="s1">all</span><span class="s3">(</span>
                <span class="s1">g </span><span class="s2">in </span><span class="s1">obj</span><span class="s3">.</span><span class="s1">columns </span><span class="s2">or </span><span class="s1">g </span><span class="s2">in </span><span class="s1">obj</span><span class="s3">.</span><span class="s1">index</span><span class="s3">.</span><span class="s1">names </span><span class="s2">for </span><span class="s1">g </span><span class="s2">in </span><span class="s1">keys</span>
            <span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">assert </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">Series</span><span class="s3">)</span>
            <span class="s1">all_in_columns_index </span><span class="s3">= </span><span class="s1">all</span><span class="s3">(</span><span class="s1">g </span><span class="s2">in </span><span class="s1">obj</span><span class="s3">.</span><span class="s1">index</span><span class="s3">.</span><span class="s1">names </span><span class="s2">for </span><span class="s1">g </span><span class="s2">in </span><span class="s1">keys</span><span class="s3">)</span>

        <span class="s2">if not </span><span class="s1">all_in_columns_index</span><span class="s3">:</span>
            <span class="s1">keys </span><span class="s3">= [</span><span class="s1">com</span><span class="s3">.</span><span class="s1">asarray_tuplesafe</span><span class="s3">(</span><span class="s1">keys</span><span class="s3">)]</span>

    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">level</span><span class="s3">, (</span><span class="s1">tuple</span><span class="s3">, </span><span class="s1">list</span><span class="s3">)):</span>
        <span class="s2">if </span><span class="s1">key </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s1">keys </span><span class="s3">= [</span><span class="s2">None</span><span class="s3">] * </span><span class="s1">len</span><span class="s3">(</span><span class="s1">level</span><span class="s3">)</span>
        <span class="s1">levels </span><span class="s3">= </span><span class="s1">level</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">levels </span><span class="s3">= [</span><span class="s1">level</span><span class="s3">] * </span><span class="s1">len</span><span class="s3">(</span><span class="s1">keys</span><span class="s3">)</span>

    <span class="s1">groupings</span><span class="s3">: </span><span class="s1">list</span><span class="s3">[</span><span class="s1">Grouping</span><span class="s3">] = []</span>
    <span class="s1">exclusions</span><span class="s3">: </span><span class="s1">set</span><span class="s3">[</span><span class="s1">Hashable</span><span class="s3">] = </span><span class="s1">set</span><span class="s3">()</span>

    <span class="s5"># if the actual grouper should be obj[key]</span>
    <span class="s2">def </span><span class="s1">is_in_axis</span><span class="s3">(</span><span class="s1">key</span><span class="s3">) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
        <span class="s2">if not </span><span class="s1">_is_label_like</span><span class="s3">(</span><span class="s1">key</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">obj</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s6">1</span><span class="s3">:</span>
                <span class="s2">return False</span>

            <span class="s5"># items -&gt; .columns for DataFrame, .index for Series</span>
            <span class="s1">items </span><span class="s3">= </span><span class="s1">obj</span><span class="s3">.</span><span class="s1">axes</span><span class="s3">[-</span><span class="s6">1</span><span class="s3">]</span>
            <span class="s2">try</span><span class="s3">:</span>
                <span class="s1">items</span><span class="s3">.</span><span class="s1">get_loc</span><span class="s3">(</span><span class="s1">key</span><span class="s3">)</span>
            <span class="s2">except </span><span class="s3">(</span><span class="s1">KeyError</span><span class="s3">, </span><span class="s1">TypeError</span><span class="s3">, </span><span class="s1">InvalidIndexError</span><span class="s3">):</span>
                <span class="s5"># TypeError shows up here if we pass e.g. an Index</span>
                <span class="s2">return False</span>

        <span class="s2">return True</span>

    <span class="s5"># if the grouper is obj[name]</span>
    <span class="s2">def </span><span class="s1">is_in_obj</span><span class="s3">(</span><span class="s1">gpr</span><span class="s3">) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
        <span class="s2">if not </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">gpr</span><span class="s3">, </span><span class="s4">&quot;name&quot;</span><span class="s3">):</span>
            <span class="s2">return False</span>
        <span class="s2">if </span><span class="s1">using_copy_on_write</span><span class="s3">() </span><span class="s2">or </span><span class="s1">warn_copy_on_write</span><span class="s3">():</span>
            <span class="s5"># For the CoW case, we check the references to determine if the</span>
            <span class="s5"># series is part of the object</span>
            <span class="s2">try</span><span class="s3">:</span>
                <span class="s1">obj_gpr_column </span><span class="s3">= </span><span class="s1">obj</span><span class="s3">[</span><span class="s1">gpr</span><span class="s3">.</span><span class="s1">name</span><span class="s3">]</span>
            <span class="s2">except </span><span class="s3">(</span><span class="s1">KeyError</span><span class="s3">, </span><span class="s1">IndexError</span><span class="s3">, </span><span class="s1">InvalidIndexError</span><span class="s3">, </span><span class="s1">OutOfBoundsDatetime</span><span class="s3">):</span>
                <span class="s2">return False</span>
            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">gpr</span><span class="s3">, </span><span class="s1">Series</span><span class="s3">) </span><span class="s2">and </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">obj_gpr_column</span><span class="s3">, </span><span class="s1">Series</span><span class="s3">):</span>
                <span class="s2">return </span><span class="s1">gpr</span><span class="s3">.</span><span class="s1">_mgr</span><span class="s3">.</span><span class="s1">references_same_values</span><span class="s3">(  </span><span class="s5"># type: ignore[union-attr]</span>
                    <span class="s1">obj_gpr_column</span><span class="s3">.</span><span class="s1">_mgr</span><span class="s3">, </span><span class="s6">0  </span><span class="s5"># type: ignore[arg-type]</span>
                <span class="s3">)</span>
            <span class="s2">return False</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">gpr </span><span class="s2">is </span><span class="s1">obj</span><span class="s3">[</span><span class="s1">gpr</span><span class="s3">.</span><span class="s1">name</span><span class="s3">]</span>
        <span class="s2">except </span><span class="s3">(</span><span class="s1">KeyError</span><span class="s3">, </span><span class="s1">IndexError</span><span class="s3">, </span><span class="s1">InvalidIndexError</span><span class="s3">, </span><span class="s1">OutOfBoundsDatetime</span><span class="s3">):</span>
            <span class="s5"># IndexError reached in e.g. test_skip_group_keys when we pass</span>
            <span class="s5">#  lambda here</span>
            <span class="s5"># InvalidIndexError raised on key-types inappropriate for index,</span>
            <span class="s5">#  e.g. DatetimeIndex.get_loc(tuple())</span>
            <span class="s5"># OutOfBoundsDatetime raised when obj is a Series with DatetimeIndex</span>
            <span class="s5"># and gpr.name is month str</span>
            <span class="s2">return False</span>

    <span class="s2">for </span><span class="s1">gpr</span><span class="s3">, </span><span class="s1">level </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">keys</span><span class="s3">, </span><span class="s1">levels</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">is_in_obj</span><span class="s3">(</span><span class="s1">gpr</span><span class="s3">):  </span><span class="s5"># df.groupby(df['name'])</span>
            <span class="s1">in_axis </span><span class="s3">= </span><span class="s2">True</span>
            <span class="s1">exclusions</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">gpr</span><span class="s3">.</span><span class="s1">name</span><span class="s3">)</span>

        <span class="s2">elif </span><span class="s1">is_in_axis</span><span class="s3">(</span><span class="s1">gpr</span><span class="s3">):  </span><span class="s5"># df.groupby('name')</span>
            <span class="s2">if </span><span class="s1">obj</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">!= </span><span class="s6">1 </span><span class="s2">and </span><span class="s1">gpr </span><span class="s2">in </span><span class="s1">obj</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">validate</span><span class="s3">:</span>
                    <span class="s1">obj</span><span class="s3">.</span><span class="s1">_check_label_or_level_ambiguity</span><span class="s3">(</span><span class="s1">gpr</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">)</span>
                <span class="s1">in_axis</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">gpr </span><span class="s3">= </span><span class="s2">True</span><span class="s3">, </span><span class="s1">gpr</span><span class="s3">, </span><span class="s1">obj</span><span class="s3">[</span><span class="s1">gpr</span><span class="s3">]</span>
                <span class="s2">if </span><span class="s1">gpr</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">!= </span><span class="s6">1</span><span class="s3">:</span>
                    <span class="s5"># non-unique columns; raise here to get the name in the</span>
                    <span class="s5"># exception message</span>
                    <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">f&quot;Grouper for '</span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s4">' not 1-dimensional&quot;</span><span class="s3">)</span>
                <span class="s1">exclusions</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">name</span><span class="s3">)</span>
            <span class="s2">elif </span><span class="s1">obj</span><span class="s3">.</span><span class="s1">_is_level_reference</span><span class="s3">(</span><span class="s1">gpr</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">):</span>
                <span class="s1">in_axis</span><span class="s3">, </span><span class="s1">level</span><span class="s3">, </span><span class="s1">gpr </span><span class="s3">= </span><span class="s2">False</span><span class="s3">, </span><span class="s1">gpr</span><span class="s3">, </span><span class="s2">None</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">KeyError</span><span class="s3">(</span><span class="s1">gpr</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">gpr</span><span class="s3">, </span><span class="s1">Grouper</span><span class="s3">) </span><span class="s2">and </span><span class="s1">gpr</span><span class="s3">.</span><span class="s1">key </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s5"># Add key to exclusions</span>
            <span class="s1">exclusions</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">gpr</span><span class="s3">.</span><span class="s1">key</span><span class="s3">)</span>
            <span class="s1">in_axis </span><span class="s3">= </span><span class="s2">True</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">in_axis </span><span class="s3">= </span><span class="s2">False</span>

        <span class="s5"># create the Grouping</span>
        <span class="s5"># allow us to passing the actual Grouping as the gpr</span>
        <span class="s1">ping </span><span class="s3">= (</span>
            <span class="s1">Grouping</span><span class="s3">(</span>
                <span class="s1">group_axis</span><span class="s3">,</span>
                <span class="s1">gpr</span><span class="s3">,</span>
                <span class="s1">obj</span><span class="s3">=</span><span class="s1">obj</span><span class="s3">,</span>
                <span class="s1">level</span><span class="s3">=</span><span class="s1">level</span><span class="s3">,</span>
                <span class="s1">sort</span><span class="s3">=</span><span class="s1">sort</span><span class="s3">,</span>
                <span class="s1">observed</span><span class="s3">=</span><span class="s1">observed</span><span class="s3">,</span>
                <span class="s1">in_axis</span><span class="s3">=</span><span class="s1">in_axis</span><span class="s3">,</span>
                <span class="s1">dropna</span><span class="s3">=</span><span class="s1">dropna</span><span class="s3">,</span>
            <span class="s3">)</span>
            <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">gpr</span><span class="s3">, </span><span class="s1">Grouping</span><span class="s3">)</span>
            <span class="s2">else </span><span class="s1">gpr</span>
        <span class="s3">)</span>

        <span class="s1">groupings</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">ping</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">groupings</span><span class="s3">) == </span><span class="s6">0 </span><span class="s2">and </span><span class="s1">len</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;No group keys passed!&quot;</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">groupings</span><span class="s3">) == </span><span class="s6">0</span><span class="s3">:</span>
        <span class="s1">groupings</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">Grouping</span><span class="s3">(</span><span class="s1">Index</span><span class="s3">([], </span><span class="s1">dtype</span><span class="s3">=</span><span class="s4">&quot;int&quot;</span><span class="s3">), </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([], </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">)))</span>

    <span class="s5"># create the internals grouper</span>
    <span class="s1">grouper </span><span class="s3">= </span><span class="s1">ops</span><span class="s3">.</span><span class="s1">BaseGrouper</span><span class="s3">(</span><span class="s1">group_axis</span><span class="s3">, </span><span class="s1">groupings</span><span class="s3">, </span><span class="s1">sort</span><span class="s3">=</span><span class="s1">sort</span><span class="s3">, </span><span class="s1">dropna</span><span class="s3">=</span><span class="s1">dropna</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">grouper</span><span class="s3">, </span><span class="s1">frozenset</span><span class="s3">(</span><span class="s1">exclusions</span><span class="s3">), </span><span class="s1">obj</span>


<span class="s2">def </span><span class="s1">_is_label_like</span><span class="s3">(</span><span class="s1">val</span><span class="s3">) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
    <span class="s2">return </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">val</span><span class="s3">, (</span><span class="s1">str</span><span class="s3">, </span><span class="s1">tuple</span><span class="s3">)) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">val </span><span class="s2">is not None and </span><span class="s1">is_scalar</span><span class="s3">(</span><span class="s1">val</span><span class="s3">))</span>


<span class="s2">def </span><span class="s1">_convert_grouper</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">: </span><span class="s1">Index</span><span class="s3">, </span><span class="s1">grouper</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">grouper</span><span class="s3">, </span><span class="s1">dict</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">grouper</span><span class="s3">.</span><span class="s1">get</span>
    <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">grouper</span><span class="s3">, </span><span class="s1">Series</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">grouper</span><span class="s3">.</span><span class="s1">index</span><span class="s3">.</span><span class="s1">equals</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">grouper</span><span class="s3">.</span><span class="s1">_values</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">grouper</span><span class="s3">.</span><span class="s1">reindex</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">).</span><span class="s1">_values</span>
    <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">grouper</span><span class="s3">, </span><span class="s1">MultiIndex</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">grouper</span><span class="s3">.</span><span class="s1">_values</span>
    <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">grouper</span><span class="s3">, (</span><span class="s1">list</span><span class="s3">, </span><span class="s1">tuple</span><span class="s3">, </span><span class="s1">Index</span><span class="s3">, </span><span class="s1">Categorical</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndarray</span><span class="s3">)):</span>
        <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">grouper</span><span class="s3">) != </span><span class="s1">len</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Grouper and axis must be same length&quot;</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">grouper</span><span class="s3">, (</span><span class="s1">list</span><span class="s3">, </span><span class="s1">tuple</span><span class="s3">)):</span>
            <span class="s1">grouper </span><span class="s3">= </span><span class="s1">com</span><span class="s3">.</span><span class="s1">asarray_tuplesafe</span><span class="s3">(</span><span class="s1">grouper</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">grouper</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">grouper</span>
</pre>
</body>
</html>