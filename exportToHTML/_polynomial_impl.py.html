<html>
<head>
<title>_polynomial_impl.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #6aab73;}
.s4 { color: #cf8e6d;}
.s5 { color: #2aacb8;}
.s6 { color: #7a7e85;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_polynomial_impl.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Functions to operate on polynomials. 
 
&quot;&quot;&quot;</span>
<span class="s1">__all__ </span><span class="s2">= [</span><span class="s3">'poly'</span><span class="s2">, </span><span class="s3">'roots'</span><span class="s2">, </span><span class="s3">'polyint'</span><span class="s2">, </span><span class="s3">'polyder'</span><span class="s2">, </span><span class="s3">'polyadd'</span><span class="s2">,</span>
           <span class="s3">'polysub'</span><span class="s2">, </span><span class="s3">'polymul'</span><span class="s2">, </span><span class="s3">'polydiv'</span><span class="s2">, </span><span class="s3">'polyval'</span><span class="s2">, </span><span class="s3">'poly1d'</span><span class="s2">,</span>
           <span class="s3">'polyfit'</span><span class="s2">]</span>

<span class="s4">import </span><span class="s1">functools</span>
<span class="s4">import </span><span class="s1">re</span>
<span class="s4">import </span><span class="s1">warnings</span>

<span class="s4">from </span><span class="s2">..</span><span class="s1">_utils </span><span class="s4">import </span><span class="s1">set_module</span>
<span class="s4">import </span><span class="s1">numpy</span><span class="s2">.</span><span class="s1">_core</span><span class="s2">.</span><span class="s1">numeric </span><span class="s4">as </span><span class="s1">NX</span>

<span class="s4">from </span><span class="s1">numpy</span><span class="s2">.</span><span class="s1">_core </span><span class="s4">import </span><span class="s2">(</span><span class="s1">isscalar</span><span class="s2">, </span><span class="s1">abs</span><span class="s2">, </span><span class="s1">finfo</span><span class="s2">, </span><span class="s1">atleast_1d</span><span class="s2">, </span><span class="s1">hstack</span><span class="s2">, </span><span class="s1">dot</span><span class="s2">, </span><span class="s1">array</span><span class="s2">,</span>
                        <span class="s1">ones</span><span class="s2">)</span>
<span class="s4">from </span><span class="s1">numpy</span><span class="s2">.</span><span class="s1">_core </span><span class="s4">import </span><span class="s1">overrides</span>
<span class="s4">from </span><span class="s1">numpy</span><span class="s2">.</span><span class="s1">exceptions </span><span class="s4">import </span><span class="s1">RankWarning</span>
<span class="s4">from </span><span class="s1">numpy</span><span class="s2">.</span><span class="s1">lib</span><span class="s2">.</span><span class="s1">_twodim_base_impl </span><span class="s4">import </span><span class="s1">diag</span><span class="s2">, </span><span class="s1">vander</span>
<span class="s4">from </span><span class="s1">numpy</span><span class="s2">.</span><span class="s1">lib</span><span class="s2">.</span><span class="s1">_function_base_impl </span><span class="s4">import </span><span class="s1">trim_zeros</span>
<span class="s4">from </span><span class="s1">numpy</span><span class="s2">.</span><span class="s1">lib</span><span class="s2">.</span><span class="s1">_type_check_impl </span><span class="s4">import </span><span class="s1">iscomplex</span><span class="s2">, </span><span class="s1">real</span><span class="s2">, </span><span class="s1">imag</span><span class="s2">, </span><span class="s1">mintypecode</span>
<span class="s4">from </span><span class="s1">numpy</span><span class="s2">.</span><span class="s1">linalg </span><span class="s4">import </span><span class="s1">eigvals</span><span class="s2">, </span><span class="s1">lstsq</span><span class="s2">, </span><span class="s1">inv</span>


<span class="s1">array_function_dispatch </span><span class="s2">= </span><span class="s1">functools</span><span class="s2">.</span><span class="s1">partial</span><span class="s2">(</span>
    <span class="s1">overrides</span><span class="s2">.</span><span class="s1">array_function_dispatch</span><span class="s2">, </span><span class="s1">module</span><span class="s2">=</span><span class="s3">'numpy'</span><span class="s2">)</span>


<span class="s4">def </span><span class="s1">_poly_dispatcher</span><span class="s2">(</span><span class="s1">seq_of_zeros</span><span class="s2">):</span>
    <span class="s4">return </span><span class="s1">seq_of_zeros</span>


<span class="s2">@</span><span class="s1">array_function_dispatch</span><span class="s2">(</span><span class="s1">_poly_dispatcher</span><span class="s2">)</span>
<span class="s4">def </span><span class="s1">poly</span><span class="s2">(</span><span class="s1">seq_of_zeros</span><span class="s2">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Find the coefficients of a polynomial with the given sequence of roots. 
 
    .. note:: 
       This forms part of the old polynomial API. Since version 1.4, the 
       new polynomial API defined in `numpy.polynomial` is preferred. 
       A summary of the differences can be found in the 
       :doc:`transition guide &lt;/reference/routines.polynomials&gt;`. 
 
    Returns the coefficients of the polynomial whose leading coefficient 
    is one for the given sequence of zeros (multiple roots must be included 
    in the sequence as many times as their multiplicity; see Examples). 
    A square matrix (or array, which will be treated as a matrix) can also 
    be given, in which case the coefficients of the characteristic polynomial 
    of the matrix are returned. 
 
    Parameters 
    ---------- 
    seq_of_zeros : array_like, shape (N,) or (N, N) 
        A sequence of polynomial roots, or a square array or matrix object. 
 
    Returns 
    ------- 
    c : ndarray 
        1D array of polynomial coefficients from highest to lowest degree: 
 
        ``c[0] * x**(N) + c[1] * x**(N-1) + ... + c[N-1] * x + c[N]`` 
        where c[0] always equals 1. 
 
    Raises 
    ------ 
    ValueError 
        If input is the wrong shape (the input must be a 1-D or square 
        2-D array). 
 
    See Also 
    -------- 
    polyval : Compute polynomial values. 
    roots : Return the roots of a polynomial. 
    polyfit : Least squares polynomial fit. 
    poly1d : A one-dimensional polynomial class. 
 
    Notes 
    ----- 
    Specifying the roots of a polynomial still leaves one degree of 
    freedom, typically represented by an undetermined leading 
    coefficient. [1]_ In the case of this function, that coefficient - 
    the first one in the returned array - is always taken as one. (If 
    for some reason you have one other point, the only automatic way 
    presently to leverage that information is to use ``polyfit``.) 
 
    The characteristic polynomial, :math:`p_a(t)`, of an `n`-by-`n` 
    matrix **A** is given by 
 
    :math:`p_a(t) = \\mathrm{det}(t\\, \\mathbf{I} - \\mathbf{A})`, 
 
    where **I** is the `n`-by-`n` identity matrix. [2]_ 
 
    References 
    ---------- 
    .. [1] M. Sullivan and M. Sullivan, III, &quot;Algebra and Trigonometry, 
       Enhanced With Graphing Utilities,&quot; Prentice-Hall, pg. 318, 1996. 
 
    .. [2] G. Strang, &quot;Linear Algebra and Its Applications, 2nd Edition,&quot; 
       Academic Press, pg. 182, 1980. 
 
    Examples 
    -------- 
    Given a sequence of a polynomial's zeros: 
 
    &gt;&gt;&gt; import numpy as np 
 
    &gt;&gt;&gt; np.poly((0, 0, 0)) # Multiple root example 
    array([1., 0., 0., 0.]) 
 
    The line above represents z**3 + 0*z**2 + 0*z + 0. 
 
    &gt;&gt;&gt; np.poly((-1./2, 0, 1./2)) 
    array([ 1.  ,  0.  , -0.25,  0.  ]) 
 
    The line above represents z**3 - z/4 
 
    &gt;&gt;&gt; np.poly((np.random.random(1)[0], 0, np.random.random(1)[0])) 
    array([ 1.        , -0.77086955,  0.08618131,  0.        ]) # random 
 
    Given a square array object: 
 
    &gt;&gt;&gt; P = np.array([[0, 1./3], [-1./2, 0]]) 
    &gt;&gt;&gt; np.poly(P) 
    array([1.        , 0.        , 0.16666667]) 
 
    Note how in all cases the leading coefficient is always 1. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">seq_of_zeros </span><span class="s2">= </span><span class="s1">atleast_1d</span><span class="s2">(</span><span class="s1">seq_of_zeros</span><span class="s2">)</span>
    <span class="s1">sh </span><span class="s2">= </span><span class="s1">seq_of_zeros</span><span class="s2">.</span><span class="s1">shape</span>

    <span class="s4">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">sh</span><span class="s2">) == </span><span class="s5">2 </span><span class="s4">and </span><span class="s1">sh</span><span class="s2">[</span><span class="s5">0</span><span class="s2">] == </span><span class="s1">sh</span><span class="s2">[</span><span class="s5">1</span><span class="s2">] </span><span class="s4">and </span><span class="s1">sh</span><span class="s2">[</span><span class="s5">0</span><span class="s2">] != </span><span class="s5">0</span><span class="s2">:</span>
        <span class="s1">seq_of_zeros </span><span class="s2">= </span><span class="s1">eigvals</span><span class="s2">(</span><span class="s1">seq_of_zeros</span><span class="s2">)</span>
    <span class="s4">elif </span><span class="s1">len</span><span class="s2">(</span><span class="s1">sh</span><span class="s2">) == </span><span class="s5">1</span><span class="s2">:</span>
        <span class="s1">dt </span><span class="s2">= </span><span class="s1">seq_of_zeros</span><span class="s2">.</span><span class="s1">dtype</span>
        <span class="s6"># Let object arrays slip through, e.g. for arbitrary precision</span>
        <span class="s4">if </span><span class="s1">dt </span><span class="s2">!= </span><span class="s1">object</span><span class="s2">:</span>
            <span class="s1">seq_of_zeros </span><span class="s2">= </span><span class="s1">seq_of_zeros</span><span class="s2">.</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">mintypecode</span><span class="s2">(</span><span class="s1">dt</span><span class="s2">.</span><span class="s1">char</span><span class="s2">))</span>
    <span class="s4">else</span><span class="s2">:</span>
        <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;input must be 1d or non-empty square 2d array.&quot;</span><span class="s2">)</span>

    <span class="s4">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">seq_of_zeros</span><span class="s2">) == </span><span class="s5">0</span><span class="s2">:</span>
        <span class="s4">return </span><span class="s5">1.0</span>
    <span class="s1">dt </span><span class="s2">= </span><span class="s1">seq_of_zeros</span><span class="s2">.</span><span class="s1">dtype</span>
    <span class="s1">a </span><span class="s2">= </span><span class="s1">ones</span><span class="s2">((</span><span class="s5">1</span><span class="s2">,), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dt</span><span class="s2">)</span>
    <span class="s4">for </span><span class="s1">zero </span><span class="s4">in </span><span class="s1">seq_of_zeros</span><span class="s2">:</span>
        <span class="s1">a </span><span class="s2">= </span><span class="s1">NX</span><span class="s2">.</span><span class="s1">convolve</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">array</span><span class="s2">([</span><span class="s5">1</span><span class="s2">, -</span><span class="s1">zero</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dt</span><span class="s2">), </span><span class="s1">mode</span><span class="s2">=</span><span class="s3">'full'</span><span class="s2">)</span>

    <span class="s4">if </span><span class="s1">issubclass</span><span class="s2">(</span><span class="s1">a</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">type</span><span class="s2">, </span><span class="s1">NX</span><span class="s2">.</span><span class="s1">complexfloating</span><span class="s2">):</span>
        <span class="s6"># if complex roots are all complex conjugates, the roots are real.</span>
        <span class="s1">roots </span><span class="s2">= </span><span class="s1">NX</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">seq_of_zeros</span><span class="s2">, </span><span class="s1">complex</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">NX</span><span class="s2">.</span><span class="s1">all</span><span class="s2">(</span><span class="s1">NX</span><span class="s2">.</span><span class="s1">sort</span><span class="s2">(</span><span class="s1">roots</span><span class="s2">) == </span><span class="s1">NX</span><span class="s2">.</span><span class="s1">sort</span><span class="s2">(</span><span class="s1">roots</span><span class="s2">.</span><span class="s1">conjugate</span><span class="s2">())):</span>
            <span class="s1">a </span><span class="s2">= </span><span class="s1">a</span><span class="s2">.</span><span class="s1">real</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>

    <span class="s4">return </span><span class="s1">a</span>


<span class="s4">def </span><span class="s1">_roots_dispatcher</span><span class="s2">(</span><span class="s1">p</span><span class="s2">):</span>
    <span class="s4">return </span><span class="s1">p</span>


<span class="s2">@</span><span class="s1">array_function_dispatch</span><span class="s2">(</span><span class="s1">_roots_dispatcher</span><span class="s2">)</span>
<span class="s4">def </span><span class="s1">roots</span><span class="s2">(</span><span class="s1">p</span><span class="s2">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return the roots of a polynomial with coefficients given in p. 
 
    .. note:: 
       This forms part of the old polynomial API. Since version 1.4, the 
       new polynomial API defined in `numpy.polynomial` is preferred. 
       A summary of the differences can be found in the 
       :doc:`transition guide &lt;/reference/routines.polynomials&gt;`. 
 
    The values in the rank-1 array `p` are coefficients of a polynomial. 
    If the length of `p` is n+1 then the polynomial is described by:: 
 
      p[0] * x**n + p[1] * x**(n-1) + ... + p[n-1]*x + p[n] 
 
    Parameters 
    ---------- 
    p : array_like 
        Rank-1 array of polynomial coefficients. 
 
    Returns 
    ------- 
    out : ndarray 
        An array containing the roots of the polynomial. 
 
    Raises 
    ------ 
    ValueError 
        When `p` cannot be converted to a rank-1 array. 
 
    See also 
    -------- 
    poly : Find the coefficients of a polynomial with a given sequence 
           of roots. 
    polyval : Compute polynomial values. 
    polyfit : Least squares polynomial fit. 
    poly1d : A one-dimensional polynomial class. 
 
    Notes 
    ----- 
    The algorithm relies on computing the eigenvalues of the 
    companion matrix [1]_. 
 
    References 
    ---------- 
    .. [1] R. A. Horn &amp; C. R. Johnson, *Matrix Analysis*.  Cambridge, UK: 
        Cambridge University Press, 1999, pp. 146-7. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; coeff = [3.2, 2, 1] 
    &gt;&gt;&gt; np.roots(coeff) 
    array([-0.3125+0.46351241j, -0.3125-0.46351241j]) 
 
    &quot;&quot;&quot;</span>
    <span class="s6"># If input is scalar, this makes it an array</span>
    <span class="s1">p </span><span class="s2">= </span><span class="s1">atleast_1d</span><span class="s2">(</span><span class="s1">p</span><span class="s2">)</span>
    <span class="s4">if </span><span class="s1">p</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">!= </span><span class="s5">1</span><span class="s2">:</span>
        <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;Input must be a rank-1 array.&quot;</span><span class="s2">)</span>

    <span class="s6"># find non-zero array entries</span>
    <span class="s1">non_zero </span><span class="s2">= </span><span class="s1">NX</span><span class="s2">.</span><span class="s1">nonzero</span><span class="s2">(</span><span class="s1">NX</span><span class="s2">.</span><span class="s1">ravel</span><span class="s2">(</span><span class="s1">p</span><span class="s2">))[</span><span class="s5">0</span><span class="s2">]</span>

    <span class="s6"># Return an empty array if polynomial is all zeros</span>
    <span class="s4">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">non_zero</span><span class="s2">) == </span><span class="s5">0</span><span class="s2">:</span>
        <span class="s4">return </span><span class="s1">NX</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([])</span>

    <span class="s6"># find the number of trailing zeros -- this is the number of roots at 0.</span>
    <span class="s1">trailing_zeros </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">p</span><span class="s2">) - </span><span class="s1">non_zero</span><span class="s2">[-</span><span class="s5">1</span><span class="s2">] - </span><span class="s5">1</span>

    <span class="s6"># strip leading and trailing zeros</span>
    <span class="s1">p </span><span class="s2">= </span><span class="s1">p</span><span class="s2">[</span><span class="s1">int</span><span class="s2">(</span><span class="s1">non_zero</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]):</span><span class="s1">int</span><span class="s2">(</span><span class="s1">non_zero</span><span class="s2">[-</span><span class="s5">1</span><span class="s2">])+</span><span class="s5">1</span><span class="s2">]</span>

    <span class="s6"># casting: if incoming array isn't floating point, make it floating point.</span>
    <span class="s4">if not </span><span class="s1">issubclass</span><span class="s2">(</span><span class="s1">p</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">type</span><span class="s2">, (</span><span class="s1">NX</span><span class="s2">.</span><span class="s1">floating</span><span class="s2">, </span><span class="s1">NX</span><span class="s2">.</span><span class="s1">complexfloating</span><span class="s2">)):</span>
        <span class="s1">p </span><span class="s2">= </span><span class="s1">p</span><span class="s2">.</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">float</span><span class="s2">)</span>

    <span class="s1">N </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">p</span><span class="s2">)</span>
    <span class="s4">if </span><span class="s1">N </span><span class="s2">&gt; </span><span class="s5">1</span><span class="s2">:</span>
        <span class="s6"># build companion matrix and find its eigenvalues (the roots)</span>
        <span class="s1">A </span><span class="s2">= </span><span class="s1">diag</span><span class="s2">(</span><span class="s1">NX</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">((</span><span class="s1">N</span><span class="s2">-</span><span class="s5">2</span><span class="s2">,), </span><span class="s1">p</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">), -</span><span class="s5">1</span><span class="s2">)</span>
        <span class="s1">A</span><span class="s2">[</span><span class="s5">0</span><span class="s2">,:] = -</span><span class="s1">p</span><span class="s2">[</span><span class="s5">1</span><span class="s2">:] / </span><span class="s1">p</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]</span>
        <span class="s1">roots </span><span class="s2">= </span><span class="s1">eigvals</span><span class="s2">(</span><span class="s1">A</span><span class="s2">)</span>
    <span class="s4">else</span><span class="s2">:</span>
        <span class="s1">roots </span><span class="s2">= </span><span class="s1">NX</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([])</span>

    <span class="s6"># tack any zeros onto the back of the array</span>
    <span class="s1">roots </span><span class="s2">= </span><span class="s1">hstack</span><span class="s2">((</span><span class="s1">roots</span><span class="s2">, </span><span class="s1">NX</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">(</span><span class="s1">trailing_zeros</span><span class="s2">, </span><span class="s1">roots</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)))</span>
    <span class="s4">return </span><span class="s1">roots</span>


<span class="s4">def </span><span class="s1">_polyint_dispatcher</span><span class="s2">(</span><span class="s1">p</span><span class="s2">, </span><span class="s1">m</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">k</span><span class="s2">=</span><span class="s4">None</span><span class="s2">):</span>
    <span class="s4">return </span><span class="s2">(</span><span class="s1">p</span><span class="s2">,)</span>


<span class="s2">@</span><span class="s1">array_function_dispatch</span><span class="s2">(</span><span class="s1">_polyint_dispatcher</span><span class="s2">)</span>
<span class="s4">def </span><span class="s1">polyint</span><span class="s2">(</span><span class="s1">p</span><span class="s2">, </span><span class="s1">m</span><span class="s2">=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">k</span><span class="s2">=</span><span class="s4">None</span><span class="s2">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return an antiderivative (indefinite integral) of a polynomial. 
 
    .. note:: 
       This forms part of the old polynomial API. Since version 1.4, the 
       new polynomial API defined in `numpy.polynomial` is preferred. 
       A summary of the differences can be found in the 
       :doc:`transition guide &lt;/reference/routines.polynomials&gt;`. 
 
    The returned order `m` antiderivative `P` of polynomial `p` satisfies 
    :math:`\\frac{d^m}{dx^m}P(x) = p(x)` and is defined up to `m - 1` 
    integration constants `k`. The constants determine the low-order 
    polynomial part 
 
    .. math:: \\frac{k_{m-1}}{0!} x^0 + \\ldots + \\frac{k_0}{(m-1)!}x^{m-1} 
 
    of `P` so that :math:`P^{(j)}(0) = k_{m-j-1}`. 
 
    Parameters 
    ---------- 
    p : array_like or poly1d 
        Polynomial to integrate. 
        A sequence is interpreted as polynomial coefficients, see `poly1d`. 
    m : int, optional 
        Order of the antiderivative. (Default: 1) 
    k : list of `m` scalars or scalar, optional 
        Integration constants. They are given in the order of integration: 
        those corresponding to highest-order terms come first. 
 
        If ``None`` (default), all constants are assumed to be zero. 
        If `m = 1`, a single scalar can be given instead of a list. 
 
    See Also 
    -------- 
    polyder : derivative of a polynomial 
    poly1d.integ : equivalent method 
 
    Examples 
    -------- 
    The defining property of the antiderivative: 
 
    &gt;&gt;&gt; import numpy as np 
 
    &gt;&gt;&gt; p = np.poly1d([1,1,1]) 
    &gt;&gt;&gt; P = np.polyint(p) 
    &gt;&gt;&gt; P 
     poly1d([ 0.33333333,  0.5       ,  1.        ,  0.        ]) # may vary 
    &gt;&gt;&gt; np.polyder(P) == p 
    True 
 
    The integration constants default to zero, but can be specified: 
 
    &gt;&gt;&gt; P = np.polyint(p, 3) 
    &gt;&gt;&gt; P(0) 
    0.0 
    &gt;&gt;&gt; np.polyder(P)(0) 
    0.0 
    &gt;&gt;&gt; np.polyder(P, 2)(0) 
    0.0 
    &gt;&gt;&gt; P = np.polyint(p, 3, k=[6,5,3]) 
    &gt;&gt;&gt; P 
    poly1d([ 0.01666667,  0.04166667,  0.16666667,  3. ,  5. ,  3. ]) # may vary 
 
    Note that 3 = 6 / 2!, and that the constants are given in the order of 
    integrations. Constant of the highest-order polynomial term comes first: 
 
    &gt;&gt;&gt; np.polyder(P, 2)(0) 
    6.0 
    &gt;&gt;&gt; np.polyder(P, 1)(0) 
    5.0 
    &gt;&gt;&gt; P(0) 
    3.0 
 
    &quot;&quot;&quot;</span>
    <span class="s1">m </span><span class="s2">= </span><span class="s1">int</span><span class="s2">(</span><span class="s1">m</span><span class="s2">)</span>
    <span class="s4">if </span><span class="s1">m </span><span class="s2">&lt; </span><span class="s5">0</span><span class="s2">:</span>
        <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;Order of integral must be positive (see polyder)&quot;</span><span class="s2">)</span>
    <span class="s4">if </span><span class="s1">k </span><span class="s4">is None</span><span class="s2">:</span>
        <span class="s1">k </span><span class="s2">= </span><span class="s1">NX</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">(</span><span class="s1">m</span><span class="s2">, </span><span class="s1">float</span><span class="s2">)</span>
    <span class="s1">k </span><span class="s2">= </span><span class="s1">atleast_1d</span><span class="s2">(</span><span class="s1">k</span><span class="s2">)</span>
    <span class="s4">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">k</span><span class="s2">) == </span><span class="s5">1 </span><span class="s4">and </span><span class="s1">m </span><span class="s2">&gt; </span><span class="s5">1</span><span class="s2">:</span>
        <span class="s1">k </span><span class="s2">= </span><span class="s1">k</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]*</span><span class="s1">NX</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">(</span><span class="s1">m</span><span class="s2">, </span><span class="s1">float</span><span class="s2">)</span>
    <span class="s4">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">k</span><span class="s2">) &lt; </span><span class="s1">m</span><span class="s2">:</span>
        <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
              <span class="s3">&quot;k must be a scalar or a rank-1 array of length 1 or &gt;m.&quot;</span><span class="s2">)</span>

    <span class="s1">truepoly </span><span class="s2">= </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">p</span><span class="s2">, </span><span class="s1">poly1d</span><span class="s2">)</span>
    <span class="s1">p </span><span class="s2">= </span><span class="s1">NX</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">p</span><span class="s2">)</span>
    <span class="s4">if </span><span class="s1">m </span><span class="s2">== </span><span class="s5">0</span><span class="s2">:</span>
        <span class="s4">if </span><span class="s1">truepoly</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s1">poly1d</span><span class="s2">(</span><span class="s1">p</span><span class="s2">)</span>
        <span class="s4">return </span><span class="s1">p</span>
    <span class="s4">else</span><span class="s2">:</span>
        <span class="s6"># Note: this must work also with object and integer arrays</span>
        <span class="s1">y </span><span class="s2">= </span><span class="s1">NX</span><span class="s2">.</span><span class="s1">concatenate</span><span class="s2">((</span><span class="s1">p</span><span class="s2">.</span><span class="s1">__truediv__</span><span class="s2">(</span><span class="s1">NX</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">p</span><span class="s2">), </span><span class="s5">0</span><span class="s2">, -</span><span class="s5">1</span><span class="s2">)), [</span><span class="s1">k</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]]))</span>
        <span class="s1">val </span><span class="s2">= </span><span class="s1">polyint</span><span class="s2">(</span><span class="s1">y</span><span class="s2">, </span><span class="s1">m </span><span class="s2">- </span><span class="s5">1</span><span class="s2">, </span><span class="s1">k</span><span class="s2">=</span><span class="s1">k</span><span class="s2">[</span><span class="s5">1</span><span class="s2">:])</span>
        <span class="s4">if </span><span class="s1">truepoly</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s1">poly1d</span><span class="s2">(</span><span class="s1">val</span><span class="s2">)</span>
        <span class="s4">return </span><span class="s1">val</span>


<span class="s4">def </span><span class="s1">_polyder_dispatcher</span><span class="s2">(</span><span class="s1">p</span><span class="s2">, </span><span class="s1">m</span><span class="s2">=</span><span class="s4">None</span><span class="s2">):</span>
    <span class="s4">return </span><span class="s2">(</span><span class="s1">p</span><span class="s2">,)</span>


<span class="s2">@</span><span class="s1">array_function_dispatch</span><span class="s2">(</span><span class="s1">_polyder_dispatcher</span><span class="s2">)</span>
<span class="s4">def </span><span class="s1">polyder</span><span class="s2">(</span><span class="s1">p</span><span class="s2">, </span><span class="s1">m</span><span class="s2">=</span><span class="s5">1</span><span class="s2">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return the derivative of the specified order of a polynomial. 
 
    .. note:: 
       This forms part of the old polynomial API. Since version 1.4, the 
       new polynomial API defined in `numpy.polynomial` is preferred. 
       A summary of the differences can be found in the 
       :doc:`transition guide &lt;/reference/routines.polynomials&gt;`. 
 
    Parameters 
    ---------- 
    p : poly1d or sequence 
        Polynomial to differentiate. 
        A sequence is interpreted as polynomial coefficients, see `poly1d`. 
    m : int, optional 
        Order of differentiation (default: 1) 
 
    Returns 
    ------- 
    der : poly1d 
        A new polynomial representing the derivative. 
 
    See Also 
    -------- 
    polyint : Anti-derivative of a polynomial. 
    poly1d : Class for one-dimensional polynomials. 
 
    Examples 
    -------- 
    The derivative of the polynomial :math:`x^3 + x^2 + x^1 + 1` is: 
 
    &gt;&gt;&gt; import numpy as np 
 
    &gt;&gt;&gt; p = np.poly1d([1,1,1,1]) 
    &gt;&gt;&gt; p2 = np.polyder(p) 
    &gt;&gt;&gt; p2 
    poly1d([3, 2, 1]) 
 
    which evaluates to: 
 
    &gt;&gt;&gt; p2(2.) 
    17.0 
 
    We can verify this, approximating the derivative with 
    ``(f(x + h) - f(x))/h``: 
 
    &gt;&gt;&gt; (p(2. + 0.001) - p(2.)) / 0.001 
    17.007000999997857 
 
    The fourth-order derivative of a 3rd-order polynomial is zero: 
 
    &gt;&gt;&gt; np.polyder(p, 2) 
    poly1d([6, 2]) 
    &gt;&gt;&gt; np.polyder(p, 3) 
    poly1d([6]) 
    &gt;&gt;&gt; np.polyder(p, 4) 
    poly1d([0]) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">m </span><span class="s2">= </span><span class="s1">int</span><span class="s2">(</span><span class="s1">m</span><span class="s2">)</span>
    <span class="s4">if </span><span class="s1">m </span><span class="s2">&lt; </span><span class="s5">0</span><span class="s2">:</span>
        <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;Order of derivative must be positive (see polyint)&quot;</span><span class="s2">)</span>

    <span class="s1">truepoly </span><span class="s2">= </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">p</span><span class="s2">, </span><span class="s1">poly1d</span><span class="s2">)</span>
    <span class="s1">p </span><span class="s2">= </span><span class="s1">NX</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">p</span><span class="s2">)</span>
    <span class="s1">n </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">p</span><span class="s2">) - </span><span class="s5">1</span>
    <span class="s1">y </span><span class="s2">= </span><span class="s1">p</span><span class="s2">[:-</span><span class="s5">1</span><span class="s2">] * </span><span class="s1">NX</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(</span><span class="s1">n</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, -</span><span class="s5">1</span><span class="s2">)</span>
    <span class="s4">if </span><span class="s1">m </span><span class="s2">== </span><span class="s5">0</span><span class="s2">:</span>
        <span class="s1">val </span><span class="s2">= </span><span class="s1">p</span>
    <span class="s4">else</span><span class="s2">:</span>
        <span class="s1">val </span><span class="s2">= </span><span class="s1">polyder</span><span class="s2">(</span><span class="s1">y</span><span class="s2">, </span><span class="s1">m </span><span class="s2">- </span><span class="s5">1</span><span class="s2">)</span>
    <span class="s4">if </span><span class="s1">truepoly</span><span class="s2">:</span>
        <span class="s1">val </span><span class="s2">= </span><span class="s1">poly1d</span><span class="s2">(</span><span class="s1">val</span><span class="s2">)</span>
    <span class="s4">return </span><span class="s1">val</span>


<span class="s4">def </span><span class="s1">_polyfit_dispatcher</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">deg</span><span class="s2">, </span><span class="s1">rcond</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">full</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">w</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">cov</span><span class="s2">=</span><span class="s4">None</span><span class="s2">):</span>
    <span class="s4">return </span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">w</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">array_function_dispatch</span><span class="s2">(</span><span class="s1">_polyfit_dispatcher</span><span class="s2">)</span>
<span class="s4">def </span><span class="s1">polyfit</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">deg</span><span class="s2">, </span><span class="s1">rcond</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">full</span><span class="s2">=</span><span class="s4">False</span><span class="s2">, </span><span class="s1">w</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">cov</span><span class="s2">=</span><span class="s4">False</span><span class="s2">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Least squares polynomial fit. 
 
    .. note:: 
       This forms part of the old polynomial API. Since version 1.4, the 
       new polynomial API defined in `numpy.polynomial` is preferred. 
       A summary of the differences can be found in the 
       :doc:`transition guide &lt;/reference/routines.polynomials&gt;`. 
 
    Fit a polynomial ``p(x) = p[0] * x**deg + ... + p[deg]`` of degree `deg` 
    to points `(x, y)`. Returns a vector of coefficients `p` that minimises 
    the squared error in the order `deg`, `deg-1`, ... `0`. 
 
    The `Polynomial.fit &lt;numpy.polynomial.polynomial.Polynomial.fit&gt;` class 
    method is recommended for new code as it is more stable numerically. See 
    the documentation of the method for more information. 
 
    Parameters 
    ---------- 
    x : array_like, shape (M,) 
        x-coordinates of the M sample points ``(x[i], y[i])``. 
    y : array_like, shape (M,) or (M, K) 
        y-coordinates of the sample points. Several data sets of sample 
        points sharing the same x-coordinates can be fitted at once by 
        passing in a 2D-array that contains one dataset per column. 
    deg : int 
        Degree of the fitting polynomial 
    rcond : float, optional 
        Relative condition number of the fit. Singular values smaller than 
        this relative to the largest singular value will be ignored. The 
        default value is len(x)*eps, where eps is the relative precision of 
        the float type, about 2e-16 in most cases. 
    full : bool, optional 
        Switch determining nature of return value. When it is False (the 
        default) just the coefficients are returned, when True diagnostic 
        information from the singular value decomposition is also returned. 
    w : array_like, shape (M,), optional 
        Weights. If not None, the weight ``w[i]`` applies to the unsquared 
        residual ``y[i] - y_hat[i]`` at ``x[i]``. Ideally the weights are 
        chosen so that the errors of the products ``w[i]*y[i]`` all have the 
        same variance.  When using inverse-variance weighting, use 
        ``w[i] = 1/sigma(y[i])``.  The default value is None. 
    cov : bool or str, optional 
        If given and not `False`, return not just the estimate but also its 
        covariance matrix. By default, the covariance are scaled by 
        chi2/dof, where dof = M - (deg + 1), i.e., the weights are presumed 
        to be unreliable except in a relative sense and everything is scaled 
        such that the reduced chi2 is unity. This scaling is omitted if 
        ``cov='unscaled'``, as is relevant for the case that the weights are 
        w = 1/sigma, with sigma known to be a reliable estimate of the 
        uncertainty. 
 
    Returns 
    ------- 
    p : ndarray, shape (deg + 1,) or (deg + 1, K) 
        Polynomial coefficients, highest power first.  If `y` was 2-D, the 
        coefficients for `k`-th data set are in ``p[:,k]``. 
 
    residuals, rank, singular_values, rcond 
        These values are only returned if ``full == True`` 
 
        - residuals -- sum of squared residuals of the least squares fit 
        - rank -- the effective rank of the scaled Vandermonde 
           coefficient matrix 
        - singular_values -- singular values of the scaled Vandermonde 
           coefficient matrix 
        - rcond -- value of `rcond`. 
 
        For more details, see `numpy.linalg.lstsq`. 
 
    V : ndarray, shape (deg + 1, deg + 1) or (deg + 1, deg + 1, K) 
        Present only if ``full == False`` and ``cov == True``.  The covariance 
        matrix of the polynomial coefficient estimates.  The diagonal of 
        this matrix are the variance estimates for each coefficient.  If y 
        is a 2-D array, then the covariance matrix for the `k`-th data set 
        are in ``V[:,:,k]`` 
 
 
    Warns 
    ----- 
    RankWarning 
        The rank of the coefficient matrix in the least-squares fit is 
        deficient. The warning is only raised if ``full == False``. 
 
        The warnings can be turned off by 
 
        &gt;&gt;&gt; import warnings 
        &gt;&gt;&gt; warnings.simplefilter('ignore', np.exceptions.RankWarning) 
 
    See Also 
    -------- 
    polyval : Compute polynomial values. 
    linalg.lstsq : Computes a least-squares fit. 
    scipy.interpolate.UnivariateSpline : Computes spline fits. 
 
    Notes 
    ----- 
    The solution minimizes the squared error 
 
    .. math:: 
        E = \\sum_{j=0}^k |p(x_j) - y_j|^2 
 
    in the equations:: 
 
        x[0]**n * p[0] + ... + x[0] * p[n-1] + p[n] = y[0] 
        x[1]**n * p[0] + ... + x[1] * p[n-1] + p[n] = y[1] 
        ... 
        x[k]**n * p[0] + ... + x[k] * p[n-1] + p[n] = y[k] 
 
    The coefficient matrix of the coefficients `p` is a Vandermonde matrix. 
 
    `polyfit` issues a `~exceptions.RankWarning` when the least-squares fit is 
    badly conditioned. This implies that the best fit is not well-defined due 
    to numerical error. The results may be improved by lowering the polynomial 
    degree or by replacing `x` by `x` - `x`.mean(). The `rcond` parameter 
    can also be set to a value smaller than its default, but the resulting 
    fit may be spurious: including contributions from the small singular 
    values can add numerical noise to the result. 
 
    Note that fitting polynomial coefficients is inherently badly conditioned 
    when the degree of the polynomial is large or the interval of sample points 
    is badly centered. The quality of the fit should always be checked in these 
    cases. When polynomial fits are not satisfactory, splines may be a good 
    alternative. 
 
    References 
    ---------- 
    .. [1] Wikipedia, &quot;Curve fitting&quot;, 
           https://en.wikipedia.org/wiki/Curve_fitting 
    .. [2] Wikipedia, &quot;Polynomial interpolation&quot;, 
           https://en.wikipedia.org/wiki/Polynomial_interpolation 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; import warnings 
    &gt;&gt;&gt; x = np.array([0.0, 1.0, 2.0, 3.0,  4.0,  5.0]) 
    &gt;&gt;&gt; y = np.array([0.0, 0.8, 0.9, 0.1, -0.8, -1.0]) 
    &gt;&gt;&gt; z = np.polyfit(x, y, 3) 
    &gt;&gt;&gt; z 
    array([ 0.08703704, -0.81349206,  1.69312169, -0.03968254]) # may vary 
 
    It is convenient to use `poly1d` objects for dealing with polynomials: 
 
    &gt;&gt;&gt; p = np.poly1d(z) 
    &gt;&gt;&gt; p(0.5) 
    0.6143849206349179 # may vary 
    &gt;&gt;&gt; p(3.5) 
    -0.34732142857143039 # may vary 
    &gt;&gt;&gt; p(10) 
    22.579365079365115 # may vary 
 
    High-order polynomials may oscillate wildly: 
 
    &gt;&gt;&gt; with warnings.catch_warnings(): 
    ...     warnings.simplefilter('ignore', np.exceptions.RankWarning) 
    ...     p30 = np.poly1d(np.polyfit(x, y, 30)) 
    ... 
    &gt;&gt;&gt; p30(4) 
    -0.80000000000000204 # may vary 
    &gt;&gt;&gt; p30(5) 
    -0.99999999999999445 # may vary 
    &gt;&gt;&gt; p30(4.5) 
    -0.10547061179440398 # may vary 
 
    Illustration: 
 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; xp = np.linspace(-2, 6, 100) 
    &gt;&gt;&gt; _ = plt.plot(x, y, '.', xp, p(xp), '-', xp, p30(xp), '--') 
    &gt;&gt;&gt; plt.ylim(-2,2) 
    (-2, 2) 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span>
    <span class="s1">order </span><span class="s2">= </span><span class="s1">int</span><span class="s2">(</span><span class="s1">deg</span><span class="s2">) + </span><span class="s5">1</span>
    <span class="s1">x </span><span class="s2">= </span><span class="s1">NX</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">x</span><span class="s2">) + </span><span class="s5">0.0</span>
    <span class="s1">y </span><span class="s2">= </span><span class="s1">NX</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">y</span><span class="s2">) + </span><span class="s5">0.0</span>

    <span class="s6"># check arguments.</span>
    <span class="s4">if </span><span class="s1">deg </span><span class="s2">&lt; </span><span class="s5">0</span><span class="s2">:</span>
        <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;expected deg &gt;= 0&quot;</span><span class="s2">)</span>
    <span class="s4">if </span><span class="s1">x</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">!= </span><span class="s5">1</span><span class="s2">:</span>
        <span class="s4">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s3">&quot;expected 1D vector for x&quot;</span><span class="s2">)</span>
    <span class="s4">if </span><span class="s1">x</span><span class="s2">.</span><span class="s1">size </span><span class="s2">== </span><span class="s5">0</span><span class="s2">:</span>
        <span class="s4">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s3">&quot;expected non-empty vector for x&quot;</span><span class="s2">)</span>
    <span class="s4">if </span><span class="s1">y</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">&lt; </span><span class="s5">1 </span><span class="s4">or </span><span class="s1">y</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">&gt; </span><span class="s5">2</span><span class="s2">:</span>
        <span class="s4">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s3">&quot;expected 1D or 2D array for y&quot;</span><span class="s2">)</span>
    <span class="s4">if </span><span class="s1">x</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">0</span><span class="s2">] != </span><span class="s1">y</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]:</span>
        <span class="s4">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s3">&quot;expected x and y to have same length&quot;</span><span class="s2">)</span>

    <span class="s6"># set rcond</span>
    <span class="s4">if </span><span class="s1">rcond </span><span class="s4">is None</span><span class="s2">:</span>
        <span class="s1">rcond </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)*</span><span class="s1">finfo</span><span class="s2">(</span><span class="s1">x</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">).</span><span class="s1">eps</span>

    <span class="s6"># set up least squares equation for powers of x</span>
    <span class="s1">lhs </span><span class="s2">= </span><span class="s1">vander</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">order</span><span class="s2">)</span>
    <span class="s1">rhs </span><span class="s2">= </span><span class="s1">y</span>

    <span class="s6"># apply weighting</span>
    <span class="s4">if </span><span class="s1">w </span><span class="s4">is not None</span><span class="s2">:</span>
        <span class="s1">w </span><span class="s2">= </span><span class="s1">NX</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">w</span><span class="s2">) + </span><span class="s5">0.0</span>
        <span class="s4">if </span><span class="s1">w</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">!= </span><span class="s5">1</span><span class="s2">:</span>
            <span class="s4">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s3">&quot;expected a 1-d array for weights&quot;</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">w</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">0</span><span class="s2">] != </span><span class="s1">y</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]:</span>
            <span class="s4">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s3">&quot;expected w and y to have the same length&quot;</span><span class="s2">)</span>
        <span class="s1">lhs </span><span class="s2">*= </span><span class="s1">w</span><span class="s2">[:, </span><span class="s1">NX</span><span class="s2">.</span><span class="s1">newaxis</span><span class="s2">]</span>
        <span class="s4">if </span><span class="s1">rhs</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s5">2</span><span class="s2">:</span>
            <span class="s1">rhs </span><span class="s2">*= </span><span class="s1">w</span><span class="s2">[:, </span><span class="s1">NX</span><span class="s2">.</span><span class="s1">newaxis</span><span class="s2">]</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">rhs </span><span class="s2">*= </span><span class="s1">w</span>

    <span class="s6"># scale lhs to improve condition number and solve</span>
    <span class="s1">scale </span><span class="s2">= </span><span class="s1">NX</span><span class="s2">.</span><span class="s1">sqrt</span><span class="s2">((</span><span class="s1">lhs</span><span class="s2">*</span><span class="s1">lhs</span><span class="s2">).</span><span class="s1">sum</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">=</span><span class="s5">0</span><span class="s2">))</span>
    <span class="s1">lhs </span><span class="s2">/= </span><span class="s1">scale</span>
    <span class="s1">c</span><span class="s2">, </span><span class="s1">resids</span><span class="s2">, </span><span class="s1">rank</span><span class="s2">, </span><span class="s1">s </span><span class="s2">= </span><span class="s1">lstsq</span><span class="s2">(</span><span class="s1">lhs</span><span class="s2">, </span><span class="s1">rhs</span><span class="s2">, </span><span class="s1">rcond</span><span class="s2">)</span>
    <span class="s1">c </span><span class="s2">= (</span><span class="s1">c</span><span class="s2">.</span><span class="s1">T</span><span class="s2">/</span><span class="s1">scale</span><span class="s2">).</span><span class="s1">T  </span><span class="s6"># broadcast scale coefficients</span>

    <span class="s6"># warn on rank reduction, which indicates an ill conditioned matrix</span>
    <span class="s4">if </span><span class="s1">rank </span><span class="s2">!= </span><span class="s1">order </span><span class="s4">and not </span><span class="s1">full</span><span class="s2">:</span>
        <span class="s1">msg </span><span class="s2">= </span><span class="s3">&quot;Polyfit may be poorly conditioned&quot;</span>
        <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">, </span><span class="s1">RankWarning</span><span class="s2">, </span><span class="s1">stacklevel</span><span class="s2">=</span><span class="s5">2</span><span class="s2">)</span>

    <span class="s4">if </span><span class="s1">full</span><span class="s2">:</span>
        <span class="s4">return </span><span class="s1">c</span><span class="s2">, </span><span class="s1">resids</span><span class="s2">, </span><span class="s1">rank</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">rcond</span>
    <span class="s4">elif </span><span class="s1">cov</span><span class="s2">:</span>
        <span class="s1">Vbase </span><span class="s2">= </span><span class="s1">inv</span><span class="s2">(</span><span class="s1">dot</span><span class="s2">(</span><span class="s1">lhs</span><span class="s2">.</span><span class="s1">T</span><span class="s2">, </span><span class="s1">lhs</span><span class="s2">))</span>
        <span class="s1">Vbase </span><span class="s2">/= </span><span class="s1">NX</span><span class="s2">.</span><span class="s1">outer</span><span class="s2">(</span><span class="s1">scale</span><span class="s2">, </span><span class="s1">scale</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">cov </span><span class="s2">== </span><span class="s3">&quot;unscaled&quot;</span><span class="s2">:</span>
            <span class="s1">fac </span><span class="s2">= </span><span class="s5">1</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s4">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">x</span><span class="s2">) &lt;= </span><span class="s1">order</span><span class="s2">:</span>
                <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;the number of data points must exceed order &quot;</span>
                                 <span class="s3">&quot;to scale the covariance matrix&quot;</span><span class="s2">)</span>
            <span class="s6"># note, this used to be: fac = resids / (len(x) - order - 2.0)</span>
            <span class="s6"># it was decided that the &quot;- 2&quot; (originally justified by &quot;Bayesian</span>
            <span class="s6"># uncertainty analysis&quot;) is not what the user expects</span>
            <span class="s6"># (see gh-11196 and gh-11197)</span>
            <span class="s1">fac </span><span class="s2">= </span><span class="s1">resids </span><span class="s2">/ (</span><span class="s1">len</span><span class="s2">(</span><span class="s1">x</span><span class="s2">) - </span><span class="s1">order</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">y</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s5">1</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s1">c</span><span class="s2">, </span><span class="s1">Vbase </span><span class="s2">* </span><span class="s1">fac</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s1">c</span><span class="s2">, </span><span class="s1">Vbase</span><span class="s2">[:,:, </span><span class="s1">NX</span><span class="s2">.</span><span class="s1">newaxis</span><span class="s2">] * </span><span class="s1">fac</span>
    <span class="s4">else</span><span class="s2">:</span>
        <span class="s4">return </span><span class="s1">c</span>


<span class="s4">def </span><span class="s1">_polyval_dispatcher</span><span class="s2">(</span><span class="s1">p</span><span class="s2">, </span><span class="s1">x</span><span class="s2">):</span>
    <span class="s4">return </span><span class="s2">(</span><span class="s1">p</span><span class="s2">, </span><span class="s1">x</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">array_function_dispatch</span><span class="s2">(</span><span class="s1">_polyval_dispatcher</span><span class="s2">)</span>
<span class="s4">def </span><span class="s1">polyval</span><span class="s2">(</span><span class="s1">p</span><span class="s2">, </span><span class="s1">x</span><span class="s2">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Evaluate a polynomial at specific values. 
 
    .. note:: 
       This forms part of the old polynomial API. Since version 1.4, the 
       new polynomial API defined in `numpy.polynomial` is preferred. 
       A summary of the differences can be found in the 
       :doc:`transition guide &lt;/reference/routines.polynomials&gt;`. 
 
    If `p` is of length N, this function returns the value:: 
 
        p[0]*x**(N-1) + p[1]*x**(N-2) + ... + p[N-2]*x + p[N-1] 
 
    If `x` is a sequence, then ``p(x)`` is returned for each element of ``x``. 
    If `x` is another polynomial then the composite polynomial ``p(x(t))`` 
    is returned. 
 
    Parameters 
    ---------- 
    p : array_like or poly1d object 
       1D array of polynomial coefficients (including coefficients equal 
       to zero) from highest degree to the constant term, or an 
       instance of poly1d. 
    x : array_like or poly1d object 
       A number, an array of numbers, or an instance of poly1d, at 
       which to evaluate `p`. 
 
    Returns 
    ------- 
    values : ndarray or poly1d 
       If `x` is a poly1d instance, the result is the composition of the two 
       polynomials, i.e., `x` is &quot;substituted&quot; in `p` and the simplified 
       result is returned. In addition, the type of `x` - array_like or 
       poly1d - governs the type of the output: `x` array_like =&gt; `values` 
       array_like, `x` a poly1d object =&gt; `values` is also. 
 
    See Also 
    -------- 
    poly1d: A polynomial class. 
 
    Notes 
    ----- 
    Horner's scheme [1]_ is used to evaluate the polynomial. Even so, 
    for polynomials of high degree the values may be inaccurate due to 
    rounding errors. Use carefully. 
 
    If `x` is a subtype of `ndarray` the return value will be of the same type. 
 
    References 
    ---------- 
    .. [1] I. N. Bronshtein, K. A. Semendyayev, and K. A. Hirsch (Eng. 
       trans. Ed.), *Handbook of Mathematics*, New York, Van Nostrand 
       Reinhold Co., 1985, pg. 720. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; np.polyval([3,0,1], 5)  # 3 * 5**2 + 0 * 5**1 + 1 
    76 
    &gt;&gt;&gt; np.polyval([3,0,1], np.poly1d(5)) 
    poly1d([76]) 
    &gt;&gt;&gt; np.polyval(np.poly1d([3,0,1]), 5) 
    76 
    &gt;&gt;&gt; np.polyval(np.poly1d([3,0,1]), np.poly1d(5)) 
    poly1d([76]) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">p </span><span class="s2">= </span><span class="s1">NX</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">p</span><span class="s2">)</span>
    <span class="s4">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">poly1d</span><span class="s2">):</span>
        <span class="s1">y </span><span class="s2">= </span><span class="s5">0</span>
    <span class="s4">else</span><span class="s2">:</span>
        <span class="s1">x </span><span class="s2">= </span><span class="s1">NX</span><span class="s2">.</span><span class="s1">asanyarray</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)</span>
        <span class="s1">y </span><span class="s2">= </span><span class="s1">NX</span><span class="s2">.</span><span class="s1">zeros_like</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)</span>
    <span class="s4">for </span><span class="s1">pv </span><span class="s4">in </span><span class="s1">p</span><span class="s2">:</span>
        <span class="s1">y </span><span class="s2">= </span><span class="s1">y </span><span class="s2">* </span><span class="s1">x </span><span class="s2">+ </span><span class="s1">pv</span>
    <span class="s4">return </span><span class="s1">y</span>


<span class="s4">def </span><span class="s1">_binary_op_dispatcher</span><span class="s2">(</span><span class="s1">a1</span><span class="s2">, </span><span class="s1">a2</span><span class="s2">):</span>
    <span class="s4">return </span><span class="s2">(</span><span class="s1">a1</span><span class="s2">, </span><span class="s1">a2</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">array_function_dispatch</span><span class="s2">(</span><span class="s1">_binary_op_dispatcher</span><span class="s2">)</span>
<span class="s4">def </span><span class="s1">polyadd</span><span class="s2">(</span><span class="s1">a1</span><span class="s2">, </span><span class="s1">a2</span><span class="s2">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Find the sum of two polynomials. 
 
    .. note:: 
       This forms part of the old polynomial API. Since version 1.4, the 
       new polynomial API defined in `numpy.polynomial` is preferred. 
       A summary of the differences can be found in the 
       :doc:`transition guide &lt;/reference/routines.polynomials&gt;`. 
 
    Returns the polynomial resulting from the sum of two input polynomials. 
    Each input must be either a poly1d object or a 1D sequence of polynomial 
    coefficients, from highest to lowest degree. 
 
    Parameters 
    ---------- 
    a1, a2 : array_like or poly1d object 
        Input polynomials. 
 
    Returns 
    ------- 
    out : ndarray or poly1d object 
        The sum of the inputs. If either input is a poly1d object, then the 
        output is also a poly1d object. Otherwise, it is a 1D array of 
        polynomial coefficients from highest to lowest degree. 
 
    See Also 
    -------- 
    poly1d : A one-dimensional polynomial class. 
    poly, polyadd, polyder, polydiv, polyfit, polyint, polysub, polyval 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; np.polyadd([1, 2], [9, 5, 4]) 
    array([9, 6, 6]) 
 
    Using poly1d objects: 
 
    &gt;&gt;&gt; p1 = np.poly1d([1, 2]) 
    &gt;&gt;&gt; p2 = np.poly1d([9, 5, 4]) 
    &gt;&gt;&gt; print(p1) 
    1 x + 2 
    &gt;&gt;&gt; print(p2) 
       2 
    9 x + 5 x + 4 
    &gt;&gt;&gt; print(np.polyadd(p1, p2)) 
       2 
    9 x + 6 x + 6 
 
    &quot;&quot;&quot;</span>
    <span class="s1">truepoly </span><span class="s2">= (</span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">a1</span><span class="s2">, </span><span class="s1">poly1d</span><span class="s2">) </span><span class="s4">or </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">a2</span><span class="s2">, </span><span class="s1">poly1d</span><span class="s2">))</span>
    <span class="s1">a1 </span><span class="s2">= </span><span class="s1">atleast_1d</span><span class="s2">(</span><span class="s1">a1</span><span class="s2">)</span>
    <span class="s1">a2 </span><span class="s2">= </span><span class="s1">atleast_1d</span><span class="s2">(</span><span class="s1">a2</span><span class="s2">)</span>
    <span class="s1">diff </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">a2</span><span class="s2">) - </span><span class="s1">len</span><span class="s2">(</span><span class="s1">a1</span><span class="s2">)</span>
    <span class="s4">if </span><span class="s1">diff </span><span class="s2">== </span><span class="s5">0</span><span class="s2">:</span>
        <span class="s1">val </span><span class="s2">= </span><span class="s1">a1 </span><span class="s2">+ </span><span class="s1">a2</span>
    <span class="s4">elif </span><span class="s1">diff </span><span class="s2">&gt; </span><span class="s5">0</span><span class="s2">:</span>
        <span class="s1">zr </span><span class="s2">= </span><span class="s1">NX</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">(</span><span class="s1">diff</span><span class="s2">, </span><span class="s1">a1</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s1">val </span><span class="s2">= </span><span class="s1">NX</span><span class="s2">.</span><span class="s1">concatenate</span><span class="s2">((</span><span class="s1">zr</span><span class="s2">, </span><span class="s1">a1</span><span class="s2">)) + </span><span class="s1">a2</span>
    <span class="s4">else</span><span class="s2">:</span>
        <span class="s1">zr </span><span class="s2">= </span><span class="s1">NX</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">(</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">diff</span><span class="s2">), </span><span class="s1">a2</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s1">val </span><span class="s2">= </span><span class="s1">a1 </span><span class="s2">+ </span><span class="s1">NX</span><span class="s2">.</span><span class="s1">concatenate</span><span class="s2">((</span><span class="s1">zr</span><span class="s2">, </span><span class="s1">a2</span><span class="s2">))</span>
    <span class="s4">if </span><span class="s1">truepoly</span><span class="s2">:</span>
        <span class="s1">val </span><span class="s2">= </span><span class="s1">poly1d</span><span class="s2">(</span><span class="s1">val</span><span class="s2">)</span>
    <span class="s4">return </span><span class="s1">val</span>


<span class="s2">@</span><span class="s1">array_function_dispatch</span><span class="s2">(</span><span class="s1">_binary_op_dispatcher</span><span class="s2">)</span>
<span class="s4">def </span><span class="s1">polysub</span><span class="s2">(</span><span class="s1">a1</span><span class="s2">, </span><span class="s1">a2</span><span class="s2">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Difference (subtraction) of two polynomials. 
 
    .. note:: 
       This forms part of the old polynomial API. Since version 1.4, the 
       new polynomial API defined in `numpy.polynomial` is preferred. 
       A summary of the differences can be found in the 
       :doc:`transition guide &lt;/reference/routines.polynomials&gt;`. 
 
    Given two polynomials `a1` and `a2`, returns ``a1 - a2``. 
    `a1` and `a2` can be either array_like sequences of the polynomials' 
    coefficients (including coefficients equal to zero), or `poly1d` objects. 
 
    Parameters 
    ---------- 
    a1, a2 : array_like or poly1d 
        Minuend and subtrahend polynomials, respectively. 
 
    Returns 
    ------- 
    out : ndarray or poly1d 
        Array or `poly1d` object of the difference polynomial's coefficients. 
 
    See Also 
    -------- 
    polyval, polydiv, polymul, polyadd 
 
    Examples 
    -------- 
    .. math:: (2 x^2 + 10 x - 2) - (3 x^2 + 10 x -4) = (-x^2 + 2) 
 
    &gt;&gt;&gt; import numpy as np 
 
    &gt;&gt;&gt; np.polysub([2, 10, -2], [3, 10, -4]) 
    array([-1,  0,  2]) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">truepoly </span><span class="s2">= (</span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">a1</span><span class="s2">, </span><span class="s1">poly1d</span><span class="s2">) </span><span class="s4">or </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">a2</span><span class="s2">, </span><span class="s1">poly1d</span><span class="s2">))</span>
    <span class="s1">a1 </span><span class="s2">= </span><span class="s1">atleast_1d</span><span class="s2">(</span><span class="s1">a1</span><span class="s2">)</span>
    <span class="s1">a2 </span><span class="s2">= </span><span class="s1">atleast_1d</span><span class="s2">(</span><span class="s1">a2</span><span class="s2">)</span>
    <span class="s1">diff </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">a2</span><span class="s2">) - </span><span class="s1">len</span><span class="s2">(</span><span class="s1">a1</span><span class="s2">)</span>
    <span class="s4">if </span><span class="s1">diff </span><span class="s2">== </span><span class="s5">0</span><span class="s2">:</span>
        <span class="s1">val </span><span class="s2">= </span><span class="s1">a1 </span><span class="s2">- </span><span class="s1">a2</span>
    <span class="s4">elif </span><span class="s1">diff </span><span class="s2">&gt; </span><span class="s5">0</span><span class="s2">:</span>
        <span class="s1">zr </span><span class="s2">= </span><span class="s1">NX</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">(</span><span class="s1">diff</span><span class="s2">, </span><span class="s1">a1</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s1">val </span><span class="s2">= </span><span class="s1">NX</span><span class="s2">.</span><span class="s1">concatenate</span><span class="s2">((</span><span class="s1">zr</span><span class="s2">, </span><span class="s1">a1</span><span class="s2">)) - </span><span class="s1">a2</span>
    <span class="s4">else</span><span class="s2">:</span>
        <span class="s1">zr </span><span class="s2">= </span><span class="s1">NX</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">(</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">diff</span><span class="s2">), </span><span class="s1">a2</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s1">val </span><span class="s2">= </span><span class="s1">a1 </span><span class="s2">- </span><span class="s1">NX</span><span class="s2">.</span><span class="s1">concatenate</span><span class="s2">((</span><span class="s1">zr</span><span class="s2">, </span><span class="s1">a2</span><span class="s2">))</span>
    <span class="s4">if </span><span class="s1">truepoly</span><span class="s2">:</span>
        <span class="s1">val </span><span class="s2">= </span><span class="s1">poly1d</span><span class="s2">(</span><span class="s1">val</span><span class="s2">)</span>
    <span class="s4">return </span><span class="s1">val</span>


<span class="s2">@</span><span class="s1">array_function_dispatch</span><span class="s2">(</span><span class="s1">_binary_op_dispatcher</span><span class="s2">)</span>
<span class="s4">def </span><span class="s1">polymul</span><span class="s2">(</span><span class="s1">a1</span><span class="s2">, </span><span class="s1">a2</span><span class="s2">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Find the product of two polynomials. 
 
    .. note:: 
       This forms part of the old polynomial API. Since version 1.4, the 
       new polynomial API defined in `numpy.polynomial` is preferred. 
       A summary of the differences can be found in the 
       :doc:`transition guide &lt;/reference/routines.polynomials&gt;`. 
 
    Finds the polynomial resulting from the multiplication of the two input 
    polynomials. Each input must be either a poly1d object or a 1D sequence 
    of polynomial coefficients, from highest to lowest degree. 
 
    Parameters 
    ---------- 
    a1, a2 : array_like or poly1d object 
        Input polynomials. 
 
    Returns 
    ------- 
    out : ndarray or poly1d object 
        The polynomial resulting from the multiplication of the inputs. If 
        either inputs is a poly1d object, then the output is also a poly1d 
        object. Otherwise, it is a 1D array of polynomial coefficients from 
        highest to lowest degree. 
 
    See Also 
    -------- 
    poly1d : A one-dimensional polynomial class. 
    poly, polyadd, polyder, polydiv, polyfit, polyint, polysub, polyval 
    convolve : Array convolution. Same output as polymul, but has parameter 
               for overlap mode. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; np.polymul([1, 2, 3], [9, 5, 1]) 
    array([ 9, 23, 38, 17,  3]) 
 
    Using poly1d objects: 
 
    &gt;&gt;&gt; p1 = np.poly1d([1, 2, 3]) 
    &gt;&gt;&gt; p2 = np.poly1d([9, 5, 1]) 
    &gt;&gt;&gt; print(p1) 
       2 
    1 x + 2 x + 3 
    &gt;&gt;&gt; print(p2) 
       2 
    9 x + 5 x + 1 
    &gt;&gt;&gt; print(np.polymul(p1, p2)) 
       4      3      2 
    9 x + 23 x + 38 x + 17 x + 3 
 
    &quot;&quot;&quot;</span>
    <span class="s1">truepoly </span><span class="s2">= (</span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">a1</span><span class="s2">, </span><span class="s1">poly1d</span><span class="s2">) </span><span class="s4">or </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">a2</span><span class="s2">, </span><span class="s1">poly1d</span><span class="s2">))</span>
    <span class="s1">a1</span><span class="s2">, </span><span class="s1">a2 </span><span class="s2">= </span><span class="s1">poly1d</span><span class="s2">(</span><span class="s1">a1</span><span class="s2">), </span><span class="s1">poly1d</span><span class="s2">(</span><span class="s1">a2</span><span class="s2">)</span>
    <span class="s1">val </span><span class="s2">= </span><span class="s1">NX</span><span class="s2">.</span><span class="s1">convolve</span><span class="s2">(</span><span class="s1">a1</span><span class="s2">, </span><span class="s1">a2</span><span class="s2">)</span>
    <span class="s4">if </span><span class="s1">truepoly</span><span class="s2">:</span>
        <span class="s1">val </span><span class="s2">= </span><span class="s1">poly1d</span><span class="s2">(</span><span class="s1">val</span><span class="s2">)</span>
    <span class="s4">return </span><span class="s1">val</span>


<span class="s4">def </span><span class="s1">_polydiv_dispatcher</span><span class="s2">(</span><span class="s1">u</span><span class="s2">, </span><span class="s1">v</span><span class="s2">):</span>
    <span class="s4">return </span><span class="s2">(</span><span class="s1">u</span><span class="s2">, </span><span class="s1">v</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">array_function_dispatch</span><span class="s2">(</span><span class="s1">_polydiv_dispatcher</span><span class="s2">)</span>
<span class="s4">def </span><span class="s1">polydiv</span><span class="s2">(</span><span class="s1">u</span><span class="s2">, </span><span class="s1">v</span><span class="s2">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns the quotient and remainder of polynomial division. 
 
    .. note:: 
       This forms part of the old polynomial API. Since version 1.4, the 
       new polynomial API defined in `numpy.polynomial` is preferred. 
       A summary of the differences can be found in the 
       :doc:`transition guide &lt;/reference/routines.polynomials&gt;`. 
 
    The input arrays are the coefficients (including any coefficients 
    equal to zero) of the &quot;numerator&quot; (dividend) and &quot;denominator&quot; 
    (divisor) polynomials, respectively. 
 
    Parameters 
    ---------- 
    u : array_like or poly1d 
        Dividend polynomial's coefficients. 
 
    v : array_like or poly1d 
        Divisor polynomial's coefficients. 
 
    Returns 
    ------- 
    q : ndarray 
        Coefficients, including those equal to zero, of the quotient. 
    r : ndarray 
        Coefficients, including those equal to zero, of the remainder. 
 
    See Also 
    -------- 
    poly, polyadd, polyder, polydiv, polyfit, polyint, polymul, polysub 
    polyval 
 
    Notes 
    ----- 
    Both `u` and `v` must be 0-d or 1-d (ndim = 0 or 1), but `u.ndim` need 
    not equal `v.ndim`. In other words, all four possible combinations - 
    ``u.ndim = v.ndim = 0``, ``u.ndim = v.ndim = 1``, 
    ``u.ndim = 1, v.ndim = 0``, and ``u.ndim = 0, v.ndim = 1`` - work. 
 
    Examples 
    -------- 
    .. math:: \\frac{3x^2 + 5x + 2}{2x + 1} = 1.5x + 1.75, remainder 0.25 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; x = np.array([3.0, 5.0, 2.0]) 
    &gt;&gt;&gt; y = np.array([2.0, 1.0]) 
    &gt;&gt;&gt; np.polydiv(x, y) 
    (array([1.5 , 1.75]), array([0.25])) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">truepoly </span><span class="s2">= (</span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">u</span><span class="s2">, </span><span class="s1">poly1d</span><span class="s2">) </span><span class="s4">or </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">v</span><span class="s2">, </span><span class="s1">poly1d</span><span class="s2">))</span>
    <span class="s1">u </span><span class="s2">= </span><span class="s1">atleast_1d</span><span class="s2">(</span><span class="s1">u</span><span class="s2">) + </span><span class="s5">0.0</span>
    <span class="s1">v </span><span class="s2">= </span><span class="s1">atleast_1d</span><span class="s2">(</span><span class="s1">v</span><span class="s2">) + </span><span class="s5">0.0</span>
    <span class="s6"># w has the common type</span>
    <span class="s1">w </span><span class="s2">= </span><span class="s1">u</span><span class="s2">[</span><span class="s5">0</span><span class="s2">] + </span><span class="s1">v</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]</span>
    <span class="s1">m </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">u</span><span class="s2">) - </span><span class="s5">1</span>
    <span class="s1">n </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">v</span><span class="s2">) - </span><span class="s5">1</span>
    <span class="s1">scale </span><span class="s2">= </span><span class="s5">1. </span><span class="s2">/ </span><span class="s1">v</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]</span>
    <span class="s1">q </span><span class="s2">= </span><span class="s1">NX</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">((</span><span class="s1">max</span><span class="s2">(</span><span class="s1">m </span><span class="s2">- </span><span class="s1">n </span><span class="s2">+ </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">),), </span><span class="s1">w</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
    <span class="s1">r </span><span class="s2">= </span><span class="s1">u</span><span class="s2">.</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">w</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
    <span class="s4">for </span><span class="s1">k </span><span class="s4">in </span><span class="s1">range</span><span class="s2">(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">m</span><span class="s2">-</span><span class="s1">n</span><span class="s2">+</span><span class="s5">1</span><span class="s2">):</span>
        <span class="s1">d </span><span class="s2">= </span><span class="s1">scale </span><span class="s2">* </span><span class="s1">r</span><span class="s2">[</span><span class="s1">k</span><span class="s2">]</span>
        <span class="s1">q</span><span class="s2">[</span><span class="s1">k</span><span class="s2">] = </span><span class="s1">d</span>
        <span class="s1">r</span><span class="s2">[</span><span class="s1">k</span><span class="s2">:</span><span class="s1">k</span><span class="s2">+</span><span class="s1">n</span><span class="s2">+</span><span class="s5">1</span><span class="s2">] -= </span><span class="s1">d</span><span class="s2">*</span><span class="s1">v</span>
    <span class="s4">while </span><span class="s1">NX</span><span class="s2">.</span><span class="s1">allclose</span><span class="s2">(</span><span class="s1">r</span><span class="s2">[</span><span class="s5">0</span><span class="s2">], </span><span class="s5">0</span><span class="s2">, </span><span class="s1">rtol</span><span class="s2">=</span><span class="s5">1e-14</span><span class="s2">) </span><span class="s4">and </span><span class="s2">(</span><span class="s1">r</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[-</span><span class="s5">1</span><span class="s2">] &gt; </span><span class="s5">1</span><span class="s2">):</span>
        <span class="s1">r </span><span class="s2">= </span><span class="s1">r</span><span class="s2">[</span><span class="s5">1</span><span class="s2">:]</span>
    <span class="s4">if </span><span class="s1">truepoly</span><span class="s2">:</span>
        <span class="s4">return </span><span class="s1">poly1d</span><span class="s2">(</span><span class="s1">q</span><span class="s2">), </span><span class="s1">poly1d</span><span class="s2">(</span><span class="s1">r</span><span class="s2">)</span>
    <span class="s4">return </span><span class="s1">q</span><span class="s2">, </span><span class="s1">r</span>

<span class="s1">_poly_mat </span><span class="s2">= </span><span class="s1">re</span><span class="s2">.</span><span class="s1">compile</span><span class="s2">(</span><span class="s3">r&quot;\*\*([0-9]*)&quot;</span><span class="s2">)</span>
<span class="s4">def </span><span class="s1">_raise_power</span><span class="s2">(</span><span class="s1">astr</span><span class="s2">, </span><span class="s1">wrap</span><span class="s2">=</span><span class="s5">70</span><span class="s2">):</span>
    <span class="s1">n </span><span class="s2">= </span><span class="s5">0</span>
    <span class="s1">line1 </span><span class="s2">= </span><span class="s3">''</span>
    <span class="s1">line2 </span><span class="s2">= </span><span class="s3">''</span>
    <span class="s1">output </span><span class="s2">= </span><span class="s3">' '</span>
    <span class="s4">while True</span><span class="s2">:</span>
        <span class="s1">mat </span><span class="s2">= </span><span class="s1">_poly_mat</span><span class="s2">.</span><span class="s1">search</span><span class="s2">(</span><span class="s1">astr</span><span class="s2">, </span><span class="s1">n</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">mat </span><span class="s4">is None</span><span class="s2">:</span>
            <span class="s4">break</span>
        <span class="s1">span </span><span class="s2">= </span><span class="s1">mat</span><span class="s2">.</span><span class="s1">span</span><span class="s2">()</span>
        <span class="s1">power </span><span class="s2">= </span><span class="s1">mat</span><span class="s2">.</span><span class="s1">groups</span><span class="s2">()[</span><span class="s5">0</span><span class="s2">]</span>
        <span class="s1">partstr </span><span class="s2">= </span><span class="s1">astr</span><span class="s2">[</span><span class="s1">n</span><span class="s2">:</span><span class="s1">span</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]]</span>
        <span class="s1">n </span><span class="s2">= </span><span class="s1">span</span><span class="s2">[</span><span class="s5">1</span><span class="s2">]</span>
        <span class="s1">toadd2 </span><span class="s2">= </span><span class="s1">partstr </span><span class="s2">+ </span><span class="s3">' '</span><span class="s2">*(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">power</span><span class="s2">)-</span><span class="s5">1</span><span class="s2">)</span>
        <span class="s1">toadd1 </span><span class="s2">= </span><span class="s3">' '</span><span class="s2">*(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">partstr</span><span class="s2">)-</span><span class="s5">1</span><span class="s2">) + </span><span class="s1">power</span>
        <span class="s4">if </span><span class="s2">((</span><span class="s1">len</span><span class="s2">(</span><span class="s1">line2</span><span class="s2">) + </span><span class="s1">len</span><span class="s2">(</span><span class="s1">toadd2</span><span class="s2">) &gt; </span><span class="s1">wrap</span><span class="s2">) </span><span class="s4">or</span>
                <span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">line1</span><span class="s2">) + </span><span class="s1">len</span><span class="s2">(</span><span class="s1">toadd1</span><span class="s2">) &gt; </span><span class="s1">wrap</span><span class="s2">)):</span>
            <span class="s1">output </span><span class="s2">+= </span><span class="s1">line1 </span><span class="s2">+ </span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3">&quot; </span><span class="s2">+ </span><span class="s1">line2 </span><span class="s2">+ </span><span class="s3">&quot;</span><span class="s4">\n </span><span class="s3">&quot;</span>
            <span class="s1">line1 </span><span class="s2">= </span><span class="s1">toadd1</span>
            <span class="s1">line2 </span><span class="s2">= </span><span class="s1">toadd2</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">line2 </span><span class="s2">+= </span><span class="s1">partstr </span><span class="s2">+ </span><span class="s3">' '</span><span class="s2">*(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">power</span><span class="s2">)-</span><span class="s5">1</span><span class="s2">)</span>
            <span class="s1">line1 </span><span class="s2">+= </span><span class="s3">' '</span><span class="s2">*(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">partstr</span><span class="s2">)-</span><span class="s5">1</span><span class="s2">) + </span><span class="s1">power</span>
    <span class="s1">output </span><span class="s2">+= </span><span class="s1">line1 </span><span class="s2">+ </span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3">&quot; </span><span class="s2">+ </span><span class="s1">line2</span>
    <span class="s4">return </span><span class="s1">output </span><span class="s2">+ </span><span class="s1">astr</span><span class="s2">[</span><span class="s1">n</span><span class="s2">:]</span>


<span class="s2">@</span><span class="s1">set_module</span><span class="s2">(</span><span class="s3">'numpy'</span><span class="s2">)</span>
<span class="s4">class </span><span class="s1">poly1d</span><span class="s2">:</span>
    <span class="s0">&quot;&quot;&quot; 
    A one-dimensional polynomial class. 
 
    .. note:: 
       This forms part of the old polynomial API. Since version 1.4, the 
       new polynomial API defined in `numpy.polynomial` is preferred. 
       A summary of the differences can be found in the 
       :doc:`transition guide &lt;/reference/routines.polynomials&gt;`. 
 
    A convenience class, used to encapsulate &quot;natural&quot; operations on 
    polynomials so that said operations may take on their customary 
    form in code (see Examples). 
 
    Parameters 
    ---------- 
    c_or_r : array_like 
        The polynomial's coefficients, in decreasing powers, or if 
        the value of the second parameter is True, the polynomial's 
        roots (values where the polynomial evaluates to 0).  For example, 
        ``poly1d([1, 2, 3])`` returns an object that represents 
        :math:`x^2 + 2x + 3`, whereas ``poly1d([1, 2, 3], True)`` returns 
        one that represents :math:`(x-1)(x-2)(x-3) = x^3 - 6x^2 + 11x -6`. 
    r : bool, optional 
        If True, `c_or_r` specifies the polynomial's roots; the default 
        is False. 
    variable : str, optional 
        Changes the variable used when printing `p` from `x` to `variable` 
        (see Examples). 
 
    Examples 
    -------- 
    Construct the polynomial :math:`x^2 + 2x + 3`: 
 
    &gt;&gt;&gt; import numpy as np 
 
    &gt;&gt;&gt; p = np.poly1d([1, 2, 3]) 
    &gt;&gt;&gt; print(np.poly1d(p)) 
       2 
    1 x + 2 x + 3 
 
    Evaluate the polynomial at :math:`x = 0.5`: 
 
    &gt;&gt;&gt; p(0.5) 
    4.25 
 
    Find the roots: 
 
    &gt;&gt;&gt; p.r 
    array([-1.+1.41421356j, -1.-1.41421356j]) 
    &gt;&gt;&gt; p(p.r) 
    array([ -4.44089210e-16+0.j,  -4.44089210e-16+0.j]) # may vary 
 
    These numbers in the previous line represent (0, 0) to machine precision 
 
    Show the coefficients: 
 
    &gt;&gt;&gt; p.c 
    array([1, 2, 3]) 
 
    Display the order (the leading zero-coefficients are removed): 
 
    &gt;&gt;&gt; p.order 
    2 
 
    Show the coefficient of the k-th power in the polynomial 
    (which is equivalent to ``p.c[-(i+1)]``): 
 
    &gt;&gt;&gt; p[1] 
    2 
 
    Polynomials can be added, subtracted, multiplied, and divided 
    (returns quotient and remainder): 
 
    &gt;&gt;&gt; p * p 
    poly1d([ 1,  4, 10, 12,  9]) 
 
    &gt;&gt;&gt; (p**3 + 4) / p 
    (poly1d([ 1.,  4., 10., 12.,  9.]), poly1d([4.])) 
 
    ``asarray(p)`` gives the coefficient array, so polynomials can be 
    used in all functions that accept arrays: 
 
    &gt;&gt;&gt; p**2 # square of polynomial 
    poly1d([ 1,  4, 10, 12,  9]) 
 
    &gt;&gt;&gt; np.square(p) # square of individual coefficients 
    array([1, 4, 9]) 
 
    The variable used in the string representation of `p` can be modified, 
    using the `variable` parameter: 
 
    &gt;&gt;&gt; p = np.poly1d([1,2,3], variable='z') 
    &gt;&gt;&gt; print(p) 
       2 
    1 z + 2 z + 3 
 
    Construct a polynomial from its roots: 
 
    &gt;&gt;&gt; np.poly1d([1, 2], True) 
    poly1d([ 1., -3.,  2.]) 
 
    This is the same polynomial as obtained by: 
 
    &gt;&gt;&gt; np.poly1d([1, -1]) * np.poly1d([1, -2]) 
    poly1d([ 1, -3,  2]) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">__hash__ </span><span class="s2">= </span><span class="s4">None</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s4">def </span><span class="s1">coeffs</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot; The polynomial coefficients &quot;&quot;&quot;</span>
        <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_coeffs</span>

    <span class="s2">@</span><span class="s1">coeffs</span><span class="s2">.</span><span class="s1">setter</span>
    <span class="s4">def </span><span class="s1">coeffs</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">value</span><span class="s2">):</span>
        <span class="s6"># allowing this makes p.coeffs *= 2 legal</span>
        <span class="s4">if </span><span class="s1">value </span><span class="s4">is not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_coeffs</span><span class="s2">:</span>
            <span class="s4">raise </span><span class="s1">AttributeError</span><span class="s2">(</span><span class="s3">&quot;Cannot set attribute&quot;</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s4">def </span><span class="s1">variable</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot; The name of the polynomial variable &quot;&quot;&quot;</span>
        <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_variable</span>

    <span class="s6"># calculated attributes</span>
    <span class="s2">@</span><span class="s1">property</span>
    <span class="s4">def </span><span class="s1">order</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot; The order or degree of the polynomial &quot;&quot;&quot;</span>
        <span class="s4">return </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_coeffs</span><span class="s2">) - </span><span class="s5">1</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s4">def </span><span class="s1">roots</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot; The roots of the polynomial, where self(x) == 0 &quot;&quot;&quot;</span>
        <span class="s4">return </span><span class="s1">roots</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_coeffs</span><span class="s2">)</span>

    <span class="s6"># our internal _coeffs property need to be backed by __dict__['coeffs'] for</span>
    <span class="s6"># scipy to work correctly.</span>
    <span class="s2">@</span><span class="s1">property</span>
    <span class="s4">def </span><span class="s1">_coeffs</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__dict__</span><span class="s2">[</span><span class="s3">'coeffs'</span><span class="s2">]</span>
    <span class="s2">@</span><span class="s1">_coeffs</span><span class="s2">.</span><span class="s1">setter</span>
    <span class="s4">def </span><span class="s1">_coeffs</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">coeffs</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">__dict__</span><span class="s2">[</span><span class="s3">'coeffs'</span><span class="s2">] = </span><span class="s1">coeffs</span>

    <span class="s6"># alias attributes</span>
    <span class="s1">r </span><span class="s2">= </span><span class="s1">roots</span>
    <span class="s1">c </span><span class="s2">= </span><span class="s1">coef </span><span class="s2">= </span><span class="s1">coefficients </span><span class="s2">= </span><span class="s1">coeffs</span>
    <span class="s1">o </span><span class="s2">= </span><span class="s1">order</span>

    <span class="s4">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">c_or_r</span><span class="s2">, </span><span class="s1">r</span><span class="s2">=</span><span class="s4">False</span><span class="s2">, </span><span class="s1">variable</span><span class="s2">=</span><span class="s4">None</span><span class="s2">):</span>
        <span class="s4">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">c_or_r</span><span class="s2">, </span><span class="s1">poly1d</span><span class="s2">):</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_variable </span><span class="s2">= </span><span class="s1">c_or_r</span><span class="s2">.</span><span class="s1">_variable</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_coeffs </span><span class="s2">= </span><span class="s1">c_or_r</span><span class="s2">.</span><span class="s1">_coeffs</span>

            <span class="s4">if </span><span class="s1">set</span><span class="s2">(</span><span class="s1">c_or_r</span><span class="s2">.</span><span class="s1">__dict__</span><span class="s2">) - </span><span class="s1">set</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">__dict__</span><span class="s2">):</span>
                <span class="s1">msg </span><span class="s2">= (</span><span class="s3">&quot;In the future extra properties will not be copied &quot;</span>
                       <span class="s3">&quot;across when constructing one poly1d from another&quot;</span><span class="s2">)</span>
                <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">, </span><span class="s1">FutureWarning</span><span class="s2">, </span><span class="s1">stacklevel</span><span class="s2">=</span><span class="s5">2</span><span class="s2">)</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">__dict__</span><span class="s2">.</span><span class="s1">update</span><span class="s2">(</span><span class="s1">c_or_r</span><span class="s2">.</span><span class="s1">__dict__</span><span class="s2">)</span>

            <span class="s4">if </span><span class="s1">variable </span><span class="s4">is not None</span><span class="s2">:</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">_variable </span><span class="s2">= </span><span class="s1">variable</span>
            <span class="s4">return</span>
        <span class="s4">if </span><span class="s1">r</span><span class="s2">:</span>
            <span class="s1">c_or_r </span><span class="s2">= </span><span class="s1">poly</span><span class="s2">(</span><span class="s1">c_or_r</span><span class="s2">)</span>
        <span class="s1">c_or_r </span><span class="s2">= </span><span class="s1">atleast_1d</span><span class="s2">(</span><span class="s1">c_or_r</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">c_or_r</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">&gt; </span><span class="s5">1</span><span class="s2">:</span>
            <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;Polynomial must be 1d only.&quot;</span><span class="s2">)</span>
        <span class="s1">c_or_r </span><span class="s2">= </span><span class="s1">trim_zeros</span><span class="s2">(</span><span class="s1">c_or_r</span><span class="s2">, </span><span class="s1">trim</span><span class="s2">=</span><span class="s3">'f'</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">c_or_r</span><span class="s2">) == </span><span class="s5">0</span><span class="s2">:</span>
            <span class="s1">c_or_r </span><span class="s2">= </span><span class="s1">NX</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s5">0</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">c_or_r</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_coeffs </span><span class="s2">= </span><span class="s1">c_or_r</span>
        <span class="s4">if </span><span class="s1">variable </span><span class="s4">is None</span><span class="s2">:</span>
            <span class="s1">variable </span><span class="s2">= </span><span class="s3">'x'</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_variable </span><span class="s2">= </span><span class="s1">variable</span>

    <span class="s4">def </span><span class="s1">__array__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">t</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s4">None</span><span class="s2">):</span>
        <span class="s4">if </span><span class="s1">t</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s1">NX</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">coeffs</span><span class="s2">, </span><span class="s1">t</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s1">copy</span><span class="s2">)</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s1">NX</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">coeffs</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s1">copy</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">__repr__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">vals </span><span class="s2">= </span><span class="s1">repr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">coeffs</span><span class="s2">)</span>
        <span class="s1">vals </span><span class="s2">= </span><span class="s1">vals</span><span class="s2">[</span><span class="s5">6</span><span class="s2">:-</span><span class="s5">1</span><span class="s2">]</span>
        <span class="s4">return </span><span class="s3">&quot;poly1d(%s)&quot; </span><span class="s2">% </span><span class="s1">vals</span>

    <span class="s4">def </span><span class="s1">__len__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">order</span>

    <span class="s4">def </span><span class="s1">__str__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">thestr </span><span class="s2">= </span><span class="s3">&quot;0&quot;</span>
        <span class="s1">var </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">variable</span>

        <span class="s6"># Remove leading zeros</span>
        <span class="s1">coeffs </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">coeffs</span><span class="s2">[</span><span class="s1">NX</span><span class="s2">.</span><span class="s1">logical_or</span><span class="s2">.</span><span class="s1">accumulate</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">coeffs </span><span class="s2">!= </span><span class="s5">0</span><span class="s2">)]</span>
        <span class="s1">N </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">coeffs</span><span class="s2">)-</span><span class="s5">1</span>

        <span class="s4">def </span><span class="s1">fmt_float</span><span class="s2">(</span><span class="s1">q</span><span class="s2">):</span>
            <span class="s1">s </span><span class="s2">= </span><span class="s3">'%.4g' </span><span class="s2">% </span><span class="s1">q</span>
            <span class="s4">if </span><span class="s1">s</span><span class="s2">.</span><span class="s1">endswith</span><span class="s2">(</span><span class="s3">'.0000'</span><span class="s2">):</span>
                <span class="s1">s </span><span class="s2">= </span><span class="s1">s</span><span class="s2">[:-</span><span class="s5">5</span><span class="s2">]</span>
            <span class="s4">return </span><span class="s1">s</span>

        <span class="s4">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">coeff </span><span class="s4">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">coeffs</span><span class="s2">):</span>
            <span class="s4">if not </span><span class="s1">iscomplex</span><span class="s2">(</span><span class="s1">coeff</span><span class="s2">):</span>
                <span class="s1">coefstr </span><span class="s2">= </span><span class="s1">fmt_float</span><span class="s2">(</span><span class="s1">real</span><span class="s2">(</span><span class="s1">coeff</span><span class="s2">))</span>
            <span class="s4">elif </span><span class="s1">real</span><span class="s2">(</span><span class="s1">coeff</span><span class="s2">) == </span><span class="s5">0</span><span class="s2">:</span>
                <span class="s1">coefstr </span><span class="s2">= </span><span class="s3">'%sj' </span><span class="s2">% </span><span class="s1">fmt_float</span><span class="s2">(</span><span class="s1">imag</span><span class="s2">(</span><span class="s1">coeff</span><span class="s2">))</span>
            <span class="s4">else</span><span class="s2">:</span>
                <span class="s1">coefstr </span><span class="s2">= </span><span class="s3">'(%s + %sj)' </span><span class="s2">% (</span><span class="s1">fmt_float</span><span class="s2">(</span><span class="s1">real</span><span class="s2">(</span><span class="s1">coeff</span><span class="s2">)),</span>
                                          <span class="s1">fmt_float</span><span class="s2">(</span><span class="s1">imag</span><span class="s2">(</span><span class="s1">coeff</span><span class="s2">)))</span>

            <span class="s1">power </span><span class="s2">= (</span><span class="s1">N</span><span class="s2">-</span><span class="s1">k</span><span class="s2">)</span>
            <span class="s4">if </span><span class="s1">power </span><span class="s2">== </span><span class="s5">0</span><span class="s2">:</span>
                <span class="s4">if </span><span class="s1">coefstr </span><span class="s2">!= </span><span class="s3">'0'</span><span class="s2">:</span>
                    <span class="s1">newstr </span><span class="s2">= </span><span class="s3">'%s' </span><span class="s2">% (</span><span class="s1">coefstr</span><span class="s2">,)</span>
                <span class="s4">else</span><span class="s2">:</span>
                    <span class="s4">if </span><span class="s1">k </span><span class="s2">== </span><span class="s5">0</span><span class="s2">:</span>
                        <span class="s1">newstr </span><span class="s2">= </span><span class="s3">'0'</span>
                    <span class="s4">else</span><span class="s2">:</span>
                        <span class="s1">newstr </span><span class="s2">= </span><span class="s3">''</span>
            <span class="s4">elif </span><span class="s1">power </span><span class="s2">== </span><span class="s5">1</span><span class="s2">:</span>
                <span class="s4">if </span><span class="s1">coefstr </span><span class="s2">== </span><span class="s3">'0'</span><span class="s2">:</span>
                    <span class="s1">newstr </span><span class="s2">= </span><span class="s3">''</span>
                <span class="s4">elif </span><span class="s1">coefstr </span><span class="s2">== </span><span class="s3">'b'</span><span class="s2">:</span>
                    <span class="s1">newstr </span><span class="s2">= </span><span class="s1">var</span>
                <span class="s4">else</span><span class="s2">:</span>
                    <span class="s1">newstr </span><span class="s2">= </span><span class="s3">'%s %s' </span><span class="s2">% (</span><span class="s1">coefstr</span><span class="s2">, </span><span class="s1">var</span><span class="s2">)</span>
            <span class="s4">else</span><span class="s2">:</span>
                <span class="s4">if </span><span class="s1">coefstr </span><span class="s2">== </span><span class="s3">'0'</span><span class="s2">:</span>
                    <span class="s1">newstr </span><span class="s2">= </span><span class="s3">''</span>
                <span class="s4">elif </span><span class="s1">coefstr </span><span class="s2">== </span><span class="s3">'b'</span><span class="s2">:</span>
                    <span class="s1">newstr </span><span class="s2">= </span><span class="s3">'%s**%d' </span><span class="s2">% (</span><span class="s1">var</span><span class="s2">, </span><span class="s1">power</span><span class="s2">,)</span>
                <span class="s4">else</span><span class="s2">:</span>
                    <span class="s1">newstr </span><span class="s2">= </span><span class="s3">'%s %s**%d' </span><span class="s2">% (</span><span class="s1">coefstr</span><span class="s2">, </span><span class="s1">var</span><span class="s2">, </span><span class="s1">power</span><span class="s2">)</span>

            <span class="s4">if </span><span class="s1">k </span><span class="s2">&gt; </span><span class="s5">0</span><span class="s2">:</span>
                <span class="s4">if </span><span class="s1">newstr </span><span class="s2">!= </span><span class="s3">''</span><span class="s2">:</span>
                    <span class="s4">if </span><span class="s1">newstr</span><span class="s2">.</span><span class="s1">startswith</span><span class="s2">(</span><span class="s3">'-'</span><span class="s2">):</span>
                        <span class="s1">thestr </span><span class="s2">= </span><span class="s3">&quot;%s - %s&quot; </span><span class="s2">% (</span><span class="s1">thestr</span><span class="s2">, </span><span class="s1">newstr</span><span class="s2">[</span><span class="s5">1</span><span class="s2">:])</span>
                    <span class="s4">else</span><span class="s2">:</span>
                        <span class="s1">thestr </span><span class="s2">= </span><span class="s3">&quot;%s + %s&quot; </span><span class="s2">% (</span><span class="s1">thestr</span><span class="s2">, </span><span class="s1">newstr</span><span class="s2">)</span>
            <span class="s4">else</span><span class="s2">:</span>
                <span class="s1">thestr </span><span class="s2">= </span><span class="s1">newstr</span>
        <span class="s4">return </span><span class="s1">_raise_power</span><span class="s2">(</span><span class="s1">thestr</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">__call__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">val</span><span class="s2">):</span>
        <span class="s4">return </span><span class="s1">polyval</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">coeffs</span><span class="s2">, </span><span class="s1">val</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">__neg__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s4">return </span><span class="s1">poly1d</span><span class="s2">(-</span><span class="s1">self</span><span class="s2">.</span><span class="s1">coeffs</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">__pos__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s4">return </span><span class="s1">self</span>

    <span class="s4">def </span><span class="s1">__mul__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">):</span>
        <span class="s4">if </span><span class="s1">isscalar</span><span class="s2">(</span><span class="s1">other</span><span class="s2">):</span>
            <span class="s4">return </span><span class="s1">poly1d</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">coeffs </span><span class="s2">* </span><span class="s1">other</span><span class="s2">)</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">other </span><span class="s2">= </span><span class="s1">poly1d</span><span class="s2">(</span><span class="s1">other</span><span class="s2">)</span>
            <span class="s4">return </span><span class="s1">poly1d</span><span class="s2">(</span><span class="s1">polymul</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">coeffs</span><span class="s2">, </span><span class="s1">other</span><span class="s2">.</span><span class="s1">coeffs</span><span class="s2">))</span>

    <span class="s4">def </span><span class="s1">__rmul__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">):</span>
        <span class="s4">if </span><span class="s1">isscalar</span><span class="s2">(</span><span class="s1">other</span><span class="s2">):</span>
            <span class="s4">return </span><span class="s1">poly1d</span><span class="s2">(</span><span class="s1">other </span><span class="s2">* </span><span class="s1">self</span><span class="s2">.</span><span class="s1">coeffs</span><span class="s2">)</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">other </span><span class="s2">= </span><span class="s1">poly1d</span><span class="s2">(</span><span class="s1">other</span><span class="s2">)</span>
            <span class="s4">return </span><span class="s1">poly1d</span><span class="s2">(</span><span class="s1">polymul</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">coeffs</span><span class="s2">, </span><span class="s1">other</span><span class="s2">.</span><span class="s1">coeffs</span><span class="s2">))</span>

    <span class="s4">def </span><span class="s1">__add__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">):</span>
        <span class="s1">other </span><span class="s2">= </span><span class="s1">poly1d</span><span class="s2">(</span><span class="s1">other</span><span class="s2">)</span>
        <span class="s4">return </span><span class="s1">poly1d</span><span class="s2">(</span><span class="s1">polyadd</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">coeffs</span><span class="s2">, </span><span class="s1">other</span><span class="s2">.</span><span class="s1">coeffs</span><span class="s2">))</span>

    <span class="s4">def </span><span class="s1">__radd__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">):</span>
        <span class="s1">other </span><span class="s2">= </span><span class="s1">poly1d</span><span class="s2">(</span><span class="s1">other</span><span class="s2">)</span>
        <span class="s4">return </span><span class="s1">poly1d</span><span class="s2">(</span><span class="s1">polyadd</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">coeffs</span><span class="s2">, </span><span class="s1">other</span><span class="s2">.</span><span class="s1">coeffs</span><span class="s2">))</span>

    <span class="s4">def </span><span class="s1">__pow__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">val</span><span class="s2">):</span>
        <span class="s4">if not </span><span class="s1">isscalar</span><span class="s2">(</span><span class="s1">val</span><span class="s2">) </span><span class="s4">or </span><span class="s1">int</span><span class="s2">(</span><span class="s1">val</span><span class="s2">) != </span><span class="s1">val </span><span class="s4">or </span><span class="s1">val </span><span class="s2">&lt; </span><span class="s5">0</span><span class="s2">:</span>
            <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;Power to non-negative integers only.&quot;</span><span class="s2">)</span>
        <span class="s1">res </span><span class="s2">= [</span><span class="s5">1</span><span class="s2">]</span>
        <span class="s4">for </span><span class="s1">_ </span><span class="s4">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">val</span><span class="s2">):</span>
            <span class="s1">res </span><span class="s2">= </span><span class="s1">polymul</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">coeffs</span><span class="s2">, </span><span class="s1">res</span><span class="s2">)</span>
        <span class="s4">return </span><span class="s1">poly1d</span><span class="s2">(</span><span class="s1">res</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">__sub__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">):</span>
        <span class="s1">other </span><span class="s2">= </span><span class="s1">poly1d</span><span class="s2">(</span><span class="s1">other</span><span class="s2">)</span>
        <span class="s4">return </span><span class="s1">poly1d</span><span class="s2">(</span><span class="s1">polysub</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">coeffs</span><span class="s2">, </span><span class="s1">other</span><span class="s2">.</span><span class="s1">coeffs</span><span class="s2">))</span>

    <span class="s4">def </span><span class="s1">__rsub__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">):</span>
        <span class="s1">other </span><span class="s2">= </span><span class="s1">poly1d</span><span class="s2">(</span><span class="s1">other</span><span class="s2">)</span>
        <span class="s4">return </span><span class="s1">poly1d</span><span class="s2">(</span><span class="s1">polysub</span><span class="s2">(</span><span class="s1">other</span><span class="s2">.</span><span class="s1">coeffs</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">coeffs</span><span class="s2">))</span>

    <span class="s4">def </span><span class="s1">__div__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">):</span>
        <span class="s4">if </span><span class="s1">isscalar</span><span class="s2">(</span><span class="s1">other</span><span class="s2">):</span>
            <span class="s4">return </span><span class="s1">poly1d</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">coeffs</span><span class="s2">/</span><span class="s1">other</span><span class="s2">)</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">other </span><span class="s2">= </span><span class="s1">poly1d</span><span class="s2">(</span><span class="s1">other</span><span class="s2">)</span>
            <span class="s4">return </span><span class="s1">polydiv</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">)</span>

    <span class="s1">__truediv__ </span><span class="s2">= </span><span class="s1">__div__</span>

    <span class="s4">def </span><span class="s1">__rdiv__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">):</span>
        <span class="s4">if </span><span class="s1">isscalar</span><span class="s2">(</span><span class="s1">other</span><span class="s2">):</span>
            <span class="s4">return </span><span class="s1">poly1d</span><span class="s2">(</span><span class="s1">other</span><span class="s2">/</span><span class="s1">self</span><span class="s2">.</span><span class="s1">coeffs</span><span class="s2">)</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">other </span><span class="s2">= </span><span class="s1">poly1d</span><span class="s2">(</span><span class="s1">other</span><span class="s2">)</span>
            <span class="s4">return </span><span class="s1">polydiv</span><span class="s2">(</span><span class="s1">other</span><span class="s2">, </span><span class="s1">self</span><span class="s2">)</span>

    <span class="s1">__rtruediv__ </span><span class="s2">= </span><span class="s1">__rdiv__</span>

    <span class="s4">def </span><span class="s1">__eq__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">):</span>
        <span class="s4">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">other</span><span class="s2">, </span><span class="s1">poly1d</span><span class="s2">):</span>
            <span class="s4">return </span><span class="s1">NotImplemented</span>
        <span class="s4">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">coeffs</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">!= </span><span class="s1">other</span><span class="s2">.</span><span class="s1">coeffs</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">:</span>
            <span class="s4">return False</span>
        <span class="s4">return </span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">coeffs </span><span class="s2">== </span><span class="s1">other</span><span class="s2">.</span><span class="s1">coeffs</span><span class="s2">).</span><span class="s1">all</span><span class="s2">()</span>

    <span class="s4">def </span><span class="s1">__ne__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">):</span>
        <span class="s4">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">other</span><span class="s2">, </span><span class="s1">poly1d</span><span class="s2">):</span>
            <span class="s4">return </span><span class="s1">NotImplemented</span>
        <span class="s4">return not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__eq__</span><span class="s2">(</span><span class="s1">other</span><span class="s2">)</span>


    <span class="s4">def </span><span class="s1">__getitem__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">val</span><span class="s2">):</span>
        <span class="s1">ind </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">order </span><span class="s2">- </span><span class="s1">val</span>
        <span class="s4">if </span><span class="s1">val </span><span class="s2">&gt; </span><span class="s1">self</span><span class="s2">.</span><span class="s1">order</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">coeffs</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">type</span><span class="s2">(</span><span class="s5">0</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">val </span><span class="s2">&lt; </span><span class="s5">0</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">coeffs</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">type</span><span class="s2">(</span><span class="s5">0</span><span class="s2">)</span>
        <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">coeffs</span><span class="s2">[</span><span class="s1">ind</span><span class="s2">]</span>

    <span class="s4">def </span><span class="s1">__setitem__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">val</span><span class="s2">):</span>
        <span class="s1">ind </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">order </span><span class="s2">- </span><span class="s1">key</span>
        <span class="s4">if </span><span class="s1">key </span><span class="s2">&lt; </span><span class="s5">0</span><span class="s2">:</span>
            <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;Does not support negative powers.&quot;</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">key </span><span class="s2">&gt; </span><span class="s1">self</span><span class="s2">.</span><span class="s1">order</span><span class="s2">:</span>
            <span class="s1">zr </span><span class="s2">= </span><span class="s1">NX</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">(</span><span class="s1">key</span><span class="s2">-</span><span class="s1">self</span><span class="s2">.</span><span class="s1">order</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">coeffs</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_coeffs </span><span class="s2">= </span><span class="s1">NX</span><span class="s2">.</span><span class="s1">concatenate</span><span class="s2">((</span><span class="s1">zr</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">coeffs</span><span class="s2">))</span>
            <span class="s1">ind </span><span class="s2">= </span><span class="s5">0</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_coeffs</span><span class="s2">[</span><span class="s1">ind</span><span class="s2">] = </span><span class="s1">val</span>
        <span class="s4">return</span>

    <span class="s4">def </span><span class="s1">__iter__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s4">return </span><span class="s1">iter</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">coeffs</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">integ</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">m</span><span class="s2">=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">k</span><span class="s2">=</span><span class="s5">0</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return an antiderivative (indefinite integral) of this polynomial. 
 
        Refer to `polyint` for full documentation. 
 
        See Also 
        -------- 
        polyint : equivalent function 
 
        &quot;&quot;&quot;</span>
        <span class="s4">return </span><span class="s1">poly1d</span><span class="s2">(</span><span class="s1">polyint</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">coeffs</span><span class="s2">, </span><span class="s1">m</span><span class="s2">=</span><span class="s1">m</span><span class="s2">, </span><span class="s1">k</span><span class="s2">=</span><span class="s1">k</span><span class="s2">))</span>

    <span class="s4">def </span><span class="s1">deriv</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">m</span><span class="s2">=</span><span class="s5">1</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return a derivative of this polynomial. 
 
        Refer to `polyder` for full documentation. 
 
        See Also 
        -------- 
        polyder : equivalent function 
 
        &quot;&quot;&quot;</span>
        <span class="s4">return </span><span class="s1">poly1d</span><span class="s2">(</span><span class="s1">polyder</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">coeffs</span><span class="s2">, </span><span class="s1">m</span><span class="s2">=</span><span class="s1">m</span><span class="s2">))</span>

<span class="s6"># Stuff to do on module import</span>

<span class="s1">warnings</span><span class="s2">.</span><span class="s1">simplefilter</span><span class="s2">(</span><span class="s3">'always'</span><span class="s2">, </span><span class="s1">RankWarning</span><span class="s2">)</span>
</pre>
</body>
</html>