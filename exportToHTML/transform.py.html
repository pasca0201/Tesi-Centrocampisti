<html>
<head>
<title>transform.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #6aab73;}
.s5 { color: #2aacb8;}
.s6 { color: #7a7e85;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
transform.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Affine 2D transformation matrix class. 
 
The Transform class implements various transformation matrix operations, 
both on the matrix itself, as well as on 2D coordinates. 
 
Transform instances are effectively immutable: all methods that operate on the 
transformation itself always return a new instance. This has as the 
interesting side effect that Transform instances are hashable, ie. they can be 
used as dictionary keys. 
 
This module exports the following symbols: 
 
Transform 
    this is the main class 
Identity 
    Transform instance set to the identity transformation 
Offset 
    Convenience function that returns a translating transformation 
Scale 
    Convenience function that returns a scaling transformation 
 
The DecomposedTransform class implements a transformation with separate 
translate, rotation, scale, skew, and transformation-center components. 
 
:Example: 
 
    &gt;&gt;&gt; t = Transform(2, 0, 0, 3, 0, 0) 
    &gt;&gt;&gt; t.transformPoint((100, 100)) 
    (200, 300) 
    &gt;&gt;&gt; t = Scale(2, 3) 
    &gt;&gt;&gt; t.transformPoint((100, 100)) 
    (200, 300) 
    &gt;&gt;&gt; t.transformPoint((0, 0)) 
    (0, 0) 
    &gt;&gt;&gt; t = Offset(2, 3) 
    &gt;&gt;&gt; t.transformPoint((100, 100)) 
    (102, 103) 
    &gt;&gt;&gt; t.transformPoint((0, 0)) 
    (2, 3) 
    &gt;&gt;&gt; t2 = t.scale(0.5) 
    &gt;&gt;&gt; t2.transformPoint((100, 100)) 
    (52.0, 53.0) 
    &gt;&gt;&gt; import math 
    &gt;&gt;&gt; t3 = t2.rotate(math.pi / 2) 
    &gt;&gt;&gt; t3.transformPoint((0, 0)) 
    (2.0, 3.0) 
    &gt;&gt;&gt; t3.transformPoint((100, 100)) 
    (-48.0, 53.0) 
    &gt;&gt;&gt; t = Identity.scale(0.5).translate(100, 200).skew(0.1, 0.2) 
    &gt;&gt;&gt; t.transformPoints([(0, 0), (1, 1), (100, 100)]) 
    [(50.0, 100.0), (50.550167336042726, 100.60135501775433), (105.01673360427253, 160.13550177543362)] 
    &gt;&gt;&gt; 
&quot;&quot;&quot;</span>

<span class="s2">import </span><span class="s1">math</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">NamedTuple</span>
<span class="s2">from </span><span class="s1">dataclasses </span><span class="s2">import </span><span class="s1">dataclass</span>


<span class="s1">__all__ </span><span class="s3">= [</span><span class="s4">&quot;Transform&quot;</span><span class="s3">, </span><span class="s4">&quot;Identity&quot;</span><span class="s3">, </span><span class="s4">&quot;Offset&quot;</span><span class="s3">, </span><span class="s4">&quot;Scale&quot;</span><span class="s3">, </span><span class="s4">&quot;DecomposedTransform&quot;</span><span class="s3">]</span>


<span class="s1">_EPSILON </span><span class="s3">= </span><span class="s5">1e-15</span>
<span class="s1">_ONE_EPSILON </span><span class="s3">= </span><span class="s5">1 </span><span class="s3">- </span><span class="s1">_EPSILON</span>
<span class="s1">_MINUS_ONE_EPSILON </span><span class="s3">= -</span><span class="s5">1 </span><span class="s3">+ </span><span class="s1">_EPSILON</span>


<span class="s2">def </span><span class="s1">_normSinCos</span><span class="s3">(</span><span class="s1">v</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">v</span><span class="s3">) &lt; </span><span class="s1">_EPSILON</span><span class="s3">:</span>
        <span class="s1">v </span><span class="s3">= </span><span class="s5">0</span>
    <span class="s2">elif </span><span class="s1">v </span><span class="s3">&gt; </span><span class="s1">_ONE_EPSILON</span><span class="s3">:</span>
        <span class="s1">v </span><span class="s3">= </span><span class="s5">1</span>
    <span class="s2">elif </span><span class="s1">v </span><span class="s3">&lt; </span><span class="s1">_MINUS_ONE_EPSILON</span><span class="s3">:</span>
        <span class="s1">v </span><span class="s3">= -</span><span class="s5">1</span>
    <span class="s2">return </span><span class="s1">v</span>


<span class="s2">class </span><span class="s1">Transform</span><span class="s3">(</span><span class="s1">NamedTuple</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;2x2 transformation matrix plus offset, a.k.a. Affine transform. 
    Transform instances are immutable: all transforming methods, eg. 
    rotate(), return a new Transform instance. 
 
    :Example: 
 
            &gt;&gt;&gt; t = Transform() 
            &gt;&gt;&gt; t 
            &lt;Transform [1 0 0 1 0 0]&gt; 
            &gt;&gt;&gt; t.scale(2) 
            &lt;Transform [2 0 0 2 0 0]&gt; 
            &gt;&gt;&gt; t.scale(2.5, 5.5) 
            &lt;Transform [2.5 0 0 5.5 0 0]&gt; 
            &gt;&gt;&gt; 
            &gt;&gt;&gt; t.scale(2, 3).transformPoint((100, 100)) 
            (200, 300) 
 
    Transform's constructor takes six arguments, all of which are 
    optional, and can be used as keyword arguments:: 
 
            &gt;&gt;&gt; Transform(12) 
            &lt;Transform [12 0 0 1 0 0]&gt; 
            &gt;&gt;&gt; Transform(dx=12) 
            &lt;Transform [1 0 0 1 12 0]&gt; 
            &gt;&gt;&gt; Transform(yx=12) 
            &lt;Transform [1 0 12 1 0 0]&gt; 
 
    Transform instances also behave like sequences of length 6:: 
 
            &gt;&gt;&gt; len(Identity) 
            6 
            &gt;&gt;&gt; list(Identity) 
            [1, 0, 0, 1, 0, 0] 
            &gt;&gt;&gt; tuple(Identity) 
            (1, 0, 0, 1, 0, 0) 
 
    Transform instances are comparable:: 
 
            &gt;&gt;&gt; t1 = Identity.scale(2, 3).translate(4, 6) 
            &gt;&gt;&gt; t2 = Identity.translate(8, 18).scale(2, 3) 
            &gt;&gt;&gt; t1 == t2 
            1 
 
    But beware of floating point rounding errors:: 
 
            &gt;&gt;&gt; t1 = Identity.scale(0.2, 0.3).translate(0.4, 0.6) 
            &gt;&gt;&gt; t2 = Identity.translate(0.08, 0.18).scale(0.2, 0.3) 
            &gt;&gt;&gt; t1 
            &lt;Transform [0.2 0 0 0.3 0.08 0.18]&gt; 
            &gt;&gt;&gt; t2 
            &lt;Transform [0.2 0 0 0.3 0.08 0.18]&gt; 
            &gt;&gt;&gt; t1 == t2 
            0 
 
    Transform instances are hashable, meaning you can use them as 
    keys in dictionaries:: 
 
            &gt;&gt;&gt; d = {Scale(12, 13): None} 
            &gt;&gt;&gt; d 
            {&lt;Transform [12 0 0 13 0 0]&gt;: None} 
 
    But again, beware of floating point rounding errors:: 
 
            &gt;&gt;&gt; t1 = Identity.scale(0.2, 0.3).translate(0.4, 0.6) 
            &gt;&gt;&gt; t2 = Identity.translate(0.08, 0.18).scale(0.2, 0.3) 
            &gt;&gt;&gt; t1 
            &lt;Transform [0.2 0 0 0.3 0.08 0.18]&gt; 
            &gt;&gt;&gt; t2 
            &lt;Transform [0.2 0 0 0.3 0.08 0.18]&gt; 
            &gt;&gt;&gt; d = {t1: None} 
            &gt;&gt;&gt; d 
            {&lt;Transform [0.2 0 0 0.3 0.08 0.18]&gt;: None} 
            &gt;&gt;&gt; d[t2] 
            Traceback (most recent call last): 
              File &quot;&lt;stdin&gt;&quot;, line 1, in ? 
            KeyError: &lt;Transform [0.2 0 0 0.3 0.08 0.18]&gt; 
    &quot;&quot;&quot;</span>

    <span class="s1">xx</span><span class="s3">: </span><span class="s1">float </span><span class="s3">= </span><span class="s5">1</span>
    <span class="s1">xy</span><span class="s3">: </span><span class="s1">float </span><span class="s3">= </span><span class="s5">0</span>
    <span class="s1">yx</span><span class="s3">: </span><span class="s1">float </span><span class="s3">= </span><span class="s5">0</span>
    <span class="s1">yy</span><span class="s3">: </span><span class="s1">float </span><span class="s3">= </span><span class="s5">1</span>
    <span class="s1">dx</span><span class="s3">: </span><span class="s1">float </span><span class="s3">= </span><span class="s5">0</span>
    <span class="s1">dy</span><span class="s3">: </span><span class="s1">float </span><span class="s3">= </span><span class="s5">0</span>

    <span class="s2">def </span><span class="s1">transformPoint</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Transform a point. 
 
        :Example: 
 
                &gt;&gt;&gt; t = Transform() 
                &gt;&gt;&gt; t = t.scale(2.5, 5.5) 
                &gt;&gt;&gt; t.transformPoint((100, 100)) 
                (250.0, 550.0) 
        &quot;&quot;&quot;</span>
        <span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">) = </span><span class="s1">p</span>
        <span class="s1">xx</span><span class="s3">, </span><span class="s1">xy</span><span class="s3">, </span><span class="s1">yx</span><span class="s3">, </span><span class="s1">yy</span><span class="s3">, </span><span class="s1">dx</span><span class="s3">, </span><span class="s1">dy </span><span class="s3">= </span><span class="s1">self</span>
        <span class="s2">return </span><span class="s3">(</span><span class="s1">xx </span><span class="s3">* </span><span class="s1">x </span><span class="s3">+ </span><span class="s1">yx </span><span class="s3">* </span><span class="s1">y </span><span class="s3">+ </span><span class="s1">dx</span><span class="s3">, </span><span class="s1">xy </span><span class="s3">* </span><span class="s1">x </span><span class="s3">+ </span><span class="s1">yy </span><span class="s3">* </span><span class="s1">y </span><span class="s3">+ </span><span class="s1">dy</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">transformPoints</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">points</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Transform a list of points. 
 
        :Example: 
 
                &gt;&gt;&gt; t = Scale(2, 3) 
                &gt;&gt;&gt; t.transformPoints([(0, 0), (0, 100), (100, 100), (100, 0)]) 
                [(0, 0), (0, 300), (200, 300), (200, 0)] 
                &gt;&gt;&gt; 
        &quot;&quot;&quot;</span>
        <span class="s1">xx</span><span class="s3">, </span><span class="s1">xy</span><span class="s3">, </span><span class="s1">yx</span><span class="s3">, </span><span class="s1">yy</span><span class="s3">, </span><span class="s1">dx</span><span class="s3">, </span><span class="s1">dy </span><span class="s3">= </span><span class="s1">self</span>
        <span class="s2">return </span><span class="s3">[(</span><span class="s1">xx </span><span class="s3">* </span><span class="s1">x </span><span class="s3">+ </span><span class="s1">yx </span><span class="s3">* </span><span class="s1">y </span><span class="s3">+ </span><span class="s1">dx</span><span class="s3">, </span><span class="s1">xy </span><span class="s3">* </span><span class="s1">x </span><span class="s3">+ </span><span class="s1">yy </span><span class="s3">* </span><span class="s1">y </span><span class="s3">+ </span><span class="s1">dy</span><span class="s3">) </span><span class="s2">for </span><span class="s1">x</span><span class="s3">, </span><span class="s1">y </span><span class="s2">in </span><span class="s1">points</span><span class="s3">]</span>

    <span class="s2">def </span><span class="s1">transformVector</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">v</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Transform an (dx, dy) vector, treating translation as zero. 
 
        :Example: 
 
                &gt;&gt;&gt; t = Transform(2, 0, 0, 2, 10, 20) 
                &gt;&gt;&gt; t.transformVector((3, -4)) 
                (6, -8) 
                &gt;&gt;&gt; 
        &quot;&quot;&quot;</span>
        <span class="s3">(</span><span class="s1">dx</span><span class="s3">, </span><span class="s1">dy</span><span class="s3">) = </span><span class="s1">v</span>
        <span class="s1">xx</span><span class="s3">, </span><span class="s1">xy</span><span class="s3">, </span><span class="s1">yx</span><span class="s3">, </span><span class="s1">yy </span><span class="s3">= </span><span class="s1">self</span><span class="s3">[:</span><span class="s5">4</span><span class="s3">]</span>
        <span class="s2">return </span><span class="s3">(</span><span class="s1">xx </span><span class="s3">* </span><span class="s1">dx </span><span class="s3">+ </span><span class="s1">yx </span><span class="s3">* </span><span class="s1">dy</span><span class="s3">, </span><span class="s1">xy </span><span class="s3">* </span><span class="s1">dx </span><span class="s3">+ </span><span class="s1">yy </span><span class="s3">* </span><span class="s1">dy</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">transformVectors</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">vectors</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Transform a list of (dx, dy) vector, treating translation as zero. 
 
        :Example: 
                &gt;&gt;&gt; t = Transform(2, 0, 0, 2, 10, 20) 
                &gt;&gt;&gt; t.transformVectors([(3, -4), (5, -6)]) 
                [(6, -8), (10, -12)] 
                &gt;&gt;&gt; 
        &quot;&quot;&quot;</span>
        <span class="s1">xx</span><span class="s3">, </span><span class="s1">xy</span><span class="s3">, </span><span class="s1">yx</span><span class="s3">, </span><span class="s1">yy </span><span class="s3">= </span><span class="s1">self</span><span class="s3">[:</span><span class="s5">4</span><span class="s3">]</span>
        <span class="s2">return </span><span class="s3">[(</span><span class="s1">xx </span><span class="s3">* </span><span class="s1">dx </span><span class="s3">+ </span><span class="s1">yx </span><span class="s3">* </span><span class="s1">dy</span><span class="s3">, </span><span class="s1">xy </span><span class="s3">* </span><span class="s1">dx </span><span class="s3">+ </span><span class="s1">yy </span><span class="s3">* </span><span class="s1">dy</span><span class="s3">) </span><span class="s2">for </span><span class="s1">dx</span><span class="s3">, </span><span class="s1">dy </span><span class="s2">in </span><span class="s1">vectors</span><span class="s3">]</span>

    <span class="s2">def </span><span class="s1">translate</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">y</span><span class="s3">=</span><span class="s5">0</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Return a new transformation, translated (offset) by x, y. 
 
        :Example: 
                &gt;&gt;&gt; t = Transform() 
                &gt;&gt;&gt; t.translate(20, 30) 
                &lt;Transform [1 0 0 1 20 30]&gt; 
                &gt;&gt;&gt; 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">transform</span><span class="s3">((</span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">scale</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">=</span><span class="s5">1</span><span class="s3">, </span><span class="s1">y</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Return a new transformation, scaled by x, y. The 'y' argument 
        may be None, which implies to use the x value for y as well. 
 
        :Example: 
                &gt;&gt;&gt; t = Transform() 
                &gt;&gt;&gt; t.scale(5) 
                &lt;Transform [5 0 0 5 0 0]&gt; 
                &gt;&gt;&gt; t.scale(5, 6) 
                &lt;Transform [5 0 0 6 0 0]&gt; 
                &gt;&gt;&gt; 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">y </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s1">y </span><span class="s3">= </span><span class="s1">x</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">transform</span><span class="s3">((</span><span class="s1">x</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">rotate</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">angle</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Return a new transformation, rotated by 'angle' (radians). 
 
        :Example: 
                &gt;&gt;&gt; import math 
                &gt;&gt;&gt; t = Transform() 
                &gt;&gt;&gt; t.rotate(math.pi / 2) 
                &lt;Transform [0 1 -1 0 0 0]&gt; 
                &gt;&gt;&gt; 
        &quot;&quot;&quot;</span>
        <span class="s2">import </span><span class="s1">math</span>

        <span class="s1">c </span><span class="s3">= </span><span class="s1">_normSinCos</span><span class="s3">(</span><span class="s1">math</span><span class="s3">.</span><span class="s1">cos</span><span class="s3">(</span><span class="s1">angle</span><span class="s3">))</span>
        <span class="s1">s </span><span class="s3">= </span><span class="s1">_normSinCos</span><span class="s3">(</span><span class="s1">math</span><span class="s3">.</span><span class="s1">sin</span><span class="s3">(</span><span class="s1">angle</span><span class="s3">))</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">transform</span><span class="s3">((</span><span class="s1">c</span><span class="s3">, </span><span class="s1">s</span><span class="s3">, -</span><span class="s1">s</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">skew</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">y</span><span class="s3">=</span><span class="s5">0</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Return a new transformation, skewed by x and y. 
 
        :Example: 
                &gt;&gt;&gt; import math 
                &gt;&gt;&gt; t = Transform() 
                &gt;&gt;&gt; t.skew(math.pi / 4) 
                &lt;Transform [1 0 1 1 0 0]&gt; 
                &gt;&gt;&gt; 
        &quot;&quot;&quot;</span>
        <span class="s2">import </span><span class="s1">math</span>

        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">transform</span><span class="s3">((</span><span class="s5">1</span><span class="s3">, </span><span class="s1">math</span><span class="s3">.</span><span class="s1">tan</span><span class="s3">(</span><span class="s1">y</span><span class="s3">), </span><span class="s1">math</span><span class="s3">.</span><span class="s1">tan</span><span class="s3">(</span><span class="s1">x</span><span class="s3">), </span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">transform</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Return a new transformation, transformed by another 
        transformation. 
 
        :Example: 
                &gt;&gt;&gt; t = Transform(2, 0, 0, 3, 1, 6) 
                &gt;&gt;&gt; t.transform((4, 3, 2, 1, 5, 6)) 
                &lt;Transform [8 9 4 3 11 24]&gt; 
                &gt;&gt;&gt; 
        &quot;&quot;&quot;</span>
        <span class="s1">xx1</span><span class="s3">, </span><span class="s1">xy1</span><span class="s3">, </span><span class="s1">yx1</span><span class="s3">, </span><span class="s1">yy1</span><span class="s3">, </span><span class="s1">dx1</span><span class="s3">, </span><span class="s1">dy1 </span><span class="s3">= </span><span class="s1">other</span>
        <span class="s1">xx2</span><span class="s3">, </span><span class="s1">xy2</span><span class="s3">, </span><span class="s1">yx2</span><span class="s3">, </span><span class="s1">yy2</span><span class="s3">, </span><span class="s1">dx2</span><span class="s3">, </span><span class="s1">dy2 </span><span class="s3">= </span><span class="s1">self</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__class__</span><span class="s3">(</span>
            <span class="s1">xx1 </span><span class="s3">* </span><span class="s1">xx2 </span><span class="s3">+ </span><span class="s1">xy1 </span><span class="s3">* </span><span class="s1">yx2</span><span class="s3">,</span>
            <span class="s1">xx1 </span><span class="s3">* </span><span class="s1">xy2 </span><span class="s3">+ </span><span class="s1">xy1 </span><span class="s3">* </span><span class="s1">yy2</span><span class="s3">,</span>
            <span class="s1">yx1 </span><span class="s3">* </span><span class="s1">xx2 </span><span class="s3">+ </span><span class="s1">yy1 </span><span class="s3">* </span><span class="s1">yx2</span><span class="s3">,</span>
            <span class="s1">yx1 </span><span class="s3">* </span><span class="s1">xy2 </span><span class="s3">+ </span><span class="s1">yy1 </span><span class="s3">* </span><span class="s1">yy2</span><span class="s3">,</span>
            <span class="s1">xx2 </span><span class="s3">* </span><span class="s1">dx1 </span><span class="s3">+ </span><span class="s1">yx2 </span><span class="s3">* </span><span class="s1">dy1 </span><span class="s3">+ </span><span class="s1">dx2</span><span class="s3">,</span>
            <span class="s1">xy2 </span><span class="s3">* </span><span class="s1">dx1 </span><span class="s3">+ </span><span class="s1">yy2 </span><span class="s3">* </span><span class="s1">dy1 </span><span class="s3">+ </span><span class="s1">dy2</span><span class="s3">,</span>
        <span class="s3">)</span>

    <span class="s2">def </span><span class="s1">reverseTransform</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Return a new transformation, which is the other transformation 
        transformed by self. self.reverseTransform(other) is equivalent to 
        other.transform(self). 
 
        :Example: 
                &gt;&gt;&gt; t = Transform(2, 0, 0, 3, 1, 6) 
                &gt;&gt;&gt; t.reverseTransform((4, 3, 2, 1, 5, 6)) 
                &lt;Transform [8 6 6 3 21 15]&gt; 
                &gt;&gt;&gt; Transform(4, 3, 2, 1, 5, 6).transform((2, 0, 0, 3, 1, 6)) 
                &lt;Transform [8 6 6 3 21 15]&gt; 
                &gt;&gt;&gt; 
        &quot;&quot;&quot;</span>
        <span class="s1">xx1</span><span class="s3">, </span><span class="s1">xy1</span><span class="s3">, </span><span class="s1">yx1</span><span class="s3">, </span><span class="s1">yy1</span><span class="s3">, </span><span class="s1">dx1</span><span class="s3">, </span><span class="s1">dy1 </span><span class="s3">= </span><span class="s1">self</span>
        <span class="s1">xx2</span><span class="s3">, </span><span class="s1">xy2</span><span class="s3">, </span><span class="s1">yx2</span><span class="s3">, </span><span class="s1">yy2</span><span class="s3">, </span><span class="s1">dx2</span><span class="s3">, </span><span class="s1">dy2 </span><span class="s3">= </span><span class="s1">other</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__class__</span><span class="s3">(</span>
            <span class="s1">xx1 </span><span class="s3">* </span><span class="s1">xx2 </span><span class="s3">+ </span><span class="s1">xy1 </span><span class="s3">* </span><span class="s1">yx2</span><span class="s3">,</span>
            <span class="s1">xx1 </span><span class="s3">* </span><span class="s1">xy2 </span><span class="s3">+ </span><span class="s1">xy1 </span><span class="s3">* </span><span class="s1">yy2</span><span class="s3">,</span>
            <span class="s1">yx1 </span><span class="s3">* </span><span class="s1">xx2 </span><span class="s3">+ </span><span class="s1">yy1 </span><span class="s3">* </span><span class="s1">yx2</span><span class="s3">,</span>
            <span class="s1">yx1 </span><span class="s3">* </span><span class="s1">xy2 </span><span class="s3">+ </span><span class="s1">yy1 </span><span class="s3">* </span><span class="s1">yy2</span><span class="s3">,</span>
            <span class="s1">xx2 </span><span class="s3">* </span><span class="s1">dx1 </span><span class="s3">+ </span><span class="s1">yx2 </span><span class="s3">* </span><span class="s1">dy1 </span><span class="s3">+ </span><span class="s1">dx2</span><span class="s3">,</span>
            <span class="s1">xy2 </span><span class="s3">* </span><span class="s1">dx1 </span><span class="s3">+ </span><span class="s1">yy2 </span><span class="s3">* </span><span class="s1">dy1 </span><span class="s3">+ </span><span class="s1">dy2</span><span class="s3">,</span>
        <span class="s3">)</span>

    <span class="s2">def </span><span class="s1">inverse</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Return the inverse transformation. 
 
        :Example: 
                &gt;&gt;&gt; t = Identity.translate(2, 3).scale(4, 5) 
                &gt;&gt;&gt; t.transformPoint((10, 20)) 
                (42, 103) 
                &gt;&gt;&gt; it = t.inverse() 
                &gt;&gt;&gt; it.transformPoint((42, 103)) 
                (10.0, 20.0) 
                &gt;&gt;&gt; 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self </span><span class="s3">== </span><span class="s1">Identity</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">self</span>
        <span class="s1">xx</span><span class="s3">, </span><span class="s1">xy</span><span class="s3">, </span><span class="s1">yx</span><span class="s3">, </span><span class="s1">yy</span><span class="s3">, </span><span class="s1">dx</span><span class="s3">, </span><span class="s1">dy </span><span class="s3">= </span><span class="s1">self</span>
        <span class="s1">det </span><span class="s3">= </span><span class="s1">xx </span><span class="s3">* </span><span class="s1">yy </span><span class="s3">- </span><span class="s1">yx </span><span class="s3">* </span><span class="s1">xy</span>
        <span class="s1">xx</span><span class="s3">, </span><span class="s1">xy</span><span class="s3">, </span><span class="s1">yx</span><span class="s3">, </span><span class="s1">yy </span><span class="s3">= </span><span class="s1">yy </span><span class="s3">/ </span><span class="s1">det</span><span class="s3">, -</span><span class="s1">xy </span><span class="s3">/ </span><span class="s1">det</span><span class="s3">, -</span><span class="s1">yx </span><span class="s3">/ </span><span class="s1">det</span><span class="s3">, </span><span class="s1">xx </span><span class="s3">/ </span><span class="s1">det</span>
        <span class="s1">dx</span><span class="s3">, </span><span class="s1">dy </span><span class="s3">= -</span><span class="s1">xx </span><span class="s3">* </span><span class="s1">dx </span><span class="s3">- </span><span class="s1">yx </span><span class="s3">* </span><span class="s1">dy</span><span class="s3">, -</span><span class="s1">xy </span><span class="s3">* </span><span class="s1">dx </span><span class="s3">- </span><span class="s1">yy </span><span class="s3">* </span><span class="s1">dy</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__class__</span><span class="s3">(</span><span class="s1">xx</span><span class="s3">, </span><span class="s1">xy</span><span class="s3">, </span><span class="s1">yx</span><span class="s3">, </span><span class="s1">yy</span><span class="s3">, </span><span class="s1">dx</span><span class="s3">, </span><span class="s1">dy</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">toPS</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Return a PostScript representation 
 
        :Example: 
 
                &gt;&gt;&gt; t = Identity.scale(2, 3).translate(4, 5) 
                &gt;&gt;&gt; t.toPS() 
                '[2 0 0 3 8 15]' 
                &gt;&gt;&gt; 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s4">&quot;[%s %s %s %s %s %s]&quot; </span><span class="s3">% </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">toDecomposed</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s4">&quot;DecomposedTransform&quot;</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Decompose into a DecomposedTransform.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">DecomposedTransform</span><span class="s3">.</span><span class="s1">fromTransform</span><span class="s3">(</span><span class="s1">self</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__bool__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Returns True if transform is not identity, False otherwise. 
 
        :Example: 
 
                &gt;&gt;&gt; bool(Identity) 
                False 
                &gt;&gt;&gt; bool(Transform()) 
                False 
                &gt;&gt;&gt; bool(Scale(1.)) 
                False 
                &gt;&gt;&gt; bool(Scale(2)) 
                True 
                &gt;&gt;&gt; bool(Offset()) 
                False 
                &gt;&gt;&gt; bool(Offset(0)) 
                False 
                &gt;&gt;&gt; bool(Offset(2)) 
                True 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self </span><span class="s3">!= </span><span class="s1">Identity</span>

    <span class="s2">def </span><span class="s1">__repr__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s4">&quot;&lt;%s [%g %g %g %g %g %g]&gt;&quot; </span><span class="s3">% ((</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__class__</span><span class="s3">.</span><span class="s1">__name__</span><span class="s3">,) + </span><span class="s1">self</span><span class="s3">)</span>


<span class="s1">Identity </span><span class="s3">= </span><span class="s1">Transform</span><span class="s3">()</span>


<span class="s2">def </span><span class="s1">Offset</span><span class="s3">(</span><span class="s1">x</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">y</span><span class="s3">=</span><span class="s5">0</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Return the identity transformation offset by x, y. 
 
    :Example: 
            &gt;&gt;&gt; Offset(2, 3) 
            &lt;Transform [1 0 0 1 2 3]&gt; 
            &gt;&gt;&gt; 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">Transform</span><span class="s3">(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">Scale</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Return the identity transformation scaled by x, y. The 'y' argument 
    may be None, which implies to use the x value for y as well. 
 
    :Example: 
            &gt;&gt;&gt; Scale(2, 3) 
            &lt;Transform [2 0 0 3 0 0]&gt; 
            &gt;&gt;&gt; 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">y </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">y </span><span class="s3">= </span><span class="s1">x</span>
    <span class="s2">return </span><span class="s1">Transform</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">dataclass</span>
<span class="s2">class </span><span class="s1">DecomposedTransform</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot;The DecomposedTransform class implements a transformation with separate 
    translate, rotation, scale, skew, and transformation-center components. 
    &quot;&quot;&quot;</span>

    <span class="s1">translateX</span><span class="s3">: </span><span class="s1">float </span><span class="s3">= </span><span class="s5">0</span>
    <span class="s1">translateY</span><span class="s3">: </span><span class="s1">float </span><span class="s3">= </span><span class="s5">0</span>
    <span class="s1">rotation</span><span class="s3">: </span><span class="s1">float </span><span class="s3">= </span><span class="s5">0  </span><span class="s6"># in degrees, counter-clockwise</span>
    <span class="s1">scaleX</span><span class="s3">: </span><span class="s1">float </span><span class="s3">= </span><span class="s5">1</span>
    <span class="s1">scaleY</span><span class="s3">: </span><span class="s1">float </span><span class="s3">= </span><span class="s5">1</span>
    <span class="s1">skewX</span><span class="s3">: </span><span class="s1">float </span><span class="s3">= </span><span class="s5">0  </span><span class="s6"># in degrees, clockwise</span>
    <span class="s1">skewY</span><span class="s3">: </span><span class="s1">float </span><span class="s3">= </span><span class="s5">0  </span><span class="s6"># in degrees, counter-clockwise</span>
    <span class="s1">tCenterX</span><span class="s3">: </span><span class="s1">float </span><span class="s3">= </span><span class="s5">0</span>
    <span class="s1">tCenterY</span><span class="s3">: </span><span class="s1">float </span><span class="s3">= </span><span class="s5">0</span>

    <span class="s2">def </span><span class="s1">__bool__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s3">(</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">translateX </span><span class="s3">!= </span><span class="s5">0</span>
            <span class="s2">or </span><span class="s1">self</span><span class="s3">.</span><span class="s1">translateY </span><span class="s3">!= </span><span class="s5">0</span>
            <span class="s2">or </span><span class="s1">self</span><span class="s3">.</span><span class="s1">rotation </span><span class="s3">!= </span><span class="s5">0</span>
            <span class="s2">or </span><span class="s1">self</span><span class="s3">.</span><span class="s1">scaleX </span><span class="s3">!= </span><span class="s5">1</span>
            <span class="s2">or </span><span class="s1">self</span><span class="s3">.</span><span class="s1">scaleY </span><span class="s3">!= </span><span class="s5">1</span>
            <span class="s2">or </span><span class="s1">self</span><span class="s3">.</span><span class="s1">skewX </span><span class="s3">!= </span><span class="s5">0</span>
            <span class="s2">or </span><span class="s1">self</span><span class="s3">.</span><span class="s1">skewY </span><span class="s3">!= </span><span class="s5">0</span>
            <span class="s2">or </span><span class="s1">self</span><span class="s3">.</span><span class="s1">tCenterX </span><span class="s3">!= </span><span class="s5">0</span>
            <span class="s2">or </span><span class="s1">self</span><span class="s3">.</span><span class="s1">tCenterY </span><span class="s3">!= </span><span class="s5">0</span>
        <span class="s3">)</span>

    <span class="s3">@</span><span class="s1">classmethod</span>
    <span class="s2">def </span><span class="s1">fromTransform</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">transform</span><span class="s3">):</span>
        <span class="s6"># Adapted from an answer on</span>
        <span class="s6"># https://math.stackexchange.com/questions/13150/extracting-rotation-scale-values-from-2d-transformation-matrix</span>
        <span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">d</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">y </span><span class="s3">= </span><span class="s1">transform</span>

        <span class="s1">sx </span><span class="s3">= </span><span class="s1">math</span><span class="s3">.</span><span class="s1">copysign</span><span class="s3">(</span><span class="s5">1</span><span class="s3">, </span><span class="s1">a</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">sx </span><span class="s3">&lt; </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s1">a </span><span class="s3">*= </span><span class="s1">sx</span>
            <span class="s1">b </span><span class="s3">*= </span><span class="s1">sx</span>

        <span class="s1">delta </span><span class="s3">= </span><span class="s1">a </span><span class="s3">* </span><span class="s1">d </span><span class="s3">- </span><span class="s1">b </span><span class="s3">* </span><span class="s1">c</span>

        <span class="s1">rotation </span><span class="s3">= </span><span class="s5">0</span>
        <span class="s1">scaleX </span><span class="s3">= </span><span class="s1">scaleY </span><span class="s3">= </span><span class="s5">0</span>
        <span class="s1">skewX </span><span class="s3">= </span><span class="s1">skewY </span><span class="s3">= </span><span class="s5">0</span>

        <span class="s6"># Apply the QR-like decomposition.</span>
        <span class="s2">if </span><span class="s1">a </span><span class="s3">!= </span><span class="s5">0 </span><span class="s2">or </span><span class="s1">b </span><span class="s3">!= </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s1">r </span><span class="s3">= </span><span class="s1">math</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s1">a </span><span class="s3">* </span><span class="s1">a </span><span class="s3">+ </span><span class="s1">b </span><span class="s3">* </span><span class="s1">b</span><span class="s3">)</span>
            <span class="s1">rotation </span><span class="s3">= </span><span class="s1">math</span><span class="s3">.</span><span class="s1">acos</span><span class="s3">(</span><span class="s1">a </span><span class="s3">/ </span><span class="s1">r</span><span class="s3">) </span><span class="s2">if </span><span class="s1">b </span><span class="s3">&gt;= </span><span class="s5">0 </span><span class="s2">else </span><span class="s3">-</span><span class="s1">math</span><span class="s3">.</span><span class="s1">acos</span><span class="s3">(</span><span class="s1">a </span><span class="s3">/ </span><span class="s1">r</span><span class="s3">)</span>
            <span class="s1">scaleX</span><span class="s3">, </span><span class="s1">scaleY </span><span class="s3">= (</span><span class="s1">r</span><span class="s3">, </span><span class="s1">delta </span><span class="s3">/ </span><span class="s1">r</span><span class="s3">)</span>
            <span class="s1">skewX</span><span class="s3">, </span><span class="s1">skewY </span><span class="s3">= (</span><span class="s1">math</span><span class="s3">.</span><span class="s1">atan</span><span class="s3">((</span><span class="s1">a </span><span class="s3">* </span><span class="s1">c </span><span class="s3">+ </span><span class="s1">b </span><span class="s3">* </span><span class="s1">d</span><span class="s3">) / (</span><span class="s1">r </span><span class="s3">* </span><span class="s1">r</span><span class="s3">)), </span><span class="s5">0</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">c </span><span class="s3">!= </span><span class="s5">0 </span><span class="s2">or </span><span class="s1">d </span><span class="s3">!= </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s1">s </span><span class="s3">= </span><span class="s1">math</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s1">c </span><span class="s3">* </span><span class="s1">c </span><span class="s3">+ </span><span class="s1">d </span><span class="s3">* </span><span class="s1">d</span><span class="s3">)</span>
            <span class="s1">rotation </span><span class="s3">= </span><span class="s1">math</span><span class="s3">.</span><span class="s1">pi </span><span class="s3">/ </span><span class="s5">2 </span><span class="s3">- (</span>
                <span class="s1">math</span><span class="s3">.</span><span class="s1">acos</span><span class="s3">(-</span><span class="s1">c </span><span class="s3">/ </span><span class="s1">s</span><span class="s3">) </span><span class="s2">if </span><span class="s1">d </span><span class="s3">&gt;= </span><span class="s5">0 </span><span class="s2">else </span><span class="s3">-</span><span class="s1">math</span><span class="s3">.</span><span class="s1">acos</span><span class="s3">(</span><span class="s1">c </span><span class="s3">/ </span><span class="s1">s</span><span class="s3">)</span>
            <span class="s3">)</span>
            <span class="s1">scaleX</span><span class="s3">, </span><span class="s1">scaleY </span><span class="s3">= (</span><span class="s1">delta </span><span class="s3">/ </span><span class="s1">s</span><span class="s3">, </span><span class="s1">s</span><span class="s3">)</span>
            <span class="s1">skewX</span><span class="s3">, </span><span class="s1">skewY </span><span class="s3">= (</span><span class="s5">0</span><span class="s3">, </span><span class="s1">math</span><span class="s3">.</span><span class="s1">atan</span><span class="s3">((</span><span class="s1">a </span><span class="s3">* </span><span class="s1">c </span><span class="s3">+ </span><span class="s1">b </span><span class="s3">* </span><span class="s1">d</span><span class="s3">) / (</span><span class="s1">s </span><span class="s3">* </span><span class="s1">s</span><span class="s3">)))</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s6"># a = b = c = d = 0</span>
            <span class="s2">pass</span>

        <span class="s2">return </span><span class="s1">DecomposedTransform</span><span class="s3">(</span>
            <span class="s1">x</span><span class="s3">,</span>
            <span class="s1">y</span><span class="s3">,</span>
            <span class="s1">math</span><span class="s3">.</span><span class="s1">degrees</span><span class="s3">(</span><span class="s1">rotation</span><span class="s3">),</span>
            <span class="s1">scaleX </span><span class="s3">* </span><span class="s1">sx</span><span class="s3">,</span>
            <span class="s1">scaleY</span><span class="s3">,</span>
            <span class="s1">math</span><span class="s3">.</span><span class="s1">degrees</span><span class="s3">(</span><span class="s1">skewX</span><span class="s3">) * </span><span class="s1">sx</span><span class="s3">,</span>
            <span class="s1">math</span><span class="s3">.</span><span class="s1">degrees</span><span class="s3">(</span><span class="s1">skewY</span><span class="s3">),</span>
            <span class="s5">0</span><span class="s3">,</span>
            <span class="s5">0</span><span class="s3">,</span>
        <span class="s3">)</span>

    <span class="s2">def </span><span class="s1">toTransform</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Return the Transform() equivalent of this transformation. 
 
        :Example: 
                &gt;&gt;&gt; DecomposedTransform(scaleX=2, scaleY=2).toTransform() 
                &lt;Transform [2 0 0 2 0 0]&gt; 
                &gt;&gt;&gt; 
        &quot;&quot;&quot;</span>
        <span class="s1">t </span><span class="s3">= </span><span class="s1">Transform</span><span class="s3">()</span>
        <span class="s1">t </span><span class="s3">= </span><span class="s1">t</span><span class="s3">.</span><span class="s1">translate</span><span class="s3">(</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">translateX </span><span class="s3">+ </span><span class="s1">self</span><span class="s3">.</span><span class="s1">tCenterX</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">translateY </span><span class="s3">+ </span><span class="s1">self</span><span class="s3">.</span><span class="s1">tCenterY</span>
        <span class="s3">)</span>
        <span class="s1">t </span><span class="s3">= </span><span class="s1">t</span><span class="s3">.</span><span class="s1">rotate</span><span class="s3">(</span><span class="s1">math</span><span class="s3">.</span><span class="s1">radians</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">rotation</span><span class="s3">))</span>
        <span class="s1">t </span><span class="s3">= </span><span class="s1">t</span><span class="s3">.</span><span class="s1">scale</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">scaleX</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">scaleY</span><span class="s3">)</span>
        <span class="s1">t </span><span class="s3">= </span><span class="s1">t</span><span class="s3">.</span><span class="s1">skew</span><span class="s3">(</span><span class="s1">math</span><span class="s3">.</span><span class="s1">radians</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">skewX</span><span class="s3">), </span><span class="s1">math</span><span class="s3">.</span><span class="s1">radians</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">skewY</span><span class="s3">))</span>
        <span class="s1">t </span><span class="s3">= </span><span class="s1">t</span><span class="s3">.</span><span class="s1">translate</span><span class="s3">(-</span><span class="s1">self</span><span class="s3">.</span><span class="s1">tCenterX</span><span class="s3">, -</span><span class="s1">self</span><span class="s3">.</span><span class="s1">tCenterY</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">t</span>


<span class="s2">if </span><span class="s1">__name__ </span><span class="s3">== </span><span class="s4">&quot;__main__&quot;</span><span class="s3">:</span>
    <span class="s2">import </span><span class="s1">sys</span>
    <span class="s2">import </span><span class="s1">doctest</span>

    <span class="s1">sys</span><span class="s3">.</span><span class="s1">exit</span><span class="s3">(</span><span class="s1">doctest</span><span class="s3">.</span><span class="s1">testmod</span><span class="s3">().</span><span class="s1">failed</span><span class="s3">)</span>
</pre>
</body>
</html>