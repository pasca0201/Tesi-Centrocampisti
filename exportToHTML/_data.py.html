<html>
<head>
<title>_data.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #2aacb8;}
.s5 { color: #6aab73;}
.s6 { color: #5f826b; font-style: italic;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_data.py</font>
</center></td></tr></table>
<pre><span class="s0"># Authors: Alexandre Gramfort &lt;alexandre.gramfort@inria.fr&gt;</span>
<span class="s0">#          Mathieu Blondel &lt;mathieu@mblondel.org&gt;</span>
<span class="s0">#          Olivier Grisel &lt;olivier.grisel@ensta.org&gt;</span>
<span class="s0">#          Andreas Mueller &lt;amueller@ais.uni-bonn.de&gt;</span>
<span class="s0">#          Eric Martin &lt;eric@ericmart.in&gt;</span>
<span class="s0">#          Giorgio Patrini &lt;giorgio.patrini@anu.edu.au&gt;</span>
<span class="s0">#          Eric Chang &lt;ericchang2017@u.northwestern.edu&gt;</span>
<span class="s0"># License: BSD 3 clause</span>


<span class="s2">import </span><span class="s1">warnings</span>
<span class="s2">from </span><span class="s1">numbers </span><span class="s2">import </span><span class="s1">Integral</span><span class="s3">, </span><span class="s1">Real</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">from </span><span class="s1">scipy </span><span class="s2">import </span><span class="s1">optimize</span><span class="s3">, </span><span class="s1">sparse</span><span class="s3">, </span><span class="s1">stats</span>
<span class="s2">from </span><span class="s1">scipy</span><span class="s3">.</span><span class="s1">special </span><span class="s2">import </span><span class="s1">boxcox</span>

<span class="s2">from </span><span class="s3">..</span><span class="s1">base </span><span class="s2">import </span><span class="s3">(</span>
    <span class="s1">BaseEstimator</span><span class="s3">,</span>
    <span class="s1">ClassNamePrefixFeaturesOutMixin</span><span class="s3">,</span>
    <span class="s1">OneToOneFeatureMixin</span><span class="s3">,</span>
    <span class="s1">TransformerMixin</span><span class="s3">,</span>
    <span class="s1">_fit_context</span><span class="s3">,</span>
<span class="s3">)</span>
<span class="s2">from </span><span class="s3">..</span><span class="s1">utils </span><span class="s2">import </span><span class="s1">_array_api</span><span class="s3">, </span><span class="s1">check_array</span><span class="s3">, </span><span class="s1">resample</span>
<span class="s2">from </span><span class="s3">..</span><span class="s1">utils</span><span class="s3">.</span><span class="s1">_array_api </span><span class="s2">import </span><span class="s1">get_namespace</span>
<span class="s2">from </span><span class="s3">..</span><span class="s1">utils</span><span class="s3">.</span><span class="s1">_param_validation </span><span class="s2">import </span><span class="s1">Interval</span><span class="s3">, </span><span class="s1">Options</span><span class="s3">, </span><span class="s1">StrOptions</span><span class="s3">, </span><span class="s1">validate_params</span>
<span class="s2">from </span><span class="s3">..</span><span class="s1">utils</span><span class="s3">.</span><span class="s1">extmath </span><span class="s2">import </span><span class="s1">_incremental_mean_and_var</span><span class="s3">, </span><span class="s1">row_norms</span>
<span class="s2">from </span><span class="s3">..</span><span class="s1">utils</span><span class="s3">.</span><span class="s1">sparsefuncs </span><span class="s2">import </span><span class="s3">(</span>
    <span class="s1">incr_mean_variance_axis</span><span class="s3">,</span>
    <span class="s1">inplace_column_scale</span><span class="s3">,</span>
    <span class="s1">mean_variance_axis</span><span class="s3">,</span>
    <span class="s1">min_max_axis</span><span class="s3">,</span>
<span class="s3">)</span>
<span class="s2">from </span><span class="s3">..</span><span class="s1">utils</span><span class="s3">.</span><span class="s1">sparsefuncs_fast </span><span class="s2">import </span><span class="s3">(</span>
    <span class="s1">inplace_csr_row_normalize_l1</span><span class="s3">,</span>
    <span class="s1">inplace_csr_row_normalize_l2</span><span class="s3">,</span>
<span class="s3">)</span>
<span class="s2">from </span><span class="s3">..</span><span class="s1">utils</span><span class="s3">.</span><span class="s1">validation </span><span class="s2">import </span><span class="s3">(</span>
    <span class="s1">FLOAT_DTYPES</span><span class="s3">,</span>
    <span class="s1">_check_sample_weight</span><span class="s3">,</span>
    <span class="s1">check_is_fitted</span><span class="s3">,</span>
    <span class="s1">check_random_state</span><span class="s3">,</span>
<span class="s3">)</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">_encoders </span><span class="s2">import </span><span class="s1">OneHotEncoder</span>

<span class="s1">BOUNDS_THRESHOLD </span><span class="s3">= </span><span class="s4">1e-7</span>

<span class="s1">__all__ </span><span class="s3">= [</span>
    <span class="s5">&quot;Binarizer&quot;</span><span class="s3">,</span>
    <span class="s5">&quot;KernelCenterer&quot;</span><span class="s3">,</span>
    <span class="s5">&quot;MinMaxScaler&quot;</span><span class="s3">,</span>
    <span class="s5">&quot;MaxAbsScaler&quot;</span><span class="s3">,</span>
    <span class="s5">&quot;Normalizer&quot;</span><span class="s3">,</span>
    <span class="s5">&quot;OneHotEncoder&quot;</span><span class="s3">,</span>
    <span class="s5">&quot;RobustScaler&quot;</span><span class="s3">,</span>
    <span class="s5">&quot;StandardScaler&quot;</span><span class="s3">,</span>
    <span class="s5">&quot;QuantileTransformer&quot;</span><span class="s3">,</span>
    <span class="s5">&quot;PowerTransformer&quot;</span><span class="s3">,</span>
    <span class="s5">&quot;add_dummy_feature&quot;</span><span class="s3">,</span>
    <span class="s5">&quot;binarize&quot;</span><span class="s3">,</span>
    <span class="s5">&quot;normalize&quot;</span><span class="s3">,</span>
    <span class="s5">&quot;scale&quot;</span><span class="s3">,</span>
    <span class="s5">&quot;robust_scale&quot;</span><span class="s3">,</span>
    <span class="s5">&quot;maxabs_scale&quot;</span><span class="s3">,</span>
    <span class="s5">&quot;minmax_scale&quot;</span><span class="s3">,</span>
    <span class="s5">&quot;quantile_transform&quot;</span><span class="s3">,</span>
    <span class="s5">&quot;power_transform&quot;</span><span class="s3">,</span>
<span class="s3">]</span>


<span class="s2">def </span><span class="s1">_is_constant_feature</span><span class="s3">(</span><span class="s1">var</span><span class="s3">, </span><span class="s1">mean</span><span class="s3">, </span><span class="s1">n_samples</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Detect if a feature is indistinguishable from a constant feature. 
 
    The detection is based on its computed variance and on the theoretical 
    error bounds of the '2 pass algorithm' for variance computation. 
 
    See &quot;Algorithms for computing the sample variance: analysis and 
    recommendations&quot;, by Chan, Golub, and LeVeque. 
    &quot;&quot;&quot;</span>
    <span class="s0"># In scikit-learn, variance is always computed using float64 accumulators.</span>
    <span class="s1">eps </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">finfo</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">).</span><span class="s1">eps</span>

    <span class="s1">upper_bound </span><span class="s3">= </span><span class="s1">n_samples </span><span class="s3">* </span><span class="s1">eps </span><span class="s3">* </span><span class="s1">var </span><span class="s3">+ (</span><span class="s1">n_samples </span><span class="s3">* </span><span class="s1">mean </span><span class="s3">* </span><span class="s1">eps</span><span class="s3">) ** </span><span class="s4">2</span>
    <span class="s2">return </span><span class="s1">var </span><span class="s3">&lt;= </span><span class="s1">upper_bound</span>


<span class="s2">def </span><span class="s1">_handle_zeros_in_scale</span><span class="s3">(</span><span class="s1">scale</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">constant_mask</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Set scales of near constant features to 1. 
 
    The goal is to avoid division by very small or zero values. 
 
    Near constant features are detected automatically by identifying 
    scales close to machine precision unless they are precomputed by 
    the caller and passed with the `constant_mask` kwarg. 
 
    Typically for standard scaling, the scales are the standard 
    deviation while near constant features are better detected on the 
    computed variances which are closer to machine precision by 
    construction. 
    &quot;&quot;&quot;</span>
    <span class="s0"># if we are fitting on 1D arrays, scale might be a scalar</span>
    <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isscalar</span><span class="s3">(</span><span class="s1">scale</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">scale </span><span class="s3">== </span><span class="s4">0.0</span><span class="s3">:</span>
            <span class="s1">scale </span><span class="s3">= </span><span class="s4">1.0</span>
        <span class="s2">return </span><span class="s1">scale</span>
    <span class="s0"># scale is an array</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">xp</span><span class="s3">, </span><span class="s1">_ </span><span class="s3">= </span><span class="s1">get_namespace</span><span class="s3">(</span><span class="s1">scale</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">constant_mask </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s0"># Detect near constant values to avoid dividing by a very small</span>
            <span class="s0"># value that could lead to surprising results and numerical</span>
            <span class="s0"># stability issues.</span>
            <span class="s1">constant_mask </span><span class="s3">= </span><span class="s1">scale </span><span class="s3">&lt; </span><span class="s4">10 </span><span class="s3">* </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">finfo</span><span class="s3">(</span><span class="s1">scale</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">).</span><span class="s1">eps</span>

        <span class="s2">if </span><span class="s1">copy</span><span class="s3">:</span>
            <span class="s0"># New array to avoid side-effects</span>
            <span class="s1">scale </span><span class="s3">= </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">scale</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
        <span class="s1">scale</span><span class="s3">[</span><span class="s1">constant_mask</span><span class="s3">] = </span><span class="s4">1.0</span>
        <span class="s2">return </span><span class="s1">scale</span>


<span class="s3">@</span><span class="s1">validate_params</span><span class="s3">(</span>
    <span class="s3">{</span>
        <span class="s5">&quot;X&quot;</span><span class="s3">: [</span><span class="s5">&quot;array-like&quot;</span><span class="s3">, </span><span class="s5">&quot;sparse matrix&quot;</span><span class="s3">],</span>
        <span class="s5">&quot;axis&quot;</span><span class="s3">: [</span><span class="s1">Options</span><span class="s3">(</span><span class="s1">Integral</span><span class="s3">, {</span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">})],</span>
        <span class="s5">&quot;with_mean&quot;</span><span class="s3">: [</span><span class="s5">&quot;boolean&quot;</span><span class="s3">],</span>
        <span class="s5">&quot;with_std&quot;</span><span class="s3">: [</span><span class="s5">&quot;boolean&quot;</span><span class="s3">],</span>
        <span class="s5">&quot;copy&quot;</span><span class="s3">: [</span><span class="s5">&quot;boolean&quot;</span><span class="s3">],</span>
    <span class="s3">},</span>
    <span class="s1">prefer_skip_nested_validation</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
<span class="s3">)</span>
<span class="s2">def </span><span class="s1">scale</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, *, </span><span class="s1">axis</span><span class="s3">=</span><span class="s4">0</span><span class="s3">, </span><span class="s1">with_mean</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">with_std</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Standardize a dataset along any axis. 
 
    Center to the mean and component wise scale to unit variance. 
 
    Read more in the :ref:`User Guide &lt;preprocessing_scaler&gt;`. 
 
    Parameters 
    ---------- 
    X : {array-like, sparse matrix} of shape (n_samples, n_features) 
        The data to center and scale. 
 
    axis : {0, 1}, default=0 
        Axis used to compute the means and standard deviations along. If 0, 
        independently standardize each feature, otherwise (if 1) standardize 
        each sample. 
 
    with_mean : bool, default=True 
        If True, center the data before scaling. 
 
    with_std : bool, default=True 
        If True, scale the data to unit variance (or equivalently, 
        unit standard deviation). 
 
    copy : bool, default=True 
        If False, try to avoid a copy and scale in place. 
        This is not guaranteed to always work in place; e.g. if the data is 
        a numpy array with an int dtype, a copy will be returned even with 
        copy=False. 
 
    Returns 
    ------- 
    X_tr : {ndarray, sparse matrix} of shape (n_samples, n_features) 
        The transformed data. 
 
    See Also 
    -------- 
    StandardScaler : Performs scaling to unit variance using the Transformer 
        API (e.g. as part of a preprocessing 
        :class:`~sklearn.pipeline.Pipeline`). 
 
    Notes 
    ----- 
    This implementation will refuse to center scipy.sparse matrices 
    since it would make them non-sparse and would potentially crash the 
    program with memory exhaustion problems. 
 
    Instead the caller is expected to either set explicitly 
    `with_mean=False` (in that case, only variance scaling will be 
    performed on the features of the CSC matrix) or to call `X.toarray()` 
    if he/she expects the materialized dense array to fit in memory. 
 
    To avoid memory copy the caller should pass a CSC matrix. 
 
    NaNs are treated as missing values: disregarded to compute the statistics, 
    and maintained during the data transformation. 
 
    We use a biased estimator for the standard deviation, equivalent to 
    `numpy.std(x, ddof=0)`. Note that the choice of `ddof` is unlikely to 
    affect model performance. 
 
    For a comparison of the different scalers, transformers, and normalizers, 
    see: :ref:`sphx_glr_auto_examples_preprocessing_plot_all_scaling.py`. 
 
    .. warning:: Risk of data leak 
 
        Do not use :func:`~sklearn.preprocessing.scale` unless you know 
        what you are doing. A common mistake is to apply it to the entire data 
        *before* splitting into training and test sets. This will bias the 
        model evaluation because information would have leaked from the test 
        set to the training set. 
        In general, we recommend using 
        :class:`~sklearn.preprocessing.StandardScaler` within a 
        :ref:`Pipeline &lt;pipeline&gt;` in order to prevent most risks of data 
        leaking: `pipe = make_pipeline(StandardScaler(), LogisticRegression())`. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from sklearn.preprocessing import scale 
    &gt;&gt;&gt; X = [[-2, 1, 2], [-1, 0, 1]] 
    &gt;&gt;&gt; scale(X, axis=0)  # scaling each column independently 
    array([[-1.,  1.,  1.], 
           [ 1., -1., -1.]]) 
    &gt;&gt;&gt; scale(X, axis=1)  # scaling each row independently 
    array([[-1.37...,  0.39...,  0.98...], 
           [-1.22...,  0.     ,  1.22...]]) 
    &quot;&quot;&quot;</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">check_array</span><span class="s3">(</span>
        <span class="s1">X</span><span class="s3">,</span>
        <span class="s1">accept_sparse</span><span class="s3">=</span><span class="s5">&quot;csc&quot;</span><span class="s3">,</span>
        <span class="s1">copy</span><span class="s3">=</span><span class="s1">copy</span><span class="s3">,</span>
        <span class="s1">ensure_2d</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
        <span class="s1">estimator</span><span class="s3">=</span><span class="s5">&quot;the scale function&quot;</span><span class="s3">,</span>
        <span class="s1">dtype</span><span class="s3">=</span><span class="s1">FLOAT_DTYPES</span><span class="s3">,</span>
        <span class="s1">force_all_finite</span><span class="s3">=</span><span class="s5">&quot;allow-nan&quot;</span><span class="s3">,</span>
    <span class="s3">)</span>
    <span class="s2">if </span><span class="s1">sparse</span><span class="s3">.</span><span class="s1">issparse</span><span class="s3">(</span><span class="s1">X</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">with_mean</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span>
                <span class="s5">&quot;Cannot center sparse matrices: pass `with_mean=False` instead&quot;</span>
                <span class="s5">&quot; See docstring for motivation and alternatives.&quot;</span>
            <span class="s3">)</span>
        <span class="s2">if </span><span class="s1">axis </span><span class="s3">!= </span><span class="s4">0</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span>
                <span class="s5">&quot;Can only scale sparse matrix on axis=0,  got axis=%d&quot; </span><span class="s3">% </span><span class="s1">axis</span>
            <span class="s3">)</span>
        <span class="s2">if </span><span class="s1">with_std</span><span class="s3">:</span>
            <span class="s1">_</span><span class="s3">, </span><span class="s1">var </span><span class="s3">= </span><span class="s1">mean_variance_axis</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s4">0</span><span class="s3">)</span>
            <span class="s1">var </span><span class="s3">= </span><span class="s1">_handle_zeros_in_scale</span><span class="s3">(</span><span class="s1">var</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
            <span class="s1">inplace_column_scale</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s4">1 </span><span class="s3">/ </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s1">var</span><span class="s3">))</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">X </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">with_mean</span><span class="s3">:</span>
            <span class="s1">mean_ </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nanmean</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">with_std</span><span class="s3">:</span>
            <span class="s1">scale_ </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nanstd</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">)</span>
        <span class="s0"># Xr is a view on the original array that enables easy use of</span>
        <span class="s0"># broadcasting on the axis in which we are interested in</span>
        <span class="s1">Xr </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">rollaxis</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">with_mean</span><span class="s3">:</span>
            <span class="s1">Xr </span><span class="s3">-= </span><span class="s1">mean_</span>
            <span class="s1">mean_1 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nanmean</span><span class="s3">(</span><span class="s1">Xr</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s4">0</span><span class="s3">)</span>
            <span class="s0"># Verify that mean_1 is 'close to zero'. If X contains very</span>
            <span class="s0"># large values, mean_1 can also be very large, due to a lack of</span>
            <span class="s0"># precision of mean_. In this case, a pre-scaling of the</span>
            <span class="s0"># concerned feature is efficient, for instance by its mean or</span>
            <span class="s0"># maximum.</span>
            <span class="s2">if not </span><span class="s1">np</span><span class="s3">.</span><span class="s1">allclose</span><span class="s3">(</span><span class="s1">mean_1</span><span class="s3">, </span><span class="s4">0</span><span class="s3">):</span>
                <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span>
                    <span class="s5">&quot;Numerical issues were encountered &quot;</span>
                    <span class="s5">&quot;when centering the data &quot;</span>
                    <span class="s5">&quot;and might not be solved. Dataset may &quot;</span>
                    <span class="s5">&quot;contain too large values. You may need &quot;</span>
                    <span class="s5">&quot;to prescale your features.&quot;</span>
                <span class="s3">)</span>
                <span class="s1">Xr </span><span class="s3">-= </span><span class="s1">mean_1</span>
        <span class="s2">if </span><span class="s1">with_std</span><span class="s3">:</span>
            <span class="s1">scale_ </span><span class="s3">= </span><span class="s1">_handle_zeros_in_scale</span><span class="s3">(</span><span class="s1">scale_</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
            <span class="s1">Xr </span><span class="s3">/= </span><span class="s1">scale_</span>
            <span class="s2">if </span><span class="s1">with_mean</span><span class="s3">:</span>
                <span class="s1">mean_2 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nanmean</span><span class="s3">(</span><span class="s1">Xr</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s4">0</span><span class="s3">)</span>
                <span class="s0"># If mean_2 is not 'close to zero', it comes from the fact that</span>
                <span class="s0"># scale_ is very small so that mean_2 = mean_1/scale_ &gt; 0, even</span>
                <span class="s0"># if mean_1 was close to zero. The problem is thus essentially</span>
                <span class="s0"># due to the lack of precision of mean_. A solution is then to</span>
                <span class="s0"># subtract the mean again:</span>
                <span class="s2">if not </span><span class="s1">np</span><span class="s3">.</span><span class="s1">allclose</span><span class="s3">(</span><span class="s1">mean_2</span><span class="s3">, </span><span class="s4">0</span><span class="s3">):</span>
                    <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span>
                        <span class="s5">&quot;Numerical issues were encountered &quot;</span>
                        <span class="s5">&quot;when scaling the data &quot;</span>
                        <span class="s5">&quot;and might not be solved. The standard &quot;</span>
                        <span class="s5">&quot;deviation of the data is probably &quot;</span>
                        <span class="s5">&quot;very close to 0. &quot;</span>
                    <span class="s3">)</span>
                    <span class="s1">Xr </span><span class="s3">-= </span><span class="s1">mean_2</span>
    <span class="s2">return </span><span class="s1">X</span>


<span class="s2">class </span><span class="s1">MinMaxScaler</span><span class="s3">(</span><span class="s1">OneToOneFeatureMixin</span><span class="s3">, </span><span class="s1">TransformerMixin</span><span class="s3">, </span><span class="s1">BaseEstimator</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Transform features by scaling each feature to a given range. 
 
    This estimator scales and translates each feature individually such 
    that it is in the given range on the training set, e.g. between 
    zero and one. 
 
    The transformation is given by:: 
 
        X_std = (X - X.min(axis=0)) / (X.max(axis=0) - X.min(axis=0)) 
        X_scaled = X_std * (max - min) + min 
 
    where min, max = feature_range. 
 
    This transformation is often used as an alternative to zero mean, 
    unit variance scaling. 
 
    `MinMaxScaler` doesn't reduce the effect of outliers, but it linearly 
    scales them down into a fixed range, where the largest occurring data point 
    corresponds to the maximum value and the smallest one corresponds to the 
    minimum value. For an example visualization, refer to :ref:`Compare 
    MinMaxScaler with other scalers &lt;plot_all_scaling_minmax_scaler_section&gt;`. 
 
    Read more in the :ref:`User Guide &lt;preprocessing_scaler&gt;`. 
 
    Parameters 
    ---------- 
    feature_range : tuple (min, max), default=(0, 1) 
        Desired range of transformed data. 
 
    copy : bool, default=True 
        Set to False to perform inplace row normalization and avoid a 
        copy (if the input is already a numpy array). 
 
    clip : bool, default=False 
        Set to True to clip transformed values of held-out data to 
        provided `feature range`. 
 
        .. versionadded:: 0.24 
 
    Attributes 
    ---------- 
    min_ : ndarray of shape (n_features,) 
        Per feature adjustment for minimum. Equivalent to 
        ``min - X.min(axis=0) * self.scale_`` 
 
    scale_ : ndarray of shape (n_features,) 
        Per feature relative scaling of the data. Equivalent to 
        ``(max - min) / (X.max(axis=0) - X.min(axis=0))`` 
 
        .. versionadded:: 0.17 
           *scale_* attribute. 
 
    data_min_ : ndarray of shape (n_features,) 
        Per feature minimum seen in the data 
 
        .. versionadded:: 0.17 
           *data_min_* 
 
    data_max_ : ndarray of shape (n_features,) 
        Per feature maximum seen in the data 
 
        .. versionadded:: 0.17 
           *data_max_* 
 
    data_range_ : ndarray of shape (n_features,) 
        Per feature range ``(data_max_ - data_min_)`` seen in the data 
 
        .. versionadded:: 0.17 
           *data_range_* 
 
    n_features_in_ : int 
        Number of features seen during :term:`fit`. 
 
        .. versionadded:: 0.24 
 
    n_samples_seen_ : int 
        The number of samples processed by the estimator. 
        It will be reset on new calls to fit, but increments across 
        ``partial_fit`` calls. 
 
    feature_names_in_ : ndarray of shape (`n_features_in_`,) 
        Names of features seen during :term:`fit`. Defined only when `X` 
        has feature names that are all strings. 
 
        .. versionadded:: 1.0 
 
    See Also 
    -------- 
    minmax_scale : Equivalent function without the estimator API. 
 
    Notes 
    ----- 
    NaNs are treated as missing values: disregarded in fit, and maintained in 
    transform. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from sklearn.preprocessing import MinMaxScaler 
    &gt;&gt;&gt; data = [[-1, 2], [-0.5, 6], [0, 10], [1, 18]] 
    &gt;&gt;&gt; scaler = MinMaxScaler() 
    &gt;&gt;&gt; print(scaler.fit(data)) 
    MinMaxScaler() 
    &gt;&gt;&gt; print(scaler.data_max_) 
    [ 1. 18.] 
    &gt;&gt;&gt; print(scaler.transform(data)) 
    [[0.   0.  ] 
     [0.25 0.25] 
     [0.5  0.5 ] 
     [1.   1.  ]] 
    &gt;&gt;&gt; print(scaler.transform([[2, 2]])) 
    [[1.5 0. ]] 
    &quot;&quot;&quot;</span>

    <span class="s1">_parameter_constraints</span><span class="s3">: </span><span class="s1">dict </span><span class="s3">= {</span>
        <span class="s5">&quot;feature_range&quot;</span><span class="s3">: [</span><span class="s1">tuple</span><span class="s3">],</span>
        <span class="s5">&quot;copy&quot;</span><span class="s3">: [</span><span class="s5">&quot;boolean&quot;</span><span class="s3">],</span>
        <span class="s5">&quot;clip&quot;</span><span class="s3">: [</span><span class="s5">&quot;boolean&quot;</span><span class="s3">],</span>
    <span class="s3">}</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">feature_range</span><span class="s3">=(</span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">), *, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">clip</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">feature_range </span><span class="s3">= </span><span class="s1">feature_range</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">copy </span><span class="s3">= </span><span class="s1">copy</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">clip </span><span class="s3">= </span><span class="s1">clip</span>

    <span class="s2">def </span><span class="s1">_reset</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot;Reset internal data-dependent state of the scaler, if necessary. 
 
        __init__ parameters are not touched. 
        &quot;&quot;&quot;</span>
        <span class="s0"># Checking one attribute is enough, because they are all set together</span>
        <span class="s0"># in partial_fit</span>
        <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s5">&quot;scale_&quot;</span><span class="s3">):</span>
            <span class="s2">del </span><span class="s1">self</span><span class="s3">.</span><span class="s1">scale_</span>
            <span class="s2">del </span><span class="s1">self</span><span class="s3">.</span><span class="s1">min_</span>
            <span class="s2">del </span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_samples_seen_</span>
            <span class="s2">del </span><span class="s1">self</span><span class="s3">.</span><span class="s1">data_min_</span>
            <span class="s2">del </span><span class="s1">self</span><span class="s3">.</span><span class="s1">data_max_</span>
            <span class="s2">del </span><span class="s1">self</span><span class="s3">.</span><span class="s1">data_range_</span>

    <span class="s2">def </span><span class="s1">fit</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot;Compute the minimum and maximum to be used for later scaling. 
 
        Parameters 
        ---------- 
        X : array-like of shape (n_samples, n_features) 
            The data used to compute the per-feature minimum and maximum 
            used for later scaling along the features axis. 
 
        y : None 
            Ignored. 
 
        Returns 
        ------- 
        self : object 
            Fitted scaler. 
        &quot;&quot;&quot;</span>
        <span class="s0"># Reset internal state before fitting</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_reset</span><span class="s3">()</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">partial_fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">_fit_context</span><span class="s3">(</span><span class="s1">prefer_skip_nested_validation</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
    <span class="s2">def </span><span class="s1">partial_fit</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot;Online computation of min and max on X for later scaling. 
 
        All of X is processed as a single batch. This is intended for cases 
        when :meth:`fit` is not feasible due to very large number of 
        `n_samples` or because X is read from a continuous stream. 
 
        Parameters 
        ---------- 
        X : array-like of shape (n_samples, n_features) 
            The data used to compute the mean and standard deviation 
            used for later scaling along the features axis. 
 
        y : None 
            Ignored. 
 
        Returns 
        ------- 
        self : object 
            Fitted scaler. 
        &quot;&quot;&quot;</span>
        <span class="s1">feature_range </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">feature_range</span>
        <span class="s2">if </span><span class="s1">feature_range</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] &gt;= </span><span class="s1">feature_range</span><span class="s3">[</span><span class="s4">1</span><span class="s3">]:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span>
                <span class="s5">&quot;Minimum of desired feature range must be smaller than maximum. Got %s.&quot;</span>
                <span class="s3">% </span><span class="s1">str</span><span class="s3">(</span><span class="s1">feature_range</span><span class="s3">)</span>
            <span class="s3">)</span>

        <span class="s2">if </span><span class="s1">sparse</span><span class="s3">.</span><span class="s1">issparse</span><span class="s3">(</span><span class="s1">X</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span>
                <span class="s5">&quot;MinMaxScaler does not support sparse input. &quot;</span>
                <span class="s5">&quot;Consider using MaxAbsScaler instead.&quot;</span>
            <span class="s3">)</span>

        <span class="s1">xp</span><span class="s3">, </span><span class="s1">_ </span><span class="s3">= </span><span class="s1">get_namespace</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>

        <span class="s1">first_pass </span><span class="s3">= </span><span class="s2">not </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s5">&quot;n_samples_seen_&quot;</span><span class="s3">)</span>
        <span class="s1">X </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_validate_data</span><span class="s3">(</span>
            <span class="s1">X</span><span class="s3">,</span>
            <span class="s1">reset</span><span class="s3">=</span><span class="s1">first_pass</span><span class="s3">,</span>
            <span class="s1">dtype</span><span class="s3">=</span><span class="s1">_array_api</span><span class="s3">.</span><span class="s1">supported_float_dtypes</span><span class="s3">(</span><span class="s1">xp</span><span class="s3">),</span>
            <span class="s1">force_all_finite</span><span class="s3">=</span><span class="s5">&quot;allow-nan&quot;</span><span class="s3">,</span>
        <span class="s3">)</span>

        <span class="s1">data_min </span><span class="s3">= </span><span class="s1">_array_api</span><span class="s3">.</span><span class="s1">_nanmin</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s4">0</span><span class="s3">, </span><span class="s1">xp</span><span class="s3">=</span><span class="s1">xp</span><span class="s3">)</span>
        <span class="s1">data_max </span><span class="s3">= </span><span class="s1">_array_api</span><span class="s3">.</span><span class="s1">_nanmax</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s4">0</span><span class="s3">, </span><span class="s1">xp</span><span class="s3">=</span><span class="s1">xp</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">first_pass</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">n_samples_seen_ </span><span class="s3">= </span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">data_min </span><span class="s3">= </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">minimum</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">data_min_</span><span class="s3">, </span><span class="s1">data_min</span><span class="s3">)</span>
            <span class="s1">data_max </span><span class="s3">= </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">maximum</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">data_max_</span><span class="s3">, </span><span class="s1">data_max</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">n_samples_seen_ </span><span class="s3">+= </span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]</span>

        <span class="s1">data_range </span><span class="s3">= </span><span class="s1">data_max </span><span class="s3">- </span><span class="s1">data_min</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">scale_ </span><span class="s3">= (</span><span class="s1">feature_range</span><span class="s3">[</span><span class="s4">1</span><span class="s3">] - </span><span class="s1">feature_range</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]) / </span><span class="s1">_handle_zeros_in_scale</span><span class="s3">(</span>
            <span class="s1">data_range</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">True</span>
        <span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">min_ </span><span class="s3">= </span><span class="s1">feature_range</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] - </span><span class="s1">data_min </span><span class="s3">* </span><span class="s1">self</span><span class="s3">.</span><span class="s1">scale_</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">data_min_ </span><span class="s3">= </span><span class="s1">data_min</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">data_max_ </span><span class="s3">= </span><span class="s1">data_max</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">data_range_ </span><span class="s3">= </span><span class="s1">data_range</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">transform</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot;Scale features of X according to feature_range. 
 
        Parameters 
        ---------- 
        X : array-like of shape (n_samples, n_features) 
            Input data that will be transformed. 
 
        Returns 
        ------- 
        Xt : ndarray of shape (n_samples, n_features) 
            Transformed data. 
        &quot;&quot;&quot;</span>
        <span class="s1">check_is_fitted</span><span class="s3">(</span><span class="s1">self</span><span class="s3">)</span>

        <span class="s1">xp</span><span class="s3">, </span><span class="s1">_ </span><span class="s3">= </span><span class="s1">get_namespace</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>

        <span class="s1">X </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_validate_data</span><span class="s3">(</span>
            <span class="s1">X</span><span class="s3">,</span>
            <span class="s1">copy</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">,</span>
            <span class="s1">dtype</span><span class="s3">=</span><span class="s1">_array_api</span><span class="s3">.</span><span class="s1">supported_float_dtypes</span><span class="s3">(</span><span class="s1">xp</span><span class="s3">),</span>
            <span class="s1">force_writeable</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
            <span class="s1">force_all_finite</span><span class="s3">=</span><span class="s5">&quot;allow-nan&quot;</span><span class="s3">,</span>
            <span class="s1">reset</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
        <span class="s3">)</span>

        <span class="s1">X </span><span class="s3">*= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">scale_</span>
        <span class="s1">X </span><span class="s3">+= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">min_</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">clip</span><span class="s3">:</span>
            <span class="s1">xp</span><span class="s3">.</span><span class="s1">clip</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">feature_range</span><span class="s3">[</span><span class="s4">0</span><span class="s3">], </span><span class="s1">self</span><span class="s3">.</span><span class="s1">feature_range</span><span class="s3">[</span><span class="s4">1</span><span class="s3">], </span><span class="s1">out</span><span class="s3">=</span><span class="s1">X</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">X</span>

    <span class="s2">def </span><span class="s1">inverse_transform</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot;Undo the scaling of X according to feature_range. 
 
        Parameters 
        ---------- 
        X : array-like of shape (n_samples, n_features) 
            Input data that will be transformed. It cannot be sparse. 
 
        Returns 
        ------- 
        Xt : ndarray of shape (n_samples, n_features) 
            Transformed data. 
        &quot;&quot;&quot;</span>
        <span class="s1">check_is_fitted</span><span class="s3">(</span><span class="s1">self</span><span class="s3">)</span>

        <span class="s1">xp</span><span class="s3">, </span><span class="s1">_ </span><span class="s3">= </span><span class="s1">get_namespace</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>

        <span class="s1">X </span><span class="s3">= </span><span class="s1">check_array</span><span class="s3">(</span>
            <span class="s1">X</span><span class="s3">,</span>
            <span class="s1">copy</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">,</span>
            <span class="s1">dtype</span><span class="s3">=</span><span class="s1">_array_api</span><span class="s3">.</span><span class="s1">supported_float_dtypes</span><span class="s3">(</span><span class="s1">xp</span><span class="s3">),</span>
            <span class="s1">force_writeable</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
            <span class="s1">force_all_finite</span><span class="s3">=</span><span class="s5">&quot;allow-nan&quot;</span><span class="s3">,</span>
        <span class="s3">)</span>

        <span class="s1">X </span><span class="s3">-= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">min_</span>
        <span class="s1">X </span><span class="s3">/= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">scale_</span>
        <span class="s2">return </span><span class="s1">X</span>

    <span class="s2">def </span><span class="s1">_more_tags</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s3">{</span><span class="s5">&quot;allow_nan&quot;</span><span class="s3">: </span><span class="s2">True</span><span class="s3">}</span>


<span class="s3">@</span><span class="s1">validate_params</span><span class="s3">(</span>
    <span class="s3">{</span>
        <span class="s5">&quot;X&quot;</span><span class="s3">: [</span><span class="s5">&quot;array-like&quot;</span><span class="s3">],</span>
        <span class="s5">&quot;axis&quot;</span><span class="s3">: [</span><span class="s1">Options</span><span class="s3">(</span><span class="s1">Integral</span><span class="s3">, {</span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">})],</span>
    <span class="s3">},</span>
    <span class="s1">prefer_skip_nested_validation</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
<span class="s3">)</span>
<span class="s2">def </span><span class="s1">minmax_scale</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">feature_range</span><span class="s3">=(</span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">), *, </span><span class="s1">axis</span><span class="s3">=</span><span class="s4">0</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Transform features by scaling each feature to a given range. 
 
    This estimator scales and translates each feature individually such 
    that it is in the given range on the training set, i.e. between 
    zero and one. 
 
    The transformation is given by (when ``axis=0``):: 
 
        X_std = (X - X.min(axis=0)) / (X.max(axis=0) - X.min(axis=0)) 
        X_scaled = X_std * (max - min) + min 
 
    where min, max = feature_range. 
 
    The transformation is calculated as (when ``axis=0``):: 
 
       X_scaled = scale * X + min - X.min(axis=0) * scale 
       where scale = (max - min) / (X.max(axis=0) - X.min(axis=0)) 
 
    This transformation is often used as an alternative to zero mean, 
    unit variance scaling. 
 
    Read more in the :ref:`User Guide &lt;preprocessing_scaler&gt;`. 
 
    .. versionadded:: 0.17 
       *minmax_scale* function interface 
       to :class:`~sklearn.preprocessing.MinMaxScaler`. 
 
    Parameters 
    ---------- 
    X : array-like of shape (n_samples, n_features) 
        The data. 
 
    feature_range : tuple (min, max), default=(0, 1) 
        Desired range of transformed data. 
 
    axis : {0, 1}, default=0 
        Axis used to scale along. If 0, independently scale each feature, 
        otherwise (if 1) scale each sample. 
 
    copy : bool, default=True 
        If False, try to avoid a copy and scale in place. 
        This is not guaranteed to always work in place; e.g. if the data is 
        a numpy array with an int dtype, a copy will be returned even with 
        copy=False. 
 
    Returns 
    ------- 
    X_tr : ndarray of shape (n_samples, n_features) 
        The transformed data. 
 
    .. warning:: Risk of data leak 
 
        Do not use :func:`~sklearn.preprocessing.minmax_scale` unless you know 
        what you are doing. A common mistake is to apply it to the entire data 
        *before* splitting into training and test sets. This will bias the 
        model evaluation because information would have leaked from the test 
        set to the training set. 
        In general, we recommend using 
        :class:`~sklearn.preprocessing.MinMaxScaler` within a 
        :ref:`Pipeline &lt;pipeline&gt;` in order to prevent most risks of data 
        leaking: `pipe = make_pipeline(MinMaxScaler(), LogisticRegression())`. 
 
    See Also 
    -------- 
    MinMaxScaler : Performs scaling to a given range using the Transformer 
        API (e.g. as part of a preprocessing 
        :class:`~sklearn.pipeline.Pipeline`). 
 
    Notes 
    ----- 
    For a comparison of the different scalers, transformers, and normalizers, 
    see: :ref:`sphx_glr_auto_examples_preprocessing_plot_all_scaling.py`. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from sklearn.preprocessing import minmax_scale 
    &gt;&gt;&gt; X = [[-2, 1, 2], [-1, 0, 1]] 
    &gt;&gt;&gt; minmax_scale(X, axis=0)  # scale each column independently 
    array([[0., 1., 1.], 
           [1., 0., 0.]]) 
    &gt;&gt;&gt; minmax_scale(X, axis=1)  # scale each row independently 
    array([[0.  , 0.75, 1.  ], 
           [0.  , 0.5 , 1.  ]]) 
    &quot;&quot;&quot;</span>
    <span class="s0"># Unlike the scaler object, this function allows 1d input.</span>
    <span class="s0"># If copy is required, it will be done inside the scaler object.</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">check_array</span><span class="s3">(</span>
        <span class="s1">X</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">ensure_2d</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">FLOAT_DTYPES</span><span class="s3">, </span><span class="s1">force_all_finite</span><span class="s3">=</span><span class="s5">&quot;allow-nan&quot;</span>
    <span class="s3">)</span>
    <span class="s1">original_ndim </span><span class="s3">= </span><span class="s1">X</span><span class="s3">.</span><span class="s1">ndim</span>

    <span class="s2">if </span><span class="s1">original_ndim </span><span class="s3">== </span><span class="s4">1</span><span class="s3">:</span>
        <span class="s1">X </span><span class="s3">= </span><span class="s1">X</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">(</span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s4">0</span><span class="s3">], </span><span class="s4">1</span><span class="s3">)</span>

    <span class="s1">s </span><span class="s3">= </span><span class="s1">MinMaxScaler</span><span class="s3">(</span><span class="s1">feature_range</span><span class="s3">=</span><span class="s1">feature_range</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s1">copy</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">axis </span><span class="s3">== </span><span class="s4">0</span><span class="s3">:</span>
        <span class="s1">X </span><span class="s3">= </span><span class="s1">s</span><span class="s3">.</span><span class="s1">fit_transform</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">X </span><span class="s3">= </span><span class="s1">s</span><span class="s3">.</span><span class="s1">fit_transform</span><span class="s3">(</span><span class="s1">X</span><span class="s3">.</span><span class="s1">T</span><span class="s3">).</span><span class="s1">T</span>

    <span class="s2">if </span><span class="s1">original_ndim </span><span class="s3">== </span><span class="s4">1</span><span class="s3">:</span>
        <span class="s1">X </span><span class="s3">= </span><span class="s1">X</span><span class="s3">.</span><span class="s1">ravel</span><span class="s3">()</span>

    <span class="s2">return </span><span class="s1">X</span>


<span class="s2">class </span><span class="s1">StandardScaler</span><span class="s3">(</span><span class="s1">OneToOneFeatureMixin</span><span class="s3">, </span><span class="s1">TransformerMixin</span><span class="s3">, </span><span class="s1">BaseEstimator</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Standardize features by removing the mean and scaling to unit variance. 
 
    The standard score of a sample `x` is calculated as: 
 
        z = (x - u) / s 
 
    where `u` is the mean of the training samples or zero if `with_mean=False`, 
    and `s` is the standard deviation of the training samples or one if 
    `with_std=False`. 
 
    Centering and scaling happen independently on each feature by computing 
    the relevant statistics on the samples in the training set. Mean and 
    standard deviation are then stored to be used on later data using 
    :meth:`transform`. 
 
    Standardization of a dataset is a common requirement for many 
    machine learning estimators: they might behave badly if the 
    individual features do not more or less look like standard normally 
    distributed data (e.g. Gaussian with 0 mean and unit variance). 
 
    For instance many elements used in the objective function of 
    a learning algorithm (such as the RBF kernel of Support Vector 
    Machines or the L1 and L2 regularizers of linear models) assume that 
    all features are centered around 0 and have variance in the same 
    order. If a feature has a variance that is orders of magnitude larger 
    than others, it might dominate the objective function and make the 
    estimator unable to learn from other features correctly as expected. 
 
    `StandardScaler` is sensitive to outliers, and the features may scale 
    differently from each other in the presence of outliers. For an example 
    visualization, refer to :ref:`Compare StandardScaler with other scalers 
    &lt;plot_all_scaling_standard_scaler_section&gt;`. 
 
    This scaler can also be applied to sparse CSR or CSC matrices by passing 
    `with_mean=False` to avoid breaking the sparsity structure of the data. 
 
    Read more in the :ref:`User Guide &lt;preprocessing_scaler&gt;`. 
 
    Parameters 
    ---------- 
    copy : bool, default=True 
        If False, try to avoid a copy and do inplace scaling instead. 
        This is not guaranteed to always work inplace; e.g. if the data is 
        not a NumPy array or scipy.sparse CSR matrix, a copy may still be 
        returned. 
 
    with_mean : bool, default=True 
        If True, center the data before scaling. 
        This does not work (and will raise an exception) when attempted on 
        sparse matrices, because centering them entails building a dense 
        matrix which in common use cases is likely to be too large to fit in 
        memory. 
 
    with_std : bool, default=True 
        If True, scale the data to unit variance (or equivalently, 
        unit standard deviation). 
 
    Attributes 
    ---------- 
    scale_ : ndarray of shape (n_features,) or None 
        Per feature relative scaling of the data to achieve zero mean and unit 
        variance. Generally this is calculated using `np.sqrt(var_)`. If a 
        variance is zero, we can't achieve unit variance, and the data is left 
        as-is, giving a scaling factor of 1. `scale_` is equal to `None` 
        when `with_std=False`. 
 
        .. versionadded:: 0.17 
           *scale_* 
 
    mean_ : ndarray of shape (n_features,) or None 
        The mean value for each feature in the training set. 
        Equal to ``None`` when ``with_mean=False`` and ``with_std=False``. 
 
    var_ : ndarray of shape (n_features,) or None 
        The variance for each feature in the training set. Used to compute 
        `scale_`. Equal to ``None`` when ``with_mean=False`` and 
        ``with_std=False``. 
 
    n_features_in_ : int 
        Number of features seen during :term:`fit`. 
 
        .. versionadded:: 0.24 
 
    feature_names_in_ : ndarray of shape (`n_features_in_`,) 
        Names of features seen during :term:`fit`. Defined only when `X` 
        has feature names that are all strings. 
 
        .. versionadded:: 1.0 
 
    n_samples_seen_ : int or ndarray of shape (n_features,) 
        The number of samples processed by the estimator for each feature. 
        If there are no missing samples, the ``n_samples_seen`` will be an 
        integer, otherwise it will be an array of dtype int. If 
        `sample_weights` are used it will be a float (if no missing data) 
        or an array of dtype float that sums the weights seen so far. 
        Will be reset on new calls to fit, but increments across 
        ``partial_fit`` calls. 
 
    See Also 
    -------- 
    scale : Equivalent function without the estimator API. 
 
    :class:`~sklearn.decomposition.PCA` : Further removes the linear 
        correlation across features with 'whiten=True'. 
 
    Notes 
    ----- 
    NaNs are treated as missing values: disregarded in fit, and maintained in 
    transform. 
 
    We use a biased estimator for the standard deviation, equivalent to 
    `numpy.std(x, ddof=0)`. Note that the choice of `ddof` is unlikely to 
    affect model performance. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from sklearn.preprocessing import StandardScaler 
    &gt;&gt;&gt; data = [[0, 0], [0, 0], [1, 1], [1, 1]] 
    &gt;&gt;&gt; scaler = StandardScaler() 
    &gt;&gt;&gt; print(scaler.fit(data)) 
    StandardScaler() 
    &gt;&gt;&gt; print(scaler.mean_) 
    [0.5 0.5] 
    &gt;&gt;&gt; print(scaler.transform(data)) 
    [[-1. -1.] 
     [-1. -1.] 
     [ 1.  1.] 
     [ 1.  1.]] 
    &gt;&gt;&gt; print(scaler.transform([[2, 2]])) 
    [[3. 3.]] 
    &quot;&quot;&quot;</span>

    <span class="s1">_parameter_constraints</span><span class="s3">: </span><span class="s1">dict </span><span class="s3">= {</span>
        <span class="s5">&quot;copy&quot;</span><span class="s3">: [</span><span class="s5">&quot;boolean&quot;</span><span class="s3">],</span>
        <span class="s5">&quot;with_mean&quot;</span><span class="s3">: [</span><span class="s5">&quot;boolean&quot;</span><span class="s3">],</span>
        <span class="s5">&quot;with_std&quot;</span><span class="s3">: [</span><span class="s5">&quot;boolean&quot;</span><span class="s3">],</span>
    <span class="s3">}</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, *, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">with_mean</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">with_std</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">with_mean </span><span class="s3">= </span><span class="s1">with_mean</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">with_std </span><span class="s3">= </span><span class="s1">with_std</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">copy </span><span class="s3">= </span><span class="s1">copy</span>

    <span class="s2">def </span><span class="s1">_reset</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot;Reset internal data-dependent state of the scaler, if necessary. 
 
        __init__ parameters are not touched. 
        &quot;&quot;&quot;</span>
        <span class="s0"># Checking one attribute is enough, because they are all set together</span>
        <span class="s0"># in partial_fit</span>
        <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s5">&quot;scale_&quot;</span><span class="s3">):</span>
            <span class="s2">del </span><span class="s1">self</span><span class="s3">.</span><span class="s1">scale_</span>
            <span class="s2">del </span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_samples_seen_</span>
            <span class="s2">del </span><span class="s1">self</span><span class="s3">.</span><span class="s1">mean_</span>
            <span class="s2">del </span><span class="s1">self</span><span class="s3">.</span><span class="s1">var_</span>

    <span class="s2">def </span><span class="s1">fit</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">sample_weight</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot;Compute the mean and std to be used for later scaling. 
 
        Parameters 
        ---------- 
        X : {array-like, sparse matrix} of shape (n_samples, n_features) 
            The data used to compute the mean and standard deviation 
            used for later scaling along the features axis. 
 
        y : None 
            Ignored. 
 
        sample_weight : array-like of shape (n_samples,), default=None 
            Individual weights for each sample. 
 
            .. versionadded:: 0.24 
               parameter *sample_weight* support to StandardScaler. 
 
        Returns 
        ------- 
        self : object 
            Fitted scaler. 
        &quot;&quot;&quot;</span>
        <span class="s0"># Reset internal state before fitting</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_reset</span><span class="s3">()</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">partial_fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">sample_weight</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">_fit_context</span><span class="s3">(</span><span class="s1">prefer_skip_nested_validation</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
    <span class="s2">def </span><span class="s1">partial_fit</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">sample_weight</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot;Online computation of mean and std on X for later scaling. 
 
        All of X is processed as a single batch. This is intended for cases 
        when :meth:`fit` is not feasible due to very large number of 
        `n_samples` or because X is read from a continuous stream. 
 
        The algorithm for incremental mean and std is given in Equation 1.5a,b 
        in Chan, Tony F., Gene H. Golub, and Randall J. LeVeque. &quot;Algorithms 
        for computing the sample variance: Analysis and recommendations.&quot; 
        The American Statistician 37.3 (1983): 242-247: 
 
        Parameters 
        ---------- 
        X : {array-like, sparse matrix} of shape (n_samples, n_features) 
            The data used to compute the mean and standard deviation 
            used for later scaling along the features axis. 
 
        y : None 
            Ignored. 
 
        sample_weight : array-like of shape (n_samples,), default=None 
            Individual weights for each sample. 
 
            .. versionadded:: 0.24 
               parameter *sample_weight* support to StandardScaler. 
 
        Returns 
        ------- 
        self : object 
            Fitted scaler. 
        &quot;&quot;&quot;</span>
        <span class="s1">first_call </span><span class="s3">= </span><span class="s2">not </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s5">&quot;n_samples_seen_&quot;</span><span class="s3">)</span>
        <span class="s1">X </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_validate_data</span><span class="s3">(</span>
            <span class="s1">X</span><span class="s3">,</span>
            <span class="s1">accept_sparse</span><span class="s3">=(</span><span class="s5">&quot;csr&quot;</span><span class="s3">, </span><span class="s5">&quot;csc&quot;</span><span class="s3">),</span>
            <span class="s1">dtype</span><span class="s3">=</span><span class="s1">FLOAT_DTYPES</span><span class="s3">,</span>
            <span class="s1">force_all_finite</span><span class="s3">=</span><span class="s5">&quot;allow-nan&quot;</span><span class="s3">,</span>
            <span class="s1">reset</span><span class="s3">=</span><span class="s1">first_call</span><span class="s3">,</span>
        <span class="s3">)</span>
        <span class="s1">n_features </span><span class="s3">= </span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s4">1</span><span class="s3">]</span>

        <span class="s2">if </span><span class="s1">sample_weight </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s1">sample_weight </span><span class="s3">= </span><span class="s1">_check_sample_weight</span><span class="s3">(</span><span class="s1">sample_weight</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">X</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>

        <span class="s0"># Even in the case of `with_mean=False`, we update the mean anyway</span>
        <span class="s0"># This is needed for the incremental computation of the var</span>
        <span class="s0"># See incr_mean_variance_axis and _incremental_mean_variance_axis</span>

        <span class="s0"># if n_samples_seen_ is an integer (i.e. no missing values), we need to</span>
        <span class="s0"># transform it to a NumPy array of shape (n_features,) required by</span>
        <span class="s0"># incr_mean_variance_axis and _incremental_variance_axis</span>
        <span class="s1">dtype </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">int64 </span><span class="s2">if </span><span class="s1">sample_weight </span><span class="s2">is None else </span><span class="s1">X</span><span class="s3">.</span><span class="s1">dtype</span>
        <span class="s2">if not </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s5">&quot;n_samples_seen_&quot;</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">n_samples_seen_ </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">n_features</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dtype</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">np</span><span class="s3">.</span><span class="s1">size</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_samples_seen_</span><span class="s3">) == </span><span class="s4">1</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">n_samples_seen_ </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">repeat</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_samples_seen_</span><span class="s3">, </span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s4">1</span><span class="s3">])</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">n_samples_seen_ </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_samples_seen_</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">sparse</span><span class="s3">.</span><span class="s1">issparse</span><span class="s3">(</span><span class="s1">X</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">with_mean</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span>
                    <span class="s5">&quot;Cannot center sparse matrices: pass `with_mean=False` &quot;</span>
                    <span class="s5">&quot;instead. See docstring for motivation and alternatives.&quot;</span>
                <span class="s3">)</span>
            <span class="s1">sparse_constructor </span><span class="s3">= (</span>
                <span class="s1">sparse</span><span class="s3">.</span><span class="s1">csr_matrix </span><span class="s2">if </span><span class="s1">X</span><span class="s3">.</span><span class="s1">format </span><span class="s3">== </span><span class="s5">&quot;csr&quot; </span><span class="s2">else </span><span class="s1">sparse</span><span class="s3">.</span><span class="s1">csc_matrix</span>
            <span class="s3">)</span>

            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">with_std</span><span class="s3">:</span>
                <span class="s0"># First pass</span>
                <span class="s2">if not </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s5">&quot;scale_&quot;</span><span class="s3">):</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">mean_</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">var_</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_samples_seen_ </span><span class="s3">= </span><span class="s1">mean_variance_axis</span><span class="s3">(</span>
                        <span class="s1">X</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s4">0</span><span class="s3">, </span><span class="s1">weights</span><span class="s3">=</span><span class="s1">sample_weight</span><span class="s3">, </span><span class="s1">return_sum_weights</span><span class="s3">=</span><span class="s2">True</span>
                    <span class="s3">)</span>
                <span class="s0"># Next passes</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s3">(</span>
                        <span class="s1">self</span><span class="s3">.</span><span class="s1">mean_</span><span class="s3">,</span>
                        <span class="s1">self</span><span class="s3">.</span><span class="s1">var_</span><span class="s3">,</span>
                        <span class="s1">self</span><span class="s3">.</span><span class="s1">n_samples_seen_</span><span class="s3">,</span>
                    <span class="s3">) = </span><span class="s1">incr_mean_variance_axis</span><span class="s3">(</span>
                        <span class="s1">X</span><span class="s3">,</span>
                        <span class="s1">axis</span><span class="s3">=</span><span class="s4">0</span><span class="s3">,</span>
                        <span class="s1">last_mean</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">mean_</span><span class="s3">,</span>
                        <span class="s1">last_var</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">var_</span><span class="s3">,</span>
                        <span class="s1">last_n</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_samples_seen_</span><span class="s3">,</span>
                        <span class="s1">weights</span><span class="s3">=</span><span class="s1">sample_weight</span><span class="s3">,</span>
                    <span class="s3">)</span>
                <span class="s0"># We force the mean and variance to float64 for large arrays</span>
                <span class="s0"># See https://github.com/scikit-learn/scikit-learn/pull/12338</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">mean_ </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">mean_</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">var_ </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">var_</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">mean_ </span><span class="s3">= </span><span class="s2">None  </span><span class="s0"># as with_mean must be False for sparse</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">var_ </span><span class="s3">= </span><span class="s2">None</span>
                <span class="s1">weights </span><span class="s3">= </span><span class="s1">_check_sample_weight</span><span class="s3">(</span><span class="s1">sample_weight</span><span class="s3">, </span><span class="s1">X</span><span class="s3">)</span>
                <span class="s1">sum_weights_nan </span><span class="s3">= </span><span class="s1">weights </span><span class="s3">@ </span><span class="s1">sparse_constructor</span><span class="s3">(</span>
                    <span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">isnan</span><span class="s3">(</span><span class="s1">X</span><span class="s3">.</span><span class="s1">data</span><span class="s3">), </span><span class="s1">X</span><span class="s3">.</span><span class="s1">indices</span><span class="s3">, </span><span class="s1">X</span><span class="s3">.</span><span class="s1">indptr</span><span class="s3">), </span><span class="s1">shape</span><span class="s3">=</span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span>
                <span class="s3">)</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">n_samples_seen_ </span><span class="s3">+= (</span><span class="s1">np</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">(</span><span class="s1">weights</span><span class="s3">) - </span><span class="s1">sum_weights_nan</span><span class="s3">).</span><span class="s1">astype</span><span class="s3">(</span>
                    <span class="s1">dtype</span>
                <span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s0"># First pass</span>
            <span class="s2">if not </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s5">&quot;scale_&quot;</span><span class="s3">):</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">mean_ </span><span class="s3">= </span><span class="s4">0.0</span>
                <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">with_std</span><span class="s3">:</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">var_ </span><span class="s3">= </span><span class="s4">0.0</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">var_ </span><span class="s3">= </span><span class="s2">None</span>

            <span class="s2">if not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">with_mean </span><span class="s2">and not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">with_std</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">mean_ </span><span class="s3">= </span><span class="s2">None</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">var_ </span><span class="s3">= </span><span class="s2">None</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">n_samples_seen_ </span><span class="s3">+= </span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] - </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isnan</span><span class="s3">(</span><span class="s1">X</span><span class="s3">).</span><span class="s1">sum</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">=</span><span class="s4">0</span><span class="s3">)</span>

            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">mean_</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">var_</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_samples_seen_ </span><span class="s3">= </span><span class="s1">_incremental_mean_and_var</span><span class="s3">(</span>
                    <span class="s1">X</span><span class="s3">,</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">mean_</span><span class="s3">,</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">var_</span><span class="s3">,</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">n_samples_seen_</span><span class="s3">,</span>
                    <span class="s1">sample_weight</span><span class="s3">=</span><span class="s1">sample_weight</span><span class="s3">,</span>
                <span class="s3">)</span>

        <span class="s0"># for backward-compatibility, reduce n_samples_seen_ to an integer</span>
        <span class="s0"># if the number of samples is the same for each feature (i.e. no</span>
        <span class="s0"># missing values)</span>
        <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ptp</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_samples_seen_</span><span class="s3">) == </span><span class="s4">0</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">n_samples_seen_ </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_samples_seen_</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]</span>

        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">with_std</span><span class="s3">:</span>
            <span class="s0"># Extract the list of near constant features on the raw variances,</span>
            <span class="s0"># before taking the square root.</span>
            <span class="s1">constant_mask </span><span class="s3">= </span><span class="s1">_is_constant_feature</span><span class="s3">(</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">var_</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">mean_</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_samples_seen_</span>
            <span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">scale_ </span><span class="s3">= </span><span class="s1">_handle_zeros_in_scale</span><span class="s3">(</span>
                <span class="s1">np</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">var_</span><span class="s3">), </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">constant_mask</span><span class="s3">=</span><span class="s1">constant_mask</span>
            <span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">scale_ </span><span class="s3">= </span><span class="s2">None</span>

        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">transform</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot;Perform standardization by centering and scaling. 
 
        Parameters 
        ---------- 
        X : {array-like, sparse matrix of shape (n_samples, n_features) 
            The data used to scale along the features axis. 
        copy : bool, default=None 
            Copy the input X or not. 
 
        Returns 
        ------- 
        X_tr : {ndarray, sparse matrix} of shape (n_samples, n_features) 
            Transformed array. 
        &quot;&quot;&quot;</span>
        <span class="s1">check_is_fitted</span><span class="s3">(</span><span class="s1">self</span><span class="s3">)</span>

        <span class="s1">copy </span><span class="s3">= </span><span class="s1">copy </span><span class="s2">if </span><span class="s1">copy </span><span class="s2">is not None else </span><span class="s1">self</span><span class="s3">.</span><span class="s1">copy</span>
        <span class="s1">X </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_validate_data</span><span class="s3">(</span>
            <span class="s1">X</span><span class="s3">,</span>
            <span class="s1">reset</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
            <span class="s1">accept_sparse</span><span class="s3">=</span><span class="s5">&quot;csr&quot;</span><span class="s3">,</span>
            <span class="s1">copy</span><span class="s3">=</span><span class="s1">copy</span><span class="s3">,</span>
            <span class="s1">dtype</span><span class="s3">=</span><span class="s1">FLOAT_DTYPES</span><span class="s3">,</span>
            <span class="s1">force_writeable</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
            <span class="s1">force_all_finite</span><span class="s3">=</span><span class="s5">&quot;allow-nan&quot;</span><span class="s3">,</span>
        <span class="s3">)</span>

        <span class="s2">if </span><span class="s1">sparse</span><span class="s3">.</span><span class="s1">issparse</span><span class="s3">(</span><span class="s1">X</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">with_mean</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span>
                    <span class="s5">&quot;Cannot center sparse matrices: pass `with_mean=False` &quot;</span>
                    <span class="s5">&quot;instead. See docstring for motivation and alternatives.&quot;</span>
                <span class="s3">)</span>
            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">scale_ </span><span class="s2">is not None</span><span class="s3">:</span>
                <span class="s1">inplace_column_scale</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s4">1 </span><span class="s3">/ </span><span class="s1">self</span><span class="s3">.</span><span class="s1">scale_</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">with_mean</span><span class="s3">:</span>
                <span class="s1">X </span><span class="s3">-= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">mean_</span>
            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">with_std</span><span class="s3">:</span>
                <span class="s1">X </span><span class="s3">/= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">scale_</span>
        <span class="s2">return </span><span class="s1">X</span>

    <span class="s2">def </span><span class="s1">inverse_transform</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot;Scale back the data to the original representation. 
 
        Parameters 
        ---------- 
        X : {array-like, sparse matrix} of shape (n_samples, n_features) 
            The data used to scale along the features axis. 
        copy : bool, default=None 
            Copy the input X or not. 
 
        Returns 
        ------- 
        X_tr : {ndarray, sparse matrix} of shape (n_samples, n_features) 
            Transformed array. 
        &quot;&quot;&quot;</span>
        <span class="s1">check_is_fitted</span><span class="s3">(</span><span class="s1">self</span><span class="s3">)</span>

        <span class="s1">copy </span><span class="s3">= </span><span class="s1">copy </span><span class="s2">if </span><span class="s1">copy </span><span class="s2">is not None else </span><span class="s1">self</span><span class="s3">.</span><span class="s1">copy</span>
        <span class="s1">X </span><span class="s3">= </span><span class="s1">check_array</span><span class="s3">(</span>
            <span class="s1">X</span><span class="s3">,</span>
            <span class="s1">accept_sparse</span><span class="s3">=</span><span class="s5">&quot;csr&quot;</span><span class="s3">,</span>
            <span class="s1">copy</span><span class="s3">=</span><span class="s1">copy</span><span class="s3">,</span>
            <span class="s1">dtype</span><span class="s3">=</span><span class="s1">FLOAT_DTYPES</span><span class="s3">,</span>
            <span class="s1">force_writeable</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
            <span class="s1">force_all_finite</span><span class="s3">=</span><span class="s5">&quot;allow-nan&quot;</span><span class="s3">,</span>
        <span class="s3">)</span>

        <span class="s2">if </span><span class="s1">sparse</span><span class="s3">.</span><span class="s1">issparse</span><span class="s3">(</span><span class="s1">X</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">with_mean</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span>
                    <span class="s5">&quot;Cannot uncenter sparse matrices: pass `with_mean=False` &quot;</span>
                    <span class="s5">&quot;instead See docstring for motivation and alternatives.&quot;</span>
                <span class="s3">)</span>
            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">scale_ </span><span class="s2">is not None</span><span class="s3">:</span>
                <span class="s1">inplace_column_scale</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">scale_</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">with_std</span><span class="s3">:</span>
                <span class="s1">X </span><span class="s3">*= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">scale_</span>
            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">with_mean</span><span class="s3">:</span>
                <span class="s1">X </span><span class="s3">+= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">mean_</span>
        <span class="s2">return </span><span class="s1">X</span>

    <span class="s2">def </span><span class="s1">_more_tags</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s3">{</span><span class="s5">&quot;allow_nan&quot;</span><span class="s3">: </span><span class="s2">True</span><span class="s3">, </span><span class="s5">&quot;preserves_dtype&quot;</span><span class="s3">: [</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">float32</span><span class="s3">]}</span>


<span class="s2">class </span><span class="s1">MaxAbsScaler</span><span class="s3">(</span><span class="s1">OneToOneFeatureMixin</span><span class="s3">, </span><span class="s1">TransformerMixin</span><span class="s3">, </span><span class="s1">BaseEstimator</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Scale each feature by its maximum absolute value. 
 
    This estimator scales and translates each feature individually such 
    that the maximal absolute value of each feature in the 
    training set will be 1.0. It does not shift/center the data, and 
    thus does not destroy any sparsity. 
 
    This scaler can also be applied to sparse CSR or CSC matrices. 
 
    `MaxAbsScaler` doesn't reduce the effect of outliers; it only linearly 
    scales them down. For an example visualization, refer to :ref:`Compare 
    MaxAbsScaler with other scalers &lt;plot_all_scaling_max_abs_scaler_section&gt;`. 
 
    .. versionadded:: 0.17 
 
    Parameters 
    ---------- 
    copy : bool, default=True 
        Set to False to perform inplace scaling and avoid a copy (if the input 
        is already a numpy array). 
 
    Attributes 
    ---------- 
    scale_ : ndarray of shape (n_features,) 
        Per feature relative scaling of the data. 
 
        .. versionadded:: 0.17 
           *scale_* attribute. 
 
    max_abs_ : ndarray of shape (n_features,) 
        Per feature maximum absolute value. 
 
    n_features_in_ : int 
        Number of features seen during :term:`fit`. 
 
        .. versionadded:: 0.24 
 
    feature_names_in_ : ndarray of shape (`n_features_in_`,) 
        Names of features seen during :term:`fit`. Defined only when `X` 
        has feature names that are all strings. 
 
        .. versionadded:: 1.0 
 
    n_samples_seen_ : int 
        The number of samples processed by the estimator. Will be reset on 
        new calls to fit, but increments across ``partial_fit`` calls. 
 
    See Also 
    -------- 
    maxabs_scale : Equivalent function without the estimator API. 
 
    Notes 
    ----- 
    NaNs are treated as missing values: disregarded in fit, and maintained in 
    transform. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from sklearn.preprocessing import MaxAbsScaler 
    &gt;&gt;&gt; X = [[ 1., -1.,  2.], 
    ...      [ 2.,  0.,  0.], 
    ...      [ 0.,  1., -1.]] 
    &gt;&gt;&gt; transformer = MaxAbsScaler().fit(X) 
    &gt;&gt;&gt; transformer 
    MaxAbsScaler() 
    &gt;&gt;&gt; transformer.transform(X) 
    array([[ 0.5, -1. ,  1. ], 
           [ 1. ,  0. ,  0. ], 
           [ 0. ,  1. , -0.5]]) 
    &quot;&quot;&quot;</span>

    <span class="s1">_parameter_constraints</span><span class="s3">: </span><span class="s1">dict </span><span class="s3">= {</span><span class="s5">&quot;copy&quot;</span><span class="s3">: [</span><span class="s5">&quot;boolean&quot;</span><span class="s3">]}</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, *, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">copy </span><span class="s3">= </span><span class="s1">copy</span>

    <span class="s2">def </span><span class="s1">_reset</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot;Reset internal data-dependent state of the scaler, if necessary. 
 
        __init__ parameters are not touched. 
        &quot;&quot;&quot;</span>
        <span class="s0"># Checking one attribute is enough, because they are all set together</span>
        <span class="s0"># in partial_fit</span>
        <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s5">&quot;scale_&quot;</span><span class="s3">):</span>
            <span class="s2">del </span><span class="s1">self</span><span class="s3">.</span><span class="s1">scale_</span>
            <span class="s2">del </span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_samples_seen_</span>
            <span class="s2">del </span><span class="s1">self</span><span class="s3">.</span><span class="s1">max_abs_</span>

    <span class="s2">def </span><span class="s1">fit</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot;Compute the maximum absolute value to be used for later scaling. 
 
        Parameters 
        ---------- 
        X : {array-like, sparse matrix} of shape (n_samples, n_features) 
            The data used to compute the per-feature minimum and maximum 
            used for later scaling along the features axis. 
 
        y : None 
            Ignored. 
 
        Returns 
        ------- 
        self : object 
            Fitted scaler. 
        &quot;&quot;&quot;</span>
        <span class="s0"># Reset internal state before fitting</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_reset</span><span class="s3">()</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">partial_fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">_fit_context</span><span class="s3">(</span><span class="s1">prefer_skip_nested_validation</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
    <span class="s2">def </span><span class="s1">partial_fit</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot;Online computation of max absolute value of X for later scaling. 
 
        All of X is processed as a single batch. This is intended for cases 
        when :meth:`fit` is not feasible due to very large number of 
        `n_samples` or because X is read from a continuous stream. 
 
        Parameters 
        ---------- 
        X : {array-like, sparse matrix} of shape (n_samples, n_features) 
            The data used to compute the mean and standard deviation 
            used for later scaling along the features axis. 
 
        y : None 
            Ignored. 
 
        Returns 
        ------- 
        self : object 
            Fitted scaler. 
        &quot;&quot;&quot;</span>
        <span class="s1">xp</span><span class="s3">, </span><span class="s1">_ </span><span class="s3">= </span><span class="s1">get_namespace</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>

        <span class="s1">first_pass </span><span class="s3">= </span><span class="s2">not </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s5">&quot;n_samples_seen_&quot;</span><span class="s3">)</span>
        <span class="s1">X </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_validate_data</span><span class="s3">(</span>
            <span class="s1">X</span><span class="s3">,</span>
            <span class="s1">reset</span><span class="s3">=</span><span class="s1">first_pass</span><span class="s3">,</span>
            <span class="s1">accept_sparse</span><span class="s3">=(</span><span class="s5">&quot;csr&quot;</span><span class="s3">, </span><span class="s5">&quot;csc&quot;</span><span class="s3">),</span>
            <span class="s1">dtype</span><span class="s3">=</span><span class="s1">_array_api</span><span class="s3">.</span><span class="s1">supported_float_dtypes</span><span class="s3">(</span><span class="s1">xp</span><span class="s3">),</span>
            <span class="s1">force_all_finite</span><span class="s3">=</span><span class="s5">&quot;allow-nan&quot;</span><span class="s3">,</span>
        <span class="s3">)</span>

        <span class="s2">if </span><span class="s1">sparse</span><span class="s3">.</span><span class="s1">issparse</span><span class="s3">(</span><span class="s1">X</span><span class="s3">):</span>
            <span class="s1">mins</span><span class="s3">, </span><span class="s1">maxs </span><span class="s3">= </span><span class="s1">min_max_axis</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s4">0</span><span class="s3">, </span><span class="s1">ignore_nan</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
            <span class="s1">max_abs </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">maximum</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">mins</span><span class="s3">), </span><span class="s1">np</span><span class="s3">.</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">maxs</span><span class="s3">))</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">max_abs </span><span class="s3">= </span><span class="s1">_array_api</span><span class="s3">.</span><span class="s1">_nanmax</span><span class="s3">(</span><span class="s1">xp</span><span class="s3">.</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">X</span><span class="s3">), </span><span class="s1">axis</span><span class="s3">=</span><span class="s4">0</span><span class="s3">, </span><span class="s1">xp</span><span class="s3">=</span><span class="s1">xp</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">first_pass</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">n_samples_seen_ </span><span class="s3">= </span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">max_abs </span><span class="s3">= </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">maximum</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">max_abs_</span><span class="s3">, </span><span class="s1">max_abs</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">n_samples_seen_ </span><span class="s3">+= </span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">max_abs_ </span><span class="s3">= </span><span class="s1">max_abs</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">scale_ </span><span class="s3">= </span><span class="s1">_handle_zeros_in_scale</span><span class="s3">(</span><span class="s1">max_abs</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">transform</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot;Scale the data. 
 
        Parameters 
        ---------- 
        X : {array-like, sparse matrix} of shape (n_samples, n_features) 
            The data that should be scaled. 
 
        Returns 
        ------- 
        X_tr : {ndarray, sparse matrix} of shape (n_samples, n_features) 
            Transformed array. 
        &quot;&quot;&quot;</span>
        <span class="s1">check_is_fitted</span><span class="s3">(</span><span class="s1">self</span><span class="s3">)</span>

        <span class="s1">xp</span><span class="s3">, </span><span class="s1">_ </span><span class="s3">= </span><span class="s1">get_namespace</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>

        <span class="s1">X </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_validate_data</span><span class="s3">(</span>
            <span class="s1">X</span><span class="s3">,</span>
            <span class="s1">accept_sparse</span><span class="s3">=(</span><span class="s5">&quot;csr&quot;</span><span class="s3">, </span><span class="s5">&quot;csc&quot;</span><span class="s3">),</span>
            <span class="s1">copy</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">,</span>
            <span class="s1">reset</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
            <span class="s1">dtype</span><span class="s3">=</span><span class="s1">_array_api</span><span class="s3">.</span><span class="s1">supported_float_dtypes</span><span class="s3">(</span><span class="s1">xp</span><span class="s3">),</span>
            <span class="s1">force_writeable</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
            <span class="s1">force_all_finite</span><span class="s3">=</span><span class="s5">&quot;allow-nan&quot;</span><span class="s3">,</span>
        <span class="s3">)</span>

        <span class="s2">if </span><span class="s1">sparse</span><span class="s3">.</span><span class="s1">issparse</span><span class="s3">(</span><span class="s1">X</span><span class="s3">):</span>
            <span class="s1">inplace_column_scale</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s4">1.0 </span><span class="s3">/ </span><span class="s1">self</span><span class="s3">.</span><span class="s1">scale_</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">X </span><span class="s3">/= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">scale_</span>
        <span class="s2">return </span><span class="s1">X</span>

    <span class="s2">def </span><span class="s1">inverse_transform</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot;Scale back the data to the original representation. 
 
        Parameters 
        ---------- 
        X : {array-like, sparse matrix} of shape (n_samples, n_features) 
            The data that should be transformed back. 
 
        Returns 
        ------- 
        X_tr : {ndarray, sparse matrix} of shape (n_samples, n_features) 
            Transformed array. 
        &quot;&quot;&quot;</span>
        <span class="s1">check_is_fitted</span><span class="s3">(</span><span class="s1">self</span><span class="s3">)</span>

        <span class="s1">xp</span><span class="s3">, </span><span class="s1">_ </span><span class="s3">= </span><span class="s1">get_namespace</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>

        <span class="s1">X </span><span class="s3">= </span><span class="s1">check_array</span><span class="s3">(</span>
            <span class="s1">X</span><span class="s3">,</span>
            <span class="s1">accept_sparse</span><span class="s3">=(</span><span class="s5">&quot;csr&quot;</span><span class="s3">, </span><span class="s5">&quot;csc&quot;</span><span class="s3">),</span>
            <span class="s1">copy</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">,</span>
            <span class="s1">dtype</span><span class="s3">=</span><span class="s1">_array_api</span><span class="s3">.</span><span class="s1">supported_float_dtypes</span><span class="s3">(</span><span class="s1">xp</span><span class="s3">),</span>
            <span class="s1">force_writeable</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
            <span class="s1">force_all_finite</span><span class="s3">=</span><span class="s5">&quot;allow-nan&quot;</span><span class="s3">,</span>
        <span class="s3">)</span>

        <span class="s2">if </span><span class="s1">sparse</span><span class="s3">.</span><span class="s1">issparse</span><span class="s3">(</span><span class="s1">X</span><span class="s3">):</span>
            <span class="s1">inplace_column_scale</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">scale_</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">X </span><span class="s3">*= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">scale_</span>
        <span class="s2">return </span><span class="s1">X</span>

    <span class="s2">def </span><span class="s1">_more_tags</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s3">{</span><span class="s5">&quot;allow_nan&quot;</span><span class="s3">: </span><span class="s2">True</span><span class="s3">}</span>


<span class="s3">@</span><span class="s1">validate_params</span><span class="s3">(</span>
    <span class="s3">{</span>
        <span class="s5">&quot;X&quot;</span><span class="s3">: [</span><span class="s5">&quot;array-like&quot;</span><span class="s3">, </span><span class="s5">&quot;sparse matrix&quot;</span><span class="s3">],</span>
        <span class="s5">&quot;axis&quot;</span><span class="s3">: [</span><span class="s1">Options</span><span class="s3">(</span><span class="s1">Integral</span><span class="s3">, {</span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">})],</span>
    <span class="s3">},</span>
    <span class="s1">prefer_skip_nested_validation</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
<span class="s3">)</span>
<span class="s2">def </span><span class="s1">maxabs_scale</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, *, </span><span class="s1">axis</span><span class="s3">=</span><span class="s4">0</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Scale each feature to the [-1, 1] range without breaking the sparsity. 
 
    This estimator scales each feature individually such 
    that the maximal absolute value of each feature in the 
    training set will be 1.0. 
 
    This scaler can also be applied to sparse CSR or CSC matrices. 
 
    Parameters 
    ---------- 
    X : {array-like, sparse matrix} of shape (n_samples, n_features) 
        The data. 
 
    axis : {0, 1}, default=0 
        Axis used to scale along. If 0, independently scale each feature, 
        otherwise (if 1) scale each sample. 
 
    copy : bool, default=True 
        If False, try to avoid a copy and scale in place. 
        This is not guaranteed to always work in place; e.g. if the data is 
        a numpy array with an int dtype, a copy will be returned even with 
        copy=False. 
 
    Returns 
    ------- 
    X_tr : {ndarray, sparse matrix} of shape (n_samples, n_features) 
        The transformed data. 
 
    .. warning:: Risk of data leak 
 
        Do not use :func:`~sklearn.preprocessing.maxabs_scale` unless you know 
        what you are doing. A common mistake is to apply it to the entire data 
        *before* splitting into training and test sets. This will bias the 
        model evaluation because information would have leaked from the test 
        set to the training set. 
        In general, we recommend using 
        :class:`~sklearn.preprocessing.MaxAbsScaler` within a 
        :ref:`Pipeline &lt;pipeline&gt;` in order to prevent most risks of data 
        leaking: `pipe = make_pipeline(MaxAbsScaler(), LogisticRegression())`. 
 
    See Also 
    -------- 
    MaxAbsScaler : Performs scaling to the [-1, 1] range using 
        the Transformer API (e.g. as part of a preprocessing 
        :class:`~sklearn.pipeline.Pipeline`). 
 
    Notes 
    ----- 
    NaNs are treated as missing values: disregarded to compute the statistics, 
    and maintained during the data transformation. 
 
    For a comparison of the different scalers, transformers, and normalizers, 
    see: :ref:`sphx_glr_auto_examples_preprocessing_plot_all_scaling.py`. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from sklearn.preprocessing import maxabs_scale 
    &gt;&gt;&gt; X = [[-2, 1, 2], [-1, 0, 1]] 
    &gt;&gt;&gt; maxabs_scale(X, axis=0)  # scale each column independently 
    array([[-1. ,  1. ,  1. ], 
           [-0.5,  0. ,  0.5]]) 
    &gt;&gt;&gt; maxabs_scale(X, axis=1)  # scale each row independently 
    array([[-1. ,  0.5,  1. ], 
           [-1. ,  0. ,  1. ]]) 
    &quot;&quot;&quot;</span>
    <span class="s0"># Unlike the scaler object, this function allows 1d input.</span>

    <span class="s0"># If copy is required, it will be done inside the scaler object.</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">check_array</span><span class="s3">(</span>
        <span class="s1">X</span><span class="s3">,</span>
        <span class="s1">accept_sparse</span><span class="s3">=(</span><span class="s5">&quot;csr&quot;</span><span class="s3">, </span><span class="s5">&quot;csc&quot;</span><span class="s3">),</span>
        <span class="s1">copy</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
        <span class="s1">ensure_2d</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
        <span class="s1">dtype</span><span class="s3">=</span><span class="s1">FLOAT_DTYPES</span><span class="s3">,</span>
        <span class="s1">force_all_finite</span><span class="s3">=</span><span class="s5">&quot;allow-nan&quot;</span><span class="s3">,</span>
    <span class="s3">)</span>
    <span class="s1">original_ndim </span><span class="s3">= </span><span class="s1">X</span><span class="s3">.</span><span class="s1">ndim</span>

    <span class="s2">if </span><span class="s1">original_ndim </span><span class="s3">== </span><span class="s4">1</span><span class="s3">:</span>
        <span class="s1">X </span><span class="s3">= </span><span class="s1">X</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">(</span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s4">0</span><span class="s3">], </span><span class="s4">1</span><span class="s3">)</span>

    <span class="s1">s </span><span class="s3">= </span><span class="s1">MaxAbsScaler</span><span class="s3">(</span><span class="s1">copy</span><span class="s3">=</span><span class="s1">copy</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">axis </span><span class="s3">== </span><span class="s4">0</span><span class="s3">:</span>
        <span class="s1">X </span><span class="s3">= </span><span class="s1">s</span><span class="s3">.</span><span class="s1">fit_transform</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">X </span><span class="s3">= </span><span class="s1">s</span><span class="s3">.</span><span class="s1">fit_transform</span><span class="s3">(</span><span class="s1">X</span><span class="s3">.</span><span class="s1">T</span><span class="s3">).</span><span class="s1">T</span>

    <span class="s2">if </span><span class="s1">original_ndim </span><span class="s3">== </span><span class="s4">1</span><span class="s3">:</span>
        <span class="s1">X </span><span class="s3">= </span><span class="s1">X</span><span class="s3">.</span><span class="s1">ravel</span><span class="s3">()</span>

    <span class="s2">return </span><span class="s1">X</span>


<span class="s2">class </span><span class="s1">RobustScaler</span><span class="s3">(</span><span class="s1">OneToOneFeatureMixin</span><span class="s3">, </span><span class="s1">TransformerMixin</span><span class="s3">, </span><span class="s1">BaseEstimator</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Scale features using statistics that are robust to outliers. 
 
    This Scaler removes the median and scales the data according to 
    the quantile range (defaults to IQR: Interquartile Range). 
    The IQR is the range between the 1st quartile (25th quantile) 
    and the 3rd quartile (75th quantile). 
 
    Centering and scaling happen independently on each feature by 
    computing the relevant statistics on the samples in the training 
    set. Median and interquartile range are then stored to be used on 
    later data using the :meth:`transform` method. 
 
    Standardization of a dataset is a common preprocessing for many machine 
    learning estimators. Typically this is done by removing the mean and 
    scaling to unit variance. However, outliers can often influence the sample 
    mean / variance in a negative way. In such cases, using the median and the 
    interquartile range often give better results. For an example visualization 
    and comparison to other scalers, refer to :ref:`Compare RobustScaler with 
    other scalers &lt;plot_all_scaling_robust_scaler_section&gt;`. 
 
    .. versionadded:: 0.17 
 
    Read more in the :ref:`User Guide &lt;preprocessing_scaler&gt;`. 
 
    Parameters 
    ---------- 
    with_centering : bool, default=True 
        If `True`, center the data before scaling. 
        This will cause :meth:`transform` to raise an exception when attempted 
        on sparse matrices, because centering them entails building a dense 
        matrix which in common use cases is likely to be too large to fit in 
        memory. 
 
    with_scaling : bool, default=True 
        If `True`, scale the data to interquartile range. 
 
    quantile_range : tuple (q_min, q_max), 0.0 &lt; q_min &lt; q_max &lt; 100.0, \ 
        default=(25.0, 75.0) 
        Quantile range used to calculate `scale_`. By default this is equal to 
        the IQR, i.e., `q_min` is the first quantile and `q_max` is the third 
        quantile. 
 
        .. versionadded:: 0.18 
 
    copy : bool, default=True 
        If `False`, try to avoid a copy and do inplace scaling instead. 
        This is not guaranteed to always work inplace; e.g. if the data is 
        not a NumPy array or scipy.sparse CSR matrix, a copy may still be 
        returned. 
 
    unit_variance : bool, default=False 
        If `True`, scale data so that normally distributed features have a 
        variance of 1. In general, if the difference between the x-values of 
        `q_max` and `q_min` for a standard normal distribution is greater 
        than 1, the dataset will be scaled down. If less than 1, the dataset 
        will be scaled up. 
 
        .. versionadded:: 0.24 
 
    Attributes 
    ---------- 
    center_ : array of floats 
        The median value for each feature in the training set. 
 
    scale_ : array of floats 
        The (scaled) interquartile range for each feature in the training set. 
 
        .. versionadded:: 0.17 
           *scale_* attribute. 
 
    n_features_in_ : int 
        Number of features seen during :term:`fit`. 
 
        .. versionadded:: 0.24 
 
    feature_names_in_ : ndarray of shape (`n_features_in_`,) 
        Names of features seen during :term:`fit`. Defined only when `X` 
        has feature names that are all strings. 
 
        .. versionadded:: 1.0 
 
    See Also 
    -------- 
    robust_scale : Equivalent function without the estimator API. 
    sklearn.decomposition.PCA : Further removes the linear correlation across 
        features with 'whiten=True'. 
 
    Notes 
    ----- 
 
    https://en.wikipedia.org/wiki/Median 
    https://en.wikipedia.org/wiki/Interquartile_range 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from sklearn.preprocessing import RobustScaler 
    &gt;&gt;&gt; X = [[ 1., -2.,  2.], 
    ...      [ -2.,  1.,  3.], 
    ...      [ 4.,  1., -2.]] 
    &gt;&gt;&gt; transformer = RobustScaler().fit(X) 
    &gt;&gt;&gt; transformer 
    RobustScaler() 
    &gt;&gt;&gt; transformer.transform(X) 
    array([[ 0. , -2. ,  0. ], 
           [-1. ,  0. ,  0.4], 
           [ 1. ,  0. , -1.6]]) 
    &quot;&quot;&quot;</span>

    <span class="s1">_parameter_constraints</span><span class="s3">: </span><span class="s1">dict </span><span class="s3">= {</span>
        <span class="s5">&quot;with_centering&quot;</span><span class="s3">: [</span><span class="s5">&quot;boolean&quot;</span><span class="s3">],</span>
        <span class="s5">&quot;with_scaling&quot;</span><span class="s3">: [</span><span class="s5">&quot;boolean&quot;</span><span class="s3">],</span>
        <span class="s5">&quot;quantile_range&quot;</span><span class="s3">: [</span><span class="s1">tuple</span><span class="s3">],</span>
        <span class="s5">&quot;copy&quot;</span><span class="s3">: [</span><span class="s5">&quot;boolean&quot;</span><span class="s3">],</span>
        <span class="s5">&quot;unit_variance&quot;</span><span class="s3">: [</span><span class="s5">&quot;boolean&quot;</span><span class="s3">],</span>
    <span class="s3">}</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s3">*,</span>
        <span class="s1">with_centering</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
        <span class="s1">with_scaling</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
        <span class="s1">quantile_range</span><span class="s3">=(</span><span class="s4">25.0</span><span class="s3">, </span><span class="s4">75.0</span><span class="s3">),</span>
        <span class="s1">copy</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
        <span class="s1">unit_variance</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
    <span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">with_centering </span><span class="s3">= </span><span class="s1">with_centering</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">with_scaling </span><span class="s3">= </span><span class="s1">with_scaling</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">quantile_range </span><span class="s3">= </span><span class="s1">quantile_range</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">unit_variance </span><span class="s3">= </span><span class="s1">unit_variance</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">copy </span><span class="s3">= </span><span class="s1">copy</span>

    <span class="s3">@</span><span class="s1">_fit_context</span><span class="s3">(</span><span class="s1">prefer_skip_nested_validation</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
    <span class="s2">def </span><span class="s1">fit</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot;Compute the median and quantiles to be used for scaling. 
 
        Parameters 
        ---------- 
        X : {array-like, sparse matrix} of shape (n_samples, n_features) 
            The data used to compute the median and quantiles 
            used for later scaling along the features axis. 
 
        y : Ignored 
            Not used, present here for API consistency by convention. 
 
        Returns 
        ------- 
        self : object 
            Fitted scaler. 
        &quot;&quot;&quot;</span>
        <span class="s0"># at fit, convert sparse matrices to csc for optimized computation of</span>
        <span class="s0"># the quantiles</span>
        <span class="s1">X </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_validate_data</span><span class="s3">(</span>
            <span class="s1">X</span><span class="s3">,</span>
            <span class="s1">accept_sparse</span><span class="s3">=</span><span class="s5">&quot;csc&quot;</span><span class="s3">,</span>
            <span class="s1">dtype</span><span class="s3">=</span><span class="s1">FLOAT_DTYPES</span><span class="s3">,</span>
            <span class="s1">force_all_finite</span><span class="s3">=</span><span class="s5">&quot;allow-nan&quot;</span><span class="s3">,</span>
        <span class="s3">)</span>

        <span class="s1">q_min</span><span class="s3">, </span><span class="s1">q_max </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">quantile_range</span>
        <span class="s2">if not </span><span class="s4">0 </span><span class="s3">&lt;= </span><span class="s1">q_min </span><span class="s3">&lt;= </span><span class="s1">q_max </span><span class="s3">&lt;= </span><span class="s4">100</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s5">&quot;Invalid quantile range: %s&quot; </span><span class="s3">% </span><span class="s1">str</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">quantile_range</span><span class="s3">))</span>

        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">with_centering</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">sparse</span><span class="s3">.</span><span class="s1">issparse</span><span class="s3">(</span><span class="s1">X</span><span class="s3">):</span>
                <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span>
                    <span class="s5">&quot;Cannot center sparse matrices: use `with_centering=False`&quot;</span>
                    <span class="s5">&quot; instead. See docstring for motivation and alternatives.&quot;</span>
                <span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">center_ </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nanmedian</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s4">0</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">center_ </span><span class="s3">= </span><span class="s2">None</span>

        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">with_scaling</span><span class="s3">:</span>
            <span class="s1">quantiles </span><span class="s3">= []</span>
            <span class="s2">for </span><span class="s1">feature_idx </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s4">1</span><span class="s3">]):</span>
                <span class="s2">if </span><span class="s1">sparse</span><span class="s3">.</span><span class="s1">issparse</span><span class="s3">(</span><span class="s1">X</span><span class="s3">):</span>
                    <span class="s1">column_nnz_data </span><span class="s3">= </span><span class="s1">X</span><span class="s3">.</span><span class="s1">data</span><span class="s3">[</span>
                        <span class="s1">X</span><span class="s3">.</span><span class="s1">indptr</span><span class="s3">[</span><span class="s1">feature_idx</span><span class="s3">] : </span><span class="s1">X</span><span class="s3">.</span><span class="s1">indptr</span><span class="s3">[</span><span class="s1">feature_idx </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">]</span>
                    <span class="s3">]</span>
                    <span class="s1">column_data </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">=</span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s4">0</span><span class="s3">], </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">X</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>
                    <span class="s1">column_data</span><span class="s3">[: </span><span class="s1">len</span><span class="s3">(</span><span class="s1">column_nnz_data</span><span class="s3">)] = </span><span class="s1">column_nnz_data</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">column_data </span><span class="s3">= </span><span class="s1">X</span><span class="s3">[:, </span><span class="s1">feature_idx</span><span class="s3">]</span>

                <span class="s1">quantiles</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">nanpercentile</span><span class="s3">(</span><span class="s1">column_data</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">quantile_range</span><span class="s3">))</span>

            <span class="s1">quantiles </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">transpose</span><span class="s3">(</span><span class="s1">quantiles</span><span class="s3">)</span>

            <span class="s1">self</span><span class="s3">.</span><span class="s1">scale_ </span><span class="s3">= </span><span class="s1">quantiles</span><span class="s3">[</span><span class="s4">1</span><span class="s3">] - </span><span class="s1">quantiles</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">scale_ </span><span class="s3">= </span><span class="s1">_handle_zeros_in_scale</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">scale_</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">unit_variance</span><span class="s3">:</span>
                <span class="s1">adjust </span><span class="s3">= </span><span class="s1">stats</span><span class="s3">.</span><span class="s1">norm</span><span class="s3">.</span><span class="s1">ppf</span><span class="s3">(</span><span class="s1">q_max </span><span class="s3">/ </span><span class="s4">100.0</span><span class="s3">) - </span><span class="s1">stats</span><span class="s3">.</span><span class="s1">norm</span><span class="s3">.</span><span class="s1">ppf</span><span class="s3">(</span><span class="s1">q_min </span><span class="s3">/ </span><span class="s4">100.0</span><span class="s3">)</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">scale_ </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">scale_ </span><span class="s3">/ </span><span class="s1">adjust</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">scale_ </span><span class="s3">= </span><span class="s2">None</span>

        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">transform</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot;Center and scale the data. 
 
        Parameters 
        ---------- 
        X : {array-like, sparse matrix} of shape (n_samples, n_features) 
            The data used to scale along the specified axis. 
 
        Returns 
        ------- 
        X_tr : {ndarray, sparse matrix} of shape (n_samples, n_features) 
            Transformed array. 
        &quot;&quot;&quot;</span>
        <span class="s1">check_is_fitted</span><span class="s3">(</span><span class="s1">self</span><span class="s3">)</span>
        <span class="s1">X </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_validate_data</span><span class="s3">(</span>
            <span class="s1">X</span><span class="s3">,</span>
            <span class="s1">accept_sparse</span><span class="s3">=(</span><span class="s5">&quot;csr&quot;</span><span class="s3">, </span><span class="s5">&quot;csc&quot;</span><span class="s3">),</span>
            <span class="s1">copy</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">,</span>
            <span class="s1">dtype</span><span class="s3">=</span><span class="s1">FLOAT_DTYPES</span><span class="s3">,</span>
            <span class="s1">force_writeable</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
            <span class="s1">reset</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
            <span class="s1">force_all_finite</span><span class="s3">=</span><span class="s5">&quot;allow-nan&quot;</span><span class="s3">,</span>
        <span class="s3">)</span>

        <span class="s2">if </span><span class="s1">sparse</span><span class="s3">.</span><span class="s1">issparse</span><span class="s3">(</span><span class="s1">X</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">with_scaling</span><span class="s3">:</span>
                <span class="s1">inplace_column_scale</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s4">1.0 </span><span class="s3">/ </span><span class="s1">self</span><span class="s3">.</span><span class="s1">scale_</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">with_centering</span><span class="s3">:</span>
                <span class="s1">X </span><span class="s3">-= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">center_</span>
            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">with_scaling</span><span class="s3">:</span>
                <span class="s1">X </span><span class="s3">/= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">scale_</span>
        <span class="s2">return </span><span class="s1">X</span>

    <span class="s2">def </span><span class="s1">inverse_transform</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot;Scale back the data to the original representation. 
 
        Parameters 
        ---------- 
        X : {array-like, sparse matrix} of shape (n_samples, n_features) 
            The rescaled data to be transformed back. 
 
        Returns 
        ------- 
        X_tr : {ndarray, sparse matrix} of shape (n_samples, n_features) 
            Transformed array. 
        &quot;&quot;&quot;</span>
        <span class="s1">check_is_fitted</span><span class="s3">(</span><span class="s1">self</span><span class="s3">)</span>
        <span class="s1">X </span><span class="s3">= </span><span class="s1">check_array</span><span class="s3">(</span>
            <span class="s1">X</span><span class="s3">,</span>
            <span class="s1">accept_sparse</span><span class="s3">=(</span><span class="s5">&quot;csr&quot;</span><span class="s3">, </span><span class="s5">&quot;csc&quot;</span><span class="s3">),</span>
            <span class="s1">copy</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">,</span>
            <span class="s1">dtype</span><span class="s3">=</span><span class="s1">FLOAT_DTYPES</span><span class="s3">,</span>
            <span class="s1">force_writeable</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
            <span class="s1">force_all_finite</span><span class="s3">=</span><span class="s5">&quot;allow-nan&quot;</span><span class="s3">,</span>
        <span class="s3">)</span>

        <span class="s2">if </span><span class="s1">sparse</span><span class="s3">.</span><span class="s1">issparse</span><span class="s3">(</span><span class="s1">X</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">with_scaling</span><span class="s3">:</span>
                <span class="s1">inplace_column_scale</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">scale_</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">with_scaling</span><span class="s3">:</span>
                <span class="s1">X </span><span class="s3">*= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">scale_</span>
            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">with_centering</span><span class="s3">:</span>
                <span class="s1">X </span><span class="s3">+= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">center_</span>
        <span class="s2">return </span><span class="s1">X</span>

    <span class="s2">def </span><span class="s1">_more_tags</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s3">{</span><span class="s5">&quot;allow_nan&quot;</span><span class="s3">: </span><span class="s2">True</span><span class="s3">}</span>


<span class="s3">@</span><span class="s1">validate_params</span><span class="s3">(</span>
    <span class="s3">{</span><span class="s5">&quot;X&quot;</span><span class="s3">: [</span><span class="s5">&quot;array-like&quot;</span><span class="s3">, </span><span class="s5">&quot;sparse matrix&quot;</span><span class="s3">], </span><span class="s5">&quot;axis&quot;</span><span class="s3">: [</span><span class="s1">Options</span><span class="s3">(</span><span class="s1">Integral</span><span class="s3">, {</span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">})]},</span>
    <span class="s1">prefer_skip_nested_validation</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
<span class="s3">)</span>
<span class="s2">def </span><span class="s1">robust_scale</span><span class="s3">(</span>
    <span class="s1">X</span><span class="s3">,</span>
    <span class="s3">*,</span>
    <span class="s1">axis</span><span class="s3">=</span><span class="s4">0</span><span class="s3">,</span>
    <span class="s1">with_centering</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
    <span class="s1">with_scaling</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
    <span class="s1">quantile_range</span><span class="s3">=(</span><span class="s4">25.0</span><span class="s3">, </span><span class="s4">75.0</span><span class="s3">),</span>
    <span class="s1">copy</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
    <span class="s1">unit_variance</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
<span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Standardize a dataset along any axis. 
 
    Center to the median and component wise scale 
    according to the interquartile range. 
 
    Read more in the :ref:`User Guide &lt;preprocessing_scaler&gt;`. 
 
    Parameters 
    ---------- 
    X : {array-like, sparse matrix} of shape (n_sample, n_features) 
        The data to center and scale. 
 
    axis : int, default=0 
        Axis used to compute the medians and IQR along. If 0, 
        independently scale each feature, otherwise (if 1) scale 
        each sample. 
 
    with_centering : bool, default=True 
        If `True`, center the data before scaling. 
 
    with_scaling : bool, default=True 
        If `True`, scale the data to unit variance (or equivalently, 
        unit standard deviation). 
 
    quantile_range : tuple (q_min, q_max), 0.0 &lt; q_min &lt; q_max &lt; 100.0,\ 
        default=(25.0, 75.0) 
        Quantile range used to calculate `scale_`. By default this is equal to 
        the IQR, i.e., `q_min` is the first quantile and `q_max` is the third 
        quantile. 
 
        .. versionadded:: 0.18 
 
    copy : bool, default=True 
        If False, try to avoid a copy and scale in place. 
        This is not guaranteed to always work in place; e.g. if the data is 
        a numpy array with an int dtype, a copy will be returned even with 
        copy=False. 
 
    unit_variance : bool, default=False 
        If `True`, scale data so that normally distributed features have a 
        variance of 1. In general, if the difference between the x-values of 
        `q_max` and `q_min` for a standard normal distribution is greater 
        than 1, the dataset will be scaled down. If less than 1, the dataset 
        will be scaled up. 
 
        .. versionadded:: 0.24 
 
    Returns 
    ------- 
    X_tr : {ndarray, sparse matrix} of shape (n_samples, n_features) 
        The transformed data. 
 
    See Also 
    -------- 
    RobustScaler : Performs centering and scaling using the Transformer API 
        (e.g. as part of a preprocessing :class:`~sklearn.pipeline.Pipeline`). 
 
    Notes 
    ----- 
    This implementation will refuse to center scipy.sparse matrices 
    since it would make them non-sparse and would potentially crash the 
    program with memory exhaustion problems. 
 
    Instead the caller is expected to either set explicitly 
    `with_centering=False` (in that case, only variance scaling will be 
    performed on the features of the CSR matrix) or to call `X.toarray()` 
    if he/she expects the materialized dense array to fit in memory. 
 
    To avoid memory copy the caller should pass a CSR matrix. 
 
    For a comparison of the different scalers, transformers, and normalizers, 
    see: :ref:`sphx_glr_auto_examples_preprocessing_plot_all_scaling.py`. 
 
    .. warning:: Risk of data leak 
 
        Do not use :func:`~sklearn.preprocessing.robust_scale` unless you know 
        what you are doing. A common mistake is to apply it to the entire data 
        *before* splitting into training and test sets. This will bias the 
        model evaluation because information would have leaked from the test 
        set to the training set. 
        In general, we recommend using 
        :class:`~sklearn.preprocessing.RobustScaler` within a 
        :ref:`Pipeline &lt;pipeline&gt;` in order to prevent most risks of data 
        leaking: `pipe = make_pipeline(RobustScaler(), LogisticRegression())`. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from sklearn.preprocessing import robust_scale 
    &gt;&gt;&gt; X = [[-2, 1, 2], [-1, 0, 1]] 
    &gt;&gt;&gt; robust_scale(X, axis=0)  # scale each column independently 
    array([[-1.,  1.,  1.], 
           [ 1., -1., -1.]]) 
    &gt;&gt;&gt; robust_scale(X, axis=1)  # scale each row independently 
    array([[-1.5,  0. ,  0.5], 
           [-1. ,  0. ,  1. ]]) 
    &quot;&quot;&quot;</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">check_array</span><span class="s3">(</span>
        <span class="s1">X</span><span class="s3">,</span>
        <span class="s1">accept_sparse</span><span class="s3">=(</span><span class="s5">&quot;csr&quot;</span><span class="s3">, </span><span class="s5">&quot;csc&quot;</span><span class="s3">),</span>
        <span class="s1">copy</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
        <span class="s1">ensure_2d</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
        <span class="s1">dtype</span><span class="s3">=</span><span class="s1">FLOAT_DTYPES</span><span class="s3">,</span>
        <span class="s1">force_all_finite</span><span class="s3">=</span><span class="s5">&quot;allow-nan&quot;</span><span class="s3">,</span>
    <span class="s3">)</span>
    <span class="s1">original_ndim </span><span class="s3">= </span><span class="s1">X</span><span class="s3">.</span><span class="s1">ndim</span>

    <span class="s2">if </span><span class="s1">original_ndim </span><span class="s3">== </span><span class="s4">1</span><span class="s3">:</span>
        <span class="s1">X </span><span class="s3">= </span><span class="s1">X</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">(</span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s4">0</span><span class="s3">], </span><span class="s4">1</span><span class="s3">)</span>

    <span class="s1">s </span><span class="s3">= </span><span class="s1">RobustScaler</span><span class="s3">(</span>
        <span class="s1">with_centering</span><span class="s3">=</span><span class="s1">with_centering</span><span class="s3">,</span>
        <span class="s1">with_scaling</span><span class="s3">=</span><span class="s1">with_scaling</span><span class="s3">,</span>
        <span class="s1">quantile_range</span><span class="s3">=</span><span class="s1">quantile_range</span><span class="s3">,</span>
        <span class="s1">unit_variance</span><span class="s3">=</span><span class="s1">unit_variance</span><span class="s3">,</span>
        <span class="s1">copy</span><span class="s3">=</span><span class="s1">copy</span><span class="s3">,</span>
    <span class="s3">)</span>
    <span class="s2">if </span><span class="s1">axis </span><span class="s3">== </span><span class="s4">0</span><span class="s3">:</span>
        <span class="s1">X </span><span class="s3">= </span><span class="s1">s</span><span class="s3">.</span><span class="s1">fit_transform</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">X </span><span class="s3">= </span><span class="s1">s</span><span class="s3">.</span><span class="s1">fit_transform</span><span class="s3">(</span><span class="s1">X</span><span class="s3">.</span><span class="s1">T</span><span class="s3">).</span><span class="s1">T</span>

    <span class="s2">if </span><span class="s1">original_ndim </span><span class="s3">== </span><span class="s4">1</span><span class="s3">:</span>
        <span class="s1">X </span><span class="s3">= </span><span class="s1">X</span><span class="s3">.</span><span class="s1">ravel</span><span class="s3">()</span>

    <span class="s2">return </span><span class="s1">X</span>


<span class="s3">@</span><span class="s1">validate_params</span><span class="s3">(</span>
    <span class="s3">{</span>
        <span class="s5">&quot;X&quot;</span><span class="s3">: [</span><span class="s5">&quot;array-like&quot;</span><span class="s3">, </span><span class="s5">&quot;sparse matrix&quot;</span><span class="s3">],</span>
        <span class="s5">&quot;norm&quot;</span><span class="s3">: [</span><span class="s1">StrOptions</span><span class="s3">({</span><span class="s5">&quot;l1&quot;</span><span class="s3">, </span><span class="s5">&quot;l2&quot;</span><span class="s3">, </span><span class="s5">&quot;max&quot;</span><span class="s3">})],</span>
        <span class="s5">&quot;axis&quot;</span><span class="s3">: [</span><span class="s1">Options</span><span class="s3">(</span><span class="s1">Integral</span><span class="s3">, {</span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">})],</span>
        <span class="s5">&quot;copy&quot;</span><span class="s3">: [</span><span class="s5">&quot;boolean&quot;</span><span class="s3">],</span>
        <span class="s5">&quot;return_norm&quot;</span><span class="s3">: [</span><span class="s5">&quot;boolean&quot;</span><span class="s3">],</span>
    <span class="s3">},</span>
    <span class="s1">prefer_skip_nested_validation</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
<span class="s3">)</span>
<span class="s2">def </span><span class="s1">normalize</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">norm</span><span class="s3">=</span><span class="s5">&quot;l2&quot;</span><span class="s3">, *, </span><span class="s1">axis</span><span class="s3">=</span><span class="s4">1</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">return_norm</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Scale input vectors individually to unit norm (vector length). 
 
    Read more in the :ref:`User Guide &lt;preprocessing_normalization&gt;`. 
 
    Parameters 
    ---------- 
    X : {array-like, sparse matrix} of shape (n_samples, n_features) 
        The data to normalize, element by element. 
        scipy.sparse matrices should be in CSR format to avoid an 
        un-necessary copy. 
 
    norm : {'l1', 'l2', 'max'}, default='l2' 
        The norm to use to normalize each non zero sample (or each non-zero 
        feature if axis is 0). 
 
    axis : {0, 1}, default=1 
        Define axis used to normalize the data along. If 1, independently 
        normalize each sample, otherwise (if 0) normalize each feature. 
 
    copy : bool, default=True 
        If False, try to avoid a copy and normalize in place. 
        This is not guaranteed to always work in place; e.g. if the data is 
        a numpy array with an int dtype, a copy will be returned even with 
        copy=False. 
 
    return_norm : bool, default=False 
        Whether to return the computed norms. 
 
    Returns 
    ------- 
    X : {ndarray, sparse matrix} of shape (n_samples, n_features) 
        Normalized input X. 
 
    norms : ndarray of shape (n_samples, ) if axis=1 else (n_features, ) 
        An array of norms along given axis for X. 
        When X is sparse, a NotImplementedError will be raised 
        for norm 'l1' or 'l2'. 
 
    See Also 
    -------- 
    Normalizer : Performs normalization using the Transformer API 
        (e.g. as part of a preprocessing :class:`~sklearn.pipeline.Pipeline`). 
 
    Notes 
    ----- 
    For a comparison of the different scalers, transformers, and normalizers, 
    see: :ref:`sphx_glr_auto_examples_preprocessing_plot_all_scaling.py`. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from sklearn.preprocessing import normalize 
    &gt;&gt;&gt; X = [[-2, 1, 2], [-1, 0, 1]] 
    &gt;&gt;&gt; normalize(X, norm=&quot;l1&quot;)  # L1 normalization each row independently 
    array([[-0.4,  0.2,  0.4], 
           [-0.5,  0. ,  0.5]]) 
    &gt;&gt;&gt; normalize(X, norm=&quot;l2&quot;)  # L2 normalization each row independently 
    array([[-0.66...,  0.33...,  0.66...], 
           [-0.70...,  0.     ,  0.70...]]) 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">axis </span><span class="s3">== </span><span class="s4">0</span><span class="s3">:</span>
        <span class="s1">sparse_format </span><span class="s3">= </span><span class="s5">&quot;csc&quot;</span>
    <span class="s2">else</span><span class="s3">:  </span><span class="s0"># axis == 1:</span>
        <span class="s1">sparse_format </span><span class="s3">= </span><span class="s5">&quot;csr&quot;</span>

    <span class="s1">xp</span><span class="s3">, </span><span class="s1">_ </span><span class="s3">= </span><span class="s1">get_namespace</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>

    <span class="s1">X </span><span class="s3">= </span><span class="s1">check_array</span><span class="s3">(</span>
        <span class="s1">X</span><span class="s3">,</span>
        <span class="s1">accept_sparse</span><span class="s3">=</span><span class="s1">sparse_format</span><span class="s3">,</span>
        <span class="s1">copy</span><span class="s3">=</span><span class="s1">copy</span><span class="s3">,</span>
        <span class="s1">estimator</span><span class="s3">=</span><span class="s5">&quot;the normalize function&quot;</span><span class="s3">,</span>
        <span class="s1">dtype</span><span class="s3">=</span><span class="s1">_array_api</span><span class="s3">.</span><span class="s1">supported_float_dtypes</span><span class="s3">(</span><span class="s1">xp</span><span class="s3">),</span>
        <span class="s1">force_writeable</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
    <span class="s3">)</span>
    <span class="s2">if </span><span class="s1">axis </span><span class="s3">== </span><span class="s4">0</span><span class="s3">:</span>
        <span class="s1">X </span><span class="s3">= </span><span class="s1">X</span><span class="s3">.</span><span class="s1">T</span>

    <span class="s2">if </span><span class="s1">sparse</span><span class="s3">.</span><span class="s1">issparse</span><span class="s3">(</span><span class="s1">X</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">return_norm </span><span class="s2">and </span><span class="s1">norm </span><span class="s2">in </span><span class="s3">(</span><span class="s5">&quot;l1&quot;</span><span class="s3">, </span><span class="s5">&quot;l2&quot;</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">NotImplementedError</span><span class="s3">(</span>
                <span class="s5">&quot;return_norm=True is not implemented &quot;</span>
                <span class="s5">&quot;for sparse matrices with norm 'l1' &quot;</span>
                <span class="s5">&quot;or norm 'l2'&quot;</span>
            <span class="s3">)</span>
        <span class="s2">if </span><span class="s1">norm </span><span class="s3">== </span><span class="s5">&quot;l1&quot;</span><span class="s3">:</span>
            <span class="s1">inplace_csr_row_normalize_l1</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">norm </span><span class="s3">== </span><span class="s5">&quot;l2&quot;</span><span class="s3">:</span>
            <span class="s1">inplace_csr_row_normalize_l2</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">norm </span><span class="s3">== </span><span class="s5">&quot;max&quot;</span><span class="s3">:</span>
            <span class="s1">mins</span><span class="s3">, </span><span class="s1">maxes </span><span class="s3">= </span><span class="s1">min_max_axis</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s4">1</span><span class="s3">)</span>
            <span class="s1">norms </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">maximum</span><span class="s3">(</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">mins</span><span class="s3">), </span><span class="s1">maxes</span><span class="s3">)</span>
            <span class="s1">norms_elementwise </span><span class="s3">= </span><span class="s1">norms</span><span class="s3">.</span><span class="s1">repeat</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">diff</span><span class="s3">(</span><span class="s1">X</span><span class="s3">.</span><span class="s1">indptr</span><span class="s3">))</span>
            <span class="s1">mask </span><span class="s3">= </span><span class="s1">norms_elementwise </span><span class="s3">!= </span><span class="s4">0</span>
            <span class="s1">X</span><span class="s3">.</span><span class="s1">data</span><span class="s3">[</span><span class="s1">mask</span><span class="s3">] /= </span><span class="s1">norms_elementwise</span><span class="s3">[</span><span class="s1">mask</span><span class="s3">]</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">norm </span><span class="s3">== </span><span class="s5">&quot;l1&quot;</span><span class="s3">:</span>
            <span class="s1">norms </span><span class="s3">= </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">(</span><span class="s1">xp</span><span class="s3">.</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">X</span><span class="s3">), </span><span class="s1">axis</span><span class="s3">=</span><span class="s4">1</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">norm </span><span class="s3">== </span><span class="s5">&quot;l2&quot;</span><span class="s3">:</span>
            <span class="s1">norms </span><span class="s3">= </span><span class="s1">row_norms</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">norm </span><span class="s3">== </span><span class="s5">&quot;max&quot;</span><span class="s3">:</span>
            <span class="s1">norms </span><span class="s3">= </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">max</span><span class="s3">(</span><span class="s1">xp</span><span class="s3">.</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">X</span><span class="s3">), </span><span class="s1">axis</span><span class="s3">=</span><span class="s4">1</span><span class="s3">)</span>
        <span class="s1">norms </span><span class="s3">= </span><span class="s1">_handle_zeros_in_scale</span><span class="s3">(</span><span class="s1">norms</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
        <span class="s1">X </span><span class="s3">/= </span><span class="s1">norms</span><span class="s3">[:, </span><span class="s2">None</span><span class="s3">]</span>

    <span class="s2">if </span><span class="s1">axis </span><span class="s3">== </span><span class="s4">0</span><span class="s3">:</span>
        <span class="s1">X </span><span class="s3">= </span><span class="s1">X</span><span class="s3">.</span><span class="s1">T</span>

    <span class="s2">if </span><span class="s1">return_norm</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">X</span><span class="s3">, </span><span class="s1">norms</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">X</span>


<span class="s2">class </span><span class="s1">Normalizer</span><span class="s3">(</span><span class="s1">OneToOneFeatureMixin</span><span class="s3">, </span><span class="s1">TransformerMixin</span><span class="s3">, </span><span class="s1">BaseEstimator</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Normalize samples individually to unit norm. 
 
    Each sample (i.e. each row of the data matrix) with at least one 
    non zero component is rescaled independently of other samples so 
    that its norm (l1, l2 or inf) equals one. 
 
    This transformer is able to work both with dense numpy arrays and 
    scipy.sparse matrix (use CSR format if you want to avoid the burden of 
    a copy / conversion). 
 
    Scaling inputs to unit norms is a common operation for text 
    classification or clustering for instance. For instance the dot 
    product of two l2-normalized TF-IDF vectors is the cosine similarity 
    of the vectors and is the base similarity metric for the Vector 
    Space Model commonly used by the Information Retrieval community. 
 
    For an example visualization, refer to :ref:`Compare Normalizer with other 
    scalers &lt;plot_all_scaling_normalizer_section&gt;`. 
 
    Read more in the :ref:`User Guide &lt;preprocessing_normalization&gt;`. 
 
    Parameters 
    ---------- 
    norm : {'l1', 'l2', 'max'}, default='l2' 
        The norm to use to normalize each non zero sample. If norm='max' 
        is used, values will be rescaled by the maximum of the absolute 
        values. 
 
    copy : bool, default=True 
        Set to False to perform inplace row normalization and avoid a 
        copy (if the input is already a numpy array or a scipy.sparse 
        CSR matrix). 
 
    Attributes 
    ---------- 
    n_features_in_ : int 
        Number of features seen during :term:`fit`. 
 
        .. versionadded:: 0.24 
 
    feature_names_in_ : ndarray of shape (`n_features_in_`,) 
        Names of features seen during :term:`fit`. Defined only when `X` 
        has feature names that are all strings. 
 
        .. versionadded:: 1.0 
 
    See Also 
    -------- 
    normalize : Equivalent function without the estimator API. 
 
    Notes 
    ----- 
    This estimator is :term:`stateless` and does not need to be fitted. 
    However, we recommend to call :meth:`fit_transform` instead of 
    :meth:`transform`, as parameter validation is only performed in 
    :meth:`fit`. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from sklearn.preprocessing import Normalizer 
    &gt;&gt;&gt; X = [[4, 1, 2, 2], 
    ...      [1, 3, 9, 3], 
    ...      [5, 7, 5, 1]] 
    &gt;&gt;&gt; transformer = Normalizer().fit(X)  # fit does nothing. 
    &gt;&gt;&gt; transformer 
    Normalizer() 
    &gt;&gt;&gt; transformer.transform(X) 
    array([[0.8, 0.2, 0.4, 0.4], 
           [0.1, 0.3, 0.9, 0.3], 
           [0.5, 0.7, 0.5, 0.1]]) 
    &quot;&quot;&quot;</span>

    <span class="s1">_parameter_constraints</span><span class="s3">: </span><span class="s1">dict </span><span class="s3">= {</span>
        <span class="s5">&quot;norm&quot;</span><span class="s3">: [</span><span class="s1">StrOptions</span><span class="s3">({</span><span class="s5">&quot;l1&quot;</span><span class="s3">, </span><span class="s5">&quot;l2&quot;</span><span class="s3">, </span><span class="s5">&quot;max&quot;</span><span class="s3">})],</span>
        <span class="s5">&quot;copy&quot;</span><span class="s3">: [</span><span class="s5">&quot;boolean&quot;</span><span class="s3">],</span>
    <span class="s3">}</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">norm</span><span class="s3">=</span><span class="s5">&quot;l2&quot;</span><span class="s3">, *, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">norm </span><span class="s3">= </span><span class="s1">norm</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">copy </span><span class="s3">= </span><span class="s1">copy</span>

    <span class="s3">@</span><span class="s1">_fit_context</span><span class="s3">(</span><span class="s1">prefer_skip_nested_validation</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
    <span class="s2">def </span><span class="s1">fit</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot;Only validates estimator's parameters. 
 
        This method allows to: (i) validate the estimator's parameters and 
        (ii) be consistent with the scikit-learn transformer API. 
 
        Parameters 
        ---------- 
        X : {array-like, sparse matrix} of shape (n_samples, n_features) 
            The data to estimate the normalization parameters. 
 
        y : Ignored 
            Not used, present here for API consistency by convention. 
 
        Returns 
        ------- 
        self : object 
            Fitted transformer. 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_validate_data</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">accept_sparse</span><span class="s3">=</span><span class="s5">&quot;csr&quot;</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">transform</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot;Scale each non zero row of X to unit norm. 
 
        Parameters 
        ---------- 
        X : {array-like, sparse matrix} of shape (n_samples, n_features) 
            The data to normalize, row by row. scipy.sparse matrices should be 
            in CSR format to avoid an un-necessary copy. 
 
        copy : bool, default=None 
            Copy the input X or not. 
 
        Returns 
        ------- 
        X_tr : {ndarray, sparse matrix} of shape (n_samples, n_features) 
            Transformed array. 
        &quot;&quot;&quot;</span>
        <span class="s1">copy </span><span class="s3">= </span><span class="s1">copy </span><span class="s2">if </span><span class="s1">copy </span><span class="s2">is not None else </span><span class="s1">self</span><span class="s3">.</span><span class="s1">copy</span>
        <span class="s1">X </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_validate_data</span><span class="s3">(</span>
            <span class="s1">X</span><span class="s3">, </span><span class="s1">accept_sparse</span><span class="s3">=</span><span class="s5">&quot;csr&quot;</span><span class="s3">, </span><span class="s1">force_writeable</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s1">copy</span><span class="s3">, </span><span class="s1">reset</span><span class="s3">=</span><span class="s2">False</span>
        <span class="s3">)</span>
        <span class="s2">return </span><span class="s1">normalize</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">norm</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">norm</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s4">1</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_more_tags</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s3">{</span><span class="s5">&quot;stateless&quot;</span><span class="s3">: </span><span class="s2">True</span><span class="s3">, </span><span class="s5">&quot;array_api_support&quot;</span><span class="s3">: </span><span class="s2">True</span><span class="s3">}</span>


<span class="s3">@</span><span class="s1">validate_params</span><span class="s3">(</span>
    <span class="s3">{</span>
        <span class="s5">&quot;X&quot;</span><span class="s3">: [</span><span class="s5">&quot;array-like&quot;</span><span class="s3">, </span><span class="s5">&quot;sparse matrix&quot;</span><span class="s3">],</span>
        <span class="s5">&quot;threshold&quot;</span><span class="s3">: [</span><span class="s1">Interval</span><span class="s3">(</span><span class="s1">Real</span><span class="s3">, </span><span class="s2">None</span><span class="s3">, </span><span class="s2">None</span><span class="s3">, </span><span class="s1">closed</span><span class="s3">=</span><span class="s5">&quot;neither&quot;</span><span class="s3">)],</span>
        <span class="s5">&quot;copy&quot;</span><span class="s3">: [</span><span class="s5">&quot;boolean&quot;</span><span class="s3">],</span>
    <span class="s3">},</span>
    <span class="s1">prefer_skip_nested_validation</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
<span class="s3">)</span>
<span class="s2">def </span><span class="s1">binarize</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, *, </span><span class="s1">threshold</span><span class="s3">=</span><span class="s4">0.0</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Boolean thresholding of array-like or scipy.sparse matrix. 
 
    Read more in the :ref:`User Guide &lt;preprocessing_binarization&gt;`. 
 
    Parameters 
    ---------- 
    X : {array-like, sparse matrix} of shape (n_samples, n_features) 
        The data to binarize, element by element. 
        scipy.sparse matrices should be in CSR or CSC format to avoid an 
        un-necessary copy. 
 
    threshold : float, default=0.0 
        Feature values below or equal to this are replaced by 0, above it by 1. 
        Threshold may not be less than 0 for operations on sparse matrices. 
 
    copy : bool, default=True 
        If False, try to avoid a copy and binarize in place. 
        This is not guaranteed to always work in place; e.g. if the data is 
        a numpy array with an object dtype, a copy will be returned even with 
        copy=False. 
 
    Returns 
    ------- 
    X_tr : {ndarray, sparse matrix} of shape (n_samples, n_features) 
        The transformed data. 
 
    See Also 
    -------- 
    Binarizer : Performs binarization using the Transformer API 
        (e.g. as part of a preprocessing :class:`~sklearn.pipeline.Pipeline`). 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from sklearn.preprocessing import binarize 
    &gt;&gt;&gt; X = [[0.4, 0.6, 0.5], [0.6, 0.1, 0.2]] 
    &gt;&gt;&gt; binarize(X, threshold=0.5) 
    array([[0., 1., 0.], 
           [1., 0., 0.]]) 
    &quot;&quot;&quot;</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">check_array</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">accept_sparse</span><span class="s3">=[</span><span class="s5">&quot;csr&quot;</span><span class="s3">, </span><span class="s5">&quot;csc&quot;</span><span class="s3">], </span><span class="s1">force_writeable</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s1">copy</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">sparse</span><span class="s3">.</span><span class="s1">issparse</span><span class="s3">(</span><span class="s1">X</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">threshold </span><span class="s3">&lt; </span><span class="s4">0</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s5">&quot;Cannot binarize a sparse matrix with threshold &lt; 0&quot;</span><span class="s3">)</span>
        <span class="s1">cond </span><span class="s3">= </span><span class="s1">X</span><span class="s3">.</span><span class="s1">data </span><span class="s3">&gt; </span><span class="s1">threshold</span>
        <span class="s1">not_cond </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">logical_not</span><span class="s3">(</span><span class="s1">cond</span><span class="s3">)</span>
        <span class="s1">X</span><span class="s3">.</span><span class="s1">data</span><span class="s3">[</span><span class="s1">cond</span><span class="s3">] = </span><span class="s4">1</span>
        <span class="s1">X</span><span class="s3">.</span><span class="s1">data</span><span class="s3">[</span><span class="s1">not_cond</span><span class="s3">] = </span><span class="s4">0</span>
        <span class="s1">X</span><span class="s3">.</span><span class="s1">eliminate_zeros</span><span class="s3">()</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">cond </span><span class="s3">= </span><span class="s1">X </span><span class="s3">&gt; </span><span class="s1">threshold</span>
        <span class="s1">not_cond </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">logical_not</span><span class="s3">(</span><span class="s1">cond</span><span class="s3">)</span>
        <span class="s1">X</span><span class="s3">[</span><span class="s1">cond</span><span class="s3">] = </span><span class="s4">1</span>
        <span class="s1">X</span><span class="s3">[</span><span class="s1">not_cond</span><span class="s3">] = </span><span class="s4">0</span>
    <span class="s2">return </span><span class="s1">X</span>


<span class="s2">class </span><span class="s1">Binarizer</span><span class="s3">(</span><span class="s1">OneToOneFeatureMixin</span><span class="s3">, </span><span class="s1">TransformerMixin</span><span class="s3">, </span><span class="s1">BaseEstimator</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Binarize data (set feature values to 0 or 1) according to a threshold. 
 
    Values greater than the threshold map to 1, while values less than 
    or equal to the threshold map to 0. With the default threshold of 0, 
    only positive values map to 1. 
 
    Binarization is a common operation on text count data where the 
    analyst can decide to only consider the presence or absence of a 
    feature rather than a quantified number of occurrences for instance. 
 
    It can also be used as a pre-processing step for estimators that 
    consider boolean random variables (e.g. modelled using the Bernoulli 
    distribution in a Bayesian setting). 
 
    Read more in the :ref:`User Guide &lt;preprocessing_binarization&gt;`. 
 
    Parameters 
    ---------- 
    threshold : float, default=0.0 
        Feature values below or equal to this are replaced by 0, above it by 1. 
        Threshold may not be less than 0 for operations on sparse matrices. 
 
    copy : bool, default=True 
        Set to False to perform inplace binarization and avoid a copy (if 
        the input is already a numpy array or a scipy.sparse CSR matrix). 
 
    Attributes 
    ---------- 
    n_features_in_ : int 
        Number of features seen during :term:`fit`. 
 
        .. versionadded:: 0.24 
 
    feature_names_in_ : ndarray of shape (`n_features_in_`,) 
        Names of features seen during :term:`fit`. Defined only when `X` 
        has feature names that are all strings. 
 
        .. versionadded:: 1.0 
 
    See Also 
    -------- 
    binarize : Equivalent function without the estimator API. 
    KBinsDiscretizer : Bin continuous data into intervals. 
    OneHotEncoder : Encode categorical features as a one-hot numeric array. 
 
    Notes 
    ----- 
    If the input is a sparse matrix, only the non-zero values are subject 
    to update by the :class:`Binarizer` class. 
 
    This estimator is :term:`stateless` and does not need to be fitted. 
    However, we recommend to call :meth:`fit_transform` instead of 
    :meth:`transform`, as parameter validation is only performed in 
    :meth:`fit`. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from sklearn.preprocessing import Binarizer 
    &gt;&gt;&gt; X = [[ 1., -1.,  2.], 
    ...      [ 2.,  0.,  0.], 
    ...      [ 0.,  1., -1.]] 
    &gt;&gt;&gt; transformer = Binarizer().fit(X)  # fit does nothing. 
    &gt;&gt;&gt; transformer 
    Binarizer() 
    &gt;&gt;&gt; transformer.transform(X) 
    array([[1., 0., 1.], 
           [1., 0., 0.], 
           [0., 1., 0.]]) 
    &quot;&quot;&quot;</span>

    <span class="s1">_parameter_constraints</span><span class="s3">: </span><span class="s1">dict </span><span class="s3">= {</span>
        <span class="s5">&quot;threshold&quot;</span><span class="s3">: [</span><span class="s1">Real</span><span class="s3">],</span>
        <span class="s5">&quot;copy&quot;</span><span class="s3">: [</span><span class="s5">&quot;boolean&quot;</span><span class="s3">],</span>
    <span class="s3">}</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, *, </span><span class="s1">threshold</span><span class="s3">=</span><span class="s4">0.0</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">threshold </span><span class="s3">= </span><span class="s1">threshold</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">copy </span><span class="s3">= </span><span class="s1">copy</span>

    <span class="s3">@</span><span class="s1">_fit_context</span><span class="s3">(</span><span class="s1">prefer_skip_nested_validation</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
    <span class="s2">def </span><span class="s1">fit</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot;Only validates estimator's parameters. 
 
        This method allows to: (i) validate the estimator's parameters and 
        (ii) be consistent with the scikit-learn transformer API. 
 
        Parameters 
        ---------- 
        X : {array-like, sparse matrix} of shape (n_samples, n_features) 
            The data. 
 
        y : None 
            Ignored. 
 
        Returns 
        ------- 
        self : object 
            Fitted transformer. 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_validate_data</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">accept_sparse</span><span class="s3">=</span><span class="s5">&quot;csr&quot;</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">transform</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot;Binarize each element of X. 
 
        Parameters 
        ---------- 
        X : {array-like, sparse matrix} of shape (n_samples, n_features) 
            The data to binarize, element by element. 
            scipy.sparse matrices should be in CSR format to avoid an 
            un-necessary copy. 
 
        copy : bool 
            Copy the input X or not. 
 
        Returns 
        ------- 
        X_tr : {ndarray, sparse matrix} of shape (n_samples, n_features) 
            Transformed array. 
        &quot;&quot;&quot;</span>
        <span class="s1">copy </span><span class="s3">= </span><span class="s1">copy </span><span class="s2">if </span><span class="s1">copy </span><span class="s2">is not None else </span><span class="s1">self</span><span class="s3">.</span><span class="s1">copy</span>
        <span class="s0"># TODO: This should be refactored because binarize also calls</span>
        <span class="s0"># check_array</span>
        <span class="s1">X </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_validate_data</span><span class="s3">(</span>
            <span class="s1">X</span><span class="s3">,</span>
            <span class="s1">accept_sparse</span><span class="s3">=[</span><span class="s5">&quot;csr&quot;</span><span class="s3">, </span><span class="s5">&quot;csc&quot;</span><span class="s3">],</span>
            <span class="s1">force_writeable</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
            <span class="s1">copy</span><span class="s3">=</span><span class="s1">copy</span><span class="s3">,</span>
            <span class="s1">reset</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
        <span class="s3">)</span>
        <span class="s2">return </span><span class="s1">binarize</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">threshold</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">threshold</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_more_tags</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s3">{</span><span class="s5">&quot;stateless&quot;</span><span class="s3">: </span><span class="s2">True</span><span class="s3">}</span>


<span class="s2">class </span><span class="s1">KernelCenterer</span><span class="s3">(</span><span class="s1">ClassNamePrefixFeaturesOutMixin</span><span class="s3">, </span><span class="s1">TransformerMixin</span><span class="s3">, </span><span class="s1">BaseEstimator</span><span class="s3">):</span>
    <span class="s6">r&quot;&quot;&quot;Center an arbitrary kernel matrix :math:`K`. 
 
    Let define a kernel :math:`K` such that: 
 
    .. math:: 
        K(X, Y) = \phi(X) . \phi(Y)^{T} 
 
    :math:`\phi(X)` is a function mapping of rows of :math:`X` to a 
    Hilbert space and :math:`K` is of shape `(n_samples, n_samples)`. 
 
    This class allows to compute :math:`\tilde{K}(X, Y)` such that: 
 
    .. math:: 
        \tilde{K(X, Y)} = \tilde{\phi}(X) . \tilde{\phi}(Y)^{T} 
 
    :math:`\tilde{\phi}(X)` is the centered mapped data in the Hilbert 
    space. 
 
    `KernelCenterer` centers the features without explicitly computing the 
    mapping :math:`\phi(\cdot)`. Working with centered kernels is sometime 
    expected when dealing with algebra computation such as eigendecomposition 
    for :class:`~sklearn.decomposition.KernelPCA` for instance. 
 
    Read more in the :ref:`User Guide &lt;kernel_centering&gt;`. 
 
    Attributes 
    ---------- 
    K_fit_rows_ : ndarray of shape (n_samples,) 
        Average of each column of kernel matrix. 
 
    K_fit_all_ : float 
        Average of kernel matrix. 
 
    n_features_in_ : int 
        Number of features seen during :term:`fit`. 
 
        .. versionadded:: 0.24 
 
    feature_names_in_ : ndarray of shape (`n_features_in_`,) 
        Names of features seen during :term:`fit`. Defined only when `X` 
        has feature names that are all strings. 
 
        .. versionadded:: 1.0 
 
    See Also 
    -------- 
    sklearn.kernel_approximation.Nystroem : Approximate a kernel map 
        using a subset of the training data. 
 
    References 
    ---------- 
    .. [1] `Schlkopf, Bernhard, Alexander Smola, and Klaus-Robert Mller. 
       &quot;Nonlinear component analysis as a kernel eigenvalue problem.&quot; 
       Neural computation 10.5 (1998): 1299-1319. 
       &lt;https://www.mlpack.org/papers/kpca.pdf&gt;`_ 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from sklearn.preprocessing import KernelCenterer 
    &gt;&gt;&gt; from sklearn.metrics.pairwise import pairwise_kernels 
    &gt;&gt;&gt; X = [[ 1., -2.,  2.], 
    ...      [ -2.,  1.,  3.], 
    ...      [ 4.,  1., -2.]] 
    &gt;&gt;&gt; K = pairwise_kernels(X, metric='linear') 
    &gt;&gt;&gt; K 
    array([[  9.,   2.,  -2.], 
           [  2.,  14., -13.], 
           [ -2., -13.,  21.]]) 
    &gt;&gt;&gt; transformer = KernelCenterer().fit(K) 
    &gt;&gt;&gt; transformer 
    KernelCenterer() 
    &gt;&gt;&gt; transformer.transform(K) 
    array([[  5.,   0.,  -5.], 
           [  0.,  14., -14.], 
           [ -5., -14.,  19.]]) 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># Needed for backported inspect.signature compatibility with PyPy</span>
        <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">fit</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">K</span><span class="s3">, </span><span class="s1">y</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot;Fit KernelCenterer. 
 
        Parameters 
        ---------- 
        K : ndarray of shape (n_samples, n_samples) 
            Kernel matrix. 
 
        y : None 
            Ignored. 
 
        Returns 
        ------- 
        self : object 
            Returns the instance itself. 
        &quot;&quot;&quot;</span>
        <span class="s1">xp</span><span class="s3">, </span><span class="s1">_ </span><span class="s3">= </span><span class="s1">get_namespace</span><span class="s3">(</span><span class="s1">K</span><span class="s3">)</span>

        <span class="s1">K </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_validate_data</span><span class="s3">(</span><span class="s1">K</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">_array_api</span><span class="s3">.</span><span class="s1">supported_float_dtypes</span><span class="s3">(</span><span class="s1">xp</span><span class="s3">))</span>

        <span class="s2">if </span><span class="s1">K</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] != </span><span class="s1">K</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s4">1</span><span class="s3">]:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span>
                <span class="s5">&quot;Kernel matrix must be a square matrix.&quot;</span>
                <span class="s5">&quot; Input is a {}x{} matrix.&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">K</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s4">0</span><span class="s3">], </span><span class="s1">K</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s4">1</span><span class="s3">])</span>
            <span class="s3">)</span>

        <span class="s1">n_samples </span><span class="s3">= </span><span class="s1">K</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">K_fit_rows_ </span><span class="s3">= </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">(</span><span class="s1">K</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s4">0</span><span class="s3">) / </span><span class="s1">n_samples</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">K_fit_all_ </span><span class="s3">= </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">K_fit_rows_</span><span class="s3">) / </span><span class="s1">n_samples</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">transform</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">K</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot;Center kernel matrix. 
 
        Parameters 
        ---------- 
        K : ndarray of shape (n_samples1, n_samples2) 
            Kernel matrix. 
 
        copy : bool, default=True 
            Set to False to perform inplace computation. 
 
        Returns 
        ------- 
        K_new : ndarray of shape (n_samples1, n_samples2) 
            Returns the instance itself. 
        &quot;&quot;&quot;</span>
        <span class="s1">check_is_fitted</span><span class="s3">(</span><span class="s1">self</span><span class="s3">)</span>

        <span class="s1">xp</span><span class="s3">, </span><span class="s1">_ </span><span class="s3">= </span><span class="s1">get_namespace</span><span class="s3">(</span><span class="s1">K</span><span class="s3">)</span>

        <span class="s1">K </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_validate_data</span><span class="s3">(</span>
            <span class="s1">K</span><span class="s3">,</span>
            <span class="s1">copy</span><span class="s3">=</span><span class="s1">copy</span><span class="s3">,</span>
            <span class="s1">force_writeable</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
            <span class="s1">dtype</span><span class="s3">=</span><span class="s1">_array_api</span><span class="s3">.</span><span class="s1">supported_float_dtypes</span><span class="s3">(</span><span class="s1">xp</span><span class="s3">),</span>
            <span class="s1">reset</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
        <span class="s3">)</span>

        <span class="s1">K_pred_cols </span><span class="s3">= (</span><span class="s1">xp</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">(</span><span class="s1">K</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s4">1</span><span class="s3">) / </span><span class="s1">self</span><span class="s3">.</span><span class="s1">K_fit_rows_</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s4">0</span><span class="s3">])[:, </span><span class="s2">None</span><span class="s3">]</span>

        <span class="s1">K </span><span class="s3">-= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">K_fit_rows_</span>
        <span class="s1">K </span><span class="s3">-= </span><span class="s1">K_pred_cols</span>
        <span class="s1">K </span><span class="s3">+= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">K_fit_all_</span>

        <span class="s2">return </span><span class="s1">K</span>

    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">_n_features_out</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot;Number of transformed output features.&quot;&quot;&quot;</span>
        <span class="s0"># Used by ClassNamePrefixFeaturesOutMixin. This model preserves the</span>
        <span class="s0"># number of input features but this is not a one-to-one mapping in the</span>
        <span class="s0"># usual sense. Hence the choice not to use OneToOneFeatureMixin to</span>
        <span class="s0"># implement get_feature_names_out for this class.</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_features_in_</span>

    <span class="s2">def </span><span class="s1">_more_tags</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s3">{</span><span class="s5">&quot;pairwise&quot;</span><span class="s3">: </span><span class="s2">True</span><span class="s3">, </span><span class="s5">&quot;array_api_support&quot;</span><span class="s3">: </span><span class="s2">True</span><span class="s3">}</span>


<span class="s3">@</span><span class="s1">validate_params</span><span class="s3">(</span>
    <span class="s3">{</span>
        <span class="s5">&quot;X&quot;</span><span class="s3">: [</span><span class="s5">&quot;array-like&quot;</span><span class="s3">, </span><span class="s5">&quot;sparse matrix&quot;</span><span class="s3">],</span>
        <span class="s5">&quot;value&quot;</span><span class="s3">: [</span><span class="s1">Interval</span><span class="s3">(</span><span class="s1">Real</span><span class="s3">, </span><span class="s2">None</span><span class="s3">, </span><span class="s2">None</span><span class="s3">, </span><span class="s1">closed</span><span class="s3">=</span><span class="s5">&quot;neither&quot;</span><span class="s3">)],</span>
    <span class="s3">},</span>
    <span class="s1">prefer_skip_nested_validation</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
<span class="s3">)</span>
<span class="s2">def </span><span class="s1">add_dummy_feature</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">value</span><span class="s3">=</span><span class="s4">1.0</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Augment dataset with an additional dummy feature. 
 
    This is useful for fitting an intercept term with implementations which 
    cannot otherwise fit it directly. 
 
    Parameters 
    ---------- 
    X : {array-like, sparse matrix} of shape (n_samples, n_features) 
        Data. 
 
    value : float 
        Value to use for the dummy feature. 
 
    Returns 
    ------- 
    X : {ndarray, sparse matrix} of shape (n_samples, n_features + 1) 
        Same data with dummy feature added as first column. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from sklearn.preprocessing import add_dummy_feature 
    &gt;&gt;&gt; add_dummy_feature([[0, 1], [1, 0]]) 
    array([[1., 0., 1.], 
           [1., 1., 0.]]) 
    &quot;&quot;&quot;</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">check_array</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">accept_sparse</span><span class="s3">=[</span><span class="s5">&quot;csc&quot;</span><span class="s3">, </span><span class="s5">&quot;csr&quot;</span><span class="s3">, </span><span class="s5">&quot;coo&quot;</span><span class="s3">], </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">FLOAT_DTYPES</span><span class="s3">)</span>
    <span class="s1">n_samples</span><span class="s3">, </span><span class="s1">n_features </span><span class="s3">= </span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span>
    <span class="s1">shape </span><span class="s3">= (</span><span class="s1">n_samples</span><span class="s3">, </span><span class="s1">n_features </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">sparse</span><span class="s3">.</span><span class="s1">issparse</span><span class="s3">(</span><span class="s1">X</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">X</span><span class="s3">.</span><span class="s1">format </span><span class="s3">== </span><span class="s5">&quot;coo&quot;</span><span class="s3">:</span>
            <span class="s0"># Shift columns to the right.</span>
            <span class="s1">col </span><span class="s3">= </span><span class="s1">X</span><span class="s3">.</span><span class="s1">col </span><span class="s3">+ </span><span class="s4">1</span>
            <span class="s0"># Column indices of dummy feature are 0 everywhere.</span>
            <span class="s1">col </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">concatenate</span><span class="s3">((</span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">n_samples</span><span class="s3">), </span><span class="s1">col</span><span class="s3">))</span>
            <span class="s0"># Row indices of dummy feature are 0, ..., n_samples-1.</span>
            <span class="s1">row </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">concatenate</span><span class="s3">((</span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s1">n_samples</span><span class="s3">), </span><span class="s1">X</span><span class="s3">.</span><span class="s1">row</span><span class="s3">))</span>
            <span class="s0"># Prepend the dummy feature n_samples times.</span>
            <span class="s1">data </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">concatenate</span><span class="s3">((</span><span class="s1">np</span><span class="s3">.</span><span class="s1">full</span><span class="s3">(</span><span class="s1">n_samples</span><span class="s3">, </span><span class="s1">value</span><span class="s3">), </span><span class="s1">X</span><span class="s3">.</span><span class="s1">data</span><span class="s3">))</span>
            <span class="s2">return </span><span class="s1">sparse</span><span class="s3">.</span><span class="s1">coo_matrix</span><span class="s3">((</span><span class="s1">data</span><span class="s3">, (</span><span class="s1">row</span><span class="s3">, </span><span class="s1">col</span><span class="s3">)), </span><span class="s1">shape</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">X</span><span class="s3">.</span><span class="s1">format </span><span class="s3">== </span><span class="s5">&quot;csc&quot;</span><span class="s3">:</span>
            <span class="s0"># Shift index pointers since we need to add n_samples elements.</span>
            <span class="s1">indptr </span><span class="s3">= </span><span class="s1">X</span><span class="s3">.</span><span class="s1">indptr </span><span class="s3">+ </span><span class="s1">n_samples</span>
            <span class="s0"># indptr[0] must be 0.</span>
            <span class="s1">indptr </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">concatenate</span><span class="s3">((</span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s4">0</span><span class="s3">]), </span><span class="s1">indptr</span><span class="s3">))</span>
            <span class="s0"># Row indices of dummy feature are 0, ..., n_samples-1.</span>
            <span class="s1">indices </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">concatenate</span><span class="s3">((</span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s1">n_samples</span><span class="s3">), </span><span class="s1">X</span><span class="s3">.</span><span class="s1">indices</span><span class="s3">))</span>
            <span class="s0"># Prepend the dummy feature n_samples times.</span>
            <span class="s1">data </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">concatenate</span><span class="s3">((</span><span class="s1">np</span><span class="s3">.</span><span class="s1">full</span><span class="s3">(</span><span class="s1">n_samples</span><span class="s3">, </span><span class="s1">value</span><span class="s3">), </span><span class="s1">X</span><span class="s3">.</span><span class="s1">data</span><span class="s3">))</span>
            <span class="s2">return </span><span class="s1">sparse</span><span class="s3">.</span><span class="s1">csc_matrix</span><span class="s3">((</span><span class="s1">data</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">, </span><span class="s1">indptr</span><span class="s3">), </span><span class="s1">shape</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">klass </span><span class="s3">= </span><span class="s1">X</span><span class="s3">.</span><span class="s1">__class__</span>
            <span class="s2">return </span><span class="s1">klass</span><span class="s3">(</span><span class="s1">add_dummy_feature</span><span class="s3">(</span><span class="s1">X</span><span class="s3">.</span><span class="s1">tocoo</span><span class="s3">(), </span><span class="s1">value</span><span class="s3">))</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">hstack</span><span class="s3">((</span><span class="s1">np</span><span class="s3">.</span><span class="s1">full</span><span class="s3">((</span><span class="s1">n_samples</span><span class="s3">, </span><span class="s4">1</span><span class="s3">), </span><span class="s1">value</span><span class="s3">), </span><span class="s1">X</span><span class="s3">))</span>


<span class="s2">class </span><span class="s1">QuantileTransformer</span><span class="s3">(</span><span class="s1">OneToOneFeatureMixin</span><span class="s3">, </span><span class="s1">TransformerMixin</span><span class="s3">, </span><span class="s1">BaseEstimator</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Transform features using quantiles information. 
 
    This method transforms the features to follow a uniform or a normal 
    distribution. Therefore, for a given feature, this transformation tends 
    to spread out the most frequent values. It also reduces the impact of 
    (marginal) outliers: this is therefore a robust preprocessing scheme. 
 
    The transformation is applied on each feature independently. First an 
    estimate of the cumulative distribution function of a feature is 
    used to map the original values to a uniform distribution. The obtained 
    values are then mapped to the desired output distribution using the 
    associated quantile function. Features values of new/unseen data that fall 
    below or above the fitted range will be mapped to the bounds of the output 
    distribution. Note that this transform is non-linear. It may distort linear 
    correlations between variables measured at the same scale but renders 
    variables measured at different scales more directly comparable. 
 
    For example visualizations, refer to :ref:`Compare QuantileTransformer with 
    other scalers &lt;plot_all_scaling_quantile_transformer_section&gt;`. 
 
    Read more in the :ref:`User Guide &lt;preprocessing_transformer&gt;`. 
 
    .. versionadded:: 0.19 
 
    Parameters 
    ---------- 
    n_quantiles : int, default=1000 or n_samples 
        Number of quantiles to be computed. It corresponds to the number 
        of landmarks used to discretize the cumulative distribution function. 
        If n_quantiles is larger than the number of samples, n_quantiles is set 
        to the number of samples as a larger number of quantiles does not give 
        a better approximation of the cumulative distribution function 
        estimator. 
 
    output_distribution : {'uniform', 'normal'}, default='uniform' 
        Marginal distribution for the transformed data. The choices are 
        'uniform' (default) or 'normal'. 
 
    ignore_implicit_zeros : bool, default=False 
        Only applies to sparse matrices. If True, the sparse entries of the 
        matrix are discarded to compute the quantile statistics. If False, 
        these entries are treated as zeros. 
 
    subsample : int or None, default=10_000 
        Maximum number of samples used to estimate the quantiles for 
        computational efficiency. Note that the subsampling procedure may 
        differ for value-identical sparse and dense matrices. 
        Disable subsampling by setting `subsample=None`. 
 
        .. versionadded:: 1.5 
           The option `None` to disable subsampling was added. 
 
    random_state : int, RandomState instance or None, default=None 
        Determines random number generation for subsampling and smoothing 
        noise. 
        Please see ``subsample`` for more details. 
        Pass an int for reproducible results across multiple function calls. 
        See :term:`Glossary &lt;random_state&gt;`. 
 
    copy : bool, default=True 
        Set to False to perform inplace transformation and avoid a copy (if the 
        input is already a numpy array). 
 
    Attributes 
    ---------- 
    n_quantiles_ : int 
        The actual number of quantiles used to discretize the cumulative 
        distribution function. 
 
    quantiles_ : ndarray of shape (n_quantiles, n_features) 
        The values corresponding the quantiles of reference. 
 
    references_ : ndarray of shape (n_quantiles, ) 
        Quantiles of references. 
 
    n_features_in_ : int 
        Number of features seen during :term:`fit`. 
 
        .. versionadded:: 0.24 
 
    feature_names_in_ : ndarray of shape (`n_features_in_`,) 
        Names of features seen during :term:`fit`. Defined only when `X` 
        has feature names that are all strings. 
 
        .. versionadded:: 1.0 
 
    See Also 
    -------- 
    quantile_transform : Equivalent function without the estimator API. 
    PowerTransformer : Perform mapping to a normal distribution using a power 
        transform. 
    StandardScaler : Perform standardization that is faster, but less robust 
        to outliers. 
    RobustScaler : Perform robust standardization that removes the influence 
        of outliers but does not put outliers and inliers on the same scale. 
 
    Notes 
    ----- 
    NaNs are treated as missing values: disregarded in fit, and maintained in 
    transform. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from sklearn.preprocessing import QuantileTransformer 
    &gt;&gt;&gt; rng = np.random.RandomState(0) 
    &gt;&gt;&gt; X = np.sort(rng.normal(loc=0.5, scale=0.25, size=(25, 1)), axis=0) 
    &gt;&gt;&gt; qt = QuantileTransformer(n_quantiles=10, random_state=0) 
    &gt;&gt;&gt; qt.fit_transform(X) 
    array([...]) 
    &quot;&quot;&quot;</span>

    <span class="s1">_parameter_constraints</span><span class="s3">: </span><span class="s1">dict </span><span class="s3">= {</span>
        <span class="s5">&quot;n_quantiles&quot;</span><span class="s3">: [</span><span class="s1">Interval</span><span class="s3">(</span><span class="s1">Integral</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s2">None</span><span class="s3">, </span><span class="s1">closed</span><span class="s3">=</span><span class="s5">&quot;left&quot;</span><span class="s3">)],</span>
        <span class="s5">&quot;output_distribution&quot;</span><span class="s3">: [</span><span class="s1">StrOptions</span><span class="s3">({</span><span class="s5">&quot;uniform&quot;</span><span class="s3">, </span><span class="s5">&quot;normal&quot;</span><span class="s3">})],</span>
        <span class="s5">&quot;ignore_implicit_zeros&quot;</span><span class="s3">: [</span><span class="s5">&quot;boolean&quot;</span><span class="s3">],</span>
        <span class="s5">&quot;subsample&quot;</span><span class="s3">: [</span><span class="s1">Interval</span><span class="s3">(</span><span class="s1">Integral</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s2">None</span><span class="s3">, </span><span class="s1">closed</span><span class="s3">=</span><span class="s5">&quot;left&quot;</span><span class="s3">), </span><span class="s2">None</span><span class="s3">],</span>
        <span class="s5">&quot;random_state&quot;</span><span class="s3">: [</span><span class="s5">&quot;random_state&quot;</span><span class="s3">],</span>
        <span class="s5">&quot;copy&quot;</span><span class="s3">: [</span><span class="s5">&quot;boolean&quot;</span><span class="s3">],</span>
    <span class="s3">}</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s3">*,</span>
        <span class="s1">n_quantiles</span><span class="s3">=</span><span class="s4">1000</span><span class="s3">,</span>
        <span class="s1">output_distribution</span><span class="s3">=</span><span class="s5">&quot;uniform&quot;</span><span class="s3">,</span>
        <span class="s1">ignore_implicit_zeros</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
        <span class="s1">subsample</span><span class="s3">=</span><span class="s4">10_000</span><span class="s3">,</span>
        <span class="s1">random_state</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">copy</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
    <span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">n_quantiles </span><span class="s3">= </span><span class="s1">n_quantiles</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">output_distribution </span><span class="s3">= </span><span class="s1">output_distribution</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">ignore_implicit_zeros </span><span class="s3">= </span><span class="s1">ignore_implicit_zeros</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">subsample </span><span class="s3">= </span><span class="s1">subsample</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">random_state </span><span class="s3">= </span><span class="s1">random_state</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">copy </span><span class="s3">= </span><span class="s1">copy</span>

    <span class="s2">def </span><span class="s1">_dense_fit</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot;Compute percentiles for dense matrices. 
 
        Parameters 
        ---------- 
        X : ndarray of shape (n_samples, n_features) 
            The data used to scale along the features axis. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">ignore_implicit_zeros</span><span class="s3">:</span>
            <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span>
                <span class="s5">&quot;'ignore_implicit_zeros' takes effect only with&quot;</span>
                <span class="s5">&quot; sparse matrix. This parameter has no effect.&quot;</span>
            <span class="s3">)</span>

        <span class="s1">n_samples</span><span class="s3">, </span><span class="s1">n_features </span><span class="s3">= </span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span>
        <span class="s1">references </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">references_ </span><span class="s3">* </span><span class="s4">100</span>

        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">subsample </span><span class="s2">is not None and </span><span class="s1">self</span><span class="s3">.</span><span class="s1">subsample </span><span class="s3">&lt; </span><span class="s1">n_samples</span><span class="s3">:</span>
            <span class="s0"># Take a subsample of `X`</span>
            <span class="s1">X </span><span class="s3">= </span><span class="s1">resample</span><span class="s3">(</span>
                <span class="s1">X</span><span class="s3">, </span><span class="s1">replace</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">n_samples</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">subsample</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s1">random_state</span>
            <span class="s3">)</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">quantiles_ </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nanpercentile</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">references</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s4">0</span><span class="s3">)</span>
        <span class="s0"># Due to floating-point precision error in `np.nanpercentile`,</span>
        <span class="s0"># make sure that quantiles are monotonically increasing.</span>
        <span class="s0"># Upstream issue in numpy:</span>
        <span class="s0"># https://github.com/numpy/numpy/issues/14685</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">quantiles_ </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">maximum</span><span class="s3">.</span><span class="s1">accumulate</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">quantiles_</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_sparse_fit</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot;Compute percentiles for sparse matrices. 
 
        Parameters 
        ---------- 
        X : sparse matrix of shape (n_samples, n_features) 
            The data used to scale along the features axis. The sparse matrix 
            needs to be nonnegative. If a sparse matrix is provided, 
            it will be converted into a sparse ``csc_matrix``. 
        &quot;&quot;&quot;</span>
        <span class="s1">n_samples</span><span class="s3">, </span><span class="s1">n_features </span><span class="s3">= </span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span>
        <span class="s1">references </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">references_ </span><span class="s3">* </span><span class="s4">100</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">quantiles_ </span><span class="s3">= []</span>
        <span class="s2">for </span><span class="s1">feature_idx </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">n_features</span><span class="s3">):</span>
            <span class="s1">column_nnz_data </span><span class="s3">= </span><span class="s1">X</span><span class="s3">.</span><span class="s1">data</span><span class="s3">[</span><span class="s1">X</span><span class="s3">.</span><span class="s1">indptr</span><span class="s3">[</span><span class="s1">feature_idx</span><span class="s3">] : </span><span class="s1">X</span><span class="s3">.</span><span class="s1">indptr</span><span class="s3">[</span><span class="s1">feature_idx </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">]]</span>
            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">subsample </span><span class="s2">is not None and </span><span class="s1">len</span><span class="s3">(</span><span class="s1">column_nnz_data</span><span class="s3">) &gt; </span><span class="s1">self</span><span class="s3">.</span><span class="s1">subsample</span><span class="s3">:</span>
                <span class="s1">column_subsample </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">subsample </span><span class="s3">* </span><span class="s1">len</span><span class="s3">(</span><span class="s1">column_nnz_data</span><span class="s3">) // </span><span class="s1">n_samples</span>
                <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">ignore_implicit_zeros</span><span class="s3">:</span>
                    <span class="s1">column_data </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">=</span><span class="s1">column_subsample</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">X</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">column_data </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">subsample</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">X</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>
                <span class="s1">column_data</span><span class="s3">[:</span><span class="s1">column_subsample</span><span class="s3">] = </span><span class="s1">random_state</span><span class="s3">.</span><span class="s1">choice</span><span class="s3">(</span>
                    <span class="s1">column_nnz_data</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=</span><span class="s1">column_subsample</span><span class="s3">, </span><span class="s1">replace</span><span class="s3">=</span><span class="s2">False</span>
                <span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">ignore_implicit_zeros</span><span class="s3">:</span>
                    <span class="s1">column_data </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">=</span><span class="s1">len</span><span class="s3">(</span><span class="s1">column_nnz_data</span><span class="s3">), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">X</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">column_data </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">=</span><span class="s1">n_samples</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">X</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>
                <span class="s1">column_data</span><span class="s3">[: </span><span class="s1">len</span><span class="s3">(</span><span class="s1">column_nnz_data</span><span class="s3">)] = </span><span class="s1">column_nnz_data</span>

            <span class="s2">if not </span><span class="s1">column_data</span><span class="s3">.</span><span class="s1">size</span><span class="s3">:</span>
                <span class="s0"># if no nnz, an error will be raised for computing the</span>
                <span class="s0"># quantiles. Force the quantiles to be zeros.</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">quantiles_</span><span class="s3">.</span><span class="s1">append</span><span class="s3">([</span><span class="s4">0</span><span class="s3">] * </span><span class="s1">len</span><span class="s3">(</span><span class="s1">references</span><span class="s3">))</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">quantiles_</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">nanpercentile</span><span class="s3">(</span><span class="s1">column_data</span><span class="s3">, </span><span class="s1">references</span><span class="s3">))</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">quantiles_ </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">transpose</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">quantiles_</span><span class="s3">)</span>
        <span class="s0"># due to floating-point precision error in `np.nanpercentile`,</span>
        <span class="s0"># make sure the quantiles are monotonically increasing</span>
        <span class="s0"># Upstream issue in numpy:</span>
        <span class="s0"># https://github.com/numpy/numpy/issues/14685</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">quantiles_ </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">maximum</span><span class="s3">.</span><span class="s1">accumulate</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">quantiles_</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">_fit_context</span><span class="s3">(</span><span class="s1">prefer_skip_nested_validation</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
    <span class="s2">def </span><span class="s1">fit</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot;Compute the quantiles used for transforming. 
 
        Parameters 
        ---------- 
        X : {array-like, sparse matrix} of shape (n_samples, n_features) 
            The data used to scale along the features axis. If a sparse 
            matrix is provided, it will be converted into a sparse 
            ``csc_matrix``. Additionally, the sparse matrix needs to be 
            nonnegative if `ignore_implicit_zeros` is False. 
 
        y : None 
            Ignored. 
 
        Returns 
        ------- 
        self : object 
           Fitted transformer. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">subsample </span><span class="s2">is not None and </span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_quantiles </span><span class="s3">&gt; </span><span class="s1">self</span><span class="s3">.</span><span class="s1">subsample</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span>
                <span class="s5">&quot;The number of quantiles cannot be greater than&quot;</span>
                <span class="s5">&quot; the number of samples used. Got {} quantiles&quot;</span>
                <span class="s5">&quot; and {} samples.&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_quantiles</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">subsample</span><span class="s3">)</span>
            <span class="s3">)</span>

        <span class="s1">X </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_check_inputs</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">in_fit</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
        <span class="s1">n_samples </span><span class="s3">= </span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]</span>

        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_quantiles </span><span class="s3">&gt; </span><span class="s1">n_samples</span><span class="s3">:</span>
            <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span>
                <span class="s5">&quot;n_quantiles (%s) is greater than the total number &quot;</span>
                <span class="s5">&quot;of samples (%s). n_quantiles is set to &quot;</span>
                <span class="s5">&quot;n_samples.&quot; </span><span class="s3">% (</span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_quantiles</span><span class="s3">, </span><span class="s1">n_samples</span><span class="s3">)</span>
            <span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">n_quantiles_ </span><span class="s3">= </span><span class="s1">max</span><span class="s3">(</span><span class="s4">1</span><span class="s3">, </span><span class="s1">min</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_quantiles</span><span class="s3">, </span><span class="s1">n_samples</span><span class="s3">))</span>

        <span class="s1">rng </span><span class="s3">= </span><span class="s1">check_random_state</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">random_state</span><span class="s3">)</span>

        <span class="s0"># Create the quantiles of reference</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">references_ </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">linspace</span><span class="s3">(</span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_quantiles_</span><span class="s3">, </span><span class="s1">endpoint</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">sparse</span><span class="s3">.</span><span class="s1">issparse</span><span class="s3">(</span><span class="s1">X</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_sparse_fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">rng</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_dense_fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">rng</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">_transform_col</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">X_col</span><span class="s3">, </span><span class="s1">quantiles</span><span class="s3">, </span><span class="s1">inverse</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot;Private function to transform a single feature.&quot;&quot;&quot;</span>

        <span class="s1">output_distribution </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">output_distribution</span>

        <span class="s2">if not </span><span class="s1">inverse</span><span class="s3">:</span>
            <span class="s1">lower_bound_x </span><span class="s3">= </span><span class="s1">quantiles</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]</span>
            <span class="s1">upper_bound_x </span><span class="s3">= </span><span class="s1">quantiles</span><span class="s3">[-</span><span class="s4">1</span><span class="s3">]</span>
            <span class="s1">lower_bound_y </span><span class="s3">= </span><span class="s4">0</span>
            <span class="s1">upper_bound_y </span><span class="s3">= </span><span class="s4">1</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">lower_bound_x </span><span class="s3">= </span><span class="s4">0</span>
            <span class="s1">upper_bound_x </span><span class="s3">= </span><span class="s4">1</span>
            <span class="s1">lower_bound_y </span><span class="s3">= </span><span class="s1">quantiles</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]</span>
            <span class="s1">upper_bound_y </span><span class="s3">= </span><span class="s1">quantiles</span><span class="s3">[-</span><span class="s4">1</span><span class="s3">]</span>
            <span class="s0"># for inverse transform, match a uniform distribution</span>
            <span class="s2">with </span><span class="s1">np</span><span class="s3">.</span><span class="s1">errstate</span><span class="s3">(</span><span class="s1">invalid</span><span class="s3">=</span><span class="s5">&quot;ignore&quot;</span><span class="s3">):  </span><span class="s0"># hide NaN comparison warnings</span>
                <span class="s2">if </span><span class="s1">output_distribution </span><span class="s3">== </span><span class="s5">&quot;normal&quot;</span><span class="s3">:</span>
                    <span class="s1">X_col </span><span class="s3">= </span><span class="s1">stats</span><span class="s3">.</span><span class="s1">norm</span><span class="s3">.</span><span class="s1">cdf</span><span class="s3">(</span><span class="s1">X_col</span><span class="s3">)</span>
                <span class="s0"># else output distribution is already a uniform distribution</span>

        <span class="s0"># find index for lower and higher bounds</span>
        <span class="s2">with </span><span class="s1">np</span><span class="s3">.</span><span class="s1">errstate</span><span class="s3">(</span><span class="s1">invalid</span><span class="s3">=</span><span class="s5">&quot;ignore&quot;</span><span class="s3">):  </span><span class="s0"># hide NaN comparison warnings</span>
            <span class="s2">if </span><span class="s1">output_distribution </span><span class="s3">== </span><span class="s5">&quot;normal&quot;</span><span class="s3">:</span>
                <span class="s1">lower_bounds_idx </span><span class="s3">= </span><span class="s1">X_col </span><span class="s3">- </span><span class="s1">BOUNDS_THRESHOLD </span><span class="s3">&lt; </span><span class="s1">lower_bound_x</span>
                <span class="s1">upper_bounds_idx </span><span class="s3">= </span><span class="s1">X_col </span><span class="s3">+ </span><span class="s1">BOUNDS_THRESHOLD </span><span class="s3">&gt; </span><span class="s1">upper_bound_x</span>
            <span class="s2">if </span><span class="s1">output_distribution </span><span class="s3">== </span><span class="s5">&quot;uniform&quot;</span><span class="s3">:</span>
                <span class="s1">lower_bounds_idx </span><span class="s3">= </span><span class="s1">X_col </span><span class="s3">== </span><span class="s1">lower_bound_x</span>
                <span class="s1">upper_bounds_idx </span><span class="s3">= </span><span class="s1">X_col </span><span class="s3">== </span><span class="s1">upper_bound_x</span>

        <span class="s1">isfinite_mask </span><span class="s3">= ~</span><span class="s1">np</span><span class="s3">.</span><span class="s1">isnan</span><span class="s3">(</span><span class="s1">X_col</span><span class="s3">)</span>
        <span class="s1">X_col_finite </span><span class="s3">= </span><span class="s1">X_col</span><span class="s3">[</span><span class="s1">isfinite_mask</span><span class="s3">]</span>
        <span class="s2">if not </span><span class="s1">inverse</span><span class="s3">:</span>
            <span class="s0"># Interpolate in one direction and in the other and take the</span>
            <span class="s0"># mean. This is in case of repeated values in the features</span>
            <span class="s0"># and hence repeated quantiles</span>
            <span class="s0">#</span>
            <span class="s0"># If we don't do this, only one extreme of the duplicated is</span>
            <span class="s0"># used (the upper when we do ascending, and the</span>
            <span class="s0"># lower for descending). We take the mean of these two</span>
            <span class="s1">X_col</span><span class="s3">[</span><span class="s1">isfinite_mask</span><span class="s3">] = </span><span class="s4">0.5 </span><span class="s3">* (</span>
                <span class="s1">np</span><span class="s3">.</span><span class="s1">interp</span><span class="s3">(</span><span class="s1">X_col_finite</span><span class="s3">, </span><span class="s1">quantiles</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">references_</span><span class="s3">)</span>
                <span class="s3">- </span><span class="s1">np</span><span class="s3">.</span><span class="s1">interp</span><span class="s3">(-</span><span class="s1">X_col_finite</span><span class="s3">, -</span><span class="s1">quantiles</span><span class="s3">[::-</span><span class="s4">1</span><span class="s3">], -</span><span class="s1">self</span><span class="s3">.</span><span class="s1">references_</span><span class="s3">[::-</span><span class="s4">1</span><span class="s3">])</span>
            <span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">X_col</span><span class="s3">[</span><span class="s1">isfinite_mask</span><span class="s3">] = </span><span class="s1">np</span><span class="s3">.</span><span class="s1">interp</span><span class="s3">(</span><span class="s1">X_col_finite</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">references_</span><span class="s3">, </span><span class="s1">quantiles</span><span class="s3">)</span>

        <span class="s1">X_col</span><span class="s3">[</span><span class="s1">upper_bounds_idx</span><span class="s3">] = </span><span class="s1">upper_bound_y</span>
        <span class="s1">X_col</span><span class="s3">[</span><span class="s1">lower_bounds_idx</span><span class="s3">] = </span><span class="s1">lower_bound_y</span>
        <span class="s0"># for forward transform, match the output distribution</span>
        <span class="s2">if not </span><span class="s1">inverse</span><span class="s3">:</span>
            <span class="s2">with </span><span class="s1">np</span><span class="s3">.</span><span class="s1">errstate</span><span class="s3">(</span><span class="s1">invalid</span><span class="s3">=</span><span class="s5">&quot;ignore&quot;</span><span class="s3">):  </span><span class="s0"># hide NaN comparison warnings</span>
                <span class="s2">if </span><span class="s1">output_distribution </span><span class="s3">== </span><span class="s5">&quot;normal&quot;</span><span class="s3">:</span>
                    <span class="s1">X_col </span><span class="s3">= </span><span class="s1">stats</span><span class="s3">.</span><span class="s1">norm</span><span class="s3">.</span><span class="s1">ppf</span><span class="s3">(</span><span class="s1">X_col</span><span class="s3">)</span>
                    <span class="s0"># find the value to clip the data to avoid mapping to</span>
                    <span class="s0"># infinity. Clip such that the inverse transform will be</span>
                    <span class="s0"># consistent</span>
                    <span class="s1">clip_min </span><span class="s3">= </span><span class="s1">stats</span><span class="s3">.</span><span class="s1">norm</span><span class="s3">.</span><span class="s1">ppf</span><span class="s3">(</span><span class="s1">BOUNDS_THRESHOLD </span><span class="s3">- </span><span class="s1">np</span><span class="s3">.</span><span class="s1">spacing</span><span class="s3">(</span><span class="s4">1</span><span class="s3">))</span>
                    <span class="s1">clip_max </span><span class="s3">= </span><span class="s1">stats</span><span class="s3">.</span><span class="s1">norm</span><span class="s3">.</span><span class="s1">ppf</span><span class="s3">(</span><span class="s4">1 </span><span class="s3">- (</span><span class="s1">BOUNDS_THRESHOLD </span><span class="s3">- </span><span class="s1">np</span><span class="s3">.</span><span class="s1">spacing</span><span class="s3">(</span><span class="s4">1</span><span class="s3">)))</span>
                    <span class="s1">X_col </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">clip</span><span class="s3">(</span><span class="s1">X_col</span><span class="s3">, </span><span class="s1">clip_min</span><span class="s3">, </span><span class="s1">clip_max</span><span class="s3">)</span>
                <span class="s0"># else output distribution is uniform and the ppf is the</span>
                <span class="s0"># identity function so we let X_col unchanged</span>

        <span class="s2">return </span><span class="s1">X_col</span>

    <span class="s2">def </span><span class="s1">_check_inputs</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">in_fit</span><span class="s3">, </span><span class="s1">accept_sparse_negative</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot;Check inputs before fit and transform.&quot;&quot;&quot;</span>
        <span class="s1">X </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_validate_data</span><span class="s3">(</span>
            <span class="s1">X</span><span class="s3">,</span>
            <span class="s1">reset</span><span class="s3">=</span><span class="s1">in_fit</span><span class="s3">,</span>
            <span class="s1">accept_sparse</span><span class="s3">=</span><span class="s5">&quot;csc&quot;</span><span class="s3">,</span>
            <span class="s1">copy</span><span class="s3">=</span><span class="s1">copy</span><span class="s3">,</span>
            <span class="s1">dtype</span><span class="s3">=</span><span class="s1">FLOAT_DTYPES</span><span class="s3">,</span>
            <span class="s0"># only set force_writeable for the validation at transform time because</span>
            <span class="s0"># it's the only place where QuantileTransformer performs inplace operations.</span>
            <span class="s1">force_writeable</span><span class="s3">=</span><span class="s2">True if not </span><span class="s1">in_fit </span><span class="s2">else None</span><span class="s3">,</span>
            <span class="s1">force_all_finite</span><span class="s3">=</span><span class="s5">&quot;allow-nan&quot;</span><span class="s3">,</span>
        <span class="s3">)</span>
        <span class="s0"># we only accept positive sparse matrix when ignore_implicit_zeros is</span>
        <span class="s0"># false and that we call fit or transform.</span>
        <span class="s2">with </span><span class="s1">np</span><span class="s3">.</span><span class="s1">errstate</span><span class="s3">(</span><span class="s1">invalid</span><span class="s3">=</span><span class="s5">&quot;ignore&quot;</span><span class="s3">):  </span><span class="s0"># hide NaN comparison warnings</span>
            <span class="s2">if </span><span class="s3">(</span>
                <span class="s2">not </span><span class="s1">accept_sparse_negative</span>
                <span class="s2">and not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">ignore_implicit_zeros</span>
                <span class="s2">and </span><span class="s3">(</span><span class="s1">sparse</span><span class="s3">.</span><span class="s1">issparse</span><span class="s3">(</span><span class="s1">X</span><span class="s3">) </span><span class="s2">and </span><span class="s1">np</span><span class="s3">.</span><span class="s1">any</span><span class="s3">(</span><span class="s1">X</span><span class="s3">.</span><span class="s1">data </span><span class="s3">&lt; </span><span class="s4">0</span><span class="s3">))</span>
            <span class="s3">):</span>
                <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span>
                    <span class="s5">&quot;QuantileTransformer only accepts non-negative sparse matrices.&quot;</span>
                <span class="s3">)</span>

        <span class="s2">return </span><span class="s1">X</span>

    <span class="s2">def </span><span class="s1">_transform</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">inverse</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot;Forward and inverse transform. 
 
        Parameters 
        ---------- 
        X : ndarray of shape (n_samples, n_features) 
            The data used to scale along the features axis. 
 
        inverse : bool, default=False 
            If False, apply forward transform. If True, apply 
            inverse transform. 
 
        Returns 
        ------- 
        X : ndarray of shape (n_samples, n_features) 
            Projected data. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">sparse</span><span class="s3">.</span><span class="s1">issparse</span><span class="s3">(</span><span class="s1">X</span><span class="s3">):</span>
            <span class="s2">for </span><span class="s1">feature_idx </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s4">1</span><span class="s3">]):</span>
                <span class="s1">column_slice </span><span class="s3">= </span><span class="s1">slice</span><span class="s3">(</span><span class="s1">X</span><span class="s3">.</span><span class="s1">indptr</span><span class="s3">[</span><span class="s1">feature_idx</span><span class="s3">], </span><span class="s1">X</span><span class="s3">.</span><span class="s1">indptr</span><span class="s3">[</span><span class="s1">feature_idx </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">])</span>
                <span class="s1">X</span><span class="s3">.</span><span class="s1">data</span><span class="s3">[</span><span class="s1">column_slice</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_transform_col</span><span class="s3">(</span>
                    <span class="s1">X</span><span class="s3">.</span><span class="s1">data</span><span class="s3">[</span><span class="s1">column_slice</span><span class="s3">], </span><span class="s1">self</span><span class="s3">.</span><span class="s1">quantiles_</span><span class="s3">[:, </span><span class="s1">feature_idx</span><span class="s3">], </span><span class="s1">inverse</span>
                <span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">for </span><span class="s1">feature_idx </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s4">1</span><span class="s3">]):</span>
                <span class="s1">X</span><span class="s3">[:, </span><span class="s1">feature_idx</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_transform_col</span><span class="s3">(</span>
                    <span class="s1">X</span><span class="s3">[:, </span><span class="s1">feature_idx</span><span class="s3">], </span><span class="s1">self</span><span class="s3">.</span><span class="s1">quantiles_</span><span class="s3">[:, </span><span class="s1">feature_idx</span><span class="s3">], </span><span class="s1">inverse</span>
                <span class="s3">)</span>

        <span class="s2">return </span><span class="s1">X</span>

    <span class="s2">def </span><span class="s1">transform</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot;Feature-wise transformation of the data. 
 
        Parameters 
        ---------- 
        X : {array-like, sparse matrix} of shape (n_samples, n_features) 
            The data used to scale along the features axis. If a sparse 
            matrix is provided, it will be converted into a sparse 
            ``csc_matrix``. Additionally, the sparse matrix needs to be 
            nonnegative if `ignore_implicit_zeros` is False. 
 
        Returns 
        ------- 
        Xt : {ndarray, sparse matrix} of shape (n_samples, n_features) 
            The projected data. 
        &quot;&quot;&quot;</span>
        <span class="s1">check_is_fitted</span><span class="s3">(</span><span class="s1">self</span><span class="s3">)</span>
        <span class="s1">X </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_check_inputs</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">in_fit</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_transform</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">inverse</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">inverse_transform</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot;Back-projection to the original space. 
 
        Parameters 
        ---------- 
        X : {array-like, sparse matrix} of shape (n_samples, n_features) 
            The data used to scale along the features axis. If a sparse 
            matrix is provided, it will be converted into a sparse 
            ``csc_matrix``. Additionally, the sparse matrix needs to be 
            nonnegative if `ignore_implicit_zeros` is False. 
 
        Returns 
        ------- 
        Xt : {ndarray, sparse matrix} of (n_samples, n_features) 
            The projected data. 
        &quot;&quot;&quot;</span>
        <span class="s1">check_is_fitted</span><span class="s3">(</span><span class="s1">self</span><span class="s3">)</span>
        <span class="s1">X </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_check_inputs</span><span class="s3">(</span>
            <span class="s1">X</span><span class="s3">, </span><span class="s1">in_fit</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">accept_sparse_negative</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">copy</span>
        <span class="s3">)</span>

        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_transform</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">inverse</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_more_tags</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s3">{</span><span class="s5">&quot;allow_nan&quot;</span><span class="s3">: </span><span class="s2">True</span><span class="s3">}</span>


<span class="s3">@</span><span class="s1">validate_params</span><span class="s3">(</span>
    <span class="s3">{</span><span class="s5">&quot;X&quot;</span><span class="s3">: [</span><span class="s5">&quot;array-like&quot;</span><span class="s3">, </span><span class="s5">&quot;sparse matrix&quot;</span><span class="s3">], </span><span class="s5">&quot;axis&quot;</span><span class="s3">: [</span><span class="s1">Options</span><span class="s3">(</span><span class="s1">Integral</span><span class="s3">, {</span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">})]},</span>
    <span class="s1">prefer_skip_nested_validation</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
<span class="s3">)</span>
<span class="s2">def </span><span class="s1">quantile_transform</span><span class="s3">(</span>
    <span class="s1">X</span><span class="s3">,</span>
    <span class="s3">*,</span>
    <span class="s1">axis</span><span class="s3">=</span><span class="s4">0</span><span class="s3">,</span>
    <span class="s1">n_quantiles</span><span class="s3">=</span><span class="s4">1000</span><span class="s3">,</span>
    <span class="s1">output_distribution</span><span class="s3">=</span><span class="s5">&quot;uniform&quot;</span><span class="s3">,</span>
    <span class="s1">ignore_implicit_zeros</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
    <span class="s1">subsample</span><span class="s3">=</span><span class="s1">int</span><span class="s3">(</span><span class="s4">1e5</span><span class="s3">),</span>
    <span class="s1">random_state</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">copy</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
<span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Transform features using quantiles information. 
 
    This method transforms the features to follow a uniform or a normal 
    distribution. Therefore, for a given feature, this transformation tends 
    to spread out the most frequent values. It also reduces the impact of 
    (marginal) outliers: this is therefore a robust preprocessing scheme. 
 
    The transformation is applied on each feature independently. First an 
    estimate of the cumulative distribution function of a feature is 
    used to map the original values to a uniform distribution. The obtained 
    values are then mapped to the desired output distribution using the 
    associated quantile function. Features values of new/unseen data that fall 
    below or above the fitted range will be mapped to the bounds of the output 
    distribution. Note that this transform is non-linear. It may distort linear 
    correlations between variables measured at the same scale but renders 
    variables measured at different scales more directly comparable. 
 
    Read more in the :ref:`User Guide &lt;preprocessing_transformer&gt;`. 
 
    Parameters 
    ---------- 
    X : {array-like, sparse matrix} of shape (n_samples, n_features) 
        The data to transform. 
 
    axis : int, default=0 
        Axis used to compute the means and standard deviations along. If 0, 
        transform each feature, otherwise (if 1) transform each sample. 
 
    n_quantiles : int, default=1000 or n_samples 
        Number of quantiles to be computed. It corresponds to the number 
        of landmarks used to discretize the cumulative distribution function. 
        If n_quantiles is larger than the number of samples, n_quantiles is set 
        to the number of samples as a larger number of quantiles does not give 
        a better approximation of the cumulative distribution function 
        estimator. 
 
    output_distribution : {'uniform', 'normal'}, default='uniform' 
        Marginal distribution for the transformed data. The choices are 
        'uniform' (default) or 'normal'. 
 
    ignore_implicit_zeros : bool, default=False 
        Only applies to sparse matrices. If True, the sparse entries of the 
        matrix are discarded to compute the quantile statistics. If False, 
        these entries are treated as zeros. 
 
    subsample : int or None, default=1e5 
        Maximum number of samples used to estimate the quantiles for 
        computational efficiency. Note that the subsampling procedure may 
        differ for value-identical sparse and dense matrices. 
        Disable subsampling by setting `subsample=None`. 
 
        .. versionadded:: 1.5 
           The option `None` to disable subsampling was added. 
 
    random_state : int, RandomState instance or None, default=None 
        Determines random number generation for subsampling and smoothing 
        noise. 
        Please see ``subsample`` for more details. 
        Pass an int for reproducible results across multiple function calls. 
        See :term:`Glossary &lt;random_state&gt;`. 
 
    copy : bool, default=True 
        If False, try to avoid a copy and transform in place. 
        This is not guaranteed to always work in place; e.g. if the data is 
        a numpy array with an int dtype, a copy will be returned even with 
        copy=False. 
 
        .. versionchanged:: 0.23 
            The default value of `copy` changed from False to True in 0.23. 
 
    Returns 
    ------- 
    Xt : {ndarray, sparse matrix} of shape (n_samples, n_features) 
        The transformed data. 
 
    See Also 
    -------- 
    QuantileTransformer : Performs quantile-based scaling using the 
        Transformer API (e.g. as part of a preprocessing 
        :class:`~sklearn.pipeline.Pipeline`). 
    power_transform : Maps data to a normal distribution using a 
        power transformation. 
    scale : Performs standardization that is faster, but less robust 
        to outliers. 
    robust_scale : Performs robust standardization that removes the influence 
        of outliers but does not put outliers and inliers on the same scale. 
 
    Notes 
    ----- 
    NaNs are treated as missing values: disregarded in fit, and maintained in 
    transform. 
 
    .. warning:: Risk of data leak 
 
        Do not use :func:`~sklearn.preprocessing.quantile_transform` unless 
        you know what you are doing. A common mistake is to apply it 
        to the entire data *before* splitting into training and 
        test sets. This will bias the model evaluation because 
        information would have leaked from the test set to the 
        training set. 
        In general, we recommend using 
        :class:`~sklearn.preprocessing.QuantileTransformer` within a 
        :ref:`Pipeline &lt;pipeline&gt;` in order to prevent most risks of data 
        leaking:`pipe = make_pipeline(QuantileTransformer(), 
        LogisticRegression())`. 
 
    For a comparison of the different scalers, transformers, and normalizers, 
    see: :ref:`sphx_glr_auto_examples_preprocessing_plot_all_scaling.py`. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from sklearn.preprocessing import quantile_transform 
    &gt;&gt;&gt; rng = np.random.RandomState(0) 
    &gt;&gt;&gt; X = np.sort(rng.normal(loc=0.5, scale=0.25, size=(25, 1)), axis=0) 
    &gt;&gt;&gt; quantile_transform(X, n_quantiles=10, random_state=0, copy=True) 
    array([...]) 
    &quot;&quot;&quot;</span>
    <span class="s1">n </span><span class="s3">= </span><span class="s1">QuantileTransformer</span><span class="s3">(</span>
        <span class="s1">n_quantiles</span><span class="s3">=</span><span class="s1">n_quantiles</span><span class="s3">,</span>
        <span class="s1">output_distribution</span><span class="s3">=</span><span class="s1">output_distribution</span><span class="s3">,</span>
        <span class="s1">subsample</span><span class="s3">=</span><span class="s1">subsample</span><span class="s3">,</span>
        <span class="s1">ignore_implicit_zeros</span><span class="s3">=</span><span class="s1">ignore_implicit_zeros</span><span class="s3">,</span>
        <span class="s1">random_state</span><span class="s3">=</span><span class="s1">random_state</span><span class="s3">,</span>
        <span class="s1">copy</span><span class="s3">=</span><span class="s1">copy</span><span class="s3">,</span>
    <span class="s3">)</span>
    <span class="s2">if </span><span class="s1">axis </span><span class="s3">== </span><span class="s4">0</span><span class="s3">:</span>
        <span class="s1">X </span><span class="s3">= </span><span class="s1">n</span><span class="s3">.</span><span class="s1">fit_transform</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:  </span><span class="s0"># axis == 1</span>
        <span class="s1">X </span><span class="s3">= </span><span class="s1">n</span><span class="s3">.</span><span class="s1">fit_transform</span><span class="s3">(</span><span class="s1">X</span><span class="s3">.</span><span class="s1">T</span><span class="s3">).</span><span class="s1">T</span>
    <span class="s2">return </span><span class="s1">X</span>


<span class="s2">class </span><span class="s1">PowerTransformer</span><span class="s3">(</span><span class="s1">OneToOneFeatureMixin</span><span class="s3">, </span><span class="s1">TransformerMixin</span><span class="s3">, </span><span class="s1">BaseEstimator</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Apply a power transform featurewise to make data more Gaussian-like. 
 
    Power transforms are a family of parametric, monotonic transformations 
    that are applied to make data more Gaussian-like. This is useful for 
    modeling issues related to heteroscedasticity (non-constant variance), 
    or other situations where normality is desired. 
 
    Currently, PowerTransformer supports the Box-Cox transform and the 
    Yeo-Johnson transform. The optimal parameter for stabilizing variance and 
    minimizing skewness is estimated through maximum likelihood. 
 
    Box-Cox requires input data to be strictly positive, while Yeo-Johnson 
    supports both positive or negative data. 
 
    By default, zero-mean, unit-variance normalization is applied to the 
    transformed data. 
 
    For an example visualization, refer to :ref:`Compare PowerTransformer with 
    other scalers &lt;plot_all_scaling_power_transformer_section&gt;`. To see the 
    effect of Box-Cox and Yeo-Johnson transformations on different 
    distributions, see: 
    :ref:`sphx_glr_auto_examples_preprocessing_plot_map_data_to_normal.py`. 
 
    Read more in the :ref:`User Guide &lt;preprocessing_transformer&gt;`. 
 
    .. versionadded:: 0.20 
 
    Parameters 
    ---------- 
    method : {'yeo-johnson', 'box-cox'}, default='yeo-johnson' 
        The power transform method. Available methods are: 
 
        - 'yeo-johnson' [1]_, works with positive and negative values 
        - 'box-cox' [2]_, only works with strictly positive values 
 
    standardize : bool, default=True 
        Set to True to apply zero-mean, unit-variance normalization to the 
        transformed output. 
 
    copy : bool, default=True 
        Set to False to perform inplace computation during transformation. 
 
    Attributes 
    ---------- 
    lambdas_ : ndarray of float of shape (n_features,) 
        The parameters of the power transformation for the selected features. 
 
    n_features_in_ : int 
        Number of features seen during :term:`fit`. 
 
        .. versionadded:: 0.24 
 
    feature_names_in_ : ndarray of shape (`n_features_in_`,) 
        Names of features seen during :term:`fit`. Defined only when `X` 
        has feature names that are all strings. 
 
        .. versionadded:: 1.0 
 
    See Also 
    -------- 
    power_transform : Equivalent function without the estimator API. 
 
    QuantileTransformer : Maps data to a standard normal distribution with 
        the parameter `output_distribution='normal'`. 
 
    Notes 
    ----- 
    NaNs are treated as missing values: disregarded in ``fit``, and maintained 
    in ``transform``. 
 
    References 
    ---------- 
 
    .. [1] :doi:`I.K. Yeo and R.A. Johnson, &quot;A new family of power 
           transformations to improve normality or symmetry.&quot; Biometrika, 
           87(4), pp.954-959, (2000). &lt;10.1093/biomet/87.4.954&gt;` 
 
    .. [2] :doi:`G.E.P. Box and D.R. Cox, &quot;An Analysis of Transformations&quot;, 
           Journal of the Royal Statistical Society B, 26, 211-252 (1964). 
           &lt;10.1111/j.2517-6161.1964.tb00553.x&gt;` 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from sklearn.preprocessing import PowerTransformer 
    &gt;&gt;&gt; pt = PowerTransformer() 
    &gt;&gt;&gt; data = [[1, 2], [3, 2], [4, 5]] 
    &gt;&gt;&gt; print(pt.fit(data)) 
    PowerTransformer() 
    &gt;&gt;&gt; print(pt.lambdas_) 
    [ 1.386... -3.100...] 
    &gt;&gt;&gt; print(pt.transform(data)) 
    [[-1.316... -0.707...] 
     [ 0.209... -0.707...] 
     [ 1.106...  1.414...]] 
    &quot;&quot;&quot;</span>

    <span class="s1">_parameter_constraints</span><span class="s3">: </span><span class="s1">dict </span><span class="s3">= {</span>
        <span class="s5">&quot;method&quot;</span><span class="s3">: [</span><span class="s1">StrOptions</span><span class="s3">({</span><span class="s5">&quot;yeo-johnson&quot;</span><span class="s3">, </span><span class="s5">&quot;box-cox&quot;</span><span class="s3">})],</span>
        <span class="s5">&quot;standardize&quot;</span><span class="s3">: [</span><span class="s5">&quot;boolean&quot;</span><span class="s3">],</span>
        <span class="s5">&quot;copy&quot;</span><span class="s3">: [</span><span class="s5">&quot;boolean&quot;</span><span class="s3">],</span>
    <span class="s3">}</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">method</span><span class="s3">=</span><span class="s5">&quot;yeo-johnson&quot;</span><span class="s3">, *, </span><span class="s1">standardize</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">method </span><span class="s3">= </span><span class="s1">method</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">standardize </span><span class="s3">= </span><span class="s1">standardize</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">copy </span><span class="s3">= </span><span class="s1">copy</span>

    <span class="s3">@</span><span class="s1">_fit_context</span><span class="s3">(</span><span class="s1">prefer_skip_nested_validation</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
    <span class="s2">def </span><span class="s1">fit</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot;Estimate the optimal parameter lambda for each feature. 
 
        The optimal lambda parameter for minimizing skewness is estimated on 
        each feature independently using maximum likelihood. 
 
        Parameters 
        ---------- 
        X : array-like of shape (n_samples, n_features) 
            The data used to estimate the optimal transformation parameters. 
 
        y : None 
            Ignored. 
 
        Returns 
        ------- 
        self : object 
            Fitted transformer. 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">=</span><span class="s1">y</span><span class="s3">, </span><span class="s1">force_transform</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s3">@</span><span class="s1">_fit_context</span><span class="s3">(</span><span class="s1">prefer_skip_nested_validation</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
    <span class="s2">def </span><span class="s1">fit_transform</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot;Fit `PowerTransformer` to `X`, then transform `X`. 
 
        Parameters 
        ---------- 
        X : array-like of shape (n_samples, n_features) 
            The data used to estimate the optimal transformation parameters 
            and to be transformed using a power transformation. 
 
        y : Ignored 
            Not used, present for API consistency by convention. 
 
        Returns 
        ------- 
        X_new : ndarray of shape (n_samples, n_features) 
            Transformed data. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">force_transform</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_fit</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">force_transform</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
        <span class="s1">X </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_check_input</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">in_fit</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">check_positive</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

        <span class="s2">if not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">copy </span><span class="s2">and not </span><span class="s1">force_transform</span><span class="s3">:  </span><span class="s0"># if call from fit()</span>
            <span class="s1">X </span><span class="s3">= </span><span class="s1">X</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()  </span><span class="s0"># force copy so that fit does not change X inplace</span>

        <span class="s1">n_samples </span><span class="s3">= </span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]</span>
        <span class="s1">mean </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">mean</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s4">0</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">)</span>
        <span class="s1">var </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">var</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s4">0</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">)</span>

        <span class="s1">optim_function </span><span class="s3">= {</span>
            <span class="s5">&quot;box-cox&quot;</span><span class="s3">: </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_box_cox_optimize</span><span class="s3">,</span>
            <span class="s5">&quot;yeo-johnson&quot;</span><span class="s3">: </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_yeo_johnson_optimize</span><span class="s3">,</span>
        <span class="s3">}[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">method</span><span class="s3">]</span>

        <span class="s1">transform_function </span><span class="s3">= {</span>
            <span class="s5">&quot;box-cox&quot;</span><span class="s3">: </span><span class="s1">boxcox</span><span class="s3">,</span>
            <span class="s5">&quot;yeo-johnson&quot;</span><span class="s3">: </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_yeo_johnson_transform</span><span class="s3">,</span>
        <span class="s3">}[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">method</span><span class="s3">]</span>

        <span class="s2">with </span><span class="s1">np</span><span class="s3">.</span><span class="s1">errstate</span><span class="s3">(</span><span class="s1">invalid</span><span class="s3">=</span><span class="s5">&quot;ignore&quot;</span><span class="s3">):  </span><span class="s0"># hide NaN warnings</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">lambdas_ </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s4">1</span><span class="s3">], </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">X</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">col </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">X</span><span class="s3">.</span><span class="s1">T</span><span class="s3">):</span>
                <span class="s0"># For yeo-johnson, leave constant features unchanged</span>
                <span class="s0"># lambda=1 corresponds to the identity transformation</span>
                <span class="s1">is_constant_feature </span><span class="s3">= </span><span class="s1">_is_constant_feature</span><span class="s3">(</span><span class="s1">var</span><span class="s3">[</span><span class="s1">i</span><span class="s3">], </span><span class="s1">mean</span><span class="s3">[</span><span class="s1">i</span><span class="s3">], </span><span class="s1">n_samples</span><span class="s3">)</span>
                <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">method </span><span class="s3">== </span><span class="s5">&quot;yeo-johnson&quot; </span><span class="s2">and </span><span class="s1">is_constant_feature</span><span class="s3">:</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">lambdas_</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s4">1.0</span>
                    <span class="s2">continue</span>

                <span class="s1">self</span><span class="s3">.</span><span class="s1">lambdas_</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">optim_function</span><span class="s3">(</span><span class="s1">col</span><span class="s3">)</span>

                <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">standardize </span><span class="s2">or </span><span class="s1">force_transform</span><span class="s3">:</span>
                    <span class="s1">X</span><span class="s3">[:, </span><span class="s1">i</span><span class="s3">] = </span><span class="s1">transform_function</span><span class="s3">(</span><span class="s1">X</span><span class="s3">[:, </span><span class="s1">i</span><span class="s3">], </span><span class="s1">self</span><span class="s3">.</span><span class="s1">lambdas_</span><span class="s3">[</span><span class="s1">i</span><span class="s3">])</span>

        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">standardize</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_scaler </span><span class="s3">= </span><span class="s1">StandardScaler</span><span class="s3">(</span><span class="s1">copy</span><span class="s3">=</span><span class="s2">False</span><span class="s3">).</span><span class="s1">set_output</span><span class="s3">(</span><span class="s1">transform</span><span class="s3">=</span><span class="s5">&quot;default&quot;</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">force_transform</span><span class="s3">:</span>
                <span class="s1">X </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_scaler</span><span class="s3">.</span><span class="s1">fit_transform</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">_scaler</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">X</span>

    <span class="s2">def </span><span class="s1">transform</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot;Apply the power transform to each feature using the fitted lambdas. 
 
        Parameters 
        ---------- 
        X : array-like of shape (n_samples, n_features) 
            The data to be transformed using a power transformation. 
 
        Returns 
        ------- 
        X_trans : ndarray of shape (n_samples, n_features) 
            The transformed data. 
        &quot;&quot;&quot;</span>
        <span class="s1">check_is_fitted</span><span class="s3">(</span><span class="s1">self</span><span class="s3">)</span>
        <span class="s1">X </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_check_input</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">in_fit</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">check_positive</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">check_shape</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

        <span class="s1">transform_function </span><span class="s3">= {</span>
            <span class="s5">&quot;box-cox&quot;</span><span class="s3">: </span><span class="s1">boxcox</span><span class="s3">,</span>
            <span class="s5">&quot;yeo-johnson&quot;</span><span class="s3">: </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_yeo_johnson_transform</span><span class="s3">,</span>
        <span class="s3">}[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">method</span><span class="s3">]</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">lmbda </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">lambdas_</span><span class="s3">):</span>
            <span class="s2">with </span><span class="s1">np</span><span class="s3">.</span><span class="s1">errstate</span><span class="s3">(</span><span class="s1">invalid</span><span class="s3">=</span><span class="s5">&quot;ignore&quot;</span><span class="s3">):  </span><span class="s0"># hide NaN warnings</span>
                <span class="s1">X</span><span class="s3">[:, </span><span class="s1">i</span><span class="s3">] = </span><span class="s1">transform_function</span><span class="s3">(</span><span class="s1">X</span><span class="s3">[:, </span><span class="s1">i</span><span class="s3">], </span><span class="s1">lmbda</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">standardize</span><span class="s3">:</span>
            <span class="s1">X </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_scaler</span><span class="s3">.</span><span class="s1">transform</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">X</span>

    <span class="s2">def </span><span class="s1">inverse_transform</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot;Apply the inverse power transformation using the fitted lambdas. 
 
        The inverse of the Box-Cox transformation is given by:: 
 
            if lambda_ == 0: 
                X = exp(X_trans) 
            else: 
                X = (X_trans * lambda_ + 1) ** (1 / lambda_) 
 
        The inverse of the Yeo-Johnson transformation is given by:: 
 
            if X &gt;= 0 and lambda_ == 0: 
                X = exp(X_trans) - 1 
            elif X &gt;= 0 and lambda_ != 0: 
                X = (X_trans * lambda_ + 1) ** (1 / lambda_) - 1 
            elif X &lt; 0 and lambda_ != 2: 
                X = 1 - (-(2 - lambda_) * X_trans + 1) ** (1 / (2 - lambda_)) 
            elif X &lt; 0 and lambda_ == 2: 
                X = 1 - exp(-X_trans) 
 
        Parameters 
        ---------- 
        X : array-like of shape (n_samples, n_features) 
            The transformed data. 
 
        Returns 
        ------- 
        X : ndarray of shape (n_samples, n_features) 
            The original data. 
        &quot;&quot;&quot;</span>
        <span class="s1">check_is_fitted</span><span class="s3">(</span><span class="s1">self</span><span class="s3">)</span>
        <span class="s1">X </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_check_input</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">in_fit</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">check_shape</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">standardize</span><span class="s3">:</span>
            <span class="s1">X </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_scaler</span><span class="s3">.</span><span class="s1">inverse_transform</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>

        <span class="s1">inv_fun </span><span class="s3">= {</span>
            <span class="s5">&quot;box-cox&quot;</span><span class="s3">: </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_box_cox_inverse_tranform</span><span class="s3">,</span>
            <span class="s5">&quot;yeo-johnson&quot;</span><span class="s3">: </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_yeo_johnson_inverse_transform</span><span class="s3">,</span>
        <span class="s3">}[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">method</span><span class="s3">]</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">lmbda </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">lambdas_</span><span class="s3">):</span>
            <span class="s2">with </span><span class="s1">np</span><span class="s3">.</span><span class="s1">errstate</span><span class="s3">(</span><span class="s1">invalid</span><span class="s3">=</span><span class="s5">&quot;ignore&quot;</span><span class="s3">):  </span><span class="s0"># hide NaN warnings</span>
                <span class="s1">X</span><span class="s3">[:, </span><span class="s1">i</span><span class="s3">] = </span><span class="s1">inv_fun</span><span class="s3">(</span><span class="s1">X</span><span class="s3">[:, </span><span class="s1">i</span><span class="s3">], </span><span class="s1">lmbda</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">X</span>

    <span class="s2">def </span><span class="s1">_box_cox_inverse_tranform</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">lmbda</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot;Return inverse-transformed input x following Box-Cox inverse 
        transform with parameter lambda. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">lmbda </span><span class="s3">== </span><span class="s4">0</span><span class="s3">:</span>
            <span class="s1">x_inv </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">exp</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">x_inv </span><span class="s3">= (</span><span class="s1">x </span><span class="s3">* </span><span class="s1">lmbda </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">) ** (</span><span class="s4">1 </span><span class="s3">/ </span><span class="s1">lmbda</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">x_inv</span>

    <span class="s2">def </span><span class="s1">_yeo_johnson_inverse_transform</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">lmbda</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot;Return inverse-transformed input x following Yeo-Johnson inverse 
        transform with parameter lambda. 
        &quot;&quot;&quot;</span>
        <span class="s1">x_inv </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros_like</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
        <span class="s1">pos </span><span class="s3">= </span><span class="s1">x </span><span class="s3">&gt;= </span><span class="s4">0</span>

        <span class="s0"># when x &gt;= 0</span>
        <span class="s2">if </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">lmbda</span><span class="s3">) &lt; </span><span class="s1">np</span><span class="s3">.</span><span class="s1">spacing</span><span class="s3">(</span><span class="s4">1.0</span><span class="s3">):</span>
            <span class="s1">x_inv</span><span class="s3">[</span><span class="s1">pos</span><span class="s3">] = </span><span class="s1">np</span><span class="s3">.</span><span class="s1">exp</span><span class="s3">(</span><span class="s1">x</span><span class="s3">[</span><span class="s1">pos</span><span class="s3">]) - </span><span class="s4">1</span>
        <span class="s2">else</span><span class="s3">:  </span><span class="s0"># lmbda != 0</span>
            <span class="s1">x_inv</span><span class="s3">[</span><span class="s1">pos</span><span class="s3">] = </span><span class="s1">np</span><span class="s3">.</span><span class="s1">power</span><span class="s3">(</span><span class="s1">x</span><span class="s3">[</span><span class="s1">pos</span><span class="s3">] * </span><span class="s1">lmbda </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">, </span><span class="s4">1 </span><span class="s3">/ </span><span class="s1">lmbda</span><span class="s3">) - </span><span class="s4">1</span>

        <span class="s0"># when x &lt; 0</span>
        <span class="s2">if </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">lmbda </span><span class="s3">- </span><span class="s4">2</span><span class="s3">) &gt; </span><span class="s1">np</span><span class="s3">.</span><span class="s1">spacing</span><span class="s3">(</span><span class="s4">1.0</span><span class="s3">):</span>
            <span class="s1">x_inv</span><span class="s3">[~</span><span class="s1">pos</span><span class="s3">] = </span><span class="s4">1 </span><span class="s3">- </span><span class="s1">np</span><span class="s3">.</span><span class="s1">power</span><span class="s3">(-(</span><span class="s4">2 </span><span class="s3">- </span><span class="s1">lmbda</span><span class="s3">) * </span><span class="s1">x</span><span class="s3">[~</span><span class="s1">pos</span><span class="s3">] + </span><span class="s4">1</span><span class="s3">, </span><span class="s4">1 </span><span class="s3">/ (</span><span class="s4">2 </span><span class="s3">- </span><span class="s1">lmbda</span><span class="s3">))</span>
        <span class="s2">else</span><span class="s3">:  </span><span class="s0"># lmbda == 2</span>
            <span class="s1">x_inv</span><span class="s3">[~</span><span class="s1">pos</span><span class="s3">] = </span><span class="s4">1 </span><span class="s3">- </span><span class="s1">np</span><span class="s3">.</span><span class="s1">exp</span><span class="s3">(-</span><span class="s1">x</span><span class="s3">[~</span><span class="s1">pos</span><span class="s3">])</span>

        <span class="s2">return </span><span class="s1">x_inv</span>

    <span class="s2">def </span><span class="s1">_yeo_johnson_transform</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">lmbda</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot;Return transformed input x following Yeo-Johnson transform with 
        parameter lambda. 
        &quot;&quot;&quot;</span>

        <span class="s1">out </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros_like</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
        <span class="s1">pos </span><span class="s3">= </span><span class="s1">x </span><span class="s3">&gt;= </span><span class="s4">0  </span><span class="s0"># binary mask</span>

        <span class="s0"># when x &gt;= 0</span>
        <span class="s2">if </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">lmbda</span><span class="s3">) &lt; </span><span class="s1">np</span><span class="s3">.</span><span class="s1">spacing</span><span class="s3">(</span><span class="s4">1.0</span><span class="s3">):</span>
            <span class="s1">out</span><span class="s3">[</span><span class="s1">pos</span><span class="s3">] = </span><span class="s1">np</span><span class="s3">.</span><span class="s1">log1p</span><span class="s3">(</span><span class="s1">x</span><span class="s3">[</span><span class="s1">pos</span><span class="s3">])</span>
        <span class="s2">else</span><span class="s3">:  </span><span class="s0"># lmbda != 0</span>
            <span class="s1">out</span><span class="s3">[</span><span class="s1">pos</span><span class="s3">] = (</span><span class="s1">np</span><span class="s3">.</span><span class="s1">power</span><span class="s3">(</span><span class="s1">x</span><span class="s3">[</span><span class="s1">pos</span><span class="s3">] + </span><span class="s4">1</span><span class="s3">, </span><span class="s1">lmbda</span><span class="s3">) - </span><span class="s4">1</span><span class="s3">) / </span><span class="s1">lmbda</span>

        <span class="s0"># when x &lt; 0</span>
        <span class="s2">if </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">lmbda </span><span class="s3">- </span><span class="s4">2</span><span class="s3">) &gt; </span><span class="s1">np</span><span class="s3">.</span><span class="s1">spacing</span><span class="s3">(</span><span class="s4">1.0</span><span class="s3">):</span>
            <span class="s1">out</span><span class="s3">[~</span><span class="s1">pos</span><span class="s3">] = -(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">power</span><span class="s3">(-</span><span class="s1">x</span><span class="s3">[~</span><span class="s1">pos</span><span class="s3">] + </span><span class="s4">1</span><span class="s3">, </span><span class="s4">2 </span><span class="s3">- </span><span class="s1">lmbda</span><span class="s3">) - </span><span class="s4">1</span><span class="s3">) / (</span><span class="s4">2 </span><span class="s3">- </span><span class="s1">lmbda</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:  </span><span class="s0"># lmbda == 2</span>
            <span class="s1">out</span><span class="s3">[~</span><span class="s1">pos</span><span class="s3">] = -</span><span class="s1">np</span><span class="s3">.</span><span class="s1">log1p</span><span class="s3">(-</span><span class="s1">x</span><span class="s3">[~</span><span class="s1">pos</span><span class="s3">])</span>

        <span class="s2">return </span><span class="s1">out</span>

    <span class="s2">def </span><span class="s1">_box_cox_optimize</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot;Find and return optimal lambda parameter of the Box-Cox transform by 
        MLE, for observed data x. 
 
        We here use scipy builtins which uses the brent optimizer. 
        &quot;&quot;&quot;</span>
        <span class="s1">mask </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isnan</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">all</span><span class="s3">(</span><span class="s1">mask</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s5">&quot;Column must not be all nan.&quot;</span><span class="s3">)</span>

        <span class="s0"># the computation of lambda is influenced by NaNs so we need to</span>
        <span class="s0"># get rid of them</span>
        <span class="s1">_</span><span class="s3">, </span><span class="s1">lmbda </span><span class="s3">= </span><span class="s1">stats</span><span class="s3">.</span><span class="s1">boxcox</span><span class="s3">(</span><span class="s1">x</span><span class="s3">[~</span><span class="s1">mask</span><span class="s3">], </span><span class="s1">lmbda</span><span class="s3">=</span><span class="s2">None</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">lmbda</span>

    <span class="s2">def </span><span class="s1">_yeo_johnson_optimize</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot;Find and return optimal lambda parameter of the Yeo-Johnson 
        transform by MLE, for observed data x. 
 
        Like for Box-Cox, MLE is done via the brent optimizer. 
        &quot;&quot;&quot;</span>
        <span class="s1">x_tiny </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">finfo</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">).</span><span class="s1">tiny</span>

        <span class="s2">def </span><span class="s1">_neg_log_likelihood</span><span class="s3">(</span><span class="s1">lmbda</span><span class="s3">):</span>
            <span class="s6">&quot;&quot;&quot;Return the negative log likelihood of the observed data x as a 
            function of lambda.&quot;&quot;&quot;</span>
            <span class="s1">x_trans </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_yeo_johnson_transform</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">lmbda</span><span class="s3">)</span>
            <span class="s1">n_samples </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]</span>
            <span class="s1">x_trans_var </span><span class="s3">= </span><span class="s1">x_trans</span><span class="s3">.</span><span class="s1">var</span><span class="s3">()</span>

            <span class="s0"># Reject transformed data that would raise a RuntimeWarning in np.log</span>
            <span class="s2">if </span><span class="s1">x_trans_var </span><span class="s3">&lt; </span><span class="s1">x_tiny</span><span class="s3">:</span>
                <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">inf</span>

            <span class="s1">log_var </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">log</span><span class="s3">(</span><span class="s1">x_trans_var</span><span class="s3">)</span>
            <span class="s1">loglike </span><span class="s3">= -</span><span class="s1">n_samples </span><span class="s3">/ </span><span class="s4">2 </span><span class="s3">* </span><span class="s1">log_var</span>
            <span class="s1">loglike </span><span class="s3">+= (</span><span class="s1">lmbda </span><span class="s3">- </span><span class="s4">1</span><span class="s3">) * (</span><span class="s1">np</span><span class="s3">.</span><span class="s1">sign</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) * </span><span class="s1">np</span><span class="s3">.</span><span class="s1">log1p</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">x</span><span class="s3">))).</span><span class="s1">sum</span><span class="s3">()</span>

            <span class="s2">return </span><span class="s3">-</span><span class="s1">loglike</span>

        <span class="s0"># the computation of lambda is influenced by NaNs so we need to</span>
        <span class="s0"># get rid of them</span>
        <span class="s1">x </span><span class="s3">= </span><span class="s1">x</span><span class="s3">[~</span><span class="s1">np</span><span class="s3">.</span><span class="s1">isnan</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)]</span>
        <span class="s0"># choosing bracket -2, 2 like for boxcox</span>
        <span class="s2">return </span><span class="s1">optimize</span><span class="s3">.</span><span class="s1">brent</span><span class="s3">(</span><span class="s1">_neg_log_likelihood</span><span class="s3">, </span><span class="s1">brack</span><span class="s3">=(-</span><span class="s4">2</span><span class="s3">, </span><span class="s4">2</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">_check_input</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">in_fit</span><span class="s3">, </span><span class="s1">check_positive</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">check_shape</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot;Validate the input before fit and transform. 
 
        Parameters 
        ---------- 
        X : array-like of shape (n_samples, n_features) 
 
        in_fit : bool 
            Whether or not `_check_input` is called from `fit` or other 
            methods, e.g. `predict`, `transform`, etc. 
 
        check_positive : bool, default=False 
            If True, check that all data is positive and non-zero (only if 
            ``self.method=='box-cox'``). 
 
        check_shape : bool, default=False 
            If True, check that n_features matches the length of self.lambdas_ 
        &quot;&quot;&quot;</span>
        <span class="s1">X </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_validate_data</span><span class="s3">(</span>
            <span class="s1">X</span><span class="s3">,</span>
            <span class="s1">ensure_2d</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
            <span class="s1">dtype</span><span class="s3">=</span><span class="s1">FLOAT_DTYPES</span><span class="s3">,</span>
            <span class="s1">force_writeable</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
            <span class="s1">copy</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">,</span>
            <span class="s1">force_all_finite</span><span class="s3">=</span><span class="s5">&quot;allow-nan&quot;</span><span class="s3">,</span>
            <span class="s1">reset</span><span class="s3">=</span><span class="s1">in_fit</span><span class="s3">,</span>
        <span class="s3">)</span>

        <span class="s2">with </span><span class="s1">warnings</span><span class="s3">.</span><span class="s1">catch_warnings</span><span class="s3">():</span>
            <span class="s1">warnings</span><span class="s3">.</span><span class="s1">filterwarnings</span><span class="s3">(</span><span class="s5">&quot;ignore&quot;</span><span class="s3">, </span><span class="s5">r&quot;All-NaN (slice|axis) encountered&quot;</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">check_positive </span><span class="s2">and </span><span class="s1">self</span><span class="s3">.</span><span class="s1">method </span><span class="s3">== </span><span class="s5">&quot;box-cox&quot; </span><span class="s2">and </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nanmin</span><span class="s3">(</span><span class="s1">X</span><span class="s3">) &lt;= </span><span class="s4">0</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span>
                    <span class="s5">&quot;The Box-Cox transformation can only be &quot;</span>
                    <span class="s5">&quot;applied to strictly positive data&quot;</span>
                <span class="s3">)</span>

        <span class="s2">if </span><span class="s1">check_shape </span><span class="s2">and not </span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s4">1</span><span class="s3">] == </span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">lambdas_</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span>
                <span class="s5">&quot;Input data has a different number of features &quot;</span>
                <span class="s5">&quot;than fitting data. Should have {n}, data has {m}&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span>
                    <span class="s1">n</span><span class="s3">=</span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">lambdas_</span><span class="s3">), </span><span class="s1">m</span><span class="s3">=</span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s4">1</span><span class="s3">]</span>
                <span class="s3">)</span>
            <span class="s3">)</span>

        <span class="s2">return </span><span class="s1">X</span>

    <span class="s2">def </span><span class="s1">_more_tags</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s3">{</span><span class="s5">&quot;allow_nan&quot;</span><span class="s3">: </span><span class="s2">True</span><span class="s3">}</span>


<span class="s3">@</span><span class="s1">validate_params</span><span class="s3">(</span>
    <span class="s3">{</span><span class="s5">&quot;X&quot;</span><span class="s3">: [</span><span class="s5">&quot;array-like&quot;</span><span class="s3">]},</span>
    <span class="s1">prefer_skip_nested_validation</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
<span class="s3">)</span>
<span class="s2">def </span><span class="s1">power_transform</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">method</span><span class="s3">=</span><span class="s5">&quot;yeo-johnson&quot;</span><span class="s3">, *, </span><span class="s1">standardize</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Parametric, monotonic transformation to make data more Gaussian-like. 
 
    Power transforms are a family of parametric, monotonic transformations 
    that are applied to make data more Gaussian-like. This is useful for 
    modeling issues related to heteroscedasticity (non-constant variance), 
    or other situations where normality is desired. 
 
    Currently, power_transform supports the Box-Cox transform and the 
    Yeo-Johnson transform. The optimal parameter for stabilizing variance and 
    minimizing skewness is estimated through maximum likelihood. 
 
    Box-Cox requires input data to be strictly positive, while Yeo-Johnson 
    supports both positive or negative data. 
 
    By default, zero-mean, unit-variance normalization is applied to the 
    transformed data. 
 
    Read more in the :ref:`User Guide &lt;preprocessing_transformer&gt;`. 
 
    Parameters 
    ---------- 
    X : array-like of shape (n_samples, n_features) 
        The data to be transformed using a power transformation. 
 
    method : {'yeo-johnson', 'box-cox'}, default='yeo-johnson' 
        The power transform method. Available methods are: 
 
        - 'yeo-johnson' [1]_, works with positive and negative values 
        - 'box-cox' [2]_, only works with strictly positive values 
 
        .. versionchanged:: 0.23 
            The default value of the `method` parameter changed from 
            'box-cox' to 'yeo-johnson' in 0.23. 
 
    standardize : bool, default=True 
        Set to True to apply zero-mean, unit-variance normalization to the 
        transformed output. 
 
    copy : bool, default=True 
        If False, try to avoid a copy and transform in place. 
        This is not guaranteed to always work in place; e.g. if the data is 
        a numpy array with an int dtype, a copy will be returned even with 
        copy=False. 
 
    Returns 
    ------- 
    X_trans : ndarray of shape (n_samples, n_features) 
        The transformed data. 
 
    See Also 
    -------- 
    PowerTransformer : Equivalent transformation with the 
        Transformer API (e.g. as part of a preprocessing 
        :class:`~sklearn.pipeline.Pipeline`). 
 
    quantile_transform : Maps data to a standard normal distribution with 
        the parameter `output_distribution='normal'`. 
 
    Notes 
    ----- 
    NaNs are treated as missing values: disregarded in ``fit``, and maintained 
    in ``transform``. 
 
    For a comparison of the different scalers, transformers, and normalizers, 
    see: :ref:`sphx_glr_auto_examples_preprocessing_plot_all_scaling.py`. 
 
    References 
    ---------- 
 
    .. [1] I.K. Yeo and R.A. Johnson, &quot;A new family of power transformations to 
           improve normality or symmetry.&quot; Biometrika, 87(4), pp.954-959, 
           (2000). 
 
    .. [2] G.E.P. Box and D.R. Cox, &quot;An Analysis of Transformations&quot;, Journal 
           of the Royal Statistical Society B, 26, 211-252 (1964). 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from sklearn.preprocessing import power_transform 
    &gt;&gt;&gt; data = [[1, 2], [3, 2], [4, 5]] 
    &gt;&gt;&gt; print(power_transform(data, method='box-cox')) 
    [[-1.332... -0.707...] 
     [ 0.256... -0.707...] 
     [ 1.076...  1.414...]] 
 
    .. warning:: Risk of data leak. 
        Do not use :func:`~sklearn.preprocessing.power_transform` unless you 
        know what you are doing. A common mistake is to apply it to the entire 
        data *before* splitting into training and test sets. This will bias the 
        model evaluation because information would have leaked from the test 
        set to the training set. 
        In general, we recommend using 
        :class:`~sklearn.preprocessing.PowerTransformer` within a 
        :ref:`Pipeline &lt;pipeline&gt;` in order to prevent most risks of data 
        leaking, e.g.: `pipe = make_pipeline(PowerTransformer(), 
        LogisticRegression())`. 
    &quot;&quot;&quot;</span>
    <span class="s1">pt </span><span class="s3">= </span><span class="s1">PowerTransformer</span><span class="s3">(</span><span class="s1">method</span><span class="s3">=</span><span class="s1">method</span><span class="s3">, </span><span class="s1">standardize</span><span class="s3">=</span><span class="s1">standardize</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s1">copy</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">pt</span><span class="s3">.</span><span class="s1">fit_transform</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
</pre>
</body>
</html>