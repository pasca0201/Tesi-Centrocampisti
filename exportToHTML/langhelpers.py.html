<html>
<head>
<title>langhelpers.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #5f826b; font-style: italic;}
.s3 { color: #cf8e6d;}
.s4 { color: #bcbec4;}
.s5 { color: #6aab73;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
langhelpers.py</font>
</center></td></tr></table>
<pre><span class="s0"># util/langhelpers.py</span>
<span class="s0"># Copyright (C) 2005-2024 the SQLAlchemy authors and contributors</span>
<span class="s0"># &lt;see AUTHORS file&gt;</span>
<span class="s0">#</span>
<span class="s0"># This module is part of SQLAlchemy and is released under</span>
<span class="s0"># the MIT License: https://www.opensource.org/licenses/mit-license.php</span>
<span class="s0"># mypy: allow-untyped-defs, allow-untyped-calls</span>

<span class="s2">&quot;&quot;&quot;Routines to help with the creation, loading and introspection of 
modules, classes, hierarchies, attributes, functions, and methods. 
 
&quot;&quot;&quot;</span>
<span class="s3">from </span><span class="s1">__future__ </span><span class="s3">import </span><span class="s1">annotations</span>

<span class="s3">import </span><span class="s1">collections</span>
<span class="s3">import </span><span class="s1">enum</span>
<span class="s3">from </span><span class="s1">functools </span><span class="s3">import </span><span class="s1">update_wrapper</span>
<span class="s3">import </span><span class="s1">inspect</span>
<span class="s3">import </span><span class="s1">itertools</span>
<span class="s3">import </span><span class="s1">operator</span>
<span class="s3">import </span><span class="s1">re</span>
<span class="s3">import </span><span class="s1">sys</span>
<span class="s3">import </span><span class="s1">textwrap</span>
<span class="s3">import </span><span class="s1">threading</span>
<span class="s3">import </span><span class="s1">types</span>
<span class="s3">from </span><span class="s1">types </span><span class="s3">import </span><span class="s1">CodeType</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Any</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Callable</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">cast</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Dict</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">FrozenSet</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Generic</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Iterator</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">List</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Mapping</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">NoReturn</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Optional</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">overload</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Sequence</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Set</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Tuple</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Type</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">TYPE_CHECKING</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">TypeVar</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Union</span>
<span class="s3">import </span><span class="s1">warnings</span>

<span class="s3">from </span><span class="s4">. </span><span class="s3">import </span><span class="s1">_collections</span>
<span class="s3">from </span><span class="s4">. </span><span class="s3">import </span><span class="s1">compat</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">_has_cy </span><span class="s3">import </span><span class="s1">HAS_CYEXTENSION</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Literal</span>
<span class="s3">from </span><span class="s4">.. </span><span class="s3">import </span><span class="s1">exc</span>

<span class="s1">_T </span><span class="s4">= </span><span class="s1">TypeVar</span><span class="s4">(</span><span class="s5">&quot;_T&quot;</span><span class="s4">)</span>
<span class="s1">_T_co </span><span class="s4">= </span><span class="s1">TypeVar</span><span class="s4">(</span><span class="s5">&quot;_T_co&quot;</span><span class="s4">, </span><span class="s1">covariant</span><span class="s4">=</span><span class="s3">True</span><span class="s4">)</span>
<span class="s1">_F </span><span class="s4">= </span><span class="s1">TypeVar</span><span class="s4">(</span><span class="s5">&quot;_F&quot;</span><span class="s4">, </span><span class="s1">bound</span><span class="s4">=</span><span class="s1">Callable</span><span class="s4">[..., </span><span class="s1">Any</span><span class="s4">])</span>
<span class="s1">_MP </span><span class="s4">= </span><span class="s1">TypeVar</span><span class="s4">(</span><span class="s5">&quot;_MP&quot;</span><span class="s4">, </span><span class="s1">bound</span><span class="s4">=</span><span class="s5">&quot;memoized_property[Any]&quot;</span><span class="s4">)</span>
<span class="s1">_MA </span><span class="s4">= </span><span class="s1">TypeVar</span><span class="s4">(</span><span class="s5">&quot;_MA&quot;</span><span class="s4">, </span><span class="s1">bound</span><span class="s4">=</span><span class="s5">&quot;HasMemoized.memoized_attribute[Any]&quot;</span><span class="s4">)</span>
<span class="s1">_HP </span><span class="s4">= </span><span class="s1">TypeVar</span><span class="s4">(</span><span class="s5">&quot;_HP&quot;</span><span class="s4">, </span><span class="s1">bound</span><span class="s4">=</span><span class="s5">&quot;hybridproperty[Any]&quot;</span><span class="s4">)</span>
<span class="s1">_HM </span><span class="s4">= </span><span class="s1">TypeVar</span><span class="s4">(</span><span class="s5">&quot;_HM&quot;</span><span class="s4">, </span><span class="s1">bound</span><span class="s4">=</span><span class="s5">&quot;hybridmethod[Any]&quot;</span><span class="s4">)</span>


<span class="s3">if </span><span class="s1">compat</span><span class="s4">.</span><span class="s1">py310</span><span class="s4">:</span>

    <span class="s3">def </span><span class="s1">get_annotations</span><span class="s4">(</span><span class="s1">obj</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; Mapping</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">Any</span><span class="s4">]:</span>
        <span class="s3">return </span><span class="s1">inspect</span><span class="s4">.</span><span class="s1">get_annotations</span><span class="s4">(</span><span class="s1">obj</span><span class="s4">)</span>

<span class="s3">else</span><span class="s4">:</span>

    <span class="s3">def </span><span class="s1">get_annotations</span><span class="s4">(</span><span class="s1">obj</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; Mapping</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">Any</span><span class="s4">]:</span>
        <span class="s0"># it's been observed that cls.__annotations__ can be non present.</span>
        <span class="s0"># it's not clear what causes this, running under tox py37/38 it</span>
        <span class="s0"># happens, running straight pytest it doesnt</span>

        <span class="s0"># https://docs.python.org/3/howto/annotations.html#annotations-howto</span>
        <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">obj</span><span class="s4">, </span><span class="s1">type</span><span class="s4">):</span>
            <span class="s1">ann </span><span class="s4">= </span><span class="s1">obj</span><span class="s4">.</span><span class="s1">__dict__</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s5">&quot;__annotations__&quot;</span><span class="s4">, </span><span class="s3">None</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">ann </span><span class="s4">= </span><span class="s1">getattr</span><span class="s4">(</span><span class="s1">obj</span><span class="s4">, </span><span class="s5">&quot;__annotations__&quot;</span><span class="s4">, </span><span class="s3">None</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s1">ann </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">_collections</span><span class="s4">.</span><span class="s1">EMPTY_DICT</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">cast</span><span class="s4">(</span><span class="s5">&quot;Mapping[str, Any]&quot;</span><span class="s4">, </span><span class="s1">ann</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">md5_hex</span><span class="s4">(</span><span class="s1">x</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; str</span><span class="s4">:</span>
    <span class="s1">x </span><span class="s4">= </span><span class="s1">x</span><span class="s4">.</span><span class="s1">encode</span><span class="s4">(</span><span class="s5">&quot;utf-8&quot;</span><span class="s4">)</span>
    <span class="s1">m </span><span class="s4">= </span><span class="s1">compat</span><span class="s4">.</span><span class="s1">md5_not_for_security</span><span class="s4">()</span>
    <span class="s1">m</span><span class="s4">.</span><span class="s1">update</span><span class="s4">(</span><span class="s1">x</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s1">cast</span><span class="s4">(</span><span class="s1">str</span><span class="s4">, </span><span class="s1">m</span><span class="s4">.</span><span class="s1">hexdigest</span><span class="s4">())</span>


<span class="s3">class </span><span class="s1">safe_reraise</span><span class="s4">:</span>
    <span class="s2">&quot;&quot;&quot;Reraise an exception after invoking some 
    handler code. 
 
    Stores the existing exception info before 
    invoking so that it is maintained across a potential 
    coroutine context switch. 
 
    e.g.:: 
 
        try: 
            sess.commit() 
        except: 
            with safe_reraise(): 
                sess.rollback() 
 
    TODO: we should at some point evaluate current behaviors in this regard 
    based on current greenlet, gevent/eventlet implementations in Python 3, and 
    also see the degree to which our own asyncio (based on greenlet also) is 
    impacted by this. .rollback() will cause IO / context switch to occur in 
    all these scenarios; what happens to the exception context from an 
    &quot;except:&quot; block if we don't explicitly store it? Original issue was #2703. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__slots__ </span><span class="s4">= (</span><span class="s5">&quot;_exc_info&quot;</span><span class="s4">,)</span>

    <span class="s1">_exc_info</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span>
        <span class="s3">None</span><span class="s4">,</span>
        <span class="s1">Tuple</span><span class="s4">[</span>
            <span class="s1">Type</span><span class="s4">[</span><span class="s1">BaseException</span><span class="s4">],</span>
            <span class="s1">BaseException</span><span class="s4">,</span>
            <span class="s1">types</span><span class="s4">.</span><span class="s1">TracebackType</span><span class="s4">,</span>
        <span class="s4">],</span>
        <span class="s1">Tuple</span><span class="s4">[</span><span class="s3">None</span><span class="s4">, </span><span class="s3">None</span><span class="s4">, </span><span class="s3">None</span><span class="s4">],</span>
    <span class="s4">]</span>

    <span class="s3">def </span><span class="s1">__enter__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_exc_info </span><span class="s4">= </span><span class="s1">sys</span><span class="s4">.</span><span class="s1">exc_info</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">__exit__</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">type_</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Type</span><span class="s4">[</span><span class="s1">BaseException</span><span class="s4">]],</span>
        <span class="s1">value</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">BaseException</span><span class="s4">],</span>
        <span class="s1">traceback</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">types</span><span class="s4">.</span><span class="s1">TracebackType</span><span class="s4">],</span>
    <span class="s4">) </span><span class="s1">-&gt; NoReturn</span><span class="s4">:</span>
        <span class="s3">assert </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_exc_info </span><span class="s3">is not None</span>
        <span class="s0"># see #2703 for notes</span>
        <span class="s3">if </span><span class="s1">type_ </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s1">exc_type</span><span class="s4">, </span><span class="s1">exc_value</span><span class="s4">, </span><span class="s1">exc_tb </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_exc_info</span>
            <span class="s3">assert </span><span class="s1">exc_value </span><span class="s3">is not None</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_exc_info </span><span class="s4">= </span><span class="s3">None  </span><span class="s0"># remove potential circular references</span>
            <span class="s3">raise </span><span class="s1">exc_value</span><span class="s4">.</span><span class="s1">with_traceback</span><span class="s4">(</span><span class="s1">exc_tb</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_exc_info </span><span class="s4">= </span><span class="s3">None  </span><span class="s0"># remove potential circular references</span>
            <span class="s3">assert </span><span class="s1">value </span><span class="s3">is not None</span>
            <span class="s3">raise </span><span class="s1">value</span><span class="s4">.</span><span class="s1">with_traceback</span><span class="s4">(</span><span class="s1">traceback</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">walk_subclasses</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">: </span><span class="s1">Type</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]) </span><span class="s1">-&gt; Iterator</span><span class="s4">[</span><span class="s1">Type</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]]:</span>
    <span class="s1">seen</span><span class="s4">: </span><span class="s1">Set</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">] = </span><span class="s1">set</span><span class="s4">()</span>

    <span class="s1">stack </span><span class="s4">= [</span><span class="s1">cls</span><span class="s4">]</span>
    <span class="s3">while </span><span class="s1">stack</span><span class="s4">:</span>
        <span class="s1">cls </span><span class="s4">= </span><span class="s1">stack</span><span class="s4">.</span><span class="s1">pop</span><span class="s4">()</span>
        <span class="s3">if </span><span class="s1">cls </span><span class="s3">in </span><span class="s1">seen</span><span class="s4">:</span>
            <span class="s3">continue</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">seen</span><span class="s4">.</span><span class="s1">add</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">)</span>
        <span class="s1">stack</span><span class="s4">.</span><span class="s1">extend</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">.</span><span class="s1">__subclasses__</span><span class="s4">())</span>
        <span class="s3">yield </span><span class="s1">cls</span>


<span class="s3">def </span><span class="s1">string_or_unprintable</span><span class="s4">(</span><span class="s1">element</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; str</span><span class="s4">:</span>
    <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">element</span><span class="s4">, </span><span class="s1">str</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">element</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s3">try</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">str</span><span class="s4">(</span><span class="s1">element</span><span class="s4">)</span>
        <span class="s3">except </span><span class="s1">Exception</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s5">&quot;unprintable element %r&quot; </span><span class="s4">% </span><span class="s1">element</span>


<span class="s3">def </span><span class="s1">clsname_as_plain_name</span><span class="s4">(</span>
    <span class="s1">cls</span><span class="s4">: </span><span class="s1">Type</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">], </span><span class="s1">use_name</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span>
<span class="s4">) </span><span class="s1">-&gt; str</span><span class="s4">:</span>
    <span class="s1">name </span><span class="s4">= </span><span class="s1">use_name </span><span class="s3">or </span><span class="s1">cls</span><span class="s4">.</span><span class="s1">__name__</span>
    <span class="s3">return </span><span class="s5">&quot; &quot;</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span><span class="s1">n</span><span class="s4">.</span><span class="s1">lower</span><span class="s4">() </span><span class="s3">for </span><span class="s1">n </span><span class="s3">in </span><span class="s1">re</span><span class="s4">.</span><span class="s1">findall</span><span class="s4">(</span><span class="s5">r&quot;([A-Z][a-z]+|SQL)&quot;</span><span class="s4">, </span><span class="s1">name</span><span class="s4">))</span>


<span class="s3">def </span><span class="s1">method_is_overridden</span><span class="s4">(</span>
    <span class="s1">instance_or_cls</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span><span class="s1">Type</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">], </span><span class="s1">object</span><span class="s4">],</span>
    <span class="s1">against_method</span><span class="s4">: </span><span class="s1">Callable</span><span class="s4">[..., </span><span class="s1">Any</span><span class="s4">],</span>
<span class="s4">) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
    <span class="s2">&quot;&quot;&quot;Return True if the two class methods don't match.&quot;&quot;&quot;</span>

    <span class="s3">if not </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">instance_or_cls</span><span class="s4">, </span><span class="s1">type</span><span class="s4">):</span>
        <span class="s1">current_cls </span><span class="s4">= </span><span class="s1">instance_or_cls</span><span class="s4">.</span><span class="s1">__class__</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">current_cls </span><span class="s4">= </span><span class="s1">instance_or_cls</span>

    <span class="s1">method_name </span><span class="s4">= </span><span class="s1">against_method</span><span class="s4">.</span><span class="s1">__name__</span>

    <span class="s1">current_method</span><span class="s4">: </span><span class="s1">types</span><span class="s4">.</span><span class="s1">MethodType </span><span class="s4">= </span><span class="s1">getattr</span><span class="s4">(</span><span class="s1">current_cls</span><span class="s4">, </span><span class="s1">method_name</span><span class="s4">)</span>

    <span class="s3">return </span><span class="s1">current_method </span><span class="s4">!= </span><span class="s1">against_method</span>


<span class="s3">def </span><span class="s1">decode_slice</span><span class="s4">(</span><span class="s1">slc</span><span class="s4">: </span><span class="s1">slice</span><span class="s4">) </span><span class="s1">-&gt; Tuple</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">, ...]:</span>
    <span class="s2">&quot;&quot;&quot;decode a slice object as sent to __getitem__. 
 
    takes into account the 2.5 __index__() method, basically. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">ret</span><span class="s4">: </span><span class="s1">List</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">] = []</span>
    <span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">slc</span><span class="s4">.</span><span class="s1">start</span><span class="s4">, </span><span class="s1">slc</span><span class="s4">.</span><span class="s1">stop</span><span class="s4">, </span><span class="s1">slc</span><span class="s4">.</span><span class="s1">step</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">x</span><span class="s4">, </span><span class="s5">&quot;__index__&quot;</span><span class="s4">):</span>
            <span class="s1">x </span><span class="s4">= </span><span class="s1">x</span><span class="s4">.</span><span class="s1">__index__</span><span class="s4">()</span>
        <span class="s1">ret</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">x</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s1">tuple</span><span class="s4">(</span><span class="s1">ret</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">_unique_symbols</span><span class="s4">(</span><span class="s1">used</span><span class="s4">: </span><span class="s1">Sequence</span><span class="s4">[</span><span class="s1">str</span><span class="s4">], *</span><span class="s1">bases</span><span class="s4">: </span><span class="s1">str</span><span class="s4">) </span><span class="s1">-&gt; Iterator</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]:</span>
    <span class="s1">used_set </span><span class="s4">= </span><span class="s1">set</span><span class="s4">(</span><span class="s1">used</span><span class="s4">)</span>
    <span class="s3">for </span><span class="s1">base </span><span class="s3">in </span><span class="s1">bases</span><span class="s4">:</span>
        <span class="s1">pool </span><span class="s4">= </span><span class="s1">itertools</span><span class="s4">.</span><span class="s1">chain</span><span class="s4">(</span>
            <span class="s4">(</span><span class="s1">base</span><span class="s4">,),</span>
            <span class="s1">map</span><span class="s4">(</span><span class="s3">lambda </span><span class="s1">i</span><span class="s4">: </span><span class="s1">base </span><span class="s4">+ </span><span class="s1">str</span><span class="s4">(</span><span class="s1">i</span><span class="s4">), </span><span class="s1">range</span><span class="s4">(</span><span class="s6">1000</span><span class="s4">)),</span>
        <span class="s4">)</span>
        <span class="s3">for </span><span class="s1">sym </span><span class="s3">in </span><span class="s1">pool</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">sym </span><span class="s3">not in </span><span class="s1">used_set</span><span class="s4">:</span>
                <span class="s1">used_set</span><span class="s4">.</span><span class="s1">add</span><span class="s4">(</span><span class="s1">sym</span><span class="s4">)</span>
                <span class="s3">yield </span><span class="s1">sym</span>
                <span class="s3">break</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">NameError</span><span class="s4">(</span><span class="s5">&quot;exhausted namespace for symbol base %s&quot; </span><span class="s4">% </span><span class="s1">base</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">map_bits</span><span class="s4">(</span><span class="s1">fn</span><span class="s4">: </span><span class="s1">Callable</span><span class="s4">[[</span><span class="s1">int</span><span class="s4">], </span><span class="s1">Any</span><span class="s4">], </span><span class="s1">n</span><span class="s4">: </span><span class="s1">int</span><span class="s4">) </span><span class="s1">-&gt; Iterator</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]:</span>
    <span class="s2">&quot;&quot;&quot;Call the given function given each nonzero bit from n.&quot;&quot;&quot;</span>

    <span class="s3">while </span><span class="s1">n</span><span class="s4">:</span>
        <span class="s1">b </span><span class="s4">= </span><span class="s1">n </span><span class="s4">&amp; (~</span><span class="s1">n </span><span class="s4">+ </span><span class="s6">1</span><span class="s4">)</span>
        <span class="s3">yield </span><span class="s1">fn</span><span class="s4">(</span><span class="s1">b</span><span class="s4">)</span>
        <span class="s1">n </span><span class="s4">^= </span><span class="s1">b</span>


<span class="s1">_Fn </span><span class="s4">= </span><span class="s1">TypeVar</span><span class="s4">(</span><span class="s5">&quot;_Fn&quot;</span><span class="s4">, </span><span class="s1">bound</span><span class="s4">=</span><span class="s5">&quot;Callable[..., Any]&quot;</span><span class="s4">)</span>

<span class="s0"># this seems to be in flux in recent mypy versions</span>


<span class="s3">def </span><span class="s1">decorator</span><span class="s4">(</span><span class="s1">target</span><span class="s4">: </span><span class="s1">Callable</span><span class="s4">[..., </span><span class="s1">Any</span><span class="s4">]) </span><span class="s1">-&gt; Callable</span><span class="s4">[[</span><span class="s1">_Fn</span><span class="s4">], </span><span class="s1">_Fn</span><span class="s4">]:</span>
    <span class="s2">&quot;&quot;&quot;A signature-matching decorator factory.&quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">decorate</span><span class="s4">(</span><span class="s1">fn</span><span class="s4">: </span><span class="s1">_Fn</span><span class="s4">) </span><span class="s1">-&gt; _Fn</span><span class="s4">:</span>
        <span class="s3">if not </span><span class="s1">inspect</span><span class="s4">.</span><span class="s1">isfunction</span><span class="s4">(</span><span class="s1">fn</span><span class="s4">) </span><span class="s3">and not </span><span class="s1">inspect</span><span class="s4">.</span><span class="s1">ismethod</span><span class="s4">(</span><span class="s1">fn</span><span class="s4">):</span>
            <span class="s3">raise </span><span class="s1">Exception</span><span class="s4">(</span><span class="s5">&quot;not a decoratable function&quot;</span><span class="s4">)</span>

        <span class="s1">spec </span><span class="s4">= </span><span class="s1">compat</span><span class="s4">.</span><span class="s1">inspect_getfullargspec</span><span class="s4">(</span><span class="s1">fn</span><span class="s4">)</span>
        <span class="s1">env</span><span class="s4">: </span><span class="s1">Dict</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">Any</span><span class="s4">] = {}</span>

        <span class="s1">spec </span><span class="s4">= </span><span class="s1">_update_argspec_defaults_into_env</span><span class="s4">(</span><span class="s1">spec</span><span class="s4">, </span><span class="s1">env</span><span class="s4">)</span>

        <span class="s1">names </span><span class="s4">= (</span>
            <span class="s1">tuple</span><span class="s4">(</span><span class="s1">cast</span><span class="s4">(</span><span class="s5">&quot;Tuple[str, ...]&quot;</span><span class="s4">, </span><span class="s1">spec</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]))</span>
            <span class="s4">+ </span><span class="s1">cast</span><span class="s4">(</span><span class="s5">&quot;Tuple[str, ...]&quot;</span><span class="s4">, </span><span class="s1">spec</span><span class="s4">[</span><span class="s6">1</span><span class="s4">:</span><span class="s6">3</span><span class="s4">])</span>
            <span class="s4">+ (</span><span class="s1">fn</span><span class="s4">.</span><span class="s1">__name__</span><span class="s4">,)</span>
        <span class="s4">)</span>
        <span class="s1">targ_name</span><span class="s4">, </span><span class="s1">fn_name </span><span class="s4">= </span><span class="s1">_unique_symbols</span><span class="s4">(</span><span class="s1">names</span><span class="s4">, </span><span class="s5">&quot;target&quot;</span><span class="s4">, </span><span class="s5">&quot;fn&quot;</span><span class="s4">)</span>

        <span class="s1">metadata</span><span class="s4">: </span><span class="s1">Dict</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]] = </span><span class="s1">dict</span><span class="s4">(</span><span class="s1">target</span><span class="s4">=</span><span class="s1">targ_name</span><span class="s4">, </span><span class="s1">fn</span><span class="s4">=</span><span class="s1">fn_name</span><span class="s4">)</span>
        <span class="s1">metadata</span><span class="s4">.</span><span class="s1">update</span><span class="s4">(</span><span class="s1">format_argspec_plus</span><span class="s4">(</span><span class="s1">spec</span><span class="s4">, </span><span class="s1">grouped</span><span class="s4">=</span><span class="s3">False</span><span class="s4">))</span>
        <span class="s1">metadata</span><span class="s4">[</span><span class="s5">&quot;name&quot;</span><span class="s4">] = </span><span class="s1">fn</span><span class="s4">.</span><span class="s1">__name__</span>

        <span class="s3">if </span><span class="s1">inspect</span><span class="s4">.</span><span class="s1">iscoroutinefunction</span><span class="s4">(</span><span class="s1">fn</span><span class="s4">):</span>
            <span class="s1">metadata</span><span class="s4">[</span><span class="s5">&quot;prefix&quot;</span><span class="s4">] = </span><span class="s5">&quot;async &quot;</span>
            <span class="s1">metadata</span><span class="s4">[</span><span class="s5">&quot;target_prefix&quot;</span><span class="s4">] = </span><span class="s5">&quot;await &quot;</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">metadata</span><span class="s4">[</span><span class="s5">&quot;prefix&quot;</span><span class="s4">] = </span><span class="s5">&quot;&quot;</span>
            <span class="s1">metadata</span><span class="s4">[</span><span class="s5">&quot;target_prefix&quot;</span><span class="s4">] = </span><span class="s5">&quot;&quot;</span>

        <span class="s0"># look for __ positional arguments.  This is a convention in</span>
        <span class="s0"># SQLAlchemy that arguments should be passed positionally</span>
        <span class="s0"># rather than as keyword</span>
        <span class="s0"># arguments.  note that apply_pos doesn't currently work in all cases</span>
        <span class="s0"># such as when a kw-only indicator &quot;*&quot; is present, which is why</span>
        <span class="s0"># we limit the use of this to just that case we can detect.  As we add</span>
        <span class="s0"># more kinds of methods that use @decorator, things may have to</span>
        <span class="s0"># be further improved in this area</span>
        <span class="s3">if </span><span class="s5">&quot;__&quot; </span><span class="s3">in </span><span class="s1">repr</span><span class="s4">(</span><span class="s1">spec</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]):</span>
            <span class="s1">code </span><span class="s4">= (</span>
                <span class="s5">&quot;&quot;&quot;</span><span class="s3">\ 
</span><span class="s5">%(prefix)sdef %(name)s%(grouped_args)s: 
    return %(target_prefix)s%(target)s(%(fn)s, %(apply_pos)s) 
&quot;&quot;&quot;</span>
                <span class="s4">% </span><span class="s1">metadata</span>
            <span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">code </span><span class="s4">= (</span>
                <span class="s5">&quot;&quot;&quot;</span><span class="s3">\ 
</span><span class="s5">%(prefix)sdef %(name)s%(grouped_args)s: 
    return %(target_prefix)s%(target)s(%(fn)s, %(apply_kw)s) 
&quot;&quot;&quot;</span>
                <span class="s4">% </span><span class="s1">metadata</span>
            <span class="s4">)</span>

        <span class="s1">mod </span><span class="s4">= </span><span class="s1">sys</span><span class="s4">.</span><span class="s1">modules</span><span class="s4">[</span><span class="s1">fn</span><span class="s4">.</span><span class="s1">__module__</span><span class="s4">]</span>
        <span class="s1">env</span><span class="s4">.</span><span class="s1">update</span><span class="s4">(</span><span class="s1">vars</span><span class="s4">(</span><span class="s1">mod</span><span class="s4">))</span>
        <span class="s1">env</span><span class="s4">.</span><span class="s1">update</span><span class="s4">({</span><span class="s1">targ_name</span><span class="s4">: </span><span class="s1">target</span><span class="s4">, </span><span class="s1">fn_name</span><span class="s4">: </span><span class="s1">fn</span><span class="s4">, </span><span class="s5">&quot;__name__&quot;</span><span class="s4">: </span><span class="s1">fn</span><span class="s4">.</span><span class="s1">__module__</span><span class="s4">})</span>

        <span class="s1">decorated </span><span class="s4">= </span><span class="s1">cast</span><span class="s4">(</span>
            <span class="s1">types</span><span class="s4">.</span><span class="s1">FunctionType</span><span class="s4">,</span>
            <span class="s1">_exec_code_in_env</span><span class="s4">(</span><span class="s1">code</span><span class="s4">, </span><span class="s1">env</span><span class="s4">, </span><span class="s1">fn</span><span class="s4">.</span><span class="s1">__name__</span><span class="s4">),</span>
        <span class="s4">)</span>
        <span class="s1">decorated</span><span class="s4">.</span><span class="s1">__defaults__ </span><span class="s4">= </span><span class="s1">getattr</span><span class="s4">(</span><span class="s1">fn</span><span class="s4">, </span><span class="s5">&quot;__func__&quot;</span><span class="s4">, </span><span class="s1">fn</span><span class="s4">).</span><span class="s1">__defaults__</span>

        <span class="s1">decorated</span><span class="s4">.</span><span class="s1">__wrapped__ </span><span class="s4">= </span><span class="s1">fn  </span><span class="s0"># type: ignore[attr-defined]</span>
        <span class="s3">return </span><span class="s1">update_wrapper</span><span class="s4">(</span><span class="s1">decorated</span><span class="s4">, </span><span class="s1">fn</span><span class="s4">)  </span><span class="s0"># type: ignore[return-value]</span>

    <span class="s3">return </span><span class="s1">update_wrapper</span><span class="s4">(</span><span class="s1">decorate</span><span class="s4">, </span><span class="s1">target</span><span class="s4">)  </span><span class="s0"># type: ignore[return-value]</span>


<span class="s3">def </span><span class="s1">_update_argspec_defaults_into_env</span><span class="s4">(</span><span class="s1">spec</span><span class="s4">, </span><span class="s1">env</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;given a FullArgSpec, convert defaults to be symbol names in an env.&quot;&quot;&quot;</span>

    <span class="s3">if </span><span class="s1">spec</span><span class="s4">.</span><span class="s1">defaults</span><span class="s4">:</span>
        <span class="s1">new_defaults </span><span class="s4">= []</span>
        <span class="s1">i </span><span class="s4">= </span><span class="s6">0</span>
        <span class="s3">for </span><span class="s1">arg </span><span class="s3">in </span><span class="s1">spec</span><span class="s4">.</span><span class="s1">defaults</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">type</span><span class="s4">(</span><span class="s1">arg</span><span class="s4">).</span><span class="s1">__module__ </span><span class="s3">not in </span><span class="s4">(</span><span class="s5">&quot;builtins&quot;</span><span class="s4">, </span><span class="s5">&quot;__builtin__&quot;</span><span class="s4">):</span>
                <span class="s1">name </span><span class="s4">= </span><span class="s5">&quot;x%d&quot; </span><span class="s4">% </span><span class="s1">i</span>
                <span class="s1">env</span><span class="s4">[</span><span class="s1">name</span><span class="s4">] = </span><span class="s1">arg</span>
                <span class="s1">new_defaults</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">name</span><span class="s4">)</span>
                <span class="s1">i </span><span class="s4">+= </span><span class="s6">1</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">new_defaults</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">arg</span><span class="s4">)</span>
        <span class="s1">elem </span><span class="s4">= </span><span class="s1">list</span><span class="s4">(</span><span class="s1">spec</span><span class="s4">)</span>
        <span class="s1">elem</span><span class="s4">[</span><span class="s6">3</span><span class="s4">] = </span><span class="s1">tuple</span><span class="s4">(</span><span class="s1">new_defaults</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">compat</span><span class="s4">.</span><span class="s1">FullArgSpec</span><span class="s4">(*</span><span class="s1">elem</span><span class="s4">)</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">spec</span>


<span class="s3">def </span><span class="s1">_exec_code_in_env</span><span class="s4">(</span>
    <span class="s1">code</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">types</span><span class="s4">.</span><span class="s1">CodeType</span><span class="s4">], </span><span class="s1">env</span><span class="s4">: </span><span class="s1">Dict</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">Any</span><span class="s4">], </span><span class="s1">fn_name</span><span class="s4">: </span><span class="s1">str</span>
<span class="s4">) </span><span class="s1">-&gt; Callable</span><span class="s4">[..., </span><span class="s1">Any</span><span class="s4">]:</span>
    <span class="s1">exec</span><span class="s4">(</span><span class="s1">code</span><span class="s4">, </span><span class="s1">env</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s1">env</span><span class="s4">[</span><span class="s1">fn_name</span><span class="s4">]  </span><span class="s0"># type: ignore[no-any-return]</span>


<span class="s1">_PF </span><span class="s4">= </span><span class="s1">TypeVar</span><span class="s4">(</span><span class="s5">&quot;_PF&quot;</span><span class="s4">)</span>
<span class="s1">_TE </span><span class="s4">= </span><span class="s1">TypeVar</span><span class="s4">(</span><span class="s5">&quot;_TE&quot;</span><span class="s4">)</span>


<span class="s3">class </span><span class="s1">PluginLoader</span><span class="s4">:</span>
    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">group</span><span class="s4">: </span><span class="s1">str</span><span class="s4">, </span><span class="s1">auto_fn</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Callable</span><span class="s4">[..., </span><span class="s1">Any</span><span class="s4">]] = </span><span class="s3">None</span>
    <span class="s4">):</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">group </span><span class="s4">= </span><span class="s1">group</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">impls</span><span class="s4">: </span><span class="s1">Dict</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">Any</span><span class="s4">] = {}</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">auto_fn </span><span class="s4">= </span><span class="s1">auto_fn</span>

    <span class="s3">def </span><span class="s1">clear</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">impls</span><span class="s4">.</span><span class="s1">clear</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">load</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">name</span><span class="s4">: </span><span class="s1">str</span><span class="s4">) </span><span class="s1">-&gt; Any</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">name </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">impls</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">impls</span><span class="s4">[</span><span class="s1">name</span><span class="s4">]()</span>

        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">auto_fn</span><span class="s4">:</span>
            <span class="s1">loader </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">auto_fn</span><span class="s4">(</span><span class="s1">name</span><span class="s4">)</span>
            <span class="s3">if </span><span class="s1">loader</span><span class="s4">:</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">impls</span><span class="s4">[</span><span class="s1">name</span><span class="s4">] = </span><span class="s1">loader</span>
                <span class="s3">return </span><span class="s1">loader</span><span class="s4">()</span>

        <span class="s3">for </span><span class="s1">impl </span><span class="s3">in </span><span class="s1">compat</span><span class="s4">.</span><span class="s1">importlib_metadata_get</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">group</span><span class="s4">):</span>
            <span class="s3">if </span><span class="s1">impl</span><span class="s4">.</span><span class="s1">name </span><span class="s4">== </span><span class="s1">name</span><span class="s4">:</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">impls</span><span class="s4">[</span><span class="s1">name</span><span class="s4">] = </span><span class="s1">impl</span><span class="s4">.</span><span class="s1">load</span>
                <span class="s3">return </span><span class="s1">impl</span><span class="s4">.</span><span class="s1">load</span><span class="s4">()</span>

        <span class="s3">raise </span><span class="s1">exc</span><span class="s4">.</span><span class="s1">NoSuchModuleError</span><span class="s4">(</span>
            <span class="s5">&quot;Can't load plugin: %s:%s&quot; </span><span class="s4">% (</span><span class="s1">self</span><span class="s4">.</span><span class="s1">group</span><span class="s4">, </span><span class="s1">name</span><span class="s4">)</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">register</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">name</span><span class="s4">: </span><span class="s1">str</span><span class="s4">, </span><span class="s1">modulepath</span><span class="s4">: </span><span class="s1">str</span><span class="s4">, </span><span class="s1">objname</span><span class="s4">: </span><span class="s1">str</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s3">def </span><span class="s1">load</span><span class="s4">():</span>
            <span class="s1">mod </span><span class="s4">= </span><span class="s1">__import__</span><span class="s4">(</span><span class="s1">modulepath</span><span class="s4">)</span>
            <span class="s3">for </span><span class="s1">token </span><span class="s3">in </span><span class="s1">modulepath</span><span class="s4">.</span><span class="s1">split</span><span class="s4">(</span><span class="s5">&quot;.&quot;</span><span class="s4">)[</span><span class="s6">1</span><span class="s4">:]:</span>
                <span class="s1">mod </span><span class="s4">= </span><span class="s1">getattr</span><span class="s4">(</span><span class="s1">mod</span><span class="s4">, </span><span class="s1">token</span><span class="s4">)</span>
            <span class="s3">return </span><span class="s1">getattr</span><span class="s4">(</span><span class="s1">mod</span><span class="s4">, </span><span class="s1">objname</span><span class="s4">)</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">impls</span><span class="s4">[</span><span class="s1">name</span><span class="s4">] = </span><span class="s1">load</span>


<span class="s3">def </span><span class="s1">_inspect_func_args</span><span class="s4">(</span><span class="s1">fn</span><span class="s4">):</span>
    <span class="s3">try</span><span class="s4">:</span>
        <span class="s1">co_varkeywords </span><span class="s4">= </span><span class="s1">inspect</span><span class="s4">.</span><span class="s1">CO_VARKEYWORDS</span>
    <span class="s3">except </span><span class="s1">AttributeError</span><span class="s4">:</span>
        <span class="s0"># https://docs.python.org/3/library/inspect.html</span>
        <span class="s0"># The flags are specific to CPython, and may not be defined in other</span>
        <span class="s0"># Python implementations. Furthermore, the flags are an implementation</span>
        <span class="s0"># detail, and can be removed or deprecated in future Python releases.</span>
        <span class="s1">spec </span><span class="s4">= </span><span class="s1">compat</span><span class="s4">.</span><span class="s1">inspect_getfullargspec</span><span class="s4">(</span><span class="s1">fn</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">spec</span><span class="s4">[</span><span class="s6">0</span><span class="s4">], </span><span class="s1">bool</span><span class="s4">(</span><span class="s1">spec</span><span class="s4">[</span><span class="s6">2</span><span class="s4">])</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s0"># use fn.__code__ plus flags to reduce method call overhead</span>
        <span class="s1">co </span><span class="s4">= </span><span class="s1">fn</span><span class="s4">.</span><span class="s1">__code__</span>
        <span class="s1">nargs </span><span class="s4">= </span><span class="s1">co</span><span class="s4">.</span><span class="s1">co_argcount</span>
        <span class="s3">return </span><span class="s4">(</span>
            <span class="s1">list</span><span class="s4">(</span><span class="s1">co</span><span class="s4">.</span><span class="s1">co_varnames</span><span class="s4">[:</span><span class="s1">nargs</span><span class="s4">]),</span>
            <span class="s1">bool</span><span class="s4">(</span><span class="s1">co</span><span class="s4">.</span><span class="s1">co_flags </span><span class="s4">&amp; </span><span class="s1">co_varkeywords</span><span class="s4">),</span>
        <span class="s4">)</span>


<span class="s4">@</span><span class="s1">overload</span>
<span class="s3">def </span><span class="s1">get_cls_kwargs</span><span class="s4">(</span>
    <span class="s1">cls</span><span class="s4">: </span><span class="s1">type</span><span class="s4">,</span>
    <span class="s4">*,</span>
    <span class="s1">_set</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Set</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]] = </span><span class="s3">None</span><span class="s4">,</span>
    <span class="s1">raiseerr</span><span class="s4">: </span><span class="s1">Literal</span><span class="s4">[</span><span class="s3">True</span><span class="s4">] = ...,</span>
<span class="s4">) </span><span class="s1">-&gt; Set</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]: ...</span>


<span class="s4">@</span><span class="s1">overload</span>
<span class="s3">def </span><span class="s1">get_cls_kwargs</span><span class="s4">(</span>
    <span class="s1">cls</span><span class="s4">: </span><span class="s1">type</span><span class="s4">, *, </span><span class="s1">_set</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Set</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]] = </span><span class="s3">None</span><span class="s4">, </span><span class="s1">raiseerr</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span>
<span class="s4">) </span><span class="s1">-&gt; Optional</span><span class="s4">[</span><span class="s1">Set</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]]: ...</span>


<span class="s3">def </span><span class="s1">get_cls_kwargs</span><span class="s4">(</span>
    <span class="s1">cls</span><span class="s4">: </span><span class="s1">type</span><span class="s4">, *, </span><span class="s1">_set</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Set</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]] = </span><span class="s3">None</span><span class="s4">, </span><span class="s1">raiseerr</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span>
<span class="s4">) </span><span class="s1">-&gt; Optional</span><span class="s4">[</span><span class="s1">Set</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]]:</span>
    <span class="s2">r&quot;&quot;&quot;Return the full set of inherited kwargs for the given `cls`. 
 
    Probes a class's __init__ method, collecting all named arguments.  If the 
    __init__ defines a \**kwargs catch-all, then the constructor is presumed 
    to pass along unrecognized keywords to its base classes, and the 
    collection process is repeated recursively on each of the bases. 
 
    Uses a subset of inspect.getfullargspec() to cut down on method overhead, 
    as this is used within the Core typing system to create copies of type 
    objects which is a performance-sensitive operation. 
 
    No anonymous tuple arguments please ! 
 
    &quot;&quot;&quot;</span>
    <span class="s1">toplevel </span><span class="s4">= </span><span class="s1">_set </span><span class="s3">is None</span>
    <span class="s3">if </span><span class="s1">toplevel</span><span class="s4">:</span>
        <span class="s1">_set </span><span class="s4">= </span><span class="s1">set</span><span class="s4">()</span>
    <span class="s3">assert </span><span class="s1">_set </span><span class="s3">is not None</span>

    <span class="s1">ctr </span><span class="s4">= </span><span class="s1">cls</span><span class="s4">.</span><span class="s1">__dict__</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s5">&quot;__init__&quot;</span><span class="s4">, </span><span class="s3">False</span><span class="s4">)</span>

    <span class="s1">has_init </span><span class="s4">= (</span>
        <span class="s1">ctr</span>
        <span class="s3">and </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">ctr</span><span class="s4">, </span><span class="s1">types</span><span class="s4">.</span><span class="s1">FunctionType</span><span class="s4">)</span>
        <span class="s3">and </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">ctr</span><span class="s4">.</span><span class="s1">__code__</span><span class="s4">, </span><span class="s1">types</span><span class="s4">.</span><span class="s1">CodeType</span><span class="s4">)</span>
    <span class="s4">)</span>

    <span class="s3">if </span><span class="s1">has_init</span><span class="s4">:</span>
        <span class="s1">names</span><span class="s4">, </span><span class="s1">has_kw </span><span class="s4">= </span><span class="s1">_inspect_func_args</span><span class="s4">(</span><span class="s1">ctr</span><span class="s4">)</span>
        <span class="s1">_set</span><span class="s4">.</span><span class="s1">update</span><span class="s4">(</span><span class="s1">names</span><span class="s4">)</span>

        <span class="s3">if not </span><span class="s1">has_kw </span><span class="s3">and not </span><span class="s1">toplevel</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">raiseerr</span><span class="s4">:</span>
                <span class="s3">raise </span><span class="s1">TypeError</span><span class="s4">(</span>
                    <span class="s5">f&quot;given cls </span><span class="s3">{</span><span class="s1">cls</span><span class="s3">} </span><span class="s5">doesn't have an __init__ method&quot;</span>
                <span class="s4">)</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s3">return None</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">has_kw </span><span class="s4">= </span><span class="s3">False</span>

    <span class="s3">if not </span><span class="s1">has_init </span><span class="s3">or </span><span class="s1">has_kw</span><span class="s4">:</span>
        <span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">cls</span><span class="s4">.</span><span class="s1">__bases__</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">get_cls_kwargs</span><span class="s4">(</span><span class="s1">c</span><span class="s4">, </span><span class="s1">_set</span><span class="s4">=</span><span class="s1">_set</span><span class="s4">) </span><span class="s3">is None</span><span class="s4">:</span>
                <span class="s3">break</span>

    <span class="s1">_set</span><span class="s4">.</span><span class="s1">discard</span><span class="s4">(</span><span class="s5">&quot;self&quot;</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s1">_set</span>


<span class="s3">def </span><span class="s1">get_func_kwargs</span><span class="s4">(</span><span class="s1">func</span><span class="s4">: </span><span class="s1">Callable</span><span class="s4">[..., </span><span class="s1">Any</span><span class="s4">]) </span><span class="s1">-&gt; List</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]:</span>
    <span class="s2">&quot;&quot;&quot;Return the set of legal kwargs for the given `func`. 
 
    Uses getargspec so is safe to call for methods, functions, 
    etc. 
 
    &quot;&quot;&quot;</span>

    <span class="s3">return </span><span class="s1">compat</span><span class="s4">.</span><span class="s1">inspect_getfullargspec</span><span class="s4">(</span><span class="s1">func</span><span class="s4">)[</span><span class="s6">0</span><span class="s4">]</span>


<span class="s3">def </span><span class="s1">get_callable_argspec</span><span class="s4">(</span>
    <span class="s1">fn</span><span class="s4">: </span><span class="s1">Callable</span><span class="s4">[..., </span><span class="s1">Any</span><span class="s4">], </span><span class="s1">no_self</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">, </span><span class="s1">_is_init</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span>
<span class="s4">) </span><span class="s1">-&gt; compat</span><span class="s4">.</span><span class="s1">FullArgSpec</span><span class="s4">:</span>
    <span class="s2">&quot;&quot;&quot;Return the argument signature for any callable. 
 
    All pure-Python callables are accepted, including 
    functions, methods, classes, objects with __call__; 
    builtins and other edge cases like functools.partial() objects 
    raise a TypeError. 
 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">inspect</span><span class="s4">.</span><span class="s1">isbuiltin</span><span class="s4">(</span><span class="s1">fn</span><span class="s4">):</span>
        <span class="s3">raise </span><span class="s1">TypeError</span><span class="s4">(</span><span class="s5">&quot;Can't inspect builtin: %s&quot; </span><span class="s4">% </span><span class="s1">fn</span><span class="s4">)</span>
    <span class="s3">elif </span><span class="s1">inspect</span><span class="s4">.</span><span class="s1">isfunction</span><span class="s4">(</span><span class="s1">fn</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">_is_init </span><span class="s3">and </span><span class="s1">no_self</span><span class="s4">:</span>
            <span class="s1">spec </span><span class="s4">= </span><span class="s1">compat</span><span class="s4">.</span><span class="s1">inspect_getfullargspec</span><span class="s4">(</span><span class="s1">fn</span><span class="s4">)</span>
            <span class="s3">return </span><span class="s1">compat</span><span class="s4">.</span><span class="s1">FullArgSpec</span><span class="s4">(</span>
                <span class="s1">spec</span><span class="s4">.</span><span class="s1">args</span><span class="s4">[</span><span class="s6">1</span><span class="s4">:],</span>
                <span class="s1">spec</span><span class="s4">.</span><span class="s1">varargs</span><span class="s4">,</span>
                <span class="s1">spec</span><span class="s4">.</span><span class="s1">varkw</span><span class="s4">,</span>
                <span class="s1">spec</span><span class="s4">.</span><span class="s1">defaults</span><span class="s4">,</span>
                <span class="s1">spec</span><span class="s4">.</span><span class="s1">kwonlyargs</span><span class="s4">,</span>
                <span class="s1">spec</span><span class="s4">.</span><span class="s1">kwonlydefaults</span><span class="s4">,</span>
                <span class="s1">spec</span><span class="s4">.</span><span class="s1">annotations</span><span class="s4">,</span>
            <span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">compat</span><span class="s4">.</span><span class="s1">inspect_getfullargspec</span><span class="s4">(</span><span class="s1">fn</span><span class="s4">)</span>
    <span class="s3">elif </span><span class="s1">inspect</span><span class="s4">.</span><span class="s1">ismethod</span><span class="s4">(</span><span class="s1">fn</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">no_self </span><span class="s3">and </span><span class="s4">(</span><span class="s1">_is_init </span><span class="s3">or </span><span class="s1">fn</span><span class="s4">.</span><span class="s1">__self__</span><span class="s4">):</span>
            <span class="s1">spec </span><span class="s4">= </span><span class="s1">compat</span><span class="s4">.</span><span class="s1">inspect_getfullargspec</span><span class="s4">(</span><span class="s1">fn</span><span class="s4">.</span><span class="s1">__func__</span><span class="s4">)</span>
            <span class="s3">return </span><span class="s1">compat</span><span class="s4">.</span><span class="s1">FullArgSpec</span><span class="s4">(</span>
                <span class="s1">spec</span><span class="s4">.</span><span class="s1">args</span><span class="s4">[</span><span class="s6">1</span><span class="s4">:],</span>
                <span class="s1">spec</span><span class="s4">.</span><span class="s1">varargs</span><span class="s4">,</span>
                <span class="s1">spec</span><span class="s4">.</span><span class="s1">varkw</span><span class="s4">,</span>
                <span class="s1">spec</span><span class="s4">.</span><span class="s1">defaults</span><span class="s4">,</span>
                <span class="s1">spec</span><span class="s4">.</span><span class="s1">kwonlyargs</span><span class="s4">,</span>
                <span class="s1">spec</span><span class="s4">.</span><span class="s1">kwonlydefaults</span><span class="s4">,</span>
                <span class="s1">spec</span><span class="s4">.</span><span class="s1">annotations</span><span class="s4">,</span>
            <span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">compat</span><span class="s4">.</span><span class="s1">inspect_getfullargspec</span><span class="s4">(</span><span class="s1">fn</span><span class="s4">.</span><span class="s1">__func__</span><span class="s4">)</span>
    <span class="s3">elif </span><span class="s1">inspect</span><span class="s4">.</span><span class="s1">isclass</span><span class="s4">(</span><span class="s1">fn</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">get_callable_argspec</span><span class="s4">(</span>
            <span class="s1">fn</span><span class="s4">.</span><span class="s1">__init__</span><span class="s4">, </span><span class="s1">no_self</span><span class="s4">=</span><span class="s1">no_self</span><span class="s4">, </span><span class="s1">_is_init</span><span class="s4">=</span><span class="s3">True</span>
        <span class="s4">)</span>
    <span class="s3">elif </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">fn</span><span class="s4">, </span><span class="s5">&quot;__func__&quot;</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">compat</span><span class="s4">.</span><span class="s1">inspect_getfullargspec</span><span class="s4">(</span><span class="s1">fn</span><span class="s4">.</span><span class="s1">__func__</span><span class="s4">)</span>
    <span class="s3">elif </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">fn</span><span class="s4">, </span><span class="s5">&quot;__call__&quot;</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">inspect</span><span class="s4">.</span><span class="s1">ismethod</span><span class="s4">(</span><span class="s1">fn</span><span class="s4">.</span><span class="s1">__call__</span><span class="s4">):</span>
            <span class="s3">return </span><span class="s1">get_callable_argspec</span><span class="s4">(</span><span class="s1">fn</span><span class="s4">.</span><span class="s1">__call__</span><span class="s4">, </span><span class="s1">no_self</span><span class="s4">=</span><span class="s1">no_self</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">TypeError</span><span class="s4">(</span><span class="s5">&quot;Can't inspect callable: %s&quot; </span><span class="s4">% </span><span class="s1">fn</span><span class="s4">)</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">TypeError</span><span class="s4">(</span><span class="s5">&quot;Can't inspect callable: %s&quot; </span><span class="s4">% </span><span class="s1">fn</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">format_argspec_plus</span><span class="s4">(</span>
    <span class="s1">fn</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span><span class="s1">Callable</span><span class="s4">[..., </span><span class="s1">Any</span><span class="s4">], </span><span class="s1">compat</span><span class="s4">.</span><span class="s1">FullArgSpec</span><span class="s4">], </span><span class="s1">grouped</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">True</span>
<span class="s4">) </span><span class="s1">-&gt; Dict</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]]:</span>
    <span class="s2">&quot;&quot;&quot;Returns a dictionary of formatted, introspected function arguments. 
 
    A enhanced variant of inspect.formatargspec to support code generation. 
 
    fn 
       An inspectable callable or tuple of inspect getargspec() results. 
    grouped 
      Defaults to True; include (parens, around, argument) lists 
 
    Returns: 
 
    args 
      Full inspect.formatargspec for fn 
    self_arg 
      The name of the first positional argument, varargs[0], or None 
      if the function defines no positional arguments. 
    apply_pos 
      args, re-written in calling rather than receiving syntax.  Arguments are 
      passed positionally. 
    apply_kw 
      Like apply_pos, except keyword-ish args are passed as keywords. 
    apply_pos_proxied 
      Like apply_pos but omits the self/cls argument 
 
    Example:: 
 
      &gt;&gt;&gt; format_argspec_plus(lambda self, a, b, c=3, **d: 123) 
      {'grouped_args': '(self, a, b, c=3, **d)', 
       'self_arg': 'self', 
       'apply_kw': '(self, a, b, c=c, **d)', 
       'apply_pos': '(self, a, b, c, **d)'} 
 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">callable</span><span class="s4">(</span><span class="s1">fn</span><span class="s4">):</span>
        <span class="s1">spec </span><span class="s4">= </span><span class="s1">compat</span><span class="s4">.</span><span class="s1">inspect_getfullargspec</span><span class="s4">(</span><span class="s1">fn</span><span class="s4">)</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">spec </span><span class="s4">= </span><span class="s1">fn</span>

    <span class="s1">args </span><span class="s4">= </span><span class="s1">compat</span><span class="s4">.</span><span class="s1">inspect_formatargspec</span><span class="s4">(*</span><span class="s1">spec</span><span class="s4">)</span>

    <span class="s1">apply_pos </span><span class="s4">= </span><span class="s1">compat</span><span class="s4">.</span><span class="s1">inspect_formatargspec</span><span class="s4">(</span>
        <span class="s1">spec</span><span class="s4">[</span><span class="s6">0</span><span class="s4">], </span><span class="s1">spec</span><span class="s4">[</span><span class="s6">1</span><span class="s4">], </span><span class="s1">spec</span><span class="s4">[</span><span class="s6">2</span><span class="s4">], </span><span class="s3">None</span><span class="s4">, </span><span class="s1">spec</span><span class="s4">[</span><span class="s6">4</span><span class="s4">]</span>
    <span class="s4">)</span>

    <span class="s3">if </span><span class="s1">spec</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]:</span>
        <span class="s1">self_arg </span><span class="s4">= </span><span class="s1">spec</span><span class="s4">[</span><span class="s6">0</span><span class="s4">][</span><span class="s6">0</span><span class="s4">]</span>

        <span class="s1">apply_pos_proxied </span><span class="s4">= </span><span class="s1">compat</span><span class="s4">.</span><span class="s1">inspect_formatargspec</span><span class="s4">(</span>
            <span class="s1">spec</span><span class="s4">[</span><span class="s6">0</span><span class="s4">][</span><span class="s6">1</span><span class="s4">:], </span><span class="s1">spec</span><span class="s4">[</span><span class="s6">1</span><span class="s4">], </span><span class="s1">spec</span><span class="s4">[</span><span class="s6">2</span><span class="s4">], </span><span class="s3">None</span><span class="s4">, </span><span class="s1">spec</span><span class="s4">[</span><span class="s6">4</span><span class="s4">]</span>
        <span class="s4">)</span>

    <span class="s3">elif </span><span class="s1">spec</span><span class="s4">[</span><span class="s6">1</span><span class="s4">]:</span>
        <span class="s0"># I'm not sure what this is</span>
        <span class="s1">self_arg </span><span class="s4">= </span><span class="s5">&quot;%s[0]&quot; </span><span class="s4">% </span><span class="s1">spec</span><span class="s4">[</span><span class="s6">1</span><span class="s4">]</span>

        <span class="s1">apply_pos_proxied </span><span class="s4">= </span><span class="s1">apply_pos</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">self_arg </span><span class="s4">= </span><span class="s3">None</span>
        <span class="s1">apply_pos_proxied </span><span class="s4">= </span><span class="s1">apply_pos</span>

    <span class="s1">num_defaults </span><span class="s4">= </span><span class="s6">0</span>
    <span class="s3">if </span><span class="s1">spec</span><span class="s4">[</span><span class="s6">3</span><span class="s4">]:</span>
        <span class="s1">num_defaults </span><span class="s4">+= </span><span class="s1">len</span><span class="s4">(</span><span class="s1">cast</span><span class="s4">(</span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">], </span><span class="s1">spec</span><span class="s4">[</span><span class="s6">3</span><span class="s4">]))</span>
    <span class="s3">if </span><span class="s1">spec</span><span class="s4">[</span><span class="s6">4</span><span class="s4">]:</span>
        <span class="s1">num_defaults </span><span class="s4">+= </span><span class="s1">len</span><span class="s4">(</span><span class="s1">spec</span><span class="s4">[</span><span class="s6">4</span><span class="s4">])</span>

    <span class="s1">name_args </span><span class="s4">= </span><span class="s1">spec</span><span class="s4">[</span><span class="s6">0</span><span class="s4">] + </span><span class="s1">spec</span><span class="s4">[</span><span class="s6">4</span><span class="s4">]</span>

    <span class="s1">defaulted_vals</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span><span class="s1">List</span><span class="s4">[</span><span class="s1">str</span><span class="s4">], </span><span class="s1">Tuple</span><span class="s4">[()]]</span>

    <span class="s3">if </span><span class="s1">num_defaults</span><span class="s4">:</span>
        <span class="s1">defaulted_vals </span><span class="s4">= </span><span class="s1">name_args</span><span class="s4">[</span><span class="s6">0 </span><span class="s4">- </span><span class="s1">num_defaults </span><span class="s4">:]</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">defaulted_vals </span><span class="s4">= ()</span>

    <span class="s1">apply_kw </span><span class="s4">= </span><span class="s1">compat</span><span class="s4">.</span><span class="s1">inspect_formatargspec</span><span class="s4">(</span>
        <span class="s1">name_args</span><span class="s4">,</span>
        <span class="s1">spec</span><span class="s4">[</span><span class="s6">1</span><span class="s4">],</span>
        <span class="s1">spec</span><span class="s4">[</span><span class="s6">2</span><span class="s4">],</span>
        <span class="s1">defaulted_vals</span><span class="s4">,</span>
        <span class="s1">formatvalue</span><span class="s4">=</span><span class="s3">lambda </span><span class="s1">x</span><span class="s4">: </span><span class="s5">&quot;=&quot; </span><span class="s4">+ </span><span class="s1">str</span><span class="s4">(</span><span class="s1">x</span><span class="s4">),</span>
    <span class="s4">)</span>

    <span class="s3">if </span><span class="s1">spec</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]:</span>
        <span class="s1">apply_kw_proxied </span><span class="s4">= </span><span class="s1">compat</span><span class="s4">.</span><span class="s1">inspect_formatargspec</span><span class="s4">(</span>
            <span class="s1">name_args</span><span class="s4">[</span><span class="s6">1</span><span class="s4">:],</span>
            <span class="s1">spec</span><span class="s4">[</span><span class="s6">1</span><span class="s4">],</span>
            <span class="s1">spec</span><span class="s4">[</span><span class="s6">2</span><span class="s4">],</span>
            <span class="s1">defaulted_vals</span><span class="s4">,</span>
            <span class="s1">formatvalue</span><span class="s4">=</span><span class="s3">lambda </span><span class="s1">x</span><span class="s4">: </span><span class="s5">&quot;=&quot; </span><span class="s4">+ </span><span class="s1">str</span><span class="s4">(</span><span class="s1">x</span><span class="s4">),</span>
        <span class="s4">)</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">apply_kw_proxied </span><span class="s4">= </span><span class="s1">apply_kw</span>

    <span class="s3">if </span><span class="s1">grouped</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">dict</span><span class="s4">(</span>
            <span class="s1">grouped_args</span><span class="s4">=</span><span class="s1">args</span><span class="s4">,</span>
            <span class="s1">self_arg</span><span class="s4">=</span><span class="s1">self_arg</span><span class="s4">,</span>
            <span class="s1">apply_pos</span><span class="s4">=</span><span class="s1">apply_pos</span><span class="s4">,</span>
            <span class="s1">apply_kw</span><span class="s4">=</span><span class="s1">apply_kw</span><span class="s4">,</span>
            <span class="s1">apply_pos_proxied</span><span class="s4">=</span><span class="s1">apply_pos_proxied</span><span class="s4">,</span>
            <span class="s1">apply_kw_proxied</span><span class="s4">=</span><span class="s1">apply_kw_proxied</span><span class="s4">,</span>
        <span class="s4">)</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">dict</span><span class="s4">(</span>
            <span class="s1">grouped_args</span><span class="s4">=</span><span class="s1">args</span><span class="s4">,</span>
            <span class="s1">self_arg</span><span class="s4">=</span><span class="s1">self_arg</span><span class="s4">,</span>
            <span class="s1">apply_pos</span><span class="s4">=</span><span class="s1">apply_pos</span><span class="s4">[</span><span class="s6">1</span><span class="s4">:-</span><span class="s6">1</span><span class="s4">],</span>
            <span class="s1">apply_kw</span><span class="s4">=</span><span class="s1">apply_kw</span><span class="s4">[</span><span class="s6">1</span><span class="s4">:-</span><span class="s6">1</span><span class="s4">],</span>
            <span class="s1">apply_pos_proxied</span><span class="s4">=</span><span class="s1">apply_pos_proxied</span><span class="s4">[</span><span class="s6">1</span><span class="s4">:-</span><span class="s6">1</span><span class="s4">],</span>
            <span class="s1">apply_kw_proxied</span><span class="s4">=</span><span class="s1">apply_kw_proxied</span><span class="s4">[</span><span class="s6">1</span><span class="s4">:-</span><span class="s6">1</span><span class="s4">],</span>
        <span class="s4">)</span>


<span class="s3">def </span><span class="s1">format_argspec_init</span><span class="s4">(</span><span class="s1">method</span><span class="s4">, </span><span class="s1">grouped</span><span class="s4">=</span><span class="s3">True</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;format_argspec_plus with considerations for typical __init__ methods 
 
    Wraps format_argspec_plus with error handling strategies for typical 
    __init__ cases:: 
 
      object.__init__ -&gt; (self) 
      other unreflectable (usually C) -&gt; (self, *args, **kwargs) 
 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">method </span><span class="s3">is </span><span class="s1">object</span><span class="s4">.</span><span class="s1">__init__</span><span class="s4">:</span>
        <span class="s1">grouped_args </span><span class="s4">= </span><span class="s5">&quot;(self)&quot;</span>
        <span class="s1">args </span><span class="s4">= </span><span class="s5">&quot;(self)&quot; </span><span class="s3">if </span><span class="s1">grouped </span><span class="s3">else </span><span class="s5">&quot;self&quot;</span>
        <span class="s1">proxied </span><span class="s4">= </span><span class="s5">&quot;()&quot; </span><span class="s3">if </span><span class="s1">grouped </span><span class="s3">else </span><span class="s5">&quot;&quot;</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s3">try</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">format_argspec_plus</span><span class="s4">(</span><span class="s1">method</span><span class="s4">, </span><span class="s1">grouped</span><span class="s4">=</span><span class="s1">grouped</span><span class="s4">)</span>
        <span class="s3">except </span><span class="s1">TypeError</span><span class="s4">:</span>
            <span class="s1">grouped_args </span><span class="s4">= </span><span class="s5">&quot;(self, *args, **kwargs)&quot;</span>
            <span class="s1">args </span><span class="s4">= </span><span class="s1">grouped_args </span><span class="s3">if </span><span class="s1">grouped </span><span class="s3">else </span><span class="s5">&quot;self, *args, **kwargs&quot;</span>
            <span class="s1">proxied </span><span class="s4">= </span><span class="s5">&quot;(*args, **kwargs)&quot; </span><span class="s3">if </span><span class="s1">grouped </span><span class="s3">else </span><span class="s5">&quot;*args, **kwargs&quot;</span>
    <span class="s3">return </span><span class="s1">dict</span><span class="s4">(</span>
        <span class="s1">self_arg</span><span class="s4">=</span><span class="s5">&quot;self&quot;</span><span class="s4">,</span>
        <span class="s1">grouped_args</span><span class="s4">=</span><span class="s1">grouped_args</span><span class="s4">,</span>
        <span class="s1">apply_pos</span><span class="s4">=</span><span class="s1">args</span><span class="s4">,</span>
        <span class="s1">apply_kw</span><span class="s4">=</span><span class="s1">args</span><span class="s4">,</span>
        <span class="s1">apply_pos_proxied</span><span class="s4">=</span><span class="s1">proxied</span><span class="s4">,</span>
        <span class="s1">apply_kw_proxied</span><span class="s4">=</span><span class="s1">proxied</span><span class="s4">,</span>
    <span class="s4">)</span>


<span class="s3">def </span><span class="s1">create_proxy_methods</span><span class="s4">(</span>
    <span class="s1">target_cls</span><span class="s4">: </span><span class="s1">Type</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">],</span>
    <span class="s1">target_cls_sphinx_name</span><span class="s4">: </span><span class="s1">str</span><span class="s4">,</span>
    <span class="s1">proxy_cls_sphinx_name</span><span class="s4">: </span><span class="s1">str</span><span class="s4">,</span>
    <span class="s1">classmethods</span><span class="s4">: </span><span class="s1">Sequence</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = (),</span>
    <span class="s1">methods</span><span class="s4">: </span><span class="s1">Sequence</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = (),</span>
    <span class="s1">attributes</span><span class="s4">: </span><span class="s1">Sequence</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = (),</span>
    <span class="s1">use_intermediate_variable</span><span class="s4">: </span><span class="s1">Sequence</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = (),</span>
<span class="s4">) </span><span class="s1">-&gt; Callable</span><span class="s4">[[</span><span class="s1">_T</span><span class="s4">], </span><span class="s1">_T</span><span class="s4">]:</span>
    <span class="s2">&quot;&quot;&quot;A class decorator indicating attributes should refer to a proxy 
    class. 
 
    This decorator is now a &quot;marker&quot; that does nothing at runtime.  Instead, 
    it is consumed by the tools/generate_proxy_methods.py script to 
    statically generate proxy methods and attributes that are fully 
    recognized by typing tools such as mypy. 
 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">decorate</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">cls</span>

    <span class="s3">return </span><span class="s1">decorate</span>


<span class="s3">def </span><span class="s1">getargspec_init</span><span class="s4">(</span><span class="s1">method</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;inspect.getargspec with considerations for typical __init__ methods 
 
    Wraps inspect.getargspec with error handling for typical __init__ cases:: 
 
      object.__init__ -&gt; (self) 
      other unreflectable (usually C) -&gt; (self, *args, **kwargs) 
 
    &quot;&quot;&quot;</span>
    <span class="s3">try</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">compat</span><span class="s4">.</span><span class="s1">inspect_getfullargspec</span><span class="s4">(</span><span class="s1">method</span><span class="s4">)</span>
    <span class="s3">except </span><span class="s1">TypeError</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">method </span><span class="s3">is </span><span class="s1">object</span><span class="s4">.</span><span class="s1">__init__</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s4">([</span><span class="s5">&quot;self&quot;</span><span class="s4">], </span><span class="s3">None</span><span class="s4">, </span><span class="s3">None</span><span class="s4">, </span><span class="s3">None</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s4">([</span><span class="s5">&quot;self&quot;</span><span class="s4">], </span><span class="s5">&quot;args&quot;</span><span class="s4">, </span><span class="s5">&quot;kwargs&quot;</span><span class="s4">, </span><span class="s3">None</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">unbound_method_to_callable</span><span class="s4">(</span><span class="s1">func_or_cls</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Adjust the incoming callable such that a 'self' argument is not 
    required. 
 
    &quot;&quot;&quot;</span>

    <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">func_or_cls</span><span class="s4">, </span><span class="s1">types</span><span class="s4">.</span><span class="s1">MethodType</span><span class="s4">) </span><span class="s3">and not </span><span class="s1">func_or_cls</span><span class="s4">.</span><span class="s1">__self__</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">func_or_cls</span><span class="s4">.</span><span class="s1">__func__</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">func_or_cls</span>


<span class="s3">def </span><span class="s1">generic_repr</span><span class="s4">(</span>
    <span class="s1">obj</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
    <span class="s1">additional_kw</span><span class="s4">: </span><span class="s1">Sequence</span><span class="s4">[</span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">Any</span><span class="s4">]] = (),</span>
    <span class="s1">to_inspect</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Union</span><span class="s4">[</span><span class="s1">object</span><span class="s4">, </span><span class="s1">List</span><span class="s4">[</span><span class="s1">object</span><span class="s4">]]] = </span><span class="s3">None</span><span class="s4">,</span>
    <span class="s1">omit_kwarg</span><span class="s4">: </span><span class="s1">Sequence</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = (),</span>
<span class="s4">) </span><span class="s1">-&gt; str</span><span class="s4">:</span>
    <span class="s2">&quot;&quot;&quot;Produce a __repr__() based on direct association of the __init__() 
    specification vs. same-named attributes present. 
 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">to_inspect </span><span class="s3">is None</span><span class="s4">:</span>
        <span class="s1">to_inspect </span><span class="s4">= [</span><span class="s1">obj</span><span class="s4">]</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">to_inspect </span><span class="s4">= </span><span class="s1">_collections</span><span class="s4">.</span><span class="s1">to_list</span><span class="s4">(</span><span class="s1">to_inspect</span><span class="s4">)</span>

    <span class="s1">missing </span><span class="s4">= </span><span class="s1">object</span><span class="s4">()</span>

    <span class="s1">pos_args </span><span class="s4">= []</span>
    <span class="s1">kw_args</span><span class="s4">: </span><span class="s1">_collections</span><span class="s4">.</span><span class="s1">OrderedDict</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">Any</span><span class="s4">] = </span><span class="s1">_collections</span><span class="s4">.</span><span class="s1">OrderedDict</span><span class="s4">()</span>
    <span class="s1">vargs </span><span class="s4">= </span><span class="s3">None</span>
    <span class="s3">for </span><span class="s1">i</span><span class="s4">, </span><span class="s1">insp </span><span class="s3">in </span><span class="s1">enumerate</span><span class="s4">(</span><span class="s1">to_inspect</span><span class="s4">):</span>
        <span class="s3">try</span><span class="s4">:</span>
            <span class="s1">spec </span><span class="s4">= </span><span class="s1">compat</span><span class="s4">.</span><span class="s1">inspect_getfullargspec</span><span class="s4">(</span><span class="s1">insp</span><span class="s4">.</span><span class="s1">__init__</span><span class="s4">)</span>
        <span class="s3">except </span><span class="s1">TypeError</span><span class="s4">:</span>
            <span class="s3">continue</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">default_len </span><span class="s4">= </span><span class="s1">len</span><span class="s4">(</span><span class="s1">spec</span><span class="s4">.</span><span class="s1">defaults</span><span class="s4">) </span><span class="s3">if </span><span class="s1">spec</span><span class="s4">.</span><span class="s1">defaults </span><span class="s3">else </span><span class="s6">0</span>
            <span class="s3">if </span><span class="s1">i </span><span class="s4">== </span><span class="s6">0</span><span class="s4">:</span>
                <span class="s3">if </span><span class="s1">spec</span><span class="s4">.</span><span class="s1">varargs</span><span class="s4">:</span>
                    <span class="s1">vargs </span><span class="s4">= </span><span class="s1">spec</span><span class="s4">.</span><span class="s1">varargs</span>
                <span class="s3">if </span><span class="s1">default_len</span><span class="s4">:</span>
                    <span class="s1">pos_args</span><span class="s4">.</span><span class="s1">extend</span><span class="s4">(</span><span class="s1">spec</span><span class="s4">.</span><span class="s1">args</span><span class="s4">[</span><span class="s6">1</span><span class="s4">:-</span><span class="s1">default_len</span><span class="s4">])</span>
                <span class="s3">else</span><span class="s4">:</span>
                    <span class="s1">pos_args</span><span class="s4">.</span><span class="s1">extend</span><span class="s4">(</span><span class="s1">spec</span><span class="s4">.</span><span class="s1">args</span><span class="s4">[</span><span class="s6">1</span><span class="s4">:])</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">kw_args</span><span class="s4">.</span><span class="s1">update</span><span class="s4">(</span>
                    <span class="s4">[(</span><span class="s1">arg</span><span class="s4">, </span><span class="s1">missing</span><span class="s4">) </span><span class="s3">for </span><span class="s1">arg </span><span class="s3">in </span><span class="s1">spec</span><span class="s4">.</span><span class="s1">args</span><span class="s4">[</span><span class="s6">1</span><span class="s4">:-</span><span class="s1">default_len</span><span class="s4">]]</span>
                <span class="s4">)</span>

            <span class="s3">if </span><span class="s1">default_len</span><span class="s4">:</span>
                <span class="s3">assert </span><span class="s1">spec</span><span class="s4">.</span><span class="s1">defaults</span>
                <span class="s1">kw_args</span><span class="s4">.</span><span class="s1">update</span><span class="s4">(</span>
                    <span class="s4">[</span>
                        <span class="s4">(</span><span class="s1">arg</span><span class="s4">, </span><span class="s1">default</span><span class="s4">)</span>
                        <span class="s3">for </span><span class="s1">arg</span><span class="s4">, </span><span class="s1">default </span><span class="s3">in </span><span class="s1">zip</span><span class="s4">(</span>
                            <span class="s1">spec</span><span class="s4">.</span><span class="s1">args</span><span class="s4">[-</span><span class="s1">default_len</span><span class="s4">:], </span><span class="s1">spec</span><span class="s4">.</span><span class="s1">defaults</span>
                        <span class="s4">)</span>
                    <span class="s4">]</span>
                <span class="s4">)</span>
    <span class="s1">output</span><span class="s4">: </span><span class="s1">List</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = []</span>

    <span class="s1">output</span><span class="s4">.</span><span class="s1">extend</span><span class="s4">(</span><span class="s1">repr</span><span class="s4">(</span><span class="s1">getattr</span><span class="s4">(</span><span class="s1">obj</span><span class="s4">, </span><span class="s1">arg</span><span class="s4">, </span><span class="s3">None</span><span class="s4">)) </span><span class="s3">for </span><span class="s1">arg </span><span class="s3">in </span><span class="s1">pos_args</span><span class="s4">)</span>

    <span class="s3">if </span><span class="s1">vargs </span><span class="s3">is not None and </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">obj</span><span class="s4">, </span><span class="s1">vargs</span><span class="s4">):</span>
        <span class="s1">output</span><span class="s4">.</span><span class="s1">extend</span><span class="s4">([</span><span class="s1">repr</span><span class="s4">(</span><span class="s1">val</span><span class="s4">) </span><span class="s3">for </span><span class="s1">val </span><span class="s3">in </span><span class="s1">getattr</span><span class="s4">(</span><span class="s1">obj</span><span class="s4">, </span><span class="s1">vargs</span><span class="s4">)])</span>

    <span class="s3">for </span><span class="s1">arg</span><span class="s4">, </span><span class="s1">defval </span><span class="s3">in </span><span class="s1">kw_args</span><span class="s4">.</span><span class="s1">items</span><span class="s4">():</span>
        <span class="s3">if </span><span class="s1">arg </span><span class="s3">in </span><span class="s1">omit_kwarg</span><span class="s4">:</span>
            <span class="s3">continue</span>
        <span class="s3">try</span><span class="s4">:</span>
            <span class="s1">val </span><span class="s4">= </span><span class="s1">getattr</span><span class="s4">(</span><span class="s1">obj</span><span class="s4">, </span><span class="s1">arg</span><span class="s4">, </span><span class="s1">missing</span><span class="s4">)</span>
            <span class="s3">if </span><span class="s1">val </span><span class="s3">is not </span><span class="s1">missing </span><span class="s3">and </span><span class="s1">val </span><span class="s4">!= </span><span class="s1">defval</span><span class="s4">:</span>
                <span class="s1">output</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s5">&quot;%s=%r&quot; </span><span class="s4">% (</span><span class="s1">arg</span><span class="s4">, </span><span class="s1">val</span><span class="s4">))</span>
        <span class="s3">except </span><span class="s1">Exception</span><span class="s4">:</span>
            <span class="s3">pass</span>

    <span class="s3">if </span><span class="s1">additional_kw</span><span class="s4">:</span>
        <span class="s3">for </span><span class="s1">arg</span><span class="s4">, </span><span class="s1">defval </span><span class="s3">in </span><span class="s1">additional_kw</span><span class="s4">:</span>
            <span class="s3">try</span><span class="s4">:</span>
                <span class="s1">val </span><span class="s4">= </span><span class="s1">getattr</span><span class="s4">(</span><span class="s1">obj</span><span class="s4">, </span><span class="s1">arg</span><span class="s4">, </span><span class="s1">missing</span><span class="s4">)</span>
                <span class="s3">if </span><span class="s1">val </span><span class="s3">is not </span><span class="s1">missing </span><span class="s3">and </span><span class="s1">val </span><span class="s4">!= </span><span class="s1">defval</span><span class="s4">:</span>
                    <span class="s1">output</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s5">&quot;%s=%r&quot; </span><span class="s4">% (</span><span class="s1">arg</span><span class="s4">, </span><span class="s1">val</span><span class="s4">))</span>
            <span class="s3">except </span><span class="s1">Exception</span><span class="s4">:</span>
                <span class="s3">pass</span>

    <span class="s3">return </span><span class="s5">&quot;%s(%s)&quot; </span><span class="s4">% (</span><span class="s1">obj</span><span class="s4">.</span><span class="s1">__class__</span><span class="s4">.</span><span class="s1">__name__</span><span class="s4">, </span><span class="s5">&quot;, &quot;</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span><span class="s1">output</span><span class="s4">))</span>


<span class="s3">class </span><span class="s1">portable_instancemethod</span><span class="s4">:</span>
    <span class="s2">&quot;&quot;&quot;Turn an instancemethod into a (parent, name) pair 
    to produce a serializable callable. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__slots__ </span><span class="s4">= </span><span class="s5">&quot;target&quot;</span><span class="s4">, </span><span class="s5">&quot;name&quot;</span><span class="s4">, </span><span class="s5">&quot;kwargs&quot;</span><span class="s4">, </span><span class="s5">&quot;__weakref__&quot;</span>

    <span class="s3">def </span><span class="s1">__getstate__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s4">{</span>
            <span class="s5">&quot;target&quot;</span><span class="s4">: </span><span class="s1">self</span><span class="s4">.</span><span class="s1">target</span><span class="s4">,</span>
            <span class="s5">&quot;name&quot;</span><span class="s4">: </span><span class="s1">self</span><span class="s4">.</span><span class="s1">name</span><span class="s4">,</span>
            <span class="s5">&quot;kwargs&quot;</span><span class="s4">: </span><span class="s1">self</span><span class="s4">.</span><span class="s1">kwargs</span><span class="s4">,</span>
        <span class="s4">}</span>

    <span class="s3">def </span><span class="s1">__setstate__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">state</span><span class="s4">):</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">target </span><span class="s4">= </span><span class="s1">state</span><span class="s4">[</span><span class="s5">&quot;target&quot;</span><span class="s4">]</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">name </span><span class="s4">= </span><span class="s1">state</span><span class="s4">[</span><span class="s5">&quot;name&quot;</span><span class="s4">]</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">kwargs </span><span class="s4">= </span><span class="s1">state</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s5">&quot;kwargs&quot;</span><span class="s4">, ())</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">meth</span><span class="s4">, </span><span class="s1">kwargs</span><span class="s4">=()):</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">target </span><span class="s4">= </span><span class="s1">meth</span><span class="s4">.</span><span class="s1">__self__</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">name </span><span class="s4">= </span><span class="s1">meth</span><span class="s4">.</span><span class="s1">__name__</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">kwargs </span><span class="s4">= </span><span class="s1">kwargs</span>

    <span class="s3">def </span><span class="s1">__call__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, *</span><span class="s1">arg</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s1">kw</span><span class="s4">.</span><span class="s1">update</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">kwargs</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">getattr</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">target</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">name</span><span class="s4">)(*</span><span class="s1">arg</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">class_hierarchy</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Return an unordered sequence of all classes related to cls. 
 
    Traverses diamond hierarchies. 
 
    Fibs slightly: subclasses of builtin types are not returned.  Thus 
    class_hierarchy(class A(object)) returns (A, object), not A plus every 
    class systemwide that derives from object. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">hier </span><span class="s4">= {</span><span class="s1">cls</span><span class="s4">}</span>
    <span class="s1">process </span><span class="s4">= </span><span class="s1">list</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">.</span><span class="s1">__mro__</span><span class="s4">)</span>
    <span class="s3">while </span><span class="s1">process</span><span class="s4">:</span>
        <span class="s1">c </span><span class="s4">= </span><span class="s1">process</span><span class="s4">.</span><span class="s1">pop</span><span class="s4">()</span>
        <span class="s1">bases </span><span class="s4">= (</span><span class="s1">_ </span><span class="s3">for </span><span class="s1">_ </span><span class="s3">in </span><span class="s1">c</span><span class="s4">.</span><span class="s1">__bases__ </span><span class="s3">if </span><span class="s1">_ </span><span class="s3">not in </span><span class="s1">hier</span><span class="s4">)</span>

        <span class="s3">for </span><span class="s1">b </span><span class="s3">in </span><span class="s1">bases</span><span class="s4">:</span>
            <span class="s1">process</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">b</span><span class="s4">)</span>
            <span class="s1">hier</span><span class="s4">.</span><span class="s1">add</span><span class="s4">(</span><span class="s1">b</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s1">c</span><span class="s4">.</span><span class="s1">__module__ </span><span class="s4">== </span><span class="s5">&quot;builtins&quot; </span><span class="s3">or not </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">c</span><span class="s4">, </span><span class="s5">&quot;__subclasses__&quot;</span><span class="s4">):</span>
            <span class="s3">continue</span>

        <span class="s3">for </span><span class="s1">s </span><span class="s3">in </span><span class="s4">[</span>
            <span class="s1">_</span>
            <span class="s3">for </span><span class="s1">_ </span><span class="s3">in </span><span class="s4">(</span>
                <span class="s1">c</span><span class="s4">.</span><span class="s1">__subclasses__</span><span class="s4">()</span>
                <span class="s3">if not </span><span class="s1">issubclass</span><span class="s4">(</span><span class="s1">c</span><span class="s4">, </span><span class="s1">type</span><span class="s4">)</span>
                <span class="s3">else </span><span class="s1">c</span><span class="s4">.</span><span class="s1">__subclasses__</span><span class="s4">(</span><span class="s1">c</span><span class="s4">)</span>
            <span class="s4">)</span>
            <span class="s3">if </span><span class="s1">_ </span><span class="s3">not in </span><span class="s1">hier</span>
        <span class="s4">]:</span>
            <span class="s1">process</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">s</span><span class="s4">)</span>
            <span class="s1">hier</span><span class="s4">.</span><span class="s1">add</span><span class="s4">(</span><span class="s1">s</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s1">list</span><span class="s4">(</span><span class="s1">hier</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">iterate_attributes</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;iterate all the keys and attributes associated 
    with a class, without using getattr(). 
 
    Does not use getattr() so that class-sensitive 
    descriptors (i.e. property.__get__()) are not called. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">keys </span><span class="s4">= </span><span class="s1">dir</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">)</span>
    <span class="s3">for </span><span class="s1">key </span><span class="s3">in </span><span class="s1">keys</span><span class="s4">:</span>
        <span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">cls</span><span class="s4">.</span><span class="s1">__mro__</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">key </span><span class="s3">in </span><span class="s1">c</span><span class="s4">.</span><span class="s1">__dict__</span><span class="s4">:</span>
                <span class="s3">yield </span><span class="s4">(</span><span class="s1">key</span><span class="s4">, </span><span class="s1">c</span><span class="s4">.</span><span class="s1">__dict__</span><span class="s4">[</span><span class="s1">key</span><span class="s4">])</span>
                <span class="s3">break</span>


<span class="s3">def </span><span class="s1">monkeypatch_proxied_specials</span><span class="s4">(</span>
    <span class="s1">into_cls</span><span class="s4">,</span>
    <span class="s1">from_cls</span><span class="s4">,</span>
    <span class="s1">skip</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
    <span class="s1">only</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
    <span class="s1">name</span><span class="s4">=</span><span class="s5">&quot;self.proxy&quot;</span><span class="s4">,</span>
    <span class="s1">from_instance</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
<span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Automates delegation of __specials__ for a proxying type.&quot;&quot;&quot;</span>

    <span class="s3">if </span><span class="s1">only</span><span class="s4">:</span>
        <span class="s1">dunders </span><span class="s4">= </span><span class="s1">only</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">skip </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s1">skip </span><span class="s4">= (</span>
                <span class="s5">&quot;__slots__&quot;</span><span class="s4">,</span>
                <span class="s5">&quot;__del__&quot;</span><span class="s4">,</span>
                <span class="s5">&quot;__getattribute__&quot;</span><span class="s4">,</span>
                <span class="s5">&quot;__metaclass__&quot;</span><span class="s4">,</span>
                <span class="s5">&quot;__getstate__&quot;</span><span class="s4">,</span>
                <span class="s5">&quot;__setstate__&quot;</span><span class="s4">,</span>
            <span class="s4">)</span>
        <span class="s1">dunders </span><span class="s4">= [</span>
            <span class="s1">m</span>
            <span class="s3">for </span><span class="s1">m </span><span class="s3">in </span><span class="s1">dir</span><span class="s4">(</span><span class="s1">from_cls</span><span class="s4">)</span>
            <span class="s3">if </span><span class="s4">(</span>
                <span class="s1">m</span><span class="s4">.</span><span class="s1">startswith</span><span class="s4">(</span><span class="s5">&quot;__&quot;</span><span class="s4">)</span>
                <span class="s3">and </span><span class="s1">m</span><span class="s4">.</span><span class="s1">endswith</span><span class="s4">(</span><span class="s5">&quot;__&quot;</span><span class="s4">)</span>
                <span class="s3">and not </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">into_cls</span><span class="s4">, </span><span class="s1">m</span><span class="s4">)</span>
                <span class="s3">and </span><span class="s1">m </span><span class="s3">not in </span><span class="s1">skip</span>
            <span class="s4">)</span>
        <span class="s4">]</span>

    <span class="s3">for </span><span class="s1">method </span><span class="s3">in </span><span class="s1">dunders</span><span class="s4">:</span>
        <span class="s3">try</span><span class="s4">:</span>
            <span class="s1">maybe_fn </span><span class="s4">= </span><span class="s1">getattr</span><span class="s4">(</span><span class="s1">from_cls</span><span class="s4">, </span><span class="s1">method</span><span class="s4">)</span>
            <span class="s3">if not </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">maybe_fn</span><span class="s4">, </span><span class="s5">&quot;__call__&quot;</span><span class="s4">):</span>
                <span class="s3">continue</span>
            <span class="s1">maybe_fn </span><span class="s4">= </span><span class="s1">getattr</span><span class="s4">(</span><span class="s1">maybe_fn</span><span class="s4">, </span><span class="s5">&quot;__func__&quot;</span><span class="s4">, </span><span class="s1">maybe_fn</span><span class="s4">)</span>
            <span class="s1">fn </span><span class="s4">= </span><span class="s1">cast</span><span class="s4">(</span><span class="s1">types</span><span class="s4">.</span><span class="s1">FunctionType</span><span class="s4">, </span><span class="s1">maybe_fn</span><span class="s4">)</span>

        <span class="s3">except </span><span class="s1">AttributeError</span><span class="s4">:</span>
            <span class="s3">continue</span>
        <span class="s3">try</span><span class="s4">:</span>
            <span class="s1">spec </span><span class="s4">= </span><span class="s1">compat</span><span class="s4">.</span><span class="s1">inspect_getfullargspec</span><span class="s4">(</span><span class="s1">fn</span><span class="s4">)</span>
            <span class="s1">fn_args </span><span class="s4">= </span><span class="s1">compat</span><span class="s4">.</span><span class="s1">inspect_formatargspec</span><span class="s4">(</span><span class="s1">spec</span><span class="s4">[</span><span class="s6">0</span><span class="s4">])</span>
            <span class="s1">d_args </span><span class="s4">= </span><span class="s1">compat</span><span class="s4">.</span><span class="s1">inspect_formatargspec</span><span class="s4">(</span><span class="s1">spec</span><span class="s4">[</span><span class="s6">0</span><span class="s4">][</span><span class="s6">1</span><span class="s4">:])</span>
        <span class="s3">except </span><span class="s1">TypeError</span><span class="s4">:</span>
            <span class="s1">fn_args </span><span class="s4">= </span><span class="s5">&quot;(self, *args, **kw)&quot;</span>
            <span class="s1">d_args </span><span class="s4">= </span><span class="s5">&quot;(*args, **kw)&quot;</span>

        <span class="s1">py </span><span class="s4">= (</span>
            <span class="s5">&quot;def %(method)s%(fn_args)s: &quot;</span>
            <span class="s5">&quot;return %(name)s.%(method)s%(d_args)s&quot; </span><span class="s4">% </span><span class="s1">locals</span><span class="s4">()</span>
        <span class="s4">)</span>

        <span class="s1">env</span><span class="s4">: </span><span class="s1">Dict</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">types</span><span class="s4">.</span><span class="s1">FunctionType</span><span class="s4">] = (</span>
            <span class="s1">from_instance </span><span class="s3">is not None and </span><span class="s4">{</span><span class="s1">name</span><span class="s4">: </span><span class="s1">from_instance</span><span class="s4">} </span><span class="s3">or </span><span class="s4">{}</span>
        <span class="s4">)</span>
        <span class="s1">exec</span><span class="s4">(</span><span class="s1">py</span><span class="s4">, </span><span class="s1">env</span><span class="s4">)</span>
        <span class="s3">try</span><span class="s4">:</span>
            <span class="s1">env</span><span class="s4">[</span><span class="s1">method</span><span class="s4">].</span><span class="s1">__defaults__ </span><span class="s4">= </span><span class="s1">fn</span><span class="s4">.</span><span class="s1">__defaults__</span>
        <span class="s3">except </span><span class="s1">AttributeError</span><span class="s4">:</span>
            <span class="s3">pass</span>
        <span class="s1">setattr</span><span class="s4">(</span><span class="s1">into_cls</span><span class="s4">, </span><span class="s1">method</span><span class="s4">, </span><span class="s1">env</span><span class="s4">[</span><span class="s1">method</span><span class="s4">])</span>


<span class="s3">def </span><span class="s1">methods_equivalent</span><span class="s4">(</span><span class="s1">meth1</span><span class="s4">, </span><span class="s1">meth2</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Return True if the two methods are the same implementation.&quot;&quot;&quot;</span>

    <span class="s3">return </span><span class="s1">getattr</span><span class="s4">(</span><span class="s1">meth1</span><span class="s4">, </span><span class="s5">&quot;__func__&quot;</span><span class="s4">, </span><span class="s1">meth1</span><span class="s4">) </span><span class="s3">is </span><span class="s1">getattr</span><span class="s4">(</span>
        <span class="s1">meth2</span><span class="s4">, </span><span class="s5">&quot;__func__&quot;</span><span class="s4">, </span><span class="s1">meth2</span>
    <span class="s4">)</span>


<span class="s3">def </span><span class="s1">as_interface</span><span class="s4">(</span><span class="s1">obj</span><span class="s4">, </span><span class="s1">cls</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">methods</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">required</span><span class="s4">=</span><span class="s3">None</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Ensure basic interface compliance for an instance or dict of callables. 
 
    Checks that ``obj`` implements public methods of ``cls`` or has members 
    listed in ``methods``. If ``required`` is not supplied, implementing at 
    least one interface method is sufficient. Methods present on ``obj`` that 
    are not in the interface are ignored. 
 
    If ``obj`` is a dict and ``dict`` does not meet the interface 
    requirements, the keys of the dictionary are inspected. Keys present in 
    ``obj`` that are not in the interface will raise TypeErrors. 
 
    Raises TypeError if ``obj`` does not meet the interface criteria. 
 
    In all passing cases, an object with callable members is returned.  In the 
    simple case, ``obj`` is returned as-is; if dict processing kicks in then 
    an anonymous class is returned. 
 
    obj 
      A type, instance, or dictionary of callables. 
    cls 
      Optional, a type.  All public methods of cls are considered the 
      interface.  An ``obj`` instance of cls will always pass, ignoring 
      ``required``.. 
    methods 
      Optional, a sequence of method names to consider as the interface. 
    required 
      Optional, a sequence of mandatory implementations. If omitted, an 
      ``obj`` that provides at least one interface method is considered 
      sufficient.  As a convenience, required may be a type, in which case 
      all public methods of the type are required. 
 
    &quot;&quot;&quot;</span>
    <span class="s3">if not </span><span class="s1">cls </span><span class="s3">and not </span><span class="s1">methods</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">TypeError</span><span class="s4">(</span><span class="s5">&quot;a class or collection of method names are required&quot;</span><span class="s4">)</span>

    <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">, </span><span class="s1">type</span><span class="s4">) </span><span class="s3">and </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">obj</span><span class="s4">, </span><span class="s1">cls</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">obj</span>

    <span class="s1">interface </span><span class="s4">= </span><span class="s1">set</span><span class="s4">(</span><span class="s1">methods </span><span class="s3">or </span><span class="s4">[</span><span class="s1">m </span><span class="s3">for </span><span class="s1">m </span><span class="s3">in </span><span class="s1">dir</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">) </span><span class="s3">if not </span><span class="s1">m</span><span class="s4">.</span><span class="s1">startswith</span><span class="s4">(</span><span class="s5">&quot;_&quot;</span><span class="s4">)])</span>
    <span class="s1">implemented </span><span class="s4">= </span><span class="s1">set</span><span class="s4">(</span><span class="s1">dir</span><span class="s4">(</span><span class="s1">obj</span><span class="s4">))</span>

    <span class="s1">complies </span><span class="s4">= </span><span class="s1">operator</span><span class="s4">.</span><span class="s1">ge</span>
    <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">required</span><span class="s4">, </span><span class="s1">type</span><span class="s4">):</span>
        <span class="s1">required </span><span class="s4">= </span><span class="s1">interface</span>
    <span class="s3">elif not </span><span class="s1">required</span><span class="s4">:</span>
        <span class="s1">required </span><span class="s4">= </span><span class="s1">set</span><span class="s4">()</span>
        <span class="s1">complies </span><span class="s4">= </span><span class="s1">operator</span><span class="s4">.</span><span class="s1">gt</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">required </span><span class="s4">= </span><span class="s1">set</span><span class="s4">(</span><span class="s1">required</span><span class="s4">)</span>

    <span class="s3">if </span><span class="s1">complies</span><span class="s4">(</span><span class="s1">implemented</span><span class="s4">.</span><span class="s1">intersection</span><span class="s4">(</span><span class="s1">interface</span><span class="s4">), </span><span class="s1">required</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">obj</span>

    <span class="s0"># No dict duck typing here.</span>
    <span class="s3">if not </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">obj</span><span class="s4">, </span><span class="s1">dict</span><span class="s4">):</span>
        <span class="s1">qualifier </span><span class="s4">= </span><span class="s1">complies </span><span class="s3">is </span><span class="s1">operator</span><span class="s4">.</span><span class="s1">gt </span><span class="s3">and </span><span class="s5">&quot;any of&quot; </span><span class="s3">or </span><span class="s5">&quot;all of&quot;</span>
        <span class="s3">raise </span><span class="s1">TypeError</span><span class="s4">(</span>
            <span class="s5">&quot;%r does not implement %s: %s&quot;</span>
            <span class="s4">% (</span><span class="s1">obj</span><span class="s4">, </span><span class="s1">qualifier</span><span class="s4">, </span><span class="s5">&quot;, &quot;</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span><span class="s1">interface</span><span class="s4">))</span>
        <span class="s4">)</span>

    <span class="s3">class </span><span class="s1">AnonymousInterface</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;A callable-holding shell.&quot;&quot;&quot;</span>

    <span class="s3">if </span><span class="s1">cls</span><span class="s4">:</span>
        <span class="s1">AnonymousInterface</span><span class="s4">.</span><span class="s1">__name__ </span><span class="s4">= </span><span class="s5">&quot;Anonymous&quot; </span><span class="s4">+ </span><span class="s1">cls</span><span class="s4">.</span><span class="s1">__name__</span>
    <span class="s1">found </span><span class="s4">= </span><span class="s1">set</span><span class="s4">()</span>

    <span class="s3">for </span><span class="s1">method</span><span class="s4">, </span><span class="s1">impl </span><span class="s3">in </span><span class="s1">dictlike_iteritems</span><span class="s4">(</span><span class="s1">obj</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">method </span><span class="s3">not in </span><span class="s1">interface</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">TypeError</span><span class="s4">(</span><span class="s5">&quot;%r: unknown in this interface&quot; </span><span class="s4">% </span><span class="s1">method</span><span class="s4">)</span>
        <span class="s3">if not </span><span class="s1">callable</span><span class="s4">(</span><span class="s1">impl</span><span class="s4">):</span>
            <span class="s3">raise </span><span class="s1">TypeError</span><span class="s4">(</span><span class="s5">&quot;%r=%r is not callable&quot; </span><span class="s4">% (</span><span class="s1">method</span><span class="s4">, </span><span class="s1">impl</span><span class="s4">))</span>
        <span class="s1">setattr</span><span class="s4">(</span><span class="s1">AnonymousInterface</span><span class="s4">, </span><span class="s1">method</span><span class="s4">, </span><span class="s1">staticmethod</span><span class="s4">(</span><span class="s1">impl</span><span class="s4">))</span>
        <span class="s1">found</span><span class="s4">.</span><span class="s1">add</span><span class="s4">(</span><span class="s1">method</span><span class="s4">)</span>

    <span class="s3">if </span><span class="s1">complies</span><span class="s4">(</span><span class="s1">found</span><span class="s4">, </span><span class="s1">required</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">AnonymousInterface</span>

    <span class="s3">raise </span><span class="s1">TypeError</span><span class="s4">(</span>
        <span class="s5">&quot;dictionary does not contain required keys %s&quot;</span>
        <span class="s4">% </span><span class="s5">&quot;, &quot;</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span><span class="s1">required </span><span class="s4">- </span><span class="s1">found</span><span class="s4">)</span>
    <span class="s4">)</span>


<span class="s1">_GFD </span><span class="s4">= </span><span class="s1">TypeVar</span><span class="s4">(</span><span class="s5">&quot;_GFD&quot;</span><span class="s4">, </span><span class="s1">bound</span><span class="s4">=</span><span class="s5">&quot;generic_fn_descriptor[Any]&quot;</span><span class="s4">)</span>


<span class="s3">class </span><span class="s1">generic_fn_descriptor</span><span class="s4">(</span><span class="s1">Generic</span><span class="s4">[</span><span class="s1">_T_co</span><span class="s4">]):</span>
    <span class="s2">&quot;&quot;&quot;Descriptor which proxies a function when the attribute is not 
    present in dict 
 
    This superclass is organized in a particular way with &quot;memoized&quot; and 
    &quot;non-memoized&quot; implementation classes that are hidden from type checkers, 
    as Mypy seems to not be able to handle seeing multiple kinds of descriptor 
    classes used for the same attribute. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">fget</span><span class="s4">: </span><span class="s1">Callable</span><span class="s4">[..., </span><span class="s1">_T_co</span><span class="s4">]</span>
    <span class="s1">__doc__</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]</span>
    <span class="s1">__name__</span><span class="s4">: </span><span class="s1">str</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">fget</span><span class="s4">: </span><span class="s1">Callable</span><span class="s4">[..., </span><span class="s1">_T_co</span><span class="s4">], </span><span class="s1">doc</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">):</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">fget </span><span class="s4">= </span><span class="s1">fget</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">__doc__ </span><span class="s4">= </span><span class="s1">doc </span><span class="s3">or </span><span class="s1">fget</span><span class="s4">.</span><span class="s1">__doc__</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">__name__ </span><span class="s4">= </span><span class="s1">fget</span><span class="s4">.</span><span class="s1">__name__</span>

    <span class="s4">@</span><span class="s1">overload</span>
    <span class="s3">def </span><span class="s1">__get__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">: </span><span class="s1">_GFD</span><span class="s4">, </span><span class="s1">obj</span><span class="s4">: </span><span class="s3">None</span><span class="s4">, </span><span class="s1">cls</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; _GFD</span><span class="s4">: ...</span>

    <span class="s4">@</span><span class="s1">overload</span>
    <span class="s3">def </span><span class="s1">__get__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">obj</span><span class="s4">: </span><span class="s1">object</span><span class="s4">, </span><span class="s1">cls</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; _T_co</span><span class="s4">: ...</span>

    <span class="s3">def </span><span class="s1">__get__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">: </span><span class="s1">_GFD</span><span class="s4">, </span><span class="s1">obj</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">, </span><span class="s1">cls</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; Union</span><span class="s4">[</span><span class="s1">_GFD</span><span class="s4">, </span><span class="s1">_T_co</span><span class="s4">]:</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">if </span><span class="s1">TYPE_CHECKING</span><span class="s4">:</span>

        <span class="s3">def </span><span class="s1">__set__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">instance</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">, </span><span class="s1">value</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">: ...</span>

        <span class="s3">def </span><span class="s1">__delete__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">instance</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">: ...</span>

    <span class="s3">def </span><span class="s1">_reset</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">obj</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s4">@</span><span class="s1">classmethod</span>
    <span class="s3">def </span><span class="s1">reset</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">, </span><span class="s1">obj</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">, </span><span class="s1">name</span><span class="s4">: </span><span class="s1">str</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>


<span class="s3">class </span><span class="s1">_non_memoized_property</span><span class="s4">(</span><span class="s1">generic_fn_descriptor</span><span class="s4">[</span><span class="s1">_T_co</span><span class="s4">]):</span>
    <span class="s2">&quot;&quot;&quot;a plain descriptor that proxies a function. 
 
    primary rationale is to provide a plain attribute that's 
    compatible with memoized_property which is also recognized as equivalent 
    by mypy. 
 
    &quot;&quot;&quot;</span>

    <span class="s3">if not </span><span class="s1">TYPE_CHECKING</span><span class="s4">:</span>

        <span class="s3">def </span><span class="s1">__get__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">obj</span><span class="s4">, </span><span class="s1">cls</span><span class="s4">):</span>
            <span class="s3">if </span><span class="s1">obj </span><span class="s3">is None</span><span class="s4">:</span>
                <span class="s3">return </span><span class="s1">self</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">fget</span><span class="s4">(</span><span class="s1">obj</span><span class="s4">)</span>


<span class="s3">class </span><span class="s1">_memoized_property</span><span class="s4">(</span><span class="s1">generic_fn_descriptor</span><span class="s4">[</span><span class="s1">_T_co</span><span class="s4">]):</span>
    <span class="s2">&quot;&quot;&quot;A read-only @property that is only evaluated once.&quot;&quot;&quot;</span>

    <span class="s3">if not </span><span class="s1">TYPE_CHECKING</span><span class="s4">:</span>

        <span class="s3">def </span><span class="s1">__get__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">obj</span><span class="s4">, </span><span class="s1">cls</span><span class="s4">):</span>
            <span class="s3">if </span><span class="s1">obj </span><span class="s3">is None</span><span class="s4">:</span>
                <span class="s3">return </span><span class="s1">self</span>
            <span class="s1">obj</span><span class="s4">.</span><span class="s1">__dict__</span><span class="s4">[</span><span class="s1">self</span><span class="s4">.</span><span class="s1">__name__</span><span class="s4">] = </span><span class="s1">result </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">fget</span><span class="s4">(</span><span class="s1">obj</span><span class="s4">)</span>
            <span class="s3">return </span><span class="s1">result</span>

    <span class="s3">def </span><span class="s1">_reset</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">obj</span><span class="s4">):</span>
        <span class="s1">_memoized_property</span><span class="s4">.</span><span class="s1">reset</span><span class="s4">(</span><span class="s1">obj</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">__name__</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">classmethod</span>
    <span class="s3">def </span><span class="s1">reset</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">, </span><span class="s1">obj</span><span class="s4">, </span><span class="s1">name</span><span class="s4">):</span>
        <span class="s1">obj</span><span class="s4">.</span><span class="s1">__dict__</span><span class="s4">.</span><span class="s1">pop</span><span class="s4">(</span><span class="s1">name</span><span class="s4">, </span><span class="s3">None</span><span class="s4">)</span>


<span class="s0"># despite many attempts to get Mypy to recognize an overridden descriptor</span>
<span class="s0"># where one is memoized and the other isn't, there seems to be no reliable</span>
<span class="s0"># way other than completely deceiving the type checker into thinking there</span>
<span class="s0"># is just one single descriptor type everywhere.  Otherwise, if a superclass</span>
<span class="s0"># has non-memoized and subclass has memoized, that requires</span>
<span class="s0"># &quot;class memoized(non_memoized)&quot;.  but then if a superclass has memoized and</span>
<span class="s0"># superclass has non-memoized, the class hierarchy of the descriptors</span>
<span class="s0"># would need to be reversed; &quot;class non_memoized(memoized)&quot;.  so there's no</span>
<span class="s0"># way to achieve this.</span>
<span class="s0"># additional issues, RO properties:</span>
<span class="s0"># https://github.com/python/mypy/issues/12440</span>
<span class="s3">if </span><span class="s1">TYPE_CHECKING</span><span class="s4">:</span>
    <span class="s0"># allow memoized and non-memoized to be freely mixed by having them</span>
    <span class="s0"># be the same class</span>
    <span class="s1">memoized_property </span><span class="s4">= </span><span class="s1">generic_fn_descriptor</span>
    <span class="s1">non_memoized_property </span><span class="s4">= </span><span class="s1">generic_fn_descriptor</span>

    <span class="s0"># for read only situations, mypy only sees @property as read only.</span>
    <span class="s0"># read only is needed when a subtype specializes the return type</span>
    <span class="s0"># of a property, meaning assignment needs to be disallowed</span>
    <span class="s1">ro_memoized_property </span><span class="s4">= </span><span class="s1">property</span>
    <span class="s1">ro_non_memoized_property </span><span class="s4">= </span><span class="s1">property</span>

<span class="s3">else</span><span class="s4">:</span>
    <span class="s1">memoized_property </span><span class="s4">= </span><span class="s1">ro_memoized_property </span><span class="s4">= </span><span class="s1">_memoized_property</span>
    <span class="s1">non_memoized_property </span><span class="s4">= </span><span class="s1">ro_non_memoized_property </span><span class="s4">= </span><span class="s1">_non_memoized_property</span>


<span class="s3">def </span><span class="s1">memoized_instancemethod</span><span class="s4">(</span><span class="s1">fn</span><span class="s4">: </span><span class="s1">_F</span><span class="s4">) </span><span class="s1">-&gt; _F</span><span class="s4">:</span>
    <span class="s2">&quot;&quot;&quot;Decorate a method memoize its return value. 
 
    Best applied to no-arg methods: memoization is not sensitive to 
    argument values, and will always return the same value even when 
    called with different arguments. 
 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">oneshot</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, *</span><span class="s1">args</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s1">result </span><span class="s4">= </span><span class="s1">fn</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, *</span><span class="s1">args</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">)</span>

        <span class="s3">def </span><span class="s1">memo</span><span class="s4">(*</span><span class="s1">a</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
            <span class="s3">return </span><span class="s1">result</span>

        <span class="s1">memo</span><span class="s4">.</span><span class="s1">__name__ </span><span class="s4">= </span><span class="s1">fn</span><span class="s4">.</span><span class="s1">__name__</span>
        <span class="s1">memo</span><span class="s4">.</span><span class="s1">__doc__ </span><span class="s4">= </span><span class="s1">fn</span><span class="s4">.</span><span class="s1">__doc__</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">__dict__</span><span class="s4">[</span><span class="s1">fn</span><span class="s4">.</span><span class="s1">__name__</span><span class="s4">] = </span><span class="s1">memo</span>
        <span class="s3">return </span><span class="s1">result</span>

    <span class="s3">return </span><span class="s1">update_wrapper</span><span class="s4">(</span><span class="s1">oneshot</span><span class="s4">, </span><span class="s1">fn</span><span class="s4">)  </span><span class="s0"># type: ignore</span>


<span class="s3">class </span><span class="s1">HasMemoized</span><span class="s4">:</span>
    <span class="s2">&quot;&quot;&quot;A mixin class that maintains the names of memoized elements in a 
    collection for easy cache clearing, generative, etc. 
 
    &quot;&quot;&quot;</span>

    <span class="s3">if not </span><span class="s1">TYPE_CHECKING</span><span class="s4">:</span>
        <span class="s0"># support classes that want to have __slots__ with an explicit</span>
        <span class="s0"># slot for __dict__.  not sure if that requires base __slots__ here.</span>
        <span class="s1">__slots__ </span><span class="s4">= ()</span>

    <span class="s1">_memoized_keys</span><span class="s4">: </span><span class="s1">FrozenSet</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s1">frozenset</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">_reset_memoizations</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s3">for </span><span class="s1">elem </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_memoized_keys</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">__dict__</span><span class="s4">.</span><span class="s1">pop</span><span class="s4">(</span><span class="s1">elem</span><span class="s4">, </span><span class="s3">None</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_assert_no_memoizations</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s3">for </span><span class="s1">elem </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_memoized_keys</span><span class="s4">:</span>
            <span class="s3">assert </span><span class="s1">elem </span><span class="s3">not in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">__dict__</span>

    <span class="s3">def </span><span class="s1">_set_memoized_attribute</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">key</span><span class="s4">: </span><span class="s1">str</span><span class="s4">, </span><span class="s1">value</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">__dict__</span><span class="s4">[</span><span class="s1">key</span><span class="s4">] = </span><span class="s1">value</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_memoized_keys </span><span class="s4">|= {</span><span class="s1">key</span><span class="s4">}</span>

    <span class="s3">class </span><span class="s1">memoized_attribute</span><span class="s4">(</span><span class="s1">memoized_property</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]):</span>
        <span class="s2">&quot;&quot;&quot;A read-only @property that is only evaluated once. 
 
        :meta private: 
 
        &quot;&quot;&quot;</span>

        <span class="s1">fget</span><span class="s4">: </span><span class="s1">Callable</span><span class="s4">[..., </span><span class="s1">_T</span><span class="s4">]</span>
        <span class="s1">__doc__</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]</span>
        <span class="s1">__name__</span><span class="s4">: </span><span class="s1">str</span>

        <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">fget</span><span class="s4">: </span><span class="s1">Callable</span><span class="s4">[..., </span><span class="s1">_T</span><span class="s4">], </span><span class="s1">doc</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">):</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">fget </span><span class="s4">= </span><span class="s1">fget</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">__doc__ </span><span class="s4">= </span><span class="s1">doc </span><span class="s3">or </span><span class="s1">fget</span><span class="s4">.</span><span class="s1">__doc__</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">__name__ </span><span class="s4">= </span><span class="s1">fget</span><span class="s4">.</span><span class="s1">__name__</span>

        <span class="s4">@</span><span class="s1">overload</span>
        <span class="s3">def </span><span class="s1">__get__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">: </span><span class="s1">_MA</span><span class="s4">, </span><span class="s1">obj</span><span class="s4">: </span><span class="s3">None</span><span class="s4">, </span><span class="s1">cls</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; _MA</span><span class="s4">: ...</span>

        <span class="s4">@</span><span class="s1">overload</span>
        <span class="s3">def </span><span class="s1">__get__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">obj</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">, </span><span class="s1">cls</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; _T</span><span class="s4">: ...</span>

        <span class="s3">def </span><span class="s1">__get__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">obj</span><span class="s4">, </span><span class="s1">cls</span><span class="s4">):</span>
            <span class="s3">if </span><span class="s1">obj </span><span class="s3">is None</span><span class="s4">:</span>
                <span class="s3">return </span><span class="s1">self</span>
            <span class="s1">obj</span><span class="s4">.</span><span class="s1">__dict__</span><span class="s4">[</span><span class="s1">self</span><span class="s4">.</span><span class="s1">__name__</span><span class="s4">] = </span><span class="s1">result </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">fget</span><span class="s4">(</span><span class="s1">obj</span><span class="s4">)</span>
            <span class="s1">obj</span><span class="s4">.</span><span class="s1">_memoized_keys </span><span class="s4">|= {</span><span class="s1">self</span><span class="s4">.</span><span class="s1">__name__</span><span class="s4">}</span>
            <span class="s3">return </span><span class="s1">result</span>

    <span class="s4">@</span><span class="s1">classmethod</span>
    <span class="s3">def </span><span class="s1">memoized_instancemethod</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">, </span><span class="s1">fn</span><span class="s4">: </span><span class="s1">_F</span><span class="s4">) </span><span class="s1">-&gt; _F</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Decorate a method memoize its return value. 
 
        :meta private: 
 
        &quot;&quot;&quot;</span>

        <span class="s3">def </span><span class="s1">oneshot</span><span class="s4">(</span><span class="s1">self</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">, *</span><span class="s1">args</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; Any</span><span class="s4">:</span>
            <span class="s1">result </span><span class="s4">= </span><span class="s1">fn</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, *</span><span class="s1">args</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">)</span>

            <span class="s3">def </span><span class="s1">memo</span><span class="s4">(*</span><span class="s1">a</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
                <span class="s3">return </span><span class="s1">result</span>

            <span class="s1">memo</span><span class="s4">.</span><span class="s1">__name__ </span><span class="s4">= </span><span class="s1">fn</span><span class="s4">.</span><span class="s1">__name__</span>
            <span class="s1">memo</span><span class="s4">.</span><span class="s1">__doc__ </span><span class="s4">= </span><span class="s1">fn</span><span class="s4">.</span><span class="s1">__doc__</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">__dict__</span><span class="s4">[</span><span class="s1">fn</span><span class="s4">.</span><span class="s1">__name__</span><span class="s4">] = </span><span class="s1">memo</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_memoized_keys </span><span class="s4">|= {</span><span class="s1">fn</span><span class="s4">.</span><span class="s1">__name__</span><span class="s4">}</span>
            <span class="s3">return </span><span class="s1">result</span>

        <span class="s3">return </span><span class="s1">update_wrapper</span><span class="s4">(</span><span class="s1">oneshot</span><span class="s4">, </span><span class="s1">fn</span><span class="s4">)  </span><span class="s0"># type: ignore</span>


<span class="s3">if </span><span class="s1">TYPE_CHECKING</span><span class="s4">:</span>
    <span class="s1">HasMemoized_ro_memoized_attribute </span><span class="s4">= </span><span class="s1">property</span>
<span class="s3">else</span><span class="s4">:</span>
    <span class="s1">HasMemoized_ro_memoized_attribute </span><span class="s4">= </span><span class="s1">HasMemoized</span><span class="s4">.</span><span class="s1">memoized_attribute</span>


<span class="s3">class </span><span class="s1">MemoizedSlots</span><span class="s4">:</span>
    <span class="s2">&quot;&quot;&quot;Apply memoized items to an object using a __getattr__ scheme. 
 
    This allows the functionality of memoized_property and 
    memoized_instancemethod to be available to a class using __slots__. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__slots__ </span><span class="s4">= ()</span>

    <span class="s3">def </span><span class="s1">_fallback_getattr</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">key</span><span class="s4">):</span>
        <span class="s3">raise </span><span class="s1">AttributeError</span><span class="s4">(</span><span class="s1">key</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">__getattr__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">key</span><span class="s4">: </span><span class="s1">str</span><span class="s4">) </span><span class="s1">-&gt; Any</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">key</span><span class="s4">.</span><span class="s1">startswith</span><span class="s4">(</span><span class="s5">&quot;_memoized_attr_&quot;</span><span class="s4">) </span><span class="s3">or </span><span class="s1">key</span><span class="s4">.</span><span class="s1">startswith</span><span class="s4">(</span>
            <span class="s5">&quot;_memoized_method_&quot;</span>
        <span class="s4">):</span>
            <span class="s3">raise </span><span class="s1">AttributeError</span><span class="s4">(</span><span class="s1">key</span><span class="s4">)</span>
        <span class="s0"># to avoid recursion errors when interacting with other __getattr__</span>
        <span class="s0"># schemes that refer to this one, when testing for memoized method</span>
        <span class="s0"># look at __class__ only rather than going into __getattr__ again.</span>
        <span class="s3">elif </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">__class__</span><span class="s4">, </span><span class="s5">f&quot;_memoized_attr_</span><span class="s3">{</span><span class="s1">key</span><span class="s3">}</span><span class="s5">&quot;</span><span class="s4">):</span>
            <span class="s1">value </span><span class="s4">= </span><span class="s1">getattr</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s5">f&quot;_memoized_attr_</span><span class="s3">{</span><span class="s1">key</span><span class="s3">}</span><span class="s5">&quot;</span><span class="s4">)()</span>
            <span class="s1">setattr</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">key</span><span class="s4">, </span><span class="s1">value</span><span class="s4">)</span>
            <span class="s3">return </span><span class="s1">value</span>
        <span class="s3">elif </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">__class__</span><span class="s4">, </span><span class="s5">f&quot;_memoized_method_</span><span class="s3">{</span><span class="s1">key</span><span class="s3">}</span><span class="s5">&quot;</span><span class="s4">):</span>
            <span class="s1">fn </span><span class="s4">= </span><span class="s1">getattr</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s5">f&quot;_memoized_method_</span><span class="s3">{</span><span class="s1">key</span><span class="s3">}</span><span class="s5">&quot;</span><span class="s4">)</span>

            <span class="s3">def </span><span class="s1">oneshot</span><span class="s4">(*</span><span class="s1">args</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
                <span class="s1">result </span><span class="s4">= </span><span class="s1">fn</span><span class="s4">(*</span><span class="s1">args</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">)</span>

                <span class="s3">def </span><span class="s1">memo</span><span class="s4">(*</span><span class="s1">a</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
                    <span class="s3">return </span><span class="s1">result</span>

                <span class="s1">memo</span><span class="s4">.</span><span class="s1">__name__ </span><span class="s4">= </span><span class="s1">fn</span><span class="s4">.</span><span class="s1">__name__</span>
                <span class="s1">memo</span><span class="s4">.</span><span class="s1">__doc__ </span><span class="s4">= </span><span class="s1">fn</span><span class="s4">.</span><span class="s1">__doc__</span>
                <span class="s1">setattr</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">key</span><span class="s4">, </span><span class="s1">memo</span><span class="s4">)</span>
                <span class="s3">return </span><span class="s1">result</span>

            <span class="s1">oneshot</span><span class="s4">.</span><span class="s1">__doc__ </span><span class="s4">= </span><span class="s1">fn</span><span class="s4">.</span><span class="s1">__doc__</span>
            <span class="s3">return </span><span class="s1">oneshot</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_fallback_getattr</span><span class="s4">(</span><span class="s1">key</span><span class="s4">)</span>


<span class="s0"># from paste.deploy.converters</span>
<span class="s3">def </span><span class="s1">asbool</span><span class="s4">(</span><span class="s1">obj</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
    <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">obj</span><span class="s4">, </span><span class="s1">str</span><span class="s4">):</span>
        <span class="s1">obj </span><span class="s4">= </span><span class="s1">obj</span><span class="s4">.</span><span class="s1">strip</span><span class="s4">().</span><span class="s1">lower</span><span class="s4">()</span>
        <span class="s3">if </span><span class="s1">obj </span><span class="s3">in </span><span class="s4">[</span><span class="s5">&quot;true&quot;</span><span class="s4">, </span><span class="s5">&quot;yes&quot;</span><span class="s4">, </span><span class="s5">&quot;on&quot;</span><span class="s4">, </span><span class="s5">&quot;y&quot;</span><span class="s4">, </span><span class="s5">&quot;t&quot;</span><span class="s4">, </span><span class="s5">&quot;1&quot;</span><span class="s4">]:</span>
            <span class="s3">return True</span>
        <span class="s3">elif </span><span class="s1">obj </span><span class="s3">in </span><span class="s4">[</span><span class="s5">&quot;false&quot;</span><span class="s4">, </span><span class="s5">&quot;no&quot;</span><span class="s4">, </span><span class="s5">&quot;off&quot;</span><span class="s4">, </span><span class="s5">&quot;n&quot;</span><span class="s4">, </span><span class="s5">&quot;f&quot;</span><span class="s4">, </span><span class="s5">&quot;0&quot;</span><span class="s4">]:</span>
            <span class="s3">return False</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;String is not true/false: %r&quot; </span><span class="s4">% </span><span class="s1">obj</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s1">bool</span><span class="s4">(</span><span class="s1">obj</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">bool_or_str</span><span class="s4">(*</span><span class="s1">text</span><span class="s4">: </span><span class="s1">str</span><span class="s4">) </span><span class="s1">-&gt; Callable</span><span class="s4">[[</span><span class="s1">str</span><span class="s4">], </span><span class="s1">Union</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">bool</span><span class="s4">]]:</span>
    <span class="s2">&quot;&quot;&quot;Return a callable that will evaluate a string as 
    boolean, or one of a set of &quot;alternate&quot; string values. 
 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">bool_or_value</span><span class="s4">(</span><span class="s1">obj</span><span class="s4">: </span><span class="s1">str</span><span class="s4">) </span><span class="s1">-&gt; Union</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">bool</span><span class="s4">]:</span>
        <span class="s3">if </span><span class="s1">obj </span><span class="s3">in </span><span class="s1">text</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">obj</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">asbool</span><span class="s4">(</span><span class="s1">obj</span><span class="s4">)</span>

    <span class="s3">return </span><span class="s1">bool_or_value</span>


<span class="s3">def </span><span class="s1">asint</span><span class="s4">(</span><span class="s1">value</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; Optional</span><span class="s4">[</span><span class="s1">int</span><span class="s4">]:</span>
    <span class="s2">&quot;&quot;&quot;Coerce to integer.&quot;&quot;&quot;</span>

    <span class="s3">if </span><span class="s1">value </span><span class="s3">is None</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">value</span>
    <span class="s3">return </span><span class="s1">int</span><span class="s4">(</span><span class="s1">value</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">coerce_kw_type</span><span class="s4">(</span>
    <span class="s1">kw</span><span class="s4">: </span><span class="s1">Dict</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">Any</span><span class="s4">],</span>
    <span class="s1">key</span><span class="s4">: </span><span class="s1">str</span><span class="s4">,</span>
    <span class="s1">type_</span><span class="s4">: </span><span class="s1">Type</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">],</span>
    <span class="s1">flexi_bool</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">True</span><span class="s4">,</span>
    <span class="s1">dest</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Dict</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">Any</span><span class="s4">]] = </span><span class="s3">None</span><span class="s4">,</span>
<span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
    <span class="s2">r&quot;&quot;&quot;If 'key' is present in dict 'kw', coerce its value to type 'type\_' if 
    necessary.  If 'flexi_bool' is True, the string '0' is considered false 
    when coercing to boolean. 
    &quot;&quot;&quot;</span>

    <span class="s3">if </span><span class="s1">dest </span><span class="s3">is None</span><span class="s4">:</span>
        <span class="s1">dest </span><span class="s4">= </span><span class="s1">kw</span>

    <span class="s3">if </span><span class="s4">(</span>
        <span class="s1">key </span><span class="s3">in </span><span class="s1">kw</span>
        <span class="s3">and </span><span class="s4">(</span><span class="s3">not </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">type_</span><span class="s4">, </span><span class="s1">type</span><span class="s4">) </span><span class="s3">or not </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">kw</span><span class="s4">[</span><span class="s1">key</span><span class="s4">], </span><span class="s1">type_</span><span class="s4">))</span>
        <span class="s3">and </span><span class="s1">kw</span><span class="s4">[</span><span class="s1">key</span><span class="s4">] </span><span class="s3">is not None</span>
    <span class="s4">):</span>
        <span class="s3">if </span><span class="s1">type_ </span><span class="s3">is </span><span class="s1">bool </span><span class="s3">and </span><span class="s1">flexi_bool</span><span class="s4">:</span>
            <span class="s1">dest</span><span class="s4">[</span><span class="s1">key</span><span class="s4">] = </span><span class="s1">asbool</span><span class="s4">(</span><span class="s1">kw</span><span class="s4">[</span><span class="s1">key</span><span class="s4">])</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">dest</span><span class="s4">[</span><span class="s1">key</span><span class="s4">] = </span><span class="s1">type_</span><span class="s4">(</span><span class="s1">kw</span><span class="s4">[</span><span class="s1">key</span><span class="s4">])</span>


<span class="s3">def </span><span class="s1">constructor_key</span><span class="s4">(</span><span class="s1">obj</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">, </span><span class="s1">cls</span><span class="s4">: </span><span class="s1">Type</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]) </span><span class="s1">-&gt; Tuple</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">, ...]:</span>
    <span class="s2">&quot;&quot;&quot;Produce a tuple structure that is cacheable using the __dict__ of 
    obj to retrieve values 
 
    &quot;&quot;&quot;</span>
    <span class="s1">names </span><span class="s4">= </span><span class="s1">get_cls_kwargs</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s4">(</span><span class="s1">cls</span><span class="s4">,) + </span><span class="s1">tuple</span><span class="s4">(</span>
        <span class="s4">(</span><span class="s1">k</span><span class="s4">, </span><span class="s1">obj</span><span class="s4">.</span><span class="s1">__dict__</span><span class="s4">[</span><span class="s1">k</span><span class="s4">]) </span><span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">names </span><span class="s3">if </span><span class="s1">k </span><span class="s3">in </span><span class="s1">obj</span><span class="s4">.</span><span class="s1">__dict__</span>
    <span class="s4">)</span>


<span class="s3">def </span><span class="s1">constructor_copy</span><span class="s4">(</span><span class="s1">obj</span><span class="s4">: </span><span class="s1">_T</span><span class="s4">, </span><span class="s1">cls</span><span class="s4">: </span><span class="s1">Type</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">], *</span><span class="s1">args</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; _T</span><span class="s4">:</span>
    <span class="s2">&quot;&quot;&quot;Instantiate cls using the __dict__ of obj as constructor arguments. 
 
    Uses inspect to match the named arguments of ``cls``. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">names </span><span class="s4">= </span><span class="s1">get_cls_kwargs</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">)</span>
    <span class="s1">kw</span><span class="s4">.</span><span class="s1">update</span><span class="s4">(</span>
        <span class="s4">(</span><span class="s1">k</span><span class="s4">, </span><span class="s1">obj</span><span class="s4">.</span><span class="s1">__dict__</span><span class="s4">[</span><span class="s1">k</span><span class="s4">]) </span><span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">names</span><span class="s4">.</span><span class="s1">difference</span><span class="s4">(</span><span class="s1">kw</span><span class="s4">) </span><span class="s3">if </span><span class="s1">k </span><span class="s3">in </span><span class="s1">obj</span><span class="s4">.</span><span class="s1">__dict__</span>
    <span class="s4">)</span>
    <span class="s3">return </span><span class="s1">cls</span><span class="s4">(*</span><span class="s1">args</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">counter</span><span class="s4">() </span><span class="s1">-&gt; Callable</span><span class="s4">[[], </span><span class="s1">int</span><span class="s4">]:</span>
    <span class="s2">&quot;&quot;&quot;Return a threadsafe counter function.&quot;&quot;&quot;</span>

    <span class="s1">lock </span><span class="s4">= </span><span class="s1">threading</span><span class="s4">.</span><span class="s1">Lock</span><span class="s4">()</span>
    <span class="s1">counter </span><span class="s4">= </span><span class="s1">itertools</span><span class="s4">.</span><span class="s1">count</span><span class="s4">(</span><span class="s6">1</span><span class="s4">)</span>

    <span class="s0"># avoid the 2to3 &quot;next&quot; transformation...</span>
    <span class="s3">def </span><span class="s1">_next</span><span class="s4">():</span>
        <span class="s3">with </span><span class="s1">lock</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">next</span><span class="s4">(</span><span class="s1">counter</span><span class="s4">)</span>

    <span class="s3">return </span><span class="s1">_next</span>


<span class="s3">def </span><span class="s1">duck_type_collection</span><span class="s4">(</span>
    <span class="s1">specimen</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">, </span><span class="s1">default</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Type</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]] = </span><span class="s3">None</span>
<span class="s4">) </span><span class="s1">-&gt; Optional</span><span class="s4">[</span><span class="s1">Type</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]:</span>
    <span class="s2">&quot;&quot;&quot;Given an instance or class, guess if it is or is acting as one of 
    the basic collection types: list, set and dict.  If the __emulates__ 
    property is present, return that preferentially. 
    &quot;&quot;&quot;</span>

    <span class="s3">if </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">specimen</span><span class="s4">, </span><span class="s5">&quot;__emulates__&quot;</span><span class="s4">):</span>
        <span class="s0"># canonicalize set vs sets.Set to a standard: the builtin set</span>
        <span class="s3">if </span><span class="s1">specimen</span><span class="s4">.</span><span class="s1">__emulates__ </span><span class="s3">is not None and </span><span class="s1">issubclass</span><span class="s4">(</span>
            <span class="s1">specimen</span><span class="s4">.</span><span class="s1">__emulates__</span><span class="s4">, </span><span class="s1">set</span>
        <span class="s4">):</span>
            <span class="s3">return </span><span class="s1">set</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">specimen</span><span class="s4">.</span><span class="s1">__emulates__  </span><span class="s0"># type: ignore</span>

    <span class="s1">isa </span><span class="s4">= </span><span class="s1">issubclass </span><span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">specimen</span><span class="s4">, </span><span class="s1">type</span><span class="s4">) </span><span class="s3">else </span><span class="s1">isinstance</span>
    <span class="s3">if </span><span class="s1">isa</span><span class="s4">(</span><span class="s1">specimen</span><span class="s4">, </span><span class="s1">list</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">list</span>
    <span class="s3">elif </span><span class="s1">isa</span><span class="s4">(</span><span class="s1">specimen</span><span class="s4">, </span><span class="s1">set</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">set</span>
    <span class="s3">elif </span><span class="s1">isa</span><span class="s4">(</span><span class="s1">specimen</span><span class="s4">, </span><span class="s1">dict</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">dict</span>

    <span class="s3">if </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">specimen</span><span class="s4">, </span><span class="s5">&quot;append&quot;</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">list</span>
    <span class="s3">elif </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">specimen</span><span class="s4">, </span><span class="s5">&quot;add&quot;</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">set</span>
    <span class="s3">elif </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">specimen</span><span class="s4">, </span><span class="s5">&quot;set&quot;</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">dict</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">default</span>


<span class="s3">def </span><span class="s1">assert_arg_type</span><span class="s4">(</span>
    <span class="s1">arg</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">, </span><span class="s1">argtype</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">Type</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">], ...], </span><span class="s1">Type</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]], </span><span class="s1">name</span><span class="s4">: </span><span class="s1">str</span>
<span class="s4">) </span><span class="s1">-&gt; Any</span><span class="s4">:</span>
    <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">arg</span><span class="s4">, </span><span class="s1">argtype</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">arg</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">argtype</span><span class="s4">, </span><span class="s1">tuple</span><span class="s4">):</span>
            <span class="s3">raise </span><span class="s1">exc</span><span class="s4">.</span><span class="s1">ArgumentError</span><span class="s4">(</span>
                <span class="s5">&quot;Argument '%s' is expected to be one of type %s, got '%s'&quot;</span>
                <span class="s4">% (</span><span class="s1">name</span><span class="s4">, </span><span class="s5">&quot; or &quot;</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span><span class="s5">&quot;'%s'&quot; </span><span class="s4">% </span><span class="s1">a </span><span class="s3">for </span><span class="s1">a </span><span class="s3">in </span><span class="s1">argtype</span><span class="s4">), </span><span class="s1">type</span><span class="s4">(</span><span class="s1">arg</span><span class="s4">))</span>
            <span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">exc</span><span class="s4">.</span><span class="s1">ArgumentError</span><span class="s4">(</span>
                <span class="s5">&quot;Argument '%s' is expected to be of type '%s', got '%s'&quot;</span>
                <span class="s4">% (</span><span class="s1">name</span><span class="s4">, </span><span class="s1">argtype</span><span class="s4">, </span><span class="s1">type</span><span class="s4">(</span><span class="s1">arg</span><span class="s4">))</span>
            <span class="s4">)</span>


<span class="s3">def </span><span class="s1">dictlike_iteritems</span><span class="s4">(</span><span class="s1">dictlike</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Return a (key, value) iterator for almost any dict-like object.&quot;&quot;&quot;</span>

    <span class="s3">if </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">dictlike</span><span class="s4">, </span><span class="s5">&quot;items&quot;</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">list</span><span class="s4">(</span><span class="s1">dictlike</span><span class="s4">.</span><span class="s1">items</span><span class="s4">())</span>

    <span class="s1">getter </span><span class="s4">= </span><span class="s1">getattr</span><span class="s4">(</span><span class="s1">dictlike</span><span class="s4">, </span><span class="s5">&quot;__getitem__&quot;</span><span class="s4">, </span><span class="s1">getattr</span><span class="s4">(</span><span class="s1">dictlike</span><span class="s4">, </span><span class="s5">&quot;get&quot;</span><span class="s4">, </span><span class="s3">None</span><span class="s4">))</span>
    <span class="s3">if </span><span class="s1">getter </span><span class="s3">is None</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">TypeError</span><span class="s4">(</span><span class="s5">&quot;Object '%r' is not dict-like&quot; </span><span class="s4">% </span><span class="s1">dictlike</span><span class="s4">)</span>

    <span class="s3">if </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">dictlike</span><span class="s4">, </span><span class="s5">&quot;iterkeys&quot;</span><span class="s4">):</span>

        <span class="s3">def </span><span class="s1">iterator</span><span class="s4">():</span>
            <span class="s3">for </span><span class="s1">key </span><span class="s3">in </span><span class="s1">dictlike</span><span class="s4">.</span><span class="s1">iterkeys</span><span class="s4">():</span>
                <span class="s3">assert </span><span class="s1">getter </span><span class="s3">is not None</span>
                <span class="s3">yield </span><span class="s1">key</span><span class="s4">, </span><span class="s1">getter</span><span class="s4">(</span><span class="s1">key</span><span class="s4">)</span>

        <span class="s3">return </span><span class="s1">iterator</span><span class="s4">()</span>
    <span class="s3">elif </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">dictlike</span><span class="s4">, </span><span class="s5">&quot;keys&quot;</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">iter</span><span class="s4">((</span><span class="s1">key</span><span class="s4">, </span><span class="s1">getter</span><span class="s4">(</span><span class="s1">key</span><span class="s4">)) </span><span class="s3">for </span><span class="s1">key </span><span class="s3">in </span><span class="s1">dictlike</span><span class="s4">.</span><span class="s1">keys</span><span class="s4">())</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">TypeError</span><span class="s4">(</span><span class="s5">&quot;Object '%r' is not dict-like&quot; </span><span class="s4">% </span><span class="s1">dictlike</span><span class="s4">)</span>


<span class="s3">class </span><span class="s1">classproperty</span><span class="s4">(</span><span class="s1">property</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;A decorator that behaves like @property except that operates 
    on classes rather than instances. 
 
    The decorator is currently special when using the declarative 
    module, but note that the 
    :class:`~.sqlalchemy.ext.declarative.declared_attr` 
    decorator should be used for this purpose with declarative. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">fget</span><span class="s4">: </span><span class="s1">Callable</span><span class="s4">[[</span><span class="s1">Any</span><span class="s4">], </span><span class="s1">Any</span><span class="s4">]</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">fget</span><span class="s4">: </span><span class="s1">Callable</span><span class="s4">[[</span><span class="s1">Any</span><span class="s4">], </span><span class="s1">Any</span><span class="s4">], *</span><span class="s1">arg</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">):</span>
        <span class="s1">super</span><span class="s4">().</span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">fget</span><span class="s4">, *</span><span class="s1">arg</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">__doc__ </span><span class="s4">= </span><span class="s1">fget</span><span class="s4">.</span><span class="s1">__doc__</span>

    <span class="s3">def </span><span class="s1">__get__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">obj</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">, </span><span class="s1">cls</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">type</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">) </span><span class="s1">-&gt; Any</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">fget</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">)</span>


<span class="s3">class </span><span class="s1">hybridproperty</span><span class="s4">(</span><span class="s1">Generic</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]):</span>
    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">func</span><span class="s4">: </span><span class="s1">Callable</span><span class="s4">[..., </span><span class="s1">_T</span><span class="s4">]):</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">func </span><span class="s4">= </span><span class="s1">func</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">clslevel </span><span class="s4">= </span><span class="s1">func</span>

    <span class="s3">def </span><span class="s1">__get__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">instance</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">, </span><span class="s1">owner</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; _T</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">instance </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s1">clsval </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">clslevel</span><span class="s4">(</span><span class="s1">owner</span><span class="s4">)</span>
            <span class="s3">return </span><span class="s1">clsval</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">func</span><span class="s4">(</span><span class="s1">instance</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">classlevel</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">func</span><span class="s4">: </span><span class="s1">Callable</span><span class="s4">[..., </span><span class="s1">Any</span><span class="s4">]) </span><span class="s1">-&gt; hybridproperty</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]:</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">clslevel </span><span class="s4">= </span><span class="s1">func</span>
        <span class="s3">return </span><span class="s1">self</span>


<span class="s3">class </span><span class="s1">rw_hybridproperty</span><span class="s4">(</span><span class="s1">Generic</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]):</span>
    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">func</span><span class="s4">: </span><span class="s1">Callable</span><span class="s4">[..., </span><span class="s1">_T</span><span class="s4">]):</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">func </span><span class="s4">= </span><span class="s1">func</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">clslevel </span><span class="s4">= </span><span class="s1">func</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">setfn</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Callable</span><span class="s4">[..., </span><span class="s1">Any</span><span class="s4">]] = </span><span class="s3">None</span>

    <span class="s3">def </span><span class="s1">__get__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">instance</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">, </span><span class="s1">owner</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; _T</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">instance </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s1">clsval </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">clslevel</span><span class="s4">(</span><span class="s1">owner</span><span class="s4">)</span>
            <span class="s3">return </span><span class="s1">clsval</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">func</span><span class="s4">(</span><span class="s1">instance</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">__set__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">instance</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">, </span><span class="s1">value</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s3">assert </span><span class="s1">self</span><span class="s4">.</span><span class="s1">setfn </span><span class="s3">is not None</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">setfn</span><span class="s4">(</span><span class="s1">instance</span><span class="s4">, </span><span class="s1">value</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">setter</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">func</span><span class="s4">: </span><span class="s1">Callable</span><span class="s4">[..., </span><span class="s1">Any</span><span class="s4">]) </span><span class="s1">-&gt; rw_hybridproperty</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]:</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">setfn </span><span class="s4">= </span><span class="s1">func</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">classlevel</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">func</span><span class="s4">: </span><span class="s1">Callable</span><span class="s4">[..., </span><span class="s1">Any</span><span class="s4">]) </span><span class="s1">-&gt; rw_hybridproperty</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]:</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">clslevel </span><span class="s4">= </span><span class="s1">func</span>
        <span class="s3">return </span><span class="s1">self</span>


<span class="s3">class </span><span class="s1">hybridmethod</span><span class="s4">(</span><span class="s1">Generic</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]):</span>
    <span class="s2">&quot;&quot;&quot;Decorate a function as cls- or instance- level.&quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">func</span><span class="s4">: </span><span class="s1">Callable</span><span class="s4">[..., </span><span class="s1">_T</span><span class="s4">]):</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">func </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">__func__ </span><span class="s4">= </span><span class="s1">func</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">clslevel </span><span class="s4">= </span><span class="s1">func</span>

    <span class="s3">def </span><span class="s1">__get__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">instance</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">, </span><span class="s1">owner</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; Callable</span><span class="s4">[..., </span><span class="s1">_T</span><span class="s4">]:</span>
        <span class="s3">if </span><span class="s1">instance </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">clslevel</span><span class="s4">.</span><span class="s1">__get__</span><span class="s4">(</span><span class="s1">owner</span><span class="s4">, </span><span class="s1">owner</span><span class="s4">.</span><span class="s1">__class__</span><span class="s4">)  </span><span class="s0"># type:ignore</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">func</span><span class="s4">.</span><span class="s1">__get__</span><span class="s4">(</span><span class="s1">instance</span><span class="s4">, </span><span class="s1">owner</span><span class="s4">)  </span><span class="s0"># type:ignore</span>

    <span class="s3">def </span><span class="s1">classlevel</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">func</span><span class="s4">: </span><span class="s1">Callable</span><span class="s4">[..., </span><span class="s1">Any</span><span class="s4">]) </span><span class="s1">-&gt; hybridmethod</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]:</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">clslevel </span><span class="s4">= </span><span class="s1">func</span>
        <span class="s3">return </span><span class="s1">self</span>


<span class="s3">class </span><span class="s1">symbol</span><span class="s4">(</span><span class="s1">int</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;A constant symbol. 
 
    &gt;&gt;&gt; symbol('foo') is symbol('foo') 
    True 
    &gt;&gt;&gt; symbol('foo') 
    &lt;symbol 'foo&gt; 
 
    A slight refinement of the MAGICCOOKIE=object() pattern.  The primary 
    advantage of symbol() is its repr().  They are also singletons. 
 
    Repeated calls of symbol('name') will all return the same instance. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">name</span><span class="s4">: </span><span class="s1">str</span>

    <span class="s1">symbols</span><span class="s4">: </span><span class="s1">Dict</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">symbol</span><span class="s4">] = {}</span>
    <span class="s1">_lock </span><span class="s4">= </span><span class="s1">threading</span><span class="s4">.</span><span class="s1">Lock</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">__new__</span><span class="s4">(</span>
        <span class="s1">cls</span><span class="s4">,</span>
        <span class="s1">name</span><span class="s4">: </span><span class="s1">str</span><span class="s4">,</span>
        <span class="s1">doc</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">canonical</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">int</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; symbol</span><span class="s4">:</span>
        <span class="s3">with </span><span class="s1">cls</span><span class="s4">.</span><span class="s1">_lock</span><span class="s4">:</span>
            <span class="s1">sym </span><span class="s4">= </span><span class="s1">cls</span><span class="s4">.</span><span class="s1">symbols</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s1">name</span><span class="s4">)</span>
            <span class="s3">if </span><span class="s1">sym </span><span class="s3">is None</span><span class="s4">:</span>
                <span class="s3">assert </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">name</span><span class="s4">, </span><span class="s1">str</span><span class="s4">)</span>
                <span class="s3">if </span><span class="s1">canonical </span><span class="s3">is None</span><span class="s4">:</span>
                    <span class="s1">canonical </span><span class="s4">= </span><span class="s1">hash</span><span class="s4">(</span><span class="s1">name</span><span class="s4">)</span>
                <span class="s1">sym </span><span class="s4">= </span><span class="s1">int</span><span class="s4">.</span><span class="s1">__new__</span><span class="s4">(</span><span class="s1">symbol</span><span class="s4">, </span><span class="s1">canonical</span><span class="s4">)</span>
                <span class="s1">sym</span><span class="s4">.</span><span class="s1">name </span><span class="s4">= </span><span class="s1">name</span>
                <span class="s3">if </span><span class="s1">doc</span><span class="s4">:</span>
                    <span class="s1">sym</span><span class="s4">.</span><span class="s1">__doc__ </span><span class="s4">= </span><span class="s1">doc</span>

                <span class="s0"># NOTE: we should ultimately get rid of this global thing,</span>
                <span class="s0"># however, currently it is to support pickling.  The best</span>
                <span class="s0"># change would be when we are on py3.11 at a minimum, we</span>
                <span class="s0"># switch to stdlib enum.IntFlag.</span>
                <span class="s1">cls</span><span class="s4">.</span><span class="s1">symbols</span><span class="s4">[</span><span class="s1">name</span><span class="s4">] = </span><span class="s1">sym</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s3">if </span><span class="s1">canonical </span><span class="s3">and </span><span class="s1">canonical </span><span class="s4">!= </span><span class="s1">sym</span><span class="s4">:</span>
                    <span class="s3">raise </span><span class="s1">TypeError</span><span class="s4">(</span>
                        <span class="s5">f&quot;Can't replace canonical symbol for </span><span class="s3">{</span><span class="s1">name</span><span class="s3">!r} </span><span class="s5">&quot;</span>
                        <span class="s5">f&quot;with new int value </span><span class="s3">{</span><span class="s1">canonical</span><span class="s3">}</span><span class="s5">&quot;</span>
                    <span class="s4">)</span>
            <span class="s3">return </span><span class="s1">sym</span>

    <span class="s3">def </span><span class="s1">__reduce__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">symbol</span><span class="s4">, (</span><span class="s1">self</span><span class="s4">.</span><span class="s1">name</span><span class="s4">, </span><span class="s5">&quot;x&quot;</span><span class="s4">, </span><span class="s1">int</span><span class="s4">(</span><span class="s1">self</span><span class="s4">))</span>

    <span class="s3">def </span><span class="s1">__str__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">repr</span><span class="s4">(</span><span class="s1">self</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">__repr__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s5">f&quot;symbol(</span><span class="s3">{</span><span class="s1">self</span><span class="s4">.</span><span class="s1">name</span><span class="s3">!r}</span><span class="s5">)&quot;</span>


<span class="s3">class </span><span class="s1">_IntFlagMeta</span><span class="s4">(</span><span class="s1">type</span><span class="s4">):</span>
    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span>
        <span class="s1">cls</span><span class="s4">,</span>
        <span class="s1">classname</span><span class="s4">: </span><span class="s1">str</span><span class="s4">,</span>
        <span class="s1">bases</span><span class="s4">: </span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">Type</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">], ...],</span>
        <span class="s1">dict_</span><span class="s4">: </span><span class="s1">Dict</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">Any</span><span class="s4">],</span>
        <span class="s4">**</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s1">items</span><span class="s4">: </span><span class="s1">List</span><span class="s4">[</span><span class="s1">symbol</span><span class="s4">]</span>
        <span class="s1">cls</span><span class="s4">.</span><span class="s1">_items </span><span class="s4">= </span><span class="s1">items </span><span class="s4">= []</span>
        <span class="s3">for </span><span class="s1">k</span><span class="s4">, </span><span class="s1">v </span><span class="s3">in </span><span class="s1">dict_</span><span class="s4">.</span><span class="s1">items</span><span class="s4">():</span>
            <span class="s3">if </span><span class="s1">re</span><span class="s4">.</span><span class="s1">match</span><span class="s4">(</span><span class="s5">r&quot;^__.*__$&quot;</span><span class="s4">, </span><span class="s1">k</span><span class="s4">):</span>
                <span class="s3">continue</span>
            <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">v</span><span class="s4">, </span><span class="s1">int</span><span class="s4">):</span>
                <span class="s1">sym </span><span class="s4">= </span><span class="s1">symbol</span><span class="s4">(</span><span class="s1">k</span><span class="s4">, </span><span class="s1">canonical</span><span class="s4">=</span><span class="s1">v</span><span class="s4">)</span>
            <span class="s3">elif not </span><span class="s1">k</span><span class="s4">.</span><span class="s1">startswith</span><span class="s4">(</span><span class="s5">&quot;_&quot;</span><span class="s4">):</span>
                <span class="s3">raise </span><span class="s1">TypeError</span><span class="s4">(</span><span class="s5">&quot;Expected integer values for IntFlag&quot;</span><span class="s4">)</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s3">continue</span>
            <span class="s1">setattr</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">, </span><span class="s1">k</span><span class="s4">, </span><span class="s1">sym</span><span class="s4">)</span>
            <span class="s1">items</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">sym</span><span class="s4">)</span>

        <span class="s1">cls</span><span class="s4">.</span><span class="s1">__members__ </span><span class="s4">= </span><span class="s1">_collections</span><span class="s4">.</span><span class="s1">immutabledict</span><span class="s4">(</span>
            <span class="s4">{</span><span class="s1">sym</span><span class="s4">.</span><span class="s1">name</span><span class="s4">: </span><span class="s1">sym </span><span class="s3">for </span><span class="s1">sym </span><span class="s3">in </span><span class="s1">items</span><span class="s4">}</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">__iter__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Iterator</span><span class="s4">[</span><span class="s1">symbol</span><span class="s4">]:</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">(</span>
            <span class="s5">&quot;iter not implemented to ensure compatibility with &quot;</span>
            <span class="s5">&quot;Python 3.11 IntFlag.  Please use __members__.  See &quot;</span>
            <span class="s5">&quot;https://github.com/python/cpython/issues/99304&quot;</span>
        <span class="s4">)</span>


<span class="s3">class </span><span class="s1">_FastIntFlag</span><span class="s4">(</span><span class="s1">metaclass</span><span class="s4">=</span><span class="s1">_IntFlagMeta</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;An 'IntFlag' copycat that isn't slow when performing bitwise 
    operations. 
 
    the ``FastIntFlag`` class will return ``enum.IntFlag`` under TYPE_CHECKING 
    and ``_FastIntFlag`` otherwise. 
 
    &quot;&quot;&quot;</span>


<span class="s3">if </span><span class="s1">TYPE_CHECKING</span><span class="s4">:</span>
    <span class="s3">from </span><span class="s1">enum </span><span class="s3">import </span><span class="s1">IntFlag</span>

    <span class="s1">FastIntFlag </span><span class="s4">= </span><span class="s1">IntFlag</span>
<span class="s3">else</span><span class="s4">:</span>
    <span class="s1">FastIntFlag </span><span class="s4">= </span><span class="s1">_FastIntFlag</span>


<span class="s1">_E </span><span class="s4">= </span><span class="s1">TypeVar</span><span class="s4">(</span><span class="s5">&quot;_E&quot;</span><span class="s4">, </span><span class="s1">bound</span><span class="s4">=</span><span class="s1">enum</span><span class="s4">.</span><span class="s1">Enum</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">parse_user_argument_for_enum</span><span class="s4">(</span>
    <span class="s1">arg</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
    <span class="s1">choices</span><span class="s4">: </span><span class="s1">Dict</span><span class="s4">[</span><span class="s1">_E</span><span class="s4">, </span><span class="s1">List</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]],</span>
    <span class="s1">name</span><span class="s4">: </span><span class="s1">str</span><span class="s4">,</span>
    <span class="s1">resolve_symbol_names</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
<span class="s4">) </span><span class="s1">-&gt; Optional</span><span class="s4">[</span><span class="s1">_E</span><span class="s4">]:</span>
    <span class="s2">&quot;&quot;&quot;Given a user parameter, parse the parameter into a chosen value 
    from a list of choice objects, typically Enum values. 
 
    The user argument can be a string name that matches the name of a 
    symbol, or the symbol object itself, or any number of alternate choices 
    such as True/False/ None etc. 
 
    :param arg: the user argument. 
    :param choices: dictionary of enum values to lists of possible 
        entries for each. 
    :param name: name of the argument.   Used in an :class:`.ArgumentError` 
        that is raised if the parameter doesn't match any available argument. 
 
    &quot;&quot;&quot;</span>
    <span class="s3">for </span><span class="s1">enum_value</span><span class="s4">, </span><span class="s1">choice </span><span class="s3">in </span><span class="s1">choices</span><span class="s4">.</span><span class="s1">items</span><span class="s4">():</span>
        <span class="s3">if </span><span class="s1">arg </span><span class="s3">is </span><span class="s1">enum_value</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">enum_value</span>
        <span class="s3">elif </span><span class="s1">resolve_symbol_names </span><span class="s3">and </span><span class="s1">arg </span><span class="s4">== </span><span class="s1">enum_value</span><span class="s4">.</span><span class="s1">name</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">enum_value</span>
        <span class="s3">elif </span><span class="s1">arg </span><span class="s3">in </span><span class="s1">choice</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">enum_value</span>

    <span class="s3">if </span><span class="s1">arg </span><span class="s3">is None</span><span class="s4">:</span>
        <span class="s3">return None</span>

    <span class="s3">raise </span><span class="s1">exc</span><span class="s4">.</span><span class="s1">ArgumentError</span><span class="s4">(</span><span class="s5">f&quot;Invalid value for '</span><span class="s3">{</span><span class="s1">name</span><span class="s3">}</span><span class="s5">': </span><span class="s3">{</span><span class="s1">arg</span><span class="s3">!r}</span><span class="s5">&quot;</span><span class="s4">)</span>


<span class="s1">_creation_order </span><span class="s4">= </span><span class="s6">1</span>


<span class="s3">def </span><span class="s1">set_creation_order</span><span class="s4">(</span><span class="s1">instance</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
    <span class="s2">&quot;&quot;&quot;Assign a '_creation_order' sequence to the given instance. 
 
    This allows multiple instances to be sorted in order of creation 
    (typically within a single thread; the counter is not particularly 
    threadsafe). 
 
    &quot;&quot;&quot;</span>
    <span class="s3">global </span><span class="s1">_creation_order</span>
    <span class="s1">instance</span><span class="s4">.</span><span class="s1">_creation_order </span><span class="s4">= </span><span class="s1">_creation_order</span>
    <span class="s1">_creation_order </span><span class="s4">+= </span><span class="s6">1</span>


<span class="s3">def </span><span class="s1">warn_exception</span><span class="s4">(</span><span class="s1">func</span><span class="s4">: </span><span class="s1">Callable</span><span class="s4">[..., </span><span class="s1">Any</span><span class="s4">], *</span><span class="s1">args</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">, **</span><span class="s1">kwargs</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; Any</span><span class="s4">:</span>
    <span class="s2">&quot;&quot;&quot;executes the given function, catches all exceptions and converts to 
    a warning. 
 
    &quot;&quot;&quot;</span>
    <span class="s3">try</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">func</span><span class="s4">(*</span><span class="s1">args</span><span class="s4">, **</span><span class="s1">kwargs</span><span class="s4">)</span>
    <span class="s3">except </span><span class="s1">Exception</span><span class="s4">:</span>
        <span class="s1">warn</span><span class="s4">(</span><span class="s5">&quot;%s('%s') ignored&quot; </span><span class="s4">% </span><span class="s1">sys</span><span class="s4">.</span><span class="s1">exc_info</span><span class="s4">()[</span><span class="s6">0</span><span class="s4">:</span><span class="s6">2</span><span class="s4">])</span>


<span class="s3">def </span><span class="s1">ellipses_string</span><span class="s4">(</span><span class="s1">value</span><span class="s4">, </span><span class="s1">len_</span><span class="s4">=</span><span class="s6">25</span><span class="s4">):</span>
    <span class="s3">try</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">value</span><span class="s4">) &gt; </span><span class="s1">len_</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s5">&quot;%s...&quot; </span><span class="s4">% </span><span class="s1">value</span><span class="s4">[</span><span class="s6">0</span><span class="s4">:</span><span class="s1">len_</span><span class="s4">]</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">value</span>
    <span class="s3">except </span><span class="s1">TypeError</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">value</span>


<span class="s3">class </span><span class="s1">_hash_limit_string</span><span class="s4">(</span><span class="s1">str</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;A string subclass that can only be hashed on a maximum amount 
    of unique values. 
 
    This is used for warnings so that we can send out parameterized warnings 
    without the __warningregistry__ of the module,  or the non-overridable 
    &quot;once&quot; registry within warnings.py, overloading memory, 
 
 
    &quot;&quot;&quot;</span>

    <span class="s1">_hash</span><span class="s4">: </span><span class="s1">int</span>

    <span class="s3">def </span><span class="s1">__new__</span><span class="s4">(</span>
        <span class="s1">cls</span><span class="s4">, </span><span class="s1">value</span><span class="s4">: </span><span class="s1">str</span><span class="s4">, </span><span class="s1">num</span><span class="s4">: </span><span class="s1">int</span><span class="s4">, </span><span class="s1">args</span><span class="s4">: </span><span class="s1">Sequence</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]</span>
    <span class="s4">) </span><span class="s1">-&gt; _hash_limit_string</span><span class="s4">:</span>
        <span class="s1">interpolated </span><span class="s4">= (</span><span class="s1">value </span><span class="s4">% </span><span class="s1">args</span><span class="s4">) + (</span>
            <span class="s5">&quot; (this warning may be suppressed after %d occurrences)&quot; </span><span class="s4">% </span><span class="s1">num</span>
        <span class="s4">)</span>
        <span class="s1">self </span><span class="s4">= </span><span class="s1">super</span><span class="s4">().</span><span class="s1">__new__</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">, </span><span class="s1">interpolated</span><span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_hash </span><span class="s4">= </span><span class="s1">hash</span><span class="s4">(</span><span class="s5">&quot;%s_%d&quot; </span><span class="s4">% (</span><span class="s1">value</span><span class="s4">, </span><span class="s1">hash</span><span class="s4">(</span><span class="s1">interpolated</span><span class="s4">) % </span><span class="s1">num</span><span class="s4">))</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">__hash__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; int</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_hash</span>

    <span class="s3">def </span><span class="s1">__eq__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">hash</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) == </span><span class="s1">hash</span><span class="s4">(</span><span class="s1">other</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">warn</span><span class="s4">(</span><span class="s1">msg</span><span class="s4">: </span><span class="s1">str</span><span class="s4">, </span><span class="s1">code</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
    <span class="s2">&quot;&quot;&quot;Issue a warning. 
 
    If msg is a string, :class:`.exc.SAWarning` is used as 
    the category. 
 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">code</span><span class="s4">:</span>
        <span class="s1">_warnings_warn</span><span class="s4">(</span><span class="s1">exc</span><span class="s4">.</span><span class="s1">SAWarning</span><span class="s4">(</span><span class="s1">msg</span><span class="s4">, </span><span class="s1">code</span><span class="s4">=</span><span class="s1">code</span><span class="s4">))</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">_warnings_warn</span><span class="s4">(</span><span class="s1">msg</span><span class="s4">, </span><span class="s1">exc</span><span class="s4">.</span><span class="s1">SAWarning</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">warn_limited</span><span class="s4">(</span><span class="s1">msg</span><span class="s4">: </span><span class="s1">str</span><span class="s4">, </span><span class="s1">args</span><span class="s4">: </span><span class="s1">Sequence</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
    <span class="s2">&quot;&quot;&quot;Issue a warning with a parameterized string, limiting the number 
    of registrations. 
 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">args</span><span class="s4">:</span>
        <span class="s1">msg </span><span class="s4">= </span><span class="s1">_hash_limit_string</span><span class="s4">(</span><span class="s1">msg</span><span class="s4">, </span><span class="s6">10</span><span class="s4">, </span><span class="s1">args</span><span class="s4">)</span>
    <span class="s1">_warnings_warn</span><span class="s4">(</span><span class="s1">msg</span><span class="s4">, </span><span class="s1">exc</span><span class="s4">.</span><span class="s1">SAWarning</span><span class="s4">)</span>


<span class="s1">_warning_tags</span><span class="s4">: </span><span class="s1">Dict</span><span class="s4">[</span><span class="s1">CodeType</span><span class="s4">, </span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">Type</span><span class="s4">[</span><span class="s1">Warning</span><span class="s4">]]] = {}</span>


<span class="s3">def </span><span class="s1">tag_method_for_warnings</span><span class="s4">(</span>
    <span class="s1">message</span><span class="s4">: </span><span class="s1">str</span><span class="s4">, </span><span class="s1">category</span><span class="s4">: </span><span class="s1">Type</span><span class="s4">[</span><span class="s1">Warning</span><span class="s4">]</span>
<span class="s4">) </span><span class="s1">-&gt; Callable</span><span class="s4">[[</span><span class="s1">_F</span><span class="s4">], </span><span class="s1">_F</span><span class="s4">]:</span>
    <span class="s3">def </span><span class="s1">go</span><span class="s4">(</span><span class="s1">fn</span><span class="s4">):</span>
        <span class="s1">_warning_tags</span><span class="s4">[</span><span class="s1">fn</span><span class="s4">.</span><span class="s1">__code__</span><span class="s4">] = (</span><span class="s1">message</span><span class="s4">, </span><span class="s1">category</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">fn</span>

    <span class="s3">return </span><span class="s1">go</span>


<span class="s1">_not_sa_pattern </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span><span class="s5">r&quot;^(?:sqlalchemy\.(?!testing)|alembic\.)&quot;</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">_warnings_warn</span><span class="s4">(</span>
    <span class="s1">message</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">Warning</span><span class="s4">],</span>
    <span class="s1">category</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Type</span><span class="s4">[</span><span class="s1">Warning</span><span class="s4">]] = </span><span class="s3">None</span><span class="s4">,</span>
    <span class="s1">stacklevel</span><span class="s4">: </span><span class="s1">int </span><span class="s4">= </span><span class="s6">2</span><span class="s4">,</span>
<span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
    <span class="s0"># adjust the given stacklevel to be outside of SQLAlchemy</span>
    <span class="s3">try</span><span class="s4">:</span>
        <span class="s1">frame </span><span class="s4">= </span><span class="s1">sys</span><span class="s4">.</span><span class="s1">_getframe</span><span class="s4">(</span><span class="s1">stacklevel</span><span class="s4">)</span>
    <span class="s3">except </span><span class="s1">ValueError</span><span class="s4">:</span>
        <span class="s0"># being called from less than 3 (or given) stacklevels, weird,</span>
        <span class="s0"># but don't crash</span>
        <span class="s1">stacklevel </span><span class="s4">= </span><span class="s6">0</span>
    <span class="s3">except</span><span class="s4">:</span>
        <span class="s0"># _getframe() doesn't work, weird interpreter issue, weird,</span>
        <span class="s0"># ok, but don't crash</span>
        <span class="s1">stacklevel </span><span class="s4">= </span><span class="s6">0</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">stacklevel_found </span><span class="s4">= </span><span class="s1">warning_tag_found </span><span class="s4">= </span><span class="s3">False</span>
        <span class="s3">while </span><span class="s1">frame </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s0"># using __name__ here requires that we have __name__ in the</span>
            <span class="s0"># __globals__ of the decorated string functions we make also.</span>
            <span class="s0"># we generate this using {&quot;__name__&quot;: fn.__module__}</span>
            <span class="s3">if not </span><span class="s1">stacklevel_found </span><span class="s3">and not </span><span class="s1">re</span><span class="s4">.</span><span class="s1">match</span><span class="s4">(</span>
                <span class="s1">_not_sa_pattern</span><span class="s4">, </span><span class="s1">frame</span><span class="s4">.</span><span class="s1">f_globals</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s5">&quot;__name__&quot;</span><span class="s4">, </span><span class="s5">&quot;&quot;</span><span class="s4">)</span>
            <span class="s4">):</span>
                <span class="s0"># stop incrementing stack level if an out-of-SQLA line</span>
                <span class="s0"># were found.</span>
                <span class="s1">stacklevel_found </span><span class="s4">= </span><span class="s3">True</span>

                <span class="s0"># however, for the warning tag thing, we have to keep</span>
                <span class="s0"># scanning up the whole traceback</span>

            <span class="s3">if </span><span class="s1">frame</span><span class="s4">.</span><span class="s1">f_code </span><span class="s3">in </span><span class="s1">_warning_tags</span><span class="s4">:</span>
                <span class="s1">warning_tag_found </span><span class="s4">= </span><span class="s3">True</span>
                <span class="s4">(</span><span class="s1">_suffix</span><span class="s4">, </span><span class="s1">_category</span><span class="s4">) = </span><span class="s1">_warning_tags</span><span class="s4">[</span><span class="s1">frame</span><span class="s4">.</span><span class="s1">f_code</span><span class="s4">]</span>
                <span class="s1">category </span><span class="s4">= </span><span class="s1">category </span><span class="s3">or </span><span class="s1">_category</span>
                <span class="s1">message </span><span class="s4">= </span><span class="s5">f&quot;</span><span class="s3">{</span><span class="s1">message</span><span class="s3">} </span><span class="s5">(</span><span class="s3">{</span><span class="s1">_suffix</span><span class="s3">}</span><span class="s5">)&quot;</span>

            <span class="s1">frame </span><span class="s4">= </span><span class="s1">frame</span><span class="s4">.</span><span class="s1">f_back  </span><span class="s0"># type: ignore[assignment]</span>

            <span class="s3">if not </span><span class="s1">stacklevel_found</span><span class="s4">:</span>
                <span class="s1">stacklevel </span><span class="s4">+= </span><span class="s6">1</span>
            <span class="s3">elif </span><span class="s1">stacklevel_found </span><span class="s3">and </span><span class="s1">warning_tag_found</span><span class="s4">:</span>
                <span class="s3">break</span>

    <span class="s3">if </span><span class="s1">category </span><span class="s3">is not None</span><span class="s4">:</span>
        <span class="s1">warnings</span><span class="s4">.</span><span class="s1">warn</span><span class="s4">(</span><span class="s1">message</span><span class="s4">, </span><span class="s1">category</span><span class="s4">, </span><span class="s1">stacklevel</span><span class="s4">=</span><span class="s1">stacklevel </span><span class="s4">+ </span><span class="s6">1</span><span class="s4">)</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">warnings</span><span class="s4">.</span><span class="s1">warn</span><span class="s4">(</span><span class="s1">message</span><span class="s4">, </span><span class="s1">stacklevel</span><span class="s4">=</span><span class="s1">stacklevel </span><span class="s4">+ </span><span class="s6">1</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">only_once</span><span class="s4">(</span>
    <span class="s1">fn</span><span class="s4">: </span><span class="s1">Callable</span><span class="s4">[..., </span><span class="s1">_T</span><span class="s4">], </span><span class="s1">retry_on_exception</span><span class="s4">: </span><span class="s1">bool</span>
<span class="s4">) </span><span class="s1">-&gt; Callable</span><span class="s4">[..., </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]]:</span>
    <span class="s2">&quot;&quot;&quot;Decorate the given function to be a no-op after it is called exactly 
    once.&quot;&quot;&quot;</span>

    <span class="s1">once </span><span class="s4">= [</span><span class="s1">fn</span><span class="s4">]</span>

    <span class="s3">def </span><span class="s1">go</span><span class="s4">(*</span><span class="s1">arg</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; Optional</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]:</span>
        <span class="s0"># strong reference fn so that it isn't garbage collected,</span>
        <span class="s0"># which interferes with the event system's expectations</span>
        <span class="s1">strong_fn </span><span class="s4">= </span><span class="s1">fn  </span><span class="s0"># noqa</span>
        <span class="s3">if </span><span class="s1">once</span><span class="s4">:</span>
            <span class="s1">once_fn </span><span class="s4">= </span><span class="s1">once</span><span class="s4">.</span><span class="s1">pop</span><span class="s4">()</span>
            <span class="s3">try</span><span class="s4">:</span>
                <span class="s3">return </span><span class="s1">once_fn</span><span class="s4">(*</span><span class="s1">arg</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">)</span>
            <span class="s3">except</span><span class="s4">:</span>
                <span class="s3">if </span><span class="s1">retry_on_exception</span><span class="s4">:</span>
                    <span class="s1">once</span><span class="s4">.</span><span class="s1">insert</span><span class="s4">(</span><span class="s6">0</span><span class="s4">, </span><span class="s1">once_fn</span><span class="s4">)</span>
                <span class="s3">raise</span>

        <span class="s3">return None</span>

    <span class="s3">return </span><span class="s1">go</span>


<span class="s1">_SQLA_RE </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span><span class="s5">r&quot;sqlalchemy/([a-z_]+/){0,2}[a-z_]+\.py&quot;</span><span class="s4">)</span>
<span class="s1">_UNITTEST_RE </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span><span class="s5">r&quot;unit(?:2|test2?/)&quot;</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">chop_traceback</span><span class="s4">(</span>
    <span class="s1">tb</span><span class="s4">: </span><span class="s1">List</span><span class="s4">[</span><span class="s1">str</span><span class="s4">],</span>
    <span class="s1">exclude_prefix</span><span class="s4">: </span><span class="s1">re</span><span class="s4">.</span><span class="s1">Pattern</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s1">_UNITTEST_RE</span><span class="s4">,</span>
    <span class="s1">exclude_suffix</span><span class="s4">: </span><span class="s1">re</span><span class="s4">.</span><span class="s1">Pattern</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s1">_SQLA_RE</span><span class="s4">,</span>
<span class="s4">) </span><span class="s1">-&gt; List</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]:</span>
    <span class="s2">&quot;&quot;&quot;Chop extraneous lines off beginning and end of a traceback. 
 
    :param tb: 
      a list of traceback lines as returned by ``traceback.format_stack()`` 
 
    :param exclude_prefix: 
      a regular expression object matching lines to skip at beginning of 
      ``tb`` 
 
    :param exclude_suffix: 
      a regular expression object matching lines to skip at end of ``tb`` 
    &quot;&quot;&quot;</span>
    <span class="s1">start </span><span class="s4">= </span><span class="s6">0</span>
    <span class="s1">end </span><span class="s4">= </span><span class="s1">len</span><span class="s4">(</span><span class="s1">tb</span><span class="s4">) - </span><span class="s6">1</span>
    <span class="s3">while </span><span class="s1">start </span><span class="s4">&lt;= </span><span class="s1">end </span><span class="s3">and </span><span class="s1">exclude_prefix</span><span class="s4">.</span><span class="s1">search</span><span class="s4">(</span><span class="s1">tb</span><span class="s4">[</span><span class="s1">start</span><span class="s4">]):</span>
        <span class="s1">start </span><span class="s4">+= </span><span class="s6">1</span>
    <span class="s3">while </span><span class="s1">start </span><span class="s4">&lt;= </span><span class="s1">end </span><span class="s3">and </span><span class="s1">exclude_suffix</span><span class="s4">.</span><span class="s1">search</span><span class="s4">(</span><span class="s1">tb</span><span class="s4">[</span><span class="s1">end</span><span class="s4">]):</span>
        <span class="s1">end </span><span class="s4">-= </span><span class="s6">1</span>
    <span class="s3">return </span><span class="s1">tb</span><span class="s4">[</span><span class="s1">start </span><span class="s4">: </span><span class="s1">end </span><span class="s4">+ </span><span class="s6">1</span><span class="s4">]</span>


<span class="s1">NoneType </span><span class="s4">= </span><span class="s1">type</span><span class="s4">(</span><span class="s3">None</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">attrsetter</span><span class="s4">(</span><span class="s1">attrname</span><span class="s4">):</span>
    <span class="s1">code </span><span class="s4">= </span><span class="s5">&quot;def set(obj, value):    obj.%s = value&quot; </span><span class="s4">% </span><span class="s1">attrname</span>
    <span class="s1">env </span><span class="s4">= </span><span class="s1">locals</span><span class="s4">().</span><span class="s1">copy</span><span class="s4">()</span>
    <span class="s1">exec</span><span class="s4">(</span><span class="s1">code</span><span class="s4">, </span><span class="s1">env</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s1">env</span><span class="s4">[</span><span class="s5">&quot;set&quot;</span><span class="s4">]</span>


<span class="s1">_dunders </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span><span class="s5">&quot;^__.+__$&quot;</span><span class="s4">)</span>


<span class="s3">class </span><span class="s1">TypingOnly</span><span class="s4">:</span>
    <span class="s2">&quot;&quot;&quot;A mixin class that marks a class as 'typing only', meaning it has 
    absolutely no methods, attributes, or runtime functionality whatsoever. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__slots__ </span><span class="s4">= ()</span>

    <span class="s3">def </span><span class="s1">__init_subclass__</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">TypingOnly </span><span class="s3">in </span><span class="s1">cls</span><span class="s4">.</span><span class="s1">__bases__</span><span class="s4">:</span>
            <span class="s1">remaining </span><span class="s4">= {</span>
                <span class="s1">name </span><span class="s3">for </span><span class="s1">name </span><span class="s3">in </span><span class="s1">cls</span><span class="s4">.</span><span class="s1">__dict__ </span><span class="s3">if not </span><span class="s1">_dunders</span><span class="s4">.</span><span class="s1">match</span><span class="s4">(</span><span class="s1">name</span><span class="s4">)</span>
            <span class="s4">}</span>
            <span class="s3">if </span><span class="s1">remaining</span><span class="s4">:</span>
                <span class="s3">raise </span><span class="s1">AssertionError</span><span class="s4">(</span>
                    <span class="s5">f&quot;Class </span><span class="s3">{</span><span class="s1">cls</span><span class="s3">} </span><span class="s5">directly inherits TypingOnly but has &quot;</span>
                    <span class="s5">f&quot;additional attributes </span><span class="s3">{</span><span class="s1">remaining</span><span class="s3">}</span><span class="s5">.&quot;</span>
                <span class="s4">)</span>
        <span class="s1">super</span><span class="s4">().</span><span class="s1">__init_subclass__</span><span class="s4">()</span>


<span class="s3">class </span><span class="s1">EnsureKWArg</span><span class="s4">:</span>
    <span class="s2">r&quot;&quot;&quot;Apply translation of functions to accept \**kw arguments if they 
    don't already. 
 
    Used to ensure cross-compatibility with third party legacy code, for things 
    like compiler visit methods that need to accept ``**kw`` arguments, 
    but may have been copied from old code that didn't accept them. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">ensure_kwarg</span><span class="s4">: </span><span class="s1">str</span>
    <span class="s5">&quot;&quot;&quot;a regular expression that indicates method names for which the method 
    should accept ``**kw`` arguments. 
 
    The class will scan for methods matching the name template and decorate 
    them if necessary to ensure ``**kw`` parameters are accepted. 
 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init_subclass__</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s1">fn_reg </span><span class="s4">= </span><span class="s1">cls</span><span class="s4">.</span><span class="s1">ensure_kwarg</span>
        <span class="s1">clsdict </span><span class="s4">= </span><span class="s1">cls</span><span class="s4">.</span><span class="s1">__dict__</span>
        <span class="s3">if </span><span class="s1">fn_reg</span><span class="s4">:</span>
            <span class="s3">for </span><span class="s1">key </span><span class="s3">in </span><span class="s1">clsdict</span><span class="s4">:</span>
                <span class="s1">m </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">match</span><span class="s4">(</span><span class="s1">fn_reg</span><span class="s4">, </span><span class="s1">key</span><span class="s4">)</span>
                <span class="s3">if </span><span class="s1">m</span><span class="s4">:</span>
                    <span class="s1">fn </span><span class="s4">= </span><span class="s1">clsdict</span><span class="s4">[</span><span class="s1">key</span><span class="s4">]</span>
                    <span class="s1">spec </span><span class="s4">= </span><span class="s1">compat</span><span class="s4">.</span><span class="s1">inspect_getfullargspec</span><span class="s4">(</span><span class="s1">fn</span><span class="s4">)</span>
                    <span class="s3">if not </span><span class="s1">spec</span><span class="s4">.</span><span class="s1">varkw</span><span class="s4">:</span>
                        <span class="s1">wrapped </span><span class="s4">= </span><span class="s1">cls</span><span class="s4">.</span><span class="s1">_wrap_w_kw</span><span class="s4">(</span><span class="s1">fn</span><span class="s4">)</span>
                        <span class="s1">setattr</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">, </span><span class="s1">key</span><span class="s4">, </span><span class="s1">wrapped</span><span class="s4">)</span>
        <span class="s1">super</span><span class="s4">().</span><span class="s1">__init_subclass__</span><span class="s4">()</span>

    <span class="s4">@</span><span class="s1">classmethod</span>
    <span class="s3">def </span><span class="s1">_wrap_w_kw</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">, </span><span class="s1">fn</span><span class="s4">: </span><span class="s1">Callable</span><span class="s4">[..., </span><span class="s1">Any</span><span class="s4">]) </span><span class="s1">-&gt; Callable</span><span class="s4">[..., </span><span class="s1">Any</span><span class="s4">]:</span>
        <span class="s3">def </span><span class="s1">wrap</span><span class="s4">(*</span><span class="s1">arg</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; Any</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">fn</span><span class="s4">(*</span><span class="s1">arg</span><span class="s4">)</span>

        <span class="s3">return </span><span class="s1">update_wrapper</span><span class="s4">(</span><span class="s1">wrap</span><span class="s4">, </span><span class="s1">fn</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">wrap_callable</span><span class="s4">(</span><span class="s1">wrapper</span><span class="s4">, </span><span class="s1">fn</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Augment functools.update_wrapper() to work with objects with 
    a ``__call__()`` method. 
 
    :param fn: 
      object with __call__ method 
 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">fn</span><span class="s4">, </span><span class="s5">&quot;__name__&quot;</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">update_wrapper</span><span class="s4">(</span><span class="s1">wrapper</span><span class="s4">, </span><span class="s1">fn</span><span class="s4">)</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">_f </span><span class="s4">= </span><span class="s1">wrapper</span>
        <span class="s1">_f</span><span class="s4">.</span><span class="s1">__name__ </span><span class="s4">= </span><span class="s1">fn</span><span class="s4">.</span><span class="s1">__class__</span><span class="s4">.</span><span class="s1">__name__</span>
        <span class="s3">if </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">fn</span><span class="s4">, </span><span class="s5">&quot;__module__&quot;</span><span class="s4">):</span>
            <span class="s1">_f</span><span class="s4">.</span><span class="s1">__module__ </span><span class="s4">= </span><span class="s1">fn</span><span class="s4">.</span><span class="s1">__module__</span>

        <span class="s3">if </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">fn</span><span class="s4">.</span><span class="s1">__call__</span><span class="s4">, </span><span class="s5">&quot;__doc__&quot;</span><span class="s4">) </span><span class="s3">and </span><span class="s1">fn</span><span class="s4">.</span><span class="s1">__call__</span><span class="s4">.</span><span class="s1">__doc__</span><span class="s4">:</span>
            <span class="s1">_f</span><span class="s4">.</span><span class="s1">__doc__ </span><span class="s4">= </span><span class="s1">fn</span><span class="s4">.</span><span class="s1">__call__</span><span class="s4">.</span><span class="s1">__doc__</span>
        <span class="s3">elif </span><span class="s1">fn</span><span class="s4">.</span><span class="s1">__doc__</span><span class="s4">:</span>
            <span class="s1">_f</span><span class="s4">.</span><span class="s1">__doc__ </span><span class="s4">= </span><span class="s1">fn</span><span class="s4">.</span><span class="s1">__doc__</span>

        <span class="s3">return </span><span class="s1">_f</span>


<span class="s3">def </span><span class="s1">quoted_token_parser</span><span class="s4">(</span><span class="s1">value</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Parse a dotted identifier with accommodation for quoted names. 
 
    Includes support for SQL-style double quotes as a literal character. 
 
    E.g.:: 
 
        &gt;&gt;&gt; quoted_token_parser(&quot;name&quot;) 
        [&quot;name&quot;] 
        &gt;&gt;&gt; quoted_token_parser(&quot;schema.name&quot;) 
        [&quot;schema&quot;, &quot;name&quot;] 
        &gt;&gt;&gt; quoted_token_parser('&quot;Schema&quot;.&quot;Name&quot;') 
        ['Schema', 'Name'] 
        &gt;&gt;&gt; quoted_token_parser('&quot;Schema&quot;.&quot;Name&quot;&quot;Foo&quot;') 
        ['Schema', 'Name&quot;&quot;Foo'] 
 
    &quot;&quot;&quot;</span>

    <span class="s3">if </span><span class="s5">'&quot;' </span><span class="s3">not in </span><span class="s1">value</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">value</span><span class="s4">.</span><span class="s1">split</span><span class="s4">(</span><span class="s5">&quot;.&quot;</span><span class="s4">)</span>

    <span class="s0"># 0 = outside of quotes</span>
    <span class="s0"># 1 = inside of quotes</span>
    <span class="s1">state </span><span class="s4">= </span><span class="s6">0</span>
    <span class="s1">result</span><span class="s4">: </span><span class="s1">List</span><span class="s4">[</span><span class="s1">List</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]] = [[]]</span>
    <span class="s1">idx </span><span class="s4">= </span><span class="s6">0</span>
    <span class="s1">lv </span><span class="s4">= </span><span class="s1">len</span><span class="s4">(</span><span class="s1">value</span><span class="s4">)</span>
    <span class="s3">while </span><span class="s1">idx </span><span class="s4">&lt; </span><span class="s1">lv</span><span class="s4">:</span>
        <span class="s1">char </span><span class="s4">= </span><span class="s1">value</span><span class="s4">[</span><span class="s1">idx</span><span class="s4">]</span>
        <span class="s3">if </span><span class="s1">char </span><span class="s4">== </span><span class="s5">'&quot;'</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">state </span><span class="s4">== </span><span class="s6">1 </span><span class="s3">and </span><span class="s1">idx </span><span class="s4">&lt; </span><span class="s1">lv </span><span class="s4">- </span><span class="s6">1 </span><span class="s3">and </span><span class="s1">value</span><span class="s4">[</span><span class="s1">idx </span><span class="s4">+ </span><span class="s6">1</span><span class="s4">] == </span><span class="s5">'&quot;'</span><span class="s4">:</span>
                <span class="s1">result</span><span class="s4">[-</span><span class="s6">1</span><span class="s4">].</span><span class="s1">append</span><span class="s4">(</span><span class="s5">'&quot;'</span><span class="s4">)</span>
                <span class="s1">idx </span><span class="s4">+= </span><span class="s6">1</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">state </span><span class="s4">^= </span><span class="s6">1</span>
        <span class="s3">elif </span><span class="s1">char </span><span class="s4">== </span><span class="s5">&quot;.&quot; </span><span class="s3">and </span><span class="s1">state </span><span class="s4">== </span><span class="s6">0</span><span class="s4">:</span>
            <span class="s1">result</span><span class="s4">.</span><span class="s1">append</span><span class="s4">([])</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">result</span><span class="s4">[-</span><span class="s6">1</span><span class="s4">].</span><span class="s1">append</span><span class="s4">(</span><span class="s1">char</span><span class="s4">)</span>
        <span class="s1">idx </span><span class="s4">+= </span><span class="s6">1</span>

    <span class="s3">return </span><span class="s4">[</span><span class="s5">&quot;&quot;</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span><span class="s1">token</span><span class="s4">) </span><span class="s3">for </span><span class="s1">token </span><span class="s3">in </span><span class="s1">result</span><span class="s4">]</span>


<span class="s3">def </span><span class="s1">add_parameter_text</span><span class="s4">(</span><span class="s1">params</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">, </span><span class="s1">text</span><span class="s4">: </span><span class="s1">str</span><span class="s4">) </span><span class="s1">-&gt; Callable</span><span class="s4">[[</span><span class="s1">_F</span><span class="s4">], </span><span class="s1">_F</span><span class="s4">]:</span>
    <span class="s1">params </span><span class="s4">= </span><span class="s1">_collections</span><span class="s4">.</span><span class="s1">to_list</span><span class="s4">(</span><span class="s1">params</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">decorate</span><span class="s4">(</span><span class="s1">fn</span><span class="s4">):</span>
        <span class="s1">doc </span><span class="s4">= </span><span class="s1">fn</span><span class="s4">.</span><span class="s1">__doc__ </span><span class="s3">is not None and </span><span class="s1">fn</span><span class="s4">.</span><span class="s1">__doc__ </span><span class="s3">or </span><span class="s5">&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">doc</span><span class="s4">:</span>
            <span class="s1">doc </span><span class="s4">= </span><span class="s1">inject_param_text</span><span class="s4">(</span><span class="s1">doc</span><span class="s4">, {</span><span class="s1">param</span><span class="s4">: </span><span class="s1">text </span><span class="s3">for </span><span class="s1">param </span><span class="s3">in </span><span class="s1">params</span><span class="s4">})</span>
        <span class="s1">fn</span><span class="s4">.</span><span class="s1">__doc__ </span><span class="s4">= </span><span class="s1">doc</span>
        <span class="s3">return </span><span class="s1">fn</span>

    <span class="s3">return </span><span class="s1">decorate</span>


<span class="s3">def </span><span class="s1">_dedent_docstring</span><span class="s4">(</span><span class="s1">text</span><span class="s4">: </span><span class="s1">str</span><span class="s4">) </span><span class="s1">-&gt; str</span><span class="s4">:</span>
    <span class="s1">split_text </span><span class="s4">= </span><span class="s1">text</span><span class="s4">.</span><span class="s1">split</span><span class="s4">(</span><span class="s5">&quot;</span><span class="s3">\n</span><span class="s5">&quot;</span><span class="s4">, </span><span class="s6">1</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">split_text</span><span class="s4">) == </span><span class="s6">1</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">text</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">firstline</span><span class="s4">, </span><span class="s1">remaining </span><span class="s4">= </span><span class="s1">split_text</span>
    <span class="s3">if not </span><span class="s1">firstline</span><span class="s4">.</span><span class="s1">startswith</span><span class="s4">(</span><span class="s5">&quot; &quot;</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">firstline </span><span class="s4">+ </span><span class="s5">&quot;</span><span class="s3">\n</span><span class="s5">&quot; </span><span class="s4">+ </span><span class="s1">textwrap</span><span class="s4">.</span><span class="s1">dedent</span><span class="s4">(</span><span class="s1">remaining</span><span class="s4">)</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">textwrap</span><span class="s4">.</span><span class="s1">dedent</span><span class="s4">(</span><span class="s1">text</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">inject_docstring_text</span><span class="s4">(</span>
    <span class="s1">given_doctext</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">], </span><span class="s1">injecttext</span><span class="s4">: </span><span class="s1">str</span><span class="s4">, </span><span class="s1">pos</span><span class="s4">: </span><span class="s1">int</span>
<span class="s4">) </span><span class="s1">-&gt; str</span><span class="s4">:</span>
    <span class="s1">doctext</span><span class="s4">: </span><span class="s1">str </span><span class="s4">= </span><span class="s1">_dedent_docstring</span><span class="s4">(</span><span class="s1">given_doctext </span><span class="s3">or </span><span class="s5">&quot;&quot;</span><span class="s4">)</span>
    <span class="s1">lines </span><span class="s4">= </span><span class="s1">doctext</span><span class="s4">.</span><span class="s1">split</span><span class="s4">(</span><span class="s5">&quot;</span><span class="s3">\n</span><span class="s5">&quot;</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">lines</span><span class="s4">) == </span><span class="s6">1</span><span class="s4">:</span>
        <span class="s1">lines</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s5">&quot;&quot;</span><span class="s4">)</span>
    <span class="s1">injectlines </span><span class="s4">= </span><span class="s1">textwrap</span><span class="s4">.</span><span class="s1">dedent</span><span class="s4">(</span><span class="s1">injecttext</span><span class="s4">).</span><span class="s1">split</span><span class="s4">(</span><span class="s5">&quot;</span><span class="s3">\n</span><span class="s5">&quot;</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">injectlines</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]:</span>
        <span class="s1">injectlines</span><span class="s4">.</span><span class="s1">insert</span><span class="s4">(</span><span class="s6">0</span><span class="s4">, </span><span class="s5">&quot;&quot;</span><span class="s4">)</span>

    <span class="s1">blanks </span><span class="s4">= [</span><span class="s1">num </span><span class="s3">for </span><span class="s1">num</span><span class="s4">, </span><span class="s1">line </span><span class="s3">in </span><span class="s1">enumerate</span><span class="s4">(</span><span class="s1">lines</span><span class="s4">) </span><span class="s3">if not </span><span class="s1">line</span><span class="s4">.</span><span class="s1">strip</span><span class="s4">()]</span>
    <span class="s1">blanks</span><span class="s4">.</span><span class="s1">insert</span><span class="s4">(</span><span class="s6">0</span><span class="s4">, </span><span class="s6">0</span><span class="s4">)</span>

    <span class="s1">inject_pos </span><span class="s4">= </span><span class="s1">blanks</span><span class="s4">[</span><span class="s1">min</span><span class="s4">(</span><span class="s1">pos</span><span class="s4">, </span><span class="s1">len</span><span class="s4">(</span><span class="s1">blanks</span><span class="s4">) - </span><span class="s6">1</span><span class="s4">)]</span>

    <span class="s1">lines </span><span class="s4">= </span><span class="s1">lines</span><span class="s4">[</span><span class="s6">0</span><span class="s4">:</span><span class="s1">inject_pos</span><span class="s4">] + </span><span class="s1">injectlines </span><span class="s4">+ </span><span class="s1">lines</span><span class="s4">[</span><span class="s1">inject_pos</span><span class="s4">:]</span>
    <span class="s3">return </span><span class="s5">&quot;</span><span class="s3">\n</span><span class="s5">&quot;</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span><span class="s1">lines</span><span class="s4">)</span>


<span class="s1">_param_reg </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span><span class="s5">r&quot;(\s+):param (.+?):&quot;</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">inject_param_text</span><span class="s4">(</span><span class="s1">doctext</span><span class="s4">: </span><span class="s1">str</span><span class="s4">, </span><span class="s1">inject_params</span><span class="s4">: </span><span class="s1">Dict</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">str</span><span class="s4">]) </span><span class="s1">-&gt; str</span><span class="s4">:</span>
    <span class="s1">doclines </span><span class="s4">= </span><span class="s1">collections</span><span class="s4">.</span><span class="s1">deque</span><span class="s4">(</span><span class="s1">doctext</span><span class="s4">.</span><span class="s1">splitlines</span><span class="s4">())</span>
    <span class="s1">lines </span><span class="s4">= []</span>

    <span class="s0"># TODO: this is not working for params like &quot;:param case_sensitive=True:&quot;</span>

    <span class="s1">to_inject </span><span class="s4">= </span><span class="s3">None</span>
    <span class="s3">while </span><span class="s1">doclines</span><span class="s4">:</span>
        <span class="s1">line </span><span class="s4">= </span><span class="s1">doclines</span><span class="s4">.</span><span class="s1">popleft</span><span class="s4">()</span>

        <span class="s1">m </span><span class="s4">= </span><span class="s1">_param_reg</span><span class="s4">.</span><span class="s1">match</span><span class="s4">(</span><span class="s1">line</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s1">to_inject </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">m</span><span class="s4">:</span>
                <span class="s1">param </span><span class="s4">= </span><span class="s1">m</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">2</span><span class="s4">).</span><span class="s1">lstrip</span><span class="s4">(</span><span class="s5">&quot;*&quot;</span><span class="s4">)</span>
                <span class="s3">if </span><span class="s1">param </span><span class="s3">in </span><span class="s1">inject_params</span><span class="s4">:</span>
                    <span class="s0"># default indent to that of :param: plus one</span>
                    <span class="s1">indent </span><span class="s4">= </span><span class="s5">&quot; &quot; </span><span class="s4">* </span><span class="s1">len</span><span class="s4">(</span><span class="s1">m</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">1</span><span class="s4">)) + </span><span class="s5">&quot; &quot;</span>

                    <span class="s0"># but if the next line has text, use that line's</span>
                    <span class="s0"># indentation</span>
                    <span class="s3">if </span><span class="s1">doclines</span><span class="s4">:</span>
                        <span class="s1">m2 </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">match</span><span class="s4">(</span><span class="s5">r&quot;(\s+)\S&quot;</span><span class="s4">, </span><span class="s1">doclines</span><span class="s4">[</span><span class="s6">0</span><span class="s4">])</span>
                        <span class="s3">if </span><span class="s1">m2</span><span class="s4">:</span>
                            <span class="s1">indent </span><span class="s4">= </span><span class="s5">&quot; &quot; </span><span class="s4">* </span><span class="s1">len</span><span class="s4">(</span><span class="s1">m2</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">1</span><span class="s4">))</span>

                    <span class="s1">to_inject </span><span class="s4">= </span><span class="s1">indent </span><span class="s4">+ </span><span class="s1">inject_params</span><span class="s4">[</span><span class="s1">param</span><span class="s4">]</span>
        <span class="s3">elif </span><span class="s1">m</span><span class="s4">:</span>
            <span class="s1">lines</span><span class="s4">.</span><span class="s1">extend</span><span class="s4">([</span><span class="s5">&quot;</span><span class="s3">\n</span><span class="s5">&quot;</span><span class="s4">, </span><span class="s1">to_inject</span><span class="s4">, </span><span class="s5">&quot;</span><span class="s3">\n</span><span class="s5">&quot;</span><span class="s4">])</span>
            <span class="s1">to_inject </span><span class="s4">= </span><span class="s3">None</span>
        <span class="s3">elif not </span><span class="s1">line</span><span class="s4">.</span><span class="s1">rstrip</span><span class="s4">():</span>
            <span class="s1">lines</span><span class="s4">.</span><span class="s1">extend</span><span class="s4">([</span><span class="s1">line</span><span class="s4">, </span><span class="s1">to_inject</span><span class="s4">, </span><span class="s5">&quot;</span><span class="s3">\n</span><span class="s5">&quot;</span><span class="s4">])</span>
            <span class="s1">to_inject </span><span class="s4">= </span><span class="s3">None</span>
        <span class="s3">elif </span><span class="s1">line</span><span class="s4">.</span><span class="s1">endswith</span><span class="s4">(</span><span class="s5">&quot;::&quot;</span><span class="s4">):</span>
            <span class="s0"># TODO: this still won't cover if the code example itself has</span>
            <span class="s0"># blank lines in it, need to detect those via indentation.</span>
            <span class="s1">lines</span><span class="s4">.</span><span class="s1">extend</span><span class="s4">([</span><span class="s1">line</span><span class="s4">, </span><span class="s1">doclines</span><span class="s4">.</span><span class="s1">popleft</span><span class="s4">()])</span>
            <span class="s3">continue</span>
        <span class="s1">lines</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">line</span><span class="s4">)</span>

    <span class="s3">return </span><span class="s5">&quot;</span><span class="s3">\n</span><span class="s5">&quot;</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span><span class="s1">lines</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">repr_tuple_names</span><span class="s4">(</span><span class="s1">names</span><span class="s4">: </span><span class="s1">List</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]) </span><span class="s1">-&gt; Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]:</span>
    <span class="s2">&quot;&quot;&quot;Trims a list of strings from the middle and return a string of up to 
    four elements. Strings greater than 11 characters will be truncated&quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">names</span><span class="s4">) == </span><span class="s6">0</span><span class="s4">:</span>
        <span class="s3">return None</span>
    <span class="s1">flag </span><span class="s4">= </span><span class="s1">len</span><span class="s4">(</span><span class="s1">names</span><span class="s4">) &lt;= </span><span class="s6">4</span>
    <span class="s1">names </span><span class="s4">= </span><span class="s1">names</span><span class="s4">[</span><span class="s6">0</span><span class="s4">:</span><span class="s6">4</span><span class="s4">] </span><span class="s3">if </span><span class="s1">flag </span><span class="s3">else </span><span class="s1">names</span><span class="s4">[</span><span class="s6">0</span><span class="s4">:</span><span class="s6">3</span><span class="s4">] + </span><span class="s1">names</span><span class="s4">[-</span><span class="s6">1</span><span class="s4">:]</span>
    <span class="s1">res </span><span class="s4">= [</span><span class="s5">&quot;%s..&quot; </span><span class="s4">% </span><span class="s1">name</span><span class="s4">[:</span><span class="s6">11</span><span class="s4">] </span><span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">name</span><span class="s4">) &gt; </span><span class="s6">11 </span><span class="s3">else </span><span class="s1">name </span><span class="s3">for </span><span class="s1">name </span><span class="s3">in </span><span class="s1">names</span><span class="s4">]</span>
    <span class="s3">if </span><span class="s1">flag</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s5">&quot;, &quot;</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span><span class="s1">res</span><span class="s4">)</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s5">&quot;%s, ..., %s&quot; </span><span class="s4">% (</span><span class="s5">&quot;, &quot;</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span><span class="s1">res</span><span class="s4">[</span><span class="s6">0</span><span class="s4">:</span><span class="s6">3</span><span class="s4">]), </span><span class="s1">res</span><span class="s4">[-</span><span class="s6">1</span><span class="s4">])</span>


<span class="s3">def </span><span class="s1">has_compiled_ext</span><span class="s4">(</span><span class="s1">raise_</span><span class="s4">=</span><span class="s3">False</span><span class="s4">):</span>
    <span class="s3">if </span><span class="s1">HAS_CYEXTENSION</span><span class="s4">:</span>
        <span class="s3">return True</span>
    <span class="s3">elif </span><span class="s1">raise_</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">ImportError</span><span class="s4">(</span>
            <span class="s5">&quot;cython extensions were expected to be installed, &quot;</span>
            <span class="s5">&quot;but are not present&quot;</span>
        <span class="s4">)</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s3">return False</span>


<span class="s3">class </span><span class="s1">_Missing</span><span class="s4">(</span><span class="s1">enum</span><span class="s4">.</span><span class="s1">Enum</span><span class="s4">):</span>
    <span class="s1">Missing </span><span class="s4">= </span><span class="s1">enum</span><span class="s4">.</span><span class="s1">auto</span><span class="s4">()</span>


<span class="s1">Missing </span><span class="s4">= </span><span class="s1">_Missing</span><span class="s4">.</span><span class="s1">Missing</span>
<span class="s1">MissingOr </span><span class="s4">= </span><span class="s1">Union</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">, </span><span class="s1">Literal</span><span class="s4">[</span><span class="s1">_Missing</span><span class="s4">.</span><span class="s1">Missing</span><span class="s4">]]</span>
</pre>
</body>
</html>