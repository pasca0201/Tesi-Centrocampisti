<html>
<head>
<title>_csr.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #6aab73;}
.s4 { color: #cf8e6d;}
.s5 { color: #7a7e85;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_csr.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Compressed Sparse Row matrix format&quot;&quot;&quot;</span>

<span class="s1">__docformat__ </span><span class="s2">= </span><span class="s3">&quot;restructuredtext en&quot;</span>

<span class="s1">__all__ </span><span class="s2">= [</span><span class="s3">'csr_array'</span><span class="s2">, </span><span class="s3">'csr_matrix'</span><span class="s2">, </span><span class="s3">'isspmatrix_csr'</span><span class="s2">]</span>

<span class="s4">import </span><span class="s1">numpy </span><span class="s4">as </span><span class="s1">np</span>

<span class="s4">from </span><span class="s2">.</span><span class="s1">_matrix </span><span class="s4">import </span><span class="s1">spmatrix</span>
<span class="s4">from </span><span class="s2">.</span><span class="s1">_base </span><span class="s4">import </span><span class="s1">_spbase</span><span class="s2">, </span><span class="s1">sparray</span>
<span class="s4">from </span><span class="s2">.</span><span class="s1">_sparsetools </span><span class="s4">import </span><span class="s2">(</span><span class="s1">csr_tocsc</span><span class="s2">, </span><span class="s1">csr_tobsr</span><span class="s2">, </span><span class="s1">csr_count_blocks</span><span class="s2">,</span>
                           <span class="s1">get_csr_submatrix</span><span class="s2">)</span>
<span class="s4">from </span><span class="s2">.</span><span class="s1">_sputils </span><span class="s4">import </span><span class="s1">upcast</span>

<span class="s4">from </span><span class="s2">.</span><span class="s1">_compressed </span><span class="s4">import </span><span class="s1">_cs_matrix</span>


<span class="s4">class </span><span class="s1">_csr_base</span><span class="s2">(</span><span class="s1">_cs_matrix</span><span class="s2">):</span>
    <span class="s1">_format </span><span class="s2">= </span><span class="s3">'csr'</span>

    <span class="s5"># override IndexMixin.__getitem__ for 1d case until fully implemented</span>
    <span class="s4">def </span><span class="s1">__getitem__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">key</span><span class="s2">):</span>
        <span class="s4">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s6">2</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s1">super</span><span class="s2">().</span><span class="s1">__getitem__</span><span class="s2">(</span><span class="s1">key</span><span class="s2">)</span>

        <span class="s4">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">key</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">) </span><span class="s4">and </span><span class="s1">len</span><span class="s2">(</span><span class="s1">key</span><span class="s2">) == </span><span class="s6">1</span><span class="s2">:</span>
            <span class="s1">key </span><span class="s2">= </span><span class="s1">key</span><span class="s2">[</span><span class="s6">0</span><span class="s2">]</span>
        <span class="s1">INT_TYPES </span><span class="s2">= (</span><span class="s1">int</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">integer</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">key</span><span class="s2">, </span><span class="s1">INT_TYPES</span><span class="s2">):</span>
            <span class="s4">if </span><span class="s1">key </span><span class="s2">&lt; </span><span class="s6">0</span><span class="s2">:</span>
                <span class="s1">key </span><span class="s2">+= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[-</span><span class="s6">1</span><span class="s2">]</span>
            <span class="s4">if </span><span class="s1">key </span><span class="s2">&lt; </span><span class="s6">0 </span><span class="s4">or </span><span class="s1">key </span><span class="s2">&gt;= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[-</span><span class="s6">1</span><span class="s2">]:</span>
                <span class="s4">raise </span><span class="s1">IndexError</span><span class="s2">(</span><span class="s3">'index value out of bounds'</span><span class="s2">)</span>
            <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_get_int</span><span class="s2">(</span><span class="s1">key</span><span class="s2">)</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s4">raise </span><span class="s1">IndexError</span><span class="s2">(</span><span class="s3">'array/slice index for 1d csr_array not yet supported'</span><span class="s2">)</span>

    <span class="s5"># override IndexMixin.__setitem__ for 1d case until fully implemented</span>
    <span class="s4">def </span><span class="s1">__setitem__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">value</span><span class="s2">):</span>
        <span class="s4">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s6">2</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s1">super</span><span class="s2">().</span><span class="s1">__setitem__</span><span class="s2">(</span><span class="s1">key</span><span class="s2">, </span><span class="s1">value</span><span class="s2">)</span>

        <span class="s4">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">key</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">) </span><span class="s4">and </span><span class="s1">len</span><span class="s2">(</span><span class="s1">key</span><span class="s2">) == </span><span class="s6">1</span><span class="s2">:</span>
            <span class="s1">key </span><span class="s2">= </span><span class="s1">key</span><span class="s2">[</span><span class="s6">0</span><span class="s2">]</span>
        <span class="s1">INT_TYPES </span><span class="s2">= (</span><span class="s1">int</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">integer</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">key</span><span class="s2">, </span><span class="s1">INT_TYPES</span><span class="s2">):</span>
            <span class="s4">if </span><span class="s1">key </span><span class="s2">&lt; </span><span class="s6">0</span><span class="s2">:</span>
                <span class="s1">key </span><span class="s2">+= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[-</span><span class="s6">1</span><span class="s2">]</span>
            <span class="s4">if </span><span class="s1">key </span><span class="s2">&lt; </span><span class="s6">0 </span><span class="s4">or </span><span class="s1">key </span><span class="s2">&gt;= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[-</span><span class="s6">1</span><span class="s2">]:</span>
                <span class="s4">raise </span><span class="s1">IndexError</span><span class="s2">(</span><span class="s3">'index value out of bounds'</span><span class="s2">)</span>
            <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_set_int</span><span class="s2">(</span><span class="s1">key</span><span class="s2">, </span><span class="s1">value</span><span class="s2">)</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s4">raise </span><span class="s1">IndexError</span><span class="s2">(</span><span class="s3">'array index for 1d csr_array not yet provided'</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">transpose</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">axes</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s4">False</span><span class="s2">):</span>
        <span class="s4">if </span><span class="s1">axes </span><span class="s4">is not None and </span><span class="s1">axes </span><span class="s2">!= (</span><span class="s6">1</span><span class="s2">, </span><span class="s6">0</span><span class="s2">):</span>
            <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;Sparse arrays/matrices do not support &quot;</span>
                              <span class="s3">&quot;an 'axes' parameter because swapping &quot;</span>
                              <span class="s3">&quot;dimensions is the only logical permutation.&quot;</span><span class="s2">)</span>

        <span class="s4">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s6">1</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">() </span><span class="s4">if </span><span class="s1">copy </span><span class="s4">else </span><span class="s1">self</span>
        <span class="s1">M</span><span class="s2">, </span><span class="s1">N </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span>
        <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_csc_container</span><span class="s2">((</span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">,</span>
                                    <span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">), </span><span class="s1">shape</span><span class="s2">=(</span><span class="s1">N</span><span class="s2">, </span><span class="s1">M</span><span class="s2">), </span><span class="s1">copy</span><span class="s2">=</span><span class="s1">copy</span><span class="s2">)</span>

    <span class="s1">transpose</span><span class="s2">.</span><span class="s1">__doc__ </span><span class="s2">= </span><span class="s1">_spbase</span><span class="s2">.</span><span class="s1">transpose</span><span class="s2">.</span><span class="s1">__doc__</span>

    <span class="s4">def </span><span class="s1">tolil</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s4">False</span><span class="s2">):</span>
        <span class="s4">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">!= </span><span class="s6">2</span><span class="s2">:</span>
            <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;Cannot convert a 1d sparse array to lil format&quot;</span><span class="s2">)</span>
        <span class="s1">lil </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_lil_container</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">sum_duplicates</span><span class="s2">()</span>
        <span class="s1">ptr</span><span class="s2">,</span><span class="s1">ind</span><span class="s2">,</span><span class="s1">dat </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">,</span><span class="s1">self</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">,</span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span>
        <span class="s1">rows</span><span class="s2">, </span><span class="s1">data </span><span class="s2">= </span><span class="s1">lil</span><span class="s2">.</span><span class="s1">rows</span><span class="s2">, </span><span class="s1">lil</span><span class="s2">.</span><span class="s1">data</span>

        <span class="s4">for </span><span class="s1">n </span><span class="s4">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s6">0</span><span class="s2">]):</span>
            <span class="s1">start </span><span class="s2">= </span><span class="s1">ptr</span><span class="s2">[</span><span class="s1">n</span><span class="s2">]</span>
            <span class="s1">end </span><span class="s2">= </span><span class="s1">ptr</span><span class="s2">[</span><span class="s1">n</span><span class="s2">+</span><span class="s6">1</span><span class="s2">]</span>
            <span class="s1">rows</span><span class="s2">[</span><span class="s1">n</span><span class="s2">] = </span><span class="s1">ind</span><span class="s2">[</span><span class="s1">start</span><span class="s2">:</span><span class="s1">end</span><span class="s2">].</span><span class="s1">tolist</span><span class="s2">()</span>
            <span class="s1">data</span><span class="s2">[</span><span class="s1">n</span><span class="s2">] = </span><span class="s1">dat</span><span class="s2">[</span><span class="s1">start</span><span class="s2">:</span><span class="s1">end</span><span class="s2">].</span><span class="s1">tolist</span><span class="s2">()</span>

        <span class="s4">return </span><span class="s1">lil</span>

    <span class="s1">tolil</span><span class="s2">.</span><span class="s1">__doc__ </span><span class="s2">= </span><span class="s1">_spbase</span><span class="s2">.</span><span class="s1">tolil</span><span class="s2">.</span><span class="s1">__doc__</span>

    <span class="s4">def </span><span class="s1">tocsr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s4">False</span><span class="s2">):</span>
        <span class="s4">if </span><span class="s1">copy</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s1">self</span>

    <span class="s1">tocsr</span><span class="s2">.</span><span class="s1">__doc__ </span><span class="s2">= </span><span class="s1">_spbase</span><span class="s2">.</span><span class="s1">tocsr</span><span class="s2">.</span><span class="s1">__doc__</span>

    <span class="s4">def </span><span class="s1">tocsc</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s4">False</span><span class="s2">):</span>
        <span class="s4">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">!= </span><span class="s6">2</span><span class="s2">:</span>
            <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;Cannot convert a 1d sparse array to csc format&quot;</span><span class="s2">)</span>
        <span class="s1">M</span><span class="s2">, </span><span class="s1">N </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span>
        <span class="s1">idx_dtype </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_get_index_dtype</span><span class="s2">((</span><span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">),</span>
                                    <span class="s1">maxval</span><span class="s2">=</span><span class="s1">max</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">nnz</span><span class="s2">, </span><span class="s1">M</span><span class="s2">))</span>
        <span class="s1">indptr </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">(</span><span class="s1">N </span><span class="s2">+ </span><span class="s6">1</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">idx_dtype</span><span class="s2">)</span>
        <span class="s1">indices </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">nnz</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">idx_dtype</span><span class="s2">)</span>
        <span class="s1">data </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">nnz</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">upcast</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">))</span>

        <span class="s1">csr_tocsc</span><span class="s2">(</span><span class="s1">M</span><span class="s2">, </span><span class="s1">N</span><span class="s2">,</span>
                  <span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">.</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">idx_dtype</span><span class="s2">),</span>
                  <span class="s1">self</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">.</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">idx_dtype</span><span class="s2">),</span>
                  <span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">,</span>
                  <span class="s1">indptr</span><span class="s2">,</span>
                  <span class="s1">indices</span><span class="s2">,</span>
                  <span class="s1">data</span><span class="s2">)</span>

        <span class="s1">A </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_csc_container</span><span class="s2">((</span><span class="s1">data</span><span class="s2">, </span><span class="s1">indices</span><span class="s2">, </span><span class="s1">indptr</span><span class="s2">), </span><span class="s1">shape</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">)</span>
        <span class="s1">A</span><span class="s2">.</span><span class="s1">has_sorted_indices </span><span class="s2">= </span><span class="s4">True</span>
        <span class="s4">return </span><span class="s1">A</span>

    <span class="s1">tocsc</span><span class="s2">.</span><span class="s1">__doc__ </span><span class="s2">= </span><span class="s1">_spbase</span><span class="s2">.</span><span class="s1">tocsc</span><span class="s2">.</span><span class="s1">__doc__</span>

    <span class="s4">def </span><span class="s1">tobsr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">blocksize</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s4">True</span><span class="s2">):</span>
        <span class="s4">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">!= </span><span class="s6">2</span><span class="s2">:</span>
            <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;Cannot convert a 1d sparse array to bsr format&quot;</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">blocksize </span><span class="s4">is None</span><span class="s2">:</span>
            <span class="s4">from </span><span class="s2">.</span><span class="s1">_spfuncs </span><span class="s4">import </span><span class="s1">estimate_blocksize</span>
            <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">tobsr</span><span class="s2">(</span><span class="s1">blocksize</span><span class="s2">=</span><span class="s1">estimate_blocksize</span><span class="s2">(</span><span class="s1">self</span><span class="s2">))</span>

        <span class="s4">elif </span><span class="s1">blocksize </span><span class="s2">== (</span><span class="s6">1</span><span class="s2">,</span><span class="s6">1</span><span class="s2">):</span>
            <span class="s1">arg1 </span><span class="s2">= (</span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">.</span><span class="s1">reshape</span><span class="s2">(-</span><span class="s6">1</span><span class="s2">,</span><span class="s6">1</span><span class="s2">,</span><span class="s6">1</span><span class="s2">),</span><span class="s1">self</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">,</span><span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">)</span>
            <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_bsr_container</span><span class="s2">(</span><span class="s1">arg1</span><span class="s2">, </span><span class="s1">shape</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s1">copy</span><span class="s2">)</span>

        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">R</span><span class="s2">,</span><span class="s1">C </span><span class="s2">= </span><span class="s1">blocksize</span>
            <span class="s1">M</span><span class="s2">,</span><span class="s1">N </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span>

            <span class="s4">if </span><span class="s1">R </span><span class="s2">&lt; </span><span class="s6">1 </span><span class="s4">or </span><span class="s1">C </span><span class="s2">&lt; </span><span class="s6">1 </span><span class="s4">or </span><span class="s1">M </span><span class="s2">% </span><span class="s1">R </span><span class="s2">!= </span><span class="s6">0 </span><span class="s4">or </span><span class="s1">N </span><span class="s2">% </span><span class="s1">C </span><span class="s2">!= </span><span class="s6">0</span><span class="s2">:</span>
                <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">'invalid blocksize %s' </span><span class="s2">% </span><span class="s1">blocksize</span><span class="s2">)</span>

            <span class="s1">blks </span><span class="s2">= </span><span class="s1">csr_count_blocks</span><span class="s2">(</span><span class="s1">M</span><span class="s2">,</span><span class="s1">N</span><span class="s2">,</span><span class="s1">R</span><span class="s2">,</span><span class="s1">C</span><span class="s2">,</span><span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">,</span><span class="s1">self</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">)</span>

            <span class="s1">idx_dtype </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_get_index_dtype</span><span class="s2">((</span><span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">),</span>
                                        <span class="s1">maxval</span><span class="s2">=</span><span class="s1">max</span><span class="s2">(</span><span class="s1">N</span><span class="s2">//</span><span class="s1">C</span><span class="s2">, </span><span class="s1">blks</span><span class="s2">))</span>
            <span class="s1">indptr </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">(</span><span class="s1">M</span><span class="s2">//</span><span class="s1">R</span><span class="s2">+</span><span class="s6">1</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">idx_dtype</span><span class="s2">)</span>
            <span class="s1">indices </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">(</span><span class="s1">blks</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">idx_dtype</span><span class="s2">)</span>
            <span class="s1">data </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">((</span><span class="s1">blks</span><span class="s2">,</span><span class="s1">R</span><span class="s2">,</span><span class="s1">C</span><span class="s2">), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>

            <span class="s1">csr_tobsr</span><span class="s2">(</span><span class="s1">M</span><span class="s2">, </span><span class="s1">N</span><span class="s2">, </span><span class="s1">R</span><span class="s2">, </span><span class="s1">C</span><span class="s2">,</span>
                      <span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">.</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">idx_dtype</span><span class="s2">),</span>
                      <span class="s1">self</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">.</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">idx_dtype</span><span class="s2">),</span>
                      <span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">,</span>
                      <span class="s1">indptr</span><span class="s2">, </span><span class="s1">indices</span><span class="s2">, </span><span class="s1">data</span><span class="s2">.</span><span class="s1">ravel</span><span class="s2">())</span>

            <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_bsr_container</span><span class="s2">(</span>
                <span class="s2">(</span><span class="s1">data</span><span class="s2">, </span><span class="s1">indices</span><span class="s2">, </span><span class="s1">indptr</span><span class="s2">), </span><span class="s1">shape</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span>
            <span class="s2">)</span>

    <span class="s1">tobsr</span><span class="s2">.</span><span class="s1">__doc__ </span><span class="s2">= </span><span class="s1">_spbase</span><span class="s2">.</span><span class="s1">tobsr</span><span class="s2">.</span><span class="s1">__doc__</span>

    <span class="s5"># these functions are used by the parent class (_cs_matrix)</span>
    <span class="s5"># to remove redundancy between csc_matrix and csr_array</span>
    <span class="s2">@</span><span class="s1">staticmethod</span>
    <span class="s4">def </span><span class="s1">_swap</span><span class="s2">(</span><span class="s1">x</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;swap the members of x if this is a column-oriented matrix 
        &quot;&quot;&quot;</span>
        <span class="s4">return </span><span class="s1">x</span>

    <span class="s4">def </span><span class="s1">__iter__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s4">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s6">1</span><span class="s2">:</span>
            <span class="s1">zero </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">type</span><span class="s2">(</span><span class="s6">0</span><span class="s2">)</span>
            <span class="s1">u </span><span class="s2">= </span><span class="s6">0</span>
            <span class="s4">for </span><span class="s1">v</span><span class="s2">, </span><span class="s1">d </span><span class="s4">in </span><span class="s1">zip</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">):</span>
                <span class="s4">for </span><span class="s1">_ </span><span class="s4">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">v </span><span class="s2">- </span><span class="s1">u</span><span class="s2">):</span>
                    <span class="s4">yield </span><span class="s1">zero</span>
                <span class="s4">yield </span><span class="s1">d</span>
                <span class="s1">u </span><span class="s2">= </span><span class="s1">v </span><span class="s2">+ </span><span class="s6">1</span>
            <span class="s4">for </span><span class="s1">_ </span><span class="s4">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s6">0</span><span class="s2">] - </span><span class="s1">u</span><span class="s2">):</span>
                <span class="s4">yield </span><span class="s1">zero</span>
            <span class="s4">return</span>

        <span class="s1">indptr </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">(</span><span class="s6">2</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s5"># return 1d (sparray) or 2drow (spmatrix)</span>
        <span class="s1">shape </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s6">1</span><span class="s2">:] </span><span class="s4">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">sparray</span><span class="s2">) </span><span class="s4">else </span><span class="s2">(</span><span class="s6">1</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s6">1</span><span class="s2">])</span>
        <span class="s1">i0 </span><span class="s2">= </span><span class="s6">0</span>
        <span class="s4">for </span><span class="s1">i1 </span><span class="s4">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">[</span><span class="s6">1</span><span class="s2">:]:</span>
            <span class="s1">indptr</span><span class="s2">[</span><span class="s6">1</span><span class="s2">] = </span><span class="s1">i1 </span><span class="s2">- </span><span class="s1">i0</span>
            <span class="s1">indices </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">[</span><span class="s1">i0</span><span class="s2">:</span><span class="s1">i1</span><span class="s2">]</span>
            <span class="s1">data </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">[</span><span class="s1">i0</span><span class="s2">:</span><span class="s1">i1</span><span class="s2">]</span>
            <span class="s4">yield </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__class__</span><span class="s2">((</span><span class="s1">data</span><span class="s2">, </span><span class="s1">indices</span><span class="s2">, </span><span class="s1">indptr</span><span class="s2">), </span><span class="s1">shape</span><span class="s2">=</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s4">True</span><span class="s2">)</span>
            <span class="s1">i0 </span><span class="s2">= </span><span class="s1">i1</span>

    <span class="s4">def </span><span class="s1">_getrow</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">i</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;Returns a copy of row i of the matrix, as a (1 x n) 
        CSR matrix (row vector). 
        &quot;&quot;&quot;</span>
        <span class="s4">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s6">1</span><span class="s2">:</span>
            <span class="s4">if </span><span class="s1">i </span><span class="s4">not in </span><span class="s2">(</span><span class="s6">0</span><span class="s2">, -</span><span class="s6">1</span><span class="s2">):</span>
                <span class="s4">raise </span><span class="s1">IndexError</span><span class="s2">(</span><span class="s3">f'index (</span><span class="s4">{</span><span class="s1">i</span><span class="s4">}</span><span class="s3">) out of range'</span><span class="s2">)</span>
            <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">reshape</span><span class="s2">((</span><span class="s6">1</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s6">0</span><span class="s2">]), </span><span class="s1">copy</span><span class="s2">=</span><span class="s4">True</span><span class="s2">)</span>

        <span class="s1">M</span><span class="s2">, </span><span class="s1">N </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span>
        <span class="s1">i </span><span class="s2">= </span><span class="s1">int</span><span class="s2">(</span><span class="s1">i</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">i </span><span class="s2">&lt; </span><span class="s6">0</span><span class="s2">:</span>
            <span class="s1">i </span><span class="s2">+= </span><span class="s1">M</span>
        <span class="s4">if </span><span class="s1">i </span><span class="s2">&lt; </span><span class="s6">0 </span><span class="s4">or </span><span class="s1">i </span><span class="s2">&gt;= </span><span class="s1">M</span><span class="s2">:</span>
            <span class="s4">raise </span><span class="s1">IndexError</span><span class="s2">(</span><span class="s3">'index (%d) out of range' </span><span class="s2">% </span><span class="s1">i</span><span class="s2">)</span>
        <span class="s1">indptr</span><span class="s2">, </span><span class="s1">indices</span><span class="s2">, </span><span class="s1">data </span><span class="s2">= </span><span class="s1">get_csr_submatrix</span><span class="s2">(</span>
            <span class="s1">M</span><span class="s2">, </span><span class="s1">N</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">, </span><span class="s1">i</span><span class="s2">, </span><span class="s1">i </span><span class="s2">+ </span><span class="s6">1</span><span class="s2">, </span><span class="s6">0</span><span class="s2">, </span><span class="s1">N</span><span class="s2">)</span>
        <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__class__</span><span class="s2">((</span><span class="s1">data</span><span class="s2">, </span><span class="s1">indices</span><span class="s2">, </span><span class="s1">indptr</span><span class="s2">), </span><span class="s1">shape</span><span class="s2">=(</span><span class="s6">1</span><span class="s2">, </span><span class="s1">N</span><span class="s2">),</span>
                              <span class="s1">dtype</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s4">False</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">_getcol</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">i</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;Returns a copy of column i. A (m x 1) sparse array (column vector). 
        &quot;&quot;&quot;</span>
        <span class="s4">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s6">1</span><span class="s2">:</span>
            <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;getcol not provided for 1d arrays. Use indexing A[j]&quot;</span><span class="s2">)</span>
        <span class="s1">M</span><span class="s2">, </span><span class="s1">N </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span>
        <span class="s1">i </span><span class="s2">= </span><span class="s1">int</span><span class="s2">(</span><span class="s1">i</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">i </span><span class="s2">&lt; </span><span class="s6">0</span><span class="s2">:</span>
            <span class="s1">i </span><span class="s2">+= </span><span class="s1">N</span>
        <span class="s4">if </span><span class="s1">i </span><span class="s2">&lt; </span><span class="s6">0 </span><span class="s4">or </span><span class="s1">i </span><span class="s2">&gt;= </span><span class="s1">N</span><span class="s2">:</span>
            <span class="s4">raise </span><span class="s1">IndexError</span><span class="s2">(</span><span class="s3">'index (%d) out of range' </span><span class="s2">% </span><span class="s1">i</span><span class="s2">)</span>
        <span class="s1">indptr</span><span class="s2">, </span><span class="s1">indices</span><span class="s2">, </span><span class="s1">data </span><span class="s2">= </span><span class="s1">get_csr_submatrix</span><span class="s2">(</span>
            <span class="s1">M</span><span class="s2">, </span><span class="s1">N</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">, </span><span class="s6">0</span><span class="s2">, </span><span class="s1">M</span><span class="s2">, </span><span class="s1">i</span><span class="s2">, </span><span class="s1">i </span><span class="s2">+ </span><span class="s6">1</span><span class="s2">)</span>
        <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__class__</span><span class="s2">((</span><span class="s1">data</span><span class="s2">, </span><span class="s1">indices</span><span class="s2">, </span><span class="s1">indptr</span><span class="s2">), </span><span class="s1">shape</span><span class="s2">=(</span><span class="s1">M</span><span class="s2">, </span><span class="s6">1</span><span class="s2">),</span>
                              <span class="s1">dtype</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s4">False</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">_get_intXarray</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">row</span><span class="s2">, </span><span class="s1">col</span><span class="s2">):</span>
        <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_getrow</span><span class="s2">(</span><span class="s1">row</span><span class="s2">).</span><span class="s1">_minor_index_fancy</span><span class="s2">(</span><span class="s1">col</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">_get_intXslice</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">row</span><span class="s2">, </span><span class="s1">col</span><span class="s2">):</span>
        <span class="s4">if </span><span class="s1">col</span><span class="s2">.</span><span class="s1">step </span><span class="s4">in </span><span class="s2">(</span><span class="s6">1</span><span class="s2">, </span><span class="s4">None</span><span class="s2">):</span>
            <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_get_submatrix</span><span class="s2">(</span><span class="s1">row</span><span class="s2">, </span><span class="s1">col</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s4">True</span><span class="s2">)</span>
        <span class="s5"># TODO: uncomment this once it's faster:</span>
        <span class="s5"># return self._getrow(row)._minor_slice(col)</span>

        <span class="s1">M</span><span class="s2">, </span><span class="s1">N </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span>
        <span class="s1">start</span><span class="s2">, </span><span class="s1">stop</span><span class="s2">, </span><span class="s1">stride </span><span class="s2">= </span><span class="s1">col</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">(</span><span class="s1">N</span><span class="s2">)</span>

        <span class="s1">ii</span><span class="s2">, </span><span class="s1">jj </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">[</span><span class="s1">row</span><span class="s2">:</span><span class="s1">row</span><span class="s2">+</span><span class="s6">2</span><span class="s2">]</span>
        <span class="s1">row_indices </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">[</span><span class="s1">ii</span><span class="s2">:</span><span class="s1">jj</span><span class="s2">]</span>
        <span class="s1">row_data </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">[</span><span class="s1">ii</span><span class="s2">:</span><span class="s1">jj</span><span class="s2">]</span>

        <span class="s4">if </span><span class="s1">stride </span><span class="s2">&gt; </span><span class="s6">0</span><span class="s2">:</span>
            <span class="s1">ind </span><span class="s2">= (</span><span class="s1">row_indices </span><span class="s2">&gt;= </span><span class="s1">start</span><span class="s2">) &amp; (</span><span class="s1">row_indices </span><span class="s2">&lt; </span><span class="s1">stop</span><span class="s2">)</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">ind </span><span class="s2">= (</span><span class="s1">row_indices </span><span class="s2">&lt;= </span><span class="s1">start</span><span class="s2">) &amp; (</span><span class="s1">row_indices </span><span class="s2">&gt; </span><span class="s1">stop</span><span class="s2">)</span>

        <span class="s4">if </span><span class="s1">abs</span><span class="s2">(</span><span class="s1">stride</span><span class="s2">) &gt; </span><span class="s6">1</span><span class="s2">:</span>
            <span class="s1">ind </span><span class="s2">&amp;= (</span><span class="s1">row_indices </span><span class="s2">- </span><span class="s1">start</span><span class="s2">) % </span><span class="s1">stride </span><span class="s2">== </span><span class="s6">0</span>

        <span class="s1">row_indices </span><span class="s2">= (</span><span class="s1">row_indices</span><span class="s2">[</span><span class="s1">ind</span><span class="s2">] - </span><span class="s1">start</span><span class="s2">) // </span><span class="s1">stride</span>
        <span class="s1">row_data </span><span class="s2">= </span><span class="s1">row_data</span><span class="s2">[</span><span class="s1">ind</span><span class="s2">]</span>
        <span class="s1">row_indptr </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s6">0</span><span class="s2">, </span><span class="s1">len</span><span class="s2">(</span><span class="s1">row_indices</span><span class="s2">)])</span>

        <span class="s4">if </span><span class="s1">stride </span><span class="s2">&lt; </span><span class="s6">0</span><span class="s2">:</span>
            <span class="s1">row_data </span><span class="s2">= </span><span class="s1">row_data</span><span class="s2">[::-</span><span class="s6">1</span><span class="s2">]</span>
            <span class="s1">row_indices </span><span class="s2">= </span><span class="s1">abs</span><span class="s2">(</span><span class="s1">row_indices</span><span class="s2">[::-</span><span class="s6">1</span><span class="s2">])</span>

        <span class="s1">shape </span><span class="s2">= (</span><span class="s6">1</span><span class="s2">, </span><span class="s1">max</span><span class="s2">(</span><span class="s6">0</span><span class="s2">, </span><span class="s1">int</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">ceil</span><span class="s2">(</span><span class="s1">float</span><span class="s2">(</span><span class="s1">stop </span><span class="s2">- </span><span class="s1">start</span><span class="s2">) / </span><span class="s1">stride</span><span class="s2">))))</span>
        <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__class__</span><span class="s2">((</span><span class="s1">row_data</span><span class="s2">, </span><span class="s1">row_indices</span><span class="s2">, </span><span class="s1">row_indptr</span><span class="s2">), </span><span class="s1">shape</span><span class="s2">=</span><span class="s1">shape</span><span class="s2">,</span>
                              <span class="s1">dtype</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s4">False</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">_get_sliceXint</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">row</span><span class="s2">, </span><span class="s1">col</span><span class="s2">):</span>
        <span class="s4">if </span><span class="s1">row</span><span class="s2">.</span><span class="s1">step </span><span class="s4">in </span><span class="s2">(</span><span class="s6">1</span><span class="s2">, </span><span class="s4">None</span><span class="s2">):</span>
            <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_get_submatrix</span><span class="s2">(</span><span class="s1">row</span><span class="s2">, </span><span class="s1">col</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s4">True</span><span class="s2">)</span>
        <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_major_slice</span><span class="s2">(</span><span class="s1">row</span><span class="s2">).</span><span class="s1">_get_submatrix</span><span class="s2">(</span><span class="s1">minor</span><span class="s2">=</span><span class="s1">col</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">_get_sliceXarray</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">row</span><span class="s2">, </span><span class="s1">col</span><span class="s2">):</span>
        <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_major_slice</span><span class="s2">(</span><span class="s1">row</span><span class="s2">).</span><span class="s1">_minor_index_fancy</span><span class="s2">(</span><span class="s1">col</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">_get_arrayXint</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">row</span><span class="s2">, </span><span class="s1">col</span><span class="s2">):</span>
        <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_major_index_fancy</span><span class="s2">(</span><span class="s1">row</span><span class="s2">).</span><span class="s1">_get_submatrix</span><span class="s2">(</span><span class="s1">minor</span><span class="s2">=</span><span class="s1">col</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">_get_arrayXslice</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">row</span><span class="s2">, </span><span class="s1">col</span><span class="s2">):</span>
        <span class="s4">if </span><span class="s1">col</span><span class="s2">.</span><span class="s1">step </span><span class="s4">not in </span><span class="s2">(</span><span class="s6">1</span><span class="s2">, </span><span class="s4">None</span><span class="s2">):</span>
            <span class="s1">col </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(*</span><span class="s1">col</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s6">1</span><span class="s2">]))</span>
            <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_get_arrayXarray</span><span class="s2">(</span><span class="s1">row</span><span class="s2">, </span><span class="s1">col</span><span class="s2">)</span>
        <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_major_index_fancy</span><span class="s2">(</span><span class="s1">row</span><span class="s2">).</span><span class="s1">_get_submatrix</span><span class="s2">(</span><span class="s1">minor</span><span class="s2">=</span><span class="s1">col</span><span class="s2">)</span>


<span class="s4">def </span><span class="s1">isspmatrix_csr</span><span class="s2">(</span><span class="s1">x</span><span class="s2">):</span>
    <span class="s0">&quot;&quot;&quot;Is `x` of csr_matrix type? 
 
    Parameters 
    ---------- 
    x 
        object to check for being a csr matrix 
 
    Returns 
    ------- 
    bool 
        True if `x` is a csr matrix, False otherwise 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.sparse import csr_array, csr_matrix, coo_matrix, isspmatrix_csr 
    &gt;&gt;&gt; isspmatrix_csr(csr_matrix([[5]])) 
    True 
    &gt;&gt;&gt; isspmatrix_csr(csr_array([[5]])) 
    False 
    &gt;&gt;&gt; isspmatrix_csr(coo_matrix([[5]])) 
    False 
    &quot;&quot;&quot;</span>
    <span class="s4">return </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">csr_matrix</span><span class="s2">)</span>


<span class="s5"># This namespace class separates array from matrix with isinstance</span>
<span class="s4">class </span><span class="s1">csr_array</span><span class="s2">(</span><span class="s1">_csr_base</span><span class="s2">, </span><span class="s1">sparray</span><span class="s2">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Compressed Sparse Row array. 
 
    This can be instantiated in several ways: 
        csr_array(D) 
            where D is a 2-D ndarray 
 
        csr_array(S) 
            with another sparse array or matrix S (equivalent to S.tocsr()) 
 
        csr_array((M, N), [dtype]) 
            to construct an empty array with shape (M, N) 
            dtype is optional, defaulting to dtype='d'. 
 
        csr_array((data, (row_ind, col_ind)), [shape=(M, N)]) 
            where ``data``, ``row_ind`` and ``col_ind`` satisfy the 
            relationship ``a[row_ind[k], col_ind[k]] = data[k]``. 
 
        csr_array((data, indices, indptr), [shape=(M, N)]) 
            is the standard CSR representation where the column indices for 
            row i are stored in ``indices[indptr[i]:indptr[i+1]]`` and their 
            corresponding values are stored in ``data[indptr[i]:indptr[i+1]]``. 
            If the shape parameter is not supplied, the array dimensions 
            are inferred from the index arrays. 
 
    Attributes 
    ---------- 
    dtype : dtype 
        Data type of the array 
    shape : 2-tuple 
        Shape of the array 
    ndim : int 
        Number of dimensions (this is always 2) 
    nnz 
    size 
    data 
        CSR format data array of the array 
    indices 
        CSR format index array of the array 
    indptr 
        CSR format index pointer array of the array 
    has_sorted_indices 
    has_canonical_format 
    T 
 
    Notes 
    ----- 
 
    Sparse arrays can be used in arithmetic operations: they support 
    addition, subtraction, multiplication, division, and matrix power. 
 
    Advantages of the CSR format 
      - efficient arithmetic operations CSR + CSR, CSR * CSR, etc. 
      - efficient row slicing 
      - fast matrix vector products 
 
    Disadvantages of the CSR format 
      - slow column slicing operations (consider CSC) 
      - changes to the sparsity structure are expensive (consider LIL or DOK) 
 
    Canonical Format 
        - Within each row, indices are sorted by column. 
        - There are no duplicate entries. 
 
    Examples 
    -------- 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.sparse import csr_array 
    &gt;&gt;&gt; csr_array((3, 4), dtype=np.int8).toarray() 
    array([[0, 0, 0, 0], 
           [0, 0, 0, 0], 
           [0, 0, 0, 0]], dtype=int8) 
 
    &gt;&gt;&gt; row = np.array([0, 0, 1, 2, 2, 2]) 
    &gt;&gt;&gt; col = np.array([0, 2, 2, 0, 1, 2]) 
    &gt;&gt;&gt; data = np.array([1, 2, 3, 4, 5, 6]) 
    &gt;&gt;&gt; csr_array((data, (row, col)), shape=(3, 3)).toarray() 
    array([[1, 0, 2], 
           [0, 0, 3], 
           [4, 5, 6]]) 
 
    &gt;&gt;&gt; indptr = np.array([0, 2, 3, 6]) 
    &gt;&gt;&gt; indices = np.array([0, 2, 2, 0, 1, 2]) 
    &gt;&gt;&gt; data = np.array([1, 2, 3, 4, 5, 6]) 
    &gt;&gt;&gt; csr_array((data, indices, indptr), shape=(3, 3)).toarray() 
    array([[1, 0, 2], 
           [0, 0, 3], 
           [4, 5, 6]]) 
 
    Duplicate entries are summed together: 
 
    &gt;&gt;&gt; row = np.array([0, 1, 2, 0]) 
    &gt;&gt;&gt; col = np.array([0, 1, 1, 0]) 
    &gt;&gt;&gt; data = np.array([1, 2, 4, 8]) 
    &gt;&gt;&gt; csr_array((data, (row, col)), shape=(3, 3)).toarray() 
    array([[9, 0, 0], 
           [0, 2, 0], 
           [0, 4, 0]]) 
 
    As an example of how to construct a CSR array incrementally, 
    the following snippet builds a term-document array from texts: 
 
    &gt;&gt;&gt; docs = [[&quot;hello&quot;, &quot;world&quot;, &quot;hello&quot;], [&quot;goodbye&quot;, &quot;cruel&quot;, &quot;world&quot;]] 
    &gt;&gt;&gt; indptr = [0] 
    &gt;&gt;&gt; indices = [] 
    &gt;&gt;&gt; data = [] 
    &gt;&gt;&gt; vocabulary = {} 
    &gt;&gt;&gt; for d in docs: 
    ...     for term in d: 
    ...         index = vocabulary.setdefault(term, len(vocabulary)) 
    ...         indices.append(index) 
    ...         data.append(1) 
    ...     indptr.append(len(indices)) 
    ... 
    &gt;&gt;&gt; csr_array((data, indices, indptr), dtype=int).toarray() 
    array([[2, 1, 0, 0], 
           [0, 1, 1, 1]]) 
 
    &quot;&quot;&quot;</span>


<span class="s4">class </span><span class="s1">csr_matrix</span><span class="s2">(</span><span class="s1">spmatrix</span><span class="s2">, </span><span class="s1">_csr_base</span><span class="s2">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Compressed Sparse Row matrix. 
 
    This can be instantiated in several ways: 
        csr_matrix(D) 
            where D is a 2-D ndarray 
 
        csr_matrix(S) 
            with another sparse array or matrix S (equivalent to S.tocsr()) 
 
        csr_matrix((M, N), [dtype]) 
            to construct an empty matrix with shape (M, N) 
            dtype is optional, defaulting to dtype='d'. 
 
        csr_matrix((data, (row_ind, col_ind)), [shape=(M, N)]) 
            where ``data``, ``row_ind`` and ``col_ind`` satisfy the 
            relationship ``a[row_ind[k], col_ind[k]] = data[k]``. 
 
        csr_matrix((data, indices, indptr), [shape=(M, N)]) 
            is the standard CSR representation where the column indices for 
            row i are stored in ``indices[indptr[i]:indptr[i+1]]`` and their 
            corresponding values are stored in ``data[indptr[i]:indptr[i+1]]``. 
            If the shape parameter is not supplied, the matrix dimensions 
            are inferred from the index arrays. 
 
    Attributes 
    ---------- 
    dtype : dtype 
        Data type of the matrix 
    shape : 2-tuple 
        Shape of the matrix 
    ndim : int 
        Number of dimensions (this is always 2) 
    nnz 
    size 
    data 
        CSR format data array of the matrix 
    indices 
        CSR format index array of the matrix 
    indptr 
        CSR format index pointer array of the matrix 
    has_sorted_indices 
    has_canonical_format 
    T 
 
    Notes 
    ----- 
 
    Sparse matrices can be used in arithmetic operations: they support 
    addition, subtraction, multiplication, division, and matrix power. 
 
    Advantages of the CSR format 
      - efficient arithmetic operations CSR + CSR, CSR * CSR, etc. 
      - efficient row slicing 
      - fast matrix vector products 
 
    Disadvantages of the CSR format 
      - slow column slicing operations (consider CSC) 
      - changes to the sparsity structure are expensive (consider LIL or DOK) 
 
    Canonical Format 
        - Within each row, indices are sorted by column. 
        - There are no duplicate entries. 
 
    Examples 
    -------- 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.sparse import csr_matrix 
    &gt;&gt;&gt; csr_matrix((3, 4), dtype=np.int8).toarray() 
    array([[0, 0, 0, 0], 
           [0, 0, 0, 0], 
           [0, 0, 0, 0]], dtype=int8) 
 
    &gt;&gt;&gt; row = np.array([0, 0, 1, 2, 2, 2]) 
    &gt;&gt;&gt; col = np.array([0, 2, 2, 0, 1, 2]) 
    &gt;&gt;&gt; data = np.array([1, 2, 3, 4, 5, 6]) 
    &gt;&gt;&gt; csr_matrix((data, (row, col)), shape=(3, 3)).toarray() 
    array([[1, 0, 2], 
           [0, 0, 3], 
           [4, 5, 6]]) 
 
    &gt;&gt;&gt; indptr = np.array([0, 2, 3, 6]) 
    &gt;&gt;&gt; indices = np.array([0, 2, 2, 0, 1, 2]) 
    &gt;&gt;&gt; data = np.array([1, 2, 3, 4, 5, 6]) 
    &gt;&gt;&gt; csr_matrix((data, indices, indptr), shape=(3, 3)).toarray() 
    array([[1, 0, 2], 
           [0, 0, 3], 
           [4, 5, 6]]) 
 
    Duplicate entries are summed together: 
 
    &gt;&gt;&gt; row = np.array([0, 1, 2, 0]) 
    &gt;&gt;&gt; col = np.array([0, 1, 1, 0]) 
    &gt;&gt;&gt; data = np.array([1, 2, 4, 8]) 
    &gt;&gt;&gt; csr_matrix((data, (row, col)), shape=(3, 3)).toarray() 
    array([[9, 0, 0], 
           [0, 2, 0], 
           [0, 4, 0]]) 
 
    As an example of how to construct a CSR matrix incrementally, 
    the following snippet builds a term-document matrix from texts: 
 
    &gt;&gt;&gt; docs = [[&quot;hello&quot;, &quot;world&quot;, &quot;hello&quot;], [&quot;goodbye&quot;, &quot;cruel&quot;, &quot;world&quot;]] 
    &gt;&gt;&gt; indptr = [0] 
    &gt;&gt;&gt; indices = [] 
    &gt;&gt;&gt; data = [] 
    &gt;&gt;&gt; vocabulary = {} 
    &gt;&gt;&gt; for d in docs: 
    ...     for term in d: 
    ...         index = vocabulary.setdefault(term, len(vocabulary)) 
    ...         indices.append(index) 
    ...         data.append(1) 
    ...     indptr.append(len(indices)) 
    ... 
    &gt;&gt;&gt; csr_matrix((data, indices, indptr), dtype=int).toarray() 
    array([[2, 1, 0, 0], 
           [0, 1, 1, 1]]) 
 
    &quot;&quot;&quot;</span>

</pre>
</body>
</html>